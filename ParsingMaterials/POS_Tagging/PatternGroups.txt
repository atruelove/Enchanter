let Patterns
VB NNP VB . NNP ( NNP ) .
VB NNP VB NNP . VB JJ NNP NNP NNP .
VB NNP VB . NNP ( NNP , NNP ) .
VB NNP VB DT DT NN .
VB NNP VB CD .
VB NNP VB NNP ( NNP ) .
VB NNP VB . JJ ( DT NN ) .
VB NNP VB NNP .
VB NNP VB . NNP ( . NNP ( NNP , `` NN '' ) ) .
VB NNP VB . NNP ( DT NN ) .
VB NNP VB DT JJ JJ NN .
VB NNP VB DT JJ NN NN .
VB NNP VB DT NN IN NNP .

multiStepIf
IN NNP VBZ JJ , RB
IN NNP ( NNP ) VBZ JJ , RB
IN NNP VBZ RB JJ , RB
IN NNP VBZ VBN , RB


throw Exception
IN NNP ( NNP ) VBZ RB JJ , VB DT NN NN .
IN NNP ( NNP ) VBZ JJ , VB DT NN NN .
IN NNP VBZ JJ , VB DT NN NN .
IN NNP VBZ RB VB DT JJ NN NNP NNP NNP JJ NN , VB DT NN NN .

if Result
IN NNP VBZ JJ , NN JJ .
IN NNP VBZ JJ , VB NNS .
IN NNP ( NNP ) VBZ RB JJ , NN JJ .
IN NNP VBZ JJ , JJ NNP .
IN NNP VBZ DT NNP NN , VB . JJ ( NNP , NNP ) .

if...let
IN NNP VBZ RB JJ , VB JJ VB JJ .
IN NNP VBZ JJ , VB NNP VB VBN .
RB IN NNP VBZ DT JJ NN NNP NNP NNP JJ NN , VB NNP VB `` NN '' .

if..let...else..let
IN NNP VBZ RB JJ , VB NNP VB JJ ( NNP ) : RB , VB NNP VB . NNP ( NNP ) .
IN NNP CC NN : CD , VB NNP VB VBN ( ( NNP NNP NNP ) , CD ) : JJ VB NNP VB VBN ( NNP , NNP ) .
IN NNP VBZ JJ , VB NNP VB NNP : JJ VB NNP VB . NNP ( NNP ) .

foreach
IN DT NN NNP IN NNP , VBP
IN DT NN NNP IN NNP IN NN NN , VBP
IN DT NNP IN NNP , VBP
IN DT NN ( JJ NNP NNP NNP NNP , NNP NNP NNP NNP NNP ) NNP WDT VBZ DT NN IN NNS , VBP
IN DT NN NNP IN DT NNS IN NNP , VBP
IN DT NNP WDT VBZ DT NN IN NNS , VBP
IN DT NN NN NNP IN NNP , VBP
IN DT NNP IN NNP , IN JJ NN NN , VBP (*0*for each d in vardeclarations, in reverse list order, do)
IN DT NNP WDT VBZ DT NN IN NNP , VBP
IN DT NNP IN NNP IN NN NN , VBP (*0*for each name in methodnames in list order, do)
IN DT NN NNP VBG IN CD JJ IN NNP CC NN : NNP , IN VBG NN , VBP

VB NNP VB DT RB VBN NN IN DT JJ NN IN DT NN IN NNP . (*0*let obj be a newly created object with an internal slot for each name in internalslotslist.)

repeat
NN , IN NNP CC NN : NNP
NN , IN NNP VBZ RB JJ
NN , IN NNP CC NN : NNP ,
NN , IN NNP CC NN : CD

increment
NN NNP IN CD .
NN NNP . (mostly return, but some increment)
NN VBN IN CD .
JJ NNP CC NNP DT IN CD . (increment 2 variables by 1, "increment toindex and fromindex each by 1.")
NN NN IN CD .
JJ NNP IN CD . (*1*increment bytelocation by 1.)

assert
NN : NNP ( NNP ) VBZ JJ .
NN : NNP ( NNP ) VBZ NN .
NN : NN VBZ DT NN NN .
NN : NNP ( NNP ) VBZ VBG .
NN : NNP VBZ DT JJ NN NN .
NN : NNP VBZ JJ .
NN : NNP VBZ CD .

perform
NN . NNP ( NNP , NNP ) . 
NN NNP ( NNP ) .
NN . NNP ( NNP , NNP , NNP ) .
NN . NNP ( NNP ) .
NN NNP ( NNP , NNP ) .
NN . NNP ( NNP , NNP , NNP , JJ ) . (only perform)
NN . NNP ( NNP , `` NN '' , NNP , JJ ) . (only perform)
NN . NNP ( NNP , . NNP ( NNP ) , NNP ) . (only perform)
NN . NNP ( NNP . VB JJ NNP NNP NNP , VBD , NNP NNP NNP ) . (only perform)
NN . NNP ( NNP , RB ) . (only perform)

return only
NN NNP .
NN JJ .
NN NNP . VB JJ NNP NNP NNP .
NN VBD .
NN NNP ( JJ ) .