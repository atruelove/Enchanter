ID= 6.2.3.4
Summary= UpdateEmpty ( completionRecord, value )
*0*assert: if VARcompletionrecord.[[TYPE]] is either return or throw, then VARcompletionrecord.[[VALUE]] is not empty. 
*0*(S assert/NN :/: if/IN (Chunk VARcompletionrecord/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ either/DT return/NN or/CC throw/NN ,/, (Chunk then/RB VARcompletionrecord/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB empty/JJ ./.)
*0*if VARcompletionrecord.[[VALUE]] is not empty, return FUNCcompletion(VARcompletionrecord). 
*0*(S if/IN (Chunk VARcompletionrecord/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB empty/JJ ,/, return/JJ (Chunk FUNCcompletion/NNP) (/( (Chunk VARcompletionrecord/NNP) )/) ./.)
*0*return completion { [[TYPE]]: VARcompletionrecord.[[TYPE]], [[VALUE]]: VARvalue, [[TARGET]]: VARcompletionrecord.[[TARGET]] }.     
*0*(S return/NN completion/NN {/( [/JJ (Chunk [/NNP) (Chunk TYPE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARcompletionrecord/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARvalue/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk TARGET/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARcompletionrecord/NNP) ./. [/VB [/JJ (Chunk TARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) }/) ./.)
ID= 6.2.4.1
Summary= GetBase ( V )
*0*assert: FUNCtype(VARv) is reference. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ reference/NN ./.)
*0*return the base value component of VARv.     
*0*(S return/VB the/DT base/NN value/NN component/NN of/IN (Chunk VARv/NNP) ./.)
ID= 6.2.4.2
Summary= GetReferencedName ( V )
*0*assert: FUNCtype(VARv) is reference. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ reference/NN ./.)
*0*return the referenced name component of VARv.     
*0*(S return/VB the/DT referenced/JJ name/NN component/NN of/IN (Chunk VARv/NNP) ./.)
ID= 6.2.4.3
Summary= IsStrictReference ( V )
*0*assert: FUNCtype(VARv) is reference. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ reference/NN ./.)
*0*return the strict reference flag of VARv.     
*0*(S return/VB the/DT strict/JJ reference/NN flag/NN of/IN (Chunk VARv/NNP) ./.)
ID= 6.2.4.4
Summary= HasPrimitiveBase ( V )
*0*assert: FUNCtype(VARv) is reference. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ reference/NN ./.)
*0*if FUNCtype(VARv's base value component) is boolean, string, symbol, or number, return true; otherwise return false.     
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) 's/POS base/NN value/NN component/NN )/) is/VBZ boolean/JJ ,/, string/NN ,/, symbol/NN ,/, or/CC number/NN ,/, return/VBP true/JJ ;/: otherwise/RB return/NN false/JJ ./.)
ID= 6.2.4.5
Summary= IsPropertyReference ( V )
*0*assert: FUNCtype(VARv) is reference. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ reference/NN ./.)
*0*if either the base value component of VARv is an object or FUNChasprimitivebase(VARv) is true, return true; otherwise return false.     
*0*(S if/IN either/CC the/DT base/NN value/NN component/NN of/IN (Chunk VARv/NNP) is/VBZ an/DT object/NN or/CC (Chunk FUNChasprimitivebase/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ true/JJ ,/, return/VB true/JJ ;/: otherwise/RB return/NN false/JJ ./.)
ID= 6.2.4.6
Summary= IsUnresolvableReference ( V )
*0*assert: FUNCtype(VARv) is reference. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ reference/NN ./.)
*0*if the base value component of VARv is undefined, return true; otherwise return false.     
*0*(S if/IN the/DT base/NN value/NN component/NN of/IN (Chunk VARv/NNP) is/VBZ undefined/JJ ,/, return/VB true/JJ ;/: otherwise/RB return/NN false/JJ ./.)
ID= 6.2.4.7
Summary= IsSuperReference ( V )
*0*assert: FUNCtype(VARv) is reference. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ reference/NN ./.)
*0*if VARv has a thisvalue component, return true; otherwise return false.     
*0*(S if/IN (Chunk VARv/NNP) has/VBZ a/DT thisvalue/JJ component/NN ,/, return/NN true/JJ ;/: otherwise/RB return/NN false/JJ ./.)
ID= 6.2.4.8
Summary= GetValue ( V )
*0*FUNCreturnifabrupt(VARv). 
*0*(S (Chunk FUNCreturnifabrupt/NNP) (/( (Chunk VARv/NNP) )/) ./.)
*0*if FUNCtype(VARv) is not reference, return VARv. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ not/RB reference/JJ ,/, (Chunk return/VB VARv/NNP) ./.)
*0*let VARbase be FUNCgetbase(VARv). 
*0*(S (Chunk let/VB VARbase/NNP) (Chunk be/VB FUNCgetbase/NNP) (/( (Chunk VARv/NNP) )/) ./.)
*0*if FUNCisunresolvablereference(VARv) is true, throw a referenceerror exception. 
*0*(S if/IN (Chunk FUNCisunresolvablereference/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT referenceerror/NN exception/NN ./.)
*0*if FUNCispropertyreference(VARv) is true, then
*0*(S if/IN (Chunk FUNCispropertyreference/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*if FUNChasprimitivebase(VARv) is true, then
*1*(S if/IN (Chunk FUNChasprimitivebase/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*assert: in this case, VARbase will never be undefined or null. 
*2*(S assert/NN :/: in/IN this/DT case/NN ,/, (Chunk VARbase/NNP) will/MD never/RB be/VB undefined/JJ or/CC null/JJ ./.)
*2*set VARbase to ! FUNCtoobject(VARbase). 
*2*(S (Chunk set/VBN VARbase/NNP) to/TO !/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARbase/NNP) )/) ./.)
*1*return ? VARbase.[[GET]](FUNCgetreferencedname(VARv), FUNCgetthisvalue(VARv)). 
*1*(S return/NN ?/. (Chunk VARbase/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk FUNCgetreferencedname/NNP) (/( (Chunk VARv/NNP) )/) ,/, (Chunk FUNCgetthisvalue/NNP) (/( (Chunk VARv/NNP) )/) )/) ./.)
*0*else VARbase must be an environment record,
*0*(S else/JJ (Chunk VARbase/NNP) must/MD be/VB an/DT environment/NN record/NN ,/,)
*1*return ? VARbase.getbindingvalue(FUNCgetreferencedname(VARv), FUNCisstrictreference(VARv)) (see 8.1.1).     
*1*(S return/NN ?/. (Chunk VARbase.getbindingvalue/NNP) (/( (Chunk FUNCgetreferencedname/NNP) (/( (Chunk VARv/NNP) )/) ,/, (Chunk FUNCisstrictreference/NNP) (/( (Chunk VARv/NNP) )/) )/) (/( see/VB 8.1.1/CD )/) ./.)
ID= 6.2.4.9
Summary= PutValue ( V, W )
*0*FUNCreturnifabrupt(VARv). 
*0*(S (Chunk FUNCreturnifabrupt/NNP) (/( (Chunk VARv/NNP) )/) ./.)
*0*FUNCreturnifabrupt(VARw). 
*0*(S (Chunk FUNCreturnifabrupt/NNP) (/( (Chunk VARw/NNP) )/) ./.)
*0*if FUNCtype(VARv) is not reference, throw a referenceerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ not/RB reference/NN ,/, throw/VB a/DT referenceerror/NN exception/NN ./.)
*0*let VARbase be FUNCgetbase(VARv). 
*0*(S (Chunk let/VB VARbase/NNP) (Chunk be/VB FUNCgetbase/NNP) (/( (Chunk VARv/NNP) )/) ./.)
*0*if FUNCisunresolvablereference(VARv) is true, then
*0*(S if/IN (Chunk FUNCisunresolvablereference/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*if FUNCisstrictreference(VARv) is true, then
*1*(S if/IN (Chunk FUNCisstrictreference/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*throw a referenceerror exception. 
*2*(S throw/VB a/DT referenceerror/NN exception/NN ./.)
*1*let VARglobalobj be FUNCgetglobalobject(). 
*1*(S (Chunk let/VB VARglobalobj/NNP) (Chunk be/VB FUNCgetglobalobject/NNP) (/( )/) ./.)
*1*return ? FUNCset(VARglobalobj, FUNCgetreferencedname(VARv), VARw, false). 
*1*(S return/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARglobalobj/NNP) ,/, (Chunk FUNCgetreferencedname/NNP) (/( (Chunk VARv/NNP) )/) ,/, (Chunk VARw/NNP) ,/, false/RB )/) ./.)
*0*else if FUNCispropertyreference(VARv) is true, then
*0*(S else/RB if/IN (Chunk FUNCispropertyreference/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*if FUNChasprimitivebase(VARv) is true, then
*1*(S if/IN (Chunk FUNChasprimitivebase/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*assert: in this case, VARbase will never be undefined or null. 
*2*(S assert/NN :/: in/IN this/DT case/NN ,/, (Chunk VARbase/NNP) will/MD never/RB be/VB undefined/JJ or/CC null/JJ ./.)
*2*set VARbase to ! FUNCtoobject(VARbase). 
*2*(S (Chunk set/VBN VARbase/NNP) to/TO !/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARbase/NNP) )/) ./.)
*1*let VARsucceeded be ? VARbase.[[SET]](FUNCgetreferencedname(VARv), VARw, FUNCgetthisvalue(VARv)). 
*1*(S (Chunk let/VB VARsucceeded/NNP) be/VB ?/. (Chunk VARbase/NNP) ./. [/NN [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk FUNCgetreferencedname/NNP) (/( (Chunk VARv/NNP) )/) ,/, (Chunk VARw/NNP) ,/, (Chunk FUNCgetthisvalue/NNP) (/( (Chunk VARv/NNP) )/) )/) ./.)
*1*if VARsucceeded is false and FUNCisstrictreference(VARv) is true, throw a typeerror exception. 
*1*(S if/IN VARsucceeded/VBN is/VBZ false/JJ and/CC (Chunk FUNCisstrictreference/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*return. 
*1*(S return/NN ./.)
*0*else VARbase must be an environment record,
*0*(S else/JJ (Chunk VARbase/NNP) must/MD be/VB an/DT environment/NN record/NN ,/,)
*1*return ? VARbase.setmutablebinding(FUNCgetreferencedname(VARv), VARw, FUNCisstrictreference(VARv)) (see 8.1.1).     
*1*(S return/NN ?/. (Chunk VARbase.setmutablebinding/NNP) (/( (Chunk FUNCgetreferencedname/NNP) (/( (Chunk VARv/NNP) )/) ,/, (Chunk VARw/NNP) ,/, (Chunk FUNCisstrictreference/NNP) (/( (Chunk VARv/NNP) )/) )/) (/( see/VB 8.1.1/CD )/) ./.)
ID= 6.2.4.10
Summary= GetThisValue ( V )
*0*assert: FUNCispropertyreference(VARv) is true. 
*0*(S assert/NN :/: FUNCispropertyreference/NN (/( (Chunk VARv/NNP) )/) is/VBZ true/JJ ./.)
*0*if FUNCissuperreference(VARv) is true, then
*0*(S if/IN (Chunk FUNCissuperreference/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*return the value of the thisvalue component of the reference VARv. 
*1*(S return/VB the/DT value/NN of/IN the/DT thisvalue/JJ component/NN of/IN the/DT reference/NN (Chunk VARv/NNP) ./.)
*0*return FUNCgetbase(VARv).     
*0*(S return/NN (Chunk FUNCgetbase/NNP) (/( (Chunk VARv/NNP) )/) ./.)
ID= 6.2.4.11
Summary= InitializeReferencedBinding ( V, W )
*0*FUNCreturnifabrupt(VARv). 
*0*(S (Chunk FUNCreturnifabrupt/NNP) (/( (Chunk VARv/NNP) )/) ./.)
*0*FUNCreturnifabrupt(VARw). 
*0*(S (Chunk FUNCreturnifabrupt/NNP) (/( (Chunk VARw/NNP) )/) ./.)
*0*assert: FUNCtype(VARv) is reference. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ reference/NN ./.)
*0*assert: FUNCisunresolvablereference(VARv) is false. 
*0*(S assert/NN :/: FUNCisunresolvablereference/NN (/( (Chunk VARv/NNP) )/) is/VBZ false/JJ ./.)
*0*let VARbase be FUNCgetbase(VARv). 
*0*(S (Chunk let/VB VARbase/NNP) (Chunk be/VB FUNCgetbase/NNP) (/( (Chunk VARv/NNP) )/) ./.)
*0*assert: VARbase is an environment record. 
*0*(S assert/NN :/: (Chunk VARbase/NNP) is/VBZ an/DT environment/NN record/NN ./.)
*0*return VARbase.initializebinding(FUNCgetreferencedname(VARv), VARw).     
*0*(S return/NN (Chunk VARbase.initializebinding/NNP) (/( (Chunk FUNCgetreferencedname/NNP) (/( (Chunk VARv/NNP) )/) ,/, (Chunk VARw/NNP) )/) ./.)
ID= 6.2.5.1
Summary= IsAccessorDescriptor ( Desc )
*0*if VARdesc is undefined, return false. 
*0*(S if/IN (Chunk VARdesc/NNP) is/VBZ undefined/JJ ,/, return/NN false/JJ ./.)
*0*if both VARdesc.[[GET]] and VARdesc.[[SET]] are absent, return false. 
*0*(S if/IN both/DT (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) and/CC (Chunk VARdesc/NNP) ./. [/NN [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) are/VBP absent/JJ ,/, return/NN false/JJ ./.)
*0*return true.     
*0*(S return/NN true/JJ ./.)
ID= 6.2.5.2
Summary= IsDataDescriptor ( Desc )
*0*if VARdesc is undefined, return false. 
*0*(S if/IN (Chunk VARdesc/NNP) is/VBZ undefined/JJ ,/, return/NN false/JJ ./.)
*0*if both VARdesc.[[VALUE]] and VARdesc.[[WRITABLE]] are absent, return false. 
*0*(S if/IN both/DT (Chunk VARdesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) and/CC (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) ]/NN ]/NN are/VBP absent/JJ ,/, return/NN false/JJ ./.)
*0*return true.     
*0*(S return/NN true/JJ ./.)
ID= 6.2.5.3
Summary= IsGenericDescriptor ( Desc )
*0*if VARdesc is undefined, return false. 
*0*(S if/IN (Chunk VARdesc/NNP) is/VBZ undefined/JJ ,/, return/NN false/JJ ./.)
*0*if FUNCisaccessordescriptor(VARdesc) and FUNCisdatadescriptor(VARdesc) are both false, return true. 
*0*(S if/IN (Chunk FUNCisaccessordescriptor/NNP) (/( (Chunk VARdesc/NNP) )/) and/CC (Chunk FUNCisdatadescriptor/NNP) (/( (Chunk VARdesc/NNP) )/) are/VBP both/DT false/JJ ,/, return/VB true/JJ ./.)
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 6.2.5.4
Summary= FromPropertyDescriptor ( Desc )
*0*if VARdesc is undefined, return undefined. 
*0*(S if/IN (Chunk VARdesc/NNP) is/VBZ undefined/JJ ,/, return/NN undefined/VBD ./.)
*0*let VARobj be FUNCobjectcreate(%objectprototype%). 
*0*(S (Chunk let/VB VARobj/NNP) (Chunk be/VB FUNCobjectcreate/NNP) (/( %/NN objectprototype/IN %/NN )/) ./.)
*0*assert: VARobj is an extensible ordinary object with no own properties. 
*0*(S assert/NN :/: (Chunk VARobj/NNP) is/VBZ an/DT extensible/JJ ordinary/JJ object/NN with/IN no/DT own/JJ properties/NNS ./.)
*0*if VARdesc has a [[VALUE]] field, then
*0*(S if/IN (Chunk VARdesc/NNP) has/VBZ a/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN ,/, then/RB)
*1*perform FUNCcreatedataproperty(VARobj, "value", VARdesc.[[VALUE]]). 
*1*(S perform/NN (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` value/NN ''/'' ,/, (Chunk VARdesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*0*if VARdesc has a [[WRITABLE]] field, then
*0*(S if/IN (Chunk VARdesc/NNP) has/VBZ a/DT [/JJ [/NN (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN ,/, then/RB)
*1*perform FUNCcreatedataproperty(VARobj, "writable", VARdesc.[[WRITABLE]]). 
*1*(S perform/NN (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` writable/JJ ''/'' ,/, (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*0*if VARdesc has a [[GET]] field, then
*0*(S if/IN (Chunk VARdesc/NNP) has/VBZ a/DT [/NN (Chunk [/NNP) (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN ,/, then/RB)
*1*perform FUNCcreatedataproperty(VARobj, "get", VARdesc.[[GET]]). 
*1*(S perform/NN (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` get/NN ''/'' ,/, (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*0*if VARdesc has a [[SET]] field, then
*0*(S if/IN (Chunk VARdesc/NNP) has/VBZ a/DT [/JJ [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN ,/, then/RB)
*1*perform FUNCcreatedataproperty(VARobj, "set", VARdesc.[[SET]]). 
*1*(S perform/NN (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` set/NN ''/'' ,/, (Chunk VARdesc/NNP) ./. [/NN [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*0*if VARdesc has an [[ENUMERABLE]] field, then
*0*(S if/IN (Chunk VARdesc/NNP) has/VBZ an/DT [/JJ [/NN (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN ,/, then/RB)
*1*perform FUNCcreatedataproperty(VARobj, "enumerable", VARdesc.[[ENUMERABLE]]). 
*1*(S perform/NN (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` enumerable/JJ ''/'' ,/, (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*0*if VARdesc has a [[CONFIGURABLE]] field, then
*0*(S if/IN (Chunk VARdesc/NNP) has/VBZ a/DT [/JJ [/NN (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN ,/, then/RB)
*1*perform FUNCcreatedataproperty(VARobj, "configurable", VARdesc.[[CONFIGURABLE]]). 
*1*(S perform/NN (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` configurable/JJ ''/'' ,/, (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*0*assert: all of the above createdataproperty operations return true. 
*0*(S assert/NN :/: all/DT of/IN the/DT above/JJ createdataproperty/NN operations/NNS return/VBP true/JJ ./.)
*0*return VARobj.     
*0*(S return/NN (Chunk VARobj/NNP) ./.)
ID= 6.2.5.5
Summary= ToPropertyDescriptor ( Obj )
*0*if FUNCtype(VARobj) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARobj/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARdesc be a new property descriptor that initially has no fields. 
*0*(S (Chunk let/VB VARdesc/NNP) be/VB a/DT new/JJ property/NN descriptor/NN that/WDT initially/RB has/VBZ no/DT fields/NNS ./.)
*0*let VARhasenumerable be ? FUNChasproperty(VARobj, "enumerable"). 
*0*(S let/VB VARhasenumerable/JJ be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` enumerable/JJ ''/'' )/) ./.)
*0*if VARhasenumerable is true, then
*0*(S if/IN (Chunk VARhasenumerable/NNP) is/VBZ true/JJ ,/, then/RB)
*1*let VARenum be FUNCtoboolean(? FUNCget(VARobj, "enumerable")). 
*1*(S (Chunk let/VB VARenum/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` enumerable/JJ ''/'' )/) )/) ./.)
*1*set VARdesc.[[ENUMERABLE]] to VARenum. 
*1*(S (Chunk set/VBN VARdesc/NNP) ./. [/VB [/JJ (Chunk ENUMERABLE/NNP) ]/NN ]/NN to/TO (Chunk VARenum/NNP) ./.)
*0*let VARhasconfigurable be ? FUNChasproperty(VARobj, "configurable"). 
*0*(S let/VB VARhasconfigurable/JJ be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` configurable/JJ ''/'' )/) ./.)
*0*if VARhasconfigurable is true, then
*0*(S if/IN (Chunk VARhasconfigurable/NNP) is/VBZ true/JJ ,/, then/RB)
*1*let VARconf be FUNCtoboolean(? FUNCget(VARobj, "configurable")). 
*1*(S (Chunk let/VB VARconf/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` configurable/JJ ''/'' )/) )/) ./.)
*1*set VARdesc.[[CONFIGURABLE]] to VARconf. 
*1*(S (Chunk set/VBN VARdesc/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) ]/NN ]/NN to/TO (Chunk VARconf/NNP) ./.)
*0*let VARhasvalue be ? FUNChasproperty(VARobj, "value"). 
*0*(S (Chunk let/VB VARhasvalue/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` value/NN ''/'' )/) ./.)
*0*if VARhasvalue is true, then
*0*(S if/IN (Chunk VARhasvalue/NNP) is/VBZ true/JJ ,/, then/RB)
*1*let VARvalue be ? FUNCget(VARobj, "value"). 
*1*(S (Chunk let/VB VARvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` value/NN ''/'' )/) ./.)
*1*set VARdesc.[[VALUE]] to VARvalue. 
*1*(S (Chunk set/VBN VARdesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARvalue/NNP) ./.)
*0*let VARhaswritable be ? FUNChasproperty(VARobj, "writable"). 
*0*(S let/VB VARhaswritable/JJ be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` writable/JJ ''/'' )/) ./.)
*0*if VARhaswritable is true, then
*0*(S if/IN (Chunk VARhaswritable/NNP) is/VBZ true/JJ ,/, then/RB)
*1*let VARwritable be FUNCtoboolean(? FUNCget(VARobj, "writable")). 
*1*(S let/VB VARwritable/JJ (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` writable/JJ ''/'' )/) )/) ./.)
*1*set VARdesc.[[WRITABLE]] to VARwritable. 
*1*(S (Chunk set/VBN VARdesc/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) ]/NN ]/NN to/TO (Chunk VARwritable/NNP) ./.)
*0*let VARhasget be ? FUNChasproperty(VARobj, "get"). 
*0*(S (Chunk let/VB VARhasget/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` get/VB ''/'' )/) ./.)
*0*if VARhasget is true, then
*0*(S if/IN (Chunk VARhasget/NNP) is/VBZ true/JJ ,/, then/RB)
*1*let VARgetter be ? FUNCget(VARobj, "get"). 
*1*(S (Chunk let/VB VARgetter/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` get/VB ''/'' )/) ./.)
*1*if FUNCiscallable(VARgetter) is false and VARgetter is not undefined, throw a typeerror exception. 
*1*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARgetter/NNP) )/) is/VBZ false/JJ and/CC (Chunk VARgetter/NNP) is/VBZ not/RB undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*set VARdesc.[[GET]] to VARgetter. 
*1*(S (Chunk set/VBN VARdesc/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARgetter/NNP) ./.)
*0*let VARhasset be ? FUNChasproperty(VARobj, "set"). 
*0*(S (Chunk let/VB VARhasset/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` set/VB ''/'' )/) ./.)
*0*if VARhasset is true, then
*0*(S if/IN (Chunk VARhasset/NNP) is/VBZ true/JJ ,/, then/RB)
*1*let VARsetter be ? FUNCget(VARobj, "set"). 
*1*(S (Chunk let/VB VARsetter/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` set/VB ''/'' )/) ./.)
*1*if FUNCiscallable(VARsetter) is false and VARsetter is not undefined, throw a typeerror exception. 
*1*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARsetter/NNP) )/) is/VBZ false/JJ and/CC (Chunk VARsetter/NNP) is/VBZ not/RB undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*set VARdesc.[[SET]] to VARsetter. 
*1*(S (Chunk set/VBN VARdesc/NNP) ./. [/NN [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARsetter/NNP) ./.)
*0*if VARdesc.[[GET]] is present or VARdesc.[[SET]] is present, then
*0*(S if/IN (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ present/JJ or/CC (Chunk VARdesc/NNP) ./. [/NN [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ present/JJ ,/, then/RB)
*1*if VARdesc.[[VALUE]] is present or VARdesc.[[WRITABLE]] is present, throw a typeerror exception. 
*1*(S if/IN (Chunk VARdesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ present/JJ or/CC (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ present/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARdesc.     
*0*(S return/NN (Chunk VARdesc/NNP) ./.)
ID= 6.2.5.6
Summary= CompletePropertyDescriptor ( Desc )
*0*assert: VARdesc is a property descriptor. 
*0*(S assert/NN :/: (Chunk VARdesc/NNP) is/VBZ a/DT property/NN descriptor/NN ./.)
*0*let VARlike be record { [[VALUE]]: undefined, [[WRITABLE]]: false, [[GET]]: undefined, [[SET]]: undefined, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }. 
*0*(S (Chunk let/VB VARlike/NNP) be/VB record/JJ {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: undefined/JJ ,/, [/JJ (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk GET/NNP) (Chunk ]/NNP) ]/NN :/: undefined/JJ ,/, [/JJ [/NN (Chunk SET/NNP) (Chunk ]/NNP) ]/NN :/: undefined/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) ./.)
*0*if FUNCisgenericdescriptor(VARdesc) is true or FUNCisdatadescriptor(VARdesc) is true, then
*0*(S if/IN (Chunk FUNCisgenericdescriptor/NNP) (/( (Chunk VARdesc/NNP) )/) is/VBZ true/JJ or/CC (Chunk FUNCisdatadescriptor/NNP) (/( (Chunk VARdesc/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*if VARdesc does not have a [[VALUE]] field, set VARdesc.[[VALUE]] to VARlike.[[VALUE]]. 
*1*(S if/IN (Chunk VARdesc/NNP) does/VBZ not/RB have/VB a/DT [/NN (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN ,/, (Chunk set/VBN VARdesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARlike/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*if VARdesc does not have a [[WRITABLE]] field, set VARdesc.[[WRITABLE]] to VARlike.[[WRITABLE]]. 
*1*(S if/IN (Chunk VARdesc/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN ,/, (Chunk set/VBN VARdesc/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) ]/NN ]/NN to/TO (Chunk VARlike/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*if VARdesc does not have a [[GET]] field, set VARdesc.[[GET]] to VARlike.[[GET]]. 
*1*(S if/IN (Chunk VARdesc/NNP) does/VBZ not/RB have/VB a/DT [/NN (Chunk [/NNP) (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN ,/, (Chunk set/VBN VARdesc/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARlike/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*if VARdesc does not have a [[SET]] field, set VARdesc.[[SET]] to VARlike.[[SET]]. 
*1*(S if/IN (Chunk VARdesc/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN ,/, (Chunk set/VBN VARdesc/NNP) ./. [/NN [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARlike/NNP) ./. [/NN [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARdesc does not have an [[ENUMERABLE]] field, set VARdesc.[[ENUMERABLE]] to VARlike.[[ENUMERABLE]]. 
*0*(S if/IN (Chunk VARdesc/NNP) does/VBZ not/RB have/VB an/DT [/JJ [/NN (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN ,/, (Chunk set/VBN VARdesc/NNP) ./. [/VB [/JJ (Chunk ENUMERABLE/NNP) ]/NN ]/NN to/TO (Chunk VARlike/NNP) ./. [/VB [/JJ (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARdesc does not have a [[CONFIGURABLE]] field, set VARdesc.[[CONFIGURABLE]] to VARlike.[[CONFIGURABLE]]. 
*0*(S if/IN (Chunk VARdesc/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN ,/, (Chunk set/VBN VARdesc/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) ]/NN ]/NN to/TO (Chunk VARlike/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*return VARdesc.     
*0*(S return/NN (Chunk VARdesc/NNP) ./.)
ID= 6.2.7.1
Summary= CreateByteDataBlock ( size )
*0*assert: VARsize≥0. 
*0*(S assert/NN :/: (Chunk VARsize≥0/NNP) ./.)
*0*let VARdb be a new data block value consisting of VARsize bytes. if it is impossible to create such a data block, throw a rangeerror exception. 
*0*(S (Chunk let/VB VARdb/NNP) be/VB a/DT new/JJ data/NN block/NN value/NN consisting/VBG of/IN (Chunk VARsize/NNP) bytes/NNS ./. if/IN it/PRP is/VBZ impossible/JJ to/TO create/VB such/JJ a/DT data/NN block/NN ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*set all of the bytes of VARdb to 0. 
*0*(S set/VBN all/DT of/IN the/DT bytes/NNS of/IN (Chunk VARdb/NNP) to/TO 0/CD ./.)
*0*return VARdb.     
*0*(S return/NN (Chunk VARdb/NNP) ./.)
ID= 6.2.7.2
Summary= CreateSharedByteDataBlock ( size )
*0*assert: VARsize≥0. 
*0*(S assert/NN :/: (Chunk VARsize≥0/NNP) ./.)
*0*let VARdb be a new shared data block value consisting of VARsize bytes. if it is impossible to create such a shared data block, throw a rangeerror exception. 
*0*(S (Chunk let/VB VARdb/NNP) be/VB a/DT new/JJ shared/VBN data/NNS block/NN value/NN consisting/VBG of/IN (Chunk VARsize/NNP) bytes/NNS ./. if/IN it/PRP is/VBZ impossible/JJ to/TO create/VB such/JJ a/DT shared/VBN data/NN block/NN ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*let VARexecution be the [[CANDIDATEEXECUTION]] field of the surrounding agent's agent record. 
*0*(S (Chunk let/VB VARexecution/NNP) be/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk CANDIDATEEXECUTION/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN of/IN the/DT surrounding/VBG agent/NN 's/POS agent/NN record/NN ./.)
*0*let VAReventlist be the [[EVENTLIST]] field of the element in VARexecution.[[EVENTLISTS]] whose [[AGENTSIGNIFIER]] is FUNCagentsignifier(). 
*0*(S (Chunk let/VB VAReventlist/NNP) be/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk EVENTLIST/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN of/IN the/DT element/NN in/IN (Chunk VARexecution/NNP) ./. [/VB [/JJ (Chunk EVENTLISTS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) whose/WP$ (Chunk [/NNP) (Chunk [/NNP) (Chunk AGENTSIGNIFIER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk is/VBZ FUNCagentsignifier/NNP) (/( )/) ./.)
*0*let VARzero be « 0 ». 
*0*(S (Chunk let/VB VARzero/NNP) be/VB «/JJ 0/CD »/NN ./.)
*0*for each index VARi of VARdb, do
*0*(S for/IN each/DT index/NN (Chunk VARi/NNP) of/IN (Chunk VARdb/NNP) ,/, do/VBP)
*1*append writesharedmemory { [[ORDER]]: "init", [[NOTEAR]]: true, [[BLOCK]]: VARdb, [[BYTEINDEX]]: VARi, [[ELEMENTSIZE]]: 1, [[PAYLOAD]]: VARzero } to VAReventlist. 
*1*(S append/RB writesharedmemory/JJ {/( [/JJ [/NN (Chunk ORDER/NNP) (Chunk ]/NNP) ]/NN :/: ``/`` init/NN ''/'' ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk NOTEAR/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk BLOCK/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARdb/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk BYTEINDEX/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARi/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ELEMENTSIZE/NNP) (Chunk ]/NNP) ]/NN :/: 1/CD ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk PAYLOAD/NNP) (Chunk ]/NNP) ]/NN :/: VARzero/NN }/) to/TO (Chunk VAReventlist/NNP) ./.)
*0*return VARdb.     
*0*(S return/NN (Chunk VARdb/NNP) ./.)
ID= 6.2.7.3
Summary= CopyDataBlockBytes ( toBlock, toIndex, fromBlock, fromIndex, count )
*0*assert: VARfromblock and VARtoblock are distinct data block or shared data block values. 
*0*(S assert/NN :/: (Chunk VARfromblock/NNP) and/CC (Chunk VARtoblock/NNP) are/VBP distinct/JJ data/NNS block/NN or/CC shared/VBN data/NNS block/NN values/NNS ./.)
*0*assert: VARfromindex, VARtoindex, and VARcount are integer values ≥ 0. 
*0*(S assert/NN :/: VARfromindex/NN ,/, (Chunk VARtoindex/NNP) ,/, and/CC (Chunk VARcount/NNP) are/VBP integer/JJ values/NNS ≥/VBP 0/CD ./.)
*0*let VARfromsize be the number of bytes in VARfromblock. 
*0*(S (Chunk let/VB VARfromsize/NNP) be/VB the/DT number/NN of/IN bytes/NNS in/IN (Chunk VARfromblock/NNP) ./.)
*0*assert: VARfromindex+VARcount ≤ VARfromsize. 
*0*(S assert/NN :/: (Chunk VARfromindex+VARcount/NNP) (Chunk ≤/NNP) (Chunk VARfromsize/NNP) ./.)
*0*let VARtosize be the number of bytes in VARtoblock. 
*0*(S (Chunk let/VB VARtosize/NNP) be/VB the/DT number/NN of/IN bytes/NNS in/IN (Chunk VARtoblock/NNP) ./.)
*0*assert: VARtoindex+VARcount ≤ VARtosize. 
*0*(S assert/NN :/: (Chunk VARtoindex+VARcount/NNP) (Chunk ≤/NNP) (Chunk VARtosize/NNP) ./.)
*0*repeat, while VARcount&gt;0
*0*(S repeat/NN ,/, while/IN (Chunk VARcount/NNP) &/CC gt/NN ;/: 0/CD)
*1*if VARfromblock is a shared data block, then
*1*(S if/IN (Chunk VARfromblock/NNP) is/VBZ a/DT shared/VBN data/NN block/NN ,/, then/RB)
*2*let VARexecution be the [[CANDIDATEEXECUTION]] field of the surrounding agent's agent record. 
*2*(S (Chunk let/VB VARexecution/NNP) be/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk CANDIDATEEXECUTION/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN of/IN the/DT surrounding/VBG agent/NN 's/POS agent/NN record/NN ./.)
*2*let VAReventlist be the [[EVENTLIST]] field of the element in VARexecution.[[EVENTLISTS]] whose [[AGENTSIGNIFIER]] is FUNCagentsignifier(). 
*2*(S (Chunk let/VB VAReventlist/NNP) be/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk EVENTLIST/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN of/IN the/DT element/NN in/IN (Chunk VARexecution/NNP) ./. [/VB [/JJ (Chunk EVENTLISTS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) whose/WP$ (Chunk [/NNP) (Chunk [/NNP) (Chunk AGENTSIGNIFIER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk is/VBZ FUNCagentsignifier/NNP) (/( )/) ./.)
*2*let VARbytes be a list of length 1 that contains a nondeterministically chosen byte value. 
*2*(S (Chunk let/VB VARbytes/NNP) be/VB a/DT list/NN of/IN length/NN 1/CD that/WDT contains/VBZ a/DT nondeterministically/RB chosen/VBN byte/NN value/NN ./.)
*2*note: in implementations, VARbytes is the result of a non-atomic read instruction on the underlying hardware. the nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency. 
*2*(S note/NN :/: in/IN implementations/NNS ,/, (Chunk VARbytes/NNP) is/VBZ the/DT result/NN of/IN a/DT non-atomic/JJ read/JJ instruction/NN on/IN the/DT underlying/JJ hardware/NN ./. the/DT nondeterminism/NN is/VBZ a/DT semantic/JJ prescription/NN of/IN the/DT memory/NN model/NN to/TO describe/VB observable/JJ behaviour/NN of/IN hardware/NN with/IN weak/JJ consistency/NN ./.)
*2*let VARreadevent be readsharedmemory { [[ORDER]]: "unordered", [[NOTEAR]]: true, [[BLOCK]]: VARfromblock, [[BYTEINDEX]]: VARfromindex, [[ELEMENTSIZE]]: 1 }. 
*2*(S (Chunk let/VB VARreadevent/NNP) be/VB readsharedmemory/JJ {/( [/JJ [/NN (Chunk ORDER/NNP) (Chunk ]/NNP) ]/NN :/: ``/`` unordered/JJ ''/'' ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk NOTEAR/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk BLOCK/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARfromblock/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk BYTEINDEX/NNP) (Chunk ]/NNP) ]/NN :/: VARfromindex/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ELEMENTSIZE/NNP) (Chunk ]/NNP) ]/NN :/: 1/CD }/) ./.)
*2*append VARreadevent to VAReventlist. 
*2*(S (Chunk append/VB VARreadevent/NNP) to/TO (Chunk VAReventlist/NNP) ./.)
*2*append chosen value record { [[EVENT]]: VARreadevent, [[CHOSENVALUE]]: VARbytes } to VARexecution.[[CHOSENVALUES]]. 
*2*(S append/NN chosen/VBZ value/NN record/NN {/( [/JJ [/FW (Chunk EVENT/NNP) (Chunk ]/NNP) ]/NN :/: VARreadevent/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk CHOSENVALUE/NNP) (Chunk ]/NNP) ]/NN :/: VARbytes/NNS }/) to/TO (Chunk VARexecution/NNP) ./. [/VB [/JJ (Chunk CHOSENVALUES/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*2*if VARtoblock is a shared data block, then
*2*(S if/IN (Chunk VARtoblock/NNP) is/VBZ a/DT shared/VBN data/NN block/NN ,/, then/RB)
*3*append writesharedmemory { [[ORDER]]: "unordered", [[NOTEAR]]: true, [[BLOCK]]: VARtoblock, [[BYTEINDEX]]: VARtoindex, [[ELEMENTSIZE]]: 1, [[PAYLOAD]]: VARbytes } to VAReventlist. 
*3*(S append/RB writesharedmemory/JJ {/( [/JJ [/NN (Chunk ORDER/NNP) (Chunk ]/NNP) ]/NN :/: ``/`` unordered/JJ ''/'' ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk NOTEAR/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk BLOCK/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARtoblock/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk BYTEINDEX/NNP) (Chunk ]/NNP) ]/NN :/: VARtoindex/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ELEMENTSIZE/NNP) (Chunk ]/NNP) ]/NN :/: 1/CD ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk PAYLOAD/NNP) (Chunk ]/NNP) ]/NN :/: VARbytes/NNS }/) to/TO (Chunk VAReventlist/NNP) ./.)
*2*else,
*2*(S else/RB ,/,)
*3*set VARtoblock[VARtoindex] to VARbytes[0]. 
*3*(S (Chunk set/VBN VARtoblock/NNP) (Chunk [/NNP) (Chunk VARtoindex/NNP) (Chunk ]/NNP) to/TO (Chunk VARbytes/NNP) (Chunk [/NNP) 0/CD ]/NN ./.)
*1*else,
*1*(S else/RB ,/,)
*2*assert: VARtoblock is not a shared data block. 
*2*(S assert/NN :/: (Chunk VARtoblock/NNP) is/VBZ not/RB a/DT shared/VBN data/NN block/NN ./.)
*2*set VARtoblock[VARtoindex] to VARfromblock[VARfromindex]. 
*2*(S (Chunk set/VBN VARtoblock/NNP) (Chunk [/NNP) (Chunk VARtoindex/NNP) (Chunk ]/NNP) to/TO (Chunk VARfromblock/NNP) (Chunk [/NNP) (Chunk VARfromindex/NNP) (Chunk ]/NNP) ./.)
*1*increment VARtoindex and VARfromindex each by 1. 
*1*(S increment/JJ (Chunk VARtoindex/NNP) and/CC (Chunk VARfromindex/NNP) each/DT by/IN 1/CD ./.)
*1*decrement VARcount by 1. 
*1*(S decrement/NN (Chunk VARcount/NNP) by/IN 1/CD ./.)
*0*return FUNCnormalcompletion(empty).     
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( empty/JJ )/) ./.)
ID= 7.1.1
Summary= ToPrimitive ( input [ , PreferredType ] )
*0*assert: VARinput is an ecmascript language value. 
*0*(S assert/NN :/: (Chunk VARinput/NNP) is/VBZ an/DT ecmascript/JJ language/NN value/NN ./.)
*0*if FUNCtype(VARinput) is object, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARinput/NNP) )/) is/VBZ object/JJ ,/, then/RB)
*1*if VARpreferredtype is not present, let VARhint be "default". 
*1*(S if/IN (Chunk VARpreferredtype/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARhint/NNP) be/VB ``/`` default/NN ''/'' ./.)
*1*else if VARpreferredtype is hint string, let VARhint be "string". 
*1*(S else/RB if/IN (Chunk VARpreferredtype/NNP) is/VBZ hint/JJ string/NN ,/, (Chunk let/VB VARhint/NNP) be/VB ``/`` string/VBG ''/'' ./.)
*1*else VARpreferredtype is hint number, let VARhint be "number". 
*1*(S (Chunk else/RB VARpreferredtype/NNP) is/VBZ hint/JJ number/NN ,/, (Chunk let/VB VARhint/NNP) be/VB ``/`` number/NN ''/'' ./.)
*1*let VARexotictoprim be ? FUNCgetmethod(VARinput, @@toprimitive). 
*1*(S (Chunk let/VB VARexotictoprim/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARinput/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) toprimitive/NN )/) ./.)
*1*if VARexotictoprim is not undefined, then
*1*(S if/IN (Chunk VARexotictoprim/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*2*let VARresult be ? FUNCcall(VARexotictoprim, VARinput, « VARhint »). 
*2*(S (Chunk let/VB VARresult/NNP) be/VB ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARexotictoprim/NNP) ,/, (Chunk VARinput/NNP) ,/, (Chunk «/NNP) (Chunk VARhint/NNP) (Chunk »/NNP) )/) ./.)
*2*if FUNCtype(VARresult) is not object, return VARresult. 
*2*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARresult/NNP) )/) is/VBZ not/RB object/JJ ,/, (Chunk return/VB VARresult/NNP) ./.)
*2*throw a typeerror exception. 
*2*(S throw/VB a/DT typeerror/NN exception/NN ./.)
*1*if VARhint is "default", set VARhint to "number". 
*1*(S if/IN (Chunk VARhint/NNP) is/VBZ ``/`` default/NN ''/'' ,/, (Chunk set/VBD VARhint/NNP) to/TO ``/`` number/NN ''/'' ./.)
*1*return ? FUNCordinarytoprimitive(VARinput, VARhint). 
*1*(S return/NN ?/. (Chunk FUNCordinarytoprimitive/NNP) (/( (Chunk VARinput/NNP) ,/, (Chunk VARhint/NNP) )/) ./.)
*0*return VARinput.    
*0*(S return/NN (Chunk VARinput/NNP) ./.)
ID= 7.1.1.1
Summary= OrdinaryToPrimitive ( O, hint )
*0*assert: FUNCtype(VARo) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ object/JJ ./.)
*0*assert: FUNCtype(VARhint) is string and its value is either "string" or "number". 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARhint/NNP) )/) is/VBZ string/VBG and/CC its/PRP$ value/NN is/VBZ either/CC ``/`` string/NN ''/'' or/CC ``/`` number/NN ''/'' ./.)
*0*if VARhint is "string", then
*0*(S if/IN (Chunk VARhint/NNP) is/VBZ ``/`` string/VBG ''/'' ,/, then/RB)
*1*let VARmethodnames be « "tostring", "valueof" ». 
*1*(S (Chunk let/VB VARmethodnames/NNP) be/VB «/VBN ``/`` tostring/VBG ''/'' ,/, ``/`` valueof/NN ''/'' »/NN ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARmethodnames be « "valueof", "tostring" ». 
*1*(S (Chunk let/VB VARmethodnames/NNP) be/VB «/VBN ``/`` valueof/NN ''/'' ,/, ``/`` tostring/VBG ''/'' »/NN ./.)
*0*for each VARname in VARmethodnames in list order, do
*0*(S for/IN each/DT (Chunk VARname/NNP) in/IN (Chunk VARmethodnames/NNP) in/IN list/NN order/NN ,/, do/VBP)
*1*let VARmethod be ? FUNCget(VARo, VARname). 
*1*(S (Chunk let/VB VARmethod/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARname/NNP) )/) ./.)
*1*if FUNCiscallable(VARmethod) is true, then
*1*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARmethod/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*let VARresult be ? FUNCcall(VARmethod, VARo). 
*2*(S (Chunk let/VB VARresult/NNP) be/VB ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARmethod/NNP) ,/, (Chunk VARo/NNP) )/) ./.)
*2*if FUNCtype(VARresult) is not object, return VARresult. 
*2*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARresult/NNP) )/) is/VBZ not/RB object/JJ ,/, (Chunk return/VB VARresult/NNP) ./.)
*0*throw a typeerror exception.     
*0*(S throw/VB a/DT typeerror/NN exception/NN ./.)
ID= 7.1.3
Summary= ToNumber ( argument )
*0*let VARprimvalue be ? FUNCtoprimitive(VARargument, hint number). 
*0*(S (Chunk let/VB VARprimvalue/NNP) be/VB ?/. (Chunk FUNCtoprimitive/NNP) (/( (Chunk VARargument/NNP) ,/, hint/NN number/NN )/) ./.)
*0*return ? FUNCtonumber(VARprimvalue).        
*0*(S return/NN ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARprimvalue/NNP) )/) ./.)
ID= 7.1.4
Summary= ToInteger ( argument )
*0*let VARnumber be ? FUNCtonumber(VARargument). 
*0*(S (Chunk let/VB VARnumber/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARargument/NNP) )/) ./.)
*0*if VARnumber is nan, return +0. 
*0*(S if/IN (Chunk VARnumber/NNP) is/VBZ nan/JJ ,/, (Chunk return/VB +0/NNP) ./.)
*0*if VARnumber is +0, -0, +∞, or -∞, return VARnumber. 
*0*(S if/IN (Chunk VARnumber/NNP) (Chunk is/VBZ +0/NNP) ,/, (Chunk -0/NNP) ,/, (Chunk +∞/NNP) ,/, or/CC -∞/NN ,/, return/NN (Chunk VARnumber/NNP) ./.)
*0*return the number value that is the same sign as VARnumber and whose magnitude is floor(abs(VARnumber)).    
*0*(S return/VB the/DT number/NN value/NN that/WDT is/VBZ the/DT same/JJ sign/NN as/IN (Chunk VARnumber/NNP) and/CC whose/WP$ magnitude/NN is/VBZ floor/NN (/( abs/JJ (/( (Chunk VARnumber/NNP) )/) )/) ./.)
ID= 7.1.5
Summary= ToInt32 ( argument )
*0*let VARnumber be ? FUNCtonumber(VARargument). 
*0*(S (Chunk let/VB VARnumber/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARargument/NNP) )/) ./.)
*0*if VARnumber is nan, +0, -0, +∞, or -∞, return +0. 
*0*(S if/IN (Chunk VARnumber/NNP) is/VBZ nan/JJ ,/, (Chunk +0/NNP) ,/, (Chunk -0/NNP) ,/, (Chunk +∞/NNP) ,/, or/CC -∞/NN ,/, return/NN +0/NN ./.)
*0*let VARint be the mathematical value that is the same sign as VARnumber and whose magnitude is floor(abs(VARnumber)). 
*0*(S (Chunk let/VB VARint/NNP) be/VB the/DT mathematical/JJ value/NN that/WDT is/VBZ the/DT same/JJ sign/NN as/IN (Chunk VARnumber/NNP) and/CC whose/WP$ magnitude/NN is/VBZ floor/NN (/( abs/JJ (/( (Chunk VARnumber/NNP) )/) )/) ./.)
*0*let VARint32bit be VARint modulo 232. 
*0*(S (Chunk let/VB VARint32bit/NNP) (Chunk be/VB VARint/NNP) modulo/$ 232/CD ./.)
*0*if VARint32bit ≥ 231, return VARint32bit - 232; otherwise return VARint32bit.    
*0*(S if/IN (Chunk VARint32bit/NNP) ≥/VBD 231/CD ,/, return/NN (Chunk VARint32bit/NNP) -/: 232/CD ;/: (Chunk otherwise/RB return/VB VARint32bit/NNP) ./.)
ID= 7.1.6
Summary= ToUint32 ( argument )
*0*let VARnumber be ? FUNCtonumber(VARargument). 
*0*(S (Chunk let/VB VARnumber/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARargument/NNP) )/) ./.)
*0*if VARnumber is nan, +0, -0, +∞, or -∞, return +0. 
*0*(S if/IN (Chunk VARnumber/NNP) is/VBZ nan/JJ ,/, (Chunk +0/NNP) ,/, (Chunk -0/NNP) ,/, (Chunk +∞/NNP) ,/, or/CC -∞/NN ,/, return/NN +0/NN ./.)
*0*let VARint be the mathematical value that is the same sign as VARnumber and whose magnitude is floor(abs(VARnumber)). 
*0*(S (Chunk let/VB VARint/NNP) be/VB the/DT mathematical/JJ value/NN that/WDT is/VBZ the/DT same/JJ sign/NN as/IN (Chunk VARnumber/NNP) and/CC whose/WP$ magnitude/NN is/VBZ floor/NN (/( abs/JJ (/( (Chunk VARnumber/NNP) )/) )/) ./.)
*0*let VARint32bit be VARint modulo 232. 
*0*(S (Chunk let/VB VARint32bit/NNP) (Chunk be/VB VARint/NNP) modulo/$ 232/CD ./.)
*0*return VARint32bit.    
*0*(S return/NN (Chunk VARint32bit/NNP) ./.)
ID= 7.1.7
Summary= ToInt16 ( argument )
*0*let VARnumber be ? FUNCtonumber(VARargument). 
*0*(S (Chunk let/VB VARnumber/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARargument/NNP) )/) ./.)
*0*if VARnumber is nan, +0, -0, +∞, or -∞, return +0. 
*0*(S if/IN (Chunk VARnumber/NNP) is/VBZ nan/JJ ,/, (Chunk +0/NNP) ,/, (Chunk -0/NNP) ,/, (Chunk +∞/NNP) ,/, or/CC -∞/NN ,/, return/NN +0/NN ./.)
*0*let VARint be the mathematical value that is the same sign as VARnumber and whose magnitude is floor(abs(VARnumber)). 
*0*(S (Chunk let/VB VARint/NNP) be/VB the/DT mathematical/JJ value/NN that/WDT is/VBZ the/DT same/JJ sign/NN as/IN (Chunk VARnumber/NNP) and/CC whose/WP$ magnitude/NN is/VBZ floor/NN (/( abs/JJ (/( (Chunk VARnumber/NNP) )/) )/) ./.)
*0*let VARint16bit be VARint modulo 216. 
*0*(S (Chunk let/VB VARint16bit/NNP) (Chunk be/VB VARint/NNP) modulo/$ 216/CD ./.)
*0*if VARint16bit ≥ 215, return VARint16bit - 216; otherwise return VARint16bit.    
*0*(S if/IN (Chunk VARint16bit/NNP) ≥/VBD 215/CD ,/, return/NN (Chunk VARint16bit/NNP) -/: 216/CD ;/: (Chunk otherwise/RB return/VB VARint16bit/NNP) ./.)
ID= 7.1.8
Summary= ToUint16 ( argument )
*0*let VARnumber be ? FUNCtonumber(VARargument). 
*0*(S (Chunk let/VB VARnumber/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARargument/NNP) )/) ./.)
*0*if VARnumber is nan, +0, -0, +∞, or -∞, return +0. 
*0*(S if/IN (Chunk VARnumber/NNP) is/VBZ nan/JJ ,/, (Chunk +0/NNP) ,/, (Chunk -0/NNP) ,/, (Chunk +∞/NNP) ,/, or/CC -∞/NN ,/, return/NN +0/NN ./.)
*0*let VARint be the mathematical value that is the same sign as VARnumber and whose magnitude is floor(abs(VARnumber)). 
*0*(S (Chunk let/VB VARint/NNP) be/VB the/DT mathematical/JJ value/NN that/WDT is/VBZ the/DT same/JJ sign/NN as/IN (Chunk VARnumber/NNP) and/CC whose/WP$ magnitude/NN is/VBZ floor/NN (/( abs/JJ (/( (Chunk VARnumber/NNP) )/) )/) ./.)
*0*let VARint16bit be VARint modulo 216. 
*0*(S (Chunk let/VB VARint16bit/NNP) (Chunk be/VB VARint/NNP) modulo/$ 216/CD ./.)
*0*return VARint16bit.    
*0*(S return/NN (Chunk VARint16bit/NNP) ./.)
ID= 7.1.9
Summary= ToInt8 ( argument )
*0*let VARnumber be ? FUNCtonumber(VARargument). 
*0*(S (Chunk let/VB VARnumber/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARargument/NNP) )/) ./.)
*0*if VARnumber is nan, +0, -0, +∞, or -∞, return +0. 
*0*(S if/IN (Chunk VARnumber/NNP) is/VBZ nan/JJ ,/, (Chunk +0/NNP) ,/, (Chunk -0/NNP) ,/, (Chunk +∞/NNP) ,/, or/CC -∞/NN ,/, return/NN +0/NN ./.)
*0*let VARint be the mathematical value that is the same sign as VARnumber and whose magnitude is floor(abs(VARnumber)). 
*0*(S (Chunk let/VB VARint/NNP) be/VB the/DT mathematical/JJ value/NN that/WDT is/VBZ the/DT same/JJ sign/NN as/IN (Chunk VARnumber/NNP) and/CC whose/WP$ magnitude/NN is/VBZ floor/NN (/( abs/JJ (/( (Chunk VARnumber/NNP) )/) )/) ./.)
*0*let VARint8bit be VARint modulo 28. 
*0*(S (Chunk let/VB VARint8bit/NNP) (Chunk be/VB VARint/NNP) modulo/$ 28/CD ./.)
*0*if VARint8bit ≥ 27, return VARint8bit - 28; otherwise return VARint8bit.    
*0*(S if/IN (Chunk VARint8bit/NNP) ≥/VBD 27/CD ,/, return/NN (Chunk VARint8bit/NNP) -/: 28/CD ;/: (Chunk otherwise/RB return/VB VARint8bit/NNP) ./.)
ID= 7.1.10
Summary= ToUint8 ( argument )
*0*let VARnumber be ? FUNCtonumber(VARargument). 
*0*(S (Chunk let/VB VARnumber/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARargument/NNP) )/) ./.)
*0*if VARnumber is nan, +0, -0, +∞, or -∞, return +0. 
*0*(S if/IN (Chunk VARnumber/NNP) is/VBZ nan/JJ ,/, (Chunk +0/NNP) ,/, (Chunk -0/NNP) ,/, (Chunk +∞/NNP) ,/, or/CC -∞/NN ,/, return/NN +0/NN ./.)
*0*let VARint be the mathematical value that is the same sign as VARnumber and whose magnitude is floor(abs(VARnumber)). 
*0*(S (Chunk let/VB VARint/NNP) be/VB the/DT mathematical/JJ value/NN that/WDT is/VBZ the/DT same/JJ sign/NN as/IN (Chunk VARnumber/NNP) and/CC whose/WP$ magnitude/NN is/VBZ floor/NN (/( abs/JJ (/( (Chunk VARnumber/NNP) )/) )/) ./.)
*0*let VARint8bit be VARint modulo 28. 
*0*(S (Chunk let/VB VARint8bit/NNP) (Chunk be/VB VARint/NNP) modulo/$ 28/CD ./.)
*0*return VARint8bit.    
*0*(S return/NN (Chunk VARint8bit/NNP) ./.)
ID= 7.1.11
Summary= ToUint8Clamp ( argument )
*0*let VARnumber be ? FUNCtonumber(VARargument). 
*0*(S (Chunk let/VB VARnumber/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARargument/NNP) )/) ./.)
*0*if VARnumber is nan, return +0. 
*0*(S if/IN (Chunk VARnumber/NNP) is/VBZ nan/JJ ,/, (Chunk return/VB +0/NNP) ./.)
*0*if VARnumber ≤ 0, return +0. 
*0*(S if/IN (Chunk VARnumber/NNP) (Chunk ≤/NNP) 0/CD ,/, return/NN +0/NN ./.)
*0*if VARnumber ≥ 255, return 255. 
*0*(S if/IN (Chunk VARnumber/NNP) (Chunk ≥/NNP) 255/CD ,/, return/NN 255/CD ./.)
*0*let VARf be floor(VARnumber). 
*0*(S (Chunk let/VB VARf/NNP) be/VB floor/NN (/( (Chunk VARnumber/NNP) )/) ./.)
*0*if VARf + 0.5 &lt; VARnumber, return VARf + 1. 
*0*(S if/IN (Chunk VARf/NNP) (Chunk +/NNP) 0.5/CD &/CC lt/NN ;/: (Chunk VARnumber/NNP) ,/, return/NN (Chunk VARf/NNP) +/VBD 1/CD ./.)
*0*if VARnumber &lt; VARf + 0.5, return VARf. 
*0*(S if/IN (Chunk VARnumber/NNP) &/CC lt/NN ;/: (Chunk VARf/NNP) +/VBD 0.5/CD ,/, return/NN (Chunk VARf/NNP) ./.)
*0*if VARf is odd, return VARf + 1. 
*0*(S if/IN (Chunk VARf/NNP) is/VBZ odd/JJ ,/, (Chunk return/VB VARf/NNP) (Chunk +/NNP) 1/CD ./.)
*0*return VARf.    
*0*(S return/NN (Chunk VARf/NNP) ./.)
ID= 7.1.12
Summary= ToString ( argument )
*0*let VARprimvalue be ? FUNCtoprimitive(VARargument, hint string). 
*0*(S (Chunk let/VB VARprimvalue/NNP) be/VB ?/. (Chunk FUNCtoprimitive/NNP) (/( (Chunk VARargument/NNP) ,/, hint/NN string/NN )/) ./.)
*0*return ? FUNCtostring(VARprimvalue).        
*0*(S return/NN ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARprimvalue/NNP) )/) ./.)
ID= 7.1.12.1
Summary= NumberToString ( m )
*0*if VARm is nan, return the string "nan". 
*0*(S if/IN (Chunk VARm/NNP) is/VBZ nan/JJ ,/, return/VB the/DT string/NN ``/`` nan/JJ ''/'' ./.)
*0*if VARm is +0 or -0, return the string "0". 
*0*(S if/IN (Chunk VARm/NNP) is/VBZ +0/JJ or/CC -0/JJ ,/, return/VB the/DT string/NN ``/`` 0/CD ''/'' ./.)
*0*if VARm is less than zero, return the FUNCstring-concatenation of "-" and ! numbertostring(-VARm). 
*0*(S if/IN (Chunk VARm/NNP) is/VBZ less/JJR than/IN zero/CD ,/, return/VBP the/DT (Chunk FUNCstring-concatenation/NNP) of/IN ``/`` -/: ''/'' and/CC !/. numbertostring/NN (/( (Chunk -VARm/NNP) )/) ./.)
*0*if VARm is +∞, return the string "infinity". 
*0*(S if/IN (Chunk VARm/NNP) is/VBZ +∞/JJ ,/, return/VB the/DT string/NN ``/`` infinity/NN ''/'' ./.)
*0*otherwise, let VARn, VARk, and VARs be integers such that VARk ≥ 1, 10VARk-1 ≤ VARs &lt; 10VARk, the number value for VARs × 10VARn-VARk is VARm, and VARk is as small as possible. note that VARk is the number of digits in the decimal representation of VARs, that VARs is not divisible by 10, and that the least significant digit of VARs is not necessarily uniquely determined by these criteria. 
*0*(S otherwise/RB ,/, (Chunk let/VB VARn/NNP) ,/, (Chunk VARk/NNP) ,/, and/CC (Chunk VARs/NNP) be/VB integers/NNS such/JJ that/IN (Chunk VARk/NNP) (Chunk ≥/NNP) 1/CD ,/, 10VARk-1/JJ (Chunk ≤/NNP) (Chunk VARs/NNP) &/CC lt/NN ;/: 10VARk/CD ,/, the/DT number/NN value/NN for/IN (Chunk VARs/NNP) (Chunk ×/NNP) 10VARn-VARk/CD (Chunk is/VBZ VARm/NNP) ,/, and/CC (Chunk VARk/NNP) is/VBZ as/RB small/JJ as/IN possible/JJ ./. note/NN that/IN (Chunk VARk/NNP) is/VBZ the/DT number/NN of/IN digits/NNS in/IN the/DT decimal/JJ representation/NN of/IN (Chunk VARs/NNP) ,/, that/IN (Chunk VARs/NNP) is/VBZ not/RB divisible/JJ by/IN 10/CD ,/, and/CC that/IN the/DT least/JJS significant/JJ digit/NN of/IN (Chunk VARs/NNP) is/VBZ not/RB necessarily/RB uniquely/RB determined/VBN by/IN these/DT criteria/NNS ./.)
*0*if VARk ≤ VARn ≤ 21, return the string-concatenation of:the code units of the VARk digits of the decimal representation of VARs (in order, with no leading zeroes) VARn-VARk occurrences of the code unit 0x0030 (digit zero) 
*0*(S if/IN (Chunk VARk/NNP) (Chunk ≤/NNP) (Chunk VARn/NNP) (Chunk ≤/NNP) 21/CD ,/, return/VBP the/DT string-concatenation/NN of/IN :/: the/DT code/NN units/NNS of/IN the/DT (Chunk VARk/NNP) digits/NNS of/IN the/DT decimal/JJ representation/NN of/IN (Chunk VARs/NNP) (/( in/IN order/NN ,/, with/IN no/DT leading/VBG zeroes/NNS )/) (Chunk VARn-VARk/NNP) occurrences/NNS of/IN the/DT code/NN unit/NN 0x0030/CD (/( digit/JJ zero/NN )/))
*0*if 0 &lt; VARn ≤ 21, return the string-concatenation of:the code units of the most significant VARn digits of the decimal representation of VARs the code unit 0x002e (full stop) the code units of the remaining VARk-VARn digits of the decimal representation of VARs 
*0*(S if/IN 0/CD &/CC lt/NN ;/: (Chunk VARn/NNP) ≤/VBZ 21/CD ,/, return/VBP the/DT string-concatenation/NN of/IN :/: the/DT code/NN units/NNS of/IN the/DT most/RBS significant/JJ (Chunk VARn/NNP) digits/NNS of/IN the/DT decimal/JJ representation/NN of/IN (Chunk VARs/NNP) the/DT code/NN unit/NN 0x002e/CD (/( full/JJ stop/NN )/) the/DT code/NN units/NNS of/IN the/DT (Chunk remaining/VBG VARk-VARn/NNP) digits/NNS of/IN the/DT decimal/JJ representation/NN of/IN (Chunk VARs/NNP))
*0*if -6 &lt; VARn ≤ 0, return the string-concatenation of:the code unit 0x0030 (digit zero) the code unit 0x002e (full stop) -VARn occurrences of the code unit 0x0030 (digit zero) the code units of the VARk digits of the decimal representation of VARs 
*0*(S if/IN (Chunk -6/NNP) &/CC lt/NN ;/: (Chunk VARn/NNP) ≤/VBZ 0/CD ,/, return/VBP the/DT string-concatenation/NN of/IN :/: the/DT code/NN unit/NN 0x0030/CD (/( digit/JJ zero/NN )/) the/DT code/NN unit/NN 0x002e/CD (/( full/JJ stop/NN )/) -VARn/NN occurrences/NNS of/IN the/DT code/NN unit/NN 0x0030/CD (/( digit/JJ zero/NN )/) the/DT code/NN units/NNS of/IN the/DT (Chunk VARk/NNP) digits/NNS of/IN the/DT decimal/JJ representation/NN of/IN (Chunk VARs/NNP))
*0*otherwise, if VARk = 1, return the FUNCstring-concatenation of:the code unit of the single digit of VARsthe code unit 0x0065 (latin small letter e)the code unit 0x002b (plus sign) or the code unit 0x002d (hyphen-minus) according to whether VARn-1 is positive or negativethe code units of the decimal representation of the integer abs(VARn-1) (with no leading zeroes) 
*0*(S otherwise/RB ,/, if/IN (Chunk VARk/NNP) (Chunk =/NNP) 1/CD ,/, return/VBP the/DT FUNCstring-concatenation/NN of/IN :/: the/DT code/NN unit/NN of/IN the/DT single/JJ digit/NN of/IN (Chunk VARsthe/NNP) code/NN unit/NN 0x0065/CD (/( latin/VB small/JJ letter/NN e/NN )/) the/DT code/NN unit/NN 0x002b/CD (/( plus/CC sign/NN )/) or/CC the/DT code/NN unit/NN 0x002d/CD (/( hyphen-minus/NN )/) according/VBG to/TO whether/IN (Chunk VARn-1/NNP) is/VBZ positive/JJ or/CC negativethe/JJ code/NN units/NNS of/IN the/DT decimal/JJ representation/NN of/IN the/DT integer/NN abs/NN (/( (Chunk VARn-1/NNP) )/) (/( with/IN no/DT leading/VBG zeroes/NNS )/))
*0*return the FUNCstring-concatenation of:the code units of the most significant digit of the decimal representation of VARsthe code unit 0x002e (full stop)the code units of the remaining VARk-1 digits of the decimal representation of VARsthe code unit 0x0065 (latin small letter e)the code unit 0x002b (plus sign) or the code unit 0x002d (hyphen-minus) according to whether VARn-1 is positive or negativethe code units of the decimal representation of the integer abs(VARn-1) (with no leading zeroes)     
*0*(S return/VB the/DT FUNCstring-concatenation/NN of/IN :/: the/DT code/NN units/NNS of/IN the/DT most/RBS significant/JJ digit/NN of/IN the/DT decimal/JJ representation/NN of/IN (Chunk VARsthe/NNP) code/NN unit/NN 0x002e/CD (/( full/JJ stop/NN )/) the/DT code/NN units/NNS of/IN the/DT (Chunk remaining/VBG VARk-1/NNP) digits/NNS of/IN the/DT decimal/JJ representation/NN of/IN (Chunk VARsthe/NNP) code/NN unit/NN 0x0065/CD (/( latin/VB small/JJ letter/NN e/NN )/) the/DT code/NN unit/NN 0x002b/CD (/( plus/CC sign/NN )/) or/CC the/DT code/NN unit/NN 0x002d/CD (/( hyphen-minus/NN )/) according/VBG to/TO whether/IN (Chunk VARn-1/NNP) is/VBZ positive/JJ or/CC negativethe/JJ code/NN units/NNS of/IN the/DT decimal/JJ representation/NN of/IN the/DT integer/NN abs/NN (/( (Chunk VARn-1/NNP) )/) (/( with/IN no/DT leading/VBG zeroes/NNS )/))
ID= 7.1.14
Summary= ToPropertyKey ( argument )
*0*let VARkey be ? FUNCtoprimitive(VARargument, hint string). 
*0*(S (Chunk let/VB VARkey/NNP) be/VB ?/. (Chunk FUNCtoprimitive/NNP) (/( (Chunk VARargument/NNP) ,/, hint/NN string/NN )/) ./.)
*0*if FUNCtype(VARkey) is symbol, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARkey/NNP) )/) is/VBZ symbol/NN ,/, then/RB)
*1*return VARkey. 
*1*(S return/NN (Chunk VARkey/NNP) ./.)
*0*return ! FUNCtostring(VARkey).    
*0*(S return/NN !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARkey/NNP) )/) ./.)
ID= 7.1.15
Summary= ToLength ( argument )
*0*let VARlen be ? FUNCtointeger(VARargument). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARargument/NNP) )/) ./.)
*0*if VARlen ≤ +0, return +0. 
*0*(S if/IN (Chunk VARlen/NNP) (Chunk ≤/NNP) (Chunk +0/NNP) ,/, return/NN +0/NN ./.)
*0*return min(VARlen, 253-1).    
*0*(S return/NN min/NN (/( (Chunk VARlen/NNP) ,/, 253-1/JJ )/) ./.)
ID= 7.1.16
Summary= CanonicalNumericIndexString ( argument )
*0*assert: FUNCtype(VARargument) is string. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARargument/NNP) )/) is/VBZ string/VBG ./.)
*0*if VARargument is "-0", return -0. 
*0*(S if/IN (Chunk VARargument/NNP) is/VBZ ``/`` -0/JJ ''/'' ,/, (Chunk return/VB -0/NNP) ./.)
*0*let VARn be ! FUNCtonumber(VARargument). 
*0*(S (Chunk let/VB VARn/NNP) be/VB !/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARargument/NNP) )/) ./.)
*0*if FUNCsamevalue(! FUNCtostring(VARn), VARargument) is false, return undefined. 
*0*(S if/IN (Chunk FUNCsamevalue/NNP) (/( !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARn/NNP) )/) ,/, (Chunk VARargument/NNP) )/) is/VBZ false/JJ ,/, return/NN undefined/VBD ./.)
*0*return VARn.    
*0*(S return/NN (Chunk VARn/NNP) ./.)
ID= 7.1.17
Summary= ToIndex ( value )
*0*if VARvalue is undefined, then
*0*(S if/IN (Chunk VARvalue/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*let VARindex be 0. 
*1*(S (Chunk let/VB VARindex/NNP) be/VB 0/CD ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARintegerindex be ? FUNCtointeger(VARvalue). 
*1*(S (Chunk let/VB VARintegerindex/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*1*if VARintegerindex &lt; 0, throw a rangeerror exception. 
*1*(S if/IN (Chunk VARintegerindex/NNP) &/CC lt/NN ;/: 0/CD ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*1*let VARindex be ! FUNCtolength(VARintegerindex). 
*1*(S (Chunk let/VB VARindex/NNP) be/VB !/. (Chunk FUNCtolength/NNP) (/( (Chunk VARintegerindex/NNP) )/) ./.)
*1*if FUNCsamevaluezero(VARintegerindex, VARindex) is false, throw a rangeerror exception. 
*1*(S if/IN (Chunk FUNCsamevaluezero/NNP) (/( (Chunk VARintegerindex/NNP) ,/, (Chunk VARindex/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT rangeerror/NN exception/NN ./.)
*0*return VARindex.    
*0*(S return/NN (Chunk VARindex/NNP) ./.)
ID= 7.2.2
Summary= IsArray ( argument )
*0*if FUNCtype(VARargument) is not object, return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARargument/NNP) )/) is/VBZ not/RB object/JJ ,/, return/NN false/JJ ./.)
*0*if VARargument is an array exotic object, return true. 
*0*(S if/IN (Chunk VARargument/NNP) is/VBZ an/DT array/NN exotic/JJ object/NN ,/, return/NN true/JJ ./.)
*0*if VARargument is a proxy exotic object, then
*0*(S if/IN (Chunk VARargument/NNP) is/VBZ a/DT proxy/JJ exotic/JJ object/NN ,/, then/RB)
*1*if VARargument.[[PROXYHANDLER]] is null, throw a typeerror exception. 
*1*(S if/IN (Chunk VARargument/NNP) ./. [/VB [/JJ (Chunk PROXYHANDLER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*let VARtarget be VARargument.[[PROXYTARGET]]. 
*1*(S (Chunk let/VB VARtarget/NNP) (Chunk be/VB VARargument/NNP) ./. [/VB [/JJ (Chunk PROXYTARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*return ? FUNCisarray(VARtarget). 
*1*(S return/NN ?/. (Chunk FUNCisarray/NNP) (/( (Chunk VARtarget/NNP) )/) ./.)
*0*return false.    
*0*(S return/NN false/JJ ./.)
ID= 7.2.3
Summary= IsCallable ( argument )
*0*if FUNCtype(VARargument) is not object, return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARargument/NNP) )/) is/VBZ not/RB object/JJ ,/, return/NN false/JJ ./.)
*0*if VARargument has a [[CALL]] internal method, return true. 
*0*(S if/IN (Chunk VARargument/NNP) has/VBZ a/DT [/JJ [/NN (Chunk CALL/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ method/NN ,/, return/NN true/JJ ./.)
*0*return false.    
*0*(S return/NN false/JJ ./.)
ID= 7.2.4
Summary= IsConstructor ( argument )
*0*if FUNCtype(VARargument) is not object, return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARargument/NNP) )/) is/VBZ not/RB object/JJ ,/, return/NN false/JJ ./.)
*0*if VARargument has a [[CONSTRUCT]] internal method, return true. 
*0*(S if/IN (Chunk VARargument/NNP) has/VBZ a/DT [/JJ (Chunk [/NNP) (Chunk CONSTRUCT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ method/NN ,/, return/NN true/JJ ./.)
*0*return false.    
*0*(S return/NN false/JJ ./.)
ID= 7.2.5
Summary= IsExtensible ( O )
*0*assert: FUNCtype(VARo) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ object/JJ ./.)
*0*return ? VARo.[[ISEXTENSIBLE]]().    
*0*(S return/NN ?/. (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk ISEXTENSIBLE/NNP) ]/NN (Chunk ]/NNP) (/( )/) ./.)
ID= 7.2.6
Summary= IsInteger ( argument )
*0*if FUNCtype(VARargument) is not number, return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARargument/NNP) )/) is/VBZ not/RB number/NN ,/, return/NN false/JJ ./.)
*0*if VARargument is nan, +∞, or -∞, return false. 
*0*(S if/IN (Chunk VARargument/NNP) is/VBZ nan/JJ ,/, +∞/JJ ,/, or/CC -∞/NN ,/, return/NN false/JJ ./.)
*0*if floor(abs(VARargument)) ≠ abs(VARargument), return false. 
*0*(S if/IN floor/NN (/( abs/JJ (/( (Chunk VARargument/NNP) )/) )/) ≠/FW abs/NN (/( (Chunk VARargument/NNP) )/) ,/, return/VBP false/JJ ./.)
*0*return true.    
*0*(S return/NN true/JJ ./.)
ID= 7.2.7
Summary= IsPropertyKey ( argument )
*0*if FUNCtype(VARargument) is string, return true. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARargument/NNP) )/) is/VBZ string/VBG ,/, return/NN true/JJ ./.)
*0*if FUNCtype(VARargument) is symbol, return true. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARargument/NNP) )/) is/VBZ symbol/JJ ,/, return/VB true/JJ ./.)
*0*return false.    
*0*(S return/NN false/JJ ./.)
ID= 7.2.8
Summary= IsRegExp ( argument )
*0*if FUNCtype(VARargument) is not object, return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARargument/NNP) )/) is/VBZ not/RB object/JJ ,/, return/NN false/JJ ./.)
*0*let VARmatcher be ? FUNCget(VARargument, @@match). 
*0*(S (Chunk let/VB VARmatcher/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARargument/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) match/NN )/) ./.)
*0*if VARmatcher is not undefined, return FUNCtoboolean(VARmatcher). 
*0*(S if/IN (Chunk VARmatcher/NNP) is/VBZ not/RB undefined/JJ ,/, return/JJ (Chunk FUNCtoboolean/NNP) (/( (Chunk VARmatcher/NNP) )/) ./.)
*0*if VARargument has a [[REGEXPMATCHER]] internal slot, return true. 
*0*(S if/IN (Chunk VARargument/NNP) has/VBZ a/DT [/JJ [/NN (Chunk REGEXPMATCHER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, return/NN true/JJ ./.)
*0*return false.    
*0*(S return/NN false/JJ ./.)
ID= 7.2.9
Summary= IsStringPrefix ( p, q )
*0*assert: FUNCtype(VARp) is string. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ string/VBG ./.)
*0*assert: FUNCtype(VARq) is string. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARq/NNP) )/) is/VBZ string/VBG ./.)
*0*if VARq can be the string-concatenation of VARp and some other string VARr, return true. otherwise, return false. 
*0*(S if/IN (Chunk VARq/NNP) can/MD be/VB the/DT string-concatenation/NN of/IN (Chunk VARp/NNP) and/CC some/DT other/JJ string/NN (Chunk VARr/NNP) ,/, return/NN true/JJ ./. otherwise/RB ,/, return/NN false/JJ ./.)
*0*note: any string is a prefix of itself, because VARr may be the empty string.    
*0*(S note/NN :/: any/DT string/NN is/VBZ a/DT prefix/NN of/IN itself/PRP ,/, because/IN (Chunk VARr/NNP) may/MD be/VB the/DT empty/JJ string/NN ./.)
ID= 7.2.10
Summary= SameValue ( x, y )
*0*if FUNCtype(VARx) is different from FUNCtype(VARy), return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARx/NNP) )/) is/VBZ different/JJ from/IN (Chunk FUNCtype/NNP) (/( (Chunk VARy/NNP) )/) ,/, return/VBP false/JJ ./.)
*0*if FUNCtype(VARx) is number, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARx/NNP) )/) is/VBZ number/NN ,/, then/RB)
*1*if VARx is nan and VARy is nan, return true. 
*1*(S if/IN (Chunk VARx/NNP) is/VBZ nan/JJ and/CC (Chunk VARy/NNP) is/VBZ nan/JJ ,/, return/VB true/JJ ./.)
*1*if VARx is +0 and VARy is -0, return false. 
*1*(S if/IN (Chunk VARx/NNP) is/VBZ +0/JJ and/CC (Chunk VARy/NNP) is/VBZ -0/JJ ,/, return/NN false/JJ ./.)
*1*if VARx is -0 and VARy is +0, return false. 
*1*(S if/IN (Chunk VARx/NNP) is/VBZ -0/JJ and/CC (Chunk VARy/NNP) is/VBZ +0/JJ ,/, return/NN false/JJ ./.)
*1*if VARx is the same number value as VARy, return true. 
*1*(S if/IN (Chunk VARx/NNP) is/VBZ the/DT same/JJ number/NN value/NN as/IN (Chunk VARy/NNP) ,/, return/NN true/JJ ./.)
*1*return false. 
*1*(S return/NN false/JJ ./.)
*0*return FUNCsamevaluenonnumber(VARx, VARy).    
*0*(S return/NN (Chunk FUNCsamevaluenonnumber/NNP) (/( (Chunk VARx/NNP) ,/, (Chunk VARy/NNP) )/) ./.)
ID= 7.2.11
Summary= SameValueZero ( x, y )
*0*if FUNCtype(VARx) is different from FUNCtype(VARy), return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARx/NNP) )/) is/VBZ different/JJ from/IN (Chunk FUNCtype/NNP) (/( (Chunk VARy/NNP) )/) ,/, return/VBP false/JJ ./.)
*0*if FUNCtype(VARx) is number, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARx/NNP) )/) is/VBZ number/NN ,/, then/RB)
*1*if VARx is nan and VARy is nan, return true. 
*1*(S if/IN (Chunk VARx/NNP) is/VBZ nan/JJ and/CC (Chunk VARy/NNP) is/VBZ nan/JJ ,/, return/VB true/JJ ./.)
*1*if VARx is +0 and VARy is -0, return true. 
*1*(S if/IN (Chunk VARx/NNP) is/VBZ +0/JJ and/CC (Chunk VARy/NNP) is/VBZ -0/JJ ,/, return/VB true/JJ ./.)
*1*if VARx is -0 and VARy is +0, return true. 
*1*(S if/IN (Chunk VARx/NNP) is/VBZ -0/JJ and/CC (Chunk VARy/NNP) is/VBZ +0/JJ ,/, return/VB true/JJ ./.)
*1*if VARx is the same number value as VARy, return true. 
*1*(S if/IN (Chunk VARx/NNP) is/VBZ the/DT same/JJ number/NN value/NN as/IN (Chunk VARy/NNP) ,/, return/NN true/JJ ./.)
*1*return false. 
*1*(S return/NN false/JJ ./.)
*0*return FUNCsamevaluenonnumber(VARx, VARy).    
*0*(S return/NN (Chunk FUNCsamevaluenonnumber/NNP) (/( (Chunk VARx/NNP) ,/, (Chunk VARy/NNP) )/) ./.)
ID= 7.2.12
Summary= SameValueNonNumber ( x, y )
*0*assert: FUNCtype(VARx) is not number. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARx/NNP) )/) is/VBZ not/RB number/NN ./.)
*0*assert: FUNCtype(VARx) is the same as FUNCtype(VARy). 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARx/NNP) )/) is/VBZ the/DT same/JJ as/IN (Chunk FUNCtype/NNP) (/( (Chunk VARy/NNP) )/) ./.)
*0*if FUNCtype(VARx) is undefined, return true. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARx/NNP) )/) is/VBZ undefined/JJ ,/, return/VB true/JJ ./.)
*0*if FUNCtype(VARx) is null, return true. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARx/NNP) )/) is/VBZ null/JJ ,/, return/VB true/JJ ./.)
*0*if FUNCtype(VARx) is string, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARx/NNP) )/) is/VBZ string/VBG ,/, then/RB)
*1*if VARx and VARy are exactly the same sequence of code units (same length and same code units at corresponding indices), return true; otherwise, return false. 
*1*(S if/IN (Chunk VARx/NNP) and/CC (Chunk VARy/NNP) are/VBP exactly/RB the/DT same/JJ sequence/NN of/IN code/NN units/NNS (/( same/JJ length/NN and/CC same/JJ code/NN units/NNS at/IN corresponding/VBG indices/NNS )/) ,/, return/VBP true/JJ ;/: otherwise/RB ,/, return/NN false/JJ ./.)
*0*if FUNCtype(VARx) is boolean, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARx/NNP) )/) is/VBZ boolean/JJ ,/, then/RB)
*1*if VARx and VARy are both true or both false, return true; otherwise, return false. 
*1*(S if/IN (Chunk VARx/NNP) and/CC (Chunk VARy/NNP) are/VBP both/DT true/JJ or/CC both/DT false/JJ ,/, return/VB true/JJ ;/: otherwise/RB ,/, return/NN false/JJ ./.)
*0*if FUNCtype(VARx) is symbol, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARx/NNP) )/) is/VBZ symbol/NN ,/, then/RB)
*1*if VARx and VARy are both the same symbol value, return true; otherwise, return false. 
*1*(S if/IN (Chunk VARx/NNP) and/CC (Chunk VARy/NNP) are/VBP both/DT the/DT same/JJ symbol/NN value/NN ,/, return/VB true/JJ ;/: otherwise/RB ,/, return/NN false/JJ ./.)
*0*if VARx and VARy are the same object value, return true. otherwise, return false.    
*0*(S if/IN (Chunk VARx/NNP) and/CC (Chunk VARy/NNP) are/VBP the/DT same/JJ object/JJ value/NN ,/, return/VB true/JJ ./. otherwise/RB ,/, return/NN false/JJ ./.)
ID= 7.3.1
Summary= Get ( O, P )
*0*assert: FUNCtype(VARo) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ object/JJ ./.)
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*return ? VARo.[[GET]](VARp, VARo).    
*0*(S return/NN ?/. (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) ,/, (Chunk VARo/NNP) )/) ./.)
ID= 7.3.2
Summary= GetV ( V, P )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARo be ? FUNCtoobject(VARv). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARv/NNP) )/) ./.)
*0*return ? VARo.[[GET]](VARp, VARv).    
*0*(S return/NN ?/. (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) ,/, (Chunk VARv/NNP) )/) ./.)
ID= 7.3.3
Summary= Set ( O, P, V, Throw )
*0*assert: FUNCtype(VARo) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ object/JJ ./.)
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*assert: FUNCtype(VARthrow) is boolean. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARthrow/NNP) )/) is/VBZ boolean/JJ ./.)
*0*let VARsuccess be ? VARo.[[SET]](VARp, VARv, VARo). 
*0*(S (Chunk let/VB VARsuccess/NNP) be/VB ?/. (Chunk VARo/NNP) ./. [/NN [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) ,/, (Chunk VARv/NNP) ,/, (Chunk VARo/NNP) )/) ./.)
*0*if VARsuccess is false and VARthrow is true, throw a typeerror exception. 
*0*(S if/IN (Chunk VARsuccess/NNP) is/VBZ false/JJ and/CC (Chunk VARthrow/NNP) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARsuccess.    
*0*(S return/NN (Chunk VARsuccess/NNP) ./.)
ID= 7.3.4
Summary= CreateDataProperty ( O, P, V )
*0*assert: FUNCtype(VARo) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ object/JJ ./.)
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARnewdesc be the propertydescriptor { [[VALUE]]: VARv, [[WRITABLE]]: true, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: true }. 
*0*(S (Chunk let/VB VARnewdesc/NNP) be/VB the/DT propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARv/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ }/) ./.)
*0*return ? VARo.[[DEFINEOWNPROPERTY]](VARp, VARnewdesc).    
*0*(S return/NN ?/. (Chunk VARo/NNP) ./. (Chunk [/VB [/NNP) (Chunk DEFINEOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) ,/, (Chunk VARnewdesc/NNP) )/) ./.)
ID= 7.3.5
Summary= CreateMethodProperty ( O, P, V )
*0*assert: FUNCtype(VARo) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ object/JJ ./.)
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARnewdesc be the propertydescriptor { [[VALUE]]: VARv, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }. 
*0*(S (Chunk let/VB VARnewdesc/NNP) be/VB the/DT propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARv/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ }/) ./.)
*0*return ? VARo.[[DEFINEOWNPROPERTY]](VARp, VARnewdesc).    
*0*(S return/NN ?/. (Chunk VARo/NNP) ./. (Chunk [/VB [/NNP) (Chunk DEFINEOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) ,/, (Chunk VARnewdesc/NNP) )/) ./.)
ID= 7.3.6
Summary= CreateDataPropertyOrThrow ( O, P, V )
*0*assert: FUNCtype(VARo) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ object/JJ ./.)
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARsuccess be ? FUNCcreatedataproperty(VARo, VARp, VARv). 
*0*(S (Chunk let/VB VARsuccess/NNP) be/VB ?/. (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARv/NNP) )/) ./.)
*0*if VARsuccess is false, throw a typeerror exception. 
*0*(S if/IN (Chunk VARsuccess/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARsuccess.    
*0*(S return/NN (Chunk VARsuccess/NNP) ./.)
ID= 7.3.7
Summary= DefinePropertyOrThrow ( O, P, desc )
*0*assert: FUNCtype(VARo) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ object/JJ ./.)
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARsuccess be ? VARo.[[DEFINEOWNPROPERTY]](VARp, VARdesc). 
*0*(S (Chunk let/VB VARsuccess/NNP) be/VB ?/. (Chunk VARo/NNP) ./. (Chunk [/VB [/NNP) (Chunk DEFINEOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) ,/, (Chunk VARdesc/NNP) )/) ./.)
*0*if VARsuccess is false, throw a typeerror exception. 
*0*(S if/IN (Chunk VARsuccess/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARsuccess.    
*0*(S return/NN (Chunk VARsuccess/NNP) ./.)
ID= 7.3.8
Summary= DeletePropertyOrThrow ( O, P )
*0*assert: FUNCtype(VARo) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ object/JJ ./.)
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARsuccess be ? VARo.[[DELETE]](VARp). 
*0*(S (Chunk let/VB VARsuccess/NNP) be/VB ?/. (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk DELETE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*if VARsuccess is false, throw a typeerror exception. 
*0*(S if/IN (Chunk VARsuccess/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARsuccess.    
*0*(S return/NN (Chunk VARsuccess/NNP) ./.)
ID= 7.3.9
Summary= GetMethod ( V, P )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARfunc be ? FUNCgetv(VARv, VARp). 
*0*(S (Chunk let/VB VARfunc/NNP) be/VB ?/. (Chunk FUNCgetv/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
*0*if VARfunc is either undefined or null, return undefined. 
*0*(S if/IN (Chunk VARfunc/NNP) is/VBZ either/RB undefined/JJ or/CC null/JJ ,/, return/NN undefined/VBD ./.)
*0*if FUNCiscallable(VARfunc) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARfunc/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARfunc.    
*0*(S return/NN (Chunk VARfunc/NNP) ./.)
ID= 7.3.10
Summary= HasProperty ( O, P )
*0*assert: FUNCtype(VARo) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ object/JJ ./.)
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*return ? VARo.[[HASPROPERTY]](VARp).    
*0*(S return/NN ?/. (Chunk VARo/NNP) ./. (Chunk [/VB [/NNP) (Chunk HASPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
ID= 7.3.11
Summary= HasOwnProperty ( O, P )
*0*assert: FUNCtype(VARo) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ object/JJ ./.)
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARdesc be ? VARo.[[GETOWNPROPERTY]](VARp). 
*0*(S (Chunk let/VB VARdesc/NNP) be/VB ?/. (Chunk VARo/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*if VARdesc is undefined, return false. 
*0*(S if/IN (Chunk VARdesc/NNP) is/VBZ undefined/JJ ,/, return/NN false/JJ ./.)
*0*return true.    
*0*(S return/NN true/JJ ./.)
ID= 7.3.12
Summary= Call ( F, V [ , argumentsList ] )
*0*if VARargumentslist is not present, set VARargumentslist to a new empty list. 
*0*(S if/IN (Chunk VARargumentslist/NNP) is/VBZ not/RB present/JJ ,/, (Chunk set/VBN VARargumentslist/NNP) to/TO a/DT new/JJ empty/JJ list/NN ./.)
*0*if FUNCiscallable(VARf) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARf/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return ? VARf.[[CALL]](VARv, VARargumentslist).    
*0*(S return/NN ?/. (Chunk VARf/NNP) ./. [/VB [/JJ (Chunk CALL/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARargumentslist/NNP) )/) ./.)
ID= 7.3.13
Summary= Construct ( F [ , argumentsList [ , newTarget ]] )
*0*if VARnewtarget is not present, set VARnewtarget to VARf. 
*0*(S if/IN (Chunk VARnewtarget/NNP) is/VBZ not/RB present/JJ ,/, (Chunk set/VB VARnewtarget/NNP) to/TO (Chunk VARf/NNP) ./.)
*0*if VARargumentslist is not present, set VARargumentslist to a new empty list. 
*0*(S if/IN (Chunk VARargumentslist/NNP) is/VBZ not/RB present/JJ ,/, (Chunk set/VBN VARargumentslist/NNP) to/TO a/DT new/JJ empty/JJ list/NN ./.)
*0*assert: FUNCisconstructor(VARf) is true. 
*0*(S assert/NN :/: (Chunk FUNCisconstructor/NNP) (/( (Chunk VARf/NNP) )/) is/VBZ true/JJ ./.)
*0*assert: FUNCisconstructor(VARnewtarget) is true. 
*0*(S assert/NN :/: (Chunk FUNCisconstructor/NNP) (/( (Chunk VARnewtarget/NNP) )/) is/VBZ true/JJ ./.)
*0*return ? VARf.[[CONSTRUCT]](VARargumentslist, VARnewtarget).    
*0*(S return/NN ?/. (Chunk VARf/NNP) ./. (Chunk [/NNP) (Chunk [/NNP) (Chunk CONSTRUCT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARargumentslist/NNP) ,/, (Chunk VARnewtarget/NNP) )/) ./.)
ID= 7.3.14
Summary= SetIntegrityLevel ( O, level )
*0*assert: FUNCtype(VARo) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ object/JJ ./.)
*0*assert: VARlevel is either "sealed" or "frozen". 
*0*(S assert/NN :/: (Chunk VARlevel/NNP) is/VBZ either/CC ``/`` sealed/JJ ''/'' or/CC ``/`` frozen/JJ ''/'' ./.)
*0*let VARstatus be ? VARo.[[PREVENTEXTENSIONS]](). 
*0*(S (Chunk let/VB VARstatus/NNP) be/VB ?/. (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk PREVENTEXTENSIONS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*0*if VARstatus is false, return false. 
*0*(S if/IN (Chunk VARstatus/NNP) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*0*let VARkeys be ? VARo.[[OWNPROPERTYKEYS]](). 
*0*(S (Chunk let/VB VARkeys/NNP) be/VB ?/. (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk OWNPROPERTYKEYS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*0*if VARlevel is "sealed", then
*0*(S if/IN (Chunk VARlevel/NNP) is/VBZ ``/`` sealed/JJ ''/'' ,/, then/RB)
*1*for each element VARk of VARkeys, do
*1*(S for/IN each/DT element/NN (Chunk VARk/NNP) of/IN (Chunk VARkeys/NNP) ,/, do/VBP)
*2*perform ? FUNCdefinepropertyorthrow(VARo, VARk, propertydescriptor { [[CONFIGURABLE]]: false }). 
*2*(S perform/NN ?/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARk/NNP) ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) )/) ./.)
*0*else VARlevel is "frozen",
*0*(S (Chunk else/RB VARlevel/NNP) is/VBZ ``/`` frozen/JJ ''/'' ,/,)
*1*for each element VARk of VARkeys, do
*1*(S for/IN each/DT element/NN (Chunk VARk/NNP) of/IN (Chunk VARkeys/NNP) ,/, do/VBP)
*2*let VARcurrentdesc be ? VARo.[[GETOWNPROPERTY]](VARk). 
*2*(S (Chunk let/VB VARcurrentdesc/NNP) be/VB ?/. (Chunk VARo/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*2*if VARcurrentdesc is not undefined, then
*2*(S if/IN (Chunk VARcurrentdesc/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*3*if FUNCisaccessordescriptor(VARcurrentdesc) is true, then
*3*(S if/IN (Chunk FUNCisaccessordescriptor/NNP) (/( (Chunk VARcurrentdesc/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*4*let VARdesc be the propertydescriptor { [[CONFIGURABLE]]: false }. 
*4*(S (Chunk let/VB VARdesc/NNP) be/VB the/DT propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) ./.)
*3*else,
*3*(S else/RB ,/,)
*4*let VARdesc be the propertydescriptor { [[CONFIGURABLE]]: false, [[WRITABLE]]: false }. 
*4*(S (Chunk let/VB VARdesc/NNP) be/VB the/DT propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) ./.)
*3*perform ? FUNCdefinepropertyorthrow(VARo, VARk, VARdesc). 
*3*(S perform/NN ?/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARk/NNP) ,/, (Chunk VARdesc/NNP) )/) ./.)
*0*return true.    
*0*(S return/NN true/JJ ./.)
ID= 7.3.15
Summary= TestIntegrityLevel ( O, level )
*0*assert: FUNCtype(VARo) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ object/JJ ./.)
*0*assert: VARlevel is either "sealed" or "frozen". 
*0*(S assert/NN :/: (Chunk VARlevel/NNP) is/VBZ either/CC ``/`` sealed/JJ ''/'' or/CC ``/`` frozen/JJ ''/'' ./.)
*0*let VARstatus be ? FUNCisextensible(VARo). 
*0*(S (Chunk let/VB VARstatus/NNP) be/VB ?/. (Chunk FUNCisextensible/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*if VARstatus is true, return false. 
*0*(S if/IN (Chunk VARstatus/NNP) is/VBZ true/JJ ,/, return/NN false/JJ ./.)
*0*note: if the object is extensible, none of its properties are examined. 
*0*(S note/NN :/: if/IN the/DT object/NN is/VBZ extensible/JJ ,/, none/NN of/IN its/PRP$ properties/NNS are/VBP examined/VBN ./.)
*0*let VARkeys be ? VARo.[[OWNPROPERTYKEYS]](). 
*0*(S (Chunk let/VB VARkeys/NNP) be/VB ?/. (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk OWNPROPERTYKEYS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*0*for each element VARk of VARkeys, do
*0*(S for/IN each/DT element/NN (Chunk VARk/NNP) of/IN (Chunk VARkeys/NNP) ,/, do/VBP)
*1*let VARcurrentdesc be ? VARo.[[GETOWNPROPERTY]](VARk). 
*1*(S (Chunk let/VB VARcurrentdesc/NNP) be/VB ?/. (Chunk VARo/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*if VARcurrentdesc is not undefined, then
*1*(S if/IN (Chunk VARcurrentdesc/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*2*if VARcurrentdesc.[[CONFIGURABLE]] is true, return false. 
*2*(S if/IN (Chunk VARcurrentdesc/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ true/JJ ,/, return/NN false/JJ ./.)
*2*if VARlevel is "frozen" and FUNCisdatadescriptor(VARcurrentdesc) is true, then
*2*(S if/IN (Chunk VARlevel/NNP) is/VBZ ``/`` frozen/JJ ''/'' and/CC (Chunk FUNCisdatadescriptor/NNP) (/( (Chunk VARcurrentdesc/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*3*if VARcurrentdesc.[[WRITABLE]] is true, return false. 
*3*(S if/IN (Chunk VARcurrentdesc/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ true/JJ ,/, return/NN false/JJ ./.)
*0*return true.    
*0*(S return/NN true/JJ ./.)
ID= 7.3.16
Summary= CreateArrayFromList ( elements )
*0*assert: VARelements is a list whose elements are all ecmascript language values. 
*0*(S assert/NN :/: VARelements/NNS is/VBZ a/DT list/NN whose/WP$ elements/NNS are/VBP all/DT ecmascript/JJ language/NN values/NNS ./.)
*0*let VARarray be ! FUNCarraycreate(0). 
*0*(S (Chunk let/VB VARarray/NNP) be/VB !/. (Chunk FUNCarraycreate/NNP) (/( 0/CD )/) ./.)
*0*let VARn be 0. 
*0*(S (Chunk let/VB VARn/NNP) be/VB 0/CD ./.)
*0*for each element VARe of VARelements, do
*0*(S for/IN each/DT element/NN (Chunk VARe/NNP) of/IN (Chunk VARelements/NNP) ,/, do/VBP)
*1*let VARstatus be FUNCcreatedataproperty(VARarray, ! FUNCtostring(VARn), VARe). 
*1*(S (Chunk let/VB VARstatus/NNP) (Chunk be/VB FUNCcreatedataproperty/NNP) (/( (Chunk VARarray/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARn/NNP) )/) ,/, (Chunk VARe/NNP) )/) ./.)
*1*assert: VARstatus is true. 
*1*(S assert/NN :/: (Chunk VARstatus/NNP) is/VBZ true/JJ ./.)
*1*increment VARn by 1. 
*1*(S increment/NN (Chunk VARn/NNP) by/IN 1/CD ./.)
*0*return VARarray.    
*0*(S return/NN (Chunk VARarray/NNP) ./.)
ID= 7.3.17
Summary= CreateListFromArrayLike ( obj [ , elementTypes ] )
*0*if VARelementtypes is not present, set VARelementtypes to « undefined, null, boolean, string, symbol, number, object ». 
*0*(S if/IN (Chunk VARelementtypes/NNP) is/VBZ not/RB present/JJ ,/, set/VBN VARelementtypes/NNS to/TO «/VB undefined/JJ ,/, null/JJ ,/, boolean/JJ ,/, string/NN ,/, symbol/NN ,/, number/NN ,/, object/JJ »/NN ./.)
*0*if FUNCtype(VARobj) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARobj/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARobj, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*let VARlist be a new empty list. 
*0*(S (Chunk let/VB VARlist/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARindex be 0. 
*0*(S (Chunk let/VB VARindex/NNP) be/VB 0/CD ./.)
*0*repeat, while VARindex &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARindex/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*let VARindexname be ! FUNCtostring(VARindex). 
*1*(S (Chunk let/VB VARindexname/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARindex/NNP) )/) ./.)
*1*let VARnext be ? FUNCget(VARobj, VARindexname). 
*1*(S (Chunk let/VB VARnext/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARobj/NNP) ,/, (Chunk VARindexname/NNP) )/) ./.)
*1*if FUNCtype(VARnext) is not an element of VARelementtypes, throw a typeerror exception. 
*1*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARnext/NNP) )/) is/VBZ not/RB an/DT element/NN of/IN (Chunk VARelementtypes/NNP) ,/, throw/VBP a/DT typeerror/NN exception/NN ./.)
*1*append VARnext as the last element of VARlist. 
*1*(S (Chunk append/RB VARnext/NNP) as/IN the/DT last/JJ element/NN of/IN (Chunk VARlist/NNP) ./.)
*1*set VARindex to VARindex + 1. 
*1*(S set/VBN VARindex/NN to/TO (Chunk VARindex/NNP) (Chunk +/NNP) 1/CD ./.)
*0*return VARlist.    
*0*(S return/NN (Chunk VARlist/NNP) ./.)
ID= 7.3.18
Summary= Invoke ( V, P [ , argumentsList ] )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*if VARargumentslist is not present, set VARargumentslist to a new empty list. 
*0*(S if/IN (Chunk VARargumentslist/NNP) is/VBZ not/RB present/JJ ,/, (Chunk set/VBN VARargumentslist/NNP) to/TO a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARfunc be ? FUNCgetv(VARv, VARp). 
*0*(S (Chunk let/VB VARfunc/NNP) be/VB ?/. (Chunk FUNCgetv/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
*0*return ? FUNCcall(VARfunc, VARv, VARargumentslist).    
*0*(S return/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARfunc/NNP) ,/, (Chunk VARv/NNP) ,/, (Chunk VARargumentslist/NNP) )/) ./.)
ID= 7.3.19
Summary= OrdinaryHasInstance ( C, O )
*0*if FUNCiscallable(VARc) is false, return false. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARc/NNP) )/) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*0*if VARc has a [[BOUNDTARGETFUNCTION]] internal slot, then
*0*(S if/IN (Chunk VARc/NNP) has/VBZ a/DT [/JJ [/JJ (Chunk BOUNDTARGETFUNCTION/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, then/RB)
*1*let VARbc be VARc.[[BOUNDTARGETFUNCTION]]. 
*1*(S (Chunk let/VB VARbc/NNP) (Chunk be/VB VARc/NNP) ./. [/VB [/JJ (Chunk BOUNDTARGETFUNCTION/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*return ? FUNCinstanceofoperator(VARo, VARbc). 
*1*(S return/NN ?/. (Chunk FUNCinstanceofoperator/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARbc/NNP) )/) ./.)
*0*if FUNCtype(VARo) is not object, return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, return/NN false/JJ ./.)
*0*let VARp be ? FUNCget(VARc, "prototype"). 
*0*(S (Chunk let/VB VARp/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARc/NNP) ,/, ``/`` prototype/NN ''/'' )/) ./.)
*0*if FUNCtype(VARp) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*repeat,
*0*(S repeat/NN ,/,)
*1*set VARo to ? VARo.[[GETPROTOTYPEOF]](). 
*1*(S (Chunk set/VBN VARo/NNP) to/TO ?/. (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk GETPROTOTYPEOF/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*1*if VARo is null, return false. 
*1*(S if/IN (Chunk VARo/NNP) is/VBZ null/JJ ,/, return/NN false/JJ ./.)
*1*if FUNCsamevalue(VARp, VARo) is true, return true.    
*1*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARp/NNP) ,/, (Chunk VARo/NNP) )/) is/VBZ true/JJ ,/, return/VB true/JJ ./.)
ID= 7.3.20
Summary= SpeciesConstructor ( O, defaultConstructor )
*0*assert: FUNCtype(VARo) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ object/JJ ./.)
*0*let VARc be ? FUNCget(VARo, "constructor"). 
*0*(S (Chunk let/VB VARc/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` constructor/NN ''/'' )/) ./.)
*0*if VARc is undefined, return VARdefaultconstructor. 
*0*(S if/IN (Chunk VARc/NNP) is/VBZ undefined/JJ ,/, return/JJ (Chunk VARdefaultconstructor/NNP) ./.)
*0*if FUNCtype(VARc) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARc/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARs be ? FUNCget(VARc, @@species). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARc/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) species/NNS )/) ./.)
*0*if VARs is either undefined or null, return VARdefaultconstructor. 
*0*(S if/IN (Chunk VARs/NNP) is/VBZ either/RB undefined/JJ or/CC null/JJ ,/, return/JJ (Chunk VARdefaultconstructor/NNP) ./.)
*0*if FUNCisconstructor(VARs) is true, return VARs. 
*0*(S if/IN (Chunk FUNCisconstructor/NNP) (/( (Chunk VARs/NNP) )/) is/VBZ true/JJ ,/, return/JJ (Chunk VARs/NNP) ./.)
*0*throw a typeerror exception.    
*0*(S throw/VB a/DT typeerror/NN exception/NN ./.)
ID= 7.3.21
Summary= EnumerableOwnPropertyNames ( O, kind )
*0*assert: FUNCtype(VARo) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ object/JJ ./.)
*0*let VARownkeys be ? VARo.[[OWNPROPERTYKEYS]](). 
*0*(S (Chunk let/VB VARownkeys/NNP) be/VB ?/. (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk OWNPROPERTYKEYS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*0*let VARproperties be a new empty list. 
*0*(S let/VB VARproperties/NNS be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*for each element VARkey of VARownkeys in list order, do
*0*(S for/IN each/DT element/NN (Chunk VARkey/NNP) of/IN (Chunk VARownkeys/NNP) in/IN list/NN order/NN ,/, do/VBP)
*1*if FUNCtype(VARkey) is string, then
*1*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARkey/NNP) )/) is/VBZ string/VBG ,/, then/RB)
*2*let VARdesc be ? VARo.[[GETOWNPROPERTY]](VARkey). 
*2*(S (Chunk let/VB VARdesc/NNP) be/VB ?/. (Chunk VARo/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARkey/NNP) )/) ./.)
*2*if VARdesc is not undefined and VARdesc.[[ENUMERABLE]] is true, then
*2*(S if/IN (Chunk VARdesc/NNP) is/VBZ not/RB undefined/JJ and/CC (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ true/JJ ,/, then/RB)
*3*if VARkind is "key", append VARkey to VARproperties. 
*3*(S if/IN (Chunk VARkind/NNP) is/VBZ ``/`` key/JJ ''/'' ,/, (Chunk append/VBP VARkey/NNP) to/TO (Chunk VARproperties/NNP) ./.)
*3*else,
*3*(S else/RB ,/,)
*4*let VARvalue be ? FUNCget(VARo, VARkey). 
*4*(S (Chunk let/VB VARvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARkey/NNP) )/) ./.)
*4*if VARkind is "value", append VARvalue to VARproperties. 
*4*(S if/IN (Chunk VARkind/NNP) is/VBZ ``/`` value/NN ''/'' ,/, (Chunk append/VBP VARvalue/NNP) to/TO (Chunk VARproperties/NNP) ./.)
*4*else,
*4*(S else/RB ,/,)
*5*assert: VARkind is "key+value". 
*5*(S assert/NN :/: (Chunk VARkind/NNP) is/VBZ ``/`` key+value/JJ ''/'' ./.)
*5*let VARentry be FUNCcreatearrayfromlist(« VARkey, VARvalue »). 
*5*(S (Chunk let/VB VARentry/NNP) (Chunk be/VB FUNCcreatearrayfromlist/NNP) (/( (Chunk «/NNP) (Chunk VARkey/NNP) ,/, (Chunk VARvalue/NNP) (Chunk »/NNP) )/) ./.)
*5*append VARentry to VARproperties. 
*5*(S append/JJ (Chunk VARentry/NNP) to/TO (Chunk VARproperties/NNP) ./.)
*0*order the elements of VARproperties so they are in the same relative order as would be produced by the iterator that would be returned if the enumerateobjectproperties internal method were invoked with VARo. 
*0*(S order/NN the/DT elements/NNS of/IN VARproperties/NNS so/IN they/PRP are/VBP in/IN the/DT same/JJ relative/JJ order/NN as/IN would/MD be/VB produced/VBN by/IN the/DT iterator/NN that/WDT would/MD be/VB returned/VBN if/IN the/DT enumerateobjectproperties/NNS internal/JJ method/NN were/VBD invoked/VBN with/IN (Chunk VARo/NNP) ./.)
*0*return VARproperties.    
*0*(S return/NN VARproperties/NNS ./.)
ID= 7.3.22
Summary= GetFunctionRealm ( obj )
*0*assert: VARobj is a callable object. 
*0*(S assert/NN :/: (Chunk VARobj/NNP) is/VBZ a/DT callable/JJ object/NN ./.)
*0*if VARobj has a [[REALM]] internal slot, then
*0*(S if/IN (Chunk VARobj/NNP) has/VBZ a/DT [/JJ (Chunk [/NNP) (Chunk REALM/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, then/RB)
*1*return VARobj.[[REALM]]. 
*1*(S return/NN (Chunk VARobj/NNP) ./. [/VB [/JJ (Chunk REALM/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARobj is a bound function exotic object, then
*0*(S if/IN (Chunk VARobj/NNP) is/VBZ a/DT bound/NN function/NN exotic/JJ object/NN ,/, then/RB)
*1*let VARtarget be VARobj.[[BOUNDTARGETFUNCTION]]. 
*1*(S (Chunk let/VB VARtarget/NNP) (Chunk be/VB VARobj/NNP) ./. [/VB [/JJ (Chunk BOUNDTARGETFUNCTION/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*return ? FUNCgetfunctionrealm(VARtarget). 
*1*(S return/NN ?/. (Chunk FUNCgetfunctionrealm/NNP) (/( (Chunk VARtarget/NNP) )/) ./.)
*0*if VARobj is a proxy exotic object, then
*0*(S if/IN (Chunk VARobj/NNP) is/VBZ a/DT proxy/JJ exotic/JJ object/NN ,/, then/RB)
*1*if VARobj.[[PROXYHANDLER]] is null, throw a typeerror exception. 
*1*(S if/IN (Chunk VARobj/NNP) ./. [/VB [/JJ (Chunk PROXYHANDLER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*let VARproxytarget be VARobj.[[PROXYTARGET]]. 
*1*(S (Chunk let/VB VARproxytarget/NNP) (Chunk be/VB VARobj/NNP) ./. [/VB [/JJ (Chunk PROXYTARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*return ? FUNCgetfunctionrealm(VARproxytarget). 
*1*(S return/NN ?/. (Chunk FUNCgetfunctionrealm/NNP) (/( (Chunk VARproxytarget/NNP) )/) ./.)
*0*return the current realm record.    
*0*(S return/VB the/DT current/JJ realm/NN record/NN ./.)
ID= 7.3.23
Summary= CopyDataProperties ( target, source, excludedItems )
*0*assert: FUNCtype(VARtarget) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ object/JJ ./.)
*0*assert: VARexcludeditems is a list of property keys. 
*0*(S assert/NN :/: (Chunk VARexcludeditems/NNP) is/VBZ a/DT list/NN of/IN property/NN keys/NNS ./.)
*0*if VARsource is undefined or null, return VARtarget. 
*0*(S if/IN (Chunk VARsource/NNP) is/VBZ undefined/JJ or/CC null/JJ ,/, (Chunk return/VB VARtarget/NNP) ./.)
*0*let VARfrom be ! FUNCtoobject(VARsource). 
*0*(S (Chunk let/VB VARfrom/NNP) be/VB !/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARsource/NNP) )/) ./.)
*0*let VARkeys be ? VARfrom.[[OWNPROPERTYKEYS]](). 
*0*(S (Chunk let/VB VARkeys/NNP) be/VB ?/. (Chunk VARfrom/NNP) ./. [/VB [/JJ (Chunk OWNPROPERTYKEYS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*0*for each element VARnextkey of VARkeys in list order, do
*0*(S for/IN each/DT element/NN (Chunk VARnextkey/NNP) of/IN (Chunk VARkeys/NNP) in/IN list/NN order/NN ,/, do/VBP)
*1*let VARexcluded be false. 
*1*(S (Chunk let/VB VARexcluded/NNP) be/VB false/JJ ./.)
*1*for each element VARe of VARexcludeditems in list order, do
*1*(S for/IN each/DT element/NN (Chunk VARe/NNP) of/IN (Chunk VARexcludeditems/NNP) in/IN list/NN order/NN ,/, do/VBP)
*2*if FUNCsamevalue(VARe, VARnextkey) is true, then
*2*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARe/NNP) ,/, (Chunk VARnextkey/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*3*set VARexcluded to true. 
*3*(S set/NN VARexcluded/VBD to/TO true/JJ ./.)
*1*if VARexcluded is false, then
*1*(S if/IN VARexcluded/VBN is/VBZ false/JJ ,/, then/RB)
*2*let VARdesc be ? VARfrom.[[GETOWNPROPERTY]](VARnextkey). 
*2*(S (Chunk let/VB VARdesc/NNP) be/VB ?/. (Chunk VARfrom/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARnextkey/NNP) )/) ./.)
*2*if VARdesc is not undefined and VARdesc.[[ENUMERABLE]] is true, then
*2*(S if/IN (Chunk VARdesc/NNP) is/VBZ not/RB undefined/JJ and/CC (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ true/JJ ,/, then/RB)
*3*let VARpropvalue be ? FUNCget(VARfrom, VARnextkey). 
*3*(S (Chunk let/VB VARpropvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARfrom/NNP) ,/, (Chunk VARnextkey/NNP) )/) ./.)
*3*perform ! FUNCcreatedataproperty(VARtarget, VARnextkey, VARpropvalue). 
*3*(S perform/NN !/. (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARtarget/NNP) ,/, (Chunk VARnextkey/NNP) ,/, (Chunk VARpropvalue/NNP) )/) ./.)
*0*return VARtarget.    
*0*(S return/NN (Chunk VARtarget/NNP) ./.)
ID= 7.4.1
Summary= GetIterator ( obj [ , hint [ , method ] ] )
*0*if VARhint is not present, set VARhint to sync. 
*0*(S if/IN (Chunk VARhint/NNP) is/VBZ not/RB present/JJ ,/, (Chunk set/VBN VARhint/NNP) to/TO sync/VB ./.)
*0*assert: VARhint is either sync or async. 
*0*(S assert/NN :/: VARhint/NN is/VBZ either/DT sync/NN or/CC async/NN ./.)
*0*if VARmethod is not present, then
*0*(S if/IN (Chunk VARmethod/NNP) is/VBZ not/RB present/JJ ,/, then/RB)
*1*if VARhint is async, then
*1*(S if/IN (Chunk VARhint/NNP) is/VBZ async/RB ,/, then/RB)
*2*set VARmethod to ? FUNCgetmethod(VARobj, @@asynciterator). 
*2*(S (Chunk set/VBN VARmethod/NNP) to/TO ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARobj/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) asynciterator/NN )/) ./.)
*2*if VARmethod is undefined, then
*2*(S if/IN (Chunk VARmethod/NNP) is/VBZ undefined/VBN ,/, then/RB)
*3*let VARsyncmethod be ? FUNCgetmethod(VARobj, @@iterator). 
*3*(S (Chunk let/VB VARsyncmethod/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARobj/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) iterator/NN )/) ./.)
*3*let VARsynciteratorrecord be ? FUNCgetiterator(VARobj, sync, VARsyncmethod). 
*3*(S (Chunk let/VB VARsynciteratorrecord/NNP) be/VB ?/. (Chunk FUNCgetiterator/NNP) (/( (Chunk VARobj/NNP) ,/, sync/NN ,/, (Chunk VARsyncmethod/NNP) )/) ./.)
*3*return ? FUNCcreateasyncfromsynciterator(VARsynciteratorrecord). 
*3*(S return/NN ?/. (Chunk FUNCcreateasyncfromsynciterator/NNP) (/( (Chunk VARsynciteratorrecord/NNP) )/) ./.)
*1*otherwise, set VARmethod to ? FUNCgetmethod(VARobj, @@iterator). 
*1*(S otherwise/RB ,/, (Chunk set/VBD VARmethod/NNP) to/TO ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARobj/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) iterator/NN )/) ./.)
*0*let VARiterator be ? FUNCcall(VARmethod, VARobj). 
*0*(S (Chunk let/VB VARiterator/NNP) be/VB ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARmethod/NNP) ,/, (Chunk VARobj/NNP) )/) ./.)
*0*if FUNCtype(VARiterator) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARiterator/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARnextmethod be ? FUNCgetv(VARiterator, "next"). 
*0*(S (Chunk let/VB VARnextmethod/NNP) be/VB ?/. (Chunk FUNCgetv/NNP) (/( (Chunk VARiterator/NNP) ,/, ``/`` next/JJ ''/'' )/) ./.)
*0*let VARiteratorrecord be record { [[ITERATOR]]: VARiterator, [[NEXTMETHOD]]: VARnextmethod, [[DONE]]: false }. 
*0*(S (Chunk let/VB VARiteratorrecord/NNP) be/VB record/JJ {/( [/JJ (Chunk [/NNP) (Chunk ITERATOR/NNP) (Chunk ]/NNP) ]/NN :/: VARiterator/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk NEXTMETHOD/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARnextmethod/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk DONE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) ./.)
*0*return VARiteratorrecord.    
*0*(S return/NN (Chunk VARiteratorrecord/NNP) ./.)
ID= 7.4.2
Summary= IteratorNext ( iteratorRecord [ , value ] )
*0*if VARvalue is not present, then
*0*(S if/IN (Chunk VARvalue/NNP) is/VBZ not/RB present/JJ ,/, then/RB)
*1*let VARresult be ? FUNCcall(VARiteratorrecord.[[NEXTMETHOD]], VARiteratorrecord.[[ITERATOR]], « »). 
*1*(S (Chunk let/VB VARresult/NNP) be/VB ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARiteratorrecord/NNP) ./. [/VB [/JJ (Chunk NEXTMETHOD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARiteratorrecord/NNP) ./. [/VB [/JJ (Chunk ITERATOR/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk «/NNP) (Chunk »/NNP) )/) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARresult be ? FUNCcall(VARiteratorrecord.[[NEXTMETHOD]], VARiteratorrecord.[[ITERATOR]], « VARvalue »). 
*1*(S (Chunk let/VB VARresult/NNP) be/VB ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARiteratorrecord/NNP) ./. [/VB [/JJ (Chunk NEXTMETHOD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARiteratorrecord/NNP) ./. [/VB [/JJ (Chunk ITERATOR/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk «/NNP) (Chunk VARvalue/NNP) (Chunk »/NNP) )/) ./.)
*0*if FUNCtype(VARresult) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARresult/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARresult.    
*0*(S return/NN (Chunk VARresult/NNP) ./.)
ID= 7.4.3
Summary= IteratorComplete ( iterResult )
*0*assert: FUNCtype(VARiterresult) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARiterresult/NNP) )/) is/VBZ object/JJ ./.)
*0*return FUNCtoboolean(? FUNCget(VARiterresult, "done")).    
*0*(S return/NN (Chunk FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARiterresult/NNP) ,/, ``/`` done/VBN ''/'' )/) )/) ./.)
ID= 7.4.4
Summary= IteratorValue ( iterResult )
*0*assert: FUNCtype(VARiterresult) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARiterresult/NNP) )/) is/VBZ object/JJ ./.)
*0*return ? FUNCget(VARiterresult, "value").    
*0*(S return/NN ?/. (Chunk FUNCget/NNP) (/( (Chunk VARiterresult/NNP) ,/, ``/`` value/NN ''/'' )/) ./.)
ID= 7.4.5
Summary= IteratorStep ( iteratorRecord )
*0*let VARresult be ? FUNCiteratornext(VARiteratorrecord). 
*0*(S (Chunk let/VB VARresult/NNP) be/VB ?/. (Chunk FUNCiteratornext/NNP) (/( (Chunk VARiteratorrecord/NNP) )/) ./.)
*0*let VARdone be ? FUNCiteratorcomplete(VARresult). 
*0*(S (Chunk let/VB VARdone/NNP) be/VB ?/. (Chunk FUNCiteratorcomplete/NNP) (/( (Chunk VARresult/NNP) )/) ./.)
*0*if VARdone is true, return false. 
*0*(S if/IN (Chunk VARdone/NNP) is/VBZ true/JJ ,/, return/NN false/JJ ./.)
*0*return VARresult.    
*0*(S return/NN (Chunk VARresult/NNP) ./.)
ID= 7.4.6
Summary= IteratorClose ( iteratorRecord, completion )
*0*assert: FUNCtype(VARiteratorrecord.[[ITERATOR]]) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARiteratorrecord/NNP) ./. [/VB [/JJ (Chunk ITERATOR/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) is/VBZ object/JJ ./.)
*0*assert: VARcompletion is a completion record. 
*0*(S assert/NN :/: VARcompletion/NN is/VBZ a/DT completion/NN record/NN ./.)
*0*let VARiterator be VARiteratorrecord.[[ITERATOR]]. 
*0*(S (Chunk let/VB VARiterator/NNP) (Chunk be/VB VARiteratorrecord/NNP) ./. [/VB [/JJ (Chunk ITERATOR/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARreturn be ? FUNCgetmethod(VARiterator, "return"). 
*0*(S (Chunk let/VB VARreturn/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARiterator/NNP) ,/, ``/`` return/NN ''/'' )/) ./.)
*0*if VARreturn is undefined, return FUNCcompletion(VARcompletion). 
*0*(S if/IN (Chunk VARreturn/NNP) is/VBZ undefined/JJ ,/, return/JJ (Chunk FUNCcompletion/NNP) (/( (Chunk VARcompletion/NNP) )/) ./.)
*0*let VARinnerresult be FUNCcall(VARreturn, VARiterator, « »). 
*0*(S (Chunk let/VB VARinnerresult/NNP) (Chunk be/VB FUNCcall/NNP) (/( (Chunk VARreturn/NNP) ,/, (Chunk VARiterator/NNP) ,/, (Chunk «/NNP) (Chunk »/NNP) )/) ./.)
*0*if VARcompletion.[[TYPE]] is throw, return FUNCcompletion(VARcompletion). 
*0*(S if/IN (Chunk VARcompletion/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ throw/JJ ,/, return/JJ (Chunk FUNCcompletion/NNP) (/( (Chunk VARcompletion/NNP) )/) ./.)
*0*if VARinnerresult.[[TYPE]] is throw, return FUNCcompletion(VARinnerresult). 
*0*(S if/IN (Chunk VARinnerresult/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ throw/JJ ,/, return/JJ (Chunk FUNCcompletion/NNP) (/( (Chunk VARinnerresult/NNP) )/) ./.)
*0*if FUNCtype(VARinnerresult.[[VALUE]]) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARinnerresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return FUNCcompletion(VARcompletion).    
*0*(S return/NN (Chunk FUNCcompletion/NNP) (/( (Chunk VARcompletion/NNP) )/) ./.)
ID= 7.4.7
Summary= AsyncIteratorClose ( iteratorRecord, completion )
*0*assert: FUNCtype(VARiteratorrecord.[[ITERATOR]]) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARiteratorrecord/NNP) ./. [/VB [/JJ (Chunk ITERATOR/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) is/VBZ object/JJ ./.)
*0*assert: VARcompletion is a completion record. 
*0*(S assert/NN :/: VARcompletion/NN is/VBZ a/DT completion/NN record/NN ./.)
*0*let VARiterator be VARiteratorrecord.[[ITERATOR]]. 
*0*(S (Chunk let/VB VARiterator/NNP) (Chunk be/VB VARiteratorrecord/NNP) ./. [/VB [/JJ (Chunk ITERATOR/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARreturn be ? FUNCgetmethod(VARiterator, "return"). 
*0*(S (Chunk let/VB VARreturn/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARiterator/NNP) ,/, ``/`` return/NN ''/'' )/) ./.)
*0*if VARreturn is undefined, return FUNCcompletion(VARcompletion). 
*0*(S if/IN (Chunk VARreturn/NNP) is/VBZ undefined/JJ ,/, return/JJ (Chunk FUNCcompletion/NNP) (/( (Chunk VARcompletion/NNP) )/) ./.)
*0*let VARinnerresult be FUNCcall(VARreturn, VARiterator, « »). 
*0*(S (Chunk let/VB VARinnerresult/NNP) (Chunk be/VB FUNCcall/NNP) (/( (Chunk VARreturn/NNP) ,/, (Chunk VARiterator/NNP) ,/, (Chunk «/NNP) (Chunk »/NNP) )/) ./.)
*0*if VARinnerresult.[[TYPE]] is normal, set VARinnerresult to await(VARinnerresult.[[VALUE]]). 
*0*(S if/IN (Chunk VARinnerresult/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ normal/JJ ,/, (Chunk set/VBN VARinnerresult/NNP) to/TO await/VB (/( (Chunk VARinnerresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*0*if VARcompletion.[[TYPE]] is throw, return FUNCcompletion(VARcompletion). 
*0*(S if/IN (Chunk VARcompletion/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ throw/JJ ,/, return/JJ (Chunk FUNCcompletion/NNP) (/( (Chunk VARcompletion/NNP) )/) ./.)
*0*if VARinnerresult.[[TYPE]] is throw, return FUNCcompletion(VARinnerresult). 
*0*(S if/IN (Chunk VARinnerresult/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ throw/JJ ,/, return/JJ (Chunk FUNCcompletion/NNP) (/( (Chunk VARinnerresult/NNP) )/) ./.)
*0*if FUNCtype(VARinnerresult.[[VALUE]]) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARinnerresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return FUNCcompletion(VARcompletion).    
*0*(S return/NN (Chunk FUNCcompletion/NNP) (/( (Chunk VARcompletion/NNP) )/) ./.)
ID= 7.4.8
Summary= CreateIterResultObject ( value, done )
*0*assert: FUNCtype(VARdone) is boolean. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARdone/NNP) )/) is/VBZ boolean/JJ ./.)
*0*let VARobj be FUNCobjectcreate(%objectprototype%). 
*0*(S (Chunk let/VB VARobj/NNP) (Chunk be/VB FUNCobjectcreate/NNP) (/( %/NN objectprototype/IN %/NN )/) ./.)
*0*perform FUNCcreatedataproperty(VARobj, "value", VARvalue). 
*0*(S perform/NN (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` value/NN ''/'' ,/, (Chunk VARvalue/NNP) )/) ./.)
*0*perform FUNCcreatedataproperty(VARobj, "done", VARdone). 
*0*(S perform/NN (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` done/VBN ''/'' ,/, (Chunk VARdone/NNP) )/) ./.)
*0*return VARobj.    
*0*(S return/NN (Chunk VARobj/NNP) ./.)
ID= 7.4.9
Summary= CreateListIteratorRecord ( list )
*0*let VARiterator be FUNCobjectcreate(%iteratorprototype%, « [[ITERATEDLIST]], [[LISTITERATORNEXTINDEX]] »). 
*0*(S (Chunk let/VB VARiterator/NNP) (Chunk be/VB FUNCobjectcreate/NNP) (/( %/NN iteratorprototype/NN %/NN ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk ITERATEDLIST/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk LISTITERATORNEXTINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARiterator.[[ITERATEDLIST]] to VARlist. 
*0*(S (Chunk set/VBN VARiterator/NNP) ./. [/VB [/JJ (Chunk ITERATEDLIST/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARlist/NNP) ./.)
*0*set VARiterator.[[LISTITERATORNEXTINDEX]] to 0. 
*0*(S (Chunk set/VBN VARiterator/NNP) ./. [/VB [/JJ (Chunk LISTITERATORNEXTINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO 0/CD ./.)
*0*let VARsteps be the algorithm steps defined in listiterator next (7.4.9.1). 
*0*(S (Chunk let/VB VARsteps/NNP) be/VB the/DT algorithm/JJ steps/NNS defined/VBN in/IN listiterator/NN next/JJ (/( 7.4.9.1/CD )/) ./.)
*0*let VARnext be FUNCcreatebuiltinfunction(VARsteps, « »). 
*0*(S (Chunk let/VB VARnext/NNP) (Chunk be/VB FUNCcreatebuiltinfunction/NNP) (/( (Chunk VARsteps/NNP) ,/, (Chunk «/NNP) (Chunk »/NNP) )/) ./.)
*0*return record { [[ITERATOR]]: VARiterator, [[NEXTMETHOD]]: VARnext, [[DONE]]: false }.    
*0*(S return/NN record/NN {/( [/JJ (Chunk [/NNP) (Chunk ITERATOR/NNP) (Chunk ]/NNP) ]/NN :/: VARiterator/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk NEXTMETHOD/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARnext/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk DONE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) ./.)
ID= 7.4.9.1
Summary= ListIterator next ( )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*assert: FUNCtype(VARo) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ object/JJ ./.)
*0*assert: VARo has an [[ITERATEDLIST]] internal slot. 
*0*(S assert/NN :/: (Chunk VARo/NNP) has/VBZ an/DT [/JJ [/JJ (Chunk ITERATEDLIST/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*let VARlist be VARo.[[ITERATEDLIST]]. 
*0*(S (Chunk let/VB VARlist/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk ITERATEDLIST/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARindex be VARo.[[LISTITERATORNEXTINDEX]]. 
*0*(S (Chunk let/VB VARindex/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk LISTITERATORNEXTINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARlen be the number of elements of VARlist. 
*0*(S (Chunk let/VB VARlen/NNP) be/VB the/DT number/NN of/IN elements/NNS of/IN (Chunk VARlist/NNP) ./.)
*0*if VARindex ≥ VARlen, then
*0*(S if/IN (Chunk VARindex/NNP) (Chunk ≥/NNP) (Chunk VARlen/NNP) ,/, then/RB)
*1*return FUNCcreateiterresultobject(undefined, true). 
*1*(S return/NN (Chunk FUNCcreateiterresultobject/NNP) (/( undefined/JJ ,/, true/JJ )/) ./.)
*0*set VARo.[[LISTITERATORNEXTINDEX]] to VARindex+1. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk LISTITERATORNEXTINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARindex+1/NNP) ./.)
*0*return FUNCcreateiterresultobject(VARlist[VARindex], false).     
*0*(S return/NN (Chunk FUNCcreateiterresultobject/NNP) (/( (Chunk VARlist/NNP) (Chunk [/NNP) (Chunk VARindex/NNP) (Chunk ]/NNP) ,/, false/RB )/) ./.)
ID= 8.1.1.1.1
Summary= HasBinding ( N )
*0*let VARenvrec be the declarative environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT declarative/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*if VARenvrec has a binding for the name that is the value of VARn, return true. 
*0*(S if/IN (Chunk VARenvrec/NNP) has/VBZ a/DT binding/NN for/IN the/DT name/NN that/WDT is/VBZ the/DT value/NN of/IN (Chunk VARn/NNP) ,/, return/NN true/JJ ./.)
*0*return false.      
*0*(S return/NN false/JJ ./.)
ID= 8.1.1.1.2
Summary= CreateMutableBinding ( N, D )
*0*let VARenvrec be the declarative environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT declarative/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*assert: VARenvrec does not already have a binding for VARn. 
*0*(S assert/NN :/: VARenvrec/NN does/VBZ not/RB already/RB have/VB a/DT binding/NN for/IN (Chunk VARn/NNP) ./.)
*0*create a mutable binding in VARenvrec for VARn and record that it is uninitialized. if VARd is true, record that the newly created binding may be deleted by a subsequent deletebinding call. 
*0*(S create/VB a/DT mutable/JJ binding/NN in/IN (Chunk VARenvrec/NNP) for/IN (Chunk VARn/NNP) and/CC record/NN that/IN it/PRP is/VBZ uninitialized/JJ ./. if/IN (Chunk VARd/NNP) is/VBZ true/JJ ,/, record/NN that/IN the/DT newly/RB created/VBN binding/NN may/MD be/VB deleted/VBN by/IN a/DT subsequent/JJ deletebinding/NN call/NN ./.)
*0*return FUNCnormalcompletion(empty).      
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( empty/JJ )/) ./.)
ID= 8.1.1.1.3
Summary= CreateImmutableBinding ( N, S )
*0*let VARenvrec be the declarative environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT declarative/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*assert: VARenvrec does not already have a binding for VARn. 
*0*(S assert/NN :/: VARenvrec/NN does/VBZ not/RB already/RB have/VB a/DT binding/NN for/IN (Chunk VARn/NNP) ./.)
*0*create an immutable binding in VARenvrec for VARn and record that it is uninitialized. if VARs is true, record that the newly created binding is a strict binding. 
*0*(S create/VB an/DT immutable/JJ binding/NN in/IN (Chunk VARenvrec/NNP) for/IN (Chunk VARn/NNP) and/CC record/NN that/IN it/PRP is/VBZ uninitialized/JJ ./. if/IN (Chunk VARs/NNP) is/VBZ true/JJ ,/, record/NN that/IN the/DT newly/RB created/VBN binding/NN is/VBZ a/DT strict/JJ binding/NN ./.)
*0*return FUNCnormalcompletion(empty).      
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( empty/JJ )/) ./.)
ID= 8.1.1.1.4
Summary= InitializeBinding ( N, V )
*0*let VARenvrec be the declarative environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT declarative/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*assert: VARenvrec must have an uninitialized binding for VARn. 
*0*(S assert/NN :/: (Chunk VARenvrec/NNP) must/MD have/VB an/DT uninitialized/JJ binding/NN for/IN (Chunk VARn/NNP) ./.)
*0*set the bound value for VARn in VARenvrec to VARv. 
*0*(S set/VB the/DT bound/NN value/NN for/IN (Chunk VARn/NNP) in/IN (Chunk VARenvrec/NNP) to/TO (Chunk VARv/NNP) ./.)
*0*record that the binding for VARn in VARenvrec has been initialized. 
*0*(S record/NN that/IN the/DT binding/NN for/IN (Chunk VARn/NNP) in/IN (Chunk VARenvrec/NNP) has/VBZ been/VBN initialized/VBN ./.)
*0*return FUNCnormalcompletion(empty).      
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( empty/JJ )/) ./.)
ID= 8.1.1.1.5
Summary= SetMutableBinding ( N, V, S )
*0*let VARenvrec be the declarative environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT declarative/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*if VARenvrec does not have a binding for VARn, then
*0*(S if/IN (Chunk VARenvrec/NNP) does/VBZ not/RB have/VB a/DT binding/NN for/IN (Chunk VARn/NNP) ,/, then/RB)
*1*if VARs is true, throw a referenceerror exception. 
*1*(S if/IN (Chunk VARs/NNP) is/VBZ true/JJ ,/, throw/VB a/DT referenceerror/NN exception/NN ./.)
*1*perform VARenvrec.createmutablebinding(VARn, true). 
*1*(S perform/NN (Chunk VARenvrec.createmutablebinding/NNP) (/( (Chunk VARn/NNP) ,/, true/JJ )/) ./.)
*1*perform VARenvrec.initializebinding(VARn, VARv). 
*1*(S perform/NN (Chunk VARenvrec.initializebinding/NNP) (/( (Chunk VARn/NNP) ,/, (Chunk VARv/NNP) )/) ./.)
*1*return FUNCnormalcompletion(empty). 
*1*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( empty/JJ )/) ./.)
*0*if the binding for VARn in VARenvrec is a strict binding, set VARs to true. 
*0*(S if/IN the/DT binding/NN for/IN (Chunk VARn/NNP) in/IN (Chunk VARenvrec/NNP) is/VBZ a/DT strict/JJ binding/NN ,/, (Chunk set/VBN VARs/NNP) to/TO true/JJ ./.)
*0*if the binding for VARn in VARenvrec has not yet been initialized, throw a referenceerror exception. 
*0*(S if/IN the/DT binding/NN for/IN (Chunk VARn/NNP) in/IN (Chunk VARenvrec/NNP) has/VBZ not/RB yet/RB been/VBN initialized/VBN ,/, throw/VB a/DT referenceerror/NN exception/NN ./.)
*0*else if the binding for VARn in VARenvrec is a mutable binding, change its bound value to VARv. 
*0*(S else/RB if/IN the/DT binding/NN for/IN (Chunk VARn/NNP) in/IN (Chunk VARenvrec/NNP) is/VBZ a/DT mutable/JJ binding/NN ,/, change/VB its/PRP$ bound/NN value/NN to/TO (Chunk VARv/NNP) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*assert: this is an attempt to change the value of an immutable binding. 
*1*(S assert/NN :/: this/DT is/VBZ an/DT attempt/NN to/TO change/VB the/DT value/NN of/IN an/DT immutable/JJ binding/NN ./.)
*1*if VARs is true, throw a typeerror exception. 
*1*(S if/IN (Chunk VARs/NNP) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return FUNCnormalcompletion(empty).      
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( empty/JJ )/) ./.)
ID= 8.1.1.1.6
Summary= GetBindingValue ( N, S )
*0*let VARenvrec be the declarative environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT declarative/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*assert: VARenvrec has a binding for VARn. 
*0*(S assert/NN :/: (Chunk VARenvrec/NNP) has/VBZ a/DT binding/NN for/IN (Chunk VARn/NNP) ./.)
*0*if the binding for VARn in VARenvrec is an uninitialized binding, throw a referenceerror exception. 
*0*(S if/IN the/DT binding/NN for/IN (Chunk VARn/NNP) in/IN (Chunk VARenvrec/NNP) is/VBZ an/DT uninitialized/JJ binding/NN ,/, throw/VB a/DT referenceerror/NN exception/NN ./.)
*0*return the value currently bound to VARn in VARenvrec.      
*0*(S return/VB the/DT value/NN currently/RB bound/IN to/TO (Chunk VARn/NNP) in/IN (Chunk VARenvrec/NNP) ./.)
ID= 8.1.1.1.7
Summary= DeleteBinding ( N )
*0*let VARenvrec be the declarative environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT declarative/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*assert: VARenvrec has a binding for the name that is the value of VARn. 
*0*(S assert/NN :/: (Chunk VARenvrec/NNP) has/VBZ a/DT binding/NN for/IN the/DT name/NN that/WDT is/VBZ the/DT value/NN of/IN (Chunk VARn/NNP) ./.)
*0*if the binding for VARn in VARenvrec cannot be deleted, return false. 
*0*(S if/IN the/DT binding/NN for/IN (Chunk VARn/NNP) in/IN (Chunk VARenvrec/NNP) can/MD not/RB be/VB deleted/VBN ,/, return/VB false/JJ ./.)
*0*remove the binding for VARn from VARenvrec. 
*0*(S remove/VB the/DT binding/NN for/IN (Chunk VARn/NNP) from/IN (Chunk VARenvrec/NNP) ./.)
*0*return true.      
*0*(S return/NN true/JJ ./.)
ID= 8.1.1.1.8
Summary= HasThisBinding ( )
*0*return false.      
*0*(S return/NN false/JJ ./.)
ID= 8.1.1.1.9
Summary= HasSuperBinding ( )
*0*return false.      
*0*(S return/NN false/JJ ./.)
ID= 8.1.1.1.10
Summary= WithBaseObject ( )
*0*return undefined.      
*0*(S return/NN undefined/VBD ./.)
ID= 8.1.1.2.1
Summary= HasBinding ( N )
*0*let VARenvrec be the object environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT object/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*let VARbindings be the binding object for VARenvrec. 
*0*(S let/VB VARbindings/NNS be/VB the/DT binding/NN object/NN for/IN (Chunk VARenvrec/NNP) ./.)
*0*let VARfoundbinding be ? FUNChasproperty(VARbindings, VARn). 
*0*(S let/VB VARfoundbinding/VBG be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARbindings/NNP) ,/, (Chunk VARn/NNP) )/) ./.)
*0*if VARfoundbinding is false, return false. 
*0*(S if/IN (Chunk VARfoundbinding/NNP) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*0*if the VARwithenvironment flag of VARenvrec is false, return true. 
*0*(S if/IN the/DT (Chunk VARwithenvironment/NNP) flag/NN of/IN (Chunk VARenvrec/NNP) is/VBZ false/JJ ,/, return/VB true/JJ ./.)
*0*let VARunscopables be ? FUNCget(VARbindings, @@unscopables). 
*0*(S (Chunk let/VB VARunscopables/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARbindings/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) unscopables/NNS )/) ./.)
*0*if FUNCtype(VARunscopables) is object, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARunscopables/NNP) )/) is/VBZ object/JJ ,/, then/RB)
*1*let VARblocked be FUNCtoboolean(? FUNCget(VARunscopables, VARn)). 
*1*(S (Chunk let/VB VARblocked/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARunscopables/NNP) ,/, (Chunk VARn/NNP) )/) )/) ./.)
*1*if VARblocked is true, return false. 
*1*(S if/IN VARblocked/VBN is/VBZ true/JJ ,/, return/NN false/JJ ./.)
*0*return true.      
*0*(S return/NN true/JJ ./.)
ID= 8.1.1.2.2
Summary= CreateMutableBinding ( N, D )
*0*let VARenvrec be the object environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT object/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*let VARbindings be the binding object for VARenvrec. 
*0*(S let/VB VARbindings/NNS be/VB the/DT binding/NN object/NN for/IN (Chunk VARenvrec/NNP) ./.)
*0*return ? FUNCdefinepropertyorthrow(VARbindings, VARn, propertydescriptor { [[VALUE]]: undefined, [[WRITABLE]]: true, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: VARd }).      
*0*(S return/NN ?/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARbindings/NNP) ,/, (Chunk VARn/NNP) ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: undefined/JJ ,/, [/JJ (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARd/NNP) }/) )/) ./.)
ID= 8.1.1.2.4
Summary= InitializeBinding ( N, V )
*0*let VARenvrec be the object environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT object/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*assert: VARenvrec must have an uninitialized binding for VARn. 
*0*(S assert/NN :/: (Chunk VARenvrec/NNP) must/MD have/VB an/DT uninitialized/JJ binding/NN for/IN (Chunk VARn/NNP) ./.)
*0*record that the binding for VARn in VARenvrec has been initialized. 
*0*(S record/NN that/IN the/DT binding/NN for/IN (Chunk VARn/NNP) in/IN (Chunk VARenvrec/NNP) has/VBZ been/VBN initialized/VBN ./.)
*0*return ? VARenvrec.setmutablebinding(VARn, VARv, false).      
*0*(S return/NN ?/. (Chunk VARenvrec.setmutablebinding/NNP) (/( (Chunk VARn/NNP) ,/, (Chunk VARv/NNP) ,/, false/RB )/) ./.)
ID= 8.1.1.2.5
Summary= SetMutableBinding ( N, V, S )
*0*let VARenvrec be the object environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT object/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*let VARbindings be the binding object for VARenvrec. 
*0*(S let/VB VARbindings/NNS be/VB the/DT binding/NN object/NN for/IN (Chunk VARenvrec/NNP) ./.)
*0*return ? FUNCset(VARbindings, VARn, VARv, VARs).      
*0*(S return/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARbindings/NNP) ,/, (Chunk VARn/NNP) ,/, (Chunk VARv/NNP) ,/, (Chunk VARs/NNP) )/) ./.)
ID= 8.1.1.2.6
Summary= GetBindingValue ( N, S )
*0*let VARenvrec be the object environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT object/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*let VARbindings be the binding object for VARenvrec. 
*0*(S let/VB VARbindings/NNS be/VB the/DT binding/NN object/NN for/IN (Chunk VARenvrec/NNP) ./.)
*0*let VARvalue be ? FUNChasproperty(VARbindings, VARn). 
*0*(S (Chunk let/VB VARvalue/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARbindings/NNP) ,/, (Chunk VARn/NNP) )/) ./.)
*0*if VARvalue is false, then
*0*(S if/IN (Chunk VARvalue/NNP) is/VBZ false/JJ ,/, then/RB)
*1*if VARs is false, return the value undefined; otherwise throw a referenceerror exception. 
*1*(S if/IN (Chunk VARs/NNP) is/VBZ false/JJ ,/, return/VB the/DT value/NN undefined/VBD ;/: otherwise/RB throw/VB a/DT referenceerror/NN exception/NN ./.)
*0*return ? FUNCget(VARbindings, VARn).      
*0*(S return/NN ?/. (Chunk FUNCget/NNP) (/( (Chunk VARbindings/NNP) ,/, (Chunk VARn/NNP) )/) ./.)
ID= 8.1.1.2.7
Summary= DeleteBinding ( N )
*0*let VARenvrec be the object environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT object/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*let VARbindings be the binding object for VARenvrec. 
*0*(S let/VB VARbindings/NNS be/VB the/DT binding/NN object/NN for/IN (Chunk VARenvrec/NNP) ./.)
*0*return ? VARbindings.[[DELETE]](VARn).      
*0*(S return/NN ?/. VARbindings/NNS ./. [/VB [/JJ (Chunk DELETE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARn/NNP) )/) ./.)
ID= 8.1.1.2.8
Summary= HasThisBinding ( )
*0*return false.      
*0*(S return/NN false/JJ ./.)
ID= 8.1.1.2.9
Summary= HasSuperBinding ( )
*0*return false.      
*0*(S return/NN false/JJ ./.)
ID= 8.1.1.2.10
Summary= WithBaseObject ( )
*0*let VARenvrec be the object environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT object/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*if the VARwithenvironment flag of VARenvrec is true, return the binding object for VARenvrec. 
*0*(S if/IN the/DT (Chunk VARwithenvironment/NNP) flag/NN of/IN (Chunk VARenvrec/NNP) is/VBZ true/JJ ,/, return/VB the/DT binding/NN object/NN for/IN (Chunk VARenvrec/NNP) ./.)
*0*otherwise, return undefined.      
*0*(S otherwise/RB ,/, return/NN undefined/VBD ./.)
ID= 8.1.1.3.1
Summary= BindThisValue ( V )
*0*let VARenvrec be the function environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT function/NN environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*assert: VARenvrec.[[THISBINDINGSTATUS]] is not "lexical". 
*0*(S assert/NN :/: (Chunk VARenvrec/NNP) ./. [/VB [/JJ (Chunk THISBINDINGSTATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB ``/`` lexical/JJ ''/'' ./.)
*0*if VARenvrec.[[THISBINDINGSTATUS]] is "initialized", throw a referenceerror exception. 
*0*(S if/IN (Chunk VARenvrec/NNP) ./. [/VB [/JJ (Chunk THISBINDINGSTATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` initialized/JJ ''/'' ,/, throw/VB a/DT referenceerror/NN exception/NN ./.)
*0*set VARenvrec.[[THISVALUE]] to VARv. 
*0*(S (Chunk set/VBN VARenvrec/NNP) ./. [/VB [/JJ (Chunk THISVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARv/NNP) ./.)
*0*set VARenvrec.[[THISBINDINGSTATUS]] to "initialized". 
*0*(S (Chunk set/VBN VARenvrec/NNP) ./. [/VB [/JJ (Chunk THISBINDINGSTATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` initialized/VBN ''/'' ./.)
*0*return VARv.      
*0*(S return/NN (Chunk VARv/NNP) ./.)
ID= 8.1.1.3.2
Summary= HasThisBinding ( )
*0*let VARenvrec be the function environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT function/NN environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*if VARenvrec.[[THISBINDINGSTATUS]] is "lexical", return false; otherwise, return true.      
*0*(S if/IN (Chunk VARenvrec/NNP) ./. [/VB [/JJ (Chunk THISBINDINGSTATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` lexical/JJ ''/'' ,/, return/VB false/JJ ;/: otherwise/RB ,/, return/NN true/JJ ./.)
ID= 8.1.1.3.3
Summary= HasSuperBinding ( )
*0*let VARenvrec be the function environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT function/NN environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*if VARenvrec.[[THISBINDINGSTATUS]] is "lexical", return false. 
*0*(S if/IN (Chunk VARenvrec/NNP) ./. [/VB [/JJ (Chunk THISBINDINGSTATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` lexical/JJ ''/'' ,/, return/NN false/JJ ./.)
*0*if VARenvrec.[[HOMEOBJECT]] has the value undefined, return false; otherwise, return true.      
*0*(S if/IN (Chunk VARenvrec/NNP) ./. [/VB [/JJ (Chunk HOMEOBJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) has/VBZ the/DT value/NN undefined/VBD ,/, return/NN false/RB ;/: otherwise/RB ,/, return/NN true/JJ ./.)
ID= 8.1.1.3.4
Summary= GetThisBinding ( )
*0*let VARenvrec be the function environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT function/NN environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*assert: VARenvrec.[[THISBINDINGSTATUS]] is not "lexical". 
*0*(S assert/NN :/: (Chunk VARenvrec/NNP) ./. [/VB [/JJ (Chunk THISBINDINGSTATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB ``/`` lexical/JJ ''/'' ./.)
*0*if VARenvrec.[[THISBINDINGSTATUS]] is "uninitialized", throw a referenceerror exception. 
*0*(S if/IN (Chunk VARenvrec/NNP) ./. [/VB [/JJ (Chunk THISBINDINGSTATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` uninitialized/JJ ''/'' ,/, throw/VB a/DT referenceerror/NN exception/NN ./.)
*0*return VARenvrec.[[THISVALUE]].      
*0*(S return/NN (Chunk VARenvrec/NNP) ./. [/VB [/JJ (Chunk THISVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
ID= 8.1.1.3.5
Summary= GetSuperBase ( )
*0*let VARenvrec be the function environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT function/NN environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*let VARhome be VARenvrec.[[HOMEOBJECT]]. 
*0*(S (Chunk let/VB VARhome/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk HOMEOBJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARhome has the value undefined, return undefined. 
*0*(S if/IN (Chunk VARhome/NNP) has/VBZ the/DT value/NN undefined/VBD ,/, return/NN undefined/VBD ./.)
*0*assert: FUNCtype(VARhome) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARhome/NNP) )/) is/VBZ object/JJ ./.)
*0*return ? VARhome.[[GETPROTOTYPEOF]]().      
*0*(S return/NN ?/. (Chunk VARhome/NNP) ./. [/VB [/JJ (Chunk GETPROTOTYPEOF/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
ID= 8.1.1.4.1
Summary= HasBinding ( N )
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT global/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*let VARdclrec be VARenvrec.[[DECLARATIVERECORD]]. 
*0*(S (Chunk let/VB VARdclrec/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk DECLARATIVERECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARdclrec.hasbinding(VARn) is true, return true. 
*0*(S if/IN (Chunk VARdclrec.hasbinding/NNP) (/( (Chunk VARn/NNP) )/) is/VBZ true/JJ ,/, return/VB true/JJ ./.)
*0*let VARobjrec be VARenvrec.[[OBJECTRECORD]]. 
*0*(S (Chunk let/VB VARobjrec/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk OBJECTRECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*return ? VARobjrec.hasbinding(VARn).      
*0*(S return/NN ?/. (Chunk VARobjrec.hasbinding/NNP) (/( (Chunk VARn/NNP) )/) ./.)
ID= 8.1.1.4.2
Summary= CreateMutableBinding ( N, D )
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT global/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*let VARdclrec be VARenvrec.[[DECLARATIVERECORD]]. 
*0*(S (Chunk let/VB VARdclrec/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk DECLARATIVERECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARdclrec.hasbinding(VARn) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk VARdclrec.hasbinding/NNP) (/( (Chunk VARn/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARdclrec.createmutablebinding(VARn, VARd).      
*0*(S return/NN (Chunk VARdclrec.createmutablebinding/NNP) (/( (Chunk VARn/NNP) ,/, (Chunk VARd/NNP) )/) ./.)
ID= 8.1.1.4.3
Summary= CreateImmutableBinding ( N, S )
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT global/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*let VARdclrec be VARenvrec.[[DECLARATIVERECORD]]. 
*0*(S (Chunk let/VB VARdclrec/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk DECLARATIVERECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARdclrec.hasbinding(VARn) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk VARdclrec.hasbinding/NNP) (/( (Chunk VARn/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARdclrec.createimmutablebinding(VARn, VARs).      
*0*(S return/NN (Chunk VARdclrec.createimmutablebinding/NNP) (/( (Chunk VARn/NNP) ,/, (Chunk VARs/NNP) )/) ./.)
ID= 8.1.1.4.4
Summary= InitializeBinding ( N, V )
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT global/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*let VARdclrec be VARenvrec.[[DECLARATIVERECORD]]. 
*0*(S (Chunk let/VB VARdclrec/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk DECLARATIVERECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARdclrec.hasbinding(VARn) is true, then
*0*(S if/IN (Chunk VARdclrec.hasbinding/NNP) (/( (Chunk VARn/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*return VARdclrec.initializebinding(VARn, VARv). 
*1*(S return/NN (Chunk VARdclrec.initializebinding/NNP) (/( (Chunk VARn/NNP) ,/, (Chunk VARv/NNP) )/) ./.)
*0*assert: if the binding exists, it must be in the object environment record. 
*0*(S assert/NN :/: if/IN the/DT binding/NN exists/VBZ ,/, it/PRP must/MD be/VB in/IN the/DT object/JJ environment/NN record/NN ./.)
*0*let VARobjrec be VARenvrec.[[OBJECTRECORD]]. 
*0*(S (Chunk let/VB VARobjrec/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk OBJECTRECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*return ? VARobjrec.initializebinding(VARn, VARv).      
*0*(S return/NN ?/. (Chunk VARobjrec.initializebinding/NNP) (/( (Chunk VARn/NNP) ,/, (Chunk VARv/NNP) )/) ./.)
ID= 8.1.1.4.5
Summary= SetMutableBinding ( N, V, S )
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT global/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*let VARdclrec be VARenvrec.[[DECLARATIVERECORD]]. 
*0*(S (Chunk let/VB VARdclrec/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk DECLARATIVERECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARdclrec.hasbinding(VARn) is true, then
*0*(S if/IN (Chunk VARdclrec.hasbinding/NNP) (/( (Chunk VARn/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*return VARdclrec.setmutablebinding(VARn, VARv, VARs). 
*1*(S return/NN (Chunk VARdclrec.setmutablebinding/NNP) (/( (Chunk VARn/NNP) ,/, (Chunk VARv/NNP) ,/, (Chunk VARs/NNP) )/) ./.)
*0*let VARobjrec be VARenvrec.[[OBJECTRECORD]]. 
*0*(S (Chunk let/VB VARobjrec/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk OBJECTRECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*return ? VARobjrec.setmutablebinding(VARn, VARv, VARs).      
*0*(S return/NN ?/. (Chunk VARobjrec.setmutablebinding/NNP) (/( (Chunk VARn/NNP) ,/, (Chunk VARv/NNP) ,/, (Chunk VARs/NNP) )/) ./.)
ID= 8.1.1.4.6
Summary= GetBindingValue ( N, S )
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT global/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*let VARdclrec be VARenvrec.[[DECLARATIVERECORD]]. 
*0*(S (Chunk let/VB VARdclrec/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk DECLARATIVERECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARdclrec.hasbinding(VARn) is true, then
*0*(S if/IN (Chunk VARdclrec.hasbinding/NNP) (/( (Chunk VARn/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*return VARdclrec.getbindingvalue(VARn, VARs). 
*1*(S return/NN (Chunk VARdclrec.getbindingvalue/NNP) (/( (Chunk VARn/NNP) ,/, (Chunk VARs/NNP) )/) ./.)
*0*let VARobjrec be VARenvrec.[[OBJECTRECORD]]. 
*0*(S (Chunk let/VB VARobjrec/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk OBJECTRECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*return ? VARobjrec.getbindingvalue(VARn, VARs).      
*0*(S return/NN ?/. (Chunk VARobjrec.getbindingvalue/NNP) (/( (Chunk VARn/NNP) ,/, (Chunk VARs/NNP) )/) ./.)
ID= 8.1.1.4.7
Summary= DeleteBinding ( N )
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT global/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*let VARdclrec be VARenvrec.[[DECLARATIVERECORD]]. 
*0*(S (Chunk let/VB VARdclrec/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk DECLARATIVERECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARdclrec.hasbinding(VARn) is true, then
*0*(S if/IN (Chunk VARdclrec.hasbinding/NNP) (/( (Chunk VARn/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*return VARdclrec.deletebinding(VARn). 
*1*(S return/NN (Chunk VARdclrec.deletebinding/NNP) (/( (Chunk VARn/NNP) )/) ./.)
*0*let VARobjrec be VARenvrec.[[OBJECTRECORD]]. 
*0*(S (Chunk let/VB VARobjrec/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk OBJECTRECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARglobalobject be the binding object for VARobjrec. 
*0*(S (Chunk let/VB VARglobalobject/NNP) be/VB the/DT binding/NN object/NN for/IN (Chunk VARobjrec/NNP) ./.)
*0*let VARexistingprop be ? FUNChasownproperty(VARglobalobject, VARn). 
*0*(S (Chunk let/VB VARexistingprop/NNP) be/VB ?/. (Chunk FUNChasownproperty/NNP) (/( (Chunk VARglobalobject/NNP) ,/, (Chunk VARn/NNP) )/) ./.)
*0*if VARexistingprop is true, then
*0*(S if/IN (Chunk VARexistingprop/NNP) is/VBZ true/JJ ,/, then/RB)
*1*let VARstatus be ? VARobjrec.deletebinding(VARn). 
*1*(S (Chunk let/VB VARstatus/NNP) be/VB ?/. (Chunk VARobjrec.deletebinding/NNP) (/( (Chunk VARn/NNP) )/) ./.)
*1*if VARstatus is true, then
*1*(S if/IN (Chunk VARstatus/NNP) is/VBZ true/JJ ,/, then/RB)
*2*let VARvarnames be VARenvrec.[[VARNAMES]]. 
*2*(S (Chunk let/VB VARvarnames/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk VARNAMES/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*2*if VARn is an element of VARvarnames, remove that element from the VARvarnames. 
*2*(S if/IN (Chunk VARn/NNP) is/VBZ an/DT element/NN of/IN (Chunk VARvarnames/NNP) ,/, remove/VB that/DT element/NN from/IN the/DT (Chunk VARvarnames/NNP) ./.)
*1*return VARstatus. 
*1*(S return/NN (Chunk VARstatus/NNP) ./.)
*0*return true.      
*0*(S return/NN true/JJ ./.)
ID= 8.1.1.4.8
Summary= HasThisBinding ( )
*0*return true.      
*0*(S return/NN true/JJ ./.)
ID= 8.1.1.4.9
Summary= HasSuperBinding ( )
*0*return false.      
*0*(S return/NN false/JJ ./.)
ID= 8.1.1.4.10
Summary= WithBaseObject ( )
*0*return undefined.      
*0*(S return/NN undefined/VBD ./.)
ID= 8.1.1.4.11
Summary= GetThisBinding ( )
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT global/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*return VARenvrec.[[GLOBALTHISVALUE]].      
*0*(S return/NN (Chunk VARenvrec/NNP) ./. [/VB [/JJ (Chunk GLOBALTHISVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
ID= 8.1.1.4.12
Summary= HasVarDeclaration ( N )
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT global/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*let VARvardeclarednames be VARenvrec.[[VARNAMES]]. 
*0*(S (Chunk let/VB VARvardeclarednames/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk VARNAMES/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARvardeclarednames contains VARn, return true. 
*0*(S if/IN (Chunk VARvardeclarednames/NNP) (Chunk contains/VBZ VARn/NNP) ,/, return/NN true/JJ ./.)
*0*return false.      
*0*(S return/NN false/JJ ./.)
ID= 8.1.1.4.13
Summary= HasLexicalDeclaration ( N )
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT global/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*let VARdclrec be VARenvrec.[[DECLARATIVERECORD]]. 
*0*(S (Chunk let/VB VARdclrec/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk DECLARATIVERECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*return VARdclrec.hasbinding(VARn).      
*0*(S return/NN (Chunk VARdclrec.hasbinding/NNP) (/( (Chunk VARn/NNP) )/) ./.)
ID= 8.1.1.4.14
Summary= HasRestrictedGlobalProperty ( N )
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT global/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*let VARobjrec be VARenvrec.[[OBJECTRECORD]]. 
*0*(S (Chunk let/VB VARobjrec/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk OBJECTRECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARglobalobject be the binding object for VARobjrec. 
*0*(S (Chunk let/VB VARglobalobject/NNP) be/VB the/DT binding/NN object/NN for/IN (Chunk VARobjrec/NNP) ./.)
*0*let VARexistingprop be ? VARglobalobject.[[GETOWNPROPERTY]](VARn). 
*0*(S (Chunk let/VB VARexistingprop/NNP) be/VB ?/. (Chunk VARglobalobject/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARn/NNP) )/) ./.)
*0*if VARexistingprop is undefined, return false. 
*0*(S if/IN (Chunk VARexistingprop/NNP) is/VBZ undefined/JJ ,/, return/NN false/JJ ./.)
*0*if VARexistingprop.[[CONFIGURABLE]] is true, return false. 
*0*(S if/IN (Chunk VARexistingprop/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ true/JJ ,/, return/NN false/JJ ./.)
*0*return true.      
*0*(S return/NN true/JJ ./.)
ID= 8.1.1.4.15
Summary= CanDeclareGlobalVar ( N )
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT global/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*let VARobjrec be VARenvrec.[[OBJECTRECORD]]. 
*0*(S (Chunk let/VB VARobjrec/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk OBJECTRECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARglobalobject be the binding object for VARobjrec. 
*0*(S (Chunk let/VB VARglobalobject/NNP) be/VB the/DT binding/NN object/NN for/IN (Chunk VARobjrec/NNP) ./.)
*0*let VARhasproperty be ? FUNChasownproperty(VARglobalobject, VARn). 
*0*(S (Chunk let/VB VARhasproperty/NNP) be/VB ?/. (Chunk FUNChasownproperty/NNP) (/( (Chunk VARglobalobject/NNP) ,/, (Chunk VARn/NNP) )/) ./.)
*0*if VARhasproperty is true, return true. 
*0*(S if/IN (Chunk VARhasproperty/NNP) is/VBZ true/JJ ,/, return/VB true/JJ ./.)
*0*return ? FUNCisextensible(VARglobalobject).      
*0*(S return/NN ?/. (Chunk FUNCisextensible/NNP) (/( (Chunk VARglobalobject/NNP) )/) ./.)
ID= 8.1.1.4.16
Summary= CanDeclareGlobalFunction ( N )
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT global/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*let VARobjrec be VARenvrec.[[OBJECTRECORD]]. 
*0*(S (Chunk let/VB VARobjrec/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk OBJECTRECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARglobalobject be the binding object for VARobjrec. 
*0*(S (Chunk let/VB VARglobalobject/NNP) be/VB the/DT binding/NN object/NN for/IN (Chunk VARobjrec/NNP) ./.)
*0*let VARexistingprop be ? VARglobalobject.[[GETOWNPROPERTY]](VARn). 
*0*(S (Chunk let/VB VARexistingprop/NNP) be/VB ?/. (Chunk VARglobalobject/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARn/NNP) )/) ./.)
*0*if VARexistingprop is undefined, return ? FUNCisextensible(VARglobalobject). 
*0*(S if/IN (Chunk VARexistingprop/NNP) is/VBZ undefined/JJ ,/, return/VB ?/. (Chunk FUNCisextensible/NNP) (/( (Chunk VARglobalobject/NNP) )/) ./.)
*0*if VARexistingprop.[[CONFIGURABLE]] is true, return true. 
*0*(S if/IN (Chunk VARexistingprop/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ true/JJ ,/, return/VB true/JJ ./.)
*0*if FUNCisdatadescriptor(VARexistingprop) is true and VARexistingprop has attribute values { [[WRITABLE]]: true, [[ENUMERABLE]]: true }, return true. 
*0*(S if/IN (Chunk FUNCisdatadescriptor/NNP) (/( (Chunk VARexistingprop/NNP) )/) is/VBZ true/JJ and/CC (Chunk VARexistingprop/NNP) has/VBZ attribute/NN values/NNS {/( [/JJ (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ }/) ,/, return/VBP true/JJ ./.)
*0*return false.      
*0*(S return/NN false/JJ ./.)
ID= 8.1.1.4.17
Summary= CreateGlobalVarBinding ( N, D )
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT global/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*let VARobjrec be VARenvrec.[[OBJECTRECORD]]. 
*0*(S (Chunk let/VB VARobjrec/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk OBJECTRECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARglobalobject be the binding object for VARobjrec. 
*0*(S (Chunk let/VB VARglobalobject/NNP) be/VB the/DT binding/NN object/NN for/IN (Chunk VARobjrec/NNP) ./.)
*0*let VARhasproperty be ? FUNChasownproperty(VARglobalobject, VARn). 
*0*(S (Chunk let/VB VARhasproperty/NNP) be/VB ?/. (Chunk FUNChasownproperty/NNP) (/( (Chunk VARglobalobject/NNP) ,/, (Chunk VARn/NNP) )/) ./.)
*0*let VARextensible be ? FUNCisextensible(VARglobalobject). 
*0*(S let/VB VARextensible/JJ be/VB ?/. (Chunk FUNCisextensible/NNP) (/( (Chunk VARglobalobject/NNP) )/) ./.)
*0*if VARhasproperty is false and VARextensible is true, then
*0*(S if/IN (Chunk VARhasproperty/NNP) is/VBZ false/JJ and/CC VARextensible/JJ is/VBZ true/JJ ,/, then/RB)
*1*perform ? VARobjrec.createmutablebinding(VARn, VARd). 
*1*(S perform/NN ?/. (Chunk VARobjrec.createmutablebinding/NNP) (/( (Chunk VARn/NNP) ,/, (Chunk VARd/NNP) )/) ./.)
*1*perform ? VARobjrec.initializebinding(VARn, undefined). 
*1*(S perform/NN ?/. (Chunk VARobjrec.initializebinding/NNP) (/( (Chunk VARn/NNP) ,/, undefined/VBD )/) ./.)
*0*let VARvardeclarednames be VARenvrec.[[VARNAMES]]. 
*0*(S (Chunk let/VB VARvardeclarednames/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk VARNAMES/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARvardeclarednames does not contain VARn, then
*0*(S if/IN (Chunk VARvardeclarednames/NNP) does/VBZ (Chunk not/RB contain/VB VARn/NNP) ,/, then/RB)
*1*append VARn to VARvardeclarednames. 
*1*(S append/NN (Chunk VARn/NNP) to/TO (Chunk VARvardeclarednames/NNP) ./.)
*0*return FUNCnormalcompletion(empty).      
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( empty/JJ )/) ./.)
ID= 8.1.1.4.18
Summary= CreateGlobalFunctionBinding ( N, V, D )
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT global/JJ environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*let VARobjrec be VARenvrec.[[OBJECTRECORD]]. 
*0*(S (Chunk let/VB VARobjrec/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk OBJECTRECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARglobalobject be the binding object for VARobjrec. 
*0*(S (Chunk let/VB VARglobalobject/NNP) be/VB the/DT binding/NN object/NN for/IN (Chunk VARobjrec/NNP) ./.)
*0*let VARexistingprop be ? VARglobalobject.[[GETOWNPROPERTY]](VARn). 
*0*(S (Chunk let/VB VARexistingprop/NNP) be/VB ?/. (Chunk VARglobalobject/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARn/NNP) )/) ./.)
*0*if VARexistingprop is undefined or VARexistingprop.[[CONFIGURABLE]] is true, then
*0*(S if/IN (Chunk VARexistingprop/NNP) is/VBZ undefined/JJ or/CC (Chunk VARexistingprop/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ true/JJ ,/, then/RB)
*1*let VARdesc be the propertydescriptor { [[VALUE]]: VARv, [[WRITABLE]]: true, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: VARd }. 
*1*(S (Chunk let/VB VARdesc/NNP) be/VB the/DT propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARv/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARd/NNP) }/) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARdesc be the propertydescriptor { [[VALUE]]: VARv }. 
*1*(S (Chunk let/VB VARdesc/NNP) be/VB the/DT propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARv/NNP) }/) ./.)
*0*perform ? FUNCdefinepropertyorthrow(VARglobalobject, VARn, VARdesc). 
*0*(S perform/NN ?/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARglobalobject/NNP) ,/, (Chunk VARn/NNP) ,/, (Chunk VARdesc/NNP) )/) ./.)
*0*record that the binding for VARn in VARobjrec has been initialized. 
*0*(S record/NN that/IN the/DT binding/NN for/IN (Chunk VARn/NNP) in/IN (Chunk VARobjrec/NNP) has/VBZ been/VBN initialized/VBN ./.)
*0*perform ? FUNCset(VARglobalobject, VARn, VARv, false). 
*0*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARglobalobject/NNP) ,/, (Chunk VARn/NNP) ,/, (Chunk VARv/NNP) ,/, false/RB )/) ./.)
*0*let VARvardeclarednames be VARenvrec.[[VARNAMES]]. 
*0*(S (Chunk let/VB VARvardeclarednames/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk VARNAMES/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARvardeclarednames does not contain VARn, then
*0*(S if/IN (Chunk VARvardeclarednames/NNP) does/VBZ (Chunk not/RB contain/VB VARn/NNP) ,/, then/RB)
*1*append VARn to VARvardeclarednames. 
*1*(S append/NN (Chunk VARn/NNP) to/TO (Chunk VARvardeclarednames/NNP) ./.)
*0*return FUNCnormalcompletion(empty).      
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( empty/JJ )/) ./.)
ID= 8.1.1.5.1
Summary= GetBindingValue ( N, S )
*0*assert: VARs is true. 
*0*(S assert/NN :/: (Chunk VARs/NNP) is/VBZ true/JJ ./.)
*0*let VARenvrec be the module environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT module/NN environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*assert: VARenvrec has a binding for VARn. 
*0*(S assert/NN :/: (Chunk VARenvrec/NNP) has/VBZ a/DT binding/NN for/IN (Chunk VARn/NNP) ./.)
*0*if the binding for VARn is an indirect binding, then
*0*(S if/IN the/DT binding/NN for/IN (Chunk VARn/NNP) is/VBZ an/DT indirect/JJ binding/NN ,/, then/RB)
*1*let VARm and VARn2 be the indirection values provided when this binding for VARn was created. 
*1*(S (Chunk let/VB VARm/NNP) and/CC (Chunk VARn2/NNP) be/VB the/DT indirection/NN values/NNS provided/VBD when/WRB this/DT binding/NN for/IN (Chunk VARn/NNP) was/VBD created/VBN ./.)
*1*let VARtargetenv be VARm.[[ENVIRONMENT]]. 
*1*(S (Chunk let/VB VARtargetenv/NNP) (Chunk be/VB VARm/NNP) ./. [/VB [/JJ (Chunk ENVIRONMENT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*if VARtargetenv is undefined, throw a referenceerror exception. 
*1*(S if/IN (Chunk VARtargetenv/NNP) is/VBZ undefined/JJ ,/, throw/VB a/DT referenceerror/NN exception/NN ./.)
*1*let VARtargeter be VARtargetenv's environmentrecord. 
*1*(S (Chunk let/VB VARtargeter/NNP) (Chunk be/VB VARtargetenv/NNP) 's/POS environmentrecord/NN ./.)
*1*return ? VARtargeter.getbindingvalue(VARn2, true). 
*1*(S return/NN ?/. (Chunk VARtargeter.getbindingvalue/NNP) (/( (Chunk VARn2/NNP) ,/, true/JJ )/) ./.)
*0*if the binding for VARn in VARenvrec is an uninitialized binding, throw a referenceerror exception. 
*0*(S if/IN the/DT binding/NN for/IN (Chunk VARn/NNP) in/IN (Chunk VARenvrec/NNP) is/VBZ an/DT uninitialized/JJ binding/NN ,/, throw/VB a/DT referenceerror/NN exception/NN ./.)
*0*return the value currently bound to VARn in VARenvrec.      
*0*(S return/VB the/DT value/NN currently/RB bound/IN to/TO (Chunk VARn/NNP) in/IN (Chunk VARenvrec/NNP) ./.)
ID= 8.1.1.5.2
Summary= DeleteBinding ( N )
*0*assert: this method is never invoked. see 12.5.3.1.      
*0*(S assert/NN :/: this/DT method/NN is/VBZ never/RB invoked/VBN ./. see/VB 12.5.3.1/CD ./.)
ID= 8.1.1.5.3
Summary= HasThisBinding ( )
*0*return true.      
*0*(S return/NN true/JJ ./.)
ID= 8.1.1.5.4
Summary= GetThisBinding ( )
*0*return undefined.      
*0*(S return/NN undefined/VBD ./.)
ID= 8.1.1.5.5
Summary= CreateImportBinding ( N, M, N2 )
*0*let VARenvrec be the module environment record for which the method was invoked. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB the/DT module/NN environment/NN record/NN for/IN which/WDT the/DT method/NN was/VBD invoked/VBN ./.)
*0*assert: VARenvrec does not already have a binding for VARn. 
*0*(S assert/NN :/: VARenvrec/NN does/VBZ not/RB already/RB have/VB a/DT binding/NN for/IN (Chunk VARn/NNP) ./.)
*0*assert: VARm is a module record. 
*0*(S assert/NN :/: (Chunk VARm/NNP) is/VBZ a/DT module/NN record/NN ./.)
*0*assert: when VARm.[[ENVIRONMENT]] is instantiated it will have a direct binding for VARn2. 
*0*(S assert/NN :/: when/WRB (Chunk VARm/NNP) ./. [/VB [/JJ (Chunk ENVIRONMENT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ instantiated/VBN it/PRP will/MD have/VB a/DT direct/JJ binding/NN for/IN (Chunk VARn2/NNP) ./.)
*0*create an immutable indirect binding in VARenvrec for VARn that references VARm and VARn2 as its target binding and record that the binding is initialized. 
*0*(S create/VB an/DT immutable/JJ indirect/JJ binding/NN in/IN (Chunk VARenvrec/NNP) for/IN (Chunk VARn/NNP) that/WDT (Chunk references/VBZ VARm/NNP) and/CC (Chunk VARn2/NNP) as/IN its/PRP$ target/NN binding/NN and/CC record/NN that/IN the/DT binding/NN is/VBZ initialized/VBN ./.)
*0*return FUNCnormalcompletion(empty).      
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( empty/JJ )/) ./.)
ID= 8.1.2.1
Summary= GetIdentifierReference ( lex, name, strict )
*0*if VARlex is the value null, then
*0*(S if/IN (Chunk VARlex/NNP) is/VBZ the/DT value/NN null/NN ,/, then/RB)
*1*return a value of type reference whose base value component is undefined, whose referenced name component is VARname, and whose strict reference flag is VARstrict. 
*1*(S return/VB a/DT value/NN of/IN type/JJ reference/NN whose/WP$ base/NN value/NN component/NN is/VBZ undefined/JJ ,/, whose/WP$ referenced/JJ name/NN component/NN (Chunk is/VBZ VARname/NNP) ,/, and/CC whose/WP$ strict/JJ reference/NN flag/NN (Chunk is/VBZ VARstrict/NNP) ./.)
*0*let VARenvrec be VARlex's environmentrecord. 
*0*(S (Chunk let/VB VARenvrec/NNP) (Chunk be/VB VARlex/NNP) 's/POS environmentrecord/NN ./.)
*0*let VARexists be ? VARenvrec.hasbinding(VARname). 
*0*(S let/VB VARexists/NNS be/VB ?/. (Chunk VARenvrec.hasbinding/NNP) (/( (Chunk VARname/NNP) )/) ./.)
*0*if VARexists is true, then
*0*(S if/IN VARexists/NNS is/VBZ true/JJ ,/, then/RB)
*1*return a value of type reference whose base value component is VARenvrec, whose referenced name component is VARname, and whose strict reference flag is VARstrict. 
*1*(S return/VB a/DT value/NN of/IN type/JJ reference/NN whose/WP$ base/NN value/NN component/NN (Chunk is/VBZ VARenvrec/NNP) ,/, whose/WP$ referenced/JJ name/NN component/NN (Chunk is/VBZ VARname/NNP) ,/, and/CC whose/WP$ strict/JJ reference/NN flag/NN (Chunk is/VBZ VARstrict/NNP) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARouter be the value of VARlex's outer environment reference. 
*1*(S (Chunk let/VB VARouter/NNP) be/VB the/DT value/NN of/IN (Chunk VARlex/NNP) 's/POS outer/NN environment/NN reference/NN ./.)
*1*return ? FUNCgetidentifierreference(VARouter, VARname, VARstrict).     
*1*(S return/NN ?/. (Chunk FUNCgetidentifierreference/NNP) (/( (Chunk VARouter/NNP) ,/, (Chunk VARname/NNP) ,/, (Chunk VARstrict/NNP) )/) ./.)
ID= 8.1.2.2
Summary= NewDeclarativeEnvironment ( E )
*0*let VARenv be a new lexical environment. 
*0*(S (Chunk let/VB VARenv/NNP) be/VB a/DT new/JJ lexical/JJ environment/NN ./.)
*0*let VARenvrec be a new declarative environment record containing no bindings. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB a/DT new/JJ declarative/JJ environment/NN record/NN containing/VBG no/DT bindings/NNS ./.)
*0*set VARenv's environmentrecord to VARenvrec. 
*0*(S (Chunk set/VBN VARenv/NNP) 's/POS environmentrecord/NN to/TO (Chunk VARenvrec/NNP) ./.)
*0*set the outer lexical environment reference of VARenv to VARe. 
*0*(S set/VB the/DT outer/JJ lexical/JJ environment/NN reference/NN of/IN (Chunk VARenv/NNP) to/TO (Chunk VARe/NNP) ./.)
*0*return VARenv.     
*0*(S return/NN (Chunk VARenv/NNP) ./.)
ID= 8.1.2.3
Summary= NewObjectEnvironment ( O, E )
*0*let VARenv be a new lexical environment. 
*0*(S (Chunk let/VB VARenv/NNP) be/VB a/DT new/JJ lexical/JJ environment/NN ./.)
*0*let VARenvrec be a new object environment record containing VARo as the binding object. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB a/DT new/JJ object/JJ environment/NN record/NN (Chunk containing/VBG VARo/NNP) as/IN the/DT binding/NN object/NN ./.)
*0*set VARenv's environmentrecord to VARenvrec. 
*0*(S (Chunk set/VBN VARenv/NNP) 's/POS environmentrecord/NN to/TO (Chunk VARenvrec/NNP) ./.)
*0*set the outer lexical environment reference of VARenv to VARe. 
*0*(S set/VB the/DT outer/JJ lexical/JJ environment/NN reference/NN of/IN (Chunk VARenv/NNP) to/TO (Chunk VARe/NNP) ./.)
*0*return VARenv.     
*0*(S return/NN (Chunk VARenv/NNP) ./.)
ID= 8.1.2.4
Summary= NewFunctionEnvironment ( F, newTarget )
*0*assert: VARf is an ecmascript function. 
*0*(S assert/NN :/: (Chunk VARf/NNP) is/VBZ an/DT ecmascript/JJ function/NN ./.)
*0*assert: FUNCtype(VARnewtarget) is undefined or object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARnewtarget/NNP) )/) is/VBZ undefined/JJ or/CC object/JJ ./.)
*0*let VARenv be a new lexical environment. 
*0*(S (Chunk let/VB VARenv/NNP) be/VB a/DT new/JJ lexical/JJ environment/NN ./.)
*0*let VARenvrec be a new function environment record containing no bindings. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB a/DT new/JJ function/NN environment/NN record/NN containing/VBG no/DT bindings/NNS ./.)
*0*set VARenvrec.[[FUNCTIONOBJECT]] to VARf. 
*0*(S (Chunk set/VBN VARenvrec/NNP) ./. [/VB [/JJ (Chunk FUNCTIONOBJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARf/NNP) ./.)
*0*if VARf.[[THISMODE]] is lexical, set VARenvrec.[[THISBINDINGSTATUS]] to "lexical". 
*0*(S if/IN (Chunk VARf/NNP) ./. [/VB [/JJ (Chunk THISMODE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ lexical/JJ ,/, (Chunk set/VBN VARenvrec/NNP) ./. [/VB [/JJ (Chunk THISBINDINGSTATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` lexical/JJ ''/'' ./.)
*0*else, set VARenvrec.[[THISBINDINGSTATUS]] to "uninitialized". 
*0*(S else/RB ,/, (Chunk set/VBN VARenvrec/NNP) ./. [/VB [/JJ (Chunk THISBINDINGSTATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` uninitialized/JJ ''/'' ./.)
*0*let VARhome be VARf.[[HOMEOBJECT]]. 
*0*(S (Chunk let/VB VARhome/NNP) (Chunk be/VB VARf/NNP) ./. [/VB [/JJ (Chunk HOMEOBJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*set VARenvrec.[[HOMEOBJECT]] to VARhome. 
*0*(S (Chunk set/VBN VARenvrec/NNP) ./. [/VB [/JJ (Chunk HOMEOBJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARhome/NNP) ./.)
*0*set VARenvrec.[[NEWTARGET]] to VARnewtarget. 
*0*(S (Chunk set/VBN VARenvrec/NNP) ./. [/VB [/JJ (Chunk NEWTARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARnewtarget/NNP) ./.)
*0*set VARenv's environmentrecord to VARenvrec. 
*0*(S (Chunk set/VBN VARenv/NNP) 's/POS environmentrecord/NN to/TO (Chunk VARenvrec/NNP) ./.)
*0*set the outer lexical environment reference of VARenv to VARf.[[ENVIRONMENT]]. 
*0*(S set/VB the/DT outer/JJ lexical/JJ environment/NN reference/NN of/IN (Chunk VARenv/NNP) to/TO (Chunk VARf/NNP) ./. [/VB [/JJ (Chunk ENVIRONMENT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*return VARenv.     
*0*(S return/NN (Chunk VARenv/NNP) ./.)
ID= 8.1.2.5
Summary= NewGlobalEnvironment ( G, thisValue )
*0*let VARenv be a new lexical environment. 
*0*(S (Chunk let/VB VARenv/NNP) be/VB a/DT new/JJ lexical/JJ environment/NN ./.)
*0*let VARobjrec be a new object environment record containing VARg as the binding object. 
*0*(S (Chunk let/VB VARobjrec/NNP) be/VB a/DT new/JJ object/JJ environment/NN record/NN (Chunk containing/VBG VARg/NNP) as/IN the/DT binding/NN object/NN ./.)
*0*let VARdclrec be a new declarative environment record containing no bindings. 
*0*(S (Chunk let/VB VARdclrec/NNP) be/VB a/DT new/JJ declarative/JJ environment/NN record/NN containing/VBG no/DT bindings/NNS ./.)
*0*let VARglobalrec be a new global environment record. 
*0*(S (Chunk let/VB VARglobalrec/NNP) be/VB a/DT new/JJ global/JJ environment/NN record/NN ./.)
*0*set VARglobalrec.[[OBJECTRECORD]] to VARobjrec. 
*0*(S (Chunk set/VBN VARglobalrec/NNP) ./. [/VB [/JJ (Chunk OBJECTRECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARobjrec/NNP) ./.)
*0*set VARglobalrec.[[GLOBALTHISVALUE]] to VARthisvalue. 
*0*(S (Chunk set/VBN VARglobalrec/NNP) ./. [/VB [/JJ (Chunk GLOBALTHISVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARthisvalue/NNP) ./.)
*0*set VARglobalrec.[[DECLARATIVERECORD]] to VARdclrec. 
*0*(S (Chunk set/VBN VARglobalrec/NNP) ./. [/VB [/JJ (Chunk DECLARATIVERECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARdclrec/NNP) ./.)
*0*set VARglobalrec.[[VARNAMES]] to a new empty list. 
*0*(S (Chunk set/VBN VARglobalrec/NNP) ./. [/VB [/JJ (Chunk VARNAMES/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO a/DT new/JJ empty/JJ list/NN ./.)
*0*set VARenv's environmentrecord to VARglobalrec. 
*0*(S (Chunk set/VBN VARenv/NNP) 's/POS environmentrecord/NN to/TO (Chunk VARglobalrec/NNP) ./.)
*0*set the outer lexical environment reference of VARenv to null. 
*0*(S set/VB the/DT outer/JJ lexical/JJ environment/NN reference/NN of/IN (Chunk VARenv/NNP) to/TO null/VB ./.)
*0*return VARenv.     
*0*(S return/NN (Chunk VARenv/NNP) ./.)
ID= 8.1.2.6
Summary= NewModuleEnvironment ( E )
*0*let VARenv be a new lexical environment. 
*0*(S (Chunk let/VB VARenv/NNP) be/VB a/DT new/JJ lexical/JJ environment/NN ./.)
*0*let VARenvrec be a new module environment record containing no bindings. 
*0*(S (Chunk let/VB VARenvrec/NNP) be/VB a/DT new/JJ module/NN environment/NN record/NN containing/VBG no/DT bindings/NNS ./.)
*0*set VARenv's environmentrecord to VARenvrec. 
*0*(S (Chunk set/VBN VARenv/NNP) 's/POS environmentrecord/NN to/TO (Chunk VARenvrec/NNP) ./.)
*0*set the outer lexical environment reference of VARenv to VARe. 
*0*(S set/VB the/DT outer/JJ lexical/JJ environment/NN reference/NN of/IN (Chunk VARenv/NNP) to/TO (Chunk VARe/NNP) ./.)
*0*return VARenv.     
*0*(S return/NN (Chunk VARenv/NNP) ./.)
ID= 8.2.1
Summary= CreateRealm ( )
*0*let VARrealmrec be a new realm record. 
*0*(S (Chunk let/VB VARrealmrec/NNP) be/VB a/DT new/JJ realm/NN record/NN ./.)
*0*perform FUNCcreateintrinsics(VARrealmrec). 
*0*(S perform/NN FUNCcreateintrinsics/NNS (/( (Chunk VARrealmrec/NNP) )/) ./.)
*0*set VARrealmrec.[[GLOBALOBJECT]] to undefined. 
*0*(S (Chunk set/VBN VARrealmrec/NNP) ./. [/VB [/JJ (Chunk GLOBALOBJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO undefined/VB ./.)
*0*set VARrealmrec.[[GLOBALENV]] to undefined. 
*0*(S (Chunk set/VBN VARrealmrec/NNP) ./. [/VB [/JJ (Chunk GLOBALENV/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO undefined/VB ./.)
*0*set VARrealmrec.[[TEMPLATEMAP]] to a new empty list. 
*0*(S (Chunk set/VBN VARrealmrec/NNP) ./. [/VB [/JJ (Chunk TEMPLATEMAP/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO a/DT new/JJ empty/JJ list/NN ./.)
*0*return VARrealmrec.    
*0*(S return/NN (Chunk VARrealmrec/NNP) ./.)
ID= 8.2.2
Summary= CreateIntrinsics ( realmRec )
*0*let VARintrinsics be a new record. 
*0*(S (Chunk let/VB VARintrinsics/NNP) be/VB a/DT new/JJ record/NN ./.)
*0*set VARrealmrec.[[INTRINSICS]] to VARintrinsics. 
*0*(S (Chunk set/VBN VARrealmrec/NNP) ./. [/VB [/JJ (Chunk INTRINSICS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARintrinsics/NNP) ./.)
*0*let VARobjproto be FUNCobjectcreate(null). 
*0*(S (Chunk let/VB VARobjproto/NNP) (Chunk be/VB FUNCobjectcreate/NNP) (/( null/NN )/) ./.)
*0*set VARintrinsics.[[%OBJECTPROTOTYPE%]] to VARobjproto. 
*0*(S set/VBN VARintrinsics/NNS ./. [/VB [/CD %/NN (Chunk OBJECTPROTOTYPE/NNP) %/NN (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARobjproto/NNP) ./.)
*0*let VARthrowersteps be the algorithm steps specified in 9.2.9.1 for the %throwtypeerror% function. 
*0*(S (Chunk let/VB VARthrowersteps/NNP) be/VB the/DT algorithm/JJ steps/NNS specified/VBN in/IN 9.2.9.1/CD for/IN the/DT %/NN throwtypeerror/NN %/NN function/NN ./.)
*0*let VARthrower be FUNCcreatebuiltinfunction(VARthrowersteps, « », VARrealmrec, null). 
*0*(S (Chunk let/VB VARthrower/NNP) (Chunk be/VB FUNCcreatebuiltinfunction/NNP) (/( (Chunk VARthrowersteps/NNP) ,/, (Chunk «/NNP) (Chunk »/NNP) ,/, (Chunk VARrealmrec/NNP) ,/, null/NN )/) ./.)
*0*set VARintrinsics.[[%THROWTYPEERROR%]] to VARthrower. 
*0*(S set/VBN VARintrinsics/NNS ./. [/VB [/CD %/NN (Chunk THROWTYPEERROR/NNP) %/NN (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARthrower/NNP) ./.)
*0*let VARnosteps be an empty sequence of algorithm steps. 
*0*(S (Chunk let/VB VARnosteps/NNP) be/VB an/DT empty/JJ sequence/NN of/IN algorithm/JJ steps/NNS ./.)
*0*let VARfuncproto be FUNCcreatebuiltinfunction(VARnosteps, « », VARrealmrec, VARobjproto). 
*0*(S (Chunk let/VB VARfuncproto/NNP) (Chunk be/VB FUNCcreatebuiltinfunction/NNP) (/( (Chunk VARnosteps/NNP) ,/, (Chunk «/NNP) (Chunk »/NNP) ,/, (Chunk VARrealmrec/NNP) ,/, (Chunk VARobjproto/NNP) )/) ./.)
*0*set VARintrinsics.[[%FUNCTIONPROTOTYPE%]] to VARfuncproto. 
*0*(S set/VBN VARintrinsics/NNS ./. [/VB [/CD %/NN (Chunk FUNCTIONPROTOTYPE/NNP) %/NN (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARfuncproto/NNP) ./.)
*0*call VARthrower.[[SETPROTOTYPEOF]](VARfuncproto). 
*0*(S call/NN (Chunk VARthrower/NNP) ./. [/VB [/JJ (Chunk SETPROTOTYPEOF/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARfuncproto/NNP) )/) ./.)
*0*perform FUNCaddrestrictedfunctionproperties(VARfuncproto, VARrealmrec). 
*0*(S perform/NN FUNCaddrestrictedfunctionproperties/NNS (/( (Chunk VARfuncproto/NNP) ,/, (Chunk VARrealmrec/NNP) )/) ./.)
*0*set fields of VARintrinsics with the values listed in table 7 that have not already been handled above. the field names are the names listed in column one of the table. the value of each field is a new object value fully and recursively populated with property values as defined by the specification of each object in clauses 18-26. all object property values are newly created object values. all values that are built-in function objects are created by performing FUNCcreatebuiltinfunction(&lt;steps&gt;, &lt;slots&gt;, VARrealmrec, &lt;prototype&gt;) where &lt;steps&gt; is the definition of that function provided by this specification, &lt;slots&gt; is a list of the names, if any, of the function's specified internal slots, and &lt;prototype&gt; is the specified value of the function's [[PROTOTYPE]] internal slot. the creation of the intrinsics and their properties must be ordered to avoid any dependencies upon objects that have not yet been created. 
*0*(S set/VBN fields/NNS of/IN VARintrinsics/NNS with/IN the/DT values/NNS listed/VBN in/IN table/JJ 7/CD that/WDT have/VBP not/RB already/RB been/VBN handled/VBN above/RB ./. the/DT field/NN names/NNS are/VBP the/DT names/NNS listed/VBN in/IN column/NN one/CD of/IN the/DT table/NN ./. the/DT value/NN of/IN each/DT field/NN is/VBZ a/DT new/JJ object/JJ value/NN fully/RB and/CC recursively/RB populated/VBN with/IN property/NN values/NNS as/IN defined/VBN by/IN the/DT specification/NN of/IN each/DT object/NN in/IN clauses/NNS 18-26./CD all/DT object/JJ property/NN values/NNS are/VBP newly/RB created/VBN object/NN values/NNS ./. all/DT values/NNS that/WDT are/VBP built-in/JJ function/NN objects/NNS are/VBP created/VBN by/IN (Chunk performing/VBG FUNCcreatebuiltinfunction/NNP) (/( &/CC lt/NN ;/: steps/NNS &/CC gt/NN ;/: ,/, &/CC lt/NN ;/: slots/CC &/CC gt/NN ;/: ,/, (Chunk VARrealmrec/NNP) ,/, &/CC lt/NN ;/: prototype/NN &/CC gt/NN ;/: )/) where/WRB &/CC lt/NN ;/: steps/NNS &/CC gt/NN ;/: is/VBZ the/DT definition/NN of/IN that/DT function/NN provided/VBN by/IN this/DT specification/NN ,/, &/CC lt/NN ;/: slots/CC &/CC gt/NN ;/: is/VBZ a/DT list/NN of/IN the/DT names/NNS ,/, if/IN any/DT ,/, of/IN the/DT function/NN 's/POS specified/VBN internal/JJ slots/NNS ,/, and/CC &/CC lt/NN ;/: prototype/NN &/CC gt/NN ;/: is/VBZ the/DT specified/JJ value/NN of/IN the/DT function/NN 's/POS [/JJ [/NN (Chunk PROTOTYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./. the/DT creation/NN of/IN the/DT intrinsics/NNS and/CC their/PRP$ properties/NNS must/MD be/VB ordered/VBN to/TO avoid/VB any/DT dependencies/NNS upon/IN objects/NNS that/WDT have/VBP not/RB yet/RB been/VBN created/VBN ./.)
*0*return VARintrinsics.    
*0*(S return/NN VARintrinsics/NNS ./.)
ID= 8.2.3
Summary= SetRealmGlobalObject ( realmRec, globalObj, thisValue )
*0*if VARglobalobj is undefined, then
*0*(S if/IN (Chunk VARglobalobj/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*let VARintrinsics be VARrealmrec.[[INTRINSICS]]. 
*1*(S let/VB VARintrinsics/NNS (Chunk be/VB VARrealmrec/NNP) ./. [/VB [/JJ (Chunk INTRINSICS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*set VARglobalobj to FUNCobjectcreate(VARintrinsics.[[%OBJECTPROTOTYPE%]]). 
*1*(S (Chunk set/VBN VARglobalobj/NNP) to/TO (Chunk FUNCobjectcreate/NNP) (/( (Chunk VARintrinsics/NNP) ./. [/VB [/CD %/NN (Chunk OBJECTPROTOTYPE/NNP) %/NN (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*0*assert: FUNCtype(VARglobalobj) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARglobalobj/NNP) )/) is/VBZ object/JJ ./.)
*0*if VARthisvalue is undefined, set VARthisvalue to VARglobalobj. 
*0*(S if/IN (Chunk VARthisvalue/NNP) is/VBZ undefined/JJ ,/, (Chunk set/VBN VARthisvalue/NNP) to/TO (Chunk VARglobalobj/NNP) ./.)
*0*set VARrealmrec.[[GLOBALOBJECT]] to VARglobalobj. 
*0*(S (Chunk set/VBN VARrealmrec/NNP) ./. [/VB [/JJ (Chunk GLOBALOBJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARglobalobj/NNP) ./.)
*0*let VARnewglobalenv be FUNCnewglobalenvironment(VARglobalobj, VARthisvalue). 
*0*(S (Chunk let/VB VARnewglobalenv/NNP) (Chunk be/VB FUNCnewglobalenvironment/NNP) (/( (Chunk VARglobalobj/NNP) ,/, (Chunk VARthisvalue/NNP) )/) ./.)
*0*set VARrealmrec.[[GLOBALENV]] to VARnewglobalenv. 
*0*(S (Chunk set/VBN VARrealmrec/NNP) ./. [/VB [/JJ (Chunk GLOBALENV/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARnewglobalenv/NNP) ./.)
*0*return VARrealmrec.    
*0*(S return/NN (Chunk VARrealmrec/NNP) ./.)
ID= 8.2.4
Summary= SetDefaultGlobalBindings ( realmRec )
*0*let VARglobal be VARrealmrec.[[GLOBALOBJECT]]. 
*0*(S (Chunk let/VB VARglobal/NNP) (Chunk be/VB VARrealmrec/NNP) ./. [/VB [/JJ (Chunk GLOBALOBJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*for each property of the global object specified in clause 18, do
*0*(S for/IN each/DT property/NN of/IN the/DT global/JJ object/NN specified/VBN in/IN clause/NN 18/CD ,/, do/VBP)
*1*let VARname be the string value of the property name. 
*1*(S (Chunk let/VB VARname/NNP) be/VB the/DT string/VBG value/NN of/IN the/DT property/NN name/NN ./.)
*1*let VARdesc be the fully populated data property descriptor for the property containing the specified attributes for the property. for properties listed in 18.2, 18.3, or 18.4 the value of the [[VALUE]] attribute is the corresponding intrinsic object from VARrealmrec. 
*1*(S (Chunk let/VB VARdesc/NNP) be/VB the/DT fully/RB populated/VBN data/NNS property/NN descriptor/NN for/IN the/DT property/NN containing/VBG the/DT specified/VBN attributes/NNS for/IN the/DT property/NN ./. for/IN properties/NNS listed/VBN in/IN 18.2/CD ,/, 18.3/CD ,/, or/CC 18.4/CD the/DT value/NN of/IN the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) attribute/NN is/VBZ the/DT corresponding/JJ intrinsic/JJ object/NN from/IN (Chunk VARrealmrec/NNP) ./.)
*1*perform ? FUNCdefinepropertyorthrow(VARglobal, VARname, VARdesc). 
*1*(S perform/NN ?/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARglobal/NNP) ,/, (Chunk VARname/NNP) ,/, (Chunk VARdesc/NNP) )/) ./.)
*0*return VARglobal.    
*0*(S return/NN (Chunk VARglobal/NNP) ./.)
ID= 8.3.1
Summary= GetActiveScriptOrModule ( )
*0*if the execution context stack is empty, return null. 
*0*(S if/IN the/DT execution/NN context/NN stack/NN is/VBZ empty/JJ ,/, return/JJ null/NN ./.)
*0*let VARec be the topmost execution context on the execution context stack whose scriptormodule component is not null. 
*0*(S (Chunk let/VB VARec/NNP) be/VB the/DT topmost/JJ execution/NN context/NN on/IN the/DT execution/NN context/NN stack/NN whose/WP$ scriptormodule/JJ component/NN is/VBZ not/RB null/JJ ./.)
*0*if no such execution context exists, return null. otherwise, return VARec's scriptormodule component.    
*0*(S if/IN no/DT such/JJ execution/NN context/NN exists/VBZ ,/, return/VB null/RB ./. otherwise/RB ,/, (Chunk return/VBP VARec/NNP) 's/POS scriptormodule/NN component/NN ./.)
ID= 8.3.2
Summary= ResolveBinding ( name [ , env ] )
*0*if VARenv is not present or if VARenv is undefined, then
*0*(S if/IN (Chunk VARenv/NNP) is/VBZ not/RB present/JJ or/CC if/IN (Chunk VARenv/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*set VARenv to the running execution context's lexicalenvironment. 
*1*(S (Chunk set/VBN VARenv/NNP) to/TO the/DT running/VBG execution/NN context/NN 's/POS lexicalenvironment/NN ./.)
*0*assert: VARenv is a lexical environment. 
*0*(S assert/NN :/: (Chunk VARenv/NNP) is/VBZ a/DT lexical/JJ environment/NN ./.)
*0*if the code matching the syntactic production that is being evaluated is contained in strict mode code, let VARstrict be true, else let VARstrict be false. 
*0*(S if/IN the/DT code/NN matching/VBG the/DT syntactic/JJ production/NN that/WDT is/VBZ being/VBG evaluated/VBN is/VBZ contained/VBN in/IN strict/JJ mode/NN code/NN ,/, (Chunk let/VB VARstrict/NNP) be/VB true/JJ ,/, else/JJ let/NN (Chunk VARstrict/NNP) be/VB false/JJ ./.)
*0*return ? FUNCgetidentifierreference(VARenv, VARname, VARstrict).    
*0*(S return/NN ?/. (Chunk FUNCgetidentifierreference/NNP) (/( (Chunk VARenv/NNP) ,/, (Chunk VARname/NNP) ,/, (Chunk VARstrict/NNP) )/) ./.)
ID= 8.3.3
Summary= GetThisEnvironment ( )
*0*let VARlex be the running execution context's lexicalenvironment. 
*0*(S (Chunk let/VB VARlex/NNP) be/VB the/DT running/JJ execution/NN context/NN 's/POS lexicalenvironment/NN ./.)
*0*repeat,
*0*(S repeat/NN ,/,)
*1*let VARenvrec be VARlex's environmentrecord. 
*1*(S (Chunk let/VB VARenvrec/NNP) (Chunk be/VB VARlex/NNP) 's/POS environmentrecord/NN ./.)
*1*let VARexists be VARenvrec.hasthisbinding(). 
*1*(S let/VB VARexists/NNS (Chunk be/VB VARenvrec.hasthisbinding/NNP) (/( )/) ./.)
*1*if VARexists is true, return VARenvrec. 
*1*(S if/IN VARexists/NNS is/VBZ true/JJ ,/, (Chunk return/VB VARenvrec/NNP) ./.)
*1*let VARouter be the value of VARlex's outer environment reference. 
*1*(S (Chunk let/VB VARouter/NNP) be/VB the/DT value/NN of/IN (Chunk VARlex/NNP) 's/POS outer/NN environment/NN reference/NN ./.)
*1*assert: VARouter is not null. 
*1*(S assert/NN :/: VARouter/NN is/VBZ not/RB null/JJ ./.)
*1*set VARlex to VARouter.    
*1*(S (Chunk set/VBN VARlex/NNP) to/TO (Chunk VARouter/NNP) ./.)
ID= 8.3.4
Summary= ResolveThisBinding ( )
*0*let VARenvrec be FUNCgetthisenvironment(). 
*0*(S (Chunk let/VB VARenvrec/NNP) (Chunk be/VB FUNCgetthisenvironment/NNP) (/( )/) ./.)
*0*return ? VARenvrec.getthisbinding().    
*0*(S return/NN ?/. (Chunk VARenvrec.getthisbinding/NNP) (/( )/) ./.)
ID= 8.3.5
Summary= GetNewTarget ( )
*0*let VARenvrec be FUNCgetthisenvironment(). 
*0*(S (Chunk let/VB VARenvrec/NNP) (Chunk be/VB FUNCgetthisenvironment/NNP) (/( )/) ./.)
*0*assert: VARenvrec has a [[NEWTARGET]] field. 
*0*(S assert/NN :/: (Chunk VARenvrec/NNP) has/VBZ a/DT [/JJ (Chunk [/NNP) (Chunk NEWTARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN ./.)
*0*return VARenvrec.[[NEWTARGET]].    
*0*(S return/NN (Chunk VARenvrec/NNP) ./. [/VB [/JJ (Chunk NEWTARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
ID= 8.3.6
Summary= GetGlobalObject ( )
*0*let VARctx be the running execution context. 
*0*(S (Chunk let/VB VARctx/NNP) be/VB the/DT running/JJ execution/NN context/NN ./.)
*0*let VARcurrentrealm be VARctx's realm. 
*0*(S (Chunk let/VB VARcurrentrealm/NNP) (Chunk be/VB VARctx/NNP) 's/POS realm/NN ./.)
*0*return VARcurrentrealm.[[GLOBALOBJECT]].    
*0*(S return/NN (Chunk VARcurrentrealm/NNP) ./. [/VB [/JJ (Chunk GLOBALOBJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
ID= 8.4.1
Summary= EnqueueJob ( queueName, job, arguments )
*0*assert: FUNCtype(VARqueuename) is string and its value is the name of a job queue recognized by this implementation. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARqueuename/NNP) )/) is/VBZ string/VBG and/CC its/PRP$ value/NN is/VBZ the/DT name/NN of/IN a/DT job/NN queue/NN recognized/VBN by/IN this/DT implementation/NN ./.)
*0*assert: VARjob is the name of a job. 
*0*(S assert/NN :/: (Chunk VARjob/NNP) is/VBZ the/DT name/NN of/IN a/DT job/NN ./.)
*0*assert: VARarguments is a list that has the same number of elements as the number of parameters required by VARjob. 
*0*(S assert/NN :/: VARarguments/NNS is/VBZ a/DT list/NN that/WDT has/VBZ the/DT same/JJ number/NN of/IN elements/NNS as/IN the/DT number/NN of/IN parameters/NNS required/VBN by/IN (Chunk VARjob/NNP) ./.)
*0*let VARcallercontext be the running execution context. 
*0*(S (Chunk let/VB VARcallercontext/NNP) be/VB the/DT running/JJ execution/NN context/NN ./.)
*0*let VARcallerrealm be VARcallercontext's realm. 
*0*(S (Chunk let/VB VARcallerrealm/NNP) (Chunk be/VB VARcallercontext/NNP) 's/POS realm/NN ./.)
*0*let VARcallerscriptormodule be VARcallercontext's scriptormodule. 
*0*(S (Chunk let/VB VARcallerscriptormodule/NNP) (Chunk be/VB VARcallercontext/NNP) 's/POS scriptormodule/NN ./.)
*0*let VARpending be pendingjob { [[JOB]]: VARjob, [[ARGUMENTS]]: VARarguments, [[REALM]]: VARcallerrealm, [[SCRIPTORMODULE]]: VARcallerscriptormodule, [[HOSTDEFINED]]: undefined }. 
*0*(S (Chunk let/VB VARpending/NNP) be/VB pendingjob/VBN {/( [/JJ [/JJ (Chunk JOB/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARjob/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ARGUMENTS/NNP) (Chunk ]/NNP) ]/NN :/: VARarguments/NNS ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk REALM/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARcallerrealm/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk SCRIPTORMODULE/NNP) (Chunk ]/NNP) ]/NN :/: VARcallerscriptormodule/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk HOSTDEFINED/NNP) (Chunk ]/NNP) ]/NN :/: undefined/JJ }/) ./.)
*0*perform any implementation or host environment defined processing of VARpending. this may include modifying the [[HOSTDEFINED]] field or any other field of VARpending. 
*0*(S perform/VB any/DT implementation/NN or/CC host/NN environment/NN defined/VBD processing/NN of/IN (Chunk VARpending/NNP) ./. this/DT may/MD include/VB modifying/VBG the/DT [/NN [/NN (Chunk HOSTDEFINED/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN or/CC any/DT other/JJ field/NN of/IN (Chunk VARpending/NNP) ./.)
*0*add VARpending at the back of the job queue named by VARqueuename. 
*0*(S add/VB VARpending/VBG at/IN the/DT back/NN of/IN the/DT job/NN queue/NN named/VBN by/IN (Chunk VARqueuename/NNP) ./.)
*0*return FUNCnormalcompletion(empty).    
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( empty/JJ )/) ./.)
ID= 8.5
Summary= InitializeHostDefinedRealm ( )
*0*let VARrealm be FUNCcreaterealm(). 
*0*(S (Chunk let/VB VARrealm/NNP) (Chunk be/VB FUNCcreaterealm/NNP) (/( )/) ./.)
*0*let VARnewcontext be a new execution context. 
*0*(S (Chunk let/VB VARnewcontext/NNP) be/VB a/DT new/JJ execution/NN context/NN ./.)
*0*set the function of VARnewcontext to null. 
*0*(S set/VB the/DT function/NN of/IN (Chunk VARnewcontext/NNP) to/TO null/VB ./.)
*0*set the realm of VARnewcontext to VARrealm. 
*0*(S set/VB the/DT realm/NN of/IN (Chunk VARnewcontext/NNP) to/TO (Chunk VARrealm/NNP) ./.)
*0*set the scriptormodule of VARnewcontext to null. 
*0*(S set/VB the/DT scriptormodule/NN of/IN (Chunk VARnewcontext/NNP) to/TO null/VB ./.)
*0*push VARnewcontext onto the execution context stack; VARnewcontext is now the running execution context. 
*0*(S push/NN (Chunk VARnewcontext/NNP) onto/IN the/DT execution/NN context/NN stack/NN ;/: (Chunk VARnewcontext/NNP) is/VBZ now/RB the/DT running/VBG execution/NN context/NN ./.)
*0*if the host requires use of an exotic object to serve as VARrealm's global object, let VARglobal be such an object created in an implementation-defined manner. otherwise, let VARglobal be undefined, indicating that an ordinary object should be created as the global object. 
*0*(S if/IN the/DT host/NN requires/VBZ use/NN of/IN an/DT exotic/JJ object/NN to/TO serve/VB as/IN (Chunk VARrealm/NNP) 's/POS global/JJ object/NN ,/, (Chunk let/VB VARglobal/NNP) be/VB such/JJ an/DT object/NN created/VBD in/IN an/DT implementation-defined/JJ manner/NN ./. otherwise/RB ,/, (Chunk let/VB VARglobal/NNP) be/VB undefined/VBN ,/, indicating/VBG that/IN an/DT ordinary/JJ object/NN should/MD be/VB created/VBN as/IN the/DT global/JJ object/NN ./.)
*0*if the host requires that the this binding in VARrealm's global scope return an object other than the global object, let VARthisvalue be such an object created in an implementation-defined manner. otherwise, let VARthisvalue be undefined, indicating that VARrealm's global this binding should be the global object. 
*0*(S if/IN the/DT host/NN requires/VBZ that/IN the/DT this/DT binding/NN in/IN (Chunk VARrealm/NNP) 's/POS global/JJ scope/NN return/VB an/DT object/NN other/JJ than/IN the/DT global/JJ object/NN ,/, (Chunk let/VB VARthisvalue/NNP) be/VB such/JJ an/DT object/NN created/VBD in/IN an/DT implementation-defined/JJ manner/NN ./. otherwise/RB ,/, (Chunk let/VB VARthisvalue/NNP) be/VB undefined/VBN ,/, indicating/VBG that/IN (Chunk VARrealm/NNP) 's/POS global/JJ this/DT binding/NN should/MD be/VB the/DT global/JJ object/NN ./.)
*0*perform FUNCsetrealmglobalobject(VARrealm, VARglobal, VARthisvalue). 
*0*(S perform/NN (Chunk FUNCsetrealmglobalobject/NNP) (/( (Chunk VARrealm/NNP) ,/, (Chunk VARglobal/NNP) ,/, (Chunk VARthisvalue/NNP) )/) ./.)
*0*let VARglobalobj be ? FUNCsetdefaultglobalbindings(VARrealm). 
*0*(S (Chunk let/VB VARglobalobj/NNP) be/VB ?/. (Chunk FUNCsetdefaultglobalbindings/NNP) (/( (Chunk VARrealm/NNP) )/) ./.)
*0*create any implementation-defined global object properties on VARglobalobj. 
*0*(S create/VB any/DT implementation-defined/JJ global/JJ object/NN properties/NNS on/IN (Chunk VARglobalobj/NNP) ./.)
*0*return FUNCnormalcompletion(empty).   
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( empty/JJ )/) ./.)
ID= 8.6
Summary= RunJobs ( )
*0*perform ? FUNCinitializehostdefinedrealm(). 
*0*(S perform/NN ?/. (Chunk FUNCinitializehostdefinedrealm/NNP) (/( )/) ./.)
*0*in an implementation-dependent manner, obtain the ecmascript source texts (see clause 10) and any associated host-defined values for zero or more ecmascript scripts and/or ecmascript modules. for each such VARsourcetext and VARhostdefined, do
*0*(S in/IN an/DT implementation-dependent/JJ manner/NN ,/, obtain/VB the/DT ecmascript/NN source/NN texts/NN (/( see/VB clause/RB 10/CD )/) and/CC any/DT associated/JJ host-defined/JJ values/NNS for/IN zero/CD or/CC more/JJR ecmascript/JJ scripts/NNS and/or/VBP ecmascript/JJ modules/NNS ./. for/IN each/DT such/JJ (Chunk VARsourcetext/NNP) and/CC (Chunk VARhostdefined/NNP) ,/, do/VBP)
*1*if VARsourcetext is the source code of a script, then
*1*(S if/IN (Chunk VARsourcetext/NNP) is/VBZ the/DT source/NN code/NN of/IN a/DT script/NN ,/, then/RB)
*2*perform FUNCenqueuejob("scriptjobs", scriptevaluationjob, « VARsourcetext, VARhostdefined »). 
*2*(S perform/NN (Chunk FUNCenqueuejob/NNP) (/( ``/`` scriptjobs/NN ''/'' ,/, scriptevaluationjob/NN ,/, (Chunk «/NNP) (Chunk VARsourcetext/NNP) ,/, (Chunk VARhostdefined/NNP) (Chunk »/NNP) )/) ./.)
*1*else VARsourcetext is the source code of a module,
*1*(S (Chunk else/RB VARsourcetext/NNP) is/VBZ the/DT source/NN code/NN of/IN a/DT module/NN ,/,)
*2*perform FUNCenqueuejob("scriptjobs", toplevelmoduleevaluationjob, « VARsourcetext, VARhostdefined »). 
*2*(S perform/NN (Chunk FUNCenqueuejob/NNP) (/( ``/`` scriptjobs/NN ''/'' ,/, toplevelmoduleevaluationjob/NN ,/, (Chunk «/NNP) (Chunk VARsourcetext/NNP) ,/, (Chunk VARhostdefined/NNP) (Chunk »/NNP) )/) ./.)
*0*repeat,
*0*(S repeat/NN ,/,)
*1*suspend the running execution context and remove it from the execution context stack. 
*1*(S suspend/VB the/DT running/JJ execution/NN context/NN and/CC remove/VB it/PRP from/IN the/DT execution/NN context/NN stack/NN ./.)
*1*assert: the execution context stack is now empty. 
*1*(S assert/NN :/: the/DT execution/NN context/NN stack/NN is/VBZ now/RB empty/JJ ./.)
*1*let VARnextqueue be a non-empty job queue chosen in an implementation-defined manner. if all job queues are empty, the result is implementation-defined. 
*1*(S (Chunk let/VB VARnextqueue/NNP) be/VB a/DT non-empty/JJ job/NN queue/JJ chosen/VBN in/IN an/DT implementation-defined/JJ manner/NN ./. if/IN all/DT job/NN queues/NNS are/VBP empty/JJ ,/, the/DT result/NN is/VBZ implementation-defined/JJ ./.)
*1*let VARnextpending be the pendingjob record at the front of VARnextqueue. remove that record from VARnextqueue. 
*1*(S (Chunk let/VB VARnextpending/NNP) be/VB the/DT pendingjob/NN record/NN at/IN the/DT front/NN of/IN (Chunk VARnextqueue/NNP) ./. remove/VB that/IN record/NN from/IN (Chunk VARnextqueue/NNP) ./.)
*1*let VARnewcontext be a new execution context. 
*1*(S (Chunk let/VB VARnewcontext/NNP) be/VB a/DT new/JJ execution/NN context/NN ./.)
*1*set VARnewcontext's function to null. 
*1*(S (Chunk set/VBN VARnewcontext/NNP) 's/POS function/NN to/TO null/VB ./.)
*1*set VARnewcontext's realm to VARnextpending.[[REALM]]. 
*1*(S (Chunk set/VBN VARnewcontext/NNP) 's/POS realm/NN to/TO (Chunk VARnextpending/NNP) ./. [/VB [/JJ (Chunk REALM/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*set VARnewcontext's scriptormodule to VARnextpending.[[SCRIPTORMODULE]]. 
*1*(S (Chunk set/VBN VARnewcontext/NNP) 's/POS scriptormodule/NN to/TO (Chunk VARnextpending/NNP) ./. [/VB [/JJ (Chunk SCRIPTORMODULE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*push VARnewcontext onto the execution context stack; VARnewcontext is now the running execution context. 
*1*(S push/NN (Chunk VARnewcontext/NNP) onto/IN the/DT execution/NN context/NN stack/NN ;/: (Chunk VARnewcontext/NNP) is/VBZ now/RB the/DT running/VBG execution/NN context/NN ./.)
*1*perform any implementation or host environment defined job initialization using VARnextpending. 
*1*(S perform/VB any/DT implementation/NN or/CC host/NN environment/NN defined/VBD job/NN initialization/NN (Chunk using/VBG VARnextpending/NNP) ./.)
*1*let VARresult be the result of performing the abstract operation named by VARnextpending.[[JOB]] using the elements of VARnextpending.[[ARGUMENTS]] as its arguments. 
*1*(S (Chunk let/VB VARresult/NNP) be/VB the/DT result/NN of/IN performing/VBG the/DT abstract/JJ operation/NN named/VBN by/IN VARnextpending/VBG ./. [/JJ [/JJ (Chunk JOB/NNP) (Chunk ]/NNP) (Chunk ]/NNP) using/VBG the/DT elements/NNS of/IN (Chunk VARnextpending/NNP) ./. [/VB [/JJ (Chunk ARGUMENTS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) as/IN its/PRP$ arguments/NNS ./.)
*1*if VARresult is an FUNCabrupt completion, perform hostreporterrors(« VARresult.[[VALUE]] »).   
*1*(S if/IN (Chunk VARresult/NNP) is/VBZ an/DT (Chunk FUNCabrupt/NNP) completion/NN ,/, perform/NN hostreporterrors/NNS (/( «/JJ (Chunk VARresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
ID= 8.7.1
Summary= AgentSignifier ( )
*0*let VARar be the agent record of the surrounding agent. 
*0*(S (Chunk let/VB VARar/NNP) be/VB the/DT agent/NN record/NN of/IN the/DT surrounding/VBG agent/NN ./.)
*0*return VARar.[[SIGNIFIER]].    
*0*(S return/NN (Chunk VARar/NNP) ./. [/VB [/JJ (Chunk SIGNIFIER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
ID= 8.7.2
Summary= AgentCanSuspend ( )
*0*let VARar be the agent record of the surrounding agent. 
*0*(S (Chunk let/VB VARar/NNP) be/VB the/DT agent/NN record/NN of/IN the/DT surrounding/VBG agent/NN ./.)
*0*return VARar.[[CANBLOCK]].    
*0*(S return/NN (Chunk VARar/NNP) ./. [/VB [/JJ (Chunk CANBLOCK/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
ID= 9.1.1
Summary= [[GetPrototypeOf]] ( )
*0*return ! FUNCordinarygetprototypeof(VARo).    
*0*(S return/NN !/. (Chunk FUNCordinarygetprototypeof/NNP) (/( (Chunk VARo/NNP) )/) ./.)
ID= 9.1.1.1
Summary= OrdinaryGetPrototypeOf ( O )
*0*return VARo.[[PROTOTYPE]].     
*0*(S return/NN (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk PROTOTYPE/NNP) ]/NN ]/NN ./.)
ID= 9.1.2
Summary= [[SetPrototypeOf]] ( V )
*0*return ! FUNCordinarysetprototypeof(VARo, VARv).    
*0*(S return/NN !/. (Chunk FUNCordinarysetprototypeof/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARv/NNP) )/) ./.)
ID= 9.1.2.1
Summary= OrdinarySetPrototypeOf ( O, V )
*0*assert: either FUNCtype(VARv) is object or FUNCtype(VARv) is null. 
*0*(S assert/NN :/: either/CC (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ object/JJ or/CC (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ null/JJ ./.)
*0*let VARextensible be VARo.[[EXTENSIBLE]]. 
*0*(S let/VB VARextensible/JJ (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk EXTENSIBLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARcurrent be VARo.[[PROTOTYPE]]. 
*0*(S (Chunk let/VB VARcurrent/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROTOTYPE/NNP) ]/NN ]/NN ./.)
*0*if FUNCsamevalue(VARv, VARcurrent) is true, return true. 
*0*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARcurrent/NNP) )/) is/VBZ true/JJ ,/, return/VB true/JJ ./.)
*0*if VARextensible is false, return false. 
*0*(S if/IN (Chunk VARextensible/NNP) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*0*let VARp be VARv. 
*0*(S (Chunk let/VB VARp/NNP) (Chunk be/VB VARv/NNP) ./.)
*0*let VARdone be false. 
*0*(S (Chunk let/VB VARdone/NNP) be/VB false/JJ ./.)
*0*repeat, while VARdone is false,
*0*(S repeat/NN ,/, while/IN (Chunk VARdone/NNP) is/VBZ false/JJ ,/,)
*1*if VARp is null, set VARdone to true. 
*1*(S if/IN (Chunk VARp/NNP) is/VBZ null/JJ ,/, (Chunk set/VB VARdone/NNP) to/TO true/JJ ./.)
*1*else if FUNCsamevalue(VARp, VARo) is true, return false. 
*1*(S else/RB if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARp/NNP) ,/, (Chunk VARo/NNP) )/) is/VBZ true/JJ ,/, return/NN false/JJ ./.)
*1*else,
*1*(S else/RB ,/,)
*2*if VARp.[[GETPROTOTYPEOF]] is not the ordinary object internal method defined in 9.1.1, set VARdone to true. 
*2*(S if/IN (Chunk VARp/NNP) ./. [/VB [/JJ (Chunk GETPROTOTYPEOF/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB the/DT ordinary/JJ object/NN internal/JJ method/NN defined/VBN in/IN 9.1.1/CD ,/, (Chunk set/VBN VARdone/NNP) to/TO true/JJ ./.)
*2*else, set VARp to VARp.[[PROTOTYPE]]. 
*2*(S else/RB ,/, (Chunk set/VBD VARp/NNP) to/TO (Chunk VARp/NNP) ./. [/VB [/JJ (Chunk PROTOTYPE/NNP) ]/NN ]/NN ./.)
*0*set VARo.[[PROTOTYPE]] to VARv. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk PROTOTYPE/NNP) ]/NN ]/NN to/TO (Chunk VARv/NNP) ./.)
*0*return true.     
*0*(S return/NN true/JJ ./.)
ID= 9.1.3
Summary= [[IsExtensible]] ( )
*0*return ! FUNCordinaryisextensible(VARo).    
*0*(S return/NN !/. (Chunk FUNCordinaryisextensible/NNP) (/( (Chunk VARo/NNP) )/) ./.)
ID= 9.1.3.1
Summary= OrdinaryIsExtensible ( O )
*0*return VARo.[[EXTENSIBLE]].     
*0*(S return/NN (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk EXTENSIBLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
ID= 9.1.4
Summary= [[PreventExtensions]] ( )
*0*return ! FUNCordinarypreventextensions(VARo).    
*0*(S return/NN !/. FUNCordinarypreventextensions/NNS (/( (Chunk VARo/NNP) )/) ./.)
ID= 9.1.4.1
Summary= OrdinaryPreventExtensions ( O )
*0*set VARo.[[EXTENSIBLE]] to false. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk EXTENSIBLE/NNP) ]/NN ]/NN to/TO false/VB ./.)
*0*return true.     
*0*(S return/NN true/JJ ./.)
ID= 9.1.5
Summary= [[GetOwnProperty]] ( P )
*0*return ! FUNCordinarygetownproperty(VARo, VARp).    
*0*(S return/NN !/. (Chunk FUNCordinarygetownproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
ID= 9.1.5.1
Summary= OrdinaryGetOwnProperty ( O, P )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*if VARo does not have an own property with key VARp, return undefined. 
*0*(S if/IN (Chunk VARo/NNP) does/VBZ not/RB have/VB an/DT own/JJ property/NN with/IN key/JJ (Chunk VARp/NNP) ,/, return/NN undefined/VBD ./.)
*0*let VARd be a newly created property descriptor with no fields. 
*0*(S (Chunk let/VB VARd/NNP) be/VB a/DT newly/RB created/VBN property/NN descriptor/NN with/IN no/DT fields/NNS ./.)
*0*let VARx be VARo's own property whose key is VARp. 
*0*(S (Chunk let/VB VARx/NNP) (Chunk be/VB VARo/NNP) 's/POS own/JJ property/NN whose/WP$ key/NN (Chunk is/VBZ VARp/NNP) ./.)
*0*if VARx is a data property, then
*0*(S if/IN (Chunk VARx/NNP) is/VBZ a/DT data/NN property/NN ,/, then/RB)
*1*set VARd.[[VALUE]] to the value of VARx's [[VALUE]] attribute. 
*1*(S (Chunk set/VBN VARd/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO the/DT value/NN of/IN (Chunk VARx/NNP) 's/POS (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) attribute/NN ./.)
*1*set VARd.[[WRITABLE]] to the value of VARx's [[WRITABLE]] attribute. 
*1*(S (Chunk set/VBN VARd/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) ]/NN ]/NN to/TO the/DT value/NN of/IN (Chunk VARx/NNP) 's/POS (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) attribute/NN ./.)
*0*else VARx is an accessor property,
*0*(S (Chunk else/RB VARx/NNP) is/VBZ an/DT accessor/JJ property/NN ,/,)
*1*set VARd.[[GET]] to the value of VARx's [[GET]] attribute. 
*1*(S (Chunk set/VBN VARd/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO the/DT value/NN of/IN (Chunk VARx/NNP) 's/POS (Chunk [/NNP) (Chunk [/NNP) (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) attribute/NN ./.)
*1*set VARd.[[SET]] to the value of VARx's [[SET]] attribute. 
*1*(S (Chunk set/VBN VARd/NNP) ./. [/NN [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO the/DT value/NN of/IN (Chunk VARx/NNP) 's/POS [/JJ [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) attribute/NN ./.)
*0*set VARd.[[ENUMERABLE]] to the value of VARx's [[ENUMERABLE]] attribute. 
*0*(S (Chunk set/VBN VARd/NNP) ./. [/VB [/JJ (Chunk ENUMERABLE/NNP) ]/NN ]/NN to/TO the/DT value/NN of/IN (Chunk VARx/NNP) 's/POS (Chunk [/NNP) (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) attribute/NN ./.)
*0*set VARd.[[CONFIGURABLE]] to the value of VARx's [[CONFIGURABLE]] attribute. 
*0*(S (Chunk set/VBN VARd/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) ]/NN ]/NN to/TO the/DT value/NN of/IN (Chunk VARx/NNP) 's/POS (Chunk [/NNP) (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) attribute/NN ./.)
*0*return VARd.     
*0*(S return/NN (Chunk VARd/NNP) ./.)
ID= 9.1.6
Summary= [[DefineOwnProperty]] ( P, Desc )
*0*return ? FUNCordinarydefineownproperty(VARo, VARp, VARdesc).    
*0*(S return/NN ?/. (Chunk FUNCordinarydefineownproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARdesc/NNP) )/) ./.)
ID= 9.1.6.1
Summary= OrdinaryDefineOwnProperty ( O, P, Desc )
*0*let VARcurrent be ? VARo.[[GETOWNPROPERTY]](VARp). 
*0*(S (Chunk let/VB VARcurrent/NNP) be/VB ?/. (Chunk VARo/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*let VARextensible be VARo.[[EXTENSIBLE]]. 
*0*(S let/VB VARextensible/JJ (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk EXTENSIBLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*return FUNCvalidateandapplypropertydescriptor(VARo, VARp, VARextensible, VARdesc, VARcurrent).     
*0*(S return/NN (Chunk FUNCvalidateandapplypropertydescriptor/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARextensible/NNP) ,/, (Chunk VARdesc/NNP) ,/, (Chunk VARcurrent/NNP) )/) ./.)
ID= 9.1.6.2
Summary= IsCompatiblePropertyDescriptor ( Extensible, Desc, Current )
*0*return FUNCvalidateandapplypropertydescriptor(undefined, undefined, VARextensible, VARdesc, VARcurrent).     
*0*(S return/NN (Chunk FUNCvalidateandapplypropertydescriptor/NNP) (/( undefined/JJ ,/, undefined/JJ ,/, VARextensible/JJ ,/, (Chunk VARdesc/NNP) ,/, (Chunk VARcurrent/NNP) )/) ./.)
ID= 9.1.6.3
Summary= ValidateAndApplyPropertyDescriptor ( O, P, extensible, Desc, current )
*0*assert: if VARo is not undefined, then FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: if/IN (Chunk VARo/NNP) is/VBZ not/RB undefined/JJ ,/, (Chunk then/RB FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*if VARcurrent is undefined, then
*0*(S if/IN (Chunk VARcurrent/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*if VARextensible is false, return false. 
*1*(S if/IN (Chunk VARextensible/NNP) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*1*assert: VARextensible is true. 
*1*(S assert/NN :/: VARextensible/JJ is/VBZ true/JJ ./.)
*1*if FUNCisgenericdescriptor(VARdesc) is true or FUNCisdatadescriptor(VARdesc) is true, then
*1*(S if/IN (Chunk FUNCisgenericdescriptor/NNP) (/( (Chunk VARdesc/NNP) )/) is/VBZ true/JJ or/CC (Chunk FUNCisdatadescriptor/NNP) (/( (Chunk VARdesc/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*if VARo is not undefined, create an own data property named VARp of object VARo whose [[VALUE]], [[WRITABLE]], [[ENUMERABLE]] and [[CONFIGURABLE]] attribute values are described by VARdesc. if the value of an attribute field of VARdesc is absent, the attribute of the newly created property is set to its default value. 
*2*(S if/IN (Chunk VARo/NNP) is/VBZ not/RB undefined/JJ ,/, create/VB an/DT own/JJ data/NN property/NN (Chunk named/VBN VARp/NNP) of/IN object/JJ (Chunk VARo/NNP) whose/WP$ (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) and/CC (Chunk [/NNP) (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) attribute/NN values/NNS are/VBP described/VBN by/IN (Chunk VARdesc/NNP) ./. if/IN the/DT value/NN of/IN an/DT attribute/JJ field/NN of/IN (Chunk VARdesc/NNP) is/VBZ absent/JJ ,/, the/DT attribute/NN of/IN the/DT newly/RB created/VBN property/NN is/VBZ set/VBN to/TO its/PRP$ default/NN value/NN ./.)
*1*else VARdesc must be an accessor property descriptor,
*1*(S (Chunk else/RB VARdesc/NNP) must/MD be/VB an/DT accessor/JJ property/NN descriptor/NN ,/,)
*2*if VARo is not undefined, create an own accessor property named VARp of object VARo whose [[GET]], [[SET]], [[ENUMERABLE]] and [[CONFIGURABLE]] attribute values are described by VARdesc. if the value of an attribute field of VARdesc is absent, the attribute of the newly created property is set to its default value. 
*2*(S if/IN (Chunk VARo/NNP) is/VBZ not/RB undefined/JJ ,/, create/VB an/DT own/JJ accessor/NN property/NN (Chunk named/VBN VARp/NNP) of/IN object/JJ (Chunk VARo/NNP) whose/WP$ (Chunk [/NNP) (Chunk [/NNP) (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) and/CC (Chunk [/NNP) (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) attribute/NN values/NNS are/VBP described/VBN by/IN (Chunk VARdesc/NNP) ./. if/IN the/DT value/NN of/IN an/DT attribute/JJ field/NN of/IN (Chunk VARdesc/NNP) is/VBZ absent/JJ ,/, the/DT attribute/NN of/IN the/DT newly/RB created/VBN property/NN is/VBZ set/VBN to/TO its/PRP$ default/NN value/NN ./.)
*1*return true. 
*1*(S return/NN true/JJ ./.)
*0*if every field in VARdesc is absent, return true. 
*0*(S if/IN every/DT field/NN in/IN (Chunk VARdesc/NNP) is/VBZ absent/JJ ,/, return/VB true/JJ ./.)
*0*if VARcurrent.[[CONFIGURABLE]] is false, then
*0*(S if/IN (Chunk VARcurrent/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, then/RB)
*1*if VARdesc.[[CONFIGURABLE]] is present and its value is true, return false. 
*1*(S if/IN (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ present/JJ and/CC its/PRP$ value/NN is/VBZ true/JJ ,/, return/NN false/JJ ./.)
*1*if VARdesc.[[ENUMERABLE]] is present and the [[ENUMERABLE]] fields of VARcurrent and VARdesc are the boolean negation of each other, return false. 
*1*(S if/IN (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ present/JJ and/CC the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) fields/NNS of/IN (Chunk VARcurrent/NNP) and/CC (Chunk VARdesc/NNP) are/VBP the/DT boolean/JJ negation/NN of/IN each/DT other/JJ ,/, return/JJ false/JJ ./.)
*0*if FUNCisgenericdescriptor(VARdesc) is true, no further validation is required. 
*0*(S if/IN (Chunk FUNCisgenericdescriptor/NNP) (/( (Chunk VARdesc/NNP) )/) is/VBZ true/JJ ,/, no/DT further/JJ validation/NN is/VBZ required/VBN ./.)
*0*else if FUNCisdatadescriptor(VARcurrent) and FUNCisdatadescriptor(VARdesc) have different results, then
*0*(S else/RB if/IN (Chunk FUNCisdatadescriptor/NNP) (/( (Chunk VARcurrent/NNP) )/) and/CC (Chunk FUNCisdatadescriptor/NNP) (/( (Chunk VARdesc/NNP) )/) have/VBP different/JJ results/NNS ,/, then/RB)
*1*if VARcurrent.[[CONFIGURABLE]] is false, return false. 
*1*(S if/IN (Chunk VARcurrent/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*1*if FUNCisdatadescriptor(VARcurrent) is true, then
*1*(S if/IN (Chunk FUNCisdatadescriptor/NNP) (/( (Chunk VARcurrent/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*if VARo is not undefined, convert the property named VARp of object VARo from a data property to an accessor property. preserve the existing values of the converted property's [[CONFIGURABLE]] and [[ENUMERABLE]] attributes and set the rest of the property's attributes to their default values. 
*2*(S if/IN (Chunk VARo/NNP) is/VBZ not/RB undefined/JJ ,/, convert/VBP the/DT property/NN (Chunk named/VBD VARp/NNP) of/IN object/JJ (Chunk VARo/NNP) from/IN a/DT data/NN property/NN to/TO an/DT accessor/NN property/NN ./. preserve/VB the/DT existing/VBG values/NNS of/IN the/DT converted/JJ property/NN 's/POS [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) and/CC (Chunk [/NNP) (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) attributes/NNS and/CC set/VBD the/DT rest/NN of/IN the/DT property/NN 's/POS attributes/NNS to/TO their/PRP$ default/NN values/NNS ./.)
*1*else,
*1*(S else/RB ,/,)
*2*if VARo is not undefined, convert the property named VARp of object VARo from an accessor property to a data property. preserve the existing values of the converted property's [[CONFIGURABLE]] and [[ENUMERABLE]] attributes and set the rest of the property's attributes to their default values. 
*2*(S if/IN (Chunk VARo/NNP) is/VBZ not/RB undefined/JJ ,/, convert/VBP the/DT property/NN (Chunk named/VBD VARp/NNP) of/IN object/JJ (Chunk VARo/NNP) from/IN an/DT accessor/NN property/NN to/TO a/DT data/NN property/NN ./. preserve/VB the/DT existing/VBG values/NNS of/IN the/DT converted/JJ property/NN 's/POS [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) and/CC (Chunk [/NNP) (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) attributes/NNS and/CC set/VBD the/DT rest/NN of/IN the/DT property/NN 's/POS attributes/NNS to/TO their/PRP$ default/NN values/NNS ./.)
*0*else if FUNCisdatadescriptor(VARcurrent) and FUNCisdatadescriptor(VARdesc) are both true, then
*0*(S else/RB if/IN (Chunk FUNCisdatadescriptor/NNP) (/( (Chunk VARcurrent/NNP) )/) and/CC (Chunk FUNCisdatadescriptor/NNP) (/( (Chunk VARdesc/NNP) )/) are/VBP both/DT true/JJ ,/, then/RB)
*1*if VARcurrent.[[CONFIGURABLE]] is false and VARcurrent.[[WRITABLE]] is false, then
*1*(S if/IN (Chunk VARcurrent/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ and/CC (Chunk VARcurrent/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, then/RB)
*2*if VARdesc.[[WRITABLE]] is present and VARdesc.[[WRITABLE]] is true, return false. 
*2*(S if/IN (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ present/JJ and/CC (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ true/JJ ,/, return/NN false/JJ ./.)
*2*if VARdesc.[[VALUE]] is present and FUNCsamevalue(VARdesc.[[VALUE]], VARcurrent.[[VALUE]]) is false, return false. 
*2*(S if/IN (Chunk VARdesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ present/JJ and/CC (Chunk FUNCsamevalue/NNP) (/( (Chunk VARdesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARcurrent/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*2*return true. 
*2*(S return/NN true/JJ ./.)
*0*else FUNCisaccessordescriptor(VARcurrent) and FUNCisaccessordescriptor(VARdesc) are both true,
*0*(S (Chunk else/RB FUNCisaccessordescriptor/NNP) (/( (Chunk VARcurrent/NNP) )/) and/CC (Chunk FUNCisaccessordescriptor/NNP) (/( (Chunk VARdesc/NNP) )/) are/VBP both/DT true/JJ ,/,)
*1*if VARcurrent.[[CONFIGURABLE]] is false, then
*1*(S if/IN (Chunk VARcurrent/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, then/RB)
*2*if VARdesc.[[SET]] is present and FUNCsamevalue(VARdesc.[[SET]], VARcurrent.[[SET]]) is false, return false. 
*2*(S if/IN (Chunk VARdesc/NNP) ./. [/NN [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ present/JJ and/CC (Chunk FUNCsamevalue/NNP) (/( (Chunk VARdesc/NNP) ./. [/NN [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARcurrent/NNP) ./. [/NN [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*2*if VARdesc.[[GET]] is present and FUNCsamevalue(VARdesc.[[GET]], VARcurrent.[[GET]]) is false, return false. 
*2*(S if/IN (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ present/JJ and/CC (Chunk FUNCsamevalue/NNP) (/( (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARcurrent/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*2*return true. 
*2*(S return/NN true/JJ ./.)
*0*if VARo is not undefined, then
*0*(S if/IN (Chunk VARo/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*1*for each field of VARdesc that is present, set the corresponding attribute of the property named VARp of object VARo to the value of the field. 
*1*(S for/IN each/DT field/NN of/IN (Chunk VARdesc/NNP) that/WDT is/VBZ present/JJ ,/, set/VBD the/DT corresponding/JJ attribute/NN of/IN the/DT property/NN (Chunk named/VBD VARp/NNP) of/IN object/JJ (Chunk VARo/NNP) to/TO the/DT value/NN of/IN the/DT field/NN ./.)
*0*return true.     
*0*(S return/NN true/JJ ./.)
ID= 9.1.7
Summary= [[HasProperty]] ( P )
*0*return ? FUNCordinaryhasproperty(VARo, VARp).    
*0*(S return/NN ?/. (Chunk FUNCordinaryhasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
ID= 9.1.7.1
Summary= OrdinaryHasProperty ( O, P )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARhasown be ? VARo.[[GETOWNPROPERTY]](VARp). 
*0*(S (Chunk let/VB VARhasown/NNP) be/VB ?/. (Chunk VARo/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*if VARhasown is not undefined, return true. 
*0*(S if/IN (Chunk VARhasown/NNP) is/VBZ not/RB undefined/JJ ,/, return/VB true/JJ ./.)
*0*let VARparent be ? VARo.[[GETPROTOTYPEOF]](). 
*0*(S (Chunk let/VB VARparent/NNP) be/VB ?/. (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk GETPROTOTYPEOF/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*0*if VARparent is not null, then
*0*(S if/IN (Chunk VARparent/NNP) is/VBZ not/RB null/JJ ,/, then/RB)
*1*return ? VARparent.[[HASPROPERTY]](VARp). 
*1*(S return/NN ?/. (Chunk VARparent/NNP) ./. (Chunk [/VB [/NNP) (Chunk HASPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 9.1.8
Summary= [[Get]] ( P, Receiver )
*0*return ? FUNCordinaryget(VARo, VARp, VARreceiver).    
*0*(S return/NN ?/. (Chunk FUNCordinaryget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARreceiver/NNP) )/) ./.)
ID= 9.1.8.1
Summary= OrdinaryGet ( O, P, Receiver )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARdesc be ? VARo.[[GETOWNPROPERTY]](VARp). 
*0*(S (Chunk let/VB VARdesc/NNP) be/VB ?/. (Chunk VARo/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*if VARdesc is undefined, then
*0*(S if/IN (Chunk VARdesc/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*let VARparent be ? VARo.[[GETPROTOTYPEOF]](). 
*1*(S (Chunk let/VB VARparent/NNP) be/VB ?/. (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk GETPROTOTYPEOF/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*1*if VARparent is null, return undefined. 
*1*(S if/IN (Chunk VARparent/NNP) is/VBZ null/JJ ,/, return/NN undefined/VBD ./.)
*1*return ? VARparent.[[GET]](VARp, VARreceiver). 
*1*(S return/NN ?/. (Chunk VARparent/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) ,/, (Chunk VARreceiver/NNP) )/) ./.)
*0*if FUNCisdatadescriptor(VARdesc) is true, return VARdesc.[[VALUE]]. 
*0*(S if/IN (Chunk FUNCisdatadescriptor/NNP) (/( (Chunk VARdesc/NNP) )/) is/VBZ true/JJ ,/, (Chunk return/VB VARdesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*assert: FUNCisaccessordescriptor(VARdesc) is true. 
*0*(S assert/NN :/: (Chunk FUNCisaccessordescriptor/NNP) (/( (Chunk VARdesc/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARgetter be VARdesc.[[GET]]. 
*0*(S (Chunk let/VB VARgetter/NNP) (Chunk be/VB VARdesc/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARgetter is undefined, return undefined. 
*0*(S if/IN (Chunk VARgetter/NNP) is/VBZ undefined/JJ ,/, return/NN undefined/VBD ./.)
*0*return ? FUNCcall(VARgetter, VARreceiver).     
*0*(S return/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARgetter/NNP) ,/, (Chunk VARreceiver/NNP) )/) ./.)
ID= 9.1.9
Summary= [[Set]] ( P, V, Receiver )
*0*return ? FUNCordinaryset(VARo, VARp, VARv, VARreceiver).    
*0*(S return/NN ?/. (Chunk FUNCordinaryset/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARv/NNP) ,/, (Chunk VARreceiver/NNP) )/) ./.)
ID= 9.1.9.1
Summary= OrdinarySet ( O, P, V, Receiver )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARowndesc be ? VARo.[[GETOWNPROPERTY]](VARp). 
*0*(S (Chunk let/VB VARowndesc/NNP) be/VB ?/. (Chunk VARo/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*return FUNCordinarysetwithowndescriptor(VARo, VARp, VARv, VARreceiver, VARowndesc).     
*0*(S return/NN (Chunk FUNCordinarysetwithowndescriptor/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARv/NNP) ,/, (Chunk VARreceiver/NNP) ,/, (Chunk VARowndesc/NNP) )/) ./.)
ID= 9.1.9.2
Summary= OrdinarySetWithOwnDescriptor ( O, P, V, Receiver, ownDesc )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*if VARowndesc is undefined, then
*0*(S if/IN (Chunk VARowndesc/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*let VARparent be ? VARo.[[GETPROTOTYPEOF]](). 
*1*(S (Chunk let/VB VARparent/NNP) be/VB ?/. (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk GETPROTOTYPEOF/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*1*if VARparent is not null, then
*1*(S if/IN (Chunk VARparent/NNP) is/VBZ not/RB null/JJ ,/, then/RB)
*2*return ? VARparent.[[SET]](VARp, VARv, VARreceiver). 
*2*(S return/NN ?/. (Chunk VARparent/NNP) ./. [/NN [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) ,/, (Chunk VARv/NNP) ,/, (Chunk VARreceiver/NNP) )/) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*set VARowndesc to the propertydescriptor { [[VALUE]]: undefined, [[WRITABLE]]: true, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: true }. 
*2*(S (Chunk set/VBN VARowndesc/NNP) to/TO the/DT propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: undefined/JJ ,/, [/JJ (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ }/) ./.)
*0*if FUNCisdatadescriptor(VARowndesc) is true, then
*0*(S if/IN (Chunk FUNCisdatadescriptor/NNP) (/( (Chunk VARowndesc/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*if VARowndesc.[[WRITABLE]] is false, return false. 
*1*(S if/IN (Chunk VARowndesc/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*1*if FUNCtype(VARreceiver) is not object, return false. 
*1*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARreceiver/NNP) )/) is/VBZ not/RB object/JJ ,/, return/NN false/JJ ./.)
*1*let VARexistingdescriptor be ? VARreceiver.[[GETOWNPROPERTY]](VARp). 
*1*(S (Chunk let/VB VARexistingdescriptor/NNP) be/VB ?/. (Chunk VARreceiver/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*1*if VARexistingdescriptor is not undefined, then
*1*(S if/IN (Chunk VARexistingdescriptor/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*2*if FUNCisaccessordescriptor(VARexistingdescriptor) is true, return false. 
*2*(S if/IN (Chunk FUNCisaccessordescriptor/NNP) (/( (Chunk VARexistingdescriptor/NNP) )/) is/VBZ true/JJ ,/, return/NN false/JJ ./.)
*2*if VARexistingdescriptor.[[WRITABLE]] is false, return false. 
*2*(S if/IN (Chunk VARexistingdescriptor/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*2*let VARvaluedesc be the propertydescriptor { [[VALUE]]: VARv }. 
*2*(S (Chunk let/VB VARvaluedesc/NNP) be/VB the/DT propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARv/NNP) }/) ./.)
*2*return ? VARreceiver.[[DEFINEOWNPROPERTY]](VARp, VARvaluedesc). 
*2*(S return/NN ?/. (Chunk VARreceiver/NNP) ./. (Chunk [/VB [/NNP) (Chunk DEFINEOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) ,/, (Chunk VARvaluedesc/NNP) )/) ./.)
*1*else VARreceiver does not currently have a property VARp,
*1*(S (Chunk else/RB VARreceiver/NNP) does/VBZ not/RB currently/RB have/VBP a/DT property/NN (Chunk VARp/NNP) ,/,)
*2*return ? FUNCcreatedataproperty(VARreceiver, VARp, VARv). 
*2*(S return/NN ?/. (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARreceiver/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARv/NNP) )/) ./.)
*0*assert: FUNCisaccessordescriptor(VARowndesc) is true. 
*0*(S assert/NN :/: (Chunk FUNCisaccessordescriptor/NNP) (/( (Chunk VARowndesc/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARsetter be VARowndesc.[[SET]]. 
*0*(S (Chunk let/VB VARsetter/NNP) (Chunk be/VB VARowndesc/NNP) ./. [/NN [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARsetter is undefined, return false. 
*0*(S if/IN (Chunk VARsetter/NNP) is/VBZ undefined/JJ ,/, return/NN false/JJ ./.)
*0*perform ? FUNCcall(VARsetter, VARreceiver, « VARv »). 
*0*(S perform/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARsetter/NNP) ,/, (Chunk VARreceiver/NNP) ,/, (Chunk «/NNP) (Chunk VARv/NNP) (Chunk »/NNP) )/) ./.)
*0*return true.     
*0*(S return/NN true/JJ ./.)
ID= 9.1.10
Summary= [[Delete]] ( P )
*0*return ? FUNCordinarydelete(VARo, VARp).    
*0*(S return/NN ?/. (Chunk FUNCordinarydelete/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
ID= 9.1.10.1
Summary= OrdinaryDelete ( O, P )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARdesc be ? VARo.[[GETOWNPROPERTY]](VARp). 
*0*(S (Chunk let/VB VARdesc/NNP) be/VB ?/. (Chunk VARo/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*if VARdesc is undefined, return true. 
*0*(S if/IN (Chunk VARdesc/NNP) is/VBZ undefined/JJ ,/, return/VB true/JJ ./.)
*0*if VARdesc.[[CONFIGURABLE]] is true, then
*0*(S if/IN (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ true/JJ ,/, then/RB)
*1*remove the own property with name VARp from VARo. 
*1*(S remove/VB the/DT own/JJ property/NN with/IN name/NN (Chunk VARp/NNP) from/IN (Chunk VARo/NNP) ./.)
*1*return true. 
*1*(S return/NN true/JJ ./.)
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 9.1.11
Summary= [[OwnPropertyKeys]] ( )
*0*return ! FUNCordinaryownpropertykeys(VARo).    
*0*(S return/NN !/. (Chunk FUNCordinaryownpropertykeys/NNP) (/( (Chunk VARo/NNP) )/) ./.)
ID= 9.1.11.1
Summary= OrdinaryOwnPropertyKeys ( O )
*0*let VARkeys be a new empty list. 
*0*(S (Chunk let/VB VARkeys/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*for each own property key VARp of VARo that is an integer index, in ascending numeric index order, do
*0*(S for/IN each/DT own/JJ property/NN key/JJ (Chunk VARp/NNP) of/IN (Chunk VARo/NNP) that/WDT is/VBZ an/DT integer/NN index/NN ,/, in/IN ascending/VBG numeric/JJ index/NN order/NN ,/, do/VBP)
*1*add VARp as the last element of VARkeys. 
*1*(S (Chunk add/RB VARp/NNP) as/IN the/DT last/JJ element/NN of/IN (Chunk VARkeys/NNP) ./.)
*0*for each own property key VARp of VARo that is a string but is not an integer index, in ascending chronological order of property creation, do
*0*(S for/IN each/DT own/JJ property/NN key/JJ (Chunk VARp/NNP) of/IN (Chunk VARo/NNP) that/WDT is/VBZ a/DT string/NN but/CC is/VBZ not/RB an/DT integer/NN index/NN ,/, in/IN ascending/VBG chronological/JJ order/NN of/IN property/NN creation/NN ,/, do/VBP)
*1*add VARp as the last element of VARkeys. 
*1*(S (Chunk add/RB VARp/NNP) as/IN the/DT last/JJ element/NN of/IN (Chunk VARkeys/NNP) ./.)
*0*for each own property key VARp of VARo that is a symbol, in ascending chronological order of property creation, do
*0*(S for/IN each/DT own/JJ property/NN key/JJ (Chunk VARp/NNP) of/IN (Chunk VARo/NNP) that/WDT is/VBZ a/DT symbol/NN ,/, in/IN ascending/VBG chronological/JJ order/NN of/IN property/NN creation/NN ,/, do/VBP)
*1*add VARp as the last element of VARkeys. 
*1*(S (Chunk add/RB VARp/NNP) as/IN the/DT last/JJ element/NN of/IN (Chunk VARkeys/NNP) ./.)
*0*return VARkeys.     
*0*(S return/NN (Chunk VARkeys/NNP) ./.)
ID= 9.1.12
Summary= ObjectCreate ( proto [ , internalSlotsList ] )
*0*if VARinternalslotslist is not present, set VARinternalslotslist to a new empty list. 
*0*(S if/IN (Chunk VARinternalslotslist/NNP) is/VBZ not/RB present/JJ ,/, (Chunk set/VBN VARinternalslotslist/NNP) to/TO a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARobj be a newly created object with an internal slot for each name in VARinternalslotslist. 
*0*(S (Chunk let/VB VARobj/NNP) be/VB a/DT newly/RB created/VBN object/NN with/IN an/DT internal/JJ slot/NN for/IN each/DT name/NN in/IN (Chunk VARinternalslotslist/NNP) ./.)
*0*set VARobj's essential internal methods to the default ordinary object definitions specified in 9.1. 
*0*(S (Chunk set/VBN VARobj/NNP) 's/POS essential/JJ internal/JJ methods/NNS to/TO the/DT default/NN ordinary/JJ object/JJ definitions/NNS specified/VBN in/IN 9.1/CD ./.)
*0*set VARobj.[[PROTOTYPE]] to VARproto. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk PROTOTYPE/NNP) ]/NN ]/NN to/TO (Chunk VARproto/NNP) ./.)
*0*set VARobj.[[EXTENSIBLE]] to true. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk EXTENSIBLE/NNP) ]/NN ]/NN to/TO true/JJ ./.)
*0*return VARobj.    
*0*(S return/NN (Chunk VARobj/NNP) ./.)
ID= 9.1.13
Summary= OrdinaryCreateFromConstructor ( constructor, intrinsicDefaultProto [ , internalSlotsList ] )
*0*assert: VARintrinsicdefaultproto is a string value that is this specification's name of an intrinsic object. the corresponding object must be an intrinsic that is intended to be used as the [[PROTOTYPE]] value of an object. 
*0*(S assert/NN :/: (Chunk VARintrinsicdefaultproto/NNP) is/VBZ a/DT string/VBG value/NN that/WDT is/VBZ this/DT specification/NN 's/POS name/NN of/IN an/DT intrinsic/JJ object/NN ./. the/DT corresponding/JJ object/NN must/MD be/VB an/DT intrinsic/JJ that/WDT is/VBZ intended/VBN to/TO be/VB used/VBN as/IN the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk PROTOTYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) value/NN of/IN an/DT object/NN ./.)
*0*let VARproto be ? FUNCgetprototypefromconstructor(VARconstructor, VARintrinsicdefaultproto). 
*0*(S (Chunk let/VB VARproto/NNP) be/VB ?/. (Chunk FUNCgetprototypefromconstructor/NNP) (/( (Chunk VARconstructor/NNP) ,/, (Chunk VARintrinsicdefaultproto/NNP) )/) ./.)
*0*return FUNCobjectcreate(VARproto, VARinternalslotslist).    
*0*(S return/NN (Chunk FUNCobjectcreate/NNP) (/( (Chunk VARproto/NNP) ,/, (Chunk VARinternalslotslist/NNP) )/) ./.)
ID= 9.1.14
Summary= GetPrototypeFromConstructor ( constructor, intrinsicDefaultProto )
*0*assert: VARintrinsicdefaultproto is a string value that is this specification's name of an intrinsic object. the corresponding object must be an intrinsic that is intended to be used as the [[PROTOTYPE]] value of an object. 
*0*(S assert/NN :/: (Chunk VARintrinsicdefaultproto/NNP) is/VBZ a/DT string/VBG value/NN that/WDT is/VBZ this/DT specification/NN 's/POS name/NN of/IN an/DT intrinsic/JJ object/NN ./. the/DT corresponding/JJ object/NN must/MD be/VB an/DT intrinsic/JJ that/WDT is/VBZ intended/VBN to/TO be/VB used/VBN as/IN the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk PROTOTYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) value/NN of/IN an/DT object/NN ./.)
*0*assert: FUNCiscallable(VARconstructor) is true. 
*0*(S assert/NN :/: FUNCiscallable/JJ (/( (Chunk VARconstructor/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARproto be ? FUNCget(VARconstructor, "prototype"). 
*0*(S (Chunk let/VB VARproto/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARconstructor/NNP) ,/, ``/`` prototype/NN ''/'' )/) ./.)
*0*if FUNCtype(VARproto) is not object, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARproto/NNP) )/) is/VBZ not/RB object/JJ ,/, then/RB)
*1*let VARrealm be ? FUNCgetfunctionrealm(VARconstructor). 
*1*(S (Chunk let/VB VARrealm/NNP) be/VB ?/. (Chunk FUNCgetfunctionrealm/NNP) (/( (Chunk VARconstructor/NNP) )/) ./.)
*1*set VARproto to VARrealm's intrinsic object named VARintrinsicdefaultproto. 
*1*(S (Chunk set/VBN VARproto/NNP) to/TO (Chunk VARrealm/NNP) 's/POS intrinsic/JJ object/NN (Chunk named/VBN VARintrinsicdefaultproto/NNP) ./.)
*0*return VARproto.    
*0*(S return/NN (Chunk VARproto/NNP) ./.)
ID= 9.2.1
Summary= [[Call]] ( thisArgument, argumentsList )
*0*assert: VARf is an ecmascript function object. 
*0*(S assert/NN :/: (Chunk VARf/NNP) is/VBZ an/DT ecmascript/JJ function/NN object/NN ./.)
*0*if VARf.[[FUNCTIONKIND]] is "classconstructor", throw a typeerror exception. 
*0*(S if/IN (Chunk VARf/NNP) ./. [/VB [/JJ (Chunk FUNCTIONKIND/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` classconstructor/NN ''/'' ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARcallercontext be the running execution context. 
*0*(S (Chunk let/VB VARcallercontext/NNP) be/VB the/DT running/JJ execution/NN context/NN ./.)
*0*let VARcalleecontext be FUNCprepareforordinarycall(VARf, undefined). 
*0*(S (Chunk let/VB VARcalleecontext/NNP) (Chunk be/VB FUNCprepareforordinarycall/NNP) (/( (Chunk VARf/NNP) ,/, undefined/VBD )/) ./.)
*0*assert: VARcalleecontext is now the running execution context. 
*0*(S assert/NN :/: (Chunk VARcalleecontext/NNP) is/VBZ now/RB the/DT running/VBG execution/NN context/NN ./.)
*0*perform FUNCordinarycallbindthis(VARf, VARcalleecontext, VARthisargument). 
*0*(S (Chunk perform/VB FUNCordinarycallbindthis/NNP) (/( (Chunk VARf/NNP) ,/, (Chunk VARcalleecontext/NNP) ,/, (Chunk VARthisargument/NNP) )/) ./.)
*0*let VARresult be FUNCordinarycallevaluatebody(VARf, VARargumentslist). 
*0*(S (Chunk let/VB VARresult/NNP) (Chunk be/VB FUNCordinarycallevaluatebody/NNP) (/( (Chunk VARf/NNP) ,/, (Chunk VARargumentslist/NNP) )/) ./.)
*0*remove VARcalleecontext from the execution context stack and restore VARcallercontext as the running execution context. 
*0*(S (Chunk remove/VB VARcalleecontext/NNP) from/IN the/DT execution/NN context/NN stack/NN and/CC (Chunk restore/VB VARcallercontext/NNP) as/IN the/DT running/VBG execution/NN context/NN ./.)
*0*if VARresult.[[TYPE]] is return, return FUNCnormalcompletion(VARresult.[[VALUE]]). 
*0*(S if/IN (Chunk VARresult/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ return/JJ ,/, return/JJ (Chunk FUNCnormalcompletion/NNP) (/( (Chunk VARresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*0*FUNCreturnifabrupt(VARresult). 
*0*(S (Chunk FUNCreturnifabrupt/NNP) (/( (Chunk VARresult/NNP) )/) ./.)
*0*return FUNCnormalcompletion(undefined).    
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( undefined/JJ )/) ./.)
ID= 9.2.1.1
Summary= PrepareForOrdinaryCall ( F, newTarget )
*0*assert: FUNCtype(VARnewtarget) is undefined or object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARnewtarget/NNP) )/) is/VBZ undefined/JJ or/CC object/JJ ./.)
*0*let VARcallercontext be the running execution context. 
*0*(S (Chunk let/VB VARcallercontext/NNP) be/VB the/DT running/JJ execution/NN context/NN ./.)
*0*let VARcalleecontext be a new ecmascript code execution context. 
*0*(S (Chunk let/VB VARcalleecontext/NNP) be/VB a/DT new/JJ ecmascript/NN code/NN execution/NN context/NN ./.)
*0*set the function of VARcalleecontext to VARf. 
*0*(S set/VB the/DT function/NN of/IN (Chunk VARcalleecontext/NNP) to/TO (Chunk VARf/NNP) ./.)
*0*let VARcalleerealm be VARf.[[REALM]]. 
*0*(S (Chunk let/VB VARcalleerealm/NNP) (Chunk be/VB VARf/NNP) ./. [/VB [/JJ (Chunk REALM/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*set the realm of VARcalleecontext to VARcalleerealm. 
*0*(S set/VB the/DT realm/NN of/IN (Chunk VARcalleecontext/NNP) to/TO (Chunk VARcalleerealm/NNP) ./.)
*0*set the scriptormodule of VARcalleecontext to VARf.[[SCRIPTORMODULE]]. 
*0*(S set/VB the/DT scriptormodule/NN of/IN (Chunk VARcalleecontext/NNP) to/TO (Chunk VARf/NNP) ./. [/VB [/JJ (Chunk SCRIPTORMODULE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARlocalenv be FUNCnewfunctionenvironment(VARf, VARnewtarget). 
*0*(S (Chunk let/VB VARlocalenv/NNP) (Chunk be/VB FUNCnewfunctionenvironment/NNP) (/( (Chunk VARf/NNP) ,/, (Chunk VARnewtarget/NNP) )/) ./.)
*0*set the lexicalenvironment of VARcalleecontext to VARlocalenv. 
*0*(S set/VB the/DT lexicalenvironment/NN of/IN (Chunk VARcalleecontext/NNP) to/TO (Chunk VARlocalenv/NNP) ./.)
*0*set the variableenvironment of VARcalleecontext to VARlocalenv. 
*0*(S set/VB the/DT variableenvironment/NN of/IN (Chunk VARcalleecontext/NNP) to/TO (Chunk VARlocalenv/NNP) ./.)
*0*if VARcallercontext is not already suspended, suspend VARcallercontext. 
*0*(S if/IN (Chunk VARcallercontext/NNP) is/VBZ not/RB already/RB suspended/VBN ,/, (Chunk suspend/VBP VARcallercontext/NNP) ./.)
*0*push VARcalleecontext onto the execution context stack; VARcalleecontext is now the running execution context. 
*0*(S push/NN (Chunk VARcalleecontext/NNP) onto/IN the/DT execution/NN context/NN stack/NN ;/: (Chunk VARcalleecontext/NNP) is/VBZ now/RB the/DT running/VBG execution/NN context/NN ./.)
*0*note: any exception objects produced after this point are associated with VARcalleerealm. 
*0*(S note/NN :/: any/DT exception/NN objects/NNS produced/VBN after/IN this/DT point/NN are/VBP associated/VBN with/IN (Chunk VARcalleerealm/NNP) ./.)
*0*return VARcalleecontext.     
*0*(S return/NN (Chunk VARcalleecontext/NNP) ./.)
ID= 9.2.1.2
Summary= OrdinaryCallBindThis ( F, calleeContext, thisArgument )
*0*let VARthismode be VARf.[[THISMODE]]. 
*0*(S (Chunk let/VB VARthismode/NNP) (Chunk be/VB VARf/NNP) ./. [/VB [/JJ (Chunk THISMODE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARthismode is lexical, return FUNCnormalcompletion(undefined). 
*0*(S if/IN (Chunk VARthismode/NNP) is/VBZ lexical/JJ ,/, return/JJ (Chunk FUNCnormalcompletion/NNP) (/( undefined/JJ )/) ./.)
*0*let VARcalleerealm be VARf.[[REALM]]. 
*0*(S (Chunk let/VB VARcalleerealm/NNP) (Chunk be/VB VARf/NNP) ./. [/VB [/JJ (Chunk REALM/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARlocalenv be the lexicalenvironment of VARcalleecontext. 
*0*(S (Chunk let/VB VARlocalenv/NNP) be/VB the/DT lexicalenvironment/NN of/IN (Chunk VARcalleecontext/NNP) ./.)
*0*if VARthismode is strict, let VARthisvalue be VARthisargument. 
*0*(S if/IN (Chunk VARthismode/NNP) is/VBZ strict/JJ ,/, (Chunk let/VB VARthisvalue/NNP) (Chunk be/VB VARthisargument/NNP) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*if VARthisargument is undefined or null, then
*1*(S if/IN (Chunk VARthisargument/NNP) is/VBZ undefined/JJ or/CC null/JJ ,/, then/RB)
*2*let VARglobalenv be VARcalleerealm.[[GLOBALENV]]. 
*2*(S (Chunk let/VB VARglobalenv/NNP) (Chunk be/VB VARcalleerealm/NNP) ./. [/VB [/JJ (Chunk GLOBALENV/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*2*let VARglobalenvrec be VARglobalenv's environmentrecord. 
*2*(S (Chunk let/VB VARglobalenvrec/NNP) (Chunk be/VB VARglobalenv/NNP) 's/POS environmentrecord/NN ./.)
*2*assert: VARglobalenvrec is a global environment record. 
*2*(S assert/NN :/: (Chunk VARglobalenvrec/NNP) is/VBZ a/DT global/JJ environment/NN record/NN ./.)
*2*let VARthisvalue be VARglobalenvrec.[[GLOBALTHISVALUE]]. 
*2*(S (Chunk let/VB VARthisvalue/NNP) (Chunk be/VB VARglobalenvrec/NNP) ./. [/VB [/JJ (Chunk GLOBALTHISVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*let VARthisvalue be ! FUNCtoobject(VARthisargument). 
*2*(S (Chunk let/VB VARthisvalue/NNP) be/VB !/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARthisargument/NNP) )/) ./.)
*2*note: toobject produces wrapper objects using VARcalleerealm. 
*2*(S note/NN :/: toobject/NN produces/VBZ wrapper/JJR objects/NNS (Chunk using/VBG VARcalleerealm/NNP) ./.)
*0*let VARenvrec be VARlocalenv's environmentrecord. 
*0*(S (Chunk let/VB VARenvrec/NNP) (Chunk be/VB VARlocalenv/NNP) 's/POS environmentrecord/NN ./.)
*0*assert: VARenvrec is a function environment record. 
*0*(S assert/NN :/: (Chunk VARenvrec/NNP) is/VBZ a/DT function/NN environment/NN record/NN ./.)
*0*assert: the next step never returns an abrupt completion because VARenvrec.[[THISBINDINGSTATUS]] is not "initialized". 
*0*(S assert/NN :/: the/DT next/JJ step/NN never/RB returns/VBZ an/DT abrupt/JJ completion/NN because/IN (Chunk VARenvrec/NNP) ./. [/VB [/JJ (Chunk THISBINDINGSTATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB ``/`` initialized/JJ ''/'' ./.)
*0*return VARenvrec.bindthisvalue(VARthisvalue).     
*0*(S return/NN (Chunk VARenvrec.bindthisvalue/NNP) (/( (Chunk VARthisvalue/NNP) )/) ./.)
ID= 9.2.1.3
Summary= OrdinaryCallEvaluateBody ( F, argumentsList )
*0*return the result of evaluatebody of the parsed code that is VARf.[[ECMASCRIPTCODE]] passing VARf and VARargumentslist as the arguments.     
*0*(S return/VB the/DT result/NN of/IN evaluatebody/NN of/IN the/DT parsed/JJ code/NN that/WDT (Chunk is/VBZ VARf/NNP) ./. [/VB [/JJ (Chunk ECMASCRIPTCODE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk passing/VBG VARf/NNP) and/CC (Chunk VARargumentslist/NNP) as/IN the/DT arguments/NNS ./.)
ID= 9.2.2
Summary= [[Construct]] ( argumentsList, newTarget )
*0*assert: VARf is an ecmascript function object. 
*0*(S assert/NN :/: (Chunk VARf/NNP) is/VBZ an/DT ecmascript/JJ function/NN object/NN ./.)
*0*assert: FUNCtype(VARnewtarget) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARnewtarget/NNP) )/) is/VBZ object/JJ ./.)
*0*let VARcallercontext be the running execution context. 
*0*(S (Chunk let/VB VARcallercontext/NNP) be/VB the/DT running/JJ execution/NN context/NN ./.)
*0*let VARkind be VARf.[[CONSTRUCTORKIND]]. 
*0*(S (Chunk let/VB VARkind/NNP) (Chunk be/VB VARf/NNP) ./. [/VB [/JJ (Chunk CONSTRUCTORKIND/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARkind is "base", then
*0*(S if/IN (Chunk VARkind/NNP) is/VBZ ``/`` base/NN ''/'' ,/, then/RB)
*1*let VARthisargument be ? FUNCordinarycreatefromconstructor(VARnewtarget, "%objectprototype%"). 
*1*(S (Chunk let/VB VARthisargument/NNP) be/VB ?/. (Chunk FUNCordinarycreatefromconstructor/NNP) (/( (Chunk VARnewtarget/NNP) ,/, ``/`` %/NN objectprototype/JJ %/NN ''/'' )/) ./.)
*0*let VARcalleecontext be FUNCprepareforordinarycall(VARf, VARnewtarget). 
*0*(S (Chunk let/VB VARcalleecontext/NNP) (Chunk be/VB FUNCprepareforordinarycall/NNP) (/( (Chunk VARf/NNP) ,/, (Chunk VARnewtarget/NNP) )/) ./.)
*0*assert: VARcalleecontext is now the running execution context. 
*0*(S assert/NN :/: (Chunk VARcalleecontext/NNP) is/VBZ now/RB the/DT running/VBG execution/NN context/NN ./.)
*0*if VARkind is "base", perform FUNCordinarycallbindthis(VARf, VARcalleecontext, VARthisargument). 
*0*(S if/IN (Chunk VARkind/NNP) is/VBZ ``/`` base/NN ''/'' ,/, (Chunk perform/VB FUNCordinarycallbindthis/NNP) (/( (Chunk VARf/NNP) ,/, (Chunk VARcalleecontext/NNP) ,/, (Chunk VARthisargument/NNP) )/) ./.)
*0*let VARconstructorenv be the lexicalenvironment of VARcalleecontext. 
*0*(S (Chunk let/VB VARconstructorenv/NNP) be/VB the/DT lexicalenvironment/NN of/IN (Chunk VARcalleecontext/NNP) ./.)
*0*let VARenvrec be VARconstructorenv's environmentrecord. 
*0*(S (Chunk let/VB VARenvrec/NNP) (Chunk be/VB VARconstructorenv/NNP) 's/POS environmentrecord/NN ./.)
*0*let VARresult be FUNCordinarycallevaluatebody(VARf, VARargumentslist). 
*0*(S (Chunk let/VB VARresult/NNP) (Chunk be/VB FUNCordinarycallevaluatebody/NNP) (/( (Chunk VARf/NNP) ,/, (Chunk VARargumentslist/NNP) )/) ./.)
*0*remove VARcalleecontext from the execution context stack and restore VARcallercontext as the running execution context. 
*0*(S (Chunk remove/VB VARcalleecontext/NNP) from/IN the/DT execution/NN context/NN stack/NN and/CC (Chunk restore/VB VARcallercontext/NNP) as/IN the/DT running/VBG execution/NN context/NN ./.)
*0*if VARresult.[[TYPE]] is return, then
*0*(S if/IN (Chunk VARresult/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ return/NN ,/, then/RB)
*1*if FUNCtype(VARresult.[[VALUE]]) is object, return FUNCnormalcompletion(VARresult.[[VALUE]]). 
*1*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) is/VBZ object/JJ ,/, (Chunk return/VB FUNCnormalcompletion/NNP) (/( (Chunk VARresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*1*if VARkind is "base", return FUNCnormalcompletion(VARthisargument). 
*1*(S if/IN (Chunk VARkind/NNP) is/VBZ ``/`` base/NN ''/'' ,/, (Chunk return/VB FUNCnormalcompletion/NNP) (/( (Chunk VARthisargument/NNP) )/) ./.)
*1*if VARresult.[[VALUE]] is not undefined, throw a typeerror exception. 
*1*(S if/IN (Chunk VARresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*else, FUNCreturnifabrupt(VARresult). 
*0*(S else/RB ,/, (Chunk FUNCreturnifabrupt/NNP) (/( (Chunk VARresult/NNP) )/) ./.)
*0*return ? VARenvrec.getthisbinding().    
*0*(S return/NN ?/. (Chunk VARenvrec.getthisbinding/NNP) (/( )/) ./.)
ID= 9.2.3
Summary= FunctionAllocate ( functionPrototype, strict, functionKind )
*0*assert: FUNCtype(VARfunctionprototype) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARfunctionprototype/NNP) )/) is/VBZ object/JJ ./.)
*0*assert: VARfunctionkind is either "normal", "non-constructor", "generator", "async", or "async generator". 
*0*(S assert/NN :/: (Chunk VARfunctionkind/NNP) is/VBZ either/RB ``/`` normal/JJ ''/'' ,/, ``/`` non-constructor/NN ''/'' ,/, ``/`` generator/NN ''/'' ,/, ``/`` async/NN ''/'' ,/, or/CC ``/`` async/JJ generator/NN ''/'' ./.)
*0*if VARfunctionkind is "normal", let VARneedsconstruct be true. 
*0*(S if/IN (Chunk VARfunctionkind/NNP) is/VBZ ``/`` normal/JJ ''/'' ,/, (Chunk let/VB VARneedsconstruct/NNP) be/VB true/JJ ./.)
*0*else, let VARneedsconstruct be false. 
*0*(S else/RB ,/, (Chunk let/VB VARneedsconstruct/NNP) be/VB false/JJ ./.)
*0*if VARfunctionkind is "non-constructor", set VARfunctionkind to "normal". 
*0*(S if/IN (Chunk VARfunctionkind/NNP) is/VBZ ``/`` non-constructor/JJ ''/'' ,/, (Chunk set/VBD VARfunctionkind/NNP) to/TO ``/`` normal/JJ ''/'' ./.)
*0*let VARf be a newly created ecmascript function object with the internal slots listed in table 27. all of those internal slots are initialized to undefined. 
*0*(S (Chunk let/VB VARf/NNP) be/VB a/DT newly/RB created/VBN ecmascript/NN function/NN object/NN with/IN the/DT internal/JJ slots/NNS listed/VBN in/IN table/JJ 27./CD all/DT of/IN those/DT internal/JJ slots/NNS are/VBP initialized/VBN to/TO undefined/JJ ./.)
*0*set VARf's essential internal methods to the default ordinary object definitions specified in 9.1. 
*0*(S (Chunk set/VBN VARf/NNP) 's/POS essential/JJ internal/JJ methods/NNS to/TO the/DT default/NN ordinary/JJ object/JJ definitions/NNS specified/VBN in/IN 9.1/CD ./.)
*0*set VARf.[[CALL]] to the definition specified in 9.2.1. 
*0*(S (Chunk set/VBN VARf/NNP) ./. [/VB [/JJ (Chunk CALL/NNP) (Chunk ]/NNP) ]/NN to/TO the/DT definition/NN specified/VBN in/IN 9.2.1/CD ./.)
*0*if VARneedsconstruct is true, then
*0*(S if/IN (Chunk VARneedsconstruct/NNP) is/VBZ true/JJ ,/, then/RB)
*1*set VARf.[[CONSTRUCT]] to the definition specified in 9.2.2. 
*1*(S (Chunk set/VBN VARf/NNP) ./. (Chunk [/NNP) (Chunk [/NNP) (Chunk CONSTRUCT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO the/DT definition/NN specified/VBN in/IN 9.2.2/CD ./.)
*1*set VARf.[[CONSTRUCTORKIND]] to "base". 
*1*(S (Chunk set/VBN VARf/NNP) ./. [/VB [/JJ (Chunk CONSTRUCTORKIND/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` base/VB ''/'' ./.)
*0*set VARf.[[STRICT]] to VARstrict. 
*0*(S (Chunk set/VBN VARf/NNP) ./. [/VB [/JJ (Chunk STRICT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARstrict/NNP) ./.)
*0*set VARf.[[FUNCTIONKIND]] to VARfunctionkind. 
*0*(S (Chunk set/VBN VARf/NNP) ./. [/VB [/JJ (Chunk FUNCTIONKIND/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARfunctionkind/NNP) ./.)
*0*set VARf.[[PROTOTYPE]] to VARfunctionprototype. 
*0*(S (Chunk set/VBN VARf/NNP) ./. [/VB [/JJ (Chunk PROTOTYPE/NNP) ]/NN ]/NN to/TO (Chunk VARfunctionprototype/NNP) ./.)
*0*set VARf.[[EXTENSIBLE]] to true. 
*0*(S (Chunk set/VBN VARf/NNP) ./. [/VB [/JJ (Chunk EXTENSIBLE/NNP) ]/NN ]/NN to/TO true/JJ ./.)
*0*set VARf.[[REALM]] to the current realm record. 
*0*(S (Chunk set/VBN VARf/NNP) ./. [/VB [/JJ (Chunk REALM/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO the/DT current/JJ realm/NN record/NN ./.)
*0*return VARf.    
*0*(S return/NN (Chunk VARf/NNP) ./.)
ID= 9.2.4
Summary= FunctionInitialize ( F, kind, ParameterList, Body, Scope )
*0*let VARlen be the expectedargumentcount of VARparameterlist. 
*0*(S (Chunk let/VB VARlen/NNP) be/VB the/DT expectedargumentcount/NN of/IN (Chunk VARparameterlist/NNP) ./.)
*0*perform ! FUNCsetfunctionlength(VARf, VARlen). 
*0*(S perform/NN !/. (Chunk FUNCsetfunctionlength/NNP) (/( (Chunk VARf/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*let VARstrict be VARf.[[STRICT]]. 
*0*(S (Chunk let/VB VARstrict/NNP) (Chunk be/VB VARf/NNP) ./. [/VB [/JJ (Chunk STRICT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*set VARf.[[ENVIRONMENT]] to VARscope. 
*0*(S (Chunk set/VBN VARf/NNP) ./. [/VB [/JJ (Chunk ENVIRONMENT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARscope/NNP) ./.)
*0*set VARf.[[FORMALPARAMETERS]] to VARparameterlist. 
*0*(S (Chunk set/VBN VARf/NNP) ./. [/VB [/JJ (Chunk FORMALPARAMETERS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARparameterlist/NNP) ./.)
*0*set VARf.[[ECMASCRIPTCODE]] to VARbody. 
*0*(S (Chunk set/VBN VARf/NNP) ./. [/VB [/JJ (Chunk ECMASCRIPTCODE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARbody/NNP) ./.)
*0*set VARf.[[SCRIPTORMODULE]] to FUNCgetactivescriptormodule(). 
*0*(S (Chunk set/VBN VARf/NNP) ./. [/VB [/JJ (Chunk SCRIPTORMODULE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk FUNCgetactivescriptormodule/NNP) (/( )/) ./.)
*0*if VARkind is arrow, set VARf.[[THISMODE]] to lexical. 
*0*(S if/IN (Chunk VARkind/NNP) is/VBZ arrow/JJ ,/, (Chunk set/VBN VARf/NNP) ./. [/VB [/JJ (Chunk THISMODE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO lexical/VB ./.)
*0*else if VARstrict is true, set VARf.[[THISMODE]] to strict. 
*0*(S else/RB if/IN (Chunk VARstrict/NNP) is/VBZ true/JJ ,/, (Chunk set/VBN VARf/NNP) ./. [/VB [/JJ (Chunk THISMODE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO strict/VB ./.)
*0*else, set VARf.[[THISMODE]] to global. 
*0*(S else/RB ,/, (Chunk set/VBN VARf/NNP) ./. [/VB [/JJ (Chunk THISMODE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO global/JJ ./.)
*0*return VARf.    
*0*(S return/NN (Chunk VARf/NNP) ./.)
ID= 9.2.5
Summary= FunctionCreate ( kind, ParameterList, Body, Scope, Strict [ , prototype ] )
*0*if VARprototype is not present, then
*0*(S if/IN (Chunk VARprototype/NNP) is/VBZ not/RB present/JJ ,/, then/RB)
*1*set VARprototype to the intrinsic object %functionprototype%. 
*1*(S (Chunk set/VBN VARprototype/NNP) to/TO the/DT intrinsic/JJ object/NN %/NN functionprototype/NN %/NN ./.)
*0*if VARkind is not normal, let VARallockind be "non-constructor". 
*0*(S if/IN (Chunk VARkind/NNP) is/VBZ not/RB normal/JJ ,/, (Chunk let/VB VARallockind/NNP) be/VB ``/`` non-constructor/JJ ''/'' ./.)
*0*else, let VARallockind be "normal". 
*0*(S else/RB ,/, (Chunk let/VB VARallockind/NNP) be/VB ``/`` normal/JJ ''/'' ./.)
*0*let VARf be FUNCfunctionallocate(VARprototype, VARstrict, VARallockind). 
*0*(S (Chunk let/VB VARf/NNP) (Chunk be/VB FUNCfunctionallocate/NNP) (/( (Chunk VARprototype/NNP) ,/, (Chunk VARstrict/NNP) ,/, (Chunk VARallockind/NNP) )/) ./.)
*0*return FUNCfunctioninitialize(VARf, VARkind, VARparameterlist, VARbody, VARscope).    
*0*(S return/NN (Chunk FUNCfunctioninitialize/NNP) (/( (Chunk VARf/NNP) ,/, (Chunk VARkind/NNP) ,/, (Chunk VARparameterlist/NNP) ,/, (Chunk VARbody/NNP) ,/, (Chunk VARscope/NNP) )/) ./.)
ID= 9.2.6
Summary= GeneratorFunctionCreate ( kind, ParameterList, Body, Scope, Strict )
*0*let VARfunctionprototype be the intrinsic object %generator%. 
*0*(S (Chunk let/VB VARfunctionprototype/NNP) be/VB the/DT intrinsic/JJ object/NN %/NN generator/NN %/NN ./.)
*0*let VARf be FUNCfunctionallocate(VARfunctionprototype, VARstrict, "generator"). 
*0*(S (Chunk let/VB VARf/NNP) (Chunk be/VB FUNCfunctionallocate/NNP) (/( (Chunk VARfunctionprototype/NNP) ,/, (Chunk VARstrict/NNP) ,/, ``/`` generator/NN ''/'' )/) ./.)
*0*return FUNCfunctioninitialize(VARf, VARkind, VARparameterlist, VARbody, VARscope).    
*0*(S return/NN (Chunk FUNCfunctioninitialize/NNP) (/( (Chunk VARf/NNP) ,/, (Chunk VARkind/NNP) ,/, (Chunk VARparameterlist/NNP) ,/, (Chunk VARbody/NNP) ,/, (Chunk VARscope/NNP) )/) ./.)
ID= 9.2.7
Summary= AsyncGeneratorFunctionCreate ( kind, ParameterList, Body, Scope, Strict )
*0*let VARfunctionprototype be the intrinsic object %asyncgenerator%. 
*0*(S (Chunk let/VB VARfunctionprototype/NNP) be/VB the/DT intrinsic/JJ object/NN %/NN asyncgenerator/NN %/NN ./.)
*0*let VARf be ! FUNCfunctionallocate(VARfunctionprototype, VARstrict, "generator"). 
*0*(S (Chunk let/VB VARf/NNP) be/VB !/. (Chunk FUNCfunctionallocate/NNP) (/( (Chunk VARfunctionprototype/NNP) ,/, (Chunk VARstrict/NNP) ,/, ``/`` generator/NN ''/'' )/) ./.)
*0*return ! FUNCfunctioninitialize(VARf, VARkind, VARparameterlist, VARbody, VARscope).    
*0*(S return/NN !/. (Chunk FUNCfunctioninitialize/NNP) (/( (Chunk VARf/NNP) ,/, (Chunk VARkind/NNP) ,/, (Chunk VARparameterlist/NNP) ,/, (Chunk VARbody/NNP) ,/, (Chunk VARscope/NNP) )/) ./.)
ID= 9.2.8
Summary= AsyncFunctionCreate ( kind, parameters, body, Scope, Strict )
*0*let VARfunctionprototype be the intrinsic object %asyncfunctionprototype%. 
*0*(S (Chunk let/VB VARfunctionprototype/NNP) be/VB the/DT intrinsic/JJ object/NN %/NN asyncfunctionprototype/NN %/NN ./.)
*0*let VARf be ! FUNCfunctionallocate(VARfunctionprototype, VARstrict, "async"). 
*0*(S (Chunk let/VB VARf/NNP) be/VB !/. (Chunk FUNCfunctionallocate/NNP) (/( (Chunk VARfunctionprototype/NNP) ,/, (Chunk VARstrict/NNP) ,/, ``/`` async/NN ''/'' )/) ./.)
*0*return ! FUNCfunctioninitialize(VARf, VARkind, VARparameters, VARbody, VARscope).    
*0*(S return/NN !/. (Chunk FUNCfunctioninitialize/NNP) (/( (Chunk VARf/NNP) ,/, (Chunk VARkind/NNP) ,/, (Chunk VARparameters/NNP) ,/, (Chunk VARbody/NNP) ,/, (Chunk VARscope/NNP) )/) ./.)
ID= 9.2.9
Summary= AddRestrictedFunctionProperties ( F, realm )
*0*assert: VARrealm.[[INTRINSICS]].[[%THROWTYPEERROR%]] exists and has been initialized. 
*0*(S assert/NN :/: (Chunk VARrealm./NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk INTRINSICS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./. [/VB [/CD %/NN (Chunk THROWTYPEERROR/NNP) %/NN (Chunk ]/NNP) (Chunk ]/NNP) exists/NNS and/CC has/VBZ been/VBN initialized/VBN ./.)
*0*let VARthrower be VARrealm.[[INTRINSICS]].[[%THROWTYPEERROR%]]. 
*0*(S (Chunk let/VB VARthrower/NNP) (Chunk be/VB VARrealm./NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk INTRINSICS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./. [/VB [/CD %/NN (Chunk THROWTYPEERROR/NNP) %/NN (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*perform ! FUNCdefinepropertyorthrow(VARf, "caller", propertydescriptor { [[GET]]: VARthrower, [[SET]]: VARthrower, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }). 
*0*(S perform/NN !/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARf/NNP) ,/, ``/`` caller/NN ''/'' ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk GET/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARthrower/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk SET/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARthrower/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ }/) )/) ./.)
*0*return ! FUNCdefinepropertyorthrow(VARf, "arguments", propertydescriptor { [[GET]]: VARthrower, [[SET]]: VARthrower, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }).    
*0*(S return/NN !/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARf/NNP) ,/, ``/`` arguments/NNS ''/'' ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk GET/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARthrower/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk SET/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARthrower/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ }/) )/) ./.)
ID= 9.2.9.1
Summary= %ThrowTypeError% ( )
*0*throw a typeerror exception.     
*0*(S throw/VB a/DT typeerror/NN exception/NN ./.)
ID= 9.2.10
Summary= MakeConstructor ( F [ , writablePrototype [ , prototype ] ] )
*0*assert: VARf is an ecmascript function object. 
*0*(S assert/NN :/: (Chunk VARf/NNP) is/VBZ an/DT ecmascript/JJ function/NN object/NN ./.)
*0*assert: FUNCisconstructor(VARf) is true. 
*0*(S assert/NN :/: (Chunk FUNCisconstructor/NNP) (/( (Chunk VARf/NNP) )/) is/VBZ true/JJ ./.)
*0*assert: VARf is an extensible object that does not have a prototype own property. 
*0*(S assert/NN :/: (Chunk VARf/NNP) is/VBZ an/DT extensible/JJ object/NN that/WDT does/VBZ not/RB have/VB a/DT prototype/NN own/JJ property/NN ./.)
*0*if VARwritableprototype is not present, set VARwritableprototype to true. 
*0*(S if/IN (Chunk VARwritableprototype/NNP) is/VBZ not/RB present/JJ ,/, (Chunk set/VBN VARwritableprototype/NNP) to/TO true/JJ ./.)
*0*if VARprototype is not present, then
*0*(S if/IN (Chunk VARprototype/NNP) is/VBZ not/RB present/JJ ,/, then/RB)
*1*set VARprototype to FUNCobjectcreate(%objectprototype%). 
*1*(S (Chunk set/VBN VARprototype/NNP) to/TO (Chunk FUNCobjectcreate/NNP) (/( %/NN objectprototype/IN %/NN )/) ./.)
*1*perform ! FUNCdefinepropertyorthrow(VARprototype, "constructor", propertydescriptor { [[VALUE]]: VARf, [[WRITABLE]]: VARwritableprototype, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }). 
*1*(S perform/NN !/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARprototype/NNP) ,/, ``/`` constructor/NN ''/'' ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARf/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: VARwritableprototype/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ }/) )/) ./.)
*0*perform ! FUNCdefinepropertyorthrow(VARf, "prototype", propertydescriptor { [[VALUE]]: VARprototype, [[WRITABLE]]: VARwritableprototype, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }). 
*0*(S perform/NN !/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARf/NNP) ,/, ``/`` prototype/NN ''/'' ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: VARprototype/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: VARwritableprototype/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) )/) ./.)
*0*return FUNCnormalcompletion(undefined).    
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( undefined/JJ )/) ./.)
ID= 9.2.11
Summary= MakeClassConstructor ( F )
*0*assert: VARf is an ecmascript function object. 
*0*(S assert/NN :/: (Chunk VARf/NNP) is/VBZ an/DT ecmascript/JJ function/NN object/NN ./.)
*0*assert: VARf.[[FUNCTIONKIND]] is "normal". 
*0*(S assert/NN :/: (Chunk VARf/NNP) ./. [/VB [/JJ (Chunk FUNCTIONKIND/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` normal/JJ ''/'' ./.)
*0*set VARf.[[FUNCTIONKIND]] to "classconstructor". 
*0*(S (Chunk set/VBN VARf/NNP) ./. [/VB [/JJ (Chunk FUNCTIONKIND/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` classconstructor/NN ''/'' ./.)
*0*return FUNCnormalcompletion(undefined).    
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( undefined/JJ )/) ./.)
ID= 9.2.12
Summary= MakeMethod ( F, homeObject )
*0*assert: VARf is an ecmascript function object. 
*0*(S assert/NN :/: (Chunk VARf/NNP) is/VBZ an/DT ecmascript/JJ function/NN object/NN ./.)
*0*assert: FUNCtype(VARhomeobject) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARhomeobject/NNP) )/) is/VBZ object/JJ ./.)
*0*set VARf.[[HOMEOBJECT]] to VARhomeobject. 
*0*(S (Chunk set/VBN VARf/NNP) ./. [/VB [/JJ (Chunk HOMEOBJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARhomeobject/NNP) ./.)
*0*return FUNCnormalcompletion(undefined).    
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( undefined/JJ )/) ./.)
ID= 9.2.13
Summary= SetFunctionName ( F, name [ , prefix ] )
*0*assert: VARf is an extensible object that does not have a name own property. 
*0*(S assert/NN :/: (Chunk VARf/NNP) is/VBZ an/DT extensible/JJ object/NN that/WDT does/VBZ not/RB have/VB a/DT name/NN own/JJ property/NN ./.)
*0*assert: FUNCtype(VARname) is either symbol or string. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARname/NNP) )/) is/VBZ either/JJ symbol/NN or/CC string/NN ./.)
*0*assert: if VARprefix is present, then FUNCtype(VARprefix) is string. 
*0*(S assert/NN :/: if/IN (Chunk VARprefix/NNP) is/VBZ present/JJ ,/, (Chunk then/RB FUNCtype/NNP) (/( (Chunk VARprefix/NNP) )/) is/VBZ string/VBG ./.)
*0*if FUNCtype(VARname) is symbol, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARname/NNP) )/) is/VBZ symbol/NN ,/, then/RB)
*1*let VARdescription be VARname's [[DESCRIPTION]] value. 
*1*(S (Chunk let/VB VARdescription/NNP) (Chunk be/VB VARname/NNP) 's/POS (Chunk [/NNP) (Chunk [/NNP) (Chunk DESCRIPTION/NNP) (Chunk ]/NNP) (Chunk ]/NNP) value/NN ./.)
*1*if VARdescription is undefined, set VARname to the empty string. 
*1*(S if/IN (Chunk VARdescription/NNP) is/VBZ undefined/JJ ,/, (Chunk set/VBN VARname/NNP) to/TO the/DT empty/JJ string/NN ./.)
*1*else, set VARname to the string-concatenation of "[", VARdescription, and "]". 
*1*(S else/RB ,/, (Chunk set/VBN VARname/NNP) to/TO the/DT string-concatenation/NN of/IN ``/`` [/JJ ``/`` ,/, (Chunk VARdescription/NNP) ,/, and/CC ``/`` ]/JJ ''/'' ./.)
*0*if VARprefix is present, then
*0*(S if/IN (Chunk VARprefix/NNP) is/VBZ present/JJ ,/, then/RB)
*1*set VARname to the string-concatenation of VARprefix, the code unit 0x0020 (space), and VARname. 
*1*(S (Chunk set/VBN VARname/NNP) to/TO the/DT string-concatenation/NN of/IN (Chunk VARprefix/NNP) ,/, the/DT code/NN unit/NN 0x0020/CD (/( space/NN )/) ,/, and/CC (Chunk VARname/NNP) ./.)
*0*return ! FUNCdefinepropertyorthrow(VARf, "name", propertydescriptor { [[VALUE]]: VARname, [[WRITABLE]]: false, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }).    
*0*(S return/NN !/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARf/NNP) ,/, ``/`` name/NN ''/'' ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: VARname/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ }/) )/) ./.)
ID= 9.2.14
Summary= SetFunctionLength ( F, length )
*0*assert: VARf is an extensible object that does not have a length own property. 
*0*(S assert/NN :/: (Chunk VARf/NNP) is/VBZ an/DT extensible/JJ object/NN that/WDT does/VBZ not/RB have/VB a/DT length/NN own/JJ property/NN ./.)
*0*assert: FUNCtype(VARlength) is number. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARlength/NNP) )/) is/VBZ number/NN ./.)
*0*assert: VARlength ≥ 0 and ! FUNCtointeger(VARlength) is equal to VARlength. 
*0*(S assert/NN :/: (Chunk VARlength/NNP) ≥/VBZ 0/CD and/CC !/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARlength/NNP) )/) is/VBZ equal/JJ to/TO (Chunk VARlength/NNP) ./.)
*0*return ! FUNCdefinepropertyorthrow(VARf, "length", propertydescriptor { [[VALUE]]: VARlength, [[WRITABLE]]: false, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }).    
*0*(S return/NN !/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARf/NNP) ,/, ``/`` length/NN ''/'' ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARlength/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ }/) )/) ./.)
ID= 9.2.15
Summary= FunctionDeclarationInstantiation ( func, argumentsList )
*0*let VARcalleecontext be the running execution context. 
*0*(S (Chunk let/VB VARcalleecontext/NNP) be/VB the/DT running/JJ execution/NN context/NN ./.)
*0*let VARenv be the lexicalenvironment of VARcalleecontext. 
*0*(S (Chunk let/VB VARenv/NNP) be/VB the/DT lexicalenvironment/NN of/IN (Chunk VARcalleecontext/NNP) ./.)
*0*let VARenvrec be VARenv's environmentrecord. 
*0*(S (Chunk let/VB VARenvrec/NNP) (Chunk be/VB VARenv/NNP) 's/POS environmentrecord/NN ./.)
*0*let VARcode be VARfunc.[[ECMASCRIPTCODE]]. 
*0*(S (Chunk let/VB VARcode/NNP) (Chunk be/VB VARfunc/NNP) ./. [/VB [/JJ (Chunk ECMASCRIPTCODE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARstrict be VARfunc.[[STRICT]]. 
*0*(S (Chunk let/VB VARstrict/NNP) (Chunk be/VB VARfunc/NNP) ./. [/VB [/JJ (Chunk STRICT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARformals be VARfunc.[[FORMALPARAMETERS]]. 
*0*(S let/NN VARformals/NNS (Chunk be/VB VARfunc/NNP) ./. [/VB [/JJ (Chunk FORMALPARAMETERS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARparameternames be the boundnames of VARformals. 
*0*(S (Chunk let/VB VARparameternames/NNP) be/VB the/DT boundnames/NNS of/IN VARformals/NNS ./.)
*0*if VARparameternames has any duplicate entries, let VARhasduplicates be true. otherwise, let VARhasduplicates be false. 
*0*(S if/IN (Chunk VARparameternames/NNP) has/VBZ any/DT duplicate/JJ entries/NNS ,/, (Chunk let/VB VARhasduplicates/NNP) be/VB true/JJ ./. otherwise/RB ,/, (Chunk let/VB VARhasduplicates/NNP) be/VB false/JJ ./.)
*0*let VARsimpleparameterlist be issimpleparameterlist of VARformals. 
*0*(S (Chunk let/VB VARsimpleparameterlist/NNP) be/VB issimpleparameterlist/NN of/IN VARformals/NNS ./.)
*0*let VARhasparameterexpressions be containsexpression of VARformals. 
*0*(S (Chunk let/VB VARhasparameterexpressions/NNP) be/VB containsexpression/NN of/IN VARformals/NNS ./.)
*0*let VARvarnames be the vardeclarednames of VARcode. 
*0*(S (Chunk let/VB VARvarnames/NNP) be/VB the/DT vardeclarednames/NNS of/IN (Chunk VARcode/NNP) ./.)
*0*let VARvardeclarations be the varscopeddeclarations of VARcode. 
*0*(S (Chunk let/VB VARvardeclarations/NNP) be/VB the/DT varscopeddeclarations/NNS of/IN (Chunk VARcode/NNP) ./.)
*0*let VARlexicalnames be the lexicallydeclarednames of VARcode. 
*0*(S (Chunk let/VB VARlexicalnames/NNP) be/VB the/DT lexicallydeclarednames/NNS of/IN (Chunk VARcode/NNP) ./.)
*0*let VARfunctionnames be a new empty list. 
*0*(S (Chunk let/VB VARfunctionnames/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARfunctionstoinitialize be a new empty list. 
*0*(S (Chunk let/VB VARfunctionstoinitialize/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*for each VARd in VARvardeclarations, in reverse list order, do
*0*(S for/IN each/DT (Chunk VARd/NNP) in/IN (Chunk VARvardeclarations/NNP) ,/, in/IN reverse/JJ list/NN order/NN ,/, do/VBP)
*1*if VARd is neither a variabledeclaration nor a forbinding nor a bindingidentifier, then
*1*(S if/IN (Chunk VARd/NNP) is/VBZ neither/CC a/DT variabledeclaration/NN nor/CC a/DT forbinding/NN nor/CC a/DT bindingidentifier/NN ,/, then/RB)
*2*assert: VARd is either a functiondeclaration, a generatordeclaration, an asyncfunctiondeclaration, or an asyncgeneratordeclaration. 
*2*(S assert/NN :/: (Chunk VARd/NNP) is/VBZ either/CC a/DT functiondeclaration/NN ,/, a/DT generatordeclaration/NN ,/, an/DT asyncfunctiondeclaration/NN ,/, or/CC an/DT asyncgeneratordeclaration/NN ./.)
*2*let VARfn be the sole element of the boundnames of VARd. 
*2*(S (Chunk let/VB VARfn/NNP) be/VB the/DT sole/JJ element/NN of/IN the/DT boundnames/NNS of/IN (Chunk VARd/NNP) ./.)
*2*if VARfn is not an element of VARfunctionnames, then
*2*(S if/IN (Chunk VARfn/NNP) is/VBZ not/RB an/DT element/NN of/IN (Chunk VARfunctionnames/NNP) ,/, then/RB)
*3*insert VARfn as the first element of VARfunctionnames. 
*3*(S insert/JJ (Chunk VARfn/NNP) as/IN the/DT first/JJ element/NN of/IN (Chunk VARfunctionnames/NNP) ./.)
*3*note: if there are multiple function declarations for the same name, the last declaration is used. 
*3*(S note/NN :/: if/IN there/EX are/VBP multiple/JJ function/NN declarations/NNS for/IN the/DT same/JJ name/NN ,/, the/DT last/JJ declaration/NN is/VBZ used/VBN ./.)
*3*insert VARd as the first element of VARfunctionstoinitialize. 
*3*(S insert/JJ (Chunk VARd/NNP) as/IN the/DT first/JJ element/NN of/IN (Chunk VARfunctionstoinitialize/NNP) ./.)
*0*let VARargumentsobjectneeded be true. 
*0*(S (Chunk let/VB VARargumentsobjectneeded/NNP) be/VB true/JJ ./.)
*0*if VARfunc.[[THISMODE]] is lexical, then
*0*(S if/IN (Chunk VARfunc/NNP) ./. [/VB [/JJ (Chunk THISMODE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ lexical/JJ ,/, then/RB)
*1*note: arrow functions never have an arguments objects. 
*1*(S note/NN :/: arrow/NN functions/NNS never/RB have/VBP an/DT arguments/NNS objects/NNS ./.)
*1*set VARargumentsobjectneeded to false. 
*1*(S set/NN VARargumentsobjectneeded/VBD to/TO false/VB ./.)
*0*else if "arguments" is an element of VARparameternames, then
*0*(S else/RB if/IN ``/`` arguments/NNS ''/'' is/VBZ an/DT element/NN of/IN (Chunk VARparameternames/NNP) ,/, then/RB)
*1*set VARargumentsobjectneeded to false. 
*1*(S set/NN VARargumentsobjectneeded/VBD to/TO false/VB ./.)
*0*else if VARhasparameterexpressions is false, then
*0*(S else/RB if/IN (Chunk VARhasparameterexpressions/NNP) is/VBZ false/JJ ,/, then/RB)
*1*if "arguments" is an element of VARfunctionnames or if "arguments" is an element of VARlexicalnames, then
*1*(S if/IN ``/`` arguments/NNS ''/'' is/VBZ an/DT element/NN of/IN (Chunk VARfunctionnames/NNP) or/CC if/IN ``/`` arguments/NNS ''/'' is/VBZ an/DT element/NN of/IN (Chunk VARlexicalnames/NNP) ,/, then/RB)
*2*set VARargumentsobjectneeded to false. 
*2*(S set/NN VARargumentsobjectneeded/VBD to/TO false/VB ./.)
*0*for each string VARparamname in VARparameternames, do
*0*(S for/IN each/DT string/NN (Chunk VARparamname/NNP) in/IN (Chunk VARparameternames/NNP) ,/, do/VBP)
*1*let VARalreadydeclared be VARenvrec.hasbinding(VARparamname). 
*1*(S (Chunk let/VB VARalreadydeclared/NNP) (Chunk be/VB VARenvrec.hasbinding/NNP) (/( (Chunk VARparamname/NNP) )/) ./.)
*1*note: early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters. 
*1*(S note/NN :/: early/JJ errors/NNS ensure/VB that/IN duplicate/NN parameter/NN names/NNS can/MD only/RB occur/VB in/IN non-strict/JJ functions/NNS that/WDT do/VBP not/RB have/VB parameter/NN default/NN values/NNS or/CC rest/NN parameters/NNS ./.)
*1*if VARalreadydeclared is false, then
*1*(S if/IN VARalreadydeclared/VBN is/VBZ false/JJ ,/, then/RB)
*2*perform ! VARenvrec.createmutablebinding(VARparamname, false). 
*2*(S perform/NN !/. (Chunk VARenvrec.createmutablebinding/NNP) (/( (Chunk VARparamname/NNP) ,/, false/RB )/) ./.)
*2*if VARhasduplicates is true, then
*2*(S if/IN (Chunk VARhasduplicates/NNP) is/VBZ true/JJ ,/, then/RB)
*3*perform ! VARenvrec.initializebinding(VARparamname, undefined). 
*3*(S perform/NN !/. (Chunk VARenvrec.initializebinding/NNP) (/( (Chunk VARparamname/NNP) ,/, undefined/VBD )/) ./.)
*0*if VARargumentsobjectneeded is true, then
*0*(S if/IN VARargumentsobjectneeded/VBN is/VBZ true/JJ ,/, then/RB)
*1*if VARstrict is true or if VARsimpleparameterlist is false, then
*1*(S if/IN (Chunk VARstrict/NNP) is/VBZ true/JJ or/CC if/IN (Chunk VARsimpleparameterlist/NNP) is/VBZ false/JJ ,/, then/RB)
*2*let VARao be FUNCcreateunmappedargumentsobject(VARargumentslist). 
*2*(S (Chunk let/VB VARao/NNP) (Chunk be/VB FUNCcreateunmappedargumentsobject/NNP) (/( (Chunk VARargumentslist/NNP) )/) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*note: mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters. 
*2*(S note/NN :/: mapped/VBN argument/NN object/NN is/VBZ only/RB provided/VBN for/IN non-strict/JJ functions/NNS that/WDT do/VBP n't/RB have/VB a/DT rest/NN parameter/NN ,/, any/DT parameter/NN default/NN value/NN initializers/NNS ,/, or/CC any/DT destructured/JJ parameters/NNS ./.)
*2*let VARao be FUNCcreatemappedargumentsobject(VARfunc, VARformals, VARargumentslist, VARenvrec). 
*2*(S (Chunk let/VB VARao/NNP) (Chunk be/VB FUNCcreatemappedargumentsobject/NNP) (/( (Chunk VARfunc/NNP) ,/, (Chunk VARformals/NNP) ,/, (Chunk VARargumentslist/NNP) ,/, (Chunk VARenvrec/NNP) )/) ./.)
*1*if VARstrict is true, then
*1*(S if/IN (Chunk VARstrict/NNP) is/VBZ true/JJ ,/, then/RB)
*2*perform ! VARenvrec.createimmutablebinding("arguments", false). 
*2*(S perform/NN !/. (Chunk VARenvrec.createimmutablebinding/NNP) (/( ``/`` arguments/NNS ''/'' ,/, false/JJ )/) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*perform ! VARenvrec.createmutablebinding("arguments", false). 
*2*(S perform/NN !/. (Chunk VARenvrec.createmutablebinding/NNP) (/( ``/`` arguments/NNS ''/'' ,/, false/JJ )/) ./.)
*1*call VARenvrec.initializebinding("arguments", VARao). 
*1*(S call/NN (Chunk VARenvrec.initializebinding/NNP) (/( ``/`` arguments/NNS ''/'' ,/, (Chunk VARao/NNP) )/) ./.)
*1*let VARparameterbindings be a new list of VARparameternames with "arguments" appended. 
*1*(S (Chunk let/VB VARparameterbindings/NNP) be/VB a/DT new/JJ list/NN of/IN (Chunk VARparameternames/NNP) with/IN ``/`` arguments/NNS ''/'' appended/VBN ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARparameterbindings be VARparameternames. 
*1*(S (Chunk let/VB VARparameterbindings/NNP) (Chunk be/VB VARparameternames/NNP) ./.)
*0*let VARiteratorrecord be FUNCcreatelistiteratorrecord(VARargumentslist). 
*0*(S (Chunk let/VB VARiteratorrecord/NNP) (Chunk be/VB FUNCcreatelistiteratorrecord/NNP) (/( (Chunk VARargumentslist/NNP) )/) ./.)
*0*if VARhasduplicates is true, then
*0*(S if/IN (Chunk VARhasduplicates/NNP) is/VBZ true/JJ ,/, then/RB)
*1*perform ? iteratorbindinginitialization for VARformals with VARiteratorrecord and undefined as arguments. 
*1*(S perform/NN ?/. iteratorbindinginitialization/NN for/IN VARformals/NNS with/IN (Chunk VARiteratorrecord/NNP) and/CC undefined/VBD as/IN arguments/NNS ./.)
*0*else,
*0*(S else/RB ,/,)
*1*perform ? iteratorbindinginitialization for VARformals with VARiteratorrecord and VARenv as arguments. 
*1*(S perform/NN ?/. iteratorbindinginitialization/NN for/IN VARformals/NNS with/IN (Chunk VARiteratorrecord/NNP) and/CC (Chunk VARenv/NNP) as/IN arguments/NNS ./.)
*0*if VARhasparameterexpressions is false, then
*0*(S if/IN (Chunk VARhasparameterexpressions/NNP) is/VBZ false/JJ ,/, then/RB)
*1*note: only a single lexical environment is needed for the parameters and top-level vars. 
*1*(S note/NN :/: only/RB a/DT single/JJ lexical/JJ environment/NN is/VBZ needed/VBN for/IN the/DT parameters/NNS and/CC top-level/JJ vars/NNS ./.)
*1*let VARinstantiatedvarnames be a copy of the list VARparameterbindings. 
*1*(S (Chunk let/VB VARinstantiatedvarnames/NNP) be/VB a/DT copy/NN of/IN the/DT list/NN (Chunk VARparameterbindings/NNP) ./.)
*1*for each VARn in VARvarnames, do
*1*(S for/IN each/DT (Chunk VARn/NNP) in/IN (Chunk VARvarnames/NNP) ,/, do/VBP)
*2*if VARn is not an element of VARinstantiatedvarnames, then
*2*(S if/IN (Chunk VARn/NNP) is/VBZ not/RB an/DT element/NN of/IN (Chunk VARinstantiatedvarnames/NNP) ,/, then/RB)
*3*append VARn to VARinstantiatedvarnames. 
*3*(S append/NN (Chunk VARn/NNP) to/TO (Chunk VARinstantiatedvarnames/NNP) ./.)
*3*perform ! VARenvrec.createmutablebinding(VARn, false). 
*3*(S perform/NN !/. (Chunk VARenvrec.createmutablebinding/NNP) (/( (Chunk VARn/NNP) ,/, false/RB )/) ./.)
*3*call VARenvrec.initializebinding(VARn, undefined). 
*3*(S call/NN (Chunk VARenvrec.initializebinding/NNP) (/( (Chunk VARn/NNP) ,/, undefined/VBD )/) ./.)
*1*let VARvarenv be VARenv. 
*1*(S (Chunk let/VB VARvarenv/NNP) (Chunk be/VB VARenv/NNP) ./.)
*1*let VARvarenvrec be VARenvrec. 
*1*(S (Chunk let/VB VARvarenvrec/NNP) (Chunk be/VB VARenvrec/NNP) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*note: a separate environment record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body. 
*1*(S note/NN :/: a/DT separate/JJ environment/NN record/NN is/VBZ needed/VBN to/TO ensure/VB that/DT closures/NNS created/VBN by/IN expressions/NNS in/IN the/DT formal/JJ parameter/NN list/NN do/VBP not/RB have/VB visibility/NN of/IN declarations/NNS in/IN the/DT function/NN body/NN ./.)
*1*let VARvarenv be FUNCnewdeclarativeenvironment(VARenv). 
*1*(S (Chunk let/VB VARvarenv/NNP) (Chunk be/VB FUNCnewdeclarativeenvironment/NNP) (/( (Chunk VARenv/NNP) )/) ./.)
*1*let VARvarenvrec be VARvarenv's environmentrecord. 
*1*(S (Chunk let/VB VARvarenvrec/NNP) (Chunk be/VB VARvarenv/NNP) 's/POS environmentrecord/NN ./.)
*1*set the variableenvironment of VARcalleecontext to VARvarenv. 
*1*(S set/VB the/DT variableenvironment/NN of/IN (Chunk VARcalleecontext/NNP) to/TO (Chunk VARvarenv/NNP) ./.)
*1*let VARinstantiatedvarnames be a new empty list. 
*1*(S (Chunk let/VB VARinstantiatedvarnames/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*1*for each VARn in VARvarnames, do
*1*(S for/IN each/DT (Chunk VARn/NNP) in/IN (Chunk VARvarnames/NNP) ,/, do/VBP)
*2*if VARn is not an element of VARinstantiatedvarnames, then
*2*(S if/IN (Chunk VARn/NNP) is/VBZ not/RB an/DT element/NN of/IN (Chunk VARinstantiatedvarnames/NNP) ,/, then/RB)
*3*append VARn to VARinstantiatedvarnames. 
*3*(S append/NN (Chunk VARn/NNP) to/TO (Chunk VARinstantiatedvarnames/NNP) ./.)
*3*perform ! VARvarenvrec.createmutablebinding(VARn, false). 
*3*(S perform/NN !/. (Chunk VARvarenvrec.createmutablebinding/NNP) (/( (Chunk VARn/NNP) ,/, false/RB )/) ./.)
*3*if VARn is not an element of VARparameterbindings or if VARn is an element of VARfunctionnames, let VARinitialvalue be undefined. 
*3*(S if/IN (Chunk VARn/NNP) is/VBZ not/RB an/DT element/NN of/IN VARparameterbindings/NNS or/CC if/IN (Chunk VARn/NNP) is/VBZ an/DT element/NN of/IN (Chunk VARfunctionnames/NNP) ,/, (Chunk let/VB VARinitialvalue/NNP) be/VB undefined/VBN ./.)
*3*else,
*3*(S else/RB ,/,)
*4*let VARinitialvalue be ! VARenvrec.getbindingvalue(VARn, false). 
*4*(S (Chunk let/VB VARinitialvalue/NNP) be/VB !/. (Chunk VARenvrec.getbindingvalue/NNP) (/( (Chunk VARn/NNP) ,/, false/RB )/) ./.)
*3*call VARvarenvrec.initializebinding(VARn, VARinitialvalue). 
*3*(S call/NN (Chunk VARvarenvrec.initializebinding/NNP) (/( (Chunk VARn/NNP) ,/, (Chunk VARinitialvalue/NNP) )/) ./.)
*3*note: vars whose names are the same as a formal parameter, initially have the same value as the corresponding initialized parameter. 
*3*(S note/NN :/: vars/NNS whose/WP$ names/NNS are/VBP the/DT same/JJ as/IN a/DT formal/JJ parameter/NN ,/, initially/RB have/VBP the/DT same/JJ value/NN as/IN the/DT corresponding/VBG initialized/JJ parameter/NN ./.)
*0*note: annex b.3.3.1 adds additional steps at this point. 
*0*(S note/NN :/: annex/NN b.3.3.1/NN adds/VBZ additional/JJ steps/NNS at/IN this/DT point/NN ./.)
*0*if VARstrict is false, then
*0*(S if/IN (Chunk VARstrict/NNP) is/VBZ false/JJ ,/, then/RB)
*1*let VARlexenv be FUNCnewdeclarativeenvironment(VARvarenv). 
*1*(S (Chunk let/VB VARlexenv/NNP) (Chunk be/VB FUNCnewdeclarativeenvironment/NNP) (/( (Chunk VARvarenv/NNP) )/) ./.)
*1*note: non-strict functions use a separate lexical environment record for top-level lexical declarations so that a direct eval can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. this is not needed for strict functions because a strict direct eval always places all declarations into a new environment record. 
*1*(S note/NN :/: non-strict/JJ functions/NNS use/VBP a/DT separate/JJ lexical/JJ environment/NN record/NN for/IN top-level/JJ lexical/JJ declarations/NNS so/IN that/IN a/DT direct/JJ eval/NN can/MD determine/VB whether/IN any/DT var/NN scoped/VBD declarations/NNS introduced/VBN by/IN the/DT eval/JJ code/NN conflict/NN with/IN pre-existing/JJ top-level/JJ lexically/RB scoped/JJ declarations/NNS ./. this/DT is/VBZ not/RB needed/VBN for/IN strict/JJ functions/NNS because/IN a/DT strict/JJ direct/JJ eval/NN always/RB places/VBZ all/DT declarations/NNS into/IN a/DT new/JJ environment/NN record/NN ./.)
*0*else, let VARlexenv be VARvarenv. 
*0*(S else/RB ,/, (Chunk let/VB VARlexenv/NNP) (Chunk be/VB VARvarenv/NNP) ./.)
*0*let VARlexenvrec be VARlexenv's environmentrecord. 
*0*(S (Chunk let/VB VARlexenvrec/NNP) (Chunk be/VB VARlexenv/NNP) 's/POS environmentrecord/NN ./.)
*0*set the lexicalenvironment of VARcalleecontext to VARlexenv. 
*0*(S set/VB the/DT lexicalenvironment/NN of/IN (Chunk VARcalleecontext/NNP) to/TO (Chunk VARlexenv/NNP) ./.)
*0*let VARlexdeclarations be the lexicallyscopeddeclarations of VARcode. 
*0*(S (Chunk let/VB VARlexdeclarations/NNP) be/VB the/DT lexicallyscopeddeclarations/NNS of/IN (Chunk VARcode/NNP) ./.)
*0*for each element VARd in VARlexdeclarations, do
*0*(S for/IN each/DT element/NN (Chunk VARd/NNP) in/IN (Chunk VARlexdeclarations/NNP) ,/, do/VBP)
*1*note: a lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. lexically declared names are only instantiated here but not initialized. 
*1*(S note/NN :/: a/DT lexically/RB declared/VBN name/NN can/MD not/RB be/VB the/DT same/JJ as/IN a/DT function/generator/NN declaration/NN ,/, formal/JJ parameter/NN ,/, or/CC a/DT var/JJ name/NN ./. lexically/RB declared/VBN names/NNS are/VBP only/RB instantiated/VBN here/RB but/CC not/RB initialized/VBN ./.)
*1*for each element VARdn of the boundnames of VARd, do
*1*(S for/IN each/DT element/NN (Chunk VARdn/NNP) of/IN the/DT boundnames/NNS of/IN (Chunk VARd/NNP) ,/, do/VBP)
*2*if isconstantdeclaration of VARd is true, then
*2*(S if/IN isconstantdeclaration/NN of/IN (Chunk VARd/NNP) is/VBZ true/JJ ,/, then/RB)
*3*perform ! VARlexenvrec.createimmutablebinding(VARdn, true). 
*3*(S perform/NN !/. (Chunk VARlexenvrec.createimmutablebinding/NNP) (/( (Chunk VARdn/NNP) ,/, true/JJ )/) ./.)
*2*else,
*2*(S else/RB ,/,)
*3*perform ! VARlexenvrec.createmutablebinding(VARdn, false). 
*3*(S perform/NN !/. (Chunk VARlexenvrec.createmutablebinding/NNP) (/( (Chunk VARdn/NNP) ,/, false/RB )/) ./.)
*0*for each parse node VARf in VARfunctionstoinitialize, do
*0*(S for/IN each/DT parse/NN node/NN (Chunk VARf/NNP) in/IN (Chunk VARfunctionstoinitialize/NNP) ,/, do/VBP)
*1*let VARfn be the sole element of the boundnames of VARf. 
*1*(S (Chunk let/VB VARfn/NNP) be/VB the/DT sole/JJ element/NN of/IN the/DT boundnames/NNS of/IN (Chunk VARf/NNP) ./.)
*1*let VARfo be the result of performing instantiatefunctionobject for VARf with argument VARlexenv. 
*1*(S (Chunk let/VB VARfo/NNP) be/VB the/DT result/NN of/IN performing/VBG instantiatefunctionobject/NN for/IN (Chunk VARf/NNP) with/IN argument/NN (Chunk VARlexenv/NNP) ./.)
*1*perform ! VARvarenvrec.setmutablebinding(VARfn, VARfo, false). 
*1*(S perform/NN !/. (Chunk VARvarenvrec.setmutablebinding/NNP) (/( (Chunk VARfn/NNP) ,/, (Chunk VARfo/NNP) ,/, false/RB )/) ./.)
*0*return FUNCnormalcompletion(empty).    
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( empty/JJ )/) ./.)
ID= 9.3.1
Summary= [[Call]] ( thisArgument, argumentsList )
*0*let VARcallercontext be the running execution context. 
*0*(S (Chunk let/VB VARcallercontext/NNP) be/VB the/DT running/JJ execution/NN context/NN ./.)
*0*if VARcallercontext is not already suspended, suspend VARcallercontext. 
*0*(S if/IN (Chunk VARcallercontext/NNP) is/VBZ not/RB already/RB suspended/VBN ,/, (Chunk suspend/VBP VARcallercontext/NNP) ./.)
*0*let VARcalleecontext be a new ecmascript code execution context. 
*0*(S (Chunk let/VB VARcalleecontext/NNP) be/VB a/DT new/JJ ecmascript/NN code/NN execution/NN context/NN ./.)
*0*set the function of VARcalleecontext to VARf. 
*0*(S set/VB the/DT function/NN of/IN (Chunk VARcalleecontext/NNP) to/TO (Chunk VARf/NNP) ./.)
*0*let VARcalleerealm be VARf.[[REALM]]. 
*0*(S (Chunk let/VB VARcalleerealm/NNP) (Chunk be/VB VARf/NNP) ./. [/VB [/JJ (Chunk REALM/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*set the realm of VARcalleecontext to VARcalleerealm. 
*0*(S set/VB the/DT realm/NN of/IN (Chunk VARcalleecontext/NNP) to/TO (Chunk VARcalleerealm/NNP) ./.)
*0*set the scriptormodule of VARcalleecontext to VARf.[[SCRIPTORMODULE]]. 
*0*(S set/VB the/DT scriptormodule/NN of/IN (Chunk VARcalleecontext/NNP) to/TO (Chunk VARf/NNP) ./. [/VB [/JJ (Chunk SCRIPTORMODULE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*perform any necessary implementation-defined initialization of VARcalleecontext. 
*0*(S perform/VB any/DT necessary/JJ implementation-defined/JJ initialization/NN of/IN (Chunk VARcalleecontext/NNP) ./.)
*0*push VARcalleecontext onto the execution context stack; VARcalleecontext is now the running execution context. 
*0*(S push/NN (Chunk VARcalleecontext/NNP) onto/IN the/DT execution/NN context/NN stack/NN ;/: (Chunk VARcalleecontext/NNP) is/VBZ now/RB the/DT running/VBG execution/NN context/NN ./.)
*0*let VARresult be the completion record that is the result of evaluating VARf in an implementation-defined manner that conforms to the specification of VARf. VARthisargument is the this value, VARargumentslist provides the named parameters, and the newtarget value is undefined. 
*0*(S (Chunk let/VB VARresult/NNP) be/VB the/DT completion/NN record/NN that/WDT is/VBZ the/DT result/NN of/IN (Chunk evaluating/VBG VARf/NNP) in/IN an/DT implementation-defined/JJ manner/NN that/WDT conforms/VBZ to/TO the/DT specification/NN of/IN (Chunk VARf/NNP) ./. (Chunk VARthisargument/NNP) is/VBZ the/DT this/DT value/NN ,/, (Chunk VARargumentslist/NNP) provides/VBZ the/DT named/JJ parameters/NNS ,/, and/CC the/DT newtarget/NN value/NN is/VBZ undefined/JJ ./.)
*0*remove VARcalleecontext from the execution context stack and restore VARcallercontext as the running execution context. 
*0*(S (Chunk remove/VB VARcalleecontext/NNP) from/IN the/DT execution/NN context/NN stack/NN and/CC (Chunk restore/VB VARcallercontext/NNP) as/IN the/DT running/VBG execution/NN context/NN ./.)
*0*return VARresult.    
*0*(S return/NN (Chunk VARresult/NNP) ./.)
ID= 9.3.2
Summary= [[Construct]] ( argumentsList, newTarget )
*0*let VARresult be the completion record that is the result of evaluating VARf in an implementation-defined manner that conforms to the specification of VARf. the this value is uninitialized, VARargumentslist provides the named parameters, and VARnewtarget provides the newtarget value.    
*0*(S (Chunk let/VB VARresult/NNP) be/VB the/DT completion/NN record/NN that/WDT is/VBZ the/DT result/NN of/IN (Chunk evaluating/VBG VARf/NNP) in/IN an/DT implementation-defined/JJ manner/NN that/WDT conforms/VBZ to/TO the/DT specification/NN of/IN (Chunk VARf/NNP) ./. the/DT this/DT value/NN is/VBZ uninitialized/JJ ,/, (Chunk VARargumentslist/NNP) provides/VBZ the/DT named/JJ parameters/NNS ,/, and/CC (Chunk VARnewtarget/NNP) provides/VBZ the/DT newtarget/NN value/NN ./.)
ID= 9.3.3
Summary= CreateBuiltinFunction ( steps, internalSlotsList [ , realm [ , prototype ] ] )
*0*assert: VARsteps is either a set of algorithm steps or other definition of a function's behaviour provided in this specification. 
*0*(S assert/NN :/: (Chunk VARsteps/NNP) is/VBZ either/CC a/DT set/NN of/IN algorithm/JJ steps/NNS or/CC other/JJ definition/NN of/IN a/DT function/NN 's/POS behaviour/NN provided/VBD in/IN this/DT specification/NN ./.)
*0*if VARrealm is not present, set VARrealm to the current realm record. 
*0*(S if/IN (Chunk VARrealm/NNP) is/VBZ not/RB present/JJ ,/, (Chunk set/VBN VARrealm/NNP) to/TO the/DT current/JJ realm/NN record/NN ./.)
*0*assert: VARrealm is a realm record. 
*0*(S assert/NN :/: (Chunk VARrealm/NNP) is/VBZ a/DT realm/NN record/NN ./.)
*0*if VARprototype is not present, set VARprototype to VARrealm.[[INTRINSICS]].[[%FUNCTIONPROTOTYPE%]]. 
*0*(S if/IN (Chunk VARprototype/NNP) is/VBZ not/RB present/JJ ,/, (Chunk set/VBN VARprototype/NNP) to/TO (Chunk VARrealm./NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk INTRINSICS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./. [/VB [/CD %/NN (Chunk FUNCTIONPROTOTYPE/NNP) %/NN (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARfunc be a new built-in function object that when called performs the action described by VARsteps. the new function object has internal slots whose names are the elements of VARinternalslotslist. the initial value of each of those internal slots is undefined. 
*0*(S (Chunk let/VB VARfunc/NNP) be/VB a/DT new/JJ built-in/JJ function/NN object/NN that/IN when/WRB called/VBN performs/VBZ the/DT action/NN described/VBN by/IN (Chunk VARsteps/NNP) ./. the/DT new/JJ function/NN object/NN has/VBZ internal/JJ slots/NNS whose/WP$ names/NNS are/VBP the/DT elements/NNS of/IN (Chunk VARinternalslotslist/NNP) ./. the/DT initial/JJ value/NN of/IN each/DT of/IN those/DT internal/JJ slots/NNS is/VBZ undefined/JJ ./.)
*0*set VARfunc.[[REALM]] to VARrealm. 
*0*(S (Chunk set/VBN VARfunc/NNP) ./. [/VB [/JJ (Chunk REALM/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARrealm/NNP) ./.)
*0*set VARfunc.[[PROTOTYPE]] to VARprototype. 
*0*(S (Chunk set/VBN VARfunc/NNP) ./. [/VB [/JJ (Chunk PROTOTYPE/NNP) ]/NN ]/NN to/TO (Chunk VARprototype/NNP) ./.)
*0*set VARfunc.[[EXTENSIBLE]] to true. 
*0*(S (Chunk set/VBN VARfunc/NNP) ./. [/VB [/JJ (Chunk EXTENSIBLE/NNP) ]/NN ]/NN to/TO true/JJ ./.)
*0*set VARfunc.[[SCRIPTORMODULE]] to null. 
*0*(S (Chunk set/VBN VARfunc/NNP) ./. [/VB [/JJ (Chunk SCRIPTORMODULE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO null/VB ./.)
*0*return VARfunc.    
*0*(S return/NN (Chunk VARfunc/NNP) ./.)
ID= 9.4.1.1
Summary= [[Call]] ( thisArgument, argumentsList )
*0*let VARtarget be VARf.[[BOUNDTARGETFUNCTION]]. 
*0*(S (Chunk let/VB VARtarget/NNP) (Chunk be/VB VARf/NNP) ./. [/VB [/JJ (Chunk BOUNDTARGETFUNCTION/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARboundthis be VARf.[[BOUNDTHIS]]. 
*0*(S (Chunk let/VB VARboundthis/NNP) (Chunk be/VB VARf/NNP) ./. [/VB [/JJ (Chunk BOUNDTHIS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARboundargs be VARf.[[BOUNDARGUMENTS]]. 
*0*(S (Chunk let/VB VARboundargs/NNP) (Chunk be/VB VARf/NNP) ./. [/VB [/JJ (Chunk BOUNDARGUMENTS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARargs be a new list containing the same values as the list VARboundargs in the same order followed by the same values as the list VARargumentslist in the same order. 
*0*(S (Chunk let/VB VARargs/NNP) be/VB a/DT new/JJ list/NN containing/VBG the/DT same/JJ values/NNS as/IN the/DT list/NN (Chunk VARboundargs/NNP) in/IN the/DT same/JJ order/NN followed/VBN by/IN the/DT same/JJ values/NNS as/IN the/DT list/NN (Chunk VARargumentslist/NNP) in/IN the/DT same/JJ order/NN ./.)
*0*return ? FUNCcall(VARtarget, VARboundthis, VARargs).     
*0*(S return/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARtarget/NNP) ,/, (Chunk VARboundthis/NNP) ,/, (Chunk VARargs/NNP) )/) ./.)
ID= 9.4.1.2
Summary= [[Construct]] ( argumentsList, newTarget )
*0*let VARtarget be VARf.[[BOUNDTARGETFUNCTION]]. 
*0*(S (Chunk let/VB VARtarget/NNP) (Chunk be/VB VARf/NNP) ./. [/VB [/JJ (Chunk BOUNDTARGETFUNCTION/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*assert: FUNCisconstructor(VARtarget) is true. 
*0*(S assert/NN :/: (Chunk FUNCisconstructor/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARboundargs be VARf.[[BOUNDARGUMENTS]]. 
*0*(S (Chunk let/VB VARboundargs/NNP) (Chunk be/VB VARf/NNP) ./. [/VB [/JJ (Chunk BOUNDARGUMENTS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARargs be a new list containing the same values as the list VARboundargs in the same order followed by the same values as the list VARargumentslist in the same order. 
*0*(S (Chunk let/VB VARargs/NNP) be/VB a/DT new/JJ list/NN containing/VBG the/DT same/JJ values/NNS as/IN the/DT list/NN (Chunk VARboundargs/NNP) in/IN the/DT same/JJ order/NN followed/VBN by/IN the/DT same/JJ values/NNS as/IN the/DT list/NN (Chunk VARargumentslist/NNP) in/IN the/DT same/JJ order/NN ./.)
*0*if FUNCsamevalue(VARf, VARnewtarget) is true, set VARnewtarget to VARtarget. 
*0*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARf/NNP) ,/, (Chunk VARnewtarget/NNP) )/) is/VBZ true/JJ ,/, (Chunk set/VB VARnewtarget/NNP) to/TO (Chunk VARtarget/NNP) ./.)
*0*return ? FUNCconstruct(VARtarget, VARargs, VARnewtarget).     
*0*(S return/NN ?/. (Chunk FUNCconstruct/NNP) (/( (Chunk VARtarget/NNP) ,/, (Chunk VARargs/NNP) ,/, (Chunk VARnewtarget/NNP) )/) ./.)
ID= 9.4.1.3
Summary= BoundFunctionCreate ( targetFunction, boundThis, boundArgs )
*0*assert: FUNCtype(VARtargetfunction) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARtargetfunction/NNP) )/) is/VBZ object/JJ ./.)
*0*let VARproto be ? VARtargetfunction.[[GETPROTOTYPEOF]](). 
*0*(S (Chunk let/VB VARproto/NNP) be/VB ?/. (Chunk VARtargetfunction/NNP) ./. [/VB [/JJ (Chunk GETPROTOTYPEOF/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*0*let VARobj be a newly created object. 
*0*(S (Chunk let/VB VARobj/NNP) be/VB a/DT newly/RB created/VBN object/NN ./.)
*0*set VARobj's essential internal methods to the default ordinary object definitions specified in 9.1. 
*0*(S (Chunk set/VBN VARobj/NNP) 's/POS essential/JJ internal/JJ methods/NNS to/TO the/DT default/NN ordinary/JJ object/JJ definitions/NNS specified/VBN in/IN 9.1/CD ./.)
*0*set VARobj.[[CALL]] as described in 9.4.1.1. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk CALL/NNP) (Chunk ]/NNP) (Chunk ]/NNP) as/IN described/VBN in/IN 9.4.1.1/CD ./.)
*0*if FUNCisconstructor(VARtargetfunction) is true, then
*0*(S if/IN (Chunk FUNCisconstructor/NNP) (/( (Chunk VARtargetfunction/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*set VARobj.[[CONSTRUCT]] as described in 9.4.1.2. 
*1*(S (Chunk set/VBN VARobj/NNP) ./. (Chunk [/NNP) (Chunk [/NNP) (Chunk CONSTRUCT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) as/IN described/VBN in/IN 9.4.1.2/CD ./.)
*0*set VARobj.[[PROTOTYPE]] to VARproto. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk PROTOTYPE/NNP) ]/NN ]/NN to/TO (Chunk VARproto/NNP) ./.)
*0*set VARobj.[[EXTENSIBLE]] to true. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk EXTENSIBLE/NNP) ]/NN ]/NN to/TO true/JJ ./.)
*0*set VARobj.[[BOUNDTARGETFUNCTION]] to VARtargetfunction. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk BOUNDTARGETFUNCTION/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARtargetfunction/NNP) ./.)
*0*set VARobj.[[BOUNDTHIS]] to VARboundthis. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk BOUNDTHIS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARboundthis/NNP) ./.)
*0*set VARobj.[[BOUNDARGUMENTS]] to VARboundargs. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk BOUNDARGUMENTS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARboundargs/NNP) ./.)
*0*return VARobj.     
*0*(S return/NN (Chunk VARobj/NNP) ./.)
ID= 9.4.2.1
Summary= [[DefineOwnProperty]] ( P, Desc )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*if VARp is "length", then
*0*(S if/IN (Chunk VARp/NNP) is/VBZ ``/`` length/JJ ''/'' ,/, then/RB)
*1*return ? FUNCarraysetlength(VARa, VARdesc). 
*1*(S return/NN ?/. (Chunk FUNCarraysetlength/NNP) (/( (Chunk VARa/NNP) ,/, (Chunk VARdesc/NNP) )/) ./.)
*0*else if VARp is an array index, then
*0*(S else/RB if/IN (Chunk VARp/NNP) is/VBZ an/DT array/NN index/NN ,/, then/RB)
*1*let VARoldlendesc be FUNCordinarygetownproperty(VARa, "length"). 
*1*(S (Chunk let/VB VARoldlendesc/NNP) (Chunk be/VB FUNCordinarygetownproperty/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` length/NN ''/'' )/) ./.)
*1*assert: VARoldlendesc will never be undefined or an accessor descriptor because array objects are created with a length data property that cannot be deleted or reconfigured. 
*1*(S assert/NN :/: (Chunk VARoldlendesc/NNP) will/MD never/RB be/VB undefined/JJ or/CC an/DT accessor/NN descriptor/NN because/IN array/NN objects/NNS are/VBP created/VBN with/IN a/DT length/NN data/NN property/NN that/WDT can/MD not/RB be/VB deleted/VBN or/CC reconfigured/VBN ./.)
*1*let VARoldlen be VARoldlendesc.[[VALUE]]. 
*1*(S (Chunk let/VB VARoldlen/NNP) (Chunk be/VB VARoldlendesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*let VARindex be ! FUNCtouint32(VARp). 
*1*(S (Chunk let/VB VARindex/NNP) be/VB !/. (Chunk FUNCtouint32/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*1*if VARindex ≥ VARoldlen and VARoldlendesc.[[WRITABLE]] is false, return false. 
*1*(S if/IN (Chunk VARindex/NNP) (Chunk ≥/NNP) (Chunk VARoldlen/NNP) and/CC (Chunk VARoldlendesc/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*1*let VARsucceeded be ! FUNCordinarydefineownproperty(VARa, VARp, VARdesc). 
*1*(S (Chunk let/VB VARsucceeded/NNP) be/VB !/. (Chunk FUNCordinarydefineownproperty/NNP) (/( (Chunk VARa/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARdesc/NNP) )/) ./.)
*1*if VARsucceeded is false, return false. 
*1*(S if/IN VARsucceeded/VBN is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*1*if VARindex ≥ VARoldlen, then
*1*(S if/IN (Chunk VARindex/NNP) (Chunk ≥/NNP) (Chunk VARoldlen/NNP) ,/, then/RB)
*2*set VARoldlendesc.[[VALUE]] to VARindex + 1. 
*2*(S (Chunk set/VBN VARoldlendesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARindex/NNP) (Chunk +/NNP) 1/CD ./.)
*2*let VARsucceeded be FUNCordinarydefineownproperty(VARa, "length", VARoldlendesc). 
*2*(S (Chunk let/VB VARsucceeded/NNP) (Chunk be/VB FUNCordinarydefineownproperty/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` length/NN ''/'' ,/, (Chunk VARoldlendesc/NNP) )/) ./.)
*2*assert: VARsucceeded is true. 
*2*(S assert/NN :/: VARsucceeded/VBN is/VBZ true/JJ ./.)
*1*return true. 
*1*(S return/NN true/JJ ./.)
*0*return FUNCordinarydefineownproperty(VARa, VARp, VARdesc).     
*0*(S return/NN (Chunk FUNCordinarydefineownproperty/NNP) (/( (Chunk VARa/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARdesc/NNP) )/) ./.)
ID= 9.4.2.2
Summary= ArrayCreate ( length [ , proto ] )
*0*assert: VARlength is an integer number ≥ 0. 
*0*(S assert/NN :/: (Chunk VARlength/NNP) is/VBZ an/DT integer/JJ number/NN ≥/$ 0/CD ./.)
*0*if VARlength is -0, set VARlength to +0. 
*0*(S if/IN (Chunk VARlength/NNP) is/VBZ -0/JJ ,/, (Chunk set/VBN VARlength/NNP) to/TO +0/VB ./.)
*0*if VARlength&gt;232-1, throw a rangeerror exception. 
*0*(S if/IN (Chunk VARlength/NNP) &/CC gt/NN ;/: 232-1/JJ ,/, throw/VB a/DT rangeerror/NN exception/NN ./.)
*0*if VARproto is not present, set VARproto to the intrinsic object %arrayprototype%. 
*0*(S if/IN (Chunk VARproto/NNP) is/VBZ not/RB present/JJ ,/, (Chunk set/VBN VARproto/NNP) to/TO the/DT intrinsic/JJ object/NN %/NN arrayprototype/NN %/NN ./.)
*0*let VARa be a newly created array exotic object. 
*0*(S (Chunk let/VB VARa/NNP) be/VB a/DT newly/RB created/VBN array/NN exotic/JJ object/NN ./.)
*0*set VARa's essential internal methods except for [[DEFINEOWNPROPERTY]] to the default ordinary object definitions specified in 9.1. 
*0*(S (Chunk set/VBN VARa/NNP) 's/POS essential/JJ internal/JJ methods/NNS except/IN for/IN (Chunk [/NNP) (Chunk [/NNP) (Chunk DEFINEOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO the/DT default/NN ordinary/JJ object/JJ definitions/NNS specified/VBN in/IN 9.1/CD ./.)
*0*set VARa.[[DEFINEOWNPROPERTY]] as specified in 9.4.2.1. 
*0*(S (Chunk set/VBN VARa/NNP) ./. (Chunk [/VB [/NNP) (Chunk DEFINEOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) as/IN specified/VBN in/IN 9.4.2.1/CD ./.)
*0*set VARa.[[PROTOTYPE]] to VARproto. 
*0*(S (Chunk set/VBN VARa/NNP) ./. [/VB [/JJ (Chunk PROTOTYPE/NNP) ]/NN ]/NN to/TO (Chunk VARproto/NNP) ./.)
*0*set VARa.[[EXTENSIBLE]] to true. 
*0*(S (Chunk set/VBN VARa/NNP) ./. [/VB [/JJ (Chunk EXTENSIBLE/NNP) ]/NN ]/NN to/TO true/JJ ./.)
*0*perform ! FUNCordinarydefineownproperty(VARa, "length", propertydescriptor { [[VALUE]]: VARlength, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }). 
*0*(S perform/NN !/. (Chunk FUNCordinarydefineownproperty/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` length/NN ''/'' ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARlength/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) )/) ./.)
*0*return VARa.     
*0*(S return/NN (Chunk VARa/NNP) ./.)
ID= 9.4.2.3
Summary= ArraySpeciesCreate ( originalArray, length )
*0*assert: VARlength is an integer number ≥ 0. 
*0*(S assert/NN :/: (Chunk VARlength/NNP) is/VBZ an/DT integer/JJ number/NN ≥/$ 0/CD ./.)
*0*if VARlength is -0, set VARlength to +0. 
*0*(S if/IN (Chunk VARlength/NNP) is/VBZ -0/JJ ,/, (Chunk set/VBN VARlength/NNP) to/TO +0/VB ./.)
*0*let VARisarray be ? FUNCisarray(VARoriginalarray). 
*0*(S (Chunk let/VB VARisarray/NNP) be/VB ?/. (Chunk FUNCisarray/NNP) (/( (Chunk VARoriginalarray/NNP) )/) ./.)
*0*if VARisarray is false, return ? FUNCarraycreate(VARlength). 
*0*(S if/IN (Chunk VARisarray/NNP) is/VBZ false/JJ ,/, return/VB ?/. (Chunk FUNCarraycreate/NNP) (/( (Chunk VARlength/NNP) )/) ./.)
*0*let VARc be ? FUNCget(VARoriginalarray, "constructor"). 
*0*(S (Chunk let/VB VARc/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARoriginalarray/NNP) ,/, ``/`` constructor/NN ''/'' )/) ./.)
*0*if FUNCisconstructor(VARc) is true, then
*0*(S if/IN (Chunk FUNCisconstructor/NNP) (/( (Chunk VARc/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*let VARthisrealm be the current realm record. 
*1*(S (Chunk let/VB VARthisrealm/NNP) be/VB the/DT current/JJ realm/NN record/NN ./.)
*1*let VARrealmc be ? FUNCgetfunctionrealm(VARc). 
*1*(S (Chunk let/VB VARrealmc/NNP) be/VB ?/. (Chunk FUNCgetfunctionrealm/NNP) (/( (Chunk VARc/NNP) )/) ./.)
*1*if VARthisrealm and VARrealmc are not the same realm record, then
*1*(S if/IN (Chunk VARthisrealm/NNP) and/CC (Chunk VARrealmc/NNP) are/VBP not/RB the/DT same/JJ realm/NN record/NN ,/, then/RB)
*2*if FUNCsamevalue(VARc, VARrealmc.[[INTRINSICS]].[[%ARRAY%]]) is true, set VARc to undefined. 
*2*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARc/NNP) ,/, (Chunk VARrealmc./NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk INTRINSICS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./. [/VB [/CD %/NN (Chunk ARRAY/NNP) %/NN (Chunk ]/NNP) (Chunk ]/NNP) )/) is/VBZ true/JJ ,/, (Chunk set/VBN VARc/NNP) to/TO undefined/VB ./.)
*0*if FUNCtype(VARc) is object, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARc/NNP) )/) is/VBZ object/JJ ,/, then/RB)
*1*set VARc to ? FUNCget(VARc, @@species). 
*1*(S (Chunk set/VBN VARc/NNP) to/TO ?/. (Chunk FUNCget/NNP) (/( (Chunk VARc/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) species/NNS )/) ./.)
*1*if VARc is null, set VARc to undefined. 
*1*(S if/IN (Chunk VARc/NNP) is/VBZ null/JJ ,/, (Chunk set/VBN VARc/NNP) to/TO undefined/VB ./.)
*0*if VARc is undefined, return ? FUNCarraycreate(VARlength). 
*0*(S if/IN (Chunk VARc/NNP) is/VBZ undefined/JJ ,/, return/VB ?/. (Chunk FUNCarraycreate/NNP) (/( (Chunk VARlength/NNP) )/) ./.)
*0*if FUNCisconstructor(VARc) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisconstructor/NNP) (/( (Chunk VARc/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return ? FUNCconstruct(VARc, « VARlength »).     
*0*(S return/NN ?/. (Chunk FUNCconstruct/NNP) (/( (Chunk VARc/NNP) ,/, (Chunk «/NNP) (Chunk VARlength/NNP) (Chunk »/NNP) )/) ./.)
ID= 9.4.2.4
Summary= ArraySetLength ( A, Desc )
*0*if VARdesc.[[VALUE]] is absent, then
*0*(S if/IN (Chunk VARdesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ absent/JJ ,/, then/RB)
*1*return FUNCordinarydefineownproperty(VARa, "length", VARdesc). 
*1*(S return/NN (Chunk FUNCordinarydefineownproperty/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` length/NN ''/'' ,/, (Chunk VARdesc/NNP) )/) ./.)
*0*let VARnewlendesc be a copy of VARdesc. 
*0*(S (Chunk let/VB VARnewlendesc/NNP) be/VB a/DT copy/NN of/IN (Chunk VARdesc/NNP) ./.)
*0*let VARnewlen be ? FUNCtouint32(VARdesc.[[VALUE]]). 
*0*(S (Chunk let/VB VARnewlen/NNP) be/VB ?/. (Chunk FUNCtouint32/NNP) (/( (Chunk VARdesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*0*let VARnumberlen be ? FUNCtonumber(VARdesc.[[VALUE]]). 
*0*(S (Chunk let/VB VARnumberlen/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARdesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*0*if VARnewlen ≠ VARnumberlen, throw a rangeerror exception. 
*0*(S if/IN (Chunk VARnewlen/NNP) (Chunk ≠/NNP) (Chunk VARnumberlen/NNP) ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*set VARnewlendesc.[[VALUE]] to VARnewlen. 
*0*(S (Chunk set/VBN VARnewlendesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARnewlen/NNP) ./.)
*0*let VARoldlendesc be FUNCordinarygetownproperty(VARa, "length"). 
*0*(S (Chunk let/VB VARoldlendesc/NNP) (Chunk be/VB FUNCordinarygetownproperty/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` length/NN ''/'' )/) ./.)
*0*assert: VARoldlendesc will never be undefined or an accessor descriptor because array objects are created with a length data property that cannot be deleted or reconfigured. 
*0*(S assert/NN :/: (Chunk VARoldlendesc/NNP) will/MD never/RB be/VB undefined/JJ or/CC an/DT accessor/NN descriptor/NN because/IN array/NN objects/NNS are/VBP created/VBN with/IN a/DT length/NN data/NN property/NN that/WDT can/MD not/RB be/VB deleted/VBN or/CC reconfigured/VBN ./.)
*0*let VARoldlen be VARoldlendesc.[[VALUE]]. 
*0*(S (Chunk let/VB VARoldlen/NNP) (Chunk be/VB VARoldlendesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARnewlen ≥ VARoldlen, then
*0*(S if/IN (Chunk VARnewlen/NNP) (Chunk ≥/NNP) (Chunk VARoldlen/NNP) ,/, then/RB)
*1*return FUNCordinarydefineownproperty(VARa, "length", VARnewlendesc). 
*1*(S return/NN (Chunk FUNCordinarydefineownproperty/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` length/NN ''/'' ,/, (Chunk VARnewlendesc/NNP) )/) ./.)
*0*if VARoldlendesc.[[WRITABLE]] is false, return false. 
*0*(S if/IN (Chunk VARoldlendesc/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*0*if VARnewlendesc.[[WRITABLE]] is absent or has the value true, let VARnewwritable be true. 
*0*(S if/IN (Chunk VARnewlendesc/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ absent/JJ or/CC has/VBZ the/DT value/NN true/JJ ,/, let/VB VARnewwritable/JJ be/VB true/JJ ./.)
*0*else,
*0*(S else/RB ,/,)
*1*need to defer setting the [[WRITABLE]] attribute to false in case any elements cannot be deleted. 
*1*(S need/NN to/TO defer/VB setting/VBG the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) attribute/NN to/TO false/VB in/IN case/NN any/DT elements/NNS can/MD not/RB be/VB deleted/VBN ./.)
*1*let VARnewwritable be false. 
*1*(S let/VB VARnewwritable/JJ be/VB false/JJ ./.)
*1*set VARnewlendesc.[[WRITABLE]] to true. 
*1*(S (Chunk set/VBN VARnewlendesc/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) ]/NN ]/NN to/TO true/JJ ./.)
*0*let VARsucceeded be ! FUNCordinarydefineownproperty(VARa, "length", VARnewlendesc). 
*0*(S (Chunk let/VB VARsucceeded/NNP) be/VB !/. (Chunk FUNCordinarydefineownproperty/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` length/NN ''/'' ,/, (Chunk VARnewlendesc/NNP) )/) ./.)
*0*if VARsucceeded is false, return false. 
*0*(S if/IN VARsucceeded/VBN is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*0*repeat, while VARnewlen &lt; VARoldlen,
*0*(S repeat/NN ,/, while/IN (Chunk VARnewlen/NNP) &/CC lt/NN ;/: (Chunk VARoldlen/NNP) ,/,)
*1*set VARoldlen to VARoldlen - 1. 
*1*(S (Chunk set/VBN VARoldlen/NNP) to/TO (Chunk VARoldlen/NNP) -/: 1/CD ./.)
*1*let VARdeletesucceeded be ! VARa.[[DELETE]](! FUNCtostring(VARoldlen)). 
*1*(S (Chunk let/VB VARdeletesucceeded/NNP) be/VB !/. (Chunk VARa./NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk DELETE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARoldlen/NNP) )/) )/) ./.)
*1*if VARdeletesucceeded is false, then
*1*(S if/IN VARdeletesucceeded/VBN is/VBZ false/JJ ,/, then/RB)
*2*set VARnewlendesc.[[VALUE]] to VARoldlen + 1. 
*2*(S (Chunk set/VBN VARnewlendesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARoldlen/NNP) (Chunk +/NNP) 1/CD ./.)
*2*if VARnewwritable is false, set VARnewlendesc.[[WRITABLE]] to false. 
*2*(S if/IN (Chunk VARnewwritable/NNP) is/VBZ false/JJ ,/, (Chunk set/VBN VARnewlendesc/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) ]/NN ]/NN to/TO false/VB ./.)
*2*perform ! FUNCordinarydefineownproperty(VARa, "length", VARnewlendesc). 
*2*(S perform/NN !/. (Chunk FUNCordinarydefineownproperty/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` length/NN ''/'' ,/, (Chunk VARnewlendesc/NNP) )/) ./.)
*2*return false. 
*2*(S return/NN false/JJ ./.)
*0*if VARnewwritable is false, then
*0*(S if/IN (Chunk VARnewwritable/NNP) is/VBZ false/JJ ,/, then/RB)
*1*return FUNCordinarydefineownproperty(VARa, "length", propertydescriptor { [[WRITABLE]]: false }). this call will always return true. 
*1*(S return/NN (Chunk FUNCordinarydefineownproperty/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` length/NN ''/'' ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) )/) ./. this/DT call/NN will/MD always/RB return/VB true/JJ ./.)
*0*return true.     
*0*(S return/NN true/JJ ./.)
ID= 9.4.3.1
Summary= [[GetOwnProperty]] ( P )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARdesc be FUNCordinarygetownproperty(VARs, VARp). 
*0*(S (Chunk let/VB VARdesc/NNP) (Chunk be/VB FUNCordinarygetownproperty/NNP) (/( (Chunk VARs/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
*0*if VARdesc is not undefined, return VARdesc. 
*0*(S if/IN (Chunk VARdesc/NNP) is/VBZ not/RB undefined/JJ ,/, (Chunk return/VB VARdesc/NNP) ./.)
*0*return ! FUNCstringgetownproperty(VARs, VARp).     
*0*(S return/NN !/. (Chunk FUNCstringgetownproperty/NNP) (/( (Chunk VARs/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
ID= 9.4.3.2
Summary= [[DefineOwnProperty]] ( P, Desc )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARstringdesc be ! FUNCstringgetownproperty(VARs, VARp). 
*0*(S (Chunk let/VB VARstringdesc/NNP) be/VB !/. (Chunk FUNCstringgetownproperty/NNP) (/( (Chunk VARs/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
*0*if VARstringdesc is not undefined, then
*0*(S if/IN (Chunk VARstringdesc/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*1*let VARextensible be VARs.[[EXTENSIBLE]]. 
*1*(S let/VB VARextensible/JJ (Chunk be/VB VARs/NNP) ./. [/VB [/JJ (Chunk EXTENSIBLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*return ! FUNCiscompatiblepropertydescriptor(VARextensible, VARdesc, VARstringdesc). 
*1*(S return/NN !/. (Chunk FUNCiscompatiblepropertydescriptor/NNP) (/( (Chunk VARextensible/NNP) ,/, (Chunk VARdesc/NNP) ,/, (Chunk VARstringdesc/NNP) )/) ./.)
*0*return ! FUNCordinarydefineownproperty(VARs, VARp, VARdesc).     
*0*(S return/NN !/. (Chunk FUNCordinarydefineownproperty/NNP) (/( (Chunk VARs/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARdesc/NNP) )/) ./.)
ID= 9.4.3.3
Summary= [[OwnPropertyKeys]] ( )
*0*let VARkeys be a new empty list. 
*0*(S (Chunk let/VB VARkeys/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARstr be the string value of VARo.[[STRINGDATA]]. 
*0*(S (Chunk let/VB VARstr/NNP) be/VB the/DT string/VBG value/NN of/IN (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk STRINGDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARlen be the length of VARstr. 
*0*(S (Chunk let/VB VARlen/NNP) be/VB the/DT length/NN of/IN (Chunk VARstr/NNP) ./.)
*0*for each integer VARi starting with 0 such that VARi &lt; VARlen, in ascending order, do
*0*(S for/IN each/DT integer/NN (Chunk VARi/NNP) starting/VBG with/IN 0/CD such/JJ that/IN (Chunk VARi/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP) ,/, in/IN ascending/VBG order/NN ,/, do/VBP)
*1*add ! FUNCtostring(VARi) as the last element of VARkeys. 
*1*(S add/NN !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARi/NNP) )/) as/IN the/DT last/JJ element/NN of/IN (Chunk VARkeys/NNP) ./.)
*0*for each own property key VARp of VARo such that VARp is an integer index and FUNCtointeger(VARp) ≥ VARlen, in ascending numeric index order, do
*0*(S for/IN each/DT own/JJ property/NN key/JJ (Chunk VARp/NNP) of/IN (Chunk VARo/NNP) such/JJ that/IN (Chunk VARp/NNP) is/VBZ an/DT integer/NN index/NN and/CC (Chunk FUNCtointeger/NNP) (/( (Chunk VARp/NNP) )/) (Chunk ≥/NNP) (Chunk VARlen/NNP) ,/, in/IN ascending/VBG numeric/JJ index/NN order/NN ,/, do/VBP)
*1*add VARp as the last element of VARkeys. 
*1*(S (Chunk add/RB VARp/NNP) as/IN the/DT last/JJ element/NN of/IN (Chunk VARkeys/NNP) ./.)
*0*for each own property key VARp of VARo such that FUNCtype(VARp) is string and VARp is not an integer index, in ascending chronological order of property creation, do
*0*(S for/IN each/DT own/JJ property/NN key/JJ (Chunk VARp/NNP) of/IN (Chunk VARo/NNP) such/JJ that/IN (Chunk FUNCtype/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ string/VBG and/CC (Chunk VARp/NNP) is/VBZ not/RB an/DT integer/NN index/NN ,/, in/IN ascending/VBG chronological/JJ order/NN of/IN property/NN creation/NN ,/, do/VBP)
*1*add VARp as the last element of VARkeys. 
*1*(S (Chunk add/RB VARp/NNP) as/IN the/DT last/JJ element/NN of/IN (Chunk VARkeys/NNP) ./.)
*0*for each own property key VARp of VARo such that FUNCtype(VARp) is symbol, in ascending chronological order of property creation, do
*0*(S for/IN each/DT own/JJ property/NN key/JJ (Chunk VARp/NNP) of/IN (Chunk VARo/NNP) such/JJ that/IN (Chunk FUNCtype/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ symbol/JJ ,/, in/IN ascending/VBG chronological/JJ order/NN of/IN property/NN creation/NN ,/, do/VBP)
*1*add VARp as the last element of VARkeys. 
*1*(S (Chunk add/RB VARp/NNP) as/IN the/DT last/JJ element/NN of/IN (Chunk VARkeys/NNP) ./.)
*0*return VARkeys.     
*0*(S return/NN (Chunk VARkeys/NNP) ./.)
ID= 9.4.3.4
Summary= StringCreate ( value, prototype )
*0*assert: FUNCtype(VARvalue) is string. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARvalue/NNP) )/) is/VBZ string/VBG ./.)
*0*let VARs be a newly created string exotic object. 
*0*(S (Chunk let/VB VARs/NNP) be/VB a/DT newly/RB created/VBN string/NN exotic/JJ object/NN ./.)
*0*set VARs.[[STRINGDATA]] to VARvalue. 
*0*(S set/NN (Chunk VARs/NNP) ./. [/VB [/JJ (Chunk STRINGDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARvalue/NNP) ./.)
*0*set VARs's essential internal methods to the default ordinary object definitions specified in 9.1. 
*0*(S set/NN (Chunk VARs/NNP) 's/POS essential/JJ internal/JJ methods/NNS to/TO the/DT default/NN ordinary/JJ object/JJ definitions/NNS specified/VBN in/IN 9.1/CD ./.)
*0*set VARs.[[GETOWNPROPERTY]] as specified in 9.4.3.1. 
*0*(S set/NN (Chunk VARs/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) as/IN specified/VBN in/IN 9.4.3.1/CD ./.)
*0*set VARs.[[DEFINEOWNPROPERTY]] as specified in 9.4.3.2. 
*0*(S set/NN (Chunk VARs/NNP) ./. (Chunk [/VB [/NNP) (Chunk DEFINEOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) as/IN specified/VBN in/IN 9.4.3.2/CD ./.)
*0*set VARs.[[OWNPROPERTYKEYS]] as specified in 9.4.3.3. 
*0*(S set/NN (Chunk VARs/NNP) ./. [/VB [/JJ (Chunk OWNPROPERTYKEYS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) as/IN specified/VBN in/IN 9.4.3.3/CD ./.)
*0*set VARs.[[PROTOTYPE]] to VARprototype. 
*0*(S set/NN (Chunk VARs/NNP) ./. [/VB [/JJ (Chunk PROTOTYPE/NNP) ]/NN ]/NN to/TO (Chunk VARprototype/NNP) ./.)
*0*set VARs.[[EXTENSIBLE]] to true. 
*0*(S set/NN (Chunk VARs/NNP) ./. [/VB [/JJ (Chunk EXTENSIBLE/NNP) ]/NN ]/NN to/TO true/JJ ./.)
*0*let VARlength be the number of code unit elements in VARvalue. 
*0*(S (Chunk let/VB VARlength/NNP) be/VB the/DT number/NN of/IN code/JJ unit/NN elements/NNS in/IN (Chunk VARvalue/NNP) ./.)
*0*perform ! FUNCdefinepropertyorthrow(VARs, "length", propertydescriptor { [[VALUE]]: VARlength, [[WRITABLE]]: false, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }). 
*0*(S perform/NN !/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARs/NNP) ,/, ``/`` length/NN ''/'' ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARlength/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) )/) ./.)
*0*return VARs.     
*0*(S return/NN (Chunk VARs/NNP) ./.)
ID= 9.4.3.5
Summary= StringGetOwnProperty ( S, P )
*0*assert: VARs is an object that has a [[STRINGDATA]] internal slot. 
*0*(S assert/NN :/: (Chunk VARs/NNP) is/VBZ an/DT object/NN that/WDT has/VBZ a/DT [/JJ [/NN (Chunk STRINGDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*if FUNCtype(VARp) is not string, return undefined. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ not/RB string/JJ ,/, return/NN undefined/VBD ./.)
*0*let VARindex be ! FUNCcanonicalnumericindexstring(VARp). 
*0*(S (Chunk let/VB VARindex/NNP) be/VB !/. (Chunk FUNCcanonicalnumericindexstring/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*if VARindex is undefined, return undefined. 
*0*(S if/IN (Chunk VARindex/NNP) is/VBZ undefined/JJ ,/, return/NN undefined/VBD ./.)
*0*if FUNCisinteger(VARindex) is false, return undefined. 
*0*(S if/IN (Chunk FUNCisinteger/NNP) (/( (Chunk VARindex/NNP) )/) is/VBZ false/JJ ,/, return/NN undefined/VBD ./.)
*0*if VARindex = -0, return undefined. 
*0*(S if/IN (Chunk VARindex/NNP) (Chunk =/NNP) (Chunk -0/NNP) ,/, return/NN undefined/VBD ./.)
*0*let VARstr be the string value of VARs.[[STRINGDATA]]. 
*0*(S (Chunk let/VB VARstr/NNP) be/VB the/DT string/VBG value/NN of/IN (Chunk VARs/NNP) ./. [/VB [/JJ (Chunk STRINGDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARlen be the length of VARstr. 
*0*(S (Chunk let/VB VARlen/NNP) be/VB the/DT length/NN of/IN (Chunk VARstr/NNP) ./.)
*0*if VARindex &lt; 0 or VARlen ≤ VARindex, return undefined. 
*0*(S if/IN (Chunk VARindex/NNP) &/CC lt/NN ;/: 0/CD or/CC (Chunk VARlen/NNP) (Chunk ≤/NNP) (Chunk VARindex/NNP) ,/, return/NN undefined/VBD ./.)
*0*let VARresultstr be the string value of length 1, containing one code unit from VARstr, specifically the code unit at index VARindex. 
*0*(S (Chunk let/VB VARresultstr/NNP) be/VB the/DT string/VBG value/NN of/IN length/NN 1/CD ,/, containing/VBG one/CD code/NN unit/NN from/IN (Chunk VARstr/NNP) ,/, specifically/RB the/DT code/NN unit/NN at/IN index/NN (Chunk VARindex/NNP) ./.)
*0*return a propertydescriptor { [[VALUE]]: VARresultstr, [[WRITABLE]]: false, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: false }.     
*0*(S return/VB a/DT propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARresultstr/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) ./.)
ID= 9.4.4.1
Summary= [[GetOwnProperty]] ( P )
*0*let VARargs be the arguments object. 
*0*(S (Chunk let/VB VARargs/NNP) be/VB the/DT arguments/NNS object/VBP ./.)
*0*let VARdesc be FUNCordinarygetownproperty(VARargs, VARp). 
*0*(S (Chunk let/VB VARdesc/NNP) (Chunk be/VB FUNCordinarygetownproperty/NNP) (/( (Chunk VARargs/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
*0*if VARdesc is undefined, return VARdesc. 
*0*(S if/IN (Chunk VARdesc/NNP) is/VBZ undefined/JJ ,/, (Chunk return/VB VARdesc/NNP) ./.)
*0*let VARmap be VARargs.[[PARAMETERMAP]]. 
*0*(S (Chunk let/VB VARmap/NNP) (Chunk be/VB VARargs/NNP) ./. [/VB [/JJ (Chunk PARAMETERMAP/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARismapped be ! FUNChasownproperty(VARmap, VARp). 
*0*(S (Chunk let/VB VARismapped/NNP) be/VB !/. (Chunk FUNChasownproperty/NNP) (/( (Chunk VARmap/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
*0*if VARismapped is true, then
*0*(S if/IN (Chunk VARismapped/NNP) is/VBZ true/JJ ,/, then/RB)
*1*set VARdesc.[[VALUE]] to FUNCget(VARmap, VARp). 
*1*(S (Chunk set/VBN VARdesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk FUNCget/NNP) (/( (Chunk VARmap/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
*0*return VARdesc.     
*0*(S return/NN (Chunk VARdesc/NNP) ./.)
ID= 9.4.4.2
Summary= [[DefineOwnProperty]] ( P, Desc )
*0*let VARargs be the arguments object. 
*0*(S (Chunk let/VB VARargs/NNP) be/VB the/DT arguments/NNS object/VBP ./.)
*0*let VARmap be VARargs.[[PARAMETERMAP]]. 
*0*(S (Chunk let/VB VARmap/NNP) (Chunk be/VB VARargs/NNP) ./. [/VB [/JJ (Chunk PARAMETERMAP/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARismapped be FUNChasownproperty(VARmap, VARp). 
*0*(S (Chunk let/VB VARismapped/NNP) (Chunk be/VB FUNChasownproperty/NNP) (/( (Chunk VARmap/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
*0*let VARnewargdesc be VARdesc. 
*0*(S (Chunk let/VB VARnewargdesc/NNP) (Chunk be/VB VARdesc/NNP) ./.)
*0*if VARismapped is true and FUNCisdatadescriptor(VARdesc) is true, then
*0*(S if/IN (Chunk VARismapped/NNP) is/VBZ true/JJ and/CC (Chunk FUNCisdatadescriptor/NNP) (/( (Chunk VARdesc/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*if VARdesc.[[VALUE]] is not present and VARdesc.[[WRITABLE]] is present and its value is false, then
*1*(S if/IN (Chunk VARdesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB present/JJ and/CC (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ present/JJ and/CC its/PRP$ value/NN is/VBZ false/JJ ,/, then/RB)
*2*set VARnewargdesc to a copy of VARdesc. 
*2*(S (Chunk set/VBN VARnewargdesc/NNP) to/TO a/DT copy/NN of/IN (Chunk VARdesc/NNP) ./.)
*2*set VARnewargdesc.[[VALUE]] to FUNCget(VARmap, VARp). 
*2*(S (Chunk set/VBN VARnewargdesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk FUNCget/NNP) (/( (Chunk VARmap/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
*0*let VARallowed be ? FUNCordinarydefineownproperty(VARargs, VARp, VARnewargdesc). 
*0*(S (Chunk let/VB VARallowed/NNP) be/VB ?/. (Chunk FUNCordinarydefineownproperty/NNP) (/( (Chunk VARargs/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARnewargdesc/NNP) )/) ./.)
*0*if VARallowed is false, return false. 
*0*(S if/IN VARallowed/VBN is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*0*if VARismapped is true, then
*0*(S if/IN (Chunk VARismapped/NNP) is/VBZ true/JJ ,/, then/RB)
*1*if FUNCisaccessordescriptor(VARdesc) is true, then
*1*(S if/IN (Chunk FUNCisaccessordescriptor/NNP) (/( (Chunk VARdesc/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*call VARmap.[[DELETE]](VARp). 
*2*(S call/NN (Chunk VARmap/NNP) ./. [/VB [/JJ (Chunk DELETE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*if VARdesc.[[VALUE]] is present, then
*2*(S if/IN (Chunk VARdesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ present/JJ ,/, then/RB)
*3*let VARsetstatus be FUNCset(VARmap, VARp, VARdesc.[[VALUE]], false). 
*3*(S (Chunk let/VB VARsetstatus/NNP) (Chunk be/VB FUNCset/NNP) (/( (Chunk VARmap/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARdesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, false/RB )/) ./.)
*3*assert: VARsetstatus is true because formal parameters mapped by argument objects are always writable. 
*3*(S assert/NN :/: (Chunk VARsetstatus/NNP) is/VBZ true/JJ because/IN formal/JJ parameters/NNS mapped/VBN by/IN argument/NN objects/NNS are/VBP always/RB writable/JJ ./.)
*2*if VARdesc.[[WRITABLE]] is present and its value is false, then
*2*(S if/IN (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ present/JJ and/CC its/PRP$ value/NN is/VBZ false/JJ ,/, then/RB)
*3*call VARmap.[[DELETE]](VARp). 
*3*(S call/NN (Chunk VARmap/NNP) ./. [/VB [/JJ (Chunk DELETE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*return true.     
*0*(S return/NN true/JJ ./.)
ID= 9.4.4.3
Summary= [[Get]] ( P, Receiver )
*0*let VARargs be the arguments object. 
*0*(S (Chunk let/VB VARargs/NNP) be/VB the/DT arguments/NNS object/VBP ./.)
*0*let VARmap be VARargs.[[PARAMETERMAP]]. 
*0*(S (Chunk let/VB VARmap/NNP) (Chunk be/VB VARargs/NNP) ./. [/VB [/JJ (Chunk PARAMETERMAP/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARismapped be ! FUNChasownproperty(VARmap, VARp). 
*0*(S (Chunk let/VB VARismapped/NNP) be/VB !/. (Chunk FUNChasownproperty/NNP) (/( (Chunk VARmap/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
*0*if VARismapped is false, then
*0*(S if/IN (Chunk VARismapped/NNP) is/VBZ false/JJ ,/, then/RB)
*1*return ? FUNCordinaryget(VARargs, VARp, VARreceiver). 
*1*(S return/NN ?/. (Chunk FUNCordinaryget/NNP) (/( (Chunk VARargs/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARreceiver/NNP) )/) ./.)
*0*else VARmap contains a formal parameter mapping for VARp,
*0*(S (Chunk else/RB VARmap/NNP) contains/VBZ a/DT formal/JJ parameter/NN mapping/VBG for/IN (Chunk VARp/NNP) ,/,)
*1*return FUNCget(VARmap, VARp).     
*1*(S return/NN (Chunk FUNCget/NNP) (/( (Chunk VARmap/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
ID= 9.4.4.4
Summary= [[Set]] ( P, V, Receiver )
*0*let VARargs be the arguments object. 
*0*(S (Chunk let/VB VARargs/NNP) be/VB the/DT arguments/NNS object/VBP ./.)
*0*if FUNCsamevalue(VARargs, VARreceiver) is false, then
*0*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARargs/NNP) ,/, (Chunk VARreceiver/NNP) )/) is/VBZ false/JJ ,/, then/RB)
*1*let VARismapped be false. 
*1*(S (Chunk let/VB VARismapped/NNP) be/VB false/JJ ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARmap be VARargs.[[PARAMETERMAP]]. 
*1*(S (Chunk let/VB VARmap/NNP) (Chunk be/VB VARargs/NNP) ./. [/VB [/JJ (Chunk PARAMETERMAP/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*let VARismapped be ! FUNChasownproperty(VARmap, VARp). 
*1*(S (Chunk let/VB VARismapped/NNP) be/VB !/. (Chunk FUNChasownproperty/NNP) (/( (Chunk VARmap/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
*0*if VARismapped is true, then
*0*(S if/IN (Chunk VARismapped/NNP) is/VBZ true/JJ ,/, then/RB)
*1*let VARsetstatus be FUNCset(VARmap, VARp, VARv, false). 
*1*(S (Chunk let/VB VARsetstatus/NNP) (Chunk be/VB FUNCset/NNP) (/( (Chunk VARmap/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARv/NNP) ,/, false/RB )/) ./.)
*1*assert: VARsetstatus is true because formal parameters mapped by argument objects are always writable. 
*1*(S assert/NN :/: (Chunk VARsetstatus/NNP) is/VBZ true/JJ because/IN formal/JJ parameters/NNS mapped/VBN by/IN argument/NN objects/NNS are/VBP always/RB writable/JJ ./.)
*0*return ? FUNCordinaryset(VARargs, VARp, VARv, VARreceiver).     
*0*(S return/NN ?/. (Chunk FUNCordinaryset/NNP) (/( (Chunk VARargs/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARv/NNP) ,/, (Chunk VARreceiver/NNP) )/) ./.)
ID= 9.4.4.5
Summary= [[Delete]] ( P )
*0*let VARargs be the arguments object. 
*0*(S (Chunk let/VB VARargs/NNP) be/VB the/DT arguments/NNS object/VBP ./.)
*0*let VARmap be VARargs.[[PARAMETERMAP]]. 
*0*(S (Chunk let/VB VARmap/NNP) (Chunk be/VB VARargs/NNP) ./. [/VB [/JJ (Chunk PARAMETERMAP/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARismapped be ! FUNChasownproperty(VARmap, VARp). 
*0*(S (Chunk let/VB VARismapped/NNP) be/VB !/. (Chunk FUNChasownproperty/NNP) (/( (Chunk VARmap/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
*0*let VARresult be ? FUNCordinarydelete(VARargs, VARp). 
*0*(S (Chunk let/VB VARresult/NNP) be/VB ?/. (Chunk FUNCordinarydelete/NNP) (/( (Chunk VARargs/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
*0*if VARresult is true and VARismapped is true, then
*0*(S if/IN (Chunk VARresult/NNP) is/VBZ true/JJ and/CC (Chunk VARismapped/NNP) is/VBZ true/JJ ,/, then/RB)
*1*call VARmap.[[DELETE]](VARp). 
*1*(S call/NN (Chunk VARmap/NNP) ./. [/VB [/JJ (Chunk DELETE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*return VARresult.     
*0*(S return/NN (Chunk VARresult/NNP) ./.)
ID= 9.4.4.6
Summary= CreateUnmappedArgumentsObject ( argumentsList )
*0*let VARlen be the number of elements in VARargumentslist. 
*0*(S (Chunk let/VB VARlen/NNP) be/VB the/DT number/NN of/IN elements/NNS in/IN (Chunk VARargumentslist/NNP) ./.)
*0*let VARobj be FUNCobjectcreate(%objectprototype%, « [[PARAMETERMAP]] »). 
*0*(S (Chunk let/VB VARobj/NNP) (Chunk be/VB FUNCobjectcreate/NNP) (/( %/NN objectprototype/NN %/NN ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk PARAMETERMAP/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARobj.[[PARAMETERMAP]] to undefined. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk PARAMETERMAP/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO undefined/VB ./.)
*0*perform FUNCdefinepropertyorthrow(VARobj, "length", propertydescriptor { [[VALUE]]: VARlen, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }). 
*0*(S perform/NN (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` length/NN ''/'' ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARlen/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ }/) )/) ./.)
*0*let VARindex be 0. 
*0*(S (Chunk let/VB VARindex/NNP) be/VB 0/CD ./.)
*0*repeat, while VARindex &lt; VARlen,
*0*(S repeat/NN ,/, while/IN (Chunk VARindex/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP) ,/,)
*1*let VARval be VARargumentslist[VARindex]. 
*1*(S (Chunk let/VB VARval/NNP) (Chunk be/VB VARargumentslist/NNP) (Chunk [/NNP) (Chunk VARindex/NNP) (Chunk ]/NNP) ./.)
*1*perform FUNCcreatedataproperty(VARobj, ! FUNCtostring(VARindex), VARval). 
*1*(S perform/NN (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARobj/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARindex/NNP) )/) ,/, (Chunk VARval/NNP) )/) ./.)
*1*let VARindex be VARindex + 1. 
*1*(S (Chunk let/VB VARindex/NNP) (Chunk be/VB VARindex/NNP) (Chunk +/NNP) 1/CD ./.)
*0*perform ! FUNCdefinepropertyorthrow(VARobj, @@iterator, propertydescriptor { [[VALUE]]: %arrayproto_values%, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }). 
*0*(S perform/NN !/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARobj/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) iterator/NN ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) :/: %/NN arrayproto_values/VBZ %/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ }/) )/) ./.)
*0*perform ! FUNCdefinepropertyorthrow(VARobj, "callee", propertydescriptor { [[GET]]: %throwtypeerror%, [[SET]]: %throwtypeerror%, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }). 
*0*(S perform/NN !/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` callee/NN ''/'' ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) :/: %/NN throwtypeerror/NN %/NN ,/, [/JJ [/NN (Chunk SET/NNP) (Chunk ]/NNP) ]/NN :/: %/NN throwtypeerror/NN %/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) )/) ./.)
*0*return VARobj.     
*0*(S return/NN (Chunk VARobj/NNP) ./.)
ID= 9.4.4.7
Summary= CreateMappedArgumentsObject ( func, formals, argumentsList, env )
*0*assert: VARformals does not contain a rest parameter, any binding patterns, or any initializers. it may contain duplicate identifiers. 
*0*(S assert/NN :/: VARformals/NNS does/VBZ not/RB contain/VB a/DT rest/NN parameter/NN ,/, any/DT binding/NN patterns/NNS ,/, or/CC any/DT initializers/NNS ./. it/PRP may/MD contain/VB duplicate/JJ identifiers/NNS ./.)
*0*let VARlen be the number of elements in VARargumentslist. 
*0*(S (Chunk let/VB VARlen/NNP) be/VB the/DT number/NN of/IN elements/NNS in/IN (Chunk VARargumentslist/NNP) ./.)
*0*let VARobj be a newly created arguments exotic object with a [[PARAMETERMAP]] internal slot. 
*0*(S (Chunk let/VB VARobj/NNP) be/VB a/DT newly/RB created/VBN arguments/NNS exotic/JJ object/NN with/IN a/DT [/JJ [/NN (Chunk PARAMETERMAP/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*set VARobj.[[GETOWNPROPERTY]] as specified in 9.4.4.1. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) as/IN specified/VBN in/IN 9.4.4.1/CD ./.)
*0*set VARobj.[[DEFINEOWNPROPERTY]] as specified in 9.4.4.2. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. (Chunk [/VB [/NNP) (Chunk DEFINEOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) as/IN specified/VBN in/IN 9.4.4.2/CD ./.)
*0*set VARobj.[[GET]] as specified in 9.4.4.3. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) as/IN specified/VBN in/IN 9.4.4.3/CD ./.)
*0*set VARobj.[[SET]] as specified in 9.4.4.4. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/NN [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) as/IN specified/VBN in/IN 9.4.4.4/CD ./.)
*0*set VARobj.[[DELETE]] as specified in 9.4.4.5. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk DELETE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) as/IN specified/VBN in/IN 9.4.4.5/CD ./.)
*0*set the remainder of VARobj's essential internal methods to the default ordinary object definitions specified in 9.1. 
*0*(S set/VB the/DT remainder/NN of/IN (Chunk VARobj/NNP) 's/POS essential/JJ internal/JJ methods/NNS to/TO the/DT default/NN ordinary/JJ object/JJ definitions/NNS specified/VBN in/IN 9.1/CD ./.)
*0*set VARobj.[[PROTOTYPE]] to %objectprototype%. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk PROTOTYPE/NNP) ]/NN (Chunk ]/NNP) to/TO %/NN objectprototype/JJ %/NN ./.)
*0*set VARobj.[[EXTENSIBLE]] to true. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk EXTENSIBLE/NNP) ]/NN ]/NN to/TO true/JJ ./.)
*0*let VARmap be FUNCobjectcreate(null). 
*0*(S (Chunk let/VB VARmap/NNP) (Chunk be/VB FUNCobjectcreate/NNP) (/( null/NN )/) ./.)
*0*set VARobj.[[PARAMETERMAP]] to VARmap. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk PARAMETERMAP/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARmap/NNP) ./.)
*0*let VARparameternames be the boundnames of VARformals. 
*0*(S (Chunk let/VB VARparameternames/NNP) be/VB the/DT boundnames/NNS of/IN VARformals/NNS ./.)
*0*let VARnumberofparameters be the number of elements in VARparameternames. 
*0*(S let/VB VARnumberofparameters/NNS be/VB the/DT number/NN of/IN elements/NNS in/IN (Chunk VARparameternames/NNP) ./.)
*0*let VARindex be 0. 
*0*(S (Chunk let/VB VARindex/NNP) be/VB 0/CD ./.)
*0*repeat, while VARindex &lt; VARlen,
*0*(S repeat/NN ,/, while/IN (Chunk VARindex/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP) ,/,)
*1*let VARval be VARargumentslist[VARindex]. 
*1*(S (Chunk let/VB VARval/NNP) (Chunk be/VB VARargumentslist/NNP) (Chunk [/NNP) (Chunk VARindex/NNP) (Chunk ]/NNP) ./.)
*1*perform FUNCcreatedataproperty(VARobj, ! FUNCtostring(VARindex), VARval). 
*1*(S perform/NN (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARobj/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARindex/NNP) )/) ,/, (Chunk VARval/NNP) )/) ./.)
*1*let VARindex be VARindex + 1. 
*1*(S (Chunk let/VB VARindex/NNP) (Chunk be/VB VARindex/NNP) (Chunk +/NNP) 1/CD ./.)
*0*perform FUNCdefinepropertyorthrow(VARobj, "length", propertydescriptor { [[VALUE]]: VARlen, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }). 
*0*(S perform/NN (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` length/NN ''/'' ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARlen/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ }/) )/) ./.)
*0*let VARmappednames be a new empty list. 
*0*(S (Chunk let/VB VARmappednames/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARindex be VARnumberofparameters - 1. 
*0*(S (Chunk let/VB VARindex/NNP) (Chunk be/VB VARnumberofparameters/NNP) -/: 1/CD ./.)
*0*repeat, while VARindex ≥ 0,
*0*(S repeat/NN ,/, while/IN (Chunk VARindex/NNP) ≥/VBD 0/CD ,/,)
*1*let VARname be VARparameternames[VARindex]. 
*1*(S (Chunk let/VB VARname/NNP) (Chunk be/VB VARparameternames/NNP) (Chunk [/NNP) (Chunk VARindex/NNP) (Chunk ]/NNP) ./.)
*1*if VARname is not an element of VARmappednames, then
*1*(S if/IN (Chunk VARname/NNP) is/VBZ not/RB an/DT element/NN of/IN (Chunk VARmappednames/NNP) ,/, then/RB)
*2*add VARname as an element of the list VARmappednames. 
*2*(S (Chunk add/RB VARname/NNP) as/IN an/DT element/NN of/IN the/DT list/NN (Chunk VARmappednames/NNP) ./.)
*2*if VARindex &lt; VARlen, then
*2*(S if/IN (Chunk VARindex/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP) ,/, then/RB)
*3*let VARg be FUNCmakearggetter(VARname, VARenv). 
*3*(S (Chunk let/VB VARg/NNP) (Chunk be/VB FUNCmakearggetter/NNP) (/( (Chunk VARname/NNP) ,/, (Chunk VARenv/NNP) )/) ./.)
*3*let VARp be FUNCmakeargsetter(VARname, VARenv). 
*3*(S (Chunk let/VB VARp/NNP) (Chunk be/VB FUNCmakeargsetter/NNP) (/( (Chunk VARname/NNP) ,/, (Chunk VARenv/NNP) )/) ./.)
*3*perform VARmap.[[DEFINEOWNPROPERTY]](! FUNCtostring(VARindex), propertydescriptor { [[SET]]: VARp, [[GET]]: VARg, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }). 
*3*(S perform/NN (Chunk VARmap./NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk DEFINEOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARindex/NNP) )/) ,/, propertydescriptor/NN {/( [/JJ [/NN (Chunk SET/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARp/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk GET/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARg/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ }/) )/) ./.)
*1*let VARindex be VARindex - 1. 
*1*(S (Chunk let/VB VARindex/NNP) (Chunk be/VB VARindex/NNP) -/: 1/CD ./.)
*0*perform ! FUNCdefinepropertyorthrow(VARobj, @@iterator, propertydescriptor { [[VALUE]]: %arrayproto_values%, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }). 
*0*(S perform/NN !/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARobj/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) iterator/NN ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) :/: %/NN arrayproto_values/VBZ %/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ }/) )/) ./.)
*0*perform ! FUNCdefinepropertyorthrow(VARobj, "callee", propertydescriptor { [[VALUE]]: VARfunc, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }). 
*0*(S perform/NN !/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` callee/NN ''/'' ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARfunc/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ }/) )/) ./.)
*0*return VARobj.     
*0*(S return/NN (Chunk VARobj/NNP) ./.)
ID= 9.4.4.7.1
Summary= MakeArgGetter ( name, env )
*0*let VARsteps be the steps of an arggetter function as specified below. 
*0*(S (Chunk let/VB VARsteps/NNP) be/VB the/DT steps/NNS of/IN an/DT arggetter/NN function/NN as/IN specified/VBN below/IN ./.)
*0*let VARgetter be FUNCcreatebuiltinfunction(VARsteps, « [[NAME]], [[ENV]] »). 
*0*(S (Chunk let/VB VARgetter/NNP) (Chunk be/VB FUNCcreatebuiltinfunction/NNP) (/( (Chunk VARsteps/NNP) ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk NAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ENV/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARgetter.[[NAME]] to VARname. 
*0*(S (Chunk set/VBN VARgetter/NNP) ./. [/CC [/JJ (Chunk NAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARname/NNP) ./.)
*0*set VARgetter.[[ENV]] to VARenv. 
*0*(S (Chunk set/VBN VARgetter/NNP) ./. [/VB [/JJ (Chunk ENV/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARenv/NNP) ./.)
*0*return VARgetter.      
*0*(S return/NN (Chunk VARgetter/NNP) ./.)
ID= 9.4.4.7.2
Summary= MakeArgSetter ( name, env )
*0*let VARsteps be the steps of an argsetter function as specified below. 
*0*(S (Chunk let/VB VARsteps/NNP) be/VB the/DT steps/NNS of/IN an/DT argsetter/NN function/NN as/IN specified/VBN below/IN ./.)
*0*let VARsetter be FUNCcreatebuiltinfunction(VARsteps, « [[NAME]], [[ENV]] »). 
*0*(S (Chunk let/VB VARsetter/NNP) (Chunk be/VB FUNCcreatebuiltinfunction/NNP) (/( (Chunk VARsteps/NNP) ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk NAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ENV/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARsetter.[[NAME]] to VARname. 
*0*(S (Chunk set/VBN VARsetter/NNP) ./. [/CC [/JJ (Chunk NAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARname/NNP) ./.)
*0*set VARsetter.[[ENV]] to VARenv. 
*0*(S (Chunk set/VBN VARsetter/NNP) ./. [/VB [/JJ (Chunk ENV/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARenv/NNP) ./.)
*0*return VARsetter.      
*0*(S return/NN (Chunk VARsetter/NNP) ./.)
ID= 9.4.5.1
Summary= [[GetOwnProperty]] ( P )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*assert: VARo is an object that has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*(S assert/NN :/: (Chunk VARo/NNP) is/VBZ an/DT object/NN that/WDT has/VBZ a/DT [/JJ [/NN (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*if FUNCtype(VARp) is string, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ string/VBG ,/, then/RB)
*1*let VARnumericindex be ! FUNCcanonicalnumericindexstring(VARp). 
*1*(S (Chunk let/VB VARnumericindex/NNP) be/VB !/. (Chunk FUNCcanonicalnumericindexstring/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*1*if VARnumericindex is not undefined, then
*1*(S if/IN (Chunk VARnumericindex/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*2*let VARvalue be ? FUNCintegerindexedelementget(VARo, VARnumericindex). 
*2*(S (Chunk let/VB VARvalue/NNP) be/VB ?/. (Chunk FUNCintegerindexedelementget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARnumericindex/NNP) )/) ./.)
*2*if VARvalue is undefined, return undefined. 
*2*(S if/IN (Chunk VARvalue/NNP) is/VBZ undefined/JJ ,/, return/NN undefined/VBD ./.)
*2*return a propertydescriptor { [[VALUE]]: VARvalue, [[WRITABLE]]: true, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: false }. 
*2*(S return/VB a/DT propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARvalue/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) ./.)
*0*return FUNCordinarygetownproperty(VARo, VARp).     
*0*(S return/NN (Chunk FUNCordinarygetownproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
ID= 9.4.5.2
Summary= [[HasProperty]] ( P )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*assert: VARo is an object that has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*(S assert/NN :/: (Chunk VARo/NNP) is/VBZ an/DT object/NN that/WDT has/VBZ a/DT [/JJ [/NN (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*if FUNCtype(VARp) is string, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ string/VBG ,/, then/RB)
*1*let VARnumericindex be ! FUNCcanonicalnumericindexstring(VARp). 
*1*(S (Chunk let/VB VARnumericindex/NNP) be/VB !/. (Chunk FUNCcanonicalnumericindexstring/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*1*if VARnumericindex is not undefined, then
*1*(S if/IN (Chunk VARnumericindex/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*2*let VARbuffer be VARo.[[VIEWEDARRAYBUFFER]]. 
*2*(S (Chunk let/VB VARbuffer/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*2*if FUNCisdetachedbuffer(VARbuffer) is true, throw a typeerror exception. 
*2*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARbuffer/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*2*if FUNCisinteger(VARnumericindex) is false, return false. 
*2*(S if/IN (Chunk FUNCisinteger/NNP) (/( (Chunk VARnumericindex/NNP) )/) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*2*if VARnumericindex = -0, return false. 
*2*(S if/IN (Chunk VARnumericindex/NNP) (Chunk =/NNP) (Chunk -0/NNP) ,/, return/NN false/JJ ./.)
*2*if VARnumericindex &lt; 0, return false. 
*2*(S if/IN (Chunk VARnumericindex/NNP) &/CC lt/NN ;/: 0/CD ,/, return/NN false/JJ ./.)
*2*if VARnumericindex ≥ VARo.[[ARRAYLENGTH]], return false. 
*2*(S if/IN (Chunk VARnumericindex/NNP) (Chunk ≥/NNP) (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, return/NN false/JJ ./.)
*2*return true. 
*2*(S return/NN true/JJ ./.)
*0*return ? FUNCordinaryhasproperty(VARo, VARp).     
*0*(S return/NN ?/. (Chunk FUNCordinaryhasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
ID= 9.4.5.3
Summary= [[DefineOwnProperty]] ( P, Desc )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*assert: VARo is an object that has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*(S assert/NN :/: (Chunk VARo/NNP) is/VBZ an/DT object/NN that/WDT has/VBZ a/DT [/JJ [/NN (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*if FUNCtype(VARp) is string, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ string/VBG ,/, then/RB)
*1*let VARnumericindex be ! FUNCcanonicalnumericindexstring(VARp). 
*1*(S (Chunk let/VB VARnumericindex/NNP) be/VB !/. (Chunk FUNCcanonicalnumericindexstring/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*1*if VARnumericindex is not undefined, then
*1*(S if/IN (Chunk VARnumericindex/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*2*if FUNCisinteger(VARnumericindex) is false, return false. 
*2*(S if/IN (Chunk FUNCisinteger/NNP) (/( (Chunk VARnumericindex/NNP) )/) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*2*if VARnumericindex = -0, return false. 
*2*(S if/IN (Chunk VARnumericindex/NNP) (Chunk =/NNP) (Chunk -0/NNP) ,/, return/NN false/JJ ./.)
*2*if VARnumericindex &lt; 0, return false. 
*2*(S if/IN (Chunk VARnumericindex/NNP) &/CC lt/NN ;/: 0/CD ,/, return/NN false/JJ ./.)
*2*let VARlength be VARo.[[ARRAYLENGTH]]. 
*2*(S (Chunk let/VB VARlength/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*2*if VARnumericindex ≥ VARlength, return false. 
*2*(S if/IN (Chunk VARnumericindex/NNP) (Chunk ≥/NNP) (Chunk VARlength/NNP) ,/, return/NN false/JJ ./.)
*2*if FUNCisaccessordescriptor(VARdesc) is true, return false. 
*2*(S if/IN (Chunk FUNCisaccessordescriptor/NNP) (/( (Chunk VARdesc/NNP) )/) is/VBZ true/JJ ,/, return/NN false/JJ ./.)
*2*if VARdesc has a [[CONFIGURABLE]] field and if VARdesc.[[CONFIGURABLE]] is true, return false. 
*2*(S if/IN (Chunk VARdesc/NNP) has/VBZ a/DT [/JJ [/NN (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN and/CC if/IN (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ true/JJ ,/, return/NN false/JJ ./.)
*2*if VARdesc has an [[ENUMERABLE]] field and if VARdesc.[[ENUMERABLE]] is false, return false. 
*2*(S if/IN (Chunk VARdesc/NNP) has/VBZ an/DT [/JJ [/NN (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN and/CC if/IN (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*2*if VARdesc has a [[WRITABLE]] field and if VARdesc.[[WRITABLE]] is false, return false. 
*2*(S if/IN (Chunk VARdesc/NNP) has/VBZ a/DT [/JJ [/NN (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN and/CC if/IN (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*2*if VARdesc has a [[VALUE]] field, then
*2*(S if/IN (Chunk VARdesc/NNP) has/VBZ a/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN ,/, then/RB)
*3*let VARvalue be VARdesc.[[VALUE]]. 
*3*(S (Chunk let/VB VARvalue/NNP) (Chunk be/VB VARdesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*3*return ? FUNCintegerindexedelementset(VARo, VARnumericindex, VARvalue). 
*3*(S return/NN ?/. (Chunk FUNCintegerindexedelementset/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARnumericindex/NNP) ,/, (Chunk VARvalue/NNP) )/) ./.)
*2*return true. 
*2*(S return/NN true/JJ ./.)
*0*return ! FUNCordinarydefineownproperty(VARo, VARp, VARdesc).     
*0*(S return/NN !/. (Chunk FUNCordinarydefineownproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARdesc/NNP) )/) ./.)
ID= 9.4.5.4
Summary= [[Get]] ( P, Receiver )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*if FUNCtype(VARp) is string, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ string/VBG ,/, then/RB)
*1*let VARnumericindex be ! FUNCcanonicalnumericindexstring(VARp). 
*1*(S (Chunk let/VB VARnumericindex/NNP) be/VB !/. (Chunk FUNCcanonicalnumericindexstring/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*1*if VARnumericindex is not undefined, then
*1*(S if/IN (Chunk VARnumericindex/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*2*return ? FUNCintegerindexedelementget(VARo, VARnumericindex). 
*2*(S return/NN ?/. (Chunk FUNCintegerindexedelementget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARnumericindex/NNP) )/) ./.)
*0*return ? FUNCordinaryget(VARo, VARp, VARreceiver).     
*0*(S return/NN ?/. (Chunk FUNCordinaryget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARreceiver/NNP) )/) ./.)
ID= 9.4.5.5
Summary= [[Set]] ( P, V, Receiver )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*if FUNCtype(VARp) is string, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ string/VBG ,/, then/RB)
*1*let VARnumericindex be ! FUNCcanonicalnumericindexstring(VARp). 
*1*(S (Chunk let/VB VARnumericindex/NNP) be/VB !/. (Chunk FUNCcanonicalnumericindexstring/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*1*if VARnumericindex is not undefined, then
*1*(S if/IN (Chunk VARnumericindex/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*2*return ? FUNCintegerindexedelementset(VARo, VARnumericindex, VARv). 
*2*(S return/NN ?/. (Chunk FUNCintegerindexedelementset/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARnumericindex/NNP) ,/, (Chunk VARv/NNP) )/) ./.)
*0*return ? FUNCordinaryset(VARo, VARp, VARv, VARreceiver).     
*0*(S return/NN ?/. (Chunk FUNCordinaryset/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARv/NNP) ,/, (Chunk VARreceiver/NNP) )/) ./.)
ID= 9.4.5.6
Summary= [[OwnPropertyKeys]] ( )
*0*let VARkeys be a new empty list. 
*0*(S (Chunk let/VB VARkeys/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*assert: VARo is an object that has [[VIEWEDARRAYBUFFER]], [[ARRAYLENGTH]], [[BYTEOFFSET]], and [[TYPEDARRAYNAME]] internal slots. 
*0*(S assert/NN :/: (Chunk VARo/NNP) is/VBZ an/DT object/NN that/WDT (Chunk has/VBZ [/VBN [/NNP) (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, and/CC (Chunk [/NNP) (Chunk [/NNP) (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slots/NNS ./.)
*0*let VARlen be VARo.[[ARRAYLENGTH]]. 
*0*(S (Chunk let/VB VARlen/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*for each integer VARi starting with 0 such that VARi &lt; VARlen, in ascending order, do
*0*(S for/IN each/DT integer/NN (Chunk VARi/NNP) starting/VBG with/IN 0/CD such/JJ that/IN (Chunk VARi/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP) ,/, in/IN ascending/VBG order/NN ,/, do/VBP)
*1*add ! FUNCtostring(VARi) as the last element of VARkeys. 
*1*(S add/NN !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARi/NNP) )/) as/IN the/DT last/JJ element/NN of/IN (Chunk VARkeys/NNP) ./.)
*0*for each own property key VARp of VARo such that FUNCtype(VARp) is string and VARp is not an integer index, in ascending chronological order of property creation, do
*0*(S for/IN each/DT own/JJ property/NN key/JJ (Chunk VARp/NNP) of/IN (Chunk VARo/NNP) such/JJ that/IN (Chunk FUNCtype/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ string/VBG and/CC (Chunk VARp/NNP) is/VBZ not/RB an/DT integer/NN index/NN ,/, in/IN ascending/VBG chronological/JJ order/NN of/IN property/NN creation/NN ,/, do/VBP)
*1*add VARp as the last element of VARkeys. 
*1*(S (Chunk add/RB VARp/NNP) as/IN the/DT last/JJ element/NN of/IN (Chunk VARkeys/NNP) ./.)
*0*for each own property key VARp of VARo such that FUNCtype(VARp) is symbol, in ascending chronological order of property creation, do
*0*(S for/IN each/DT own/JJ property/NN key/JJ (Chunk VARp/NNP) of/IN (Chunk VARo/NNP) such/JJ that/IN (Chunk FUNCtype/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ symbol/JJ ,/, in/IN ascending/VBG chronological/JJ order/NN of/IN property/NN creation/NN ,/, do/VBP)
*1*add VARp as the last element of VARkeys. 
*1*(S (Chunk add/RB VARp/NNP) as/IN the/DT last/JJ element/NN of/IN (Chunk VARkeys/NNP) ./.)
*0*return VARkeys.     
*0*(S return/NN (Chunk VARkeys/NNP) ./.)
ID= 9.4.5.7
Summary= IntegerIndexedObjectCreate ( prototype, internalSlotsList )
*0*assert: VARinternalslotslist contains the names [[VIEWEDARRAYBUFFER]], [[ARRAYLENGTH]], [[BYTEOFFSET]], and [[TYPEDARRAYNAME]]. 
*0*(S assert/NN :/: VARinternalslotslist/NN contains/VBZ the/DT names/NNS (Chunk [/VBP [/NNP) (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, and/CC (Chunk [/NNP) (Chunk [/NNP) (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARa be a newly created object with an internal slot for each name in VARinternalslotslist. 
*0*(S (Chunk let/VB VARa/NNP) be/VB a/DT newly/RB created/VBN object/NN with/IN an/DT internal/JJ slot/NN for/IN each/DT name/NN in/IN (Chunk VARinternalslotslist/NNP) ./.)
*0*set VARa's essential internal methods to the default ordinary object definitions specified in 9.1. 
*0*(S (Chunk set/VBN VARa/NNP) 's/POS essential/JJ internal/JJ methods/NNS to/TO the/DT default/NN ordinary/JJ object/JJ definitions/NNS specified/VBN in/IN 9.1/CD ./.)
*0*set VARa.[[GETOWNPROPERTY]] as specified in 9.4.5.1. 
*0*(S (Chunk set/VBN VARa/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) as/IN specified/VBN in/IN 9.4.5.1/CD ./.)
*0*set VARa.[[HASPROPERTY]] as specified in 9.4.5.2. 
*0*(S (Chunk set/VBN VARa/NNP) ./. (Chunk [/VB [/NNP) (Chunk HASPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) as/IN specified/VBN in/IN 9.4.5.2/CD ./.)
*0*set VARa.[[DEFINEOWNPROPERTY]] as specified in 9.4.5.3. 
*0*(S (Chunk set/VBN VARa/NNP) ./. (Chunk [/VB [/NNP) (Chunk DEFINEOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) as/IN specified/VBN in/IN 9.4.5.3/CD ./.)
*0*set VARa.[[GET]] as specified in 9.4.5.4. 
*0*(S (Chunk set/VBN VARa/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) as/IN specified/VBN in/IN 9.4.5.4/CD ./.)
*0*set VARa.[[SET]] as specified in 9.4.5.5. 
*0*(S (Chunk set/VBN VARa/NNP) ./. [/NN [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) as/IN specified/VBN in/IN 9.4.5.5/CD ./.)
*0*set VARa.[[OWNPROPERTYKEYS]] as specified in 9.4.5.6. 
*0*(S (Chunk set/VBN VARa/NNP) ./. [/VB [/JJ (Chunk OWNPROPERTYKEYS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) as/IN specified/VBN in/IN 9.4.5.6/CD ./.)
*0*set VARa.[[PROTOTYPE]] to VARprototype. 
*0*(S (Chunk set/VBN VARa/NNP) ./. [/VB [/JJ (Chunk PROTOTYPE/NNP) ]/NN ]/NN to/TO (Chunk VARprototype/NNP) ./.)
*0*set VARa.[[EXTENSIBLE]] to true. 
*0*(S (Chunk set/VBN VARa/NNP) ./. [/VB [/JJ (Chunk EXTENSIBLE/NNP) ]/NN ]/NN to/TO true/JJ ./.)
*0*return VARa.     
*0*(S return/NN (Chunk VARa/NNP) ./.)
ID= 9.4.5.8
Summary= IntegerIndexedElementGet ( O, index )
*0*assert: FUNCtype(VARindex) is number. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARindex/NNP) )/) is/VBZ number/NN ./.)
*0*assert: VARo is an object that has [[VIEWEDARRAYBUFFER]], [[ARRAYLENGTH]], [[BYTEOFFSET]], and [[TYPEDARRAYNAME]] internal slots. 
*0*(S assert/NN :/: (Chunk VARo/NNP) is/VBZ an/DT object/NN that/WDT (Chunk has/VBZ [/VBN [/NNP) (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, and/CC (Chunk [/NNP) (Chunk [/NNP) (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slots/NNS ./.)
*0*let VARbuffer be VARo.[[VIEWEDARRAYBUFFER]]. 
*0*(S (Chunk let/VB VARbuffer/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if FUNCisdetachedbuffer(VARbuffer) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARbuffer/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if FUNCisinteger(VARindex) is false, return undefined. 
*0*(S if/IN (Chunk FUNCisinteger/NNP) (/( (Chunk VARindex/NNP) )/) is/VBZ false/JJ ,/, return/NN undefined/VBD ./.)
*0*if VARindex = -0, return undefined. 
*0*(S if/IN (Chunk VARindex/NNP) (Chunk =/NNP) (Chunk -0/NNP) ,/, return/NN undefined/VBD ./.)
*0*let VARlength be VARo.[[ARRAYLENGTH]]. 
*0*(S (Chunk let/VB VARlength/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARindex &lt; 0 or VARindex ≥ VARlength, return undefined. 
*0*(S if/IN (Chunk VARindex/NNP) &/CC lt/NN ;/: 0/CD or/CC (Chunk VARindex/NNP) (Chunk ≥/NNP) (Chunk VARlength/NNP) ,/, return/NN undefined/VBD ./.)
*0*let VARoffset be VARo.[[BYTEOFFSET]]. 
*0*(S (Chunk let/VB VARoffset/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARarraytypename be the string value of VARo.[[TYPEDARRAYNAME]]. 
*0*(S (Chunk let/VB VARarraytypename/NNP) be/VB the/DT string/VBG value/NN of/IN (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARelementsize be the number value of the element size value specified in table 56 for VARarraytypename. 
*0*(S (Chunk let/VB VARelementsize/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN (Chunk VARarraytypename/NNP) ./.)
*0*let VARindexedposition be (VARindex × VARelementsize) + VARoffset. 
*0*(S (Chunk let/VB VARindexedposition/NNP) be/VB (/( (Chunk VARindex/NNP) (Chunk ×/NNP) (Chunk VARelementsize/NNP) )/) +/NN (Chunk VARoffset/NNP) ./.)
*0*let VARelementtype be the string value of the element type value in table 56 for VARarraytypename. 
*0*(S (Chunk let/VB VARelementtype/NNP) be/VB the/DT string/VBG value/NN of/IN the/DT element/NN type/NN value/NN in/IN table/JJ 56/CD for/IN (Chunk VARarraytypename/NNP) ./.)
*0*return FUNCgetvaluefrombuffer(VARbuffer, VARindexedposition, VARelementtype, true, "unordered").     
*0*(S return/NN (Chunk FUNCgetvaluefrombuffer/NNP) (/( (Chunk VARbuffer/NNP) ,/, (Chunk VARindexedposition/NNP) ,/, (Chunk VARelementtype/NNP) ,/, true/JJ ,/, ``/`` unordered/JJ ''/'' )/) ./.)
ID= 9.4.5.9
Summary= IntegerIndexedElementSet ( O, index, value )
*0*assert: FUNCtype(VARindex) is number. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARindex/NNP) )/) is/VBZ number/NN ./.)
*0*assert: VARo is an object that has [[VIEWEDARRAYBUFFER]], [[ARRAYLENGTH]], [[BYTEOFFSET]], and [[TYPEDARRAYNAME]] internal slots. 
*0*(S assert/NN :/: (Chunk VARo/NNP) is/VBZ an/DT object/NN that/WDT (Chunk has/VBZ [/VBN [/NNP) (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, and/CC (Chunk [/NNP) (Chunk [/NNP) (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slots/NNS ./.)
*0*let VARnumvalue be ? FUNCtonumber(VARvalue). 
*0*(S (Chunk let/VB VARnumvalue/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*0*let VARbuffer be VARo.[[VIEWEDARRAYBUFFER]]. 
*0*(S (Chunk let/VB VARbuffer/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if FUNCisdetachedbuffer(VARbuffer) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARbuffer/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if FUNCisinteger(VARindex) is false, return false. 
*0*(S if/IN (Chunk FUNCisinteger/NNP) (/( (Chunk VARindex/NNP) )/) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*0*if VARindex = -0, return false. 
*0*(S if/IN (Chunk VARindex/NNP) (Chunk =/NNP) (Chunk -0/NNP) ,/, return/NN false/JJ ./.)
*0*let VARlength be VARo.[[ARRAYLENGTH]]. 
*0*(S (Chunk let/VB VARlength/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARindex &lt; 0 or VARindex ≥ VARlength, return false. 
*0*(S if/IN (Chunk VARindex/NNP) &/CC lt/NN ;/: 0/CD or/CC (Chunk VARindex/NNP) (Chunk ≥/NNP) (Chunk VARlength/NNP) ,/, return/NN false/JJ ./.)
*0*let VARoffset be VARo.[[BYTEOFFSET]]. 
*0*(S (Chunk let/VB VARoffset/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARarraytypename be the string value of VARo.[[TYPEDARRAYNAME]]. 
*0*(S (Chunk let/VB VARarraytypename/NNP) be/VB the/DT string/VBG value/NN of/IN (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARelementsize be the number value of the element size value specified in table 56 for VARarraytypename. 
*0*(S (Chunk let/VB VARelementsize/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN (Chunk VARarraytypename/NNP) ./.)
*0*let VARindexedposition be (VARindex × VARelementsize) + VARoffset. 
*0*(S (Chunk let/VB VARindexedposition/NNP) be/VB (/( (Chunk VARindex/NNP) (Chunk ×/NNP) (Chunk VARelementsize/NNP) )/) +/NN (Chunk VARoffset/NNP) ./.)
*0*let VARelementtype be the string value of the element type value in table 56 for VARarraytypename. 
*0*(S (Chunk let/VB VARelementtype/NNP) be/VB the/DT string/VBG value/NN of/IN the/DT element/NN type/NN value/NN in/IN table/JJ 56/CD for/IN (Chunk VARarraytypename/NNP) ./.)
*0*perform FUNCsetvalueinbuffer(VARbuffer, VARindexedposition, VARelementtype, VARnumvalue, true, "unordered"). 
*0*(S perform/NN (Chunk FUNCsetvalueinbuffer/NNP) (/( (Chunk VARbuffer/NNP) ,/, (Chunk VARindexedposition/NNP) ,/, (Chunk VARelementtype/NNP) ,/, (Chunk VARnumvalue/NNP) ,/, true/JJ ,/, ``/`` unordered/JJ ''/'' )/) ./.)
*0*return true.     
*0*(S return/NN true/JJ ./.)
ID= 9.4.6.1
Summary= [[SetPrototypeOf]] ( V )
*0*return ? FUNCsetimmutableprototype(VARo, VARv).     
*0*(S return/NN ?/. (Chunk FUNCsetimmutableprototype/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARv/NNP) )/) ./.)
ID= 9.4.6.2
Summary= [[IsExtensible]] ( )
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 9.4.6.3
Summary= [[PreventExtensions]] ( )
*0*return true.     
*0*(S return/NN true/JJ ./.)
ID= 9.4.6.4
Summary= [[GetOwnProperty]] ( P )
*0*if FUNCtype(VARp) is symbol, return FUNCordinarygetownproperty(VARo, VARp). 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ symbol/JJ ,/, (Chunk return/VB FUNCordinarygetownproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
*0*let VARexports be VARo.[[EXPORTS]]. 
*0*(S (Chunk let/VB VARexports/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk EXPORTS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARp is not an element of VARexports, return undefined. 
*0*(S if/IN (Chunk VARp/NNP) is/VBZ not/RB an/DT element/NN of/IN (Chunk VARexports/NNP) ,/, return/NN undefined/VBD ./.)
*0*let VARvalue be ? VARo.[[GET]](VARp, VARo). 
*0*(S (Chunk let/VB VARvalue/NNP) be/VB ?/. (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) ,/, (Chunk VARo/NNP) )/) ./.)
*0*return propertydescriptor { [[VALUE]]: VARvalue, [[WRITABLE]]: true, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: false }.     
*0*(S return/NN propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARvalue/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) ./.)
ID= 9.4.6.5
Summary= [[DefineOwnProperty]] ( P, Desc )
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 9.4.6.6
Summary= [[HasProperty]] ( P )
*0*if FUNCtype(VARp) is symbol, return FUNCordinaryhasproperty(VARo, VARp). 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ symbol/JJ ,/, (Chunk return/VB FUNCordinaryhasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
*0*let VARexports be VARo.[[EXPORTS]]. 
*0*(S (Chunk let/VB VARexports/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk EXPORTS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARp is an element of VARexports, return true. 
*0*(S if/IN (Chunk VARp/NNP) is/VBZ an/DT element/NN of/IN (Chunk VARexports/NNP) ,/, return/NN true/JJ ./.)
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 9.4.6.7
Summary= [[Get]] ( P, Receiver )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*if FUNCtype(VARp) is symbol, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ symbol/NN ,/, then/RB)
*1*return ? FUNCordinaryget(VARo, VARp, VARreceiver). 
*1*(S return/NN ?/. (Chunk FUNCordinaryget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARreceiver/NNP) )/) ./.)
*0*let VARexports be VARo.[[EXPORTS]]. 
*0*(S (Chunk let/VB VARexports/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk EXPORTS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARp is not an element of VARexports, return undefined. 
*0*(S if/IN (Chunk VARp/NNP) is/VBZ not/RB an/DT element/NN of/IN (Chunk VARexports/NNP) ,/, return/NN undefined/VBD ./.)
*0*let VARm be VARo.[[MODULE]]. 
*0*(S (Chunk let/VB VARm/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk MODULE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARbinding be ! VARm.resolveexport(VARp, « »). 
*0*(S (Chunk let/VB VARbinding/NNP) be/VB !/. (Chunk VARm.resolveexport/NNP) (/( (Chunk VARp/NNP) ,/, (Chunk «/NNP) (Chunk »/NNP) )/) ./.)
*0*assert: VARbinding is a resolvedbinding record. 
*0*(S assert/NN :/: VARbinding/NN is/VBZ a/DT resolvedbinding/NN record/NN ./.)
*0*let VARtargetmodule be VARbinding.[[MODULE]]. 
*0*(S (Chunk let/VB VARtargetmodule/NNP) (Chunk be/VB VARbinding/NNP) ./. [/VB [/JJ (Chunk MODULE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*assert: VARtargetmodule is not undefined. 
*0*(S assert/NN :/: VARtargetmodule/NN is/VBZ not/RB undefined/JJ ./.)
*0*let VARtargetenv be VARtargetmodule.[[ENVIRONMENT]]. 
*0*(S (Chunk let/VB VARtargetenv/NNP) (Chunk be/VB VARtargetmodule/NNP) ./. [/VB [/JJ (Chunk ENVIRONMENT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARtargetenv is undefined, throw a referenceerror exception. 
*0*(S if/IN (Chunk VARtargetenv/NNP) is/VBZ undefined/JJ ,/, throw/VB a/DT referenceerror/NN exception/NN ./.)
*0*let VARtargetenvrec be VARtargetenv's environmentrecord. 
*0*(S (Chunk let/VB VARtargetenvrec/NNP) (Chunk be/VB VARtargetenv/NNP) 's/POS environmentrecord/NN ./.)
*0*return ? VARtargetenvrec.getbindingvalue(VARbinding.[[BINDINGNAME]], true).     
*0*(S return/NN ?/. (Chunk VARtargetenvrec.getbindingvalue/NNP) (/( (Chunk VARbinding/NNP) ./. [/VB [/JJ (Chunk BINDINGNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, true/JJ )/) ./.)
ID= 9.4.6.8
Summary= [[Set]] ( P, V, Receiver )
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 9.4.6.9
Summary= [[Delete]] ( P )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*if FUNCtype(VARp) is symbol, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ symbol/NN ,/, then/RB)
*1*return ? FUNCordinarydelete(VARo, VARp). 
*1*(S return/NN ?/. (Chunk FUNCordinarydelete/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
*0*let VARexports be VARo.[[EXPORTS]]. 
*0*(S (Chunk let/VB VARexports/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk EXPORTS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARp is an element of VARexports, return false. 
*0*(S if/IN (Chunk VARp/NNP) is/VBZ an/DT element/NN of/IN (Chunk VARexports/NNP) ,/, return/NN false/JJ ./.)
*0*return true.     
*0*(S return/NN true/JJ ./.)
ID= 9.4.6.10
Summary= [[OwnPropertyKeys]] ( )
*0*let VARexports be a copy of VARo.[[EXPORTS]]. 
*0*(S (Chunk let/VB VARexports/NNP) be/VB a/DT copy/NN of/IN (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk EXPORTS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARsymbolkeys be ! FUNCordinaryownpropertykeys(VARo). 
*0*(S (Chunk let/VB VARsymbolkeys/NNP) be/VB !/. (Chunk FUNCordinaryownpropertykeys/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*append all the entries of VARsymbolkeys to the end of VARexports. 
*0*(S append/VB all/PDT the/DT entries/NNS of/IN (Chunk VARsymbolkeys/NNP) to/TO the/DT end/NN of/IN VARexports/NNS ./.)
*0*return VARexports.     
*0*(S return/NN VARexports/NNS ./.)
ID= 9.4.6.11
Summary= ModuleNamespaceCreate ( module, exports )
*0*assert: VARmodule is a module record. 
*0*(S assert/NN :/: VARmodule/NN is/VBZ a/DT module/NN record/NN ./.)
*0*assert: VARmodule.[[NAMESPACE]] is undefined. 
*0*(S assert/NN :/: VARmodule/NN ./. [/CC [/JJ (Chunk NAMESPACE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ undefined/VBN ./.)
*0*assert: VARexports is a list of string values. 
*0*(S assert/NN :/: VARexports/NNS is/VBZ a/DT list/NN of/IN string/VBG values/NNS ./.)
*0*let VARm be a newly created object. 
*0*(S (Chunk let/VB VARm/NNP) be/VB a/DT newly/RB created/VBN object/NN ./.)
*0*set VARm's essential internal methods to the definitions specified in 9.4.6. 
*0*(S (Chunk set/VBN VARm/NNP) 's/POS essential/JJ internal/JJ methods/NNS to/TO the/DT definitions/NNS specified/VBN in/IN 9.4.6/CD ./.)
*0*set VARm.[[MODULE]] to VARmodule. 
*0*(S (Chunk set/VBN VARm/NNP) ./. [/VB [/JJ (Chunk MODULE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARmodule/NNP) ./.)
*0*let VARsortedexports be a new list containing the same values as the list VARexports where the values are ordered as if an array of the same values had been sorted using array.prototype.sort using undefined as VARcomparefn. 
*0*(S (Chunk let/VB VARsortedexports/NNP) be/VB a/DT new/JJ list/NN containing/VBG the/DT same/JJ values/NNS as/IN the/DT list/NN (Chunk VARexports/NNP) where/WRB the/DT values/NNS are/VBP ordered/VBN as/IN if/IN an/DT array/NN of/IN the/DT same/JJ values/NNS had/VBD been/VBN sorted/VBN using/VBG array.prototype.sort/NN using/VBG undefined/JJ as/IN (Chunk VARcomparefn/NNP) ./.)
*0*set VARm.[[EXPORTS]] to VARsortedexports. 
*0*(S (Chunk set/VBN VARm/NNP) ./. [/VB [/JJ (Chunk EXPORTS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARsortedexports/NNP) ./.)
*0*create own properties of VARm corresponding to the definitions in 26.3. 
*0*(S create/NN own/JJ properties/NNS of/IN (Chunk VARm/NNP) corresponding/VBG to/TO the/DT definitions/NNS in/IN 26.3/CD ./.)
*0*set VARmodule.[[NAMESPACE]] to VARm. 
*0*(S (Chunk set/VBN VARmodule/NNP) ./. [/VB [/JJ (Chunk NAMESPACE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARm/NNP) ./.)
*0*return VARm.     
*0*(S return/NN (Chunk VARm/NNP) ./.)
ID= 9.4.7.1
Summary= [[SetPrototypeOf]] ( V )
*0*return ? FUNCsetimmutableprototype(VARo, VARv).     
*0*(S return/NN ?/. (Chunk FUNCsetimmutableprototype/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARv/NNP) )/) ./.)
ID= 9.4.7.2
Summary= SetImmutablePrototype ( O, V )
*0*assert: either FUNCtype(VARv) is object or FUNCtype(VARv) is null. 
*0*(S assert/NN :/: either/CC (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ object/JJ or/CC (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ null/JJ ./.)
*0*let VARcurrent be ? VARo.[[GETPROTOTYPEOF]](). 
*0*(S (Chunk let/VB VARcurrent/NNP) be/VB ?/. (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk GETPROTOTYPEOF/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*0*if FUNCsamevalue(VARv, VARcurrent) is true, return true. 
*0*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARcurrent/NNP) )/) is/VBZ true/JJ ,/, return/VB true/JJ ./.)
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 9.5.1
Summary= [[GetPrototypeOf]] ( )
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*(S (Chunk let/VB VARhandler/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYHANDLER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARhandler is null, throw a typeerror exception. 
*0*(S if/IN (Chunk VARhandler/NNP) is/VBZ null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: FUNCtype(VARhandler) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARhandler/NNP) )/) is/VBZ object/JJ ./.)
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*(S (Chunk let/VB VARtarget/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYTARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "getprototypeof"). 
*0*(S (Chunk let/VB VARtrap/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARhandler/NNP) ,/, ``/`` getprototypeof/NN ''/'' )/) ./.)
*0*if VARtrap is undefined, then
*0*(S if/IN (Chunk VARtrap/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*return ? VARtarget.[[GETPROTOTYPEOF]](). 
*1*(S return/NN ?/. (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk GETPROTOTYPEOF/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*0*let VARhandlerproto be ? FUNCcall(VARtrap, VARhandler, « VARtarget »). 
*0*(S (Chunk let/VB VARhandlerproto/NNP) be/VB ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARtrap/NNP) ,/, (Chunk VARhandler/NNP) ,/, (Chunk «/NNP) (Chunk VARtarget/NNP) (Chunk »/NNP) )/) ./.)
*0*if FUNCtype(VARhandlerproto) is neither object nor null, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARhandlerproto/NNP) )/) is/VBZ neither/DT object/JJ nor/CC null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARextensibletarget be ? FUNCisextensible(VARtarget). 
*0*(S (Chunk let/VB VARextensibletarget/NNP) be/VB ?/. (Chunk FUNCisextensible/NNP) (/( (Chunk VARtarget/NNP) )/) ./.)
*0*if VARextensibletarget is true, return VARhandlerproto. 
*0*(S if/IN (Chunk VARextensibletarget/NNP) is/VBZ true/JJ ,/, return/JJ (Chunk VARhandlerproto/NNP) ./.)
*0*let VARtargetproto be ? VARtarget.[[GETPROTOTYPEOF]](). 
*0*(S (Chunk let/VB VARtargetproto/NNP) be/VB ?/. (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk GETPROTOTYPEOF/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*0*if FUNCsamevalue(VARhandlerproto, VARtargetproto) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARhandlerproto/NNP) ,/, (Chunk VARtargetproto/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARhandlerproto.    
*0*(S return/NN (Chunk VARhandlerproto/NNP) ./.)
ID= 9.5.2
Summary= [[SetPrototypeOf]] ( V )
*0*assert: either FUNCtype(VARv) is object or FUNCtype(VARv) is null. 
*0*(S assert/NN :/: either/CC (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ object/JJ or/CC (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ null/JJ ./.)
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*(S (Chunk let/VB VARhandler/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYHANDLER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARhandler is null, throw a typeerror exception. 
*0*(S if/IN (Chunk VARhandler/NNP) is/VBZ null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: FUNCtype(VARhandler) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARhandler/NNP) )/) is/VBZ object/JJ ./.)
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*(S (Chunk let/VB VARtarget/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYTARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "setprototypeof"). 
*0*(S (Chunk let/VB VARtrap/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARhandler/NNP) ,/, ``/`` setprototypeof/NN ''/'' )/) ./.)
*0*if VARtrap is undefined, then
*0*(S if/IN (Chunk VARtrap/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*return ? VARtarget.[[SETPROTOTYPEOF]](VARv). 
*1*(S return/NN ?/. (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk SETPROTOTYPEOF/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARv/NNP) )/) ./.)
*0*let VARbooleantrapresult be FUNCtoboolean(? FUNCcall(VARtrap, VARhandler, « VARtarget, VARv »)). 
*0*(S (Chunk let/VB VARbooleantrapresult/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARtrap/NNP) ,/, (Chunk VARhandler/NNP) ,/, (Chunk «/NNP) (Chunk VARtarget/NNP) ,/, (Chunk VARv/NNP) (Chunk »/NNP) )/) )/) ./.)
*0*if VARbooleantrapresult is false, return false. 
*0*(S if/IN (Chunk VARbooleantrapresult/NNP) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*0*let VARextensibletarget be ? FUNCisextensible(VARtarget). 
*0*(S (Chunk let/VB VARextensibletarget/NNP) be/VB ?/. (Chunk FUNCisextensible/NNP) (/( (Chunk VARtarget/NNP) )/) ./.)
*0*if VARextensibletarget is true, return true. 
*0*(S if/IN (Chunk VARextensibletarget/NNP) is/VBZ true/JJ ,/, return/VB true/JJ ./.)
*0*let VARtargetproto be ? VARtarget.[[GETPROTOTYPEOF]](). 
*0*(S (Chunk let/VB VARtargetproto/NNP) be/VB ?/. (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk GETPROTOTYPEOF/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*0*if FUNCsamevalue(VARv, VARtargetproto) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARtargetproto/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return true.    
*0*(S return/NN true/JJ ./.)
ID= 9.5.3
Summary= [[IsExtensible]] ( )
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*(S (Chunk let/VB VARhandler/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYHANDLER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARhandler is null, throw a typeerror exception. 
*0*(S if/IN (Chunk VARhandler/NNP) is/VBZ null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: FUNCtype(VARhandler) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARhandler/NNP) )/) is/VBZ object/JJ ./.)
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*(S (Chunk let/VB VARtarget/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYTARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "isextensible"). 
*0*(S (Chunk let/VB VARtrap/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARhandler/NNP) ,/, ``/`` isextensible/JJ ''/'' )/) ./.)
*0*if VARtrap is undefined, then
*0*(S if/IN (Chunk VARtrap/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*return ? VARtarget.[[ISEXTENSIBLE]](). 
*1*(S return/NN ?/. (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk ISEXTENSIBLE/NNP) ]/NN (Chunk ]/NNP) (/( )/) ./.)
*0*let VARbooleantrapresult be FUNCtoboolean(? FUNCcall(VARtrap, VARhandler, « VARtarget »)). 
*0*(S (Chunk let/VB VARbooleantrapresult/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARtrap/NNP) ,/, (Chunk VARhandler/NNP) ,/, (Chunk «/NNP) (Chunk VARtarget/NNP) (Chunk »/NNP) )/) )/) ./.)
*0*let VARtargetresult be ? VARtarget.[[ISEXTENSIBLE]](). 
*0*(S (Chunk let/VB VARtargetresult/NNP) be/VB ?/. (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk ISEXTENSIBLE/NNP) ]/NN (Chunk ]/NNP) (/( )/) ./.)
*0*if FUNCsamevalue(VARbooleantrapresult, VARtargetresult) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARbooleantrapresult/NNP) ,/, (Chunk VARtargetresult/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARbooleantrapresult.    
*0*(S return/NN (Chunk VARbooleantrapresult/NNP) ./.)
ID= 9.5.4
Summary= [[PreventExtensions]] ( )
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*(S (Chunk let/VB VARhandler/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYHANDLER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARhandler is null, throw a typeerror exception. 
*0*(S if/IN (Chunk VARhandler/NNP) is/VBZ null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: FUNCtype(VARhandler) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARhandler/NNP) )/) is/VBZ object/JJ ./.)
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*(S (Chunk let/VB VARtarget/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYTARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "preventextensions"). 
*0*(S (Chunk let/VB VARtrap/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARhandler/NNP) ,/, ``/`` preventextensions/NNS ''/'' )/) ./.)
*0*if VARtrap is undefined, then
*0*(S if/IN (Chunk VARtrap/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*return ? VARtarget.[[PREVENTEXTENSIONS]](). 
*1*(S return/NN ?/. (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk PREVENTEXTENSIONS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*0*let VARbooleantrapresult be FUNCtoboolean(? FUNCcall(VARtrap, VARhandler, « VARtarget »)). 
*0*(S (Chunk let/VB VARbooleantrapresult/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARtrap/NNP) ,/, (Chunk VARhandler/NNP) ,/, (Chunk «/NNP) (Chunk VARtarget/NNP) (Chunk »/NNP) )/) )/) ./.)
*0*if VARbooleantrapresult is true, then
*0*(S if/IN (Chunk VARbooleantrapresult/NNP) is/VBZ true/JJ ,/, then/RB)
*1*let VARtargetisextensible be ? VARtarget.[[ISEXTENSIBLE]](). 
*1*(S let/VB VARtargetisextensible/JJ be/VB ?/. (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk ISEXTENSIBLE/NNP) ]/NN (Chunk ]/NNP) (/( )/) ./.)
*1*if VARtargetisextensible is true, throw a typeerror exception. 
*1*(S if/IN (Chunk VARtargetisextensible/NNP) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARbooleantrapresult.    
*0*(S return/NN (Chunk VARbooleantrapresult/NNP) ./.)
ID= 9.5.5
Summary= [[GetOwnProperty]] ( P )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*(S (Chunk let/VB VARhandler/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYHANDLER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARhandler is null, throw a typeerror exception. 
*0*(S if/IN (Chunk VARhandler/NNP) is/VBZ null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: FUNCtype(VARhandler) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARhandler/NNP) )/) is/VBZ object/JJ ./.)
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*(S (Chunk let/VB VARtarget/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYTARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "getownpropertydescriptor"). 
*0*(S (Chunk let/VB VARtrap/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARhandler/NNP) ,/, ``/`` getownpropertydescriptor/NN ''/'' )/) ./.)
*0*if VARtrap is undefined, then
*0*(S if/IN (Chunk VARtrap/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*return ? VARtarget.[[GETOWNPROPERTY]](VARp). 
*1*(S return/NN ?/. (Chunk VARtarget/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*let VARtrapresultobj be ? FUNCcall(VARtrap, VARhandler, « VARtarget, VARp »). 
*0*(S (Chunk let/VB VARtrapresultobj/NNP) be/VB ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARtrap/NNP) ,/, (Chunk VARhandler/NNP) ,/, (Chunk «/NNP) (Chunk VARtarget/NNP) ,/, (Chunk VARp/NNP) (Chunk »/NNP) )/) ./.)
*0*if FUNCtype(VARtrapresultobj) is neither object nor undefined, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtrapresultobj/NNP) )/) is/VBZ neither/DT object/JJ nor/CC undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARtargetdesc be ? VARtarget.[[GETOWNPROPERTY]](VARp). 
*0*(S (Chunk let/VB VARtargetdesc/NNP) be/VB ?/. (Chunk VARtarget/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*if VARtrapresultobj is undefined, then
*0*(S if/IN (Chunk VARtrapresultobj/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*if VARtargetdesc is undefined, return undefined. 
*1*(S if/IN (Chunk VARtargetdesc/NNP) is/VBZ undefined/JJ ,/, return/NN undefined/VBD ./.)
*1*if VARtargetdesc.[[CONFIGURABLE]] is false, throw a typeerror exception. 
*1*(S if/IN (Chunk VARtargetdesc/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*let VARextensibletarget be ? FUNCisextensible(VARtarget). 
*1*(S (Chunk let/VB VARextensibletarget/NNP) be/VB ?/. (Chunk FUNCisextensible/NNP) (/( (Chunk VARtarget/NNP) )/) ./.)
*1*assert: FUNCtype(VARextensibletarget) is boolean. 
*1*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARextensibletarget/NNP) )/) is/VBZ boolean/JJ ./.)
*1*if VARextensibletarget is false, throw a typeerror exception. 
*1*(S if/IN (Chunk VARextensibletarget/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*return undefined. 
*1*(S return/NN undefined/VBD ./.)
*0*let VARextensibletarget be ? FUNCisextensible(VARtarget). 
*0*(S (Chunk let/VB VARextensibletarget/NNP) be/VB ?/. (Chunk FUNCisextensible/NNP) (/( (Chunk VARtarget/NNP) )/) ./.)
*0*let VARresultdesc be ? FUNCtopropertydescriptor(VARtrapresultobj). 
*0*(S (Chunk let/VB VARresultdesc/NNP) be/VB ?/. (Chunk FUNCtopropertydescriptor/NNP) (/( (Chunk VARtrapresultobj/NNP) )/) ./.)
*0*call FUNCcompletepropertydescriptor(VARresultdesc). 
*0*(S call/NN (Chunk FUNCcompletepropertydescriptor/NNP) (/( (Chunk VARresultdesc/NNP) )/) ./.)
*0*let VARvalid be FUNCiscompatiblepropertydescriptor(VARextensibletarget, VARresultdesc, VARtargetdesc). 
*0*(S (Chunk let/VB VARvalid/NNP) (Chunk be/VB FUNCiscompatiblepropertydescriptor/NNP) (/( (Chunk VARextensibletarget/NNP) ,/, (Chunk VARresultdesc/NNP) ,/, (Chunk VARtargetdesc/NNP) )/) ./.)
*0*if VARvalid is false, throw a typeerror exception. 
*0*(S if/IN (Chunk VARvalid/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARresultdesc.[[CONFIGURABLE]] is false, then
*0*(S if/IN (Chunk VARresultdesc/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, then/RB)
*1*if VARtargetdesc is undefined or VARtargetdesc.[[CONFIGURABLE]] is true, then
*1*(S if/IN (Chunk VARtargetdesc/NNP) is/VBZ undefined/JJ or/CC (Chunk VARtargetdesc/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ true/JJ ,/, then/RB)
*2*throw a typeerror exception. 
*2*(S throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARresultdesc.    
*0*(S return/NN (Chunk VARresultdesc/NNP) ./.)
ID= 9.5.6
Summary= [[DefineOwnProperty]] ( P, Desc )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*(S (Chunk let/VB VARhandler/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYHANDLER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARhandler is null, throw a typeerror exception. 
*0*(S if/IN (Chunk VARhandler/NNP) is/VBZ null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: FUNCtype(VARhandler) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARhandler/NNP) )/) is/VBZ object/JJ ./.)
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*(S (Chunk let/VB VARtarget/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYTARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "defineproperty"). 
*0*(S (Chunk let/VB VARtrap/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARhandler/NNP) ,/, ``/`` defineproperty/NN ''/'' )/) ./.)
*0*if VARtrap is undefined, then
*0*(S if/IN (Chunk VARtrap/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*return ? VARtarget.[[DEFINEOWNPROPERTY]](VARp, VARdesc). 
*1*(S return/NN ?/. (Chunk VARtarget/NNP) ./. (Chunk [/VB [/NNP) (Chunk DEFINEOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) ,/, (Chunk VARdesc/NNP) )/) ./.)
*0*let VARdescobj be FUNCfrompropertydescriptor(VARdesc). 
*0*(S (Chunk let/VB VARdescobj/NNP) (Chunk be/VB FUNCfrompropertydescriptor/NNP) (/( (Chunk VARdesc/NNP) )/) ./.)
*0*let VARbooleantrapresult be FUNCtoboolean(? FUNCcall(VARtrap, VARhandler, « VARtarget, VARp, VARdescobj »)). 
*0*(S (Chunk let/VB VARbooleantrapresult/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARtrap/NNP) ,/, (Chunk VARhandler/NNP) ,/, (Chunk «/NNP) (Chunk VARtarget/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARdescobj/NNP) (Chunk »/NNP) )/) )/) ./.)
*0*if VARbooleantrapresult is false, return false. 
*0*(S if/IN (Chunk VARbooleantrapresult/NNP) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*0*let VARtargetdesc be ? VARtarget.[[GETOWNPROPERTY]](VARp). 
*0*(S (Chunk let/VB VARtargetdesc/NNP) be/VB ?/. (Chunk VARtarget/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*let VARextensibletarget be ? FUNCisextensible(VARtarget). 
*0*(S (Chunk let/VB VARextensibletarget/NNP) be/VB ?/. (Chunk FUNCisextensible/NNP) (/( (Chunk VARtarget/NNP) )/) ./.)
*0*if VARdesc has a [[CONFIGURABLE]] field and if VARdesc.[[CONFIGURABLE]] is false, then
*0*(S if/IN (Chunk VARdesc/NNP) has/VBZ a/DT [/JJ [/NN (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN and/CC if/IN (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, then/RB)
*1*let VARsettingconfigfalse be true. 
*1*(S (Chunk let/VB VARsettingconfigfalse/NNP) be/VB true/JJ ./.)
*0*else, let VARsettingconfigfalse be false. 
*0*(S else/RB ,/, (Chunk let/VB VARsettingconfigfalse/NNP) be/VB false/JJ ./.)
*0*if VARtargetdesc is undefined, then
*0*(S if/IN (Chunk VARtargetdesc/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*if VARextensibletarget is false, throw a typeerror exception. 
*1*(S if/IN (Chunk VARextensibletarget/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*if VARsettingconfigfalse is true, throw a typeerror exception. 
*1*(S if/IN (Chunk VARsettingconfigfalse/NNP) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*else VARtargetdesc is not undefined,
*0*(S (Chunk else/RB VARtargetdesc/NNP) is/VBZ not/RB undefined/JJ ,/,)
*1*if FUNCiscompatiblepropertydescriptor(VARextensibletarget, VARdesc, VARtargetdesc) is false, throw a typeerror exception. 
*1*(S if/IN (Chunk FUNCiscompatiblepropertydescriptor/NNP) (/( (Chunk VARextensibletarget/NNP) ,/, (Chunk VARdesc/NNP) ,/, (Chunk VARtargetdesc/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*if VARsettingconfigfalse is true and VARtargetdesc.[[CONFIGURABLE]] is true, throw a typeerror exception. 
*1*(S if/IN (Chunk VARsettingconfigfalse/NNP) is/VBZ true/JJ and/CC (Chunk VARtargetdesc/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return true.    
*0*(S return/NN true/JJ ./.)
ID= 9.5.7
Summary= [[HasProperty]] ( P )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*(S (Chunk let/VB VARhandler/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYHANDLER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARhandler is null, throw a typeerror exception. 
*0*(S if/IN (Chunk VARhandler/NNP) is/VBZ null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: FUNCtype(VARhandler) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARhandler/NNP) )/) is/VBZ object/JJ ./.)
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*(S (Chunk let/VB VARtarget/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYTARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "has"). 
*0*(S (Chunk let/VB VARtrap/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARhandler/NNP) ,/, ``/`` has/VBZ ''/'' )/) ./.)
*0*if VARtrap is undefined, then
*0*(S if/IN (Chunk VARtrap/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*return ? VARtarget.[[HASPROPERTY]](VARp). 
*1*(S return/NN ?/. (Chunk VARtarget/NNP) ./. (Chunk [/VB [/NNP) (Chunk HASPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*let VARbooleantrapresult be FUNCtoboolean(? FUNCcall(VARtrap, VARhandler, « VARtarget, VARp »)). 
*0*(S (Chunk let/VB VARbooleantrapresult/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARtrap/NNP) ,/, (Chunk VARhandler/NNP) ,/, (Chunk «/NNP) (Chunk VARtarget/NNP) ,/, (Chunk VARp/NNP) (Chunk »/NNP) )/) )/) ./.)
*0*if VARbooleantrapresult is false, then
*0*(S if/IN (Chunk VARbooleantrapresult/NNP) is/VBZ false/JJ ,/, then/RB)
*1*let VARtargetdesc be ? VARtarget.[[GETOWNPROPERTY]](VARp). 
*1*(S (Chunk let/VB VARtargetdesc/NNP) be/VB ?/. (Chunk VARtarget/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*1*if VARtargetdesc is not undefined, then
*1*(S if/IN (Chunk VARtargetdesc/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*2*if VARtargetdesc.[[CONFIGURABLE]] is false, throw a typeerror exception. 
*2*(S if/IN (Chunk VARtargetdesc/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*2*let VARextensibletarget be ? FUNCisextensible(VARtarget). 
*2*(S (Chunk let/VB VARextensibletarget/NNP) be/VB ?/. (Chunk FUNCisextensible/NNP) (/( (Chunk VARtarget/NNP) )/) ./.)
*2*if VARextensibletarget is false, throw a typeerror exception. 
*2*(S if/IN (Chunk VARextensibletarget/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARbooleantrapresult.    
*0*(S return/NN (Chunk VARbooleantrapresult/NNP) ./.)
ID= 9.5.8
Summary= [[Get]] ( P, Receiver )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*(S (Chunk let/VB VARhandler/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYHANDLER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARhandler is null, throw a typeerror exception. 
*0*(S if/IN (Chunk VARhandler/NNP) is/VBZ null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: FUNCtype(VARhandler) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARhandler/NNP) )/) is/VBZ object/JJ ./.)
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*(S (Chunk let/VB VARtarget/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYTARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "get"). 
*0*(S (Chunk let/VB VARtrap/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARhandler/NNP) ,/, ``/`` get/VB ''/'' )/) ./.)
*0*if VARtrap is undefined, then
*0*(S if/IN (Chunk VARtrap/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*return ? VARtarget.[[GET]](VARp, VARreceiver). 
*1*(S return/NN ?/. (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) ,/, (Chunk VARreceiver/NNP) )/) ./.)
*0*let VARtrapresult be ? FUNCcall(VARtrap, VARhandler, « VARtarget, VARp, VARreceiver »). 
*0*(S (Chunk let/VB VARtrapresult/NNP) be/VB ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARtrap/NNP) ,/, (Chunk VARhandler/NNP) ,/, (Chunk «/NNP) (Chunk VARtarget/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARreceiver/NNP) (Chunk »/NNP) )/) ./.)
*0*let VARtargetdesc be ? VARtarget.[[GETOWNPROPERTY]](VARp). 
*0*(S (Chunk let/VB VARtargetdesc/NNP) be/VB ?/. (Chunk VARtarget/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*if VARtargetdesc is not undefined and VARtargetdesc.[[CONFIGURABLE]] is false, then
*0*(S if/IN (Chunk VARtargetdesc/NNP) is/VBZ not/RB undefined/JJ and/CC (Chunk VARtargetdesc/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, then/RB)
*1*if FUNCisdatadescriptor(VARtargetdesc) is true and VARtargetdesc.[[WRITABLE]] is false, then
*1*(S if/IN (Chunk FUNCisdatadescriptor/NNP) (/( (Chunk VARtargetdesc/NNP) )/) is/VBZ true/JJ and/CC (Chunk VARtargetdesc/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, then/RB)
*2*if FUNCsamevalue(VARtrapresult, VARtargetdesc.[[VALUE]]) is false, throw a typeerror exception. 
*2*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARtrapresult/NNP) ,/, (Chunk VARtargetdesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*if FUNCisaccessordescriptor(VARtargetdesc) is true and VARtargetdesc.[[GET]] is undefined, then
*1*(S if/IN (Chunk FUNCisaccessordescriptor/NNP) (/( (Chunk VARtargetdesc/NNP) )/) is/VBZ true/JJ and/CC (Chunk VARtargetdesc/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ undefined/VBN ,/, then/RB)
*2*if VARtrapresult is not undefined, throw a typeerror exception. 
*2*(S if/IN (Chunk VARtrapresult/NNP) is/VBZ not/RB undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARtrapresult.    
*0*(S return/NN (Chunk VARtrapresult/NNP) ./.)
ID= 9.5.9
Summary= [[Set]] ( P, V, Receiver )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*(S (Chunk let/VB VARhandler/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYHANDLER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARhandler is null, throw a typeerror exception. 
*0*(S if/IN (Chunk VARhandler/NNP) is/VBZ null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: FUNCtype(VARhandler) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARhandler/NNP) )/) is/VBZ object/JJ ./.)
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*(S (Chunk let/VB VARtarget/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYTARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "set"). 
*0*(S (Chunk let/VB VARtrap/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARhandler/NNP) ,/, ``/`` set/VB ''/'' )/) ./.)
*0*if VARtrap is undefined, then
*0*(S if/IN (Chunk VARtrap/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*return ? VARtarget.[[SET]](VARp, VARv, VARreceiver). 
*1*(S return/NN ?/. (Chunk VARtarget/NNP) ./. [/NN [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) ,/, (Chunk VARv/NNP) ,/, (Chunk VARreceiver/NNP) )/) ./.)
*0*let VARbooleantrapresult be FUNCtoboolean(? FUNCcall(VARtrap, VARhandler, « VARtarget, VARp, VARv, VARreceiver »)). 
*0*(S (Chunk let/VB VARbooleantrapresult/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARtrap/NNP) ,/, (Chunk VARhandler/NNP) ,/, (Chunk «/NNP) (Chunk VARtarget/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARv/NNP) ,/, (Chunk VARreceiver/NNP) (Chunk »/NNP) )/) )/) ./.)
*0*if VARbooleantrapresult is false, return false. 
*0*(S if/IN (Chunk VARbooleantrapresult/NNP) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*0*let VARtargetdesc be ? VARtarget.[[GETOWNPROPERTY]](VARp). 
*0*(S (Chunk let/VB VARtargetdesc/NNP) be/VB ?/. (Chunk VARtarget/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*if VARtargetdesc is not undefined and VARtargetdesc.[[CONFIGURABLE]] is false, then
*0*(S if/IN (Chunk VARtargetdesc/NNP) is/VBZ not/RB undefined/JJ and/CC (Chunk VARtargetdesc/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, then/RB)
*1*if FUNCisdatadescriptor(VARtargetdesc) is true and VARtargetdesc.[[WRITABLE]] is false, then
*1*(S if/IN (Chunk FUNCisdatadescriptor/NNP) (/( (Chunk VARtargetdesc/NNP) )/) is/VBZ true/JJ and/CC (Chunk VARtargetdesc/NNP) ./. [/VB [/JJ (Chunk WRITABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, then/RB)
*2*if FUNCsamevalue(VARv, VARtargetdesc.[[VALUE]]) is false, throw a typeerror exception. 
*2*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARtargetdesc/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*if FUNCisaccessordescriptor(VARtargetdesc) is true, then
*1*(S if/IN (Chunk FUNCisaccessordescriptor/NNP) (/( (Chunk VARtargetdesc/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*if VARtargetdesc.[[SET]] is undefined, throw a typeerror exception. 
*2*(S if/IN (Chunk VARtargetdesc/NNP) ./. [/NN [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return true.    
*0*(S return/NN true/JJ ./.)
ID= 9.5.10
Summary= [[Delete]] ( P )
*0*assert: FUNCispropertykey(VARp) is true. 
*0*(S assert/NN :/: (Chunk FUNCispropertykey/NNP) (/( (Chunk VARp/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*(S (Chunk let/VB VARhandler/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYHANDLER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARhandler is null, throw a typeerror exception. 
*0*(S if/IN (Chunk VARhandler/NNP) is/VBZ null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: FUNCtype(VARhandler) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARhandler/NNP) )/) is/VBZ object/JJ ./.)
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*(S (Chunk let/VB VARtarget/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYTARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "deleteproperty"). 
*0*(S (Chunk let/VB VARtrap/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARhandler/NNP) ,/, ``/`` deleteproperty/NN ''/'' )/) ./.)
*0*if VARtrap is undefined, then
*0*(S if/IN (Chunk VARtrap/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*return ? VARtarget.[[DELETE]](VARp). 
*1*(S return/NN ?/. (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk DELETE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*let VARbooleantrapresult be FUNCtoboolean(? FUNCcall(VARtrap, VARhandler, « VARtarget, VARp »)). 
*0*(S (Chunk let/VB VARbooleantrapresult/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARtrap/NNP) ,/, (Chunk VARhandler/NNP) ,/, (Chunk «/NNP) (Chunk VARtarget/NNP) ,/, (Chunk VARp/NNP) (Chunk »/NNP) )/) )/) ./.)
*0*if VARbooleantrapresult is false, return false. 
*0*(S if/IN (Chunk VARbooleantrapresult/NNP) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*0*let VARtargetdesc be ? VARtarget.[[GETOWNPROPERTY]](VARp). 
*0*(S (Chunk let/VB VARtargetdesc/NNP) be/VB ?/. (Chunk VARtarget/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*if VARtargetdesc is undefined, return true. 
*0*(S if/IN (Chunk VARtargetdesc/NNP) is/VBZ undefined/JJ ,/, return/VB true/JJ ./.)
*0*if VARtargetdesc.[[CONFIGURABLE]] is false, throw a typeerror exception. 
*0*(S if/IN (Chunk VARtargetdesc/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return true.    
*0*(S return/NN true/JJ ./.)
ID= 9.5.11
Summary= [[OwnPropertyKeys]] ( )
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*(S (Chunk let/VB VARhandler/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYHANDLER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARhandler is null, throw a typeerror exception. 
*0*(S if/IN (Chunk VARhandler/NNP) is/VBZ null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: FUNCtype(VARhandler) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARhandler/NNP) )/) is/VBZ object/JJ ./.)
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*(S (Chunk let/VB VARtarget/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYTARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "ownkeys"). 
*0*(S (Chunk let/VB VARtrap/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARhandler/NNP) ,/, ``/`` ownkeys/NNS ''/'' )/) ./.)
*0*if VARtrap is undefined, then
*0*(S if/IN (Chunk VARtrap/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*return ? VARtarget.[[OWNPROPERTYKEYS]](). 
*1*(S return/NN ?/. (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk OWNPROPERTYKEYS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*0*let VARtrapresultarray be ? FUNCcall(VARtrap, VARhandler, « VARtarget »). 
*0*(S (Chunk let/VB VARtrapresultarray/NNP) be/VB ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARtrap/NNP) ,/, (Chunk VARhandler/NNP) ,/, (Chunk «/NNP) (Chunk VARtarget/NNP) (Chunk »/NNP) )/) ./.)
*0*let VARtrapresult be ? FUNCcreatelistfromarraylike(VARtrapresultarray, « string, symbol »). 
*0*(S (Chunk let/VB VARtrapresult/NNP) be/VB ?/. (Chunk FUNCcreatelistfromarraylike/NNP) (/( (Chunk VARtrapresultarray/NNP) ,/, (Chunk «/NNP) string/NN ,/, symbol/NN »/NN )/) ./.)
*0*if VARtrapresult contains any duplicate entries, throw a typeerror exception. 
*0*(S if/IN (Chunk VARtrapresult/NNP) contains/VBZ any/DT duplicate/JJ entries/NNS ,/, throw/VBP a/DT typeerror/NN exception/NN ./.)
*0*let VARextensibletarget be ? FUNCisextensible(VARtarget). 
*0*(S (Chunk let/VB VARextensibletarget/NNP) be/VB ?/. (Chunk FUNCisextensible/NNP) (/( (Chunk VARtarget/NNP) )/) ./.)
*0*let VARtargetkeys be ? VARtarget.[[OWNPROPERTYKEYS]](). 
*0*(S (Chunk let/VB VARtargetkeys/NNP) be/VB ?/. (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk OWNPROPERTYKEYS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*0*assert: VARtargetkeys is a list containing only string and symbol values. 
*0*(S assert/NN :/: (Chunk VARtargetkeys/NNP) is/VBZ a/DT list/NN containing/VBG only/RB string/VBG and/CC symbol/NN values/NNS ./.)
*0*assert: VARtargetkeys contains no duplicate entries. 
*0*(S assert/NN :/: (Chunk VARtargetkeys/NNP) contains/VBZ no/DT duplicate/NN entries/NNS ./.)
*0*let VARtargetconfigurablekeys be a new empty list. 
*0*(S (Chunk let/VB VARtargetconfigurablekeys/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARtargetnonconfigurablekeys be a new empty list. 
*0*(S (Chunk let/VB VARtargetnonconfigurablekeys/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*for each element VARkey of VARtargetkeys, do
*0*(S for/IN each/DT element/NN (Chunk VARkey/NNP) of/IN (Chunk VARtargetkeys/NNP) ,/, do/VBP)
*1*let VARdesc be ? VARtarget.[[GETOWNPROPERTY]](VARkey). 
*1*(S (Chunk let/VB VARdesc/NNP) be/VB ?/. (Chunk VARtarget/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARkey/NNP) )/) ./.)
*1*if VARdesc is not undefined and VARdesc.[[CONFIGURABLE]] is false, then
*1*(S if/IN (Chunk VARdesc/NNP) is/VBZ not/RB undefined/JJ and/CC (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, then/RB)
*2*append VARkey as an element of VARtargetnonconfigurablekeys. 
*2*(S (Chunk append/RB VARkey/NNP) as/IN an/DT element/NN of/IN (Chunk VARtargetnonconfigurablekeys/NNP) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*append VARkey as an element of VARtargetconfigurablekeys. 
*2*(S (Chunk append/RB VARkey/NNP) as/IN an/DT element/NN of/IN (Chunk VARtargetconfigurablekeys/NNP) ./.)
*0*if VARextensibletarget is true and VARtargetnonconfigurablekeys is empty, then
*0*(S if/IN (Chunk VARextensibletarget/NNP) is/VBZ true/JJ and/CC (Chunk VARtargetnonconfigurablekeys/NNP) is/VBZ empty/JJ ,/, then/RB)
*1*return VARtrapresult. 
*1*(S return/NN (Chunk VARtrapresult/NNP) ./.)
*0*let VARuncheckedresultkeys be a new list which is a copy of VARtrapresult. 
*0*(S (Chunk let/VB VARuncheckedresultkeys/NNP) be/VB a/DT new/JJ list/NN which/WDT is/VBZ a/DT copy/NN of/IN (Chunk VARtrapresult/NNP) ./.)
*0*for each VARkey that is an element of VARtargetnonconfigurablekeys, do
*0*(S for/IN each/DT (Chunk VARkey/NNP) that/WDT is/VBZ an/DT element/NN of/IN (Chunk VARtargetnonconfigurablekeys/NNP) ,/, do/VBP)
*1*if VARkey is not an element of VARuncheckedresultkeys, throw a typeerror exception. 
*1*(S if/IN (Chunk VARkey/NNP) is/VBZ not/RB an/DT element/NN of/IN (Chunk VARuncheckedresultkeys/NNP) ,/, throw/VBP a/DT typeerror/NN exception/NN ./.)
*1*remove VARkey from VARuncheckedresultkeys. 
*1*(S (Chunk remove/VB VARkey/NNP) from/IN (Chunk VARuncheckedresultkeys/NNP) ./.)
*0*if VARextensibletarget is true, return VARtrapresult. 
*0*(S if/IN (Chunk VARextensibletarget/NNP) is/VBZ true/JJ ,/, return/JJ (Chunk VARtrapresult/NNP) ./.)
*0*for each VARkey that is an element of VARtargetconfigurablekeys, do
*0*(S for/IN each/DT (Chunk VARkey/NNP) that/WDT is/VBZ an/DT element/NN of/IN (Chunk VARtargetconfigurablekeys/NNP) ,/, do/VBP)
*1*if VARkey is not an element of VARuncheckedresultkeys, throw a typeerror exception. 
*1*(S if/IN (Chunk VARkey/NNP) is/VBZ not/RB an/DT element/NN of/IN (Chunk VARuncheckedresultkeys/NNP) ,/, throw/VBP a/DT typeerror/NN exception/NN ./.)
*1*remove VARkey from VARuncheckedresultkeys. 
*1*(S (Chunk remove/VB VARkey/NNP) from/IN (Chunk VARuncheckedresultkeys/NNP) ./.)
*0*if VARuncheckedresultkeys is not empty, throw a typeerror exception. 
*0*(S if/IN (Chunk VARuncheckedresultkeys/NNP) is/VBZ not/RB empty/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARtrapresult.    
*0*(S return/NN (Chunk VARtrapresult/NNP) ./.)
ID= 9.5.12
Summary= [[Call]] ( thisArgument, argumentsList )
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*(S (Chunk let/VB VARhandler/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYHANDLER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARhandler is null, throw a typeerror exception. 
*0*(S if/IN (Chunk VARhandler/NNP) is/VBZ null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: FUNCtype(VARhandler) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARhandler/NNP) )/) is/VBZ object/JJ ./.)
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*(S (Chunk let/VB VARtarget/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYTARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "apply"). 
*0*(S (Chunk let/VB VARtrap/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARhandler/NNP) ,/, ``/`` apply/VB ''/'' )/) ./.)
*0*if VARtrap is undefined, then
*0*(S if/IN (Chunk VARtrap/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*return ? FUNCcall(VARtarget, VARthisargument, VARargumentslist). 
*1*(S return/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARtarget/NNP) ,/, (Chunk VARthisargument/NNP) ,/, (Chunk VARargumentslist/NNP) )/) ./.)
*0*let VARargarray be FUNCcreatearrayfromlist(VARargumentslist). 
*0*(S (Chunk let/VB VARargarray/NNP) (Chunk be/VB FUNCcreatearrayfromlist/NNP) (/( (Chunk VARargumentslist/NNP) )/) ./.)
*0*return ? FUNCcall(VARtrap, VARhandler, « VARtarget, VARthisargument, VARargarray »).    
*0*(S return/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARtrap/NNP) ,/, (Chunk VARhandler/NNP) ,/, (Chunk «/NNP) (Chunk VARtarget/NNP) ,/, (Chunk VARthisargument/NNP) ,/, (Chunk VARargarray/NNP) (Chunk »/NNP) )/) ./.)
ID= 9.5.13
Summary= [[Construct]] ( argumentsList, newTarget )
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*(S (Chunk let/VB VARhandler/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYHANDLER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARhandler is null, throw a typeerror exception. 
*0*(S if/IN (Chunk VARhandler/NNP) is/VBZ null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: FUNCtype(VARhandler) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARhandler/NNP) )/) is/VBZ object/JJ ./.)
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*(S (Chunk let/VB VARtarget/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk PROXYTARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "construct"). 
*0*(S (Chunk let/VB VARtrap/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARhandler/NNP) ,/, ``/`` construct/NN ''/'' )/) ./.)
*0*if VARtrap is undefined, then
*0*(S if/IN (Chunk VARtrap/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*assert: FUNCisconstructor(VARtarget) is true. 
*1*(S assert/NN :/: (Chunk FUNCisconstructor/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ true/JJ ./.)
*1*return ? FUNCconstruct(VARtarget, VARargumentslist, VARnewtarget). 
*1*(S return/NN ?/. (Chunk FUNCconstruct/NNP) (/( (Chunk VARtarget/NNP) ,/, (Chunk VARargumentslist/NNP) ,/, (Chunk VARnewtarget/NNP) )/) ./.)
*0*let VARargarray be FUNCcreatearrayfromlist(VARargumentslist). 
*0*(S (Chunk let/VB VARargarray/NNP) (Chunk be/VB FUNCcreatearrayfromlist/NNP) (/( (Chunk VARargumentslist/NNP) )/) ./.)
*0*let VARnewobj be ? FUNCcall(VARtrap, VARhandler, « VARtarget, VARargarray, VARnewtarget »). 
*0*(S (Chunk let/VB VARnewobj/NNP) be/VB ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARtrap/NNP) ,/, (Chunk VARhandler/NNP) ,/, (Chunk «/NNP) (Chunk VARtarget/NNP) ,/, (Chunk VARargarray/NNP) ,/, (Chunk VARnewtarget/NNP) (Chunk »/NNP) )/) ./.)
*0*if FUNCtype(VARnewobj) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARnewobj/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARnewobj.    
*0*(S return/NN (Chunk VARnewobj/NNP) ./.)
ID= 9.5.14
Summary= ProxyCreate ( target, handler )
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARtarget is a proxy exotic object and VARtarget.[[PROXYHANDLER]] is null, throw a typeerror exception. 
*0*(S if/IN (Chunk VARtarget/NNP) is/VBZ a/DT proxy/JJ exotic/JJ object/NN and/CC (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk PROXYHANDLER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if FUNCtype(VARhandler) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARhandler/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARhandler is a proxy exotic object and VARhandler.[[PROXYHANDLER]] is null, throw a typeerror exception. 
*0*(S if/IN (Chunk VARhandler/NNP) is/VBZ a/DT proxy/JJ exotic/JJ object/NN and/CC (Chunk VARhandler/NNP) ./. [/VB [/JJ (Chunk PROXYHANDLER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARp be a newly created object. 
*0*(S (Chunk let/VB VARp/NNP) be/VB a/DT newly/RB created/VBN object/NN ./.)
*0*set VARp's essential internal methods (except for [[CALL]] and [[CONSTRUCT]]) to the definitions specified in 9.5. 
*0*(S (Chunk set/VBN VARp/NNP) 's/POS essential/JJ internal/JJ methods/NNS (/( except/IN for/IN (Chunk [/NNP) (Chunk [/NNP) (Chunk CALL/NNP) (Chunk ]/NNP) (Chunk ]/NNP) and/CC (Chunk [/NNP) (Chunk [/NNP) (Chunk CONSTRUCT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) to/TO the/DT definitions/NNS specified/VBN in/IN 9.5/CD ./.)
*0*if FUNCiscallable(VARtarget) is true, then
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*set VARp.[[CALL]] as specified in 9.5.12. 
*1*(S (Chunk set/VBN VARp/NNP) ./. [/VB [/JJ (Chunk CALL/NNP) (Chunk ]/NNP) (Chunk ]/NNP) as/IN specified/VBN in/IN 9.5.12/CD ./.)
*1*if FUNCisconstructor(VARtarget) is true, then
*1*(S if/IN (Chunk FUNCisconstructor/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*set VARp.[[CONSTRUCT]] as specified in 9.5.13. 
*2*(S (Chunk set/VBN VARp/NNP) ./. (Chunk [/NNP) (Chunk [/NNP) (Chunk CONSTRUCT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) as/IN specified/VBN in/IN 9.5.13/CD ./.)
*0*set VARp.[[PROXYTARGET]] to VARtarget. 
*0*(S (Chunk set/VBN VARp/NNP) ./. [/VB [/JJ (Chunk PROXYTARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARtarget/NNP) ./.)
*0*set VARp.[[PROXYHANDLER]] to VARhandler. 
*0*(S (Chunk set/VBN VARp/NNP) ./. [/VB [/JJ (Chunk PROXYHANDLER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARhandler/NNP) ./.)
*0*return VARp.    
*0*(S return/NN (Chunk VARp/NNP) ./.)
ID= 10.1.1
Summary= Static Semantics: UTF16Encoding ( cp )
*0*assert: 0 ≤ VARcp ≤ 0x10ffff. 
*0*(S assert/NN :/: 0/CD ≤/NN (Chunk VARcp/NNP) ≤/VBZ 0x10ffff/CD ./.)
*0*if VARcp ≤ 0xffff, return VARcp. 
*0*(S if/IN (Chunk VARcp/NNP) ≤/VBD 0xffff/CD ,/, return/NN (Chunk VARcp/NNP) ./.)
*0*let VARcu1 be floor((VARcp - 0x10000) / 0x400) + 0xd800. 
*0*(S (Chunk let/VB VARcu1/NNP) be/VB floor/NN (/( (/( (Chunk VARcp/NNP) -/: 0x10000/CD )/) //FW 0x400/CD )/) +/NN 0xd800/CD ./.)
*0*let VARcu2 be ((VARcp - 0x10000) modulo 0x400) + 0xdc00. 
*0*(S (Chunk let/VB VARcu2/NNP) be/VB (/( (/( (Chunk VARcp/NNP) -/: 0x10000/CD )/) modulo/FW 0x400/CD )/) +/NN 0xdc00/CD ./.)
*0*return the code unit sequence consisting of VARcu1 followed by VARcu2.    
*0*(S return/VB the/DT code/NN unit/NN sequence/NN consisting/NN of/IN (Chunk VARcu1/NNP) followed/VBN by/IN (Chunk VARcu2/NNP) ./.)
ID= 10.1.2
Summary= Static Semantics: UTF16Decode ( lead, trail )
*0*assert: VARlead is a leading surrogate and VARtrail is a trailing surrogate. 
*0*(S assert/NN :/: VARlead/NN is/VBZ a/DT leading/VBG surrogate/NN and/CC (Chunk VARtrail/NNP) is/VBZ a/DT trailing/VBG surrogate/NN ./.)
*0*let VARcp be (VARlead - 0xd800) × 0x400 + (VARtrail - 0xdc00) + 0x10000. 
*0*(S (Chunk let/VB VARcp/NNP) be/VB (/( (Chunk VARlead/NNP) -/: 0xd800/CD )/) ×/VBD 0x400/CD (Chunk +/NNP) (/( (Chunk VARtrail/NNP) -/: 0xdc00/CD )/) +/NN 0x10000/CD ./.)
*0*return the code point VARcp.    
*0*(S return/VB the/DT code/NN point/NN (Chunk VARcp/NNP) ./.)
ID= 12.1.5.1
Summary= Runtime Semantics: InitializeBoundName ( name, value, environment )
*0*assert: FUNCtype(VARname) is string. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARname/NNP) )/) is/VBZ string/VBG ./.)
*0*if VARenvironment is not undefined, then
*0*(S if/IN (Chunk VARenvironment/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*1*let VARenv be the environmentrecord component of VARenvironment. 
*1*(S (Chunk let/VB VARenv/NNP) be/VB the/DT environmentrecord/JJ component/NN of/IN (Chunk VARenvironment/NNP) ./.)
*1*perform VARenv.initializebinding(VARname, VARvalue). 
*1*(S perform/NN (Chunk VARenv.initializebinding/NNP) (/( (Chunk VARname/NNP) ,/, (Chunk VARvalue/NNP) )/) ./.)
*1*return FUNCnormalcompletion(undefined). 
*1*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( undefined/JJ )/) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARlhs be FUNCresolvebinding(VARname). 
*1*(S (Chunk let/VB VARlhs/NNP) (Chunk be/VB FUNCresolvebinding/NNP) (/( (Chunk VARname/NNP) )/) ./.)
*1*return ? FUNCputvalue(VARlhs, VARvalue).     
*1*(S return/NN ?/. (Chunk FUNCputvalue/NNP) (/( (Chunk VARlhs/NNP) ,/, (Chunk VARvalue/NNP) )/) ./.)
ID= 12.2.9.4
Summary= Runtime Semantics: GetTemplateObject ( templateLiteral )
*0*let VARrawstrings be templatestrings of VARtemplateliteral with argument true. 
*0*(S (Chunk let/VB VARrawstrings/NNP) be/VB templatestrings/NNS of/IN (Chunk VARtemplateliteral/NNP) with/IN argument/NN true/JJ ./.)
*0*let VARrealm be the current realm record. 
*0*(S (Chunk let/VB VARrealm/NNP) be/VB the/DT current/JJ realm/NN record/NN ./.)
*0*let VARtemplateregistry be VARrealm.[[TEMPLATEMAP]]. 
*0*(S (Chunk let/VB VARtemplateregistry/NNP) (Chunk be/VB VARrealm/NNP) ./. [/VB [/JJ (Chunk TEMPLATEMAP/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*for each element VARe of VARtemplateregistry, do
*0*(S for/IN each/DT element/NN (Chunk VARe/NNP) of/IN (Chunk VARtemplateregistry/NNP) ,/, do/VBP)
*1*if VARe.[[SITE]] is the same parse node as VARtemplateliteral, then
*1*(S if/IN (Chunk VARe/NNP) ./. [/VB [/JJ (Chunk SITE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ the/DT same/JJ parse/NN node/NN as/IN (Chunk VARtemplateliteral/NNP) ,/, then/RB)
*2*return VARe.[[ARRAY]]. 
*2*(S return/NN (Chunk VARe/NNP) ./. [/VB [/JJ (Chunk ARRAY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARcookedstrings be templatestrings of VARtemplateliteral with argument false. 
*0*(S (Chunk let/VB VARcookedstrings/NNP) be/VB templatestrings/NNS of/IN (Chunk VARtemplateliteral/NNP) with/IN argument/NN false/NN ./.)
*0*let VARcount be the number of elements in the list VARcookedstrings. 
*0*(S (Chunk let/VB VARcount/NNP) be/VB the/DT number/NN of/IN elements/NNS in/IN the/DT list/NN (Chunk VARcookedstrings/NNP) ./.)
*0*assert: VARcount ≤ 232-1. 
*0*(S assert/NN :/: (Chunk VARcount/NNP) (Chunk ≤/NNP) 232-1/JJ ./.)
*0*let VARtemplate be ! FUNCarraycreate(VARcount). 
*0*(S (Chunk let/VB VARtemplate/NNP) be/VB !/. (Chunk FUNCarraycreate/NNP) (/( (Chunk VARcount/NNP) )/) ./.)
*0*let VARrawobj be ! FUNCarraycreate(VARcount). 
*0*(S (Chunk let/VB VARrawobj/NNP) be/VB !/. (Chunk FUNCarraycreate/NNP) (/( (Chunk VARcount/NNP) )/) ./.)
*0*let VARindex be 0. 
*0*(S (Chunk let/VB VARindex/NNP) be/VB 0/CD ./.)
*0*repeat, while VARindex &lt; VARcount
*0*(S repeat/NN ,/, while/IN (Chunk VARindex/NNP) &/CC lt/NN ;/: (Chunk VARcount/NNP))
*1*let VARprop be ! FUNCtostring(VARindex). 
*1*(S (Chunk let/VB VARprop/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARindex/NNP) )/) ./.)
*1*let VARcookedvalue be the string value VARcookedstrings[VARindex]. 
*1*(S (Chunk let/VB VARcookedvalue/NNP) be/VB the/DT string/VBG value/NN (Chunk VARcookedstrings/NNP) (Chunk [/NNP) (Chunk VARindex/NNP) (Chunk ]/NNP) ./.)
*1*call VARtemplate.[[DEFINEOWNPROPERTY]](VARprop, propertydescriptor { [[VALUE]]: VARcookedvalue, [[WRITABLE]]: false, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: false }). 
*1*(S call/NN (Chunk VARtemplate/NNP) ./. (Chunk [/VB [/NNP) (Chunk DEFINEOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARprop/NNP) ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARcookedvalue/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) )/) ./.)
*1*let VARrawvalue be the string value VARrawstrings[VARindex]. 
*1*(S (Chunk let/VB VARrawvalue/NNP) be/VB the/DT string/VBG value/NN (Chunk VARrawstrings/NNP) (Chunk [/NNP) (Chunk VARindex/NNP) (Chunk ]/NNP) ./.)
*1*call VARrawobj.[[DEFINEOWNPROPERTY]](VARprop, propertydescriptor { [[VALUE]]: VARrawvalue, [[WRITABLE]]: false, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: false }). 
*1*(S call/NN (Chunk VARrawobj/NNP) ./. (Chunk [/VB [/NNP) (Chunk DEFINEOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARprop/NNP) ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARrawvalue/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) )/) ./.)
*1*let VARindex be VARindex+1. 
*1*(S (Chunk let/VB VARindex/NNP) (Chunk be/VB VARindex+1/NNP) ./.)
*0*perform FUNCsetintegritylevel(VARrawobj, "frozen"). 
*0*(S perform/NN (Chunk FUNCsetintegritylevel/NNP) (/( (Chunk VARrawobj/NNP) ,/, ``/`` frozen/JJ ''/'' )/) ./.)
*0*call VARtemplate.[[DEFINEOWNPROPERTY]]("raw", propertydescriptor { [[VALUE]]: VARrawobj, [[WRITABLE]]: false, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }). 
*0*(S call/NN (Chunk VARtemplate/NNP) ./. (Chunk [/VB [/NNP) (Chunk DEFINEOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( ``/`` raw/VB ''/'' ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARrawobj/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) )/) ./.)
*0*perform FUNCsetintegritylevel(VARtemplate, "frozen"). 
*0*(S perform/NN (Chunk FUNCsetintegritylevel/NNP) (/( (Chunk VARtemplate/NNP) ,/, ``/`` frozen/JJ ''/'' )/) ./.)
*0*append the record { [[SITE]]: VARtemplateliteral, [[ARRAY]]: VARtemplate } to VARtemplateregistry. 
*0*(S append/VB the/DT record/NN {/( [/JJ (Chunk [/NNP) (Chunk SITE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARtemplateliteral/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ARRAY/NNP) (Chunk ]/NNP) ]/NN :/: VARtemplate/NN }/) to/TO (Chunk VARtemplateregistry/NNP) ./.)
*0*return VARtemplate.     
*0*(S return/NN (Chunk VARtemplate/NNP) ./.)
ID= 12.3.3.1.1
Summary= Runtime Semantics: EvaluateNew ( constructExpr, arguments )
*0*assert: VARconstructexpr is either a newexpression or a memberexpression. 
*0*(S assert/NN :/: (Chunk VARconstructexpr/NNP) is/VBZ either/CC a/DT newexpression/NN or/CC a/DT memberexpression/NN ./.)
*0*assert: VARarguments is either empty or an arguments. 
*0*(S assert/NN :/: VARarguments/NNS is/VBZ either/DT empty/JJ or/CC an/DT arguments/NNS ./.)
*0*let VARref be the result of evaluating VARconstructexpr. 
*0*(S (Chunk let/VB VARref/NNP) be/VB the/DT result/NN of/IN (Chunk evaluating/VBG VARconstructexpr/NNP) ./.)
*0*let VARconstructor be ? FUNCgetvalue(VARref). 
*0*(S (Chunk let/VB VARconstructor/NNP) be/VB ?/. (Chunk FUNCgetvalue/NNP) (/( (Chunk VARref/NNP) )/) ./.)
*0*if VARarguments is empty, let VARarglist be a new empty list. 
*0*(S if/IN VARarguments/NNS is/VBZ empty/JJ ,/, (Chunk let/VB VARarglist/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARarglist be argumentlistevaluation of VARarguments. 
*1*(S (Chunk let/VB VARarglist/NNP) be/VB argumentlistevaluation/NN of/IN VARarguments/NNS ./.)
*1*FUNCreturnifabrupt(VARarglist). 
*1*(S (Chunk FUNCreturnifabrupt/NNP) (/( (Chunk VARarglist/NNP) )/) ./.)
*0*if FUNCisconstructor(VARconstructor) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisconstructor/NNP) (/( (Chunk VARconstructor/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return ? FUNCconstruct(VARconstructor, VARarglist).      
*0*(S return/NN ?/. (Chunk FUNCconstruct/NNP) (/( (Chunk VARconstructor/NNP) ,/, (Chunk VARarglist/NNP) )/) ./.)
ID= 12.3.4.2
Summary= Runtime Semantics: EvaluateCall ( func, ref, arguments, tailPosition )
*0*if FUNCtype(VARref) is reference, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARref/NNP) )/) is/VBZ reference/NN ,/, then/RB)
*1*if FUNCispropertyreference(VARref) is true, then
*1*(S if/IN (Chunk FUNCispropertyreference/NNP) (/( (Chunk VARref/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*let VARthisvalue be FUNCgetthisvalue(VARref). 
*2*(S (Chunk let/VB VARthisvalue/NNP) (Chunk be/VB FUNCgetthisvalue/NNP) (/( (Chunk VARref/NNP) )/) ./.)
*1*else the base of VARref is an environment record,
*1*(S else/RB the/DT base/NN of/IN (Chunk VARref/NNP) is/VBZ an/DT environment/NN record/NN ,/,)
*2*let VARrefenv be FUNCgetbase(VARref). 
*2*(S (Chunk let/VB VARrefenv/NNP) (Chunk be/VB FUNCgetbase/NNP) (/( (Chunk VARref/NNP) )/) ./.)
*2*let VARthisvalue be VARrefenv.withbaseobject(). 
*2*(S (Chunk let/VB VARthisvalue/NNP) (Chunk be/VB VARrefenv.withbaseobject/NNP) (/( )/) ./.)
*0*else FUNCtype(VARref) is not reference,
*0*(S (Chunk else/RB FUNCtype/NNP) (/( (Chunk VARref/NNP) )/) is/VBZ not/RB reference/NN ,/,)
*1*let VARthisvalue be undefined. 
*1*(S (Chunk let/VB VARthisvalue/NNP) be/VB undefined/VBN ./.)
*0*let VARarglist be argumentlistevaluation of VARarguments. 
*0*(S (Chunk let/VB VARarglist/NNP) be/VB argumentlistevaluation/NN of/IN VARarguments/NNS ./.)
*0*FUNCreturnifabrupt(VARarglist). 
*0*(S (Chunk FUNCreturnifabrupt/NNP) (/( (Chunk VARarglist/NNP) )/) ./.)
*0*if FUNCtype(VARfunc) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARfunc/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if FUNCiscallable(VARfunc) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARfunc/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARtailposition is true, perform FUNCpreparefortailcall(). 
*0*(S if/IN (Chunk VARtailposition/NNP) is/VBZ true/JJ ,/, (Chunk perform/VB FUNCpreparefortailcall/NNP) (/( )/) ./.)
*0*let VARresult be FUNCcall(VARfunc, VARthisvalue, VARarglist). 
*0*(S (Chunk let/VB VARresult/NNP) (Chunk be/VB FUNCcall/NNP) (/( (Chunk VARfunc/NNP) ,/, (Chunk VARthisvalue/NNP) ,/, (Chunk VARarglist/NNP) )/) ./.)
*0*assert: if VARtailposition is true, the above call will not return here, but instead evaluation will continue as if the following return has already occurred. 
*0*(S assert/NN :/: if/IN (Chunk VARtailposition/NNP) is/VBZ true/JJ ,/, the/DT above/NN call/NN will/MD not/RB return/VB here/RB ,/, but/CC instead/RB evaluation/NN will/MD continue/VB as/IN if/IN the/DT following/VBG return/NN has/VBZ already/RB occurred/VBN ./.)
*0*assert: if VARresult is not an FUNCabrupt completion, then type(VARresult) is an ecmascript language type. 
*0*(S assert/NN :/: if/IN (Chunk VARresult/NNP) is/VBZ not/RB an/DT (Chunk FUNCabrupt/NNP) completion/NN ,/, then/RB type/NN (/( (Chunk VARresult/NNP) )/) is/VBZ an/DT ecmascript/JJ language/NN type/NN ./.)
*0*return VARresult.     
*0*(S return/NN (Chunk VARresult/NNP) ./.)
ID= 12.3.5.2
Summary= Runtime Semantics: GetSuperConstructor ( )
*0*let VARenvrec be FUNCgetthisenvironment(). 
*0*(S (Chunk let/VB VARenvrec/NNP) (Chunk be/VB FUNCgetthisenvironment/NNP) (/( )/) ./.)
*0*assert: VARenvrec is a function environment record. 
*0*(S assert/NN :/: (Chunk VARenvrec/NNP) is/VBZ a/DT function/NN environment/NN record/NN ./.)
*0*let VARactivefunction be VARenvrec.[[FUNCTIONOBJECT]]. 
*0*(S (Chunk let/VB VARactivefunction/NNP) (Chunk be/VB VARenvrec/NNP) ./. [/VB [/JJ (Chunk FUNCTIONOBJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*assert: VARactivefunction is an ecmascript function object. 
*0*(S assert/NN :/: VARactivefunction/NN is/VBZ an/DT ecmascript/JJ function/NN object/NN ./.)
*0*let VARsuperconstructor be ! VARactivefunction.[[GETPROTOTYPEOF]](). 
*0*(S (Chunk let/VB VARsuperconstructor/NNP) be/VB !/. (Chunk VARactivefunction/NNP) ./. [/VB [/JJ (Chunk GETPROTOTYPEOF/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*0*if FUNCisconstructor(VARsuperconstructor) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisconstructor/NNP) (/( (Chunk VARsuperconstructor/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARsuperconstructor.     
*0*(S return/NN (Chunk VARsuperconstructor/NNP) ./.)
ID= 12.3.5.3
Summary= Runtime Semantics: MakeSuperPropertyReference ( propertyKey, strict )
*0*let VARenv be FUNCgetthisenvironment(). 
*0*(S (Chunk let/VB VARenv/NNP) (Chunk be/VB FUNCgetthisenvironment/NNP) (/( )/) ./.)
*0*assert: VARenv.hassuperbinding() is true. 
*0*(S assert/NN :/: (Chunk VARenv.hassuperbinding/NNP) (/( )/) is/VBZ true/JJ ./.)
*0*let VARactualthis be ? VARenv.getthisbinding(). 
*0*(S (Chunk let/VB VARactualthis/NNP) be/VB ?/. (Chunk VARenv.getthisbinding/NNP) (/( )/) ./.)
*0*let VARbasevalue be ? VARenv.getsuperbase(). 
*0*(S (Chunk let/VB VARbasevalue/NNP) be/VB ?/. (Chunk VARenv.getsuperbase/NNP) (/( )/) ./.)
*0*let VARbv be ? FUNCrequireobjectcoercible(VARbasevalue). 
*0*(S (Chunk let/VB VARbv/NNP) be/VB ?/. (Chunk FUNCrequireobjectcoercible/NNP) (/( (Chunk VARbasevalue/NNP) )/) ./.)
*0*return a value of type reference that is a super reference whose base value component is VARbv, whose referenced name component is VARpropertykey, whose thisvalue component is VARactualthis, and whose strict reference flag is VARstrict.     
*0*(S return/VB a/DT value/NN of/IN type/JJ reference/NN that/WDT is/VBZ a/DT super/JJ reference/NN whose/WP$ base/NN value/NN component/NN (Chunk is/VBZ VARbv/NNP) ,/, whose/WP$ referenced/JJ name/NN component/NN (Chunk is/VBZ VARpropertykey/NNP) ,/, whose/WP$ thisvalue/JJ component/NN (Chunk is/VBZ VARactualthis/NNP) ,/, and/CC whose/WP$ strict/JJ reference/NN flag/NN (Chunk is/VBZ VARstrict/NNP) ./.)
ID= 12.5.8
Summary= Bitwise NOT Operator ( ~ )
*0*let VARexpr be the result of evaluating unaryexpression. 
*0*(S (Chunk let/VB VARexpr/NNP) be/VB the/DT result/NN of/IN evaluating/VBG unaryexpression/NN ./.)
*0*let VARoldvalue be ? FUNCtoint32(? FUNCgetvalue(VARexpr)). 
*0*(S (Chunk let/VB VARoldvalue/NNP) be/VB ?/. (Chunk FUNCtoint32/NNP) (/( ?/. (Chunk FUNCgetvalue/NNP) (/( (Chunk VARexpr/NNP) )/) )/) ./.)
*0*return the result of applying bitwise complement to VARoldvalue. the result is a signed 32-bit integer.     
*0*(S return/VB the/DT result/NN of/IN applying/VBG bitwise/NN complement/NN to/TO (Chunk VARoldvalue/NNP) ./. the/DT result/NN is/VBZ a/DT signed/JJ 32-bit/JJ integer/NN ./.)
ID= 12.5.9
Summary= Logical NOT Operator ( ! )
*0*let VARexpr be the result of evaluating unaryexpression. 
*0*(S (Chunk let/VB VARexpr/NNP) be/VB the/DT result/NN of/IN evaluating/VBG unaryexpression/NN ./.)
*0*let VARoldvalue be FUNCtoboolean(? FUNCgetvalue(VARexpr)). 
*0*(S (Chunk let/VB VARoldvalue/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCgetvalue/NNP) (/( (Chunk VARexpr/NNP) )/) )/) ./.)
*0*if VARoldvalue is true, return false. 
*0*(S if/IN (Chunk VARoldvalue/NNP) is/VBZ true/JJ ,/, return/NN false/JJ ./.)
*0*return true.     
*0*(S return/NN true/JJ ./.)
ID= 12.8.3
Summary= The Addition Operator ( + )
*0*let VARlref be the result of evaluating additiveexpression. 
*0*(S (Chunk let/VB VARlref/NNP) be/VB the/DT result/NN of/IN evaluating/VBG additiveexpression/NN ./.)
*0*let VARlval be ? FUNCgetvalue(VARlref). 
*0*(S (Chunk let/VB VARlval/NNP) be/VB ?/. (Chunk FUNCgetvalue/NNP) (/( (Chunk VARlref/NNP) )/) ./.)
*0*let VARrref be the result of evaluating multiplicativeexpression. 
*0*(S (Chunk let/VB VARrref/NNP) be/VB the/DT result/NN of/IN evaluating/VBG multiplicativeexpression/NN ./.)
*0*let VARrval be ? FUNCgetvalue(VARrref). 
*0*(S (Chunk let/VB VARrval/NNP) be/VB ?/. (Chunk FUNCgetvalue/NNP) (/( (Chunk VARrref/NNP) )/) ./.)
*0*let VARlprim be ? FUNCtoprimitive(VARlval). 
*0*(S (Chunk let/VB VARlprim/NNP) be/VB ?/. (Chunk FUNCtoprimitive/NNP) (/( (Chunk VARlval/NNP) )/) ./.)
*0*let VARrprim be ? FUNCtoprimitive(VARrval). 
*0*(S (Chunk let/VB VARrprim/NNP) be/VB ?/. (Chunk FUNCtoprimitive/NNP) (/( (Chunk VARrval/NNP) )/) ./.)
*0*if FUNCtype(VARlprim) is string or FUNCtype(VARrprim) is string, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARlprim/NNP) )/) is/VBZ string/VBG or/CC (Chunk FUNCtype/NNP) (/( (Chunk VARrprim/NNP) )/) is/VBZ string/VBG ,/, then/RB)
*1*let VARlstr be ? FUNCtostring(VARlprim). 
*1*(S (Chunk let/VB VARlstr/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARlprim/NNP) )/) ./.)
*1*let VARrstr be ? FUNCtostring(VARrprim). 
*1*(S (Chunk let/VB VARrstr/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARrprim/NNP) )/) ./.)
*1*return the string-concatenation of VARlstr and VARrstr. 
*1*(S return/VB the/DT string-concatenation/NN of/IN (Chunk VARlstr/NNP) and/CC (Chunk VARrstr/NNP) ./.)
*0*let VARlnum be ? FUNCtonumber(VARlprim). 
*0*(S (Chunk let/VB VARlnum/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARlprim/NNP) )/) ./.)
*0*let VARrnum be ? FUNCtonumber(VARrprim). 
*0*(S (Chunk let/VB VARrnum/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARrprim/NNP) )/) ./.)
*0*return the result of applying the addition operation to VARlnum and VARrnum. see the note below 12.8.5.     
*0*(S return/VB the/DT result/NN of/IN applying/VBG the/DT addition/NN operation/NN to/TO (Chunk VARlnum/NNP) and/CC (Chunk VARrnum/NNP) ./. see/VB the/DT note/NN below/IN 12.8.5/CD ./.)
ID= 12.8.4
Summary= The Subtraction Operator ( - )
*0*let VARlref be the result of evaluating additiveexpression. 
*0*(S (Chunk let/VB VARlref/NNP) be/VB the/DT result/NN of/IN evaluating/VBG additiveexpression/NN ./.)
*0*let VARlval be ? FUNCgetvalue(VARlref). 
*0*(S (Chunk let/VB VARlval/NNP) be/VB ?/. (Chunk FUNCgetvalue/NNP) (/( (Chunk VARlref/NNP) )/) ./.)
*0*let VARrref be the result of evaluating multiplicativeexpression. 
*0*(S (Chunk let/VB VARrref/NNP) be/VB the/DT result/NN of/IN evaluating/VBG multiplicativeexpression/NN ./.)
*0*let VARrval be ? FUNCgetvalue(VARrref). 
*0*(S (Chunk let/VB VARrval/NNP) be/VB ?/. (Chunk FUNCgetvalue/NNP) (/( (Chunk VARrref/NNP) )/) ./.)
*0*let VARlnum be ? FUNCtonumber(VARlval). 
*0*(S (Chunk let/VB VARlnum/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARlval/NNP) )/) ./.)
*0*let VARrnum be ? FUNCtonumber(VARrval). 
*0*(S (Chunk let/VB VARrnum/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARrval/NNP) )/) ./.)
*0*return the result of applying the subtraction operation to VARlnum and VARrnum. see the note below 12.8.5.     
*0*(S return/VB the/DT result/NN of/IN applying/VBG the/DT subtraction/NN operation/NN to/TO (Chunk VARlnum/NNP) and/CC (Chunk VARrnum/NNP) ./. see/VB the/DT note/NN below/IN 12.8.5/CD ./.)
ID= 12.9.3
Summary= The Left Shift Operator ( &lt;&lt; )
*0*let VARlref be the result of evaluating shiftexpression. 
*0*(S (Chunk let/VB VARlref/NNP) be/VB the/DT result/NN of/IN evaluating/VBG shiftexpression/NN ./.)
*0*let VARlval be ? FUNCgetvalue(VARlref). 
*0*(S (Chunk let/VB VARlval/NNP) be/VB ?/. (Chunk FUNCgetvalue/NNP) (/( (Chunk VARlref/NNP) )/) ./.)
*0*let VARrref be the result of evaluating additiveexpression. 
*0*(S (Chunk let/VB VARrref/NNP) be/VB the/DT result/NN of/IN evaluating/VBG additiveexpression/NN ./.)
*0*let VARrval be ? FUNCgetvalue(VARrref). 
*0*(S (Chunk let/VB VARrval/NNP) be/VB ?/. (Chunk FUNCgetvalue/NNP) (/( (Chunk VARrref/NNP) )/) ./.)
*0*let VARlnum be ? FUNCtoint32(VARlval). 
*0*(S (Chunk let/VB VARlnum/NNP) be/VB ?/. (Chunk FUNCtoint32/NNP) (/( (Chunk VARlval/NNP) )/) ./.)
*0*let VARrnum be ? FUNCtouint32(VARrval). 
*0*(S (Chunk let/VB VARrnum/NNP) be/VB ?/. (Chunk FUNCtouint32/NNP) (/( (Chunk VARrval/NNP) )/) ./.)
*0*let VARshiftcount be the result of masking out all but the least significant 5 bits of VARrnum, that is, compute VARrnum &amp; 0x1f. 
*0*(S (Chunk let/VB VARshiftcount/NNP) be/VB the/DT result/NN of/IN masking/VBG out/RP all/DT but/CC the/DT least/JJS significant/JJ 5/CD bits/NNS of/IN (Chunk VARrnum/NNP) ,/, that/WDT is/VBZ ,/, compute/JJ (Chunk VARrnum/NNP) &/CC amp/NN ;/: 0x1f/CD ./.)
*0*return the result of left shifting VARlnum by VARshiftcount bits. the result is a signed 32-bit integer.     
*0*(S return/VB the/DT result/NN of/IN left/NN (Chunk shifting/VBG VARlnum/NNP) by/IN (Chunk VARshiftcount/NNP) bits/NNS ./. the/DT result/NN is/VBZ a/DT signed/JJ 32-bit/JJ integer/NN ./.)
ID= 12.9.4
Summary= The Signed Right Shift Operator ( &gt;&gt; )
*0*let VARlref be the result of evaluating shiftexpression. 
*0*(S (Chunk let/VB VARlref/NNP) be/VB the/DT result/NN of/IN evaluating/VBG shiftexpression/NN ./.)
*0*let VARlval be ? FUNCgetvalue(VARlref). 
*0*(S (Chunk let/VB VARlval/NNP) be/VB ?/. (Chunk FUNCgetvalue/NNP) (/( (Chunk VARlref/NNP) )/) ./.)
*0*let VARrref be the result of evaluating additiveexpression. 
*0*(S (Chunk let/VB VARrref/NNP) be/VB the/DT result/NN of/IN evaluating/VBG additiveexpression/NN ./.)
*0*let VARrval be ? FUNCgetvalue(VARrref). 
*0*(S (Chunk let/VB VARrval/NNP) be/VB ?/. (Chunk FUNCgetvalue/NNP) (/( (Chunk VARrref/NNP) )/) ./.)
*0*let VARlnum be ? FUNCtoint32(VARlval). 
*0*(S (Chunk let/VB VARlnum/NNP) be/VB ?/. (Chunk FUNCtoint32/NNP) (/( (Chunk VARlval/NNP) )/) ./.)
*0*let VARrnum be ? FUNCtouint32(VARrval). 
*0*(S (Chunk let/VB VARrnum/NNP) be/VB ?/. (Chunk FUNCtouint32/NNP) (/( (Chunk VARrval/NNP) )/) ./.)
*0*let VARshiftcount be the result of masking out all but the least significant 5 bits of VARrnum, that is, compute VARrnum &amp; 0x1f. 
*0*(S (Chunk let/VB VARshiftcount/NNP) be/VB the/DT result/NN of/IN masking/VBG out/RP all/DT but/CC the/DT least/JJS significant/JJ 5/CD bits/NNS of/IN (Chunk VARrnum/NNP) ,/, that/WDT is/VBZ ,/, compute/JJ (Chunk VARrnum/NNP) &/CC amp/NN ;/: 0x1f/CD ./.)
*0*return the result of performing a sign-extending right shift of VARlnum by VARshiftcount bits. the most significant bit is propagated. the result is a signed 32-bit integer.     
*0*(S return/VB the/DT result/NN of/IN performing/VBG a/DT sign-extending/JJ right/JJ shift/NN of/IN (Chunk VARlnum/NNP) by/IN (Chunk VARshiftcount/NNP) bits/NNS ./. the/DT most/RBS significant/JJ bit/NN is/VBZ propagated/VBN ./. the/DT result/NN is/VBZ a/DT signed/JJ 32-bit/JJ integer/NN ./.)
ID= 12.9.5
Summary= The Unsigned Right Shift Operator ( &gt;&gt;&gt; )
*0*let VARlref be the result of evaluating shiftexpression. 
*0*(S (Chunk let/VB VARlref/NNP) be/VB the/DT result/NN of/IN evaluating/VBG shiftexpression/NN ./.)
*0*let VARlval be ? FUNCgetvalue(VARlref). 
*0*(S (Chunk let/VB VARlval/NNP) be/VB ?/. (Chunk FUNCgetvalue/NNP) (/( (Chunk VARlref/NNP) )/) ./.)
*0*let VARrref be the result of evaluating additiveexpression. 
*0*(S (Chunk let/VB VARrref/NNP) be/VB the/DT result/NN of/IN evaluating/VBG additiveexpression/NN ./.)
*0*let VARrval be ? FUNCgetvalue(VARrref). 
*0*(S (Chunk let/VB VARrval/NNP) be/VB ?/. (Chunk FUNCgetvalue/NNP) (/( (Chunk VARrref/NNP) )/) ./.)
*0*let VARlnum be ? FUNCtouint32(VARlval). 
*0*(S (Chunk let/VB VARlnum/NNP) be/VB ?/. (Chunk FUNCtouint32/NNP) (/( (Chunk VARlval/NNP) )/) ./.)
*0*let VARrnum be ? FUNCtouint32(VARrval). 
*0*(S (Chunk let/VB VARrnum/NNP) be/VB ?/. (Chunk FUNCtouint32/NNP) (/( (Chunk VARrval/NNP) )/) ./.)
*0*let VARshiftcount be the result of masking out all but the least significant 5 bits of VARrnum, that is, compute VARrnum &amp; 0x1f. 
*0*(S (Chunk let/VB VARshiftcount/NNP) be/VB the/DT result/NN of/IN masking/VBG out/RP all/DT but/CC the/DT least/JJS significant/JJ 5/CD bits/NNS of/IN (Chunk VARrnum/NNP) ,/, that/WDT is/VBZ ,/, compute/JJ (Chunk VARrnum/NNP) &/CC amp/NN ;/: 0x1f/CD ./.)
*0*return the result of performing a zero-filling right shift of VARlnum by VARshiftcount bits. vacated bits are filled with zero. the result is an unsigned 32-bit integer.     
*0*(S return/VB the/DT result/NN of/IN performing/VBG a/DT zero-filling/JJ right/JJ shift/NN of/IN (Chunk VARlnum/NNP) by/IN (Chunk VARshiftcount/NNP) bits/NNS ./. vacated/VBN bits/NNS are/VBP filled/VBN with/IN zero/NN ./. the/DT result/NN is/VBZ an/DT unsigned/JJ 32-bit/JJ integer/NN ./.)
ID= 12.10.4
Summary= Runtime Semantics: InstanceofOperator ( V, target )
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARinstofhandler be ? FUNCgetmethod(VARtarget, @@hasinstance). 
*0*(S (Chunk let/VB VARinstofhandler/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARtarget/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) hasinstance/NN )/) ./.)
*0*if VARinstofhandler is not undefined, then
*0*(S if/IN (Chunk VARinstofhandler/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*1*return FUNCtoboolean(? FUNCcall(VARinstofhandler, VARtarget, « VARv »)). 
*1*(S return/NN (Chunk FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARinstofhandler/NNP) ,/, (Chunk VARtarget/NNP) ,/, (Chunk «/NNP) (Chunk VARv/NNP) (Chunk »/NNP) )/) )/) ./.)
*0*if FUNCiscallable(VARtarget) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return ? FUNCordinaryhasinstance(VARtarget, VARv).    
*0*(S return/NN ?/. (Chunk FUNCordinaryhasinstance/NNP) (/( (Chunk VARtarget/NNP) ,/, (Chunk VARv/NNP) )/) ./.)
ID= 12.14
Summary= Conditional Operator ( ? : )
*0*return false.    
*0*(S return/NN false/JJ ./.)
ID= 12.16
Summary= Comma Operator ( , )
*0*return false.    
*0*(S return/NN false/JJ ./.)
ID= 13.2.14
Summary= Runtime Semantics: BlockDeclarationInstantiation ( code, env )
*0*let VARenvrec be VARenv's environmentrecord. 
*0*(S (Chunk let/VB VARenvrec/NNP) (Chunk be/VB VARenv/NNP) 's/POS environmentrecord/NN ./.)
*0*assert: VARenvrec is a declarative environment record. 
*0*(S assert/NN :/: (Chunk VARenvrec/NNP) is/VBZ a/DT declarative/JJ environment/NN record/NN ./.)
*0*let VARdeclarations be the lexicallyscopeddeclarations of VARcode. 
*0*(S (Chunk let/VB VARdeclarations/NNP) be/VB the/DT lexicallyscopeddeclarations/NNS of/IN (Chunk VARcode/NNP) ./.)
*0*for each element VARd in VARdeclarations, do
*0*(S for/IN each/DT element/NN (Chunk VARd/NNP) in/IN (Chunk VARdeclarations/NNP) ,/, do/VBP)
*1*for each element VARdn of the boundnames of VARd, do
*1*(S for/IN each/DT element/NN (Chunk VARdn/NNP) of/IN the/DT boundnames/NNS of/IN (Chunk VARd/NNP) ,/, do/VBP)
*2*if isconstantdeclaration of VARd is true, then
*2*(S if/IN isconstantdeclaration/NN of/IN (Chunk VARd/NNP) is/VBZ true/JJ ,/, then/RB)
*3*perform ! VARenvrec.createimmutablebinding(VARdn, true). 
*3*(S perform/NN !/. (Chunk VARenvrec.createimmutablebinding/NNP) (/( (Chunk VARdn/NNP) ,/, true/JJ )/) ./.)
*2*else,
*2*(S else/RB ,/,)
*3*perform ! VARenvrec.createmutablebinding(VARdn, false). 
*3*(S perform/NN !/. (Chunk VARenvrec.createmutablebinding/NNP) (/( (Chunk VARdn/NNP) ,/, false/RB )/) ./.)
*1*if VARd is a functiondeclaration, a generatordeclaration, an asyncfunctiondeclaration, or an asyncgeneratordeclaration, then
*1*(S if/IN (Chunk VARd/NNP) is/VBZ a/DT functiondeclaration/NN ,/, a/DT generatordeclaration/NN ,/, an/DT asyncfunctiondeclaration/NN ,/, or/CC an/DT asyncgeneratordeclaration/NN ,/, then/RB)
*2*let VARfn be the sole element of the boundnames of VARd. 
*2*(S (Chunk let/VB VARfn/NNP) be/VB the/DT sole/JJ element/NN of/IN the/DT boundnames/NNS of/IN (Chunk VARd/NNP) ./.)
*2*let VARfo be the result of performing instantiatefunctionobject for VARd with argument VARenv. 
*2*(S (Chunk let/VB VARfo/NNP) be/VB the/DT result/NN of/IN performing/VBG instantiatefunctionobject/NN for/IN (Chunk VARd/NNP) with/IN argument/NN (Chunk VARenv/NNP) ./.)
*2*perform VARenvrec.initializebinding(VARfn, VARfo).    
*2*(S perform/NN (Chunk VARenvrec.initializebinding/NNP) (/( (Chunk VARfn/NNP) ,/, (Chunk VARfo/NNP) )/) ./.)
ID= 13.7.1.2
Summary= Runtime Semantics: LoopContinues ( completion, labelSet )
*0*if VARcompletion.[[TYPE]] is normal, return true. 
*0*(S if/IN (Chunk VARcompletion/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ normal/JJ ,/, return/VB true/JJ ./.)
*0*if VARcompletion.[[TYPE]] is not continue, return false. 
*0*(S if/IN (Chunk VARcompletion/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB continue/JJ ,/, return/VB false/JJ ./.)
*0*if VARcompletion.[[TARGET]] is empty, return true. 
*0*(S if/IN (Chunk VARcompletion/NNP) ./. [/VB [/JJ (Chunk TARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ empty/JJ ,/, return/VB true/JJ ./.)
*0*if VARcompletion.[[TARGET]] is an element of VARlabelset, return true. 
*0*(S if/IN (Chunk VARcompletion/NNP) ./. [/VB [/JJ (Chunk TARGET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ an/DT element/NN of/IN (Chunk VARlabelset/NNP) ,/, return/NN true/JJ ./.)
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 13.7.4.8
Summary= Runtime Semantics: ForBodyEvaluation ( test, increment, stmt, perIterationBindings, labelSet )
*0*let VARv be undefined. 
*0*(S (Chunk let/VB VARv/NNP) be/VB undefined/VBN ./.)
*0*perform ? FUNCcreateperiterationenvironment(VARperiterationbindings). 
*0*(S perform/NN ?/. (Chunk FUNCcreateperiterationenvironment/NNP) (/( (Chunk VARperiterationbindings/NNP) )/) ./.)
*0*repeat,
*0*(S repeat/NN ,/,)
*1*if VARtest is not [empty], then
*1*(S if/IN (Chunk VARtest/NNP) is/VBZ not/RB [/JJ empty/JJ ]/NN ,/, then/RB)
*2*let VARtestref be the result of evaluating VARtest. 
*2*(S (Chunk let/VB VARtestref/NNP) be/VB the/DT result/NN of/IN (Chunk evaluating/VBG VARtest/NNP) ./.)
*2*let VARtestvalue be ? FUNCgetvalue(VARtestref). 
*2*(S (Chunk let/VB VARtestvalue/NNP) be/VB ?/. (Chunk FUNCgetvalue/NNP) (/( (Chunk VARtestref/NNP) )/) ./.)
*2*if FUNCtoboolean(VARtestvalue) is false, return FUNCnormalcompletion(VARv). 
*2*(S if/IN (Chunk FUNCtoboolean/NNP) (/( (Chunk VARtestvalue/NNP) )/) is/VBZ false/JJ ,/, return/JJ (Chunk FUNCnormalcompletion/NNP) (/( (Chunk VARv/NNP) )/) ./.)
*1*let VARresult be the result of evaluating VARstmt. 
*1*(S (Chunk let/VB VARresult/NNP) be/VB the/DT result/NN of/IN (Chunk evaluating/VBG VARstmt/NNP) ./.)
*1*if FUNCloopcontinues(VARresult, VARlabelset) is false, return FUNCcompletion(FUNCupdateempty(VARresult, VARv)). 
*1*(S if/IN (Chunk FUNCloopcontinues/NNP) (/( (Chunk VARresult/NNP) ,/, (Chunk VARlabelset/NNP) )/) is/VBZ false/JJ ,/, return/JJ (Chunk FUNCcompletion/NNP) (/( (Chunk FUNCupdateempty/NNP) (/( (Chunk VARresult/NNP) ,/, (Chunk VARv/NNP) )/) )/) ./.)
*1*if VARresult.[[VALUE]] is not empty, set VARv to VARresult.[[VALUE]]. 
*1*(S if/IN (Chunk VARresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB empty/JJ ,/, (Chunk set/VBN VARv/NNP) to/TO (Chunk VARresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*perform ? FUNCcreateperiterationenvironment(VARperiterationbindings). 
*1*(S perform/NN ?/. (Chunk FUNCcreateperiterationenvironment/NNP) (/( (Chunk VARperiterationbindings/NNP) )/) ./.)
*1*if VARincrement is not [empty], then
*1*(S if/IN (Chunk VARincrement/NNP) is/VBZ not/RB [/JJ empty/JJ ]/NN ,/, then/RB)
*2*let VARincref be the result of evaluating VARincrement. 
*2*(S (Chunk let/VB VARincref/NNP) be/VB the/DT result/NN of/IN (Chunk evaluating/VBG VARincrement/NNP) ./.)
*2*perform ? FUNCgetvalue(VARincref).     
*2*(S perform/NN ?/. (Chunk FUNCgetvalue/NNP) (/( (Chunk VARincref/NNP) )/) ./.)
ID= 13.7.4.9
Summary= Runtime Semantics: CreatePerIterationEnvironment ( perIterationBindings )
*0*if VARperiterationbindings has any elements, then
*0*(S if/IN (Chunk VARperiterationbindings/NNP) has/VBZ any/DT elements/NNS ,/, then/RB)
*1*let VARlastiterationenv be the running execution context's lexicalenvironment. 
*1*(S (Chunk let/VB VARlastiterationenv/NNP) be/VB the/DT running/JJ execution/NN context/NN 's/POS lexicalenvironment/NN ./.)
*1*let VARlastiterationenvrec be VARlastiterationenv's environmentrecord. 
*1*(S (Chunk let/VB VARlastiterationenvrec/NNP) (Chunk be/VB VARlastiterationenv/NNP) 's/POS environmentrecord/NN ./.)
*1*let VARouter be VARlastiterationenv's outer environment reference. 
*1*(S (Chunk let/VB VARouter/NNP) (Chunk be/VB VARlastiterationenv/NNP) 's/POS outer/NN environment/NN reference/NN ./.)
*1*assert: VARouter is not null. 
*1*(S assert/NN :/: VARouter/NN is/VBZ not/RB null/JJ ./.)
*1*let VARthisiterationenv be FUNCnewdeclarativeenvironment(VARouter). 
*1*(S (Chunk let/VB VARthisiterationenv/NNP) (Chunk be/VB FUNCnewdeclarativeenvironment/NNP) (/( (Chunk VARouter/NNP) )/) ./.)
*1*let VARthisiterationenvrec be VARthisiterationenv's environmentrecord. 
*1*(S (Chunk let/VB VARthisiterationenvrec/NNP) (Chunk be/VB VARthisiterationenv/NNP) 's/POS environmentrecord/NN ./.)
*1*for each element VARbn of VARperiterationbindings, do
*1*(S for/IN each/DT element/NN (Chunk VARbn/NNP) of/IN (Chunk VARperiterationbindings/NNP) ,/, do/VBP)
*2*perform ! VARthisiterationenvrec.createmutablebinding(VARbn, false). 
*2*(S perform/NN !/. (Chunk VARthisiterationenvrec.createmutablebinding/NNP) (/( (Chunk VARbn/NNP) ,/, false/RB )/) ./.)
*2*let VARlastvalue be ? VARlastiterationenvrec.getbindingvalue(VARbn, true). 
*2*(S (Chunk let/VB VARlastvalue/NNP) be/VB ?/. (Chunk VARlastiterationenvrec.getbindingvalue/NNP) (/( (Chunk VARbn/NNP) ,/, true/JJ )/) ./.)
*2*perform VARthisiterationenvrec.initializebinding(VARbn, VARlastvalue). 
*2*(S perform/NN (Chunk VARthisiterationenvrec.initializebinding/NNP) (/( (Chunk VARbn/NNP) ,/, (Chunk VARlastvalue/NNP) )/) ./.)
*1*set the running execution context's lexicalenvironment to VARthisiterationenv. 
*1*(S set/VB the/DT running/JJ execution/NN context/NN 's/POS lexicalenvironment/NN to/TO (Chunk VARthisiterationenv/NNP) ./.)
*0*return undefined.     
*0*(S return/NN undefined/VBD ./.)
ID= 13.7.5.12
Summary= Runtime Semantics: ForIn/OfHeadEvaluation ( TDZnames, expr, iterationKind )
*0*let VARoldenv be the running execution context's lexicalenvironment. 
*0*(S (Chunk let/VB VARoldenv/NNP) be/VB the/DT running/JJ execution/NN context/NN 's/POS lexicalenvironment/NN ./.)
*0*if VARtdznames is not an empty list, then
*0*(S if/IN (Chunk VARtdznames/NNP) is/VBZ not/RB an/DT empty/JJ list/NN ,/, then/RB)
*1*assert: VARtdznames has no duplicate entries. 
*1*(S assert/NN :/: (Chunk VARtdznames/NNP) has/VBZ no/DT duplicate/NN entries/NNS ./.)
*1*let VARtdz be FUNCnewdeclarativeenvironment(VARoldenv). 
*1*(S (Chunk let/VB VARtdz/NNP) (Chunk be/VB FUNCnewdeclarativeenvironment/NNP) (/( (Chunk VARoldenv/NNP) )/) ./.)
*1*let VARtdzenvrec be VARtdz's environmentrecord. 
*1*(S (Chunk let/VB VARtdzenvrec/NNP) (Chunk be/VB VARtdz/NNP) 's/POS environmentrecord/NN ./.)
*1*for each string VARname in VARtdznames, do
*1*(S for/IN each/DT string/NN (Chunk VARname/NNP) in/IN (Chunk VARtdznames/NNP) ,/, do/VBP)
*2*perform ! VARtdzenvrec.createmutablebinding(VARname, false). 
*2*(S perform/NN !/. (Chunk VARtdzenvrec.createmutablebinding/NNP) (/( (Chunk VARname/NNP) ,/, false/RB )/) ./.)
*1*set the running execution context's lexicalenvironment to VARtdz. 
*1*(S set/VB the/DT running/JJ execution/NN context/NN 's/POS lexicalenvironment/NN to/TO (Chunk VARtdz/NNP) ./.)
*0*let VARexprref be the result of evaluating VARexpr. 
*0*(S (Chunk let/VB VARexprref/NNP) be/VB the/DT result/NN of/IN (Chunk evaluating/VBG VARexpr/NNP) ./.)
*0*set the running execution context's lexicalenvironment to VARoldenv. 
*0*(S set/VB the/DT running/JJ execution/NN context/NN 's/POS lexicalenvironment/NN to/TO (Chunk VARoldenv/NNP) ./.)
*0*let VARexprvalue be ? FUNCgetvalue(VARexprref). 
*0*(S (Chunk let/VB VARexprvalue/NNP) be/VB ?/. (Chunk FUNCgetvalue/NNP) (/( (Chunk VARexprref/NNP) )/) ./.)
*0*if VARiterationkind is enumerate, then
*0*(S if/IN (Chunk VARiterationkind/NNP) is/VBZ enumerate/JJ ,/, then/RB)
*1*if VARexprvalue is undefined or null, then
*1*(S if/IN (Chunk VARexprvalue/NNP) is/VBZ undefined/JJ or/CC null/JJ ,/, then/RB)
*2*return completion { [[TYPE]]: break, [[VALUE]]: empty, [[TARGET]]: empty }. 
*2*(S return/NN completion/NN {/( [/JJ (Chunk [/NNP) (Chunk TYPE/NNP) (Chunk ]/NNP) ]/NN :/: break/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: empty/JJ ,/, [/JJ (Chunk [/NNP) (Chunk TARGET/NNP) (Chunk ]/NNP) ]/NN :/: empty/JJ }/) ./.)
*1*let VARobj be ! FUNCtoobject(VARexprvalue). 
*1*(S (Chunk let/VB VARobj/NNP) be/VB !/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARexprvalue/NNP) )/) ./.)
*1*return ? FUNCenumerateobjectproperties(VARobj). 
*1*(S return/NN ?/. FUNCenumerateobjectproperties/NNS (/( (Chunk VARobj/NNP) )/) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*assert: VARiterationkind is iterate. 
*1*(S assert/NN :/: (Chunk VARiterationkind/NNP) is/VBZ iterate/JJ ./.)
*1*if VARiterationkind is async-iterate, let VARiteratorhint be async. 
*1*(S if/IN (Chunk VARiterationkind/NNP) is/VBZ async-iterate/JJ ,/, (Chunk let/VB VARiteratorhint/NNP) be/VB async/VBN ./.)
*1*else, let VARiteratorhint be sync. 
*1*(S else/RB ,/, (Chunk let/VB VARiteratorhint/NNP) be/VB sync/VBN ./.)
*1*return ? FUNCgetiterator(VARexprvalue, VARiteratorhint).     
*1*(S return/NN ?/. (Chunk FUNCgetiterator/NNP) (/( (Chunk VARexprvalue/NNP) ,/, (Chunk VARiteratorhint/NNP) )/) ./.)
ID= 13.7.5.13
Summary= Runtime Semantics: ForIn/OfBodyEvaluation ( lhs, stmt, iteratorRecord, iterationKind, lhsKind, labelSet [ , iteratorKind ] )
*0*if VARiteratorkind is not present, set VARiteratorkind to sync. 
*0*(S if/IN (Chunk VARiteratorkind/NNP) is/VBZ not/RB present/JJ ,/, (Chunk set/VBN VARiteratorkind/NNP) to/TO sync/VB ./.)
*0*let VARoldenv be the running execution context's lexicalenvironment. 
*0*(S (Chunk let/VB VARoldenv/NNP) be/VB the/DT running/JJ execution/NN context/NN 's/POS lexicalenvironment/NN ./.)
*0*let VARv be undefined. 
*0*(S (Chunk let/VB VARv/NNP) be/VB undefined/VBN ./.)
*0*let VARdestructuring be isdestructuring of VARlhs. 
*0*(S (Chunk let/VB VARdestructuring/NNP) be/VB isdestructuring/VBG of/IN (Chunk VARlhs/NNP) ./.)
*0*if VARdestructuring is true and if VARlhskind is assignment, then
*0*(S if/IN (Chunk VARdestructuring/NNP) is/VBZ true/JJ and/CC if/IN (Chunk VARlhskind/NNP) is/VBZ assignment/JJ ,/, then/RB)
*1*assert: VARlhs is a lefthandsideexpression. 
*1*(S assert/NN :/: (Chunk VARlhs/NNP) is/VBZ a/DT lefthandsideexpression/NN ./.)
*1*let VARassignmentpattern be the assignmentpattern that is covered by VARlhs. 
*1*(S (Chunk let/VB VARassignmentpattern/NNP) be/VB the/DT assignmentpattern/JJ that/WDT is/VBZ covered/VBN by/IN (Chunk VARlhs/NNP) ./.)
*0*repeat,
*0*(S repeat/NN ,/,)
*1*let VARnextresult be ? FUNCcall(VARiteratorrecord.[[NEXTMETHOD]], VARiteratorrecord.[[ITERATOR]], « »). 
*1*(S (Chunk let/VB VARnextresult/NNP) be/VB ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARiteratorrecord/NNP) ./. [/VB [/JJ (Chunk NEXTMETHOD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARiteratorrecord/NNP) ./. [/VB [/JJ (Chunk ITERATOR/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk «/NNP) (Chunk »/NNP) )/) ./.)
*1*if VARiteratorkind is async, then set VARnextresult to ? await(VARnextresult). 
*1*(S if/IN (Chunk VARiteratorkind/NNP) is/VBZ async/RB ,/, (Chunk then/RB set/VB VARnextresult/NNP) to/TO ?/. await/NN (/( (Chunk VARnextresult/NNP) )/) ./.)
*1*if FUNCtype(VARnextresult) is not object, throw a typeerror exception. 
*1*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARnextresult/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*let VARnextvalue be ? FUNCiteratorvalue(VARnextresult). 
*1*(S (Chunk let/VB VARnextvalue/NNP) be/VB ?/. (Chunk FUNCiteratorvalue/NNP) (/( (Chunk VARnextresult/NNP) )/) ./.)
*1*if VARlhskind is either assignment or varbinding, then
*1*(S if/IN (Chunk VARlhskind/NNP) is/VBZ either/DT assignment/NN or/CC varbinding/NN ,/, then/RB)
*2*if VARdestructuring is false, then
*2*(S if/IN (Chunk VARdestructuring/NNP) is/VBZ false/JJ ,/, then/RB)
*3*let VARlhsref be the result of evaluating VARlhs. (it may be evaluated repeatedly.) 
*3*(S (Chunk let/VB VARlhsref/NNP) be/VB the/DT result/NN of/IN (Chunk evaluating/VBG VARlhs/NNP) ./. (/( it/PRP may/MD be/VB evaluated/VBN repeatedly/RB ./. )/))
*1*else,
*1*(S else/RB ,/,)
*2*assert: VARlhskind is lexicalbinding. 
*2*(S assert/NN :/: (Chunk VARlhskind/NNP) is/VBZ lexicalbinding/VBG ./.)
*2*assert: VARlhs is a fordeclaration. 
*2*(S assert/NN :/: (Chunk VARlhs/NNP) is/VBZ a/DT fordeclaration/NN ./.)
*2*let VARiterationenv be FUNCnewdeclarativeenvironment(VARoldenv). 
*2*(S (Chunk let/VB VARiterationenv/NNP) (Chunk be/VB FUNCnewdeclarativeenvironment/NNP) (/( (Chunk VARoldenv/NNP) )/) ./.)
*2*perform bindinginstantiation for VARlhs passing VARiterationenv as the argument. 
*2*(S perform/NN bindinginstantiation/NN for/IN (Chunk VARlhs/NNP) (Chunk passing/VBG VARiterationenv/NNP) as/IN the/DT argument/NN ./.)
*2*set the running execution context's lexicalenvironment to VARiterationenv. 
*2*(S set/VB the/DT running/JJ execution/NN context/NN 's/POS lexicalenvironment/NN to/TO (Chunk VARiterationenv/NNP) ./.)
*2*if VARdestructuring is false, then
*2*(S if/IN (Chunk VARdestructuring/NNP) is/VBZ false/JJ ,/, then/RB)
*3*assert: VARlhs binds a single name. 
*3*(S assert/NN :/: (Chunk VARlhs/NNP) binds/VBZ a/DT single/JJ name/NN ./.)
*3*let VARlhsname be the sole element of boundnames of VARlhs. 
*3*(S (Chunk let/VB VARlhsname/NNP) be/VB the/DT sole/JJ element/NN of/IN boundnames/NNS of/IN (Chunk VARlhs/NNP) ./.)
*3*let VARlhsref be ! FUNCresolvebinding(VARlhsname). 
*3*(S (Chunk let/VB VARlhsref/NNP) be/VB !/. (Chunk FUNCresolvebinding/NNP) (/( (Chunk VARlhsname/NNP) )/) ./.)
*1*if VARdestructuring is false, then
*1*(S if/IN (Chunk VARdestructuring/NNP) is/VBZ false/JJ ,/, then/RB)
*2*if VARlhsref is an abrupt completion, then
*2*(S if/IN (Chunk VARlhsref/NNP) is/VBZ an/DT abrupt/JJ completion/NN ,/, then/RB)
*3*let VARstatus be VARlhsref. 
*3*(S (Chunk let/VB VARstatus/NNP) (Chunk be/VB VARlhsref/NNP) ./.)
*2*else if VARlhskind is lexicalbinding, then
*2*(S else/RB if/IN (Chunk VARlhskind/NNP) is/VBZ lexicalbinding/VBG ,/, then/RB)
*3*let VARstatus be FUNCinitializereferencedbinding(VARlhsref, VARnextvalue). 
*3*(S (Chunk let/VB VARstatus/NNP) (Chunk be/VB FUNCinitializereferencedbinding/NNP) (/( (Chunk VARlhsref/NNP) ,/, (Chunk VARnextvalue/NNP) )/) ./.)
*2*else,
*2*(S else/RB ,/,)
*3*let VARstatus be FUNCputvalue(VARlhsref, VARnextvalue). 
*3*(S (Chunk let/VB VARstatus/NNP) (Chunk be/VB FUNCputvalue/NNP) (/( (Chunk VARlhsref/NNP) ,/, (Chunk VARnextvalue/NNP) )/) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*if VARlhskind is assignment, then
*2*(S if/IN (Chunk VARlhskind/NNP) is/VBZ assignment/JJ ,/, then/RB)
*3*let VARstatus be the result of performing destructuringassignmentevaluation of VARassignmentpattern using VARnextvalue as the argument. 
*3*(S (Chunk let/VB VARstatus/NNP) be/VB the/DT result/NN of/IN performing/VBG destructuringassignmentevaluation/NN of/IN (Chunk VARassignmentpattern/NNP) (Chunk using/VBG VARnextvalue/NNP) as/IN the/DT argument/NN ./.)
*2*else if VARlhskind is varbinding, then
*2*(S else/RB if/IN (Chunk VARlhskind/NNP) is/VBZ varbinding/VBG ,/, then/RB)
*3*assert: VARlhs is a forbinding. 
*3*(S assert/NN :/: (Chunk VARlhs/NNP) is/VBZ a/DT forbinding/NN ./.)
*3*let VARstatus be the result of performing bindinginitialization for VARlhs passing VARnextvalue and undefined as the arguments. 
*3*(S (Chunk let/VB VARstatus/NNP) be/VB the/DT result/NN of/IN performing/VBG bindinginitialization/NN for/IN (Chunk VARlhs/NNP) (Chunk passing/VBG VARnextvalue/NNP) and/CC undefined/VBD as/IN the/DT arguments/NNS ./.)
*2*else,
*2*(S else/RB ,/,)
*3*assert: VARlhskind is lexicalbinding. 
*3*(S assert/NN :/: (Chunk VARlhskind/NNP) is/VBZ lexicalbinding/VBG ./.)
*3*assert: VARlhs is a fordeclaration. 
*3*(S assert/NN :/: (Chunk VARlhs/NNP) is/VBZ a/DT fordeclaration/NN ./.)
*3*let VARstatus be the result of performing bindinginitialization for VARlhs passing VARnextvalue and VARiterationenv as arguments. 
*3*(S (Chunk let/VB VARstatus/NNP) be/VB the/DT result/NN of/IN performing/VBG bindinginitialization/NN for/IN (Chunk VARlhs/NNP) (Chunk passing/VBG VARnextvalue/NNP) and/CC (Chunk VARiterationenv/NNP) as/IN arguments/NNS ./.)
*1*if VARstatus is an abrupt completion, then
*1*(S if/IN (Chunk VARstatus/NNP) is/VBZ an/DT abrupt/JJ completion/NN ,/, then/RB)
*2*set the running execution context's lexicalenvironment to VARoldenv. 
*2*(S set/VB the/DT running/JJ execution/NN context/NN 's/POS lexicalenvironment/NN to/TO (Chunk VARoldenv/NNP) ./.)
*2*if VARiteratorkind is async, return ? FUNCasynciteratorclose(VARiteratorrecord, VARstatus). 
*2*(S if/IN (Chunk VARiteratorkind/NNP) is/VBZ async/JJ ,/, return/VB ?/. (Chunk FUNCasynciteratorclose/NNP) (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARstatus/NNP) )/) ./.)
*2*if VARiterationkind is enumerate, then
*2*(S if/IN (Chunk VARiterationkind/NNP) is/VBZ enumerate/JJ ,/, then/RB)
*3*return VARstatus. 
*3*(S return/NN (Chunk VARstatus/NNP) ./.)
*2*else,
*2*(S else/RB ,/,)
*3*assert: VARiterationkind is iterate. 
*3*(S assert/NN :/: (Chunk VARiterationkind/NNP) is/VBZ iterate/JJ ./.)
*3*return ? FUNCiteratorclose(VARiteratorrecord, VARstatus). 
*3*(S return/NN ?/. (Chunk FUNCiteratorclose/NNP) (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARstatus/NNP) )/) ./.)
*1*let VARresult be the result of evaluating VARstmt. 
*1*(S (Chunk let/VB VARresult/NNP) be/VB the/DT result/NN of/IN (Chunk evaluating/VBG VARstmt/NNP) ./.)
*1*set the running execution context's lexicalenvironment to VARoldenv. 
*1*(S set/VB the/DT running/JJ execution/NN context/NN 's/POS lexicalenvironment/NN to/TO (Chunk VARoldenv/NNP) ./.)
*1*if FUNCloopcontinues(VARresult, VARlabelset) is false, then
*1*(S if/IN (Chunk FUNCloopcontinues/NNP) (/( (Chunk VARresult/NNP) ,/, (Chunk VARlabelset/NNP) )/) is/VBZ false/JJ ,/, then/RB)
*2*if VARiterationkind is enumerate, then
*2*(S if/IN (Chunk VARiterationkind/NNP) is/VBZ enumerate/JJ ,/, then/RB)
*3*return FUNCcompletion(FUNCupdateempty(VARresult, VARv)). 
*3*(S return/NN (Chunk FUNCcompletion/NNP) (/( (Chunk FUNCupdateempty/NNP) (/( (Chunk VARresult/NNP) ,/, (Chunk VARv/NNP) )/) )/) ./.)
*2*else,
*2*(S else/RB ,/,)
*3*assert: VARiterationkind is iterate. 
*3*(S assert/NN :/: (Chunk VARiterationkind/NNP) is/VBZ iterate/JJ ./.)
*3*set VARstatus to FUNCupdateempty(VARresult, VARv). 
*3*(S (Chunk set/VBN VARstatus/NNP) to/TO (Chunk FUNCupdateempty/NNP) (/( (Chunk VARresult/NNP) ,/, (Chunk VARv/NNP) )/) ./.)
*3*if VARiteratorkind is async, return ? FUNCasynciteratorclose(VARiteratorrecord, VARstatus). 
*3*(S if/IN (Chunk VARiteratorkind/NNP) is/VBZ async/JJ ,/, return/VB ?/. (Chunk FUNCasynciteratorclose/NNP) (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARstatus/NNP) )/) ./.)
*3*return ? FUNCiteratorclose(VARiteratorrecord, VARstatus). 
*3*(S return/NN ?/. (Chunk FUNCiteratorclose/NNP) (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARstatus/NNP) )/) ./.)
*1*if VARresult.[[VALUE]] is not empty, set VARv to VARresult.[[VALUE]].     
*1*(S if/IN (Chunk VARresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB empty/JJ ,/, (Chunk set/VBN VARv/NNP) to/TO (Chunk VARresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
ID= 13.7.5.15
Summary= EnumerateObjectProperties ( O )
*0*assert: FUNCtype(VARo) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ object/JJ ./.)
*0*return an iterator object (25.1.1.2) whose next method iterates over all the string-valued keys of enumerable properties of VARo. the iterator object is never directly accessible to ecmascript code. the mechanics and order of enumerating the properties is not specified but must conform to the rules specified below.     
*0*(S return/VB an/DT iterator/NN object/NN (/( 25.1.1.2/CD )/) whose/WP$ next/JJ method/NN iterates/VBZ over/IN all/PDT the/DT string-valued/JJ keys/NNS of/IN enumerable/JJ properties/NNS of/IN (Chunk VARo/NNP) ./. the/DT iterator/NN object/NN is/VBZ never/RB directly/RB accessible/JJ to/TO ecmascript/VB code/NN ./. the/DT mechanics/NNS and/CC order/NN of/IN enumerating/VBG the/DT properties/NNS is/VBZ not/RB specified/VBN but/CC must/MD conform/VB to/TO the/DT rules/NNS specified/VBN below/IN ./.)
ID= 13.12.10
Summary= Runtime Semantics: CaseClauseIsSelected ( C, input )
*0*assert: VARc is an instance of the production caseclause:caseexpression:statementlistopt. 
*0*(S assert/NN :/: (Chunk VARc/NNP) is/VBZ an/DT instance/NN of/IN the/DT production/NN caseclause/NN :/: caseexpression/NN :/: statementlistopt/NN ./.)
*0*let VARexprref be the result of evaluating the expression of VARc. 
*0*(S (Chunk let/VB VARexprref/NNP) be/VB the/DT result/NN of/IN evaluating/VBG the/DT expression/NN of/IN (Chunk VARc/NNP) ./.)
*0*let VARclauseselector be ? FUNCgetvalue(VARexprref). 
*0*(S (Chunk let/VB VARclauseselector/NNP) be/VB ?/. (Chunk FUNCgetvalue/NNP) (/( (Chunk VARexprref/NNP) )/) ./.)
*0*return the result of performing strict equality comparison VARinput === VARclauseselector.    
*0*(S return/VB the/DT result/NN of/IN performing/VBG strict/JJ equality/NN comparison/NN (Chunk VARinput/NNP) (Chunk ===/NNP) (Chunk VARclauseselector/NNP) ./.)
ID= 13.13.5
Summary= Static Semantics: IsLabelledFunction ( stmt )
*0*if VARstmt is not a labelledstatement, return false. 
*0*(S if/IN (Chunk VARstmt/NNP) is/VBZ not/RB a/DT labelledstatement/NN ,/, return/NN false/JJ ./.)
*0*let VARitem be the labelleditem of VARstmt. 
*0*(S (Chunk let/VB VARitem/NNP) be/VB the/DT labelleditem/NN of/IN (Chunk VARstmt/NNP) ./.)
*0*if VARitem is labelleditem:functiondeclaration , return true. 
*0*(S if/IN (Chunk VARitem/NNP) is/VBZ labelleditem/JJ :/: functiondeclaration/NN ,/, return/NN true/JJ ./.)
*0*let VARsubstmt be the statement of VARitem. 
*0*(S (Chunk let/VB VARsubstmt/NNP) be/VB the/DT statement/NN of/IN (Chunk VARitem/NNP) ./.)
*0*return FUNCislabelledfunction(VARsubstmt).    
*0*(S return/NN (Chunk FUNCislabelledfunction/NNP) (/( (Chunk VARsubstmt/NNP) )/) ./.)
ID= 14.1.10
Summary= Static Semantics: IsAnonymousFunctionDefinition ( expr )
*0*if isfunctiondefinition of VARexpr is false, return false. 
*0*(S if/IN isfunctiondefinition/NN of/IN (Chunk VARexpr/NNP) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*0*let VARhasname be the result of hasname of VARexpr. 
*0*(S (Chunk let/VB VARhasname/NNP) be/VB the/DT result/NN of/IN hasname/NN of/IN (Chunk VARexpr/NNP) ./.)
*0*if VARhasname is true, return false. 
*0*(S if/IN (Chunk VARhasname/NNP) is/VBZ true/JJ ,/, return/NN false/JJ ./.)
*0*return true.    
*0*(S return/NN true/JJ ./.)
ID= 14.9.1
Summary= Static Semantics: IsInTailPosition ( call )
*0*assert: VARcall is a parse node. 
*0*(S assert/NN :/: VARcall/NN is/VBZ a/DT parse/JJ node/NN ./.)
*0*if the source code matching VARcall is non-strict code, return false. 
*0*(S if/IN the/DT source/NN code/NN (Chunk matching/VBG VARcall/NNP) is/VBZ non-strict/JJ code/NN ,/, return/NN false/JJ ./.)
*0*if VARcall is not contained within a functionbody, concisebody, or asyncconcisebody, return false. 
*0*(S if/IN (Chunk VARcall/NNP) is/VBZ not/RB contained/VBN within/IN a/DT functionbody/NN ,/, concisebody/NN ,/, or/CC asyncconcisebody/NN ,/, return/NN false/JJ ./.)
*0*let VARbody be the functionbody, concisebody, or asyncconcisebody that most closely contains VARcall. 
*0*(S (Chunk let/VB VARbody/NNP) be/VB the/DT functionbody/NN ,/, concisebody/NN ,/, or/CC asyncconcisebody/NN that/IN most/JJS (Chunk closely/RB contains/VBZ VARcall/NNP) ./.)
*0*if VARbody is the functionbody of a generatorbody, return false. 
*0*(S if/IN (Chunk VARbody/NNP) is/VBZ the/DT functionbody/NN of/IN a/DT generatorbody/NN ,/, return/NN false/JJ ./.)
*0*if VARbody is the functionbody of an asyncfunctionbody, return false. 
*0*(S if/IN (Chunk VARbody/NNP) is/VBZ the/DT functionbody/NN of/IN an/DT asyncfunctionbody/NN ,/, return/NN false/JJ ./.)
*0*if VARbody is the functionbody of an asyncgeneratorbody, return false. 
*0*(S if/IN (Chunk VARbody/NNP) is/VBZ the/DT functionbody/NN of/IN an/DT asyncgeneratorbody/NN ,/, return/NN false/JJ ./.)
*0*if VARbody is an asyncconcisebody, return false. 
*0*(S if/IN (Chunk VARbody/NNP) is/VBZ an/DT asyncconcisebody/NN ,/, return/NN false/JJ ./.)
*0*return the result of hascallintailposition of VARbody with argument VARcall.    
*0*(S return/VB the/DT result/NN of/IN hascallintailposition/NN of/IN VARbody/NN with/IN argument/NN (Chunk VARcall/NNP) ./.)
ID= 14.9.3
Summary= Runtime Semantics: PrepareForTailCall ( )
*0*let VARleafcontext be the running execution context. 
*0*(S (Chunk let/VB VARleafcontext/NNP) be/VB the/DT running/JJ execution/NN context/NN ./.)
*0*suspend VARleafcontext. 
*0*(S suspend/NN (Chunk VARleafcontext/NNP) ./.)
*0*pop VARleafcontext from the execution context stack. the execution context now on the top of the stack becomes the running execution context. 
*0*(S pop/NN (Chunk VARleafcontext/NNP) from/IN the/DT execution/NN context/NN stack/NN ./. the/DT execution/NN context/NN now/RB on/IN the/DT top/NN of/IN the/DT stack/NN becomes/VBZ the/DT running/JJ execution/NN context/NN ./.)
*0*assert: VARleafcontext has no further use. it will never be activated as the running execution context.    
*0*(S assert/NN :/: (Chunk VARleafcontext/NNP) has/VBZ no/DT further/JJ use/NN ./. it/PRP will/MD never/RB be/VB activated/VBN as/IN the/DT running/VBG execution/NN context/NN ./.)
ID= 15.1.9
Summary= ParseScript ( sourceText, realm, hostDefined )
*0*assert: VARsourcetext is an ecmascript source text (see clause 10). 
*0*(S assert/NN :/: (Chunk VARsourcetext/NNP) is/VBZ an/DT ecmascript/JJ source/NN text/NN (/( see/VB clause/RB 10/CD )/) ./.)
*0*parse VARsourcetext using script as the goal symbol and analyse the parse result for any early error conditions. if the parse was successful and no early errors were found, let VARbody be the resulting parse tree. otherwise, let VARbody be a list of one or more syntaxerror or referenceerror objects representing the parsing errors and/or early errors. parsing and early error detection may be interweaved in an implementation-dependent manner. if more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-dependent, but at least one must be present. 
*0*(S parse/NN (Chunk VARsourcetext/NNP) using/VBG script/NN as/IN the/DT goal/NN symbol/NN and/CC analyse/VB the/DT parse/NN result/NN for/IN any/DT early/JJ error/NN conditions/NNS ./. if/IN the/DT parse/NN was/VBD successful/JJ and/CC no/DT early/JJ errors/NNS were/VBD found/VBN ,/, (Chunk let/VB VARbody/NNP) be/VB the/DT resulting/JJ parse/JJ tree/NN ./. otherwise/RB ,/, (Chunk let/VB VARbody/NNP) be/VB a/DT list/NN of/IN one/CD or/CC more/JJR syntaxerror/NN or/CC referenceerror/NN objects/NNS representing/VBG the/DT parsing/JJ errors/NNS and/or/VBP early/JJ errors/NNS ./. parsing/NN and/CC early/JJ error/NN detection/NN may/MD be/VB interweaved/VBN in/IN an/DT implementation-dependent/JJ manner/NN ./. if/IN more/JJR than/IN one/CD parsing/VBG error/NN or/CC early/JJ error/NN is/VBZ present/JJ ,/, the/DT number/NN and/CC ordering/NN of/IN error/NN objects/NNS in/IN the/DT list/NN is/VBZ implementation-dependent/JJ ,/, but/CC at/IN least/JJS one/CD must/MD be/VB present/JJ ./.)
*0*if VARbody is a list of errors, return VARbody. 
*0*(S if/IN (Chunk VARbody/NNP) is/VBZ a/DT list/NN of/IN errors/NNS ,/, return/NN (Chunk VARbody/NNP) ./.)
*0*return script record { [[REALM]]: VARrealm, [[ENVIRONMENT]]: undefined, [[ECMASCRIPTCODE]]: VARbody, [[HOSTDEFINED]]: VARhostdefined }.    
*0*(S return/NN script/NN record/NN {/( [/JJ (Chunk [/NNP) (Chunk REALM/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARrealm/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ENVIRONMENT/NNP) (Chunk ]/NNP) ]/NN :/: undefined/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ECMASCRIPTCODE/NNP) (Chunk ]/NNP) ]/NN :/: VARbody/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk HOSTDEFINED/NNP) (Chunk ]/NNP) ]/NN :/: VARhostdefined/VBN }/) ./.)
ID= 15.1.10
Summary= ScriptEvaluation ( scriptRecord )
*0*let VARglobalenv be VARscriptrecord.[[REALM]].[[GLOBALENV]]. 
*0*(S (Chunk let/VB VARglobalenv/NNP) (Chunk be/VB VARscriptrecord./NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk REALM/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./. [/VB [/JJ (Chunk GLOBALENV/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARscriptcxt be a new ecmascript code execution context. 
*0*(S (Chunk let/VB VARscriptcxt/NNP) be/VB a/DT new/JJ ecmascript/NN code/NN execution/NN context/NN ./.)
*0*set the function of VARscriptcxt to null. 
*0*(S set/VB the/DT function/NN of/IN (Chunk VARscriptcxt/NNP) to/TO null/VB ./.)
*0*set the realm of VARscriptcxt to VARscriptrecord.[[REALM]]. 
*0*(S set/VB the/DT realm/NN of/IN (Chunk VARscriptcxt/NNP) to/TO (Chunk VARscriptrecord/NNP) ./. [/VB [/JJ (Chunk REALM/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*set the scriptormodule of VARscriptcxt to VARscriptrecord. 
*0*(S set/VB the/DT scriptormodule/NN of/IN (Chunk VARscriptcxt/NNP) to/TO (Chunk VARscriptrecord/NNP) ./.)
*0*set the variableenvironment of VARscriptcxt to VARglobalenv. 
*0*(S set/VB the/DT variableenvironment/NN of/IN (Chunk VARscriptcxt/NNP) to/TO (Chunk VARglobalenv/NNP) ./.)
*0*set the lexicalenvironment of VARscriptcxt to VARglobalenv. 
*0*(S set/VB the/DT lexicalenvironment/NN of/IN (Chunk VARscriptcxt/NNP) to/TO (Chunk VARglobalenv/NNP) ./.)
*0*suspend the currently running execution context. 
*0*(S suspend/VB the/DT currently/RB running/VBG execution/NN context/NN ./.)
*0*push VARscriptcxt on to the execution context stack; VARscriptcxt is now the running execution context. 
*0*(S push/NN (Chunk VARscriptcxt/NNP) on/IN to/TO the/DT execution/NN context/NN stack/NN ;/: (Chunk VARscriptcxt/NNP) is/VBZ now/RB the/DT running/VBG execution/NN context/NN ./.)
*0*let VARscriptbody be VARscriptrecord.[[ECMASCRIPTCODE]]. 
*0*(S (Chunk let/VB VARscriptbody/NNP) (Chunk be/VB VARscriptrecord/NNP) ./. [/VB [/JJ (Chunk ECMASCRIPTCODE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARresult be FUNCglobaldeclarationinstantiation(VARscriptbody, VARglobalenv). 
*0*(S (Chunk let/VB VARresult/NNP) (Chunk be/VB FUNCglobaldeclarationinstantiation/NNP) (/( (Chunk VARscriptbody/NNP) ,/, (Chunk VARglobalenv/NNP) )/) ./.)
*0*if VARresult.[[TYPE]] is normal, then
*0*(S if/IN (Chunk VARresult/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ normal/JJ ,/, then/RB)
*1*set VARresult to the result of evaluating VARscriptbody. 
*1*(S (Chunk set/VBN VARresult/NNP) to/TO the/DT result/NN of/IN (Chunk evaluating/VBG VARscriptbody/NNP) ./.)
*0*if VARresult.[[TYPE]] is normal and VARresult.[[VALUE]] is empty, then
*0*(S if/IN (Chunk VARresult/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ normal/JJ and/CC (Chunk VARresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ empty/JJ ,/, then/RB)
*1*set VARresult to FUNCnormalcompletion(undefined). 
*1*(S (Chunk set/VBN VARresult/NNP) to/TO (Chunk FUNCnormalcompletion/NNP) (/( undefined/JJ )/) ./.)
*0*suspend VARscriptcxt and remove it from the execution context stack. 
*0*(S suspend/NN (Chunk VARscriptcxt/NNP) and/CC remove/VB it/PRP from/IN the/DT execution/NN context/NN stack/NN ./.)
*0*assert: the execution context stack is not empty. 
*0*(S assert/NN :/: the/DT execution/NN context/NN stack/NN is/VBZ not/RB empty/JJ ./.)
*0*resume the context that is now on the top of the execution context stack as the running execution context. 
*0*(S resume/VB the/DT context/NN that/WDT is/VBZ now/RB on/IN the/DT top/NN of/IN the/DT execution/NN context/NN stack/NN as/IN the/DT running/VBG execution/NN context/NN ./.)
*0*return FUNCcompletion(VARresult).    
*0*(S return/NN (Chunk FUNCcompletion/NNP) (/( (Chunk VARresult/NNP) )/) ./.)
ID= 15.1.11
Summary= Runtime Semantics: GlobalDeclarationInstantiation ( script, env )
*0*let VARenvrec be VARenv's environmentrecord. 
*0*(S (Chunk let/VB VARenvrec/NNP) (Chunk be/VB VARenv/NNP) 's/POS environmentrecord/NN ./.)
*0*assert: VARenvrec is a global environment record. 
*0*(S assert/NN :/: (Chunk VARenvrec/NNP) is/VBZ a/DT global/JJ environment/NN record/NN ./.)
*0*let VARlexnames be the lexicallydeclarednames of VARscript. 
*0*(S (Chunk let/VB VARlexnames/NNP) be/VB the/DT lexicallydeclarednames/NNS of/IN (Chunk VARscript/NNP) ./.)
*0*let VARvarnames be the vardeclarednames of VARscript. 
*0*(S (Chunk let/VB VARvarnames/NNP) be/VB the/DT vardeclarednames/NNS of/IN (Chunk VARscript/NNP) ./.)
*0*for each VARname in VARlexnames, do
*0*(S for/IN each/DT (Chunk VARname/NNP) in/IN (Chunk VARlexnames/NNP) ,/, do/VBP)
*1*if VARenvrec.hasvardeclaration(VARname) is true, throw a syntaxerror exception. 
*1*(S if/IN (Chunk VARenvrec.hasvardeclaration/NNP) (/( (Chunk VARname/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT syntaxerror/NN exception/NN ./.)
*1*if VARenvrec.haslexicaldeclaration(VARname) is true, throw a syntaxerror exception. 
*1*(S if/IN (Chunk VARenvrec.haslexicaldeclaration/NNP) (/( (Chunk VARname/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT syntaxerror/NN exception/NN ./.)
*1*let VARhasrestrictedglobal be ? VARenvrec.hasrestrictedglobalproperty(VARname). 
*1*(S (Chunk let/VB VARhasrestrictedglobal/NNP) be/VB ?/. (Chunk VARenvrec.hasrestrictedglobalproperty/NNP) (/( (Chunk VARname/NNP) )/) ./.)
*1*if VARhasrestrictedglobal is true, throw a syntaxerror exception. 
*1*(S if/IN (Chunk VARhasrestrictedglobal/NNP) is/VBZ true/JJ ,/, throw/VB a/DT syntaxerror/NN exception/NN ./.)
*0*for each VARname in VARvarnames, do
*0*(S for/IN each/DT (Chunk VARname/NNP) in/IN (Chunk VARvarnames/NNP) ,/, do/VBP)
*1*if VARenvrec.haslexicaldeclaration(VARname) is true, throw a syntaxerror exception. 
*1*(S if/IN (Chunk VARenvrec.haslexicaldeclaration/NNP) (/( (Chunk VARname/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT syntaxerror/NN exception/NN ./.)
*0*let VARvardeclarations be the varscopeddeclarations of VARscript. 
*0*(S (Chunk let/VB VARvardeclarations/NNP) be/VB the/DT varscopeddeclarations/NNS of/IN (Chunk VARscript/NNP) ./.)
*0*let VARfunctionstoinitialize be a new empty list. 
*0*(S (Chunk let/VB VARfunctionstoinitialize/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARdeclaredfunctionnames be a new empty list. 
*0*(S (Chunk let/VB VARdeclaredfunctionnames/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*for each VARd in VARvardeclarations, in reverse list order, do
*0*(S for/IN each/DT (Chunk VARd/NNP) in/IN (Chunk VARvardeclarations/NNP) ,/, in/IN reverse/JJ list/NN order/NN ,/, do/VBP)
*1*if VARd is neither a variabledeclaration nor a forbinding nor a bindingidentifier, then
*1*(S if/IN (Chunk VARd/NNP) is/VBZ neither/CC a/DT variabledeclaration/NN nor/CC a/DT forbinding/NN nor/CC a/DT bindingidentifier/NN ,/, then/RB)
*2*assert: VARd is either a functiondeclaration, a generatordeclaration, an asyncfunctiondeclaration, or an asyncgeneratordeclaration. 
*2*(S assert/NN :/: (Chunk VARd/NNP) is/VBZ either/CC a/DT functiondeclaration/NN ,/, a/DT generatordeclaration/NN ,/, an/DT asyncfunctiondeclaration/NN ,/, or/CC an/DT asyncgeneratordeclaration/NN ./.)
*2*note: if there are multiple function declarations for the same name, the last declaration is used. 
*2*(S note/NN :/: if/IN there/EX are/VBP multiple/JJ function/NN declarations/NNS for/IN the/DT same/JJ name/NN ,/, the/DT last/JJ declaration/NN is/VBZ used/VBN ./.)
*2*let VARfn be the sole element of the boundnames of VARd. 
*2*(S (Chunk let/VB VARfn/NNP) be/VB the/DT sole/JJ element/NN of/IN the/DT boundnames/NNS of/IN (Chunk VARd/NNP) ./.)
*2*if VARfn is not an element of VARdeclaredfunctionnames, then
*2*(S if/IN (Chunk VARfn/NNP) is/VBZ not/RB an/DT element/NN of/IN (Chunk VARdeclaredfunctionnames/NNP) ,/, then/RB)
*3*let VARfndefinable be ? VARenvrec.candeclareglobalfunction(VARfn). 
*3*(S let/VB VARfndefinable/JJ be/VB ?/. (Chunk VARenvrec.candeclareglobalfunction/NNP) (/( (Chunk VARfn/NNP) )/) ./.)
*3*if VARfndefinable is false, throw a typeerror exception. 
*3*(S if/IN (Chunk VARfndefinable/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*3*append VARfn to VARdeclaredfunctionnames. 
*3*(S append/NN (Chunk VARfn/NNP) to/TO (Chunk VARdeclaredfunctionnames/NNP) ./.)
*3*insert VARd as the first element of VARfunctionstoinitialize. 
*3*(S insert/JJ (Chunk VARd/NNP) as/IN the/DT first/JJ element/NN of/IN (Chunk VARfunctionstoinitialize/NNP) ./.)
*0*let VARdeclaredvarnames be a new empty list. 
*0*(S (Chunk let/VB VARdeclaredvarnames/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*for each VARd in VARvardeclarations, do
*0*(S for/IN each/DT (Chunk VARd/NNP) in/IN (Chunk VARvardeclarations/NNP) ,/, do/VBP)
*1*if VARd is a variabledeclaration, a forbinding, or a bindingidentifier, then
*1*(S if/IN (Chunk VARd/NNP) is/VBZ a/DT variabledeclaration/NN ,/, a/DT forbinding/NN ,/, or/CC a/DT bindingidentifier/NN ,/, then/RB)
*2*for each string VARvn in the boundnames of VARd, do
*2*(S for/IN each/DT string/NN (Chunk VARvn/NNP) in/IN the/DT boundnames/NNS of/IN (Chunk VARd/NNP) ,/, do/VBP)
*3*if VARvn is not an element of VARdeclaredfunctionnames, then
*3*(S if/IN (Chunk VARvn/NNP) is/VBZ not/RB an/DT element/NN of/IN (Chunk VARdeclaredfunctionnames/NNP) ,/, then/RB)
*4*let VARvndefinable be ? VARenvrec.candeclareglobalvar(VARvn). 
*4*(S let/VB VARvndefinable/JJ be/VB ?/. (Chunk VARenvrec.candeclareglobalvar/NNP) (/( (Chunk VARvn/NNP) )/) ./.)
*4*if VARvndefinable is false, throw a typeerror exception. 
*4*(S if/IN (Chunk VARvndefinable/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*4*if VARvn is not an element of VARdeclaredvarnames, then
*4*(S if/IN (Chunk VARvn/NNP) is/VBZ not/RB an/DT element/NN of/IN (Chunk VARdeclaredvarnames/NNP) ,/, then/RB)
*5*append VARvn to VARdeclaredvarnames. 
*5*(S append/NN (Chunk VARvn/NNP) to/TO (Chunk VARdeclaredvarnames/NNP) ./.)
*0*note: no abnormal terminations occur after this algorithm step if the global object is an ordinary object. however, if the global object is a proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps. 
*0*(S note/NN :/: no/DT abnormal/JJ terminations/NNS occur/VBP after/IN this/DT algorithm/JJ step/NN if/IN the/DT global/JJ object/NN is/VBZ an/DT ordinary/JJ object/NN ./. however/RB ,/, if/IN the/DT global/JJ object/NN is/VBZ a/DT proxy/JJ exotic/JJ object/NN it/PRP may/MD exhibit/VB behaviours/NNS that/WDT cause/VBP abnormal/JJ terminations/NNS in/IN some/DT of/IN the/DT following/JJ steps/NNS ./.)
*0*note: annex b.3.3.2 adds additional steps at this point. 
*0*(S note/NN :/: annex/NN b.3.3.2/NN adds/VBZ additional/JJ steps/NNS at/IN this/DT point/NN ./.)
*0*let VARlexdeclarations be the lexicallyscopeddeclarations of VARscript. 
*0*(S (Chunk let/VB VARlexdeclarations/NNP) be/VB the/DT lexicallyscopeddeclarations/NNS of/IN (Chunk VARscript/NNP) ./.)
*0*for each element VARd in VARlexdeclarations, do
*0*(S for/IN each/DT element/NN (Chunk VARd/NNP) in/IN (Chunk VARlexdeclarations/NNP) ,/, do/VBP)
*1*note: lexically declared names are only instantiated here but not initialized. 
*1*(S note/NN :/: lexically/RB declared/VBN names/NNS are/VBP only/RB instantiated/VBN here/RB but/CC not/RB initialized/VBN ./.)
*1*for each element VARdn of the boundnames of VARd, do
*1*(S for/IN each/DT element/NN (Chunk VARdn/NNP) of/IN the/DT boundnames/NNS of/IN (Chunk VARd/NNP) ,/, do/VBP)
*2*if isconstantdeclaration of VARd is true, then
*2*(S if/IN isconstantdeclaration/NN of/IN (Chunk VARd/NNP) is/VBZ true/JJ ,/, then/RB)
*3*perform ? VARenvrec.createimmutablebinding(VARdn, true). 
*3*(S perform/NN ?/. (Chunk VARenvrec.createimmutablebinding/NNP) (/( (Chunk VARdn/NNP) ,/, true/JJ )/) ./.)
*2*else,
*2*(S else/RB ,/,)
*3*perform ? VARenvrec.createmutablebinding(VARdn, false). 
*3*(S perform/NN ?/. (Chunk VARenvrec.createmutablebinding/NNP) (/( (Chunk VARdn/NNP) ,/, false/RB )/) ./.)
*0*for each parse node VARf in VARfunctionstoinitialize, do
*0*(S for/IN each/DT parse/NN node/NN (Chunk VARf/NNP) in/IN (Chunk VARfunctionstoinitialize/NNP) ,/, do/VBP)
*1*let VARfn be the sole element of the boundnames of VARf. 
*1*(S (Chunk let/VB VARfn/NNP) be/VB the/DT sole/JJ element/NN of/IN the/DT boundnames/NNS of/IN (Chunk VARf/NNP) ./.)
*1*let VARfo be the result of performing instantiatefunctionobject for VARf with argument VARenv. 
*1*(S (Chunk let/VB VARfo/NNP) be/VB the/DT result/NN of/IN performing/VBG instantiatefunctionobject/NN for/IN (Chunk VARf/NNP) with/IN argument/NN (Chunk VARenv/NNP) ./.)
*1*perform ? VARenvrec.createglobalfunctionbinding(VARfn, VARfo, false). 
*1*(S perform/NN ?/. (Chunk VARenvrec.createglobalfunctionbinding/NNP) (/( (Chunk VARfn/NNP) ,/, (Chunk VARfo/NNP) ,/, false/RB )/) ./.)
*0*for each string VARvn in VARdeclaredvarnames, in list order, do
*0*(S for/IN each/DT string/NN (Chunk VARvn/NNP) in/IN (Chunk VARdeclaredvarnames/NNP) ,/, in/IN list/NN order/NN ,/, do/VBP)
*1*perform ? VARenvrec.createglobalvarbinding(VARvn, false). 
*1*(S perform/NN ?/. (Chunk VARenvrec.createglobalvarbinding/NNP) (/( (Chunk VARvn/NNP) ,/, false/RB )/) ./.)
*0*return FUNCnormalcompletion(empty).    
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( empty/JJ )/) ./.)
ID= 15.1.12
Summary= Runtime Semantics: ScriptEvaluationJob ( sourceText, hostDefined )
*0*assert: VARsourcetext is an ecmascript source text (see clause 10). 
*0*(S assert/NN :/: (Chunk VARsourcetext/NNP) is/VBZ an/DT ecmascript/JJ source/NN text/NN (/( see/VB clause/RB 10/CD )/) ./.)
*0*let VARrealm be the current realm record. 
*0*(S (Chunk let/VB VARrealm/NNP) be/VB the/DT current/JJ realm/NN record/NN ./.)
*0*let VARs be FUNCparsescript(VARsourcetext, VARrealm, VARhostdefined). 
*0*(S (Chunk let/VB VARs/NNP) (Chunk be/VB FUNCparsescript/NNP) (/( (Chunk VARsourcetext/NNP) ,/, (Chunk VARrealm/NNP) ,/, (Chunk VARhostdefined/NNP) )/) ./.)
*0*if VARs is a list of errors, then
*0*(S if/IN (Chunk VARs/NNP) is/VBZ a/DT list/NN of/IN errors/NNS ,/, then/RB)
*1*perform FUNChostreporterrors(VARs). 
*1*(S perform/NN FUNChostreporterrors/NNS (/( (Chunk VARs/NNP) )/) ./.)
*1*return FUNCnormalcompletion(undefined). 
*1*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( undefined/JJ )/) ./.)
*0*return ? FUNCscriptevaluation(VARs).    
*0*(S return/NN ?/. (Chunk FUNCscriptevaluation/NNP) (/( (Chunk VARs/NNP) )/) ./.)
ID= 15.2.1.9
Summary= Static Semantics: ImportedLocalNames ( importEntries )
*0*let VARlocalnames be a new empty list. 
*0*(S (Chunk let/VB VARlocalnames/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*for each importentry record VARi in VARimportentries, do
*0*(S for/IN each/DT importentry/NN record/NN (Chunk VARi/NNP) in/IN (Chunk VARimportentries/NNP) ,/, do/VBP)
*1*append VARi.[[LOCALNAME]] to VARlocalnames. 
*1*(S append/NN (Chunk VARi/NNP) ./. [/VB [/JJ (Chunk LOCALNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARlocalnames/NNP) ./.)
*0*return VARlocalnames.     
*0*(S return/NN VARlocalnames/NNS ./.)
ID= 15.2.1.16.1
Summary= ParseModule ( sourceText, realm, hostDefined )
*0*assert: VARsourcetext is an ecmascript source text (see clause 10). 
*0*(S assert/NN :/: (Chunk VARsourcetext/NNP) is/VBZ an/DT ecmascript/JJ source/NN text/NN (/( see/VB clause/RB 10/CD )/) ./.)
*0*parse VARsourcetext using module as the goal symbol and analyse the parse result for any early error conditions. if the parse was successful and no early errors were found, let VARbody be the resulting parse tree. otherwise, let VARbody be a list of one or more syntaxerror or referenceerror objects representing the parsing errors and/or early errors. parsing and early error detection may be interweaved in an implementation-dependent manner. if more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-dependent, but at least one must be present. 
*0*(S parse/NN (Chunk VARsourcetext/NNP) using/VBG module/NN as/IN the/DT goal/NN symbol/NN and/CC analyse/VB the/DT parse/NN result/NN for/IN any/DT early/JJ error/NN conditions/NNS ./. if/IN the/DT parse/NN was/VBD successful/JJ and/CC no/DT early/JJ errors/NNS were/VBD found/VBN ,/, (Chunk let/VB VARbody/NNP) be/VB the/DT resulting/JJ parse/JJ tree/NN ./. otherwise/RB ,/, (Chunk let/VB VARbody/NNP) be/VB a/DT list/NN of/IN one/CD or/CC more/JJR syntaxerror/NN or/CC referenceerror/NN objects/NNS representing/VBG the/DT parsing/JJ errors/NNS and/or/VBP early/JJ errors/NNS ./. parsing/NN and/CC early/JJ error/NN detection/NN may/MD be/VB interweaved/VBN in/IN an/DT implementation-dependent/JJ manner/NN ./. if/IN more/JJR than/IN one/CD parsing/VBG error/NN or/CC early/JJ error/NN is/VBZ present/JJ ,/, the/DT number/NN and/CC ordering/NN of/IN error/NN objects/NNS in/IN the/DT list/NN is/VBZ implementation-dependent/JJ ,/, but/CC at/IN least/JJS one/CD must/MD be/VB present/JJ ./.)
*0*if VARbody is a list of errors, return VARbody. 
*0*(S if/IN (Chunk VARbody/NNP) is/VBZ a/DT list/NN of/IN errors/NNS ,/, return/NN (Chunk VARbody/NNP) ./.)
*0*let VARrequestedmodules be the modulerequests of VARbody. 
*0*(S (Chunk let/VB VARrequestedmodules/NNP) be/VB the/DT modulerequests/NNS of/IN (Chunk VARbody/NNP) ./.)
*0*let VARimportentries be importentries of VARbody. 
*0*(S let/VB VARimportentries/NNS be/VB importentries/NNS of/IN (Chunk VARbody/NNP) ./.)
*0*let VARimportedboundnames be FUNCimportedlocalnames(VARimportentries). 
*0*(S (Chunk let/VB VARimportedboundnames/NNP) (Chunk be/VB FUNCimportedlocalnames/NNP) (/( (Chunk VARimportentries/NNP) )/) ./.)
*0*let VARindirectexportentries be a new empty list. 
*0*(S let/VB VARindirectexportentries/NNS be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARlocalexportentries be a new empty list. 
*0*(S let/VB VARlocalexportentries/NNS be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARstarexportentries be a new empty list. 
*0*(S let/VB VARstarexportentries/NNS be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARexportentries be exportentries of VARbody. 
*0*(S let/VB VARexportentries/NNS be/VB exportentries/NNS of/IN (Chunk VARbody/NNP) ./.)
*0*for each exportentry record VARee in VARexportentries, do
*0*(S for/IN each/DT exportentry/NN record/NN (Chunk VARee/NNP) in/IN (Chunk VARexportentries/NNP) ,/, do/VBP)
*1*if VARee.[[MODULEREQUEST]] is null, then
*1*(S if/IN (Chunk VARee/NNP) ./. [/VB [/JJ (Chunk MODULEREQUEST/NNP) ]/NN ]/NN is/VBZ null/RB ,/, then/RB)
*2*if VARee.[[LOCALNAME]] is not an element of VARimportedboundnames, then
*2*(S if/IN (Chunk VARee/NNP) ./. [/VB [/JJ (Chunk LOCALNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB an/DT element/NN of/IN (Chunk VARimportedboundnames/NNP) ,/, then/RB)
*3*append VARee to VARlocalexportentries. 
*3*(S (Chunk append/RB VARee/NNP) to/TO (Chunk VARlocalexportentries/NNP) ./.)
*2*else,
*2*(S else/RB ,/,)
*3*let VARie be the element of VARimportentries whose [[LOCALNAME]] is the same as VARee.[[LOCALNAME]]. 
*3*(S (Chunk let/VB VARie/NNP) be/VB the/DT element/NN of/IN VARimportentries/NNS whose/WP$ [/JJ [/NN (Chunk LOCALNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ the/DT same/JJ as/IN (Chunk VARee/NNP) ./. [/VB [/JJ (Chunk LOCALNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*3*if VARie.[[IMPORTNAME]] is "*", then
*3*(S if/IN (Chunk VARie/NNP) ./. [/VB [/JJ (Chunk IMPORTNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` */JJ ''/'' ,/, then/RB)
*4*assert: this is a re-export of an imported module namespace object. 
*4*(S assert/NN :/: this/DT is/VBZ a/DT re-export/NN of/IN an/DT imported/VBN module/NN namespace/NN object/NN ./.)
*4*append VARee to VARlocalexportentries. 
*4*(S (Chunk append/RB VARee/NNP) to/TO (Chunk VARlocalexportentries/NNP) ./.)
*3*else this is a re-export of a single name,
*3*(S else/RB this/DT is/VBZ a/DT re-export/NN of/IN a/DT single/JJ name/NN ,/,)
*4*append the exportentry record { [[MODULEREQUEST]]: VARie.[[MODULEREQUEST]], [[IMPORTNAME]]: VARie.[[IMPORTNAME]], [[LOCALNAME]]: null, [[EXPORTNAME]]: VARee.[[EXPORTNAME]] } to VARindirectexportentries. 
*4*(S append/VB the/DT exportentry/NN record/NN {/( [/JJ [/NN (Chunk MODULEREQUEST/NNP) ]/NN ]/NN :/: (Chunk VARie/NNP) ./. [/VB [/JJ (Chunk MODULEREQUEST/NNP) ]/NN (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk IMPORTNAME/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARie/NNP) ./. [/VB [/JJ (Chunk IMPORTNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk LOCALNAME/NNP) (Chunk ]/NNP) ]/NN :/: null/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk EXPORTNAME/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARee/NNP) ./. [/VB [/JJ (Chunk EXPORTNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) }/) to/TO VARindirectexportentries/NNS ./.)
*1*else if VARee.[[IMPORTNAME]] is "*", then
*1*(S else/RB if/IN (Chunk VARee/NNP) ./. [/VB [/JJ (Chunk IMPORTNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` */JJ ''/'' ,/, then/RB)
*2*append VARee to VARstarexportentries. 
*2*(S (Chunk append/RB VARee/NNP) to/TO (Chunk VARstarexportentries/NNP) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*append VARee to VARindirectexportentries. 
*2*(S (Chunk append/RB VARee/NNP) to/TO (Chunk VARindirectexportentries/NNP) ./.)
*0*return source text module record { [[REALM]]: VARrealm, [[ENVIRONMENT]]: undefined, [[NAMESPACE]]: undefined, [[STATUS]]: "uninstantiated", [[EVALUATIONERROR]]: undefined, [[HOSTDEFINED]]: VARhostdefined, [[ECMASCRIPTCODE]]: VARbody, [[REQUESTEDMODULES]]: VARrequestedmodules, [[IMPORTENTRIES]]: VARimportentries, [[LOCALEXPORTENTRIES]]: VARlocalexportentries, [[INDIRECTEXPORTENTRIES]]: VARindirectexportentries, [[STAREXPORTENTRIES]]: VARstarexportentries, [[DFSINDEX]]: undefined, [[DFSANCESTORINDEX]]: undefined }.      
*0*(S return/NN source/NN text/NN module/NN record/NN {/( [/JJ (Chunk [/NNP) (Chunk REALM/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARrealm/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ENVIRONMENT/NNP) (Chunk ]/NNP) ]/NN :/: undefined/JJ ,/, [/JJ [/FW (Chunk NAMESPACE/NNP) (Chunk ]/NNP) ]/NN :/: undefined/JJ ,/, [/JJ [/NN (Chunk STATUS/NNP) (Chunk ]/NNP) ]/NN :/: ``/`` uninstantiated/JJ ''/'' ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk EVALUATIONERROR/NNP) (Chunk ]/NNP) ]/NN :/: undefined/JJ ,/, [/JJ [/NN (Chunk HOSTDEFINED/NNP) (Chunk ]/NNP) ]/NN :/: VARhostdefined/VBN ,/, [/JJ (Chunk [/NNP) (Chunk ECMASCRIPTCODE/NNP) (Chunk ]/NNP) ]/NN :/: VARbody/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk REQUESTEDMODULES/NNP) (Chunk ]/NNP) ]/NN :/: VARrequestedmodules/NNS ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk IMPORTENTRIES/NNP) (Chunk ]/NNP) ]/NN :/: VARimportentries/NNS ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk LOCALEXPORTENTRIES/NNP) (Chunk ]/NNP) ]/NN :/: VARlocalexportentries/NNS ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk INDIRECTEXPORTENTRIES/NNP) (Chunk ]/NNP) ]/NN :/: VARindirectexportentries/NNS ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk STAREXPORTENTRIES/NNP) (Chunk ]/NNP) ]/NN :/: VARstarexportentries/NNS ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk DFSINDEX/NNP) (Chunk ]/NNP) ]/NN :/: undefined/JJ ,/, [/JJ (Chunk [/NNP) (Chunk DFSANCESTORINDEX/NNP) (Chunk ]/NNP) ]/NN :/: undefined/JJ }/) ./.)
ID= 15.2.1.16.4.1
Summary= InnerModuleInstantiation ( module, stack, index )
*0*if VARmodule is not a source text module record, then
*0*(S if/IN (Chunk VARmodule/NNP) is/VBZ not/RB a/DT source/NN text/NN module/NN record/NN ,/, then/RB)
*1*perform ? VARmodule.instantiate(). 
*1*(S perform/NN ?/. (Chunk VARmodule.instantiate/NNP) (/( )/) ./.)
*1*return VARindex. 
*1*(S return/NN (Chunk VARindex/NNP) ./.)
*0*if VARmodule.[[STATUS]] is "instantiating", "instantiated", or "evaluated", then
*0*(S if/IN (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk STATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` instantiating/VBG ''/'' ,/, ``/`` instantiated/VBN ''/'' ,/, or/CC ``/`` evaluated/VBN ''/'' ,/, then/RB)
*1*return VARindex. 
*1*(S return/NN (Chunk VARindex/NNP) ./.)
*0*assert: VARmodule.[[STATUS]] is "uninstantiated". 
*0*(S assert/NN :/: VARmodule/NN ./. [/CC [/JJ (Chunk STATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` uninstantiated/JJ ''/'' ./.)
*0*set VARmodule.[[STATUS]] to "instantiating". 
*0*(S (Chunk set/VBN VARmodule/NNP) ./. [/VB [/JJ (Chunk STATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` instantiating/VBG ''/'' ./.)
*0*set VARmodule.[[DFSINDEX]] to VARindex. 
*0*(S (Chunk set/VBN VARmodule/NNP) ./. [/VB [/JJ (Chunk DFSINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARindex/NNP) ./.)
*0*set VARmodule.[[DFSANCESTORINDEX]] to VARindex. 
*0*(S (Chunk set/VBN VARmodule/NNP) ./. [/VB [/JJ (Chunk DFSANCESTORINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARindex/NNP) ./.)
*0*set VARindex to VARindex + 1. 
*0*(S set/VBN VARindex/NN to/TO (Chunk VARindex/NNP) (Chunk +/NNP) 1/CD ./.)
*0*append VARmodule to VARstack. 
*0*(S append/NN (Chunk VARmodule/NNP) to/TO (Chunk VARstack/NNP) ./.)
*0*for each string VARrequired that is an element of VARmodule.[[REQUESTEDMODULES]], do
*0*(S for/IN each/DT string/NN VARrequired/VBD that/DT is/VBZ an/DT element/NN of/IN (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk REQUESTEDMODULES/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, do/VBP)
*1*let VARrequiredmodule be ? FUNChostresolveimportedmodule(VARmodule, VARrequired). 
*1*(S (Chunk let/VB VARrequiredmodule/NNP) be/VB ?/. (Chunk FUNChostresolveimportedmodule/NNP) (/( (Chunk VARmodule/NNP) ,/, (Chunk VARrequired/NNP) )/) ./.)
*1*set VARindex to ? FUNCinnermoduleinstantiation(VARrequiredmodule, VARstack, VARindex). 
*1*(S set/VBN VARindex/NN to/TO ?/. (Chunk FUNCinnermoduleinstantiation/NNP) (/( (Chunk VARrequiredmodule/NNP) ,/, (Chunk VARstack/NNP) ,/, (Chunk VARindex/NNP) )/) ./.)
*1*assert: VARrequiredmodule.[[STATUS]] is either "instantiating", "instantiated", or "evaluated". 
*1*(S assert/NN :/: VARrequiredmodule/NN ./. [/CC [/JJ (Chunk STATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ either/CC ``/`` instantiating/NN ''/'' ,/, ``/`` instantiated/VBN ''/'' ,/, or/CC ``/`` evaluated/VBN ''/'' ./.)
*1*assert: VARrequiredmodule.[[STATUS]] is "instantiating" if and only if VARrequiredmodule is in VARstack. 
*1*(S assert/NN :/: VARrequiredmodule/NN ./. [/CC [/JJ (Chunk STATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` instantiating/VBG ''/'' if/IN and/CC only/RB if/IN (Chunk VARrequiredmodule/NNP) is/VBZ in/IN (Chunk VARstack/NNP) ./.)
*1*if VARrequiredmodule.[[STATUS]] is "instantiating", then
*1*(S if/IN (Chunk VARrequiredmodule/NNP) ./. [/VB [/JJ (Chunk STATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` instantiating/VBG ''/'' ,/, then/RB)
*2*assert: VARrequiredmodule is a source text module record. 
*2*(S assert/NN :/: VARrequiredmodule/NN is/VBZ a/DT source/NN text/NN module/NN record/NN ./.)
*2*set VARmodule.[[DFSANCESTORINDEX]] to min(VARmodule.[[DFSANCESTORINDEX]], VARrequiredmodule.[[DFSANCESTORINDEX]]). 
*2*(S (Chunk set/VBN VARmodule/NNP) ./. [/VB [/JJ (Chunk DFSANCESTORINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO min/VB (/( (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk DFSANCESTORINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARrequiredmodule/NNP) ./. [/VB [/JJ (Chunk DFSANCESTORINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*0*perform ? FUNCmoduledeclarationenvironmentsetup(VARmodule). 
*0*(S perform/NN ?/. (Chunk FUNCmoduledeclarationenvironmentsetup/NNP) (/( (Chunk VARmodule/NNP) )/) ./.)
*0*assert: VARmodule occurs exactly once in VARstack. 
*0*(S assert/NN :/: VARmodule/NN occurs/VBZ exactly/RB once/RB in/IN (Chunk VARstack/NNP) ./.)
*0*assert: VARmodule.[[DFSANCESTORINDEX]] is less than or equal to VARmodule.[[DFSINDEX]]. 
*0*(S assert/NN :/: VARmodule/NN ./. [/CC [/JJ (Chunk DFSANCESTORINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ less/JJR than/IN or/CC equal/JJ to/TO (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk DFSINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARmodule.[[DFSANCESTORINDEX]] equals VARmodule.[[DFSINDEX]], then
*0*(S if/IN (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk DFSANCESTORINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) equals/NNS (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk DFSINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, then/RB)
*1*let VARdone be false. 
*1*(S (Chunk let/VB VARdone/NNP) be/VB false/JJ ./.)
*1*repeat, while VARdone is false,
*1*(S repeat/NN ,/, while/IN (Chunk VARdone/NNP) is/VBZ false/JJ ,/,)
*2*let VARrequiredmodule be the last element in VARstack. 
*2*(S (Chunk let/VB VARrequiredmodule/NNP) be/VB the/DT last/JJ element/NN in/IN (Chunk VARstack/NNP) ./.)
*2*remove the last element of VARstack. 
*2*(S remove/VB the/DT last/JJ element/NN of/IN (Chunk VARstack/NNP) ./.)
*2*set VARrequiredmodule.[[STATUS]] to "instantiated". 
*2*(S (Chunk set/VBN VARrequiredmodule/NNP) ./. [/VB [/JJ (Chunk STATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` instantiated/VBN ''/'' ./.)
*2*if VARrequiredmodule and VARmodule are the same module record, set VARdone to true. 
*2*(S if/IN (Chunk VARrequiredmodule/NNP) and/CC (Chunk VARmodule/NNP) are/VBP the/DT same/JJ module/NN record/NN ,/, (Chunk set/VB VARdone/NNP) to/TO true/JJ ./.)
*0*return VARindex.       
*0*(S return/NN (Chunk VARindex/NNP) ./.)
ID= 15.2.1.16.4.2
Summary= ModuleDeclarationEnvironmentSetup ( module )
*0*for each exportentry record VARe in VARmodule.[[INDIRECTEXPORTENTRIES]], do
*0*(S for/IN each/DT exportentry/NN record/NN (Chunk VARe/NNP) in/IN (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk INDIRECTEXPORTENTRIES/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, do/VBP)
*1*let VARresolution be ? VARmodule.resolveexport(VARe.[[EXPORTNAME]], « »). 
*1*(S (Chunk let/VB VARresolution/NNP) be/VB ?/. (Chunk VARmodule.resolveexport/NNP) (/( (Chunk VARe/NNP) ./. [/VB [/JJ (Chunk EXPORTNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk «/NNP) (Chunk »/NNP) )/) ./.)
*1*if VARresolution is null or "ambiguous", throw a syntaxerror exception. 
*1*(S if/IN (Chunk VARresolution/NNP) is/VBZ null/JJ or/CC ``/`` ambiguous/JJ ''/'' ,/, throw/VB a/DT syntaxerror/NN exception/NN ./.)
*1*assert: VARresolution is a resolvedbinding record. 
*1*(S assert/NN :/: VARresolution/NN is/VBZ a/DT resolvedbinding/NN record/NN ./.)
*0*assert: all named exports from VARmodule are resolvable. 
*0*(S assert/NN :/: all/DT named/VBN exports/NNS from/IN (Chunk VARmodule/NNP) are/VBP resolvable/JJ ./.)
*0*let VARrealm be VARmodule.[[REALM]]. 
*0*(S (Chunk let/VB VARrealm/NNP) (Chunk be/VB VARmodule/NNP) ./. [/VB [/JJ (Chunk REALM/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*assert: VARrealm is not undefined. 
*0*(S assert/NN :/: (Chunk VARrealm/NNP) is/VBZ not/RB undefined/JJ ./.)
*0*let VARenv be FUNCnewmoduleenvironment(VARrealm.[[GLOBALENV]]). 
*0*(S (Chunk let/VB VARenv/NNP) (Chunk be/VB FUNCnewmoduleenvironment/NNP) (/( (Chunk VARrealm/NNP) ./. [/VB [/JJ (Chunk GLOBALENV/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*0*set VARmodule.[[ENVIRONMENT]] to VARenv. 
*0*(S (Chunk set/VBN VARmodule/NNP) ./. [/VB [/JJ (Chunk ENVIRONMENT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARenv/NNP) ./.)
*0*let VARenvrec be VARenv's environmentrecord. 
*0*(S (Chunk let/VB VARenvrec/NNP) (Chunk be/VB VARenv/NNP) 's/POS environmentrecord/NN ./.)
*0*for each importentry record VARin in VARmodule.[[IMPORTENTRIES]], do
*0*(S for/IN each/DT importentry/NN record/NN (Chunk VARin/NNP) in/IN (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk IMPORTENTRIES/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, do/VBP)
*1*let VARimportedmodule be ! FUNChostresolveimportedmodule(VARmodule, VARin.[[MODULEREQUEST]]). 
*1*(S (Chunk let/VB VARimportedmodule/NNP) be/VB !/. (Chunk FUNChostresolveimportedmodule/NNP) (/( (Chunk VARmodule/NNP) ,/, (Chunk VARin/NNP) ./. [/VB [/JJ (Chunk MODULEREQUEST/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*1*note: the above call cannot fail because imported module requests are a subset of VARmodule.[[REQUESTEDMODULES]], and these have been resolved earlier in this algorithm. 
*1*(S note/NN :/: the/DT above/IN call/NN can/MD not/RB fail/VB because/IN imported/VBN module/NN requests/NNS are/VBP a/DT subset/NN of/IN (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk REQUESTEDMODULES/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, and/CC these/DT have/VBP been/VBN resolved/VBN earlier/RBR in/IN this/DT algorithm/NN ./.)
*1*if VARin.[[IMPORTNAME]] is "*", then
*1*(S if/IN (Chunk VARin/NNP) ./. [/VB [/JJ (Chunk IMPORTNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` */JJ ''/'' ,/, then/RB)
*2*let VARnamespace be ? FUNCgetmodulenamespace(VARimportedmodule). 
*2*(S (Chunk let/VB VARnamespace/NNP) be/VB ?/. (Chunk FUNCgetmodulenamespace/NNP) (/( (Chunk VARimportedmodule/NNP) )/) ./.)
*2*perform ! VARenvrec.createimmutablebinding(VARin.[[LOCALNAME]], true). 
*2*(S perform/NN !/. (Chunk VARenvrec.createimmutablebinding/NNP) (/( (Chunk VARin/NNP) ./. [/VB [/JJ (Chunk LOCALNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, true/JJ )/) ./.)
*2*call VARenvrec.initializebinding(VARin.[[LOCALNAME]], VARnamespace). 
*2*(S call/NN (Chunk VARenvrec.initializebinding/NNP) (/( (Chunk VARin/NNP) ./. [/VB [/JJ (Chunk LOCALNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARnamespace/NNP) )/) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*let VARresolution be ? VARimportedmodule.resolveexport(VARin.[[IMPORTNAME]], « »). 
*2*(S (Chunk let/VB VARresolution/NNP) be/VB ?/. (Chunk VARimportedmodule.resolveexport/NNP) (/( (Chunk VARin/NNP) ./. [/VB [/JJ (Chunk IMPORTNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk «/NNP) (Chunk »/NNP) )/) ./.)
*2*if VARresolution is null or "ambiguous", throw a syntaxerror exception. 
*2*(S if/IN (Chunk VARresolution/NNP) is/VBZ null/JJ or/CC ``/`` ambiguous/JJ ''/'' ,/, throw/VB a/DT syntaxerror/NN exception/NN ./.)
*2*call VARenvrec.createimportbinding(VARin.[[LOCALNAME]], VARresolution.[[MODULE]], VARresolution.[[BINDINGNAME]]). 
*2*(S call/NN (Chunk VARenvrec.createimportbinding/NNP) (/( (Chunk VARin/NNP) ./. [/VB [/JJ (Chunk LOCALNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARresolution/NNP) ./. [/VB [/JJ (Chunk MODULE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARresolution/NNP) ./. [/VB [/JJ (Chunk BINDINGNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*0*let VARcode be VARmodule.[[ECMASCRIPTCODE]]. 
*0*(S (Chunk let/VB VARcode/NNP) (Chunk be/VB VARmodule/NNP) ./. [/VB [/JJ (Chunk ECMASCRIPTCODE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARvardeclarations be the varscopeddeclarations of VARcode. 
*0*(S (Chunk let/VB VARvardeclarations/NNP) be/VB the/DT varscopeddeclarations/NNS of/IN (Chunk VARcode/NNP) ./.)
*0*let VARdeclaredvarnames be a new empty list. 
*0*(S (Chunk let/VB VARdeclaredvarnames/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*for each element VARd in VARvardeclarations, do
*0*(S for/IN each/DT element/NN (Chunk VARd/NNP) in/IN (Chunk VARvardeclarations/NNP) ,/, do/VBP)
*1*for each element VARdn of the boundnames of VARd, do
*1*(S for/IN each/DT element/NN (Chunk VARdn/NNP) of/IN the/DT boundnames/NNS of/IN (Chunk VARd/NNP) ,/, do/VBP)
*2*if VARdn is not an element of VARdeclaredvarnames, then
*2*(S if/IN (Chunk VARdn/NNP) is/VBZ not/RB an/DT element/NN of/IN (Chunk VARdeclaredvarnames/NNP) ,/, then/RB)
*3*perform ! VARenvrec.createmutablebinding(VARdn, false). 
*3*(S perform/NN !/. (Chunk VARenvrec.createmutablebinding/NNP) (/( (Chunk VARdn/NNP) ,/, false/RB )/) ./.)
*3*call VARenvrec.initializebinding(VARdn, undefined). 
*3*(S call/NN (Chunk VARenvrec.initializebinding/NNP) (/( (Chunk VARdn/NNP) ,/, undefined/VBD )/) ./.)
*3*append VARdn to VARdeclaredvarnames. 
*3*(S append/NN (Chunk VARdn/NNP) to/TO (Chunk VARdeclaredvarnames/NNP) ./.)
*0*let VARlexdeclarations be the lexicallyscopeddeclarations of VARcode. 
*0*(S (Chunk let/VB VARlexdeclarations/NNP) be/VB the/DT lexicallyscopeddeclarations/NNS of/IN (Chunk VARcode/NNP) ./.)
*0*for each element VARd in VARlexdeclarations, do
*0*(S for/IN each/DT element/NN (Chunk VARd/NNP) in/IN (Chunk VARlexdeclarations/NNP) ,/, do/VBP)
*1*for each element VARdn of the boundnames of VARd, do
*1*(S for/IN each/DT element/NN (Chunk VARdn/NNP) of/IN the/DT boundnames/NNS of/IN (Chunk VARd/NNP) ,/, do/VBP)
*2*if isconstantdeclaration of VARd is true, then
*2*(S if/IN isconstantdeclaration/NN of/IN (Chunk VARd/NNP) is/VBZ true/JJ ,/, then/RB)
*3*perform ! VARenvrec.createimmutablebinding(VARdn, true). 
*3*(S perform/NN !/. (Chunk VARenvrec.createimmutablebinding/NNP) (/( (Chunk VARdn/NNP) ,/, true/JJ )/) ./.)
*2*else,
*2*(S else/RB ,/,)
*3*perform ! VARenvrec.createmutablebinding(VARdn, false). 
*3*(S perform/NN !/. (Chunk VARenvrec.createmutablebinding/NNP) (/( (Chunk VARdn/NNP) ,/, false/RB )/) ./.)
*2*if VARd is a functiondeclaration, a generatordeclaration, an asyncfunctiondeclaration, or an asyncgeneratordeclaration, then
*2*(S if/IN (Chunk VARd/NNP) is/VBZ a/DT functiondeclaration/NN ,/, a/DT generatordeclaration/NN ,/, an/DT asyncfunctiondeclaration/NN ,/, or/CC an/DT asyncgeneratordeclaration/NN ,/, then/RB)
*3*let VARfo be the result of performing instantiatefunctionobject for VARd with argument VARenv. 
*3*(S (Chunk let/VB VARfo/NNP) be/VB the/DT result/NN of/IN performing/VBG instantiatefunctionobject/NN for/IN (Chunk VARd/NNP) with/IN argument/NN (Chunk VARenv/NNP) ./.)
*3*call VARenvrec.initializebinding(VARdn, VARfo).       
*3*(S call/NN (Chunk VARenvrec.initializebinding/NNP) (/( (Chunk VARdn/NNP) ,/, (Chunk VARfo/NNP) )/) ./.)
ID= 15.2.1.16.5.1
Summary= InnerModuleEvaluation ( module, stack, index )
*0*if VARmodule is not a source text module record, then
*0*(S if/IN (Chunk VARmodule/NNP) is/VBZ not/RB a/DT source/NN text/NN module/NN record/NN ,/, then/RB)
*1*perform ? VARmodule.evaluate(). 
*1*(S perform/NN ?/. (Chunk VARmodule.evaluate/NNP) (/( )/) ./.)
*1*return VARindex. 
*1*(S return/NN (Chunk VARindex/NNP) ./.)
*0*if VARmodule.[[STATUS]] is "evaluated", then
*0*(S if/IN (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk STATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` evaluated/JJ ''/'' ,/, then/RB)
*1*if VARmodule.[[EVALUATIONERROR]] is undefined, return VARindex. 
*1*(S if/IN (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk EVALUATIONERROR/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ undefined/JJ ,/, return/JJ (Chunk VARindex/NNP) ./.)
*1*otherwise return VARmodule.[[EVALUATIONERROR]]. 
*1*(S otherwise/RB return/NN (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk EVALUATIONERROR/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARmodule.[[STATUS]] is "evaluating", return VARindex. 
*0*(S if/IN (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk STATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` evaluating/VBG ''/'' ,/, (Chunk return/VB VARindex/NNP) ./.)
*0*assert: VARmodule.[[STATUS]] is "instantiated". 
*0*(S assert/NN :/: VARmodule/NN ./. [/CC [/JJ (Chunk STATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` instantiated/JJ ''/'' ./.)
*0*set VARmodule.[[STATUS]] to "evaluating". 
*0*(S (Chunk set/VBN VARmodule/NNP) ./. [/VB [/JJ (Chunk STATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` evaluating/VBG ''/'' ./.)
*0*set VARmodule.[[DFSINDEX]] to VARindex. 
*0*(S (Chunk set/VBN VARmodule/NNP) ./. [/VB [/JJ (Chunk DFSINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARindex/NNP) ./.)
*0*set VARmodule.[[DFSANCESTORINDEX]] to VARindex. 
*0*(S (Chunk set/VBN VARmodule/NNP) ./. [/VB [/JJ (Chunk DFSANCESTORINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARindex/NNP) ./.)
*0*set VARindex to VARindex + 1. 
*0*(S set/VBN VARindex/NN to/TO (Chunk VARindex/NNP) (Chunk +/NNP) 1/CD ./.)
*0*append VARmodule to VARstack. 
*0*(S append/NN (Chunk VARmodule/NNP) to/TO (Chunk VARstack/NNP) ./.)
*0*for each string VARrequired that is an element of VARmodule.[[REQUESTEDMODULES]], do
*0*(S for/IN each/DT string/NN VARrequired/VBD that/DT is/VBZ an/DT element/NN of/IN (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk REQUESTEDMODULES/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, do/VBP)
*1*let VARrequiredmodule be ! FUNChostresolveimportedmodule(VARmodule, VARrequired). 
*1*(S (Chunk let/VB VARrequiredmodule/NNP) be/VB !/. (Chunk FUNChostresolveimportedmodule/NNP) (/( (Chunk VARmodule/NNP) ,/, (Chunk VARrequired/NNP) )/) ./.)
*1*note: instantiate must be completed successfully prior to invoking this method, so every requested module is guaranteed to resolve successfully. 
*1*(S note/NN :/: instantiate/NN must/MD be/VB completed/VBN successfully/RB prior/JJ to/TO invoking/VBG this/DT method/NN ,/, so/RB every/DT requested/JJ module/NN is/VBZ guaranteed/VBN to/TO resolve/VB successfully/RB ./.)
*1*set VARindex to ? FUNCinnermoduleevaluation(VARrequiredmodule, VARstack, VARindex). 
*1*(S set/VBN VARindex/NN to/TO ?/. (Chunk FUNCinnermoduleevaluation/NNP) (/( (Chunk VARrequiredmodule/NNP) ,/, (Chunk VARstack/NNP) ,/, (Chunk VARindex/NNP) )/) ./.)
*1*assert: VARrequiredmodule.[[STATUS]] is either "evaluating" or "evaluated". 
*1*(S assert/NN :/: VARrequiredmodule/NN ./. [/CC [/JJ (Chunk STATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ either/CC ``/`` evaluating/NN ''/'' or/CC ``/`` evaluated/VBN ''/'' ./.)
*1*assert: VARrequiredmodule.[[STATUS]] is "evaluating" if and only if VARrequiredmodule is in VARstack. 
*1*(S assert/NN :/: VARrequiredmodule/NN ./. [/CC [/JJ (Chunk STATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` evaluating/VBG ''/'' if/IN and/CC only/RB if/IN (Chunk VARrequiredmodule/NNP) is/VBZ in/IN (Chunk VARstack/NNP) ./.)
*1*if VARrequiredmodule.[[STATUS]] is "evaluating", then
*1*(S if/IN (Chunk VARrequiredmodule/NNP) ./. [/VB [/JJ (Chunk STATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` evaluating/VBG ''/'' ,/, then/RB)
*2*assert: VARrequiredmodule is a source text module record. 
*2*(S assert/NN :/: VARrequiredmodule/NN is/VBZ a/DT source/NN text/NN module/NN record/NN ./.)
*2*set VARmodule.[[DFSANCESTORINDEX]] to min(VARmodule.[[DFSANCESTORINDEX]], VARrequiredmodule.[[DFSANCESTORINDEX]]). 
*2*(S (Chunk set/VBN VARmodule/NNP) ./. [/VB [/JJ (Chunk DFSANCESTORINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO min/VB (/( (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk DFSANCESTORINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARrequiredmodule/NNP) ./. [/VB [/JJ (Chunk DFSANCESTORINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*0*perform ? FUNCmoduleexecution(VARmodule). 
*0*(S perform/NN ?/. (Chunk FUNCmoduleexecution/NNP) (/( (Chunk VARmodule/NNP) )/) ./.)
*0*assert: VARmodule occurs exactly once in VARstack. 
*0*(S assert/NN :/: VARmodule/NN occurs/VBZ exactly/RB once/RB in/IN (Chunk VARstack/NNP) ./.)
*0*assert: VARmodule.[[DFSANCESTORINDEX]] is less than or equal to VARmodule.[[DFSINDEX]]. 
*0*(S assert/NN :/: VARmodule/NN ./. [/CC [/JJ (Chunk DFSANCESTORINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ less/JJR than/IN or/CC equal/JJ to/TO (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk DFSINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARmodule.[[DFSANCESTORINDEX]] equals VARmodule.[[DFSINDEX]], then
*0*(S if/IN (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk DFSANCESTORINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) equals/NNS (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk DFSINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, then/RB)
*1*let VARdone be false. 
*1*(S (Chunk let/VB VARdone/NNP) be/VB false/JJ ./.)
*1*repeat, while VARdone is false,
*1*(S repeat/NN ,/, while/IN (Chunk VARdone/NNP) is/VBZ false/JJ ,/,)
*2*let VARrequiredmodule be the last element in VARstack. 
*2*(S (Chunk let/VB VARrequiredmodule/NNP) be/VB the/DT last/JJ element/NN in/IN (Chunk VARstack/NNP) ./.)
*2*remove the last element of VARstack. 
*2*(S remove/VB the/DT last/JJ element/NN of/IN (Chunk VARstack/NNP) ./.)
*2*set VARrequiredmodule.[[STATUS]] to "evaluated". 
*2*(S (Chunk set/VBN VARrequiredmodule/NNP) ./. [/VB [/JJ (Chunk STATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` evaluated/VBN ''/'' ./.)
*2*if VARrequiredmodule and VARmodule are the same module record, set VARdone to true. 
*2*(S if/IN (Chunk VARrequiredmodule/NNP) and/CC (Chunk VARmodule/NNP) are/VBP the/DT same/JJ module/NN record/NN ,/, (Chunk set/VB VARdone/NNP) to/TO true/JJ ./.)
*0*return VARindex.       
*0*(S return/NN (Chunk VARindex/NNP) ./.)
ID= 15.2.1.16.5.2
Summary= ModuleExecution ( module )
*0*let VARmodulecxt be a new ecmascript code execution context. 
*0*(S (Chunk let/VB VARmodulecxt/NNP) be/VB a/DT new/JJ ecmascript/NN code/NN execution/NN context/NN ./.)
*0*set the function of VARmodulecxt to null. 
*0*(S set/VB the/DT function/NN of/IN (Chunk VARmodulecxt/NNP) to/TO null/VB ./.)
*0*assert: VARmodule.[[REALM]] is not undefined. 
*0*(S assert/NN :/: VARmodule/NN ./. [/CC [/JJ (Chunk REALM/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB undefined/JJ ./.)
*0*set the realm of VARmodulecxt to VARmodule.[[REALM]]. 
*0*(S set/VB the/DT realm/NN of/IN (Chunk VARmodulecxt/NNP) to/TO (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk REALM/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*set the scriptormodule of VARmodulecxt to VARmodule. 
*0*(S set/VB the/DT scriptormodule/NN of/IN (Chunk VARmodulecxt/NNP) to/TO (Chunk VARmodule/NNP) ./.)
*0*assert: VARmodule has been linked and declarations in its module environment have been instantiated. 
*0*(S assert/NN :/: VARmodule/NN has/VBZ been/VBN linked/VBN and/CC declarations/NNS in/IN its/PRP$ module/NN environment/NN have/VBP been/VBN instantiated/VBN ./.)
*0*set the variableenvironment of VARmodulecxt to VARmodule.[[ENVIRONMENT]]. 
*0*(S set/VB the/DT variableenvironment/NN of/IN (Chunk VARmodulecxt/NNP) to/TO (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk ENVIRONMENT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*set the lexicalenvironment of VARmodulecxt to VARmodule.[[ENVIRONMENT]]. 
*0*(S set/VB the/DT lexicalenvironment/NN of/IN (Chunk VARmodulecxt/NNP) to/TO (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk ENVIRONMENT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*suspend the currently running execution context. 
*0*(S suspend/VB the/DT currently/RB running/VBG execution/NN context/NN ./.)
*0*push VARmodulecxt on to the execution context stack; VARmodulecxt is now the running execution context. 
*0*(S push/NN (Chunk VARmodulecxt/NNP) on/IN to/TO the/DT execution/NN context/NN stack/NN ;/: (Chunk VARmodulecxt/NNP) is/VBZ now/RB the/DT running/VBG execution/NN context/NN ./.)
*0*let VARresult be the result of evaluating VARmodule.[[ECMASCRIPTCODE]]. 
*0*(S (Chunk let/VB VARresult/NNP) be/VB the/DT result/NN of/IN (Chunk evaluating/VBG VARmodule/NNP) ./. [/VB [/JJ (Chunk ECMASCRIPTCODE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*suspend VARmodulecxt and remove it from the execution context stack. 
*0*(S suspend/NN (Chunk VARmodulecxt/NNP) and/CC remove/VB it/PRP from/IN the/DT execution/NN context/NN stack/NN ./.)
*0*resume the context that is now on the top of the execution context stack as the running execution context. 
*0*(S resume/VB the/DT context/NN that/WDT is/VBZ now/RB on/IN the/DT top/NN of/IN the/DT execution/NN context/NN stack/NN as/IN the/DT running/VBG execution/NN context/NN ./.)
*0*return FUNCcompletion(VARresult).       
*0*(S return/NN (Chunk FUNCcompletion/NNP) (/( (Chunk VARresult/NNP) )/) ./.)
ID= 15.2.1.18
Summary= Runtime Semantics: GetModuleNamespace ( module )
*0*assert: VARmodule is an instance of a concrete subclass of module record. 
*0*(S assert/NN :/: VARmodule/NN is/VBZ an/DT instance/NN of/IN a/DT concrete/JJ subclass/NN of/IN module/NN record/NN ./.)
*0*assert: VARmodule.[[STATUS]] is not "uninstantiated". 
*0*(S assert/NN :/: VARmodule/NN ./. [/CC [/JJ (Chunk STATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB ``/`` uninstantiated/JJ ''/'' ./.)
*0*assert: if VARmodule.[[STATUS]] is "evaluated", VARmodule.[[EVALUATIONERROR]] is undefined. 
*0*(S assert/NN :/: if/IN (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk STATUS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` evaluated/JJ ''/'' ,/, (Chunk VARmodule/NNP) ./. [/VB [/JJ (Chunk EVALUATIONERROR/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ undefined/VBN ./.)
*0*let VARnamespace be VARmodule.[[NAMESPACE]]. 
*0*(S (Chunk let/VB VARnamespace/NNP) (Chunk be/VB VARmodule/NNP) ./. [/VB [/JJ (Chunk NAMESPACE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARnamespace is undefined, then
*0*(S if/IN (Chunk VARnamespace/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*let VARexportednames be ? VARmodule.getexportednames(« »). 
*1*(S (Chunk let/VB VARexportednames/NNP) be/VB ?/. (Chunk VARmodule.getexportednames/NNP) (/( (Chunk «/NNP) (Chunk »/NNP) )/) ./.)
*1*let VARunambiguousnames be a new empty list. 
*1*(S (Chunk let/VB VARunambiguousnames/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*1*for each VARname that is an element of VARexportednames, do
*1*(S for/IN each/DT (Chunk VARname/NNP) that/WDT is/VBZ an/DT element/NN of/IN (Chunk VARexportednames/NNP) ,/, do/VBP)
*2*let VARresolution be ? VARmodule.resolveexport(VARname, « »). 
*2*(S (Chunk let/VB VARresolution/NNP) be/VB ?/. (Chunk VARmodule.resolveexport/NNP) (/( (Chunk VARname/NNP) ,/, (Chunk «/NNP) (Chunk »/NNP) )/) ./.)
*2*if VARresolution is a resolvedbinding record, append VARname to VARunambiguousnames. 
*2*(S if/IN (Chunk VARresolution/NNP) is/VBZ a/DT resolvedbinding/NN record/NN ,/, (Chunk append/VBP VARname/NNP) to/TO (Chunk VARunambiguousnames/NNP) ./.)
*1*set VARnamespace to FUNCmodulenamespacecreate(VARmodule, VARunambiguousnames). 
*1*(S (Chunk set/VBN VARnamespace/NNP) to/TO (Chunk FUNCmodulenamespacecreate/NNP) (/( (Chunk VARmodule/NNP) ,/, (Chunk VARunambiguousnames/NNP) )/) ./.)
*0*return VARnamespace.     
*0*(S return/NN (Chunk VARnamespace/NNP) ./.)
ID= 15.2.1.19
Summary= Runtime Semantics: TopLevelModuleEvaluationJob ( sourceText, hostDefined )
*0*assert: VARsourcetext is an ecmascript source text (see clause 10). 
*0*(S assert/NN :/: (Chunk VARsourcetext/NNP) is/VBZ an/DT ecmascript/JJ source/NN text/NN (/( see/VB clause/RB 10/CD )/) ./.)
*0*let VARrealm be the current realm record. 
*0*(S (Chunk let/VB VARrealm/NNP) be/VB the/DT current/JJ realm/NN record/NN ./.)
*0*let VARm be FUNCparsemodule(VARsourcetext, VARrealm, VARhostdefined). 
*0*(S (Chunk let/VB VARm/NNP) (Chunk be/VB FUNCparsemodule/NNP) (/( (Chunk VARsourcetext/NNP) ,/, (Chunk VARrealm/NNP) ,/, (Chunk VARhostdefined/NNP) )/) ./.)
*0*if VARm is a list of errors, then
*0*(S if/IN (Chunk VARm/NNP) is/VBZ a/DT list/NN of/IN errors/NNS ,/, then/RB)
*1*perform FUNChostreporterrors(VARm). 
*1*(S perform/NN FUNChostreporterrors/NNS (/( (Chunk VARm/NNP) )/) ./.)
*1*return FUNCnormalcompletion(undefined). 
*1*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( undefined/JJ )/) ./.)
*0*perform ? VARm.instantiate(). 
*0*(S perform/NN ?/. (Chunk VARm.instantiate/NNP) (/( )/) ./.)
*0*assert: all dependencies of VARm have been transitively resolved and VARm is ready for evaluation. 
*0*(S assert/NN :/: all/DT dependencies/NNS of/IN (Chunk VARm/NNP) have/VBP been/VBN transitively/RB resolved/VBN and/CC (Chunk VARm/NNP) is/VBZ ready/JJ for/IN evaluation/NN ./.)
*0*return ? VARm.evaluate().     
*0*(S return/NN ?/. (Chunk VARm.evaluate/NNP) (/( )/) ./.)
ID= 18.2.1
Summary= eval ( x )
*0*assert: the execution context stack has at least two elements. 
*0*(S assert/NN :/: the/DT execution/NN context/NN stack/NN has/VBZ at/IN least/JJS two/CD elements/NNS ./.)
*0*let VARcallercontext be the second to top element of the execution context stack. 
*0*(S (Chunk let/VB VARcallercontext/NNP) be/VB the/DT second/JJ to/TO top/VB element/NN of/IN the/DT execution/NN context/NN stack/NN ./.)
*0*let VARcallerrealm be VARcallercontext's realm. 
*0*(S (Chunk let/VB VARcallerrealm/NNP) (Chunk be/VB VARcallercontext/NNP) 's/POS realm/NN ./.)
*0*let VARcalleerealm be the current realm record. 
*0*(S (Chunk let/VB VARcalleerealm/NNP) be/VB the/DT current/JJ realm/NN record/NN ./.)
*0*perform ? FUNChostensurecancompilestrings(VARcallerrealm, VARcalleerealm). 
*0*(S perform/NN ?/. FUNChostensurecancompilestrings/NNS (/( (Chunk VARcallerrealm/NNP) ,/, (Chunk VARcalleerealm/NNP) )/) ./.)
*0*return ? FUNCperformeval(VARx, VARcalleerealm, false, false).    
*0*(S return/NN ?/. (Chunk FUNCperformeval/NNP) (/( (Chunk VARx/NNP) ,/, (Chunk VARcalleerealm/NNP) ,/, false/JJ ,/, false/JJ )/) ./.)
ID= 18.2.1.1
Summary= Runtime Semantics: PerformEval ( x, evalRealm, strictCaller, direct )
*0*assert: if VARdirect is false, then VARstrictcaller is also false. 
*0*(S assert/NN :/: if/IN (Chunk VARdirect/NNP) is/VBZ false/JJ ,/, (Chunk then/RB VARstrictcaller/NNP) is/VBZ also/RB false/JJ ./.)
*0*if FUNCtype(VARx) is not string, return VARx. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARx/NNP) )/) is/VBZ not/RB string/JJ ,/, return/JJ (Chunk VARx/NNP) ./.)
*0*let VARthisenvrec be ! FUNCgetthisenvironment(). 
*0*(S (Chunk let/VB VARthisenvrec/NNP) be/VB !/. (Chunk FUNCgetthisenvironment/NNP) (/( )/) ./.)
*0*if VARthisenvrec is a function environment record, then
*0*(S if/IN (Chunk VARthisenvrec/NNP) is/VBZ a/DT function/NN environment/NN record/NN ,/, then/RB)
*1*let VARf be VARthisenvrec.[[FUNCTIONOBJECT]]. 
*1*(S (Chunk let/VB VARf/NNP) (Chunk be/VB VARthisenvrec/NNP) ./. [/VB [/JJ (Chunk FUNCTIONOBJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*let VARinfunction be true. 
*1*(S (Chunk let/VB VARinfunction/NNP) be/VB true/JJ ./.)
*1*let VARinmethod be VARthisenvrec.hassuperbinding(). 
*1*(S (Chunk let/VB VARinmethod/NNP) (Chunk be/VB VARthisenvrec.hassuperbinding/NNP) (/( )/) ./.)
*1*if VARf.[[CONSTRUCTORKIND]] is "derived", let VARinderivedconstructor be true; otherwise, let VARinderivedconstructor be false. 
*1*(S if/IN (Chunk VARf/NNP) ./. [/VB [/JJ (Chunk CONSTRUCTORKIND/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` derived/JJ ''/'' ,/, (Chunk let/VB VARinderivedconstructor/NNP) be/VB true/JJ ;/: otherwise/RB ,/, (Chunk let/VB VARinderivedconstructor/NNP) be/VB false/JJ ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARinfunction be false. 
*1*(S (Chunk let/VB VARinfunction/NNP) be/VB false/JJ ./.)
*1*let VARinmethod be false. 
*1*(S (Chunk let/VB VARinmethod/NNP) be/VB false/JJ ./.)
*1*let VARinderivedconstructor be false. 
*1*(S (Chunk let/VB VARinderivedconstructor/NNP) be/VB false/JJ ./.)
*0*let VARscript be the ecmascript code that is the result of parsing VARx, interpreted as utf-16 encoded unicode text as described in 6.1.4, for the goal symbol script. if VARinfunction is false, additional early error rules from 18.2.1.1.1 are applied. if VARinmethod is false, additional early error rules from 18.2.1.1.2 are applied. if VARinderivedconstructor is false, additional early error rules from 18.2.1.1.3 are applied. if the parse fails, throw a syntaxerror exception. if any early errors are detected, throw a syntaxerror or a referenceerror exception, depending on the type of the error (but see also clause 16). parsing and early error detection may be interweaved in an implementation-dependent manner. 
*0*(S (Chunk let/VB VARscript/NNP) be/VB the/DT ecmascript/JJ code/NN that/WDT is/VBZ the/DT result/NN of/IN (Chunk parsing/VBG VARx/NNP) ,/, interpreted/VBD as/IN utf-16/JJ encoded/VBD unicode/JJ text/NN as/IN described/VBN in/IN 6.1.4/CD ,/, for/IN the/DT goal/NN symbol/NN script/NN ./. if/IN (Chunk VARinfunction/NNP) is/VBZ false/JJ ,/, additional/JJ early/JJ error/NN rules/NNS from/IN 18.2.1.1.1/CD are/VBP applied/VBN ./. if/IN (Chunk VARinmethod/NNP) is/VBZ false/JJ ,/, additional/JJ early/JJ error/NN rules/NNS from/IN 18.2.1.1.2/CD are/VBP applied/VBN ./. if/IN (Chunk VARinderivedconstructor/NNP) is/VBZ false/JJ ,/, additional/JJ early/JJ error/NN rules/NNS from/IN 18.2.1.1.3/CD are/VBP applied/VBN ./. if/IN the/DT parse/NN fails/VBZ ,/, throw/VB a/DT syntaxerror/NN exception/NN ./. if/IN any/DT early/JJ errors/NNS are/VBP detected/VBN ,/, throw/VB a/DT syntaxerror/NN or/CC a/DT referenceerror/NN exception/NN ,/, depending/VBG on/IN the/DT type/NN of/IN the/DT error/NN (/( but/CC see/VBP also/RB clause/VBP 16/CD )/) ./. parsing/VBG and/CC early/JJ error/NN detection/NN may/MD be/VB interweaved/VBN in/IN an/DT implementation-dependent/JJ manner/NN ./.)
*0*if VARscript contains scriptbody is false, return undefined. 
*0*(S if/IN (Chunk VARscript/NNP) contains/VBZ scriptbody/NN is/VBZ false/JJ ,/, return/NN undefined/VBD ./.)
*0*let VARbody be the scriptbody of VARscript. 
*0*(S (Chunk let/VB VARbody/NNP) be/VB the/DT scriptbody/NN of/IN (Chunk VARscript/NNP) ./.)
*0*if VARstrictcaller is true, let VARstricteval be true. 
*0*(S if/IN (Chunk VARstrictcaller/NNP) is/VBZ true/JJ ,/, (Chunk let/VB VARstricteval/NNP) be/VB true/JJ ./.)
*0*else, let VARstricteval be isstrict of VARscript. 
*0*(S else/RB ,/, (Chunk let/VB VARstricteval/NNP) be/VB isstrict/NN of/IN (Chunk VARscript/NNP) ./.)
*0*let VARctx be the running execution context. 
*0*(S (Chunk let/VB VARctx/NNP) be/VB the/DT running/JJ execution/NN context/NN ./.)
*0*note: if VARdirect is true, VARctx will be the execution context that performed the direct eval. if VARdirect is false, VARctx will be the execution context for the invocation of the eval function. 
*0*(S note/NN :/: if/IN (Chunk VARdirect/NNP) is/VBZ true/JJ ,/, (Chunk VARctx/NNP) will/MD be/VB the/DT execution/NN context/NN that/WDT performed/VBD the/DT direct/JJ eval/NN ./. if/IN (Chunk VARdirect/NNP) is/VBZ false/JJ ,/, (Chunk VARctx/NNP) will/MD be/VB the/DT execution/NN context/NN for/IN the/DT invocation/NN of/IN the/DT eval/JJ function/NN ./.)
*0*if VARdirect is true, then
*0*(S if/IN (Chunk VARdirect/NNP) is/VBZ true/JJ ,/, then/RB)
*1*let VARlexenv be FUNCnewdeclarativeenvironment(VARctx's lexicalenvironment). 
*1*(S (Chunk let/VB VARlexenv/NNP) (Chunk be/VB FUNCnewdeclarativeenvironment/NNP) (/( (Chunk VARctx/NNP) 's/POS lexicalenvironment/NN )/) ./.)
*1*let VARvarenv be VARctx's variableenvironment. 
*1*(S (Chunk let/VB VARvarenv/NNP) (Chunk be/VB VARctx/NNP) 's/POS variableenvironment/NN ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARlexenv be FUNCnewdeclarativeenvironment(VARevalrealm.[[GLOBALENV]]). 
*1*(S (Chunk let/VB VARlexenv/NNP) (Chunk be/VB FUNCnewdeclarativeenvironment/NNP) (/( (Chunk VARevalrealm/NNP) ./. [/VB [/JJ (Chunk GLOBALENV/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*1*let VARvarenv be VARevalrealm.[[GLOBALENV]]. 
*1*(S (Chunk let/VB VARvarenv/NNP) (Chunk be/VB VARevalrealm/NNP) ./. [/VB [/JJ (Chunk GLOBALENV/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARstricteval is true, set VARvarenv to VARlexenv. 
*0*(S if/IN (Chunk VARstricteval/NNP) is/VBZ true/JJ ,/, (Chunk set/VBN VARvarenv/NNP) to/TO (Chunk VARlexenv/NNP) ./.)
*0*if VARctx is not already suspended, suspend VARctx. 
*0*(S if/IN (Chunk VARctx/NNP) is/VBZ not/RB already/RB suspended/VBN ,/, (Chunk suspend/VBP VARctx/NNP) ./.)
*0*let VARevalcxt be a new ecmascript code execution context. 
*0*(S (Chunk let/VB VARevalcxt/NNP) be/VB a/DT new/JJ ecmascript/NN code/NN execution/NN context/NN ./.)
*0*set the VARevalcxt's function to null. 
*0*(S set/VB the/DT (Chunk VARevalcxt/NNP) 's/POS function/NN to/TO null/VB ./.)
*0*set the VARevalcxt's realm to VARevalrealm. 
*0*(S set/VB the/DT (Chunk VARevalcxt/NNP) 's/POS realm/NN to/TO (Chunk VARevalrealm/NNP) ./.)
*0*set the VARevalcxt's scriptormodule to VARctx's scriptormodule. 
*0*(S set/VB the/DT (Chunk VARevalcxt/NNP) 's/POS scriptormodule/NN to/TO (Chunk VARctx/NNP) 's/POS scriptormodule/NN ./.)
*0*set the VARevalcxt's variableenvironment to VARvarenv. 
*0*(S set/VB the/DT (Chunk VARevalcxt/NNP) 's/POS variableenvironment/NN to/TO (Chunk VARvarenv/NNP) ./.)
*0*set the VARevalcxt's lexicalenvironment to VARlexenv. 
*0*(S set/VB the/DT (Chunk VARevalcxt/NNP) 's/POS lexicalenvironment/NN to/TO (Chunk VARlexenv/NNP) ./.)
*0*push VARevalcxt on to the execution context stack; VARevalcxt is now the running execution context. 
*0*(S push/NN (Chunk VARevalcxt/NNP) on/IN to/TO the/DT execution/NN context/NN stack/NN ;/: (Chunk VARevalcxt/NNP) is/VBZ now/RB the/DT running/VBG execution/NN context/NN ./.)
*0*let VARresult be FUNCevaldeclarationinstantiation(VARbody, VARvarenv, VARlexenv, VARstricteval). 
*0*(S (Chunk let/VB VARresult/NNP) (Chunk be/VB FUNCevaldeclarationinstantiation/NNP) (/( (Chunk VARbody/NNP) ,/, (Chunk VARvarenv/NNP) ,/, (Chunk VARlexenv/NNP) ,/, (Chunk VARstricteval/NNP) )/) ./.)
*0*if VARresult.[[TYPE]] is normal, then
*0*(S if/IN (Chunk VARresult/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ normal/JJ ,/, then/RB)
*1*set VARresult to the result of evaluating VARbody. 
*1*(S (Chunk set/VBN VARresult/NNP) to/TO the/DT result/NN of/IN (Chunk evaluating/VBG VARbody/NNP) ./.)
*0*if VARresult.[[TYPE]] is normal and VARresult.[[VALUE]] is empty, then
*0*(S if/IN (Chunk VARresult/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ normal/JJ and/CC (Chunk VARresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ empty/JJ ,/, then/RB)
*1*set VARresult to FUNCnormalcompletion(undefined). 
*1*(S (Chunk set/VBN VARresult/NNP) to/TO (Chunk FUNCnormalcompletion/NNP) (/( undefined/JJ )/) ./.)
*0*suspend VARevalcxt and remove it from the execution context stack. 
*0*(S suspend/NN (Chunk VARevalcxt/NNP) and/CC remove/VB it/PRP from/IN the/DT execution/NN context/NN stack/NN ./.)
*0*resume the context that is now on the top of the execution context stack as the running execution context. 
*0*(S resume/VB the/DT context/NN that/WDT is/VBZ now/RB on/IN the/DT top/NN of/IN the/DT execution/NN context/NN stack/NN as/IN the/DT running/VBG execution/NN context/NN ./.)
*0*return FUNCcompletion(VARresult).     
*0*(S return/NN (Chunk FUNCcompletion/NNP) (/( (Chunk VARresult/NNP) )/) ./.)
ID= 18.2.1.3
Summary= Runtime Semantics: EvalDeclarationInstantiation ( body, varEnv, lexEnv, strict )
*0*let VARvarnames be the vardeclarednames of VARbody. 
*0*(S (Chunk let/VB VARvarnames/NNP) be/VB the/DT vardeclarednames/NNS of/IN (Chunk VARbody/NNP) ./.)
*0*let VARvardeclarations be the varscopeddeclarations of VARbody. 
*0*(S (Chunk let/VB VARvardeclarations/NNP) be/VB the/DT varscopeddeclarations/NNS of/IN (Chunk VARbody/NNP) ./.)
*0*let VARlexenvrec be VARlexenv's environmentrecord. 
*0*(S (Chunk let/VB VARlexenvrec/NNP) (Chunk be/VB VARlexenv/NNP) 's/POS environmentrecord/NN ./.)
*0*let VARvarenvrec be VARvarenv's environmentrecord. 
*0*(S (Chunk let/VB VARvarenvrec/NNP) (Chunk be/VB VARvarenv/NNP) 's/POS environmentrecord/NN ./.)
*0*if VARstrict is false, then
*0*(S if/IN (Chunk VARstrict/NNP) is/VBZ false/JJ ,/, then/RB)
*1*if VARvarenvrec is a global environment record, then
*1*(S if/IN (Chunk VARvarenvrec/NNP) is/VBZ a/DT global/JJ environment/NN record/NN ,/, then/RB)
*2*for each VARname in VARvarnames, do
*2*(S for/IN each/DT (Chunk VARname/NNP) in/IN (Chunk VARvarnames/NNP) ,/, do/VBP)
*3*if VARvarenvrec.haslexicaldeclaration(VARname) is true, throw a syntaxerror exception. 
*3*(S if/IN (Chunk VARvarenvrec.haslexicaldeclaration/NNP) (/( (Chunk VARname/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT syntaxerror/NN exception/NN ./.)
*3*note: eval will not create a global var declaration that would be shadowed by a global lexical declaration. 
*3*(S note/NN :/: eval/NN will/MD not/RB create/VB a/DT global/JJ var/NN declaration/NN that/WDT would/MD be/VB shadowed/VBN by/IN a/DT global/JJ lexical/JJ declaration/NN ./.)
*1*let VARthislex be VARlexenv. 
*1*(S (Chunk let/VB VARthislex/NNP) (Chunk be/VB VARlexenv/NNP) ./.)
*1*assert: the following loop will terminate. 
*1*(S assert/NN :/: the/DT following/VBG loop/NN will/MD terminate/VB ./.)
*1*repeat, while VARthislex is not the same as VARvarenv,
*1*(S repeat/NN ,/, while/IN (Chunk VARthislex/NNP) is/VBZ not/RB the/DT same/JJ as/IN (Chunk VARvarenv/NNP) ,/,)
*2*let VARthisenvrec be VARthislex's environmentrecord. 
*2*(S (Chunk let/VB VARthisenvrec/NNP) (Chunk be/VB VARthislex/NNP) 's/POS environmentrecord/NN ./.)
*2*if VARthisenvrec is not an object environment record, then
*2*(S if/IN (Chunk VARthisenvrec/NNP) is/VBZ not/RB an/DT object/JJ environment/NN record/NN ,/, then/RB)
*3*note: the environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts. 
*3*(S note/NN :/: the/DT environment/NN of/IN with/IN statements/NNS can/MD not/RB contain/VB any/DT lexical/JJ declaration/NN so/IN it/PRP does/VBZ n't/RB need/VB to/TO be/VB checked/VBN for/IN var/let/NN hoisting/NN conflicts/NNS ./.)
*3*for each VARname in VARvarnames, do
*3*(S for/IN each/DT (Chunk VARname/NNP) in/IN (Chunk VARvarnames/NNP) ,/, do/VBP)
*4*if VARthisenvrec.hasbinding(VARname) is true, then
*4*(S if/IN (Chunk VARthisenvrec.hasbinding/NNP) (/( (Chunk VARname/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*5*throw a syntaxerror exception. 
*5*(S throw/VB a/DT syntaxerror/NN exception/NN ./.)
*5*note: annex b.3.5 defines alternate semantics for the above step. 
*5*(S note/NN :/: annex/NN b.3.5/NN defines/NNS alternate/VBP semantics/NNS for/IN the/DT above/JJ step/NN ./.)
*4*note: a direct eval will not hoist var declaration over a like-named lexical declaration. 
*4*(S note/NN :/: a/DT direct/JJ eval/NN will/MD not/RB hoist/VB var/NN declaration/NN over/IN a/DT like-named/JJ lexical/JJ declaration/NN ./.)
*2*set VARthislex to VARthislex's outer environment reference. 
*2*(S (Chunk set/VBN VARthislex/NNP) to/TO (Chunk VARthislex/NNP) 's/POS outer/NN environment/NN reference/NN ./.)
*0*let VARfunctionstoinitialize be a new empty list. 
*0*(S (Chunk let/VB VARfunctionstoinitialize/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARdeclaredfunctionnames be a new empty list. 
*0*(S (Chunk let/VB VARdeclaredfunctionnames/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*for each VARd in VARvardeclarations, in reverse list order, do
*0*(S for/IN each/DT (Chunk VARd/NNP) in/IN (Chunk VARvardeclarations/NNP) ,/, in/IN reverse/JJ list/NN order/NN ,/, do/VBP)
*1*if VARd is neither a variabledeclaration nor a forbinding nor a bindingidentifier, then
*1*(S if/IN (Chunk VARd/NNP) is/VBZ neither/CC a/DT variabledeclaration/NN nor/CC a/DT forbinding/NN nor/CC a/DT bindingidentifier/NN ,/, then/RB)
*2*assert: VARd is either a functiondeclaration, a generatordeclaration, an asyncfunctiondeclaration, or an asyncgeneratordeclaration. 
*2*(S assert/NN :/: (Chunk VARd/NNP) is/VBZ either/CC a/DT functiondeclaration/NN ,/, a/DT generatordeclaration/NN ,/, an/DT asyncfunctiondeclaration/NN ,/, or/CC an/DT asyncgeneratordeclaration/NN ./.)
*2*note: if there are multiple function declarations for the same name, the last declaration is used. 
*2*(S note/NN :/: if/IN there/EX are/VBP multiple/JJ function/NN declarations/NNS for/IN the/DT same/JJ name/NN ,/, the/DT last/JJ declaration/NN is/VBZ used/VBN ./.)
*2*let VARfn be the sole element of the boundnames of VARd. 
*2*(S (Chunk let/VB VARfn/NNP) be/VB the/DT sole/JJ element/NN of/IN the/DT boundnames/NNS of/IN (Chunk VARd/NNP) ./.)
*2*if VARfn is not an element of VARdeclaredfunctionnames, then
*2*(S if/IN (Chunk VARfn/NNP) is/VBZ not/RB an/DT element/NN of/IN (Chunk VARdeclaredfunctionnames/NNP) ,/, then/RB)
*3*if VARvarenvrec is a global environment record, then
*3*(S if/IN (Chunk VARvarenvrec/NNP) is/VBZ a/DT global/JJ environment/NN record/NN ,/, then/RB)
*4*let VARfndefinable be ? VARvarenvrec.candeclareglobalfunction(VARfn). 
*4*(S let/VB VARfndefinable/JJ be/VB ?/. (Chunk VARvarenvrec.candeclareglobalfunction/NNP) (/( (Chunk VARfn/NNP) )/) ./.)
*4*if VARfndefinable is false, throw a typeerror exception. 
*4*(S if/IN (Chunk VARfndefinable/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*3*append VARfn to VARdeclaredfunctionnames. 
*3*(S append/NN (Chunk VARfn/NNP) to/TO (Chunk VARdeclaredfunctionnames/NNP) ./.)
*3*insert VARd as the first element of VARfunctionstoinitialize. 
*3*(S insert/JJ (Chunk VARd/NNP) as/IN the/DT first/JJ element/NN of/IN (Chunk VARfunctionstoinitialize/NNP) ./.)
*0*note: annex b.3.3.3 adds additional steps at this point. 
*0*(S note/NN :/: annex/NN b.3.3.3/NN adds/VBZ additional/JJ steps/NNS at/IN this/DT point/NN ./.)
*0*let VARdeclaredvarnames be a new empty list. 
*0*(S (Chunk let/VB VARdeclaredvarnames/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*for each VARd in VARvardeclarations, do
*0*(S for/IN each/DT (Chunk VARd/NNP) in/IN (Chunk VARvardeclarations/NNP) ,/, do/VBP)
*1*if VARd is a variabledeclaration, a forbinding, or a bindingidentifier, then
*1*(S if/IN (Chunk VARd/NNP) is/VBZ a/DT variabledeclaration/NN ,/, a/DT forbinding/NN ,/, or/CC a/DT bindingidentifier/NN ,/, then/RB)
*2*for each string VARvn in the boundnames of VARd, do
*2*(S for/IN each/DT string/NN (Chunk VARvn/NNP) in/IN the/DT boundnames/NNS of/IN (Chunk VARd/NNP) ,/, do/VBP)
*3*if VARvn is not an element of VARdeclaredfunctionnames, then
*3*(S if/IN (Chunk VARvn/NNP) is/VBZ not/RB an/DT element/NN of/IN (Chunk VARdeclaredfunctionnames/NNP) ,/, then/RB)
*4*if VARvarenvrec is a global environment record, then
*4*(S if/IN (Chunk VARvarenvrec/NNP) is/VBZ a/DT global/JJ environment/NN record/NN ,/, then/RB)
*5*let VARvndefinable be ? VARvarenvrec.candeclareglobalvar(VARvn). 
*5*(S let/VB VARvndefinable/JJ be/VB ?/. (Chunk VARvarenvrec.candeclareglobalvar/NNP) (/( (Chunk VARvn/NNP) )/) ./.)
*5*if VARvndefinable is false, throw a typeerror exception. 
*5*(S if/IN (Chunk VARvndefinable/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*4*if VARvn is not an element of VARdeclaredvarnames, then
*4*(S if/IN (Chunk VARvn/NNP) is/VBZ not/RB an/DT element/NN of/IN (Chunk VARdeclaredvarnames/NNP) ,/, then/RB)
*5*append VARvn to VARdeclaredvarnames. 
*5*(S append/NN (Chunk VARvn/NNP) to/TO (Chunk VARdeclaredvarnames/NNP) ./.)
*0*note: no abnormal terminations occur after this algorithm step unless VARvarenvrec is a global environment record and the global object is a proxy exotic object. 
*0*(S note/NN :/: no/DT abnormal/JJ terminations/NNS occur/VBP after/IN this/DT algorithm/JJ step/NN unless/IN (Chunk VARvarenvrec/NNP) is/VBZ a/DT global/JJ environment/NN record/NN and/CC the/DT global/JJ object/NN is/VBZ a/DT proxy/JJ exotic/JJ object/NN ./.)
*0*let VARlexdeclarations be the lexicallyscopeddeclarations of VARbody. 
*0*(S (Chunk let/VB VARlexdeclarations/NNP) be/VB the/DT lexicallyscopeddeclarations/NNS of/IN (Chunk VARbody/NNP) ./.)
*0*for each element VARd in VARlexdeclarations, do
*0*(S for/IN each/DT element/NN (Chunk VARd/NNP) in/IN (Chunk VARlexdeclarations/NNP) ,/, do/VBP)
*1*note: lexically declared names are only instantiated here but not initialized. 
*1*(S note/NN :/: lexically/RB declared/VBN names/NNS are/VBP only/RB instantiated/VBN here/RB but/CC not/RB initialized/VBN ./.)
*1*for each element VARdn of the boundnames of VARd, do
*1*(S for/IN each/DT element/NN (Chunk VARdn/NNP) of/IN the/DT boundnames/NNS of/IN (Chunk VARd/NNP) ,/, do/VBP)
*2*if isconstantdeclaration of VARd is true, then
*2*(S if/IN isconstantdeclaration/NN of/IN (Chunk VARd/NNP) is/VBZ true/JJ ,/, then/RB)
*3*perform ? VARlexenvrec.createimmutablebinding(VARdn, true). 
*3*(S perform/NN ?/. (Chunk VARlexenvrec.createimmutablebinding/NNP) (/( (Chunk VARdn/NNP) ,/, true/JJ )/) ./.)
*2*else,
*2*(S else/RB ,/,)
*3*perform ? VARlexenvrec.createmutablebinding(VARdn, false). 
*3*(S perform/NN ?/. (Chunk VARlexenvrec.createmutablebinding/NNP) (/( (Chunk VARdn/NNP) ,/, false/RB )/) ./.)
*0*for each parse node VARf in VARfunctionstoinitialize, do
*0*(S for/IN each/DT parse/NN node/NN (Chunk VARf/NNP) in/IN (Chunk VARfunctionstoinitialize/NNP) ,/, do/VBP)
*1*let VARfn be the sole element of the boundnames of VARf. 
*1*(S (Chunk let/VB VARfn/NNP) be/VB the/DT sole/JJ element/NN of/IN the/DT boundnames/NNS of/IN (Chunk VARf/NNP) ./.)
*1*let VARfo be the result of performing instantiatefunctionobject for VARf with argument VARlexenv. 
*1*(S (Chunk let/VB VARfo/NNP) be/VB the/DT result/NN of/IN performing/VBG instantiatefunctionobject/NN for/IN (Chunk VARf/NNP) with/IN argument/NN (Chunk VARlexenv/NNP) ./.)
*1*if VARvarenvrec is a global environment record, then
*1*(S if/IN (Chunk VARvarenvrec/NNP) is/VBZ a/DT global/JJ environment/NN record/NN ,/, then/RB)
*2*perform ? VARvarenvrec.createglobalfunctionbinding(VARfn, VARfo, true). 
*2*(S perform/NN ?/. (Chunk VARvarenvrec.createglobalfunctionbinding/NNP) (/( (Chunk VARfn/NNP) ,/, (Chunk VARfo/NNP) ,/, true/JJ )/) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*let VARbindingexists be VARvarenvrec.hasbinding(VARfn). 
*2*(S let/VB VARbindingexists/NNS (Chunk be/VB VARvarenvrec.hasbinding/NNP) (/( (Chunk VARfn/NNP) )/) ./.)
*2*if VARbindingexists is false, then
*2*(S if/IN VARbindingexists/NNS is/VBZ false/JJ ,/, then/RB)
*3*let VARstatus be ! VARvarenvrec.createmutablebinding(VARfn, true). 
*3*(S (Chunk let/VB VARstatus/NNP) be/VB !/. (Chunk VARvarenvrec.createmutablebinding/NNP) (/( (Chunk VARfn/NNP) ,/, true/JJ )/) ./.)
*3*assert: VARstatus is not an abrupt completion because of validation preceding step 12. 
*3*(S assert/NN :/: (Chunk VARstatus/NNP) is/VBZ not/RB an/DT abrupt/JJ completion/NN because/IN of/IN validation/NN preceding/VBG step/NN 12/CD ./.)
*3*perform ! VARvarenvrec.initializebinding(VARfn, VARfo). 
*3*(S perform/NN !/. (Chunk VARvarenvrec.initializebinding/NNP) (/( (Chunk VARfn/NNP) ,/, (Chunk VARfo/NNP) )/) ./.)
*2*else,
*2*(S else/RB ,/,)
*3*perform ! VARvarenvrec.setmutablebinding(VARfn, VARfo, false). 
*3*(S perform/NN !/. (Chunk VARvarenvrec.setmutablebinding/NNP) (/( (Chunk VARfn/NNP) ,/, (Chunk VARfo/NNP) ,/, false/RB )/) ./.)
*0*for each string VARvn in VARdeclaredvarnames, in list order, do
*0*(S for/IN each/DT string/NN (Chunk VARvn/NNP) in/IN (Chunk VARdeclaredvarnames/NNP) ,/, in/IN list/NN order/NN ,/, do/VBP)
*1*if VARvarenvrec is a global environment record, then
*1*(S if/IN (Chunk VARvarenvrec/NNP) is/VBZ a/DT global/JJ environment/NN record/NN ,/, then/RB)
*2*perform ? VARvarenvrec.createglobalvarbinding(VARvn, true). 
*2*(S perform/NN ?/. (Chunk VARvarenvrec.createglobalvarbinding/NNP) (/( (Chunk VARvn/NNP) ,/, true/JJ )/) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*let VARbindingexists be VARvarenvrec.hasbinding(VARvn). 
*2*(S let/VB VARbindingexists/NNS (Chunk be/VB VARvarenvrec.hasbinding/NNP) (/( (Chunk VARvn/NNP) )/) ./.)
*2*if VARbindingexists is false, then
*2*(S if/IN VARbindingexists/NNS is/VBZ false/JJ ,/, then/RB)
*3*let VARstatus be ! VARvarenvrec.createmutablebinding(VARvn, true). 
*3*(S (Chunk let/VB VARstatus/NNP) be/VB !/. (Chunk VARvarenvrec.createmutablebinding/NNP) (/( (Chunk VARvn/NNP) ,/, true/JJ )/) ./.)
*3*assert: VARstatus is not an abrupt completion because of validation preceding step 12. 
*3*(S assert/NN :/: (Chunk VARstatus/NNP) is/VBZ not/RB an/DT abrupt/JJ completion/NN because/IN of/IN validation/NN preceding/VBG step/NN 12/CD ./.)
*3*perform ! VARvarenvrec.initializebinding(VARvn, undefined). 
*3*(S perform/NN !/. (Chunk VARvarenvrec.initializebinding/NNP) (/( (Chunk VARvn/NNP) ,/, undefined/VBD )/) ./.)
*0*return FUNCnormalcompletion(empty).     
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( empty/JJ )/) ./.)
ID= 18.2.2
Summary= isFinite ( number )
*0*let VARnum be ? FUNCtonumber(VARnumber). 
*0*(S (Chunk let/VB VARnum/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARnumber/NNP) )/) ./.)
*0*if VARnum is nan, +∞, or -∞, return false. 
*0*(S if/IN (Chunk VARnum/NNP) is/VBZ nan/JJ ,/, +∞/JJ ,/, or/CC -∞/NN ,/, return/NN false/JJ ./.)
*0*otherwise, return true.    
*0*(S otherwise/RB ,/, return/NN true/JJ ./.)
ID= 18.2.3
Summary= isNaN ( number )
*0*let VARnum be ? FUNCtonumber(VARnumber). 
*0*(S (Chunk let/VB VARnum/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARnumber/NNP) )/) ./.)
*0*if VARnum is nan, return true. 
*0*(S if/IN (Chunk VARnum/NNP) is/VBZ nan/JJ ,/, return/VB true/JJ ./.)
*0*otherwise, return false.    
*0*(S otherwise/RB ,/, return/NN false/JJ ./.)
ID= 18.2.4
Summary= parseFloat ( string )
*0*let VARinputstring be ? FUNCtostring(VARstring). 
*0*(S let/VB VARinputstring/VBG be/VB ?/. (Chunk FUNCtostring/NNP) (/( VARstring/VBG )/) ./.)
*0*let VARtrimmedstring be a substring of VARinputstring consisting of the leftmost code unit that is not a strwhitespacechar and all code units to the right of that code unit. (in other words, remove leading white space.) if VARinputstring does not contain any such code units, let VARtrimmedstring be the empty string. 
*0*(S (Chunk let/VB VARtrimmedstring/NNP) be/VB a/DT substring/NN of/IN VARinputstring/VBG consisting/VBG of/IN the/DT leftmost/JJS code/NN unit/NN that/WDT is/VBZ not/RB a/DT strwhitespacechar/NN and/CC all/DT code/VBP units/NNS to/TO the/DT right/NN of/IN that/DT code/NN unit/NN ./. (/( in/IN other/JJ words/NNS ,/, remove/VB leading/VBG white/JJ space/NN ./. )/) if/IN (Chunk VARinputstring/NNP) does/VBZ not/RB contain/VB any/DT such/JJ code/NN units/NNS ,/, (Chunk let/VB VARtrimmedstring/NNP) be/VB the/DT empty/JJ string/NN ./.)
*0*if neither VARtrimmedstring nor any prefix of VARtrimmedstring satisfies the syntax of a strdecimalliteral (see 7.1.3.1), return nan. 
*0*(S if/IN neither/DT (Chunk VARtrimmedstring/NNP) nor/CC any/DT prefix/NN of/IN VARtrimmedstring/VBG satisfies/NNS the/DT syntax/NN of/IN a/DT strdecimalliteral/JJ (/( see/VB 7.1.3.1/CD )/) ,/, return/VBP nan/RB ./.)
*0*let VARnumberstring be the longest prefix of VARtrimmedstring, which might be VARtrimmedstring itself, that satisfies the syntax of a strdecimalliteral. 
*0*(S (Chunk let/VB VARnumberstring/NNP) be/VB the/DT longest/JJS prefix/NN of/IN (Chunk VARtrimmedstring/NNP) ,/, which/WDT might/MD be/VB VARtrimmedstring/VBG itself/PRP ,/, that/IN satisfies/VBZ the/DT syntax/NN of/IN a/DT strdecimalliteral/JJ ./.)
*0*let VARmathfloat be mv of VARnumberstring. 
*0*(S (Chunk let/VB VARmathfloat/NNP) be/VB mv/VBN of/IN (Chunk VARnumberstring/NNP) ./.)
*0*if VARmathfloat=0, then
*0*(S if/IN (Chunk VARmathfloat=0/NNP) ,/, then/RB)
*1*if the first code unit of VARtrimmedstring is the code unit 0x002d (hyphen-minus), return -0. 
*1*(S if/IN the/DT first/JJ code/NN unit/NN of/IN (Chunk VARtrimmedstring/NNP) is/VBZ the/DT code/NN unit/NN 0x002d/CD (/( hyphen-minus/NN )/) ,/, return/VBP -0/UH ./.)
*1*return +0. 
*1*(S return/NN +0/NN ./.)
*0*return the number value for VARmathfloat.    
*0*(S return/VB the/DT number/NN value/NN for/IN (Chunk VARmathfloat/NNP) ./.)
ID= 18.2.5
Summary= parseInt ( string, radix )
*0*let VARinputstring be ? FUNCtostring(VARstring). 
*0*(S let/VB VARinputstring/VBG be/VB ?/. (Chunk FUNCtostring/NNP) (/( VARstring/VBG )/) ./.)
*0*let VARs be a newly created substring of VARinputstring consisting of the first code unit that is not a strwhitespacechar and all code units following that code unit. (in other words, remove leading white space.) if VARinputstring does not contain any such code unit, let VARs be the empty string. 
*0*(S (Chunk let/VB VARs/NNP) be/VB a/DT newly/RB created/VBN substring/NN of/IN VARinputstring/VBG consisting/VBG of/IN the/DT first/JJ code/NN unit/NN that/WDT is/VBZ not/RB a/DT strwhitespacechar/NN and/CC all/DT code/VBP units/NNS following/VBG that/IN code/JJ unit/NN ./. (/( in/IN other/JJ words/NNS ,/, remove/VB leading/VBG white/JJ space/NN ./. )/) if/IN (Chunk VARinputstring/NNP) does/VBZ not/RB contain/VB any/DT such/JJ code/NN unit/NN ,/, (Chunk let/VB VARs/NNP) be/VB the/DT empty/JJ string/NN ./.)
*0*let VARsign be 1. 
*0*(S (Chunk let/VB VARsign/NNP) be/VB 1/CD ./.)
*0*if VARs is not empty and the first code unit of VARs is the code unit 0x002d (hyphen-minus), let VARsign be -1. 
*0*(S if/IN (Chunk VARs/NNP) is/VBZ not/RB empty/JJ and/CC the/DT first/JJ code/NN unit/NN of/IN (Chunk VARs/NNP) is/VBZ the/DT code/NN unit/NN 0x002d/CD (/( hyphen-minus/NN )/) ,/, (Chunk let/VB VARsign/NNP) be/VB -1/VBN ./.)
*0*if VARs is not empty and the first code unit of VARs is the code unit 0x002b (plus sign) or the code unit 0x002d (hyphen-minus), remove the first code unit from VARs. 
*0*(S if/IN (Chunk VARs/NNP) is/VBZ not/RB empty/JJ and/CC the/DT first/JJ code/NN unit/NN of/IN (Chunk VARs/NNP) is/VBZ the/DT code/NN unit/NN 0x002b/CD (/( plus/CC sign/NN )/) or/CC the/DT code/NN unit/NN 0x002d/CD (/( hyphen-minus/NN )/) ,/, remove/VB the/DT first/JJ code/NN unit/NN from/IN (Chunk VARs/NNP) ./.)
*0*let VARr be ? FUNCtoint32(VARradix). 
*0*(S (Chunk let/VB VARr/NNP) be/VB ?/. (Chunk FUNCtoint32/NNP) (/( (Chunk VARradix/NNP) )/) ./.)
*0*let VARstripprefix be true. 
*0*(S (Chunk let/VB VARstripprefix/NNP) be/VB true/JJ ./.)
*0*if VARr ≠ 0, then
*0*(S if/IN (Chunk VARr/NNP) ≠/VBD 0/CD ,/, then/RB)
*1*if VARr &lt; 2 or VARr &gt; 36, return nan. 
*1*(S if/IN (Chunk VARr/NNP) &/CC lt/NN ;/: 2/CD or/CC (Chunk VARr/NNP) &/CC gt/NN ;/: 36/CD ,/, return/NN nan/NN ./.)
*1*if VARr ≠ 16, let VARstripprefix be false. 
*1*(S if/IN (Chunk VARr/NNP) ≠/VBD 16/CD ,/, (Chunk let/VB VARstripprefix/NNP) be/VB false/JJ ./.)
*0*else VARr = 0,
*0*(S (Chunk else/RB VARr/NNP) (Chunk =/NNP) 0/CD ,/,)
*1*let VARr be 10. 
*1*(S (Chunk let/VB VARr/NNP) be/VB 10/CD ./.)
*0*if VARstripprefix is true, then
*0*(S if/IN (Chunk VARstripprefix/NNP) is/VBZ true/JJ ,/, then/RB)
*1*if the length of VARs is at least 2 and the first two code units of VARs are either "0x" or "0x", remove the first two code units from VARs and let VARr be 16. 
*1*(S if/IN the/DT length/NN of/IN (Chunk VARs/NNP) is/VBZ at/IN least/JJS 2/CD and/CC the/DT first/JJ two/CD code/VBP units/NNS of/IN (Chunk VARs/NNP) are/VBP either/DT ``/`` 0x/CD ''/'' or/CC ``/`` 0x/CD ''/'' ,/, remove/VB the/DT first/JJ two/CD code/VBP units/NNS from/IN (Chunk VARs/NNP) and/CC (Chunk let/VB VARr/NNP) be/VB 16/CD ./.)
*0*if VARs contains a code unit that is not a radix-VARr digit, let VARz be the substring of VARs consisting of all code units before the first such code unit; otherwise, let VARz be VARs. 
*0*(S if/IN (Chunk VARs/NNP) contains/VBZ a/DT code/NN unit/NN that/WDT is/VBZ not/RB a/DT radix-VARr/JJ digit/NN ,/, (Chunk let/VB VARz/NNP) be/VB the/DT substring/NN of/IN (Chunk VARs/NNP) consisting/VBG of/IN all/DT code/NNS units/NNS before/IN the/DT first/JJ such/JJ code/NN unit/NN ;/: otherwise/RB ,/, (Chunk let/VB VARz/NNP) (Chunk be/VB VARs/NNP) ./.)
*0*if VARz is empty, return nan. 
*0*(S if/IN (Chunk VARz/NNP) is/VBZ empty/JJ ,/, return/VB nan/NNS ./.)
*0*let VARmathint be the mathematical integer value that is represented by VARz in radix-VARr notation, using the letters a-z and a-z for digits with values 10 through 35. (however, if VARr is 10 and VARz contains more than 20 significant digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the implementation; and if VARr is not 2, 4, 8, 10, 16, or 32, then VARmathint may be an implementation-dependent approximation to the mathematical integer value that is represented by VARz in radix-VARr notation.) 
*0*(S (Chunk let/VB VARmathint/NNP) be/VB the/DT mathematical/JJ integer/NN value/NN that/WDT is/VBZ represented/VBN by/IN (Chunk VARz/NNP) in/IN radix-VARr/JJ notation/NN ,/, using/VBG the/DT letters/NNS a-z/JJ and/CC a-z/JJ for/IN digits/NNS with/IN values/NNS 10/CD through/IN 35/CD ./. (/( however/RB ,/, if/IN (Chunk VARr/NNP) is/VBZ 10/CD and/CC (Chunk VARz/NNP) contains/VBZ more/JJR than/IN 20/CD significant/JJ digits/NNS ,/, every/DT significant/JJ digit/NN after/IN the/DT 20th/JJ may/MD be/VB replaced/VBN by/IN a/DT 0/CD digit/NN ,/, at/IN the/DT option/NN of/IN the/DT implementation/NN ;/: and/CC if/IN (Chunk VARr/NNP) is/VBZ not/RB 2/CD ,/, 4/CD ,/, 8/CD ,/, 10/CD ,/, 16/CD ,/, or/CC 32/CD ,/, (Chunk then/RB VARmathint/NNP) may/MD be/VB an/DT implementation-dependent/JJ approximation/NN to/TO the/DT mathematical/JJ integer/NN value/NN that/WDT is/VBZ represented/VBN by/IN (Chunk VARz/NNP) in/IN radix-VARr/JJ notation/NN ./. )/))
*0*if VARmathint = 0, then
*0*(S if/IN (Chunk VARmathint/NNP) =/VBD 0/CD ,/, then/RB)
*1*if VARsign = -1, return -0. 
*1*(S if/IN (Chunk VARsign/NNP) (Chunk =/NNP) (Chunk -1/NNP) ,/, return/NN -0/NN ./.)
*1*return +0. 
*1*(S return/NN +0/NN ./.)
*0*let VARnumber be the number value for VARmathint. 
*0*(S (Chunk let/VB VARnumber/NNP) be/VB the/DT number/NN value/NN for/IN (Chunk VARmathint/NNP) ./.)
*0*return VARsign × VARnumber.    
*0*(S return/NN (Chunk VARsign/NNP) (Chunk ×/NNP) (Chunk VARnumber/NNP) ./.)
ID= 18.2.6.1.1
Summary= Runtime Semantics: Encode ( string, unescapedSet )
*0*let VARstrlen be the number of code units in VARstring. 
*0*(S (Chunk let/VB VARstrlen/NNP) be/VB the/DT number/NN of/IN code/JJ units/NNS in/IN (Chunk VARstring/NNP) ./.)
*0*let VARr be the empty string. 
*0*(S (Chunk let/VB VARr/NNP) be/VB the/DT empty/JJ string/NN ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*repeat,
*0*(S repeat/NN ,/,)
*1*if VARk equals VARstrlen, return VARr. 
*1*(S if/IN (Chunk VARk/NNP) equals/NNS (Chunk VARstrlen/NNP) ,/, return/NN (Chunk VARr/NNP) ./.)
*1*let VARc be the code unit at index VARk within VARstring. 
*1*(S (Chunk let/VB VARc/NNP) be/VB the/DT code/NN unit/NN at/IN index/NN (Chunk VARk/NNP) within/IN (Chunk VARstring/NNP) ./.)
*1*if VARc is in VARunescapedset, then
*1*(S if/IN (Chunk VARc/NNP) is/VBZ in/IN (Chunk VARunescapedset/NNP) ,/, then/RB)
*2*let VARs be the string value containing only the code unit VARc. 
*2*(S (Chunk let/VB VARs/NNP) be/VB the/DT string/VBG value/NN containing/VBG only/RB the/DT code/NN unit/NN (Chunk VARc/NNP) ./.)
*2*set VARr to the string-concatenation of the previous value of VARr and VARs. 
*2*(S (Chunk set/VBN VARr/NNP) to/TO the/DT string-concatenation/NN of/IN the/DT previous/JJ value/NN of/IN (Chunk VARr/NNP) and/CC (Chunk VARs/NNP) ./.)
*1*else VARc is not in VARunescapedset,
*1*(S (Chunk else/RB VARc/NNP) is/VBZ not/RB in/IN (Chunk VARunescapedset/NNP) ,/,)
*2*if VARc is a trailing surrogate, throw a urierror exception. 
*2*(S if/IN (Chunk VARc/NNP) is/VBZ a/DT trailing/VBG surrogate/NN ,/, throw/VB a/DT urierror/JJ exception/NN ./.)
*2*if VARc is not a leading surrogate, then
*2*(S if/IN (Chunk VARc/NNP) is/VBZ not/RB a/DT leading/VBG surrogate/NN ,/, then/RB)
*3*let VARv be the code point with the same numeric value as code unit VARc. 
*3*(S (Chunk let/VB VARv/NNP) be/VB the/DT code/NN point/NN with/IN the/DT same/JJ numeric/JJ value/NN as/IN code/NN unit/NN (Chunk VARc/NNP) ./.)
*2*else,
*2*(S else/RB ,/,)
*3*increase VARk by 1. 
*3*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*3*if VARk equals VARstrlen, throw a urierror exception. 
*3*(S if/IN (Chunk VARk/NNP) equals/NNS (Chunk VARstrlen/NNP) ,/, throw/VBP a/DT urierror/JJ exception/NN ./.)
*3*let VARkchar be the code unit at index VARk within VARstring. 
*3*(S (Chunk let/VB VARkchar/NNP) be/VB the/DT code/NN unit/NN at/IN index/NN (Chunk VARk/NNP) within/IN (Chunk VARstring/NNP) ./.)
*3*if VARkchar is not a trailing surrogate, throw a urierror exception. 
*3*(S if/IN (Chunk VARkchar/NNP) is/VBZ not/RB a/DT trailing/NN surrogate/NN ,/, throw/VB a/DT urierror/JJ exception/NN ./.)
*3*let VARv be FUNCutf16decode(VARc, VARkchar). 
*3*(S (Chunk let/VB VARv/NNP) (Chunk be/VB FUNCutf16decode/NNP) (/( (Chunk VARc/NNP) ,/, (Chunk VARkchar/NNP) )/) ./.)
*2*let VARoctets be the list of octets resulting by applying the utf-8 transformation to VARv. 
*2*(S let/VB VARoctets/NNS be/VB the/DT list/NN of/IN octets/NNS resulting/VBG by/IN applying/VBG the/DT utf-8/JJ transformation/NN to/TO (Chunk VARv/NNP) ./.)
*2*for each element VARoctet of VARoctets in list order, do
*2*(S for/IN each/DT element/NN (Chunk VARoctet/NNP) of/IN (Chunk VARoctets/NNP) in/IN list/NN order/NN ,/, do/VBP)
*3*let VARs be the string-concatenation of:"%" the string representation of VARoctet, formatted as a two-digit uppercase hexadecimal number, padded to the left with a zero if necessary 
*3*(S (Chunk let/VB VARs/NNP) be/VB the/DT string-concatenation/NN of/IN :/: ''/'' %/NN ''/'' the/DT string/NN representation/NN of/IN (Chunk VARoctet/NNP) ,/, formatted/VBD as/IN a/DT two-digit/JJ uppercase/NN hexadecimal/JJ number/NN ,/, padded/VBD to/TO the/DT left/NN with/IN a/DT zero/NN if/IN necessary/JJ)
*3*set VARr to the string-concatenation of the previous value of VARr and VARs. 
*3*(S (Chunk set/VBN VARr/NNP) to/TO the/DT string-concatenation/NN of/IN the/DT previous/JJ value/NN of/IN (Chunk VARr/NNP) and/CC (Chunk VARs/NNP) ./.)
*1*increase VARk by 1.      
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
ID= 18.2.6.1.2
Summary= Runtime Semantics: Decode ( string, reservedSet )
*0*let VARstrlen be the number of code units in VARstring. 
*0*(S (Chunk let/VB VARstrlen/NNP) be/VB the/DT number/NN of/IN code/JJ units/NNS in/IN (Chunk VARstring/NNP) ./.)
*0*let VARr be the empty string. 
*0*(S (Chunk let/VB VARr/NNP) be/VB the/DT empty/JJ string/NN ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*repeat,
*0*(S repeat/NN ,/,)
*1*if VARk equals VARstrlen, return VARr. 
*1*(S if/IN (Chunk VARk/NNP) equals/NNS (Chunk VARstrlen/NNP) ,/, return/NN (Chunk VARr/NNP) ./.)
*1*let VARc be the code unit at index VARk within VARstring. 
*1*(S (Chunk let/VB VARc/NNP) be/VB the/DT code/NN unit/NN at/IN index/NN (Chunk VARk/NNP) within/IN (Chunk VARstring/NNP) ./.)
*1*if VARc is not the code unit 0x0025 (percent sign), then
*1*(S if/IN (Chunk VARc/NNP) is/VBZ not/RB the/DT code/NN unit/NN 0x0025/CD (/( percent/JJ sign/NN )/) ,/, then/RB)
*2*let VARs be the string value containing only the code unit VARc. 
*2*(S (Chunk let/VB VARs/NNP) be/VB the/DT string/VBG value/NN containing/VBG only/RB the/DT code/NN unit/NN (Chunk VARc/NNP) ./.)
*1*else VARc is the code unit 0x0025 (percent sign),
*1*(S (Chunk else/RB VARc/NNP) is/VBZ the/DT code/NN unit/NN 0x0025/CD (/( percent/JJ sign/NN )/) ,/,)
*2*let VARstart be VARk. 
*2*(S (Chunk let/VB VARstart/NNP) (Chunk be/VB VARk/NNP) ./.)
*2*if VARk + 2 is greater than or equal to VARstrlen, throw a urierror exception. 
*2*(S if/IN (Chunk VARk/NNP) (Chunk +/NNP) 2/CD is/VBZ greater/JJR than/IN or/CC equal/JJ to/TO (Chunk VARstrlen/NNP) ,/, throw/VBP a/DT urierror/JJ exception/NN ./.)
*2*if the code units at index (VARk + 1) and (VARk + 2) within VARstring do not represent hexadecimal digits, throw a urierror exception. 
*2*(S if/IN the/DT code/NN units/NNS at/IN index/NN (/( (Chunk VARk/NNP) (Chunk +/NNP) 1/CD )/) and/CC (/( (Chunk VARk/NNP) (Chunk +/NNP) 2/CD )/) within/IN VARstring/VBG do/VBP not/RB represent/VB hexadecimal/JJ digits/NNS ,/, throw/VBP a/DT urierror/JJ exception/NN ./.)
*2*let VARb be the 8-bit value represented by the two hexadecimal digits at index (VARk + 1) and (VARk + 2). 
*2*(S (Chunk let/VB VARb/NNP) be/VB the/DT 8-bit/JJ value/NN represented/VBN by/IN the/DT two/CD hexadecimal/JJ digits/NNS at/IN index/NN (/( (Chunk VARk/NNP) (Chunk +/NNP) 1/CD )/) and/CC (/( (Chunk VARk/NNP) (Chunk +/NNP) 2/CD )/) ./.)
*2*increment VARk by 2. 
*2*(S increment/NN (Chunk VARk/NNP) by/IN 2/CD ./.)
*2*if the most significant bit in VARb is 0, then
*2*(S if/IN the/DT most/RBS significant/JJ bit/NN in/IN (Chunk VARb/NNP) is/VBZ 0/CD ,/, then/RB)
*3*let VARc be the code unit whose value is VARb. 
*3*(S (Chunk let/VB VARc/NNP) be/VB the/DT code/NN unit/NN whose/WP$ value/NN (Chunk is/VBZ VARb/NNP) ./.)
*3*if VARc is not in VARreservedset, then
*3*(S if/IN (Chunk VARc/NNP) is/VBZ not/RB in/IN (Chunk VARreservedset/NNP) ,/, then/RB)
*4*let VARs be the string value containing only the code unit VARc. 
*4*(S (Chunk let/VB VARs/NNP) be/VB the/DT string/VBG value/NN containing/VBG only/RB the/DT code/NN unit/NN (Chunk VARc/NNP) ./.)
*3*else VARc is in VARreservedset,
*3*(S (Chunk else/RB VARc/NNP) is/VBZ in/IN (Chunk VARreservedset/NNP) ,/,)
*4*let VARs be the substring of VARstring from index VARstart to index VARk inclusive. 
*4*(S (Chunk let/VB VARs/NNP) be/VB the/DT substring/NN of/IN VARstring/VBG from/IN index/NN (Chunk VARstart/NNP) to/TO index/NN (Chunk VARk/NNP) inclusive/NN ./.)
*2*else the most significant bit in VARb is 1,
*2*(S else/RB the/DT most/RBS significant/JJ bit/NN in/IN (Chunk VARb/NNP) is/VBZ 1/CD ,/,)
*3*let VARn be the smallest nonnegative integer such that (VARb &lt;&lt; VARn) &amp; 0x80 is equal to 0. 
*3*(S (Chunk let/VB VARn/NNP) be/VB the/DT smallest/JJS nonnegative/JJ integer/NN such/JJ that/IN (/( (Chunk VARb/NNP) &/CC lt/NN ;/: &/CC lt/NN ;/: (Chunk VARn/NNP) )/) &/CC amp/NN ;/: 0x80/CD is/VBZ equal/JJ to/TO 0/CD ./.)
*3*if VARn equals 1 or VARn is greater than 4, throw a urierror exception. 
*3*(S if/IN (Chunk VARn/NNP) equals/VBZ 1/CD or/CC (Chunk VARn/NNP) is/VBZ greater/JJR than/IN 4/CD ,/, throw/VBP a/DT urierror/JJ exception/NN ./.)
*3*let VARoctets be a list of 8-bit integers of size VARn. 
*3*(S let/VB VARoctets/NNS be/VB a/DT list/NN of/IN 8-bit/JJ integers/NNS of/IN size/NN (Chunk VARn/NNP) ./.)
*3*set VARoctets[0] to VARb. 
*3*(S set/VBN VARoctets/NNS [/VBP 0/CD ]/NN to/TO (Chunk VARb/NNP) ./.)
*3*if VARk + (3 × (VARn - 1)) is greater than or equal to VARstrlen, throw a urierror exception. 
*3*(S if/IN (Chunk VARk/NNP) (Chunk +/NNP) (/( 3/CD ×/NN (/( (Chunk VARn/NNP) -/: 1/CD )/) )/) is/VBZ greater/JJR than/IN or/CC equal/JJ to/TO (Chunk VARstrlen/NNP) ,/, throw/VBP a/DT urierror/JJ exception/NN ./.)
*3*let VARj be 1. 
*3*(S (Chunk let/VB VARj/NNP) be/VB 1/CD ./.)
*3*repeat, while VARj &lt; VARn
*3*(S repeat/NN ,/, while/IN (Chunk VARj/NNP) &/CC lt/NN ;/: (Chunk VARn/NNP))
*4*increment VARk by 1. 
*4*(S increment/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*4*if the code unit at index VARk within VARstring is not the code unit 0x0025 (percent sign), throw a urierror exception. 
*4*(S if/IN the/DT code/NN unit/NN at/IN index/NN (Chunk VARk/NNP) within/IN (Chunk VARstring/NNP) is/VBZ not/RB the/DT code/NN unit/NN 0x0025/CD (/( percent/JJ sign/NN )/) ,/, throw/VBP a/DT urierror/JJ exception/NN ./.)
*4*if the code units at index (VARk + 1) and (VARk + 2) within VARstring do not represent hexadecimal digits, throw a urierror exception. 
*4*(S if/IN the/DT code/NN units/NNS at/IN index/NN (/( (Chunk VARk/NNP) (Chunk +/NNP) 1/CD )/) and/CC (/( (Chunk VARk/NNP) (Chunk +/NNP) 2/CD )/) within/IN VARstring/VBG do/VBP not/RB represent/VB hexadecimal/JJ digits/NNS ,/, throw/VBP a/DT urierror/JJ exception/NN ./.)
*4*let VARb be the 8-bit value represented by the two hexadecimal digits at index (VARk + 1) and (VARk + 2). 
*4*(S (Chunk let/VB VARb/NNP) be/VB the/DT 8-bit/JJ value/NN represented/VBN by/IN the/DT two/CD hexadecimal/JJ digits/NNS at/IN index/NN (/( (Chunk VARk/NNP) (Chunk +/NNP) 1/CD )/) and/CC (/( (Chunk VARk/NNP) (Chunk +/NNP) 2/CD )/) ./.)
*4*if the two most significant bits in VARb are not 10, throw a urierror exception. 
*4*(S if/IN the/DT two/CD most/RBS significant/JJ bits/NNS in/IN (Chunk VARb/NNP) are/VBP not/RB 10/CD ,/, throw/VBP a/DT urierror/JJ exception/NN ./.)
*4*increment VARk by 2. 
*4*(S increment/NN (Chunk VARk/NNP) by/IN 2/CD ./.)
*4*set VARoctets[VARj] to VARb. 
*4*(S set/VBN VARoctets/NNS (Chunk [/VBP VARj/NNP) (Chunk ]/NNP) to/TO (Chunk VARb/NNP) ./.)
*4*increment VARj by 1. 
*4*(S increment/NN (Chunk VARj/NNP) by/IN 1/CD ./.)
*3*if VARoctets does not contain a valid utf-8 encoding of a unicode code point, throw a urierror exception. 
*3*(S if/IN VARoctets/NNS does/VBZ not/RB contain/VB a/DT valid/JJ utf-8/JJ encoding/NN of/IN a/DT unicode/JJ code/NN point/NN ,/, throw/VB a/DT urierror/JJ exception/NN ./.)
*3*let VARv be the value obtained by applying the utf-8 transformation to VARoctets, that is, from a list of octets into a 21-bit value. 
*3*(S (Chunk let/VB VARv/NNP) be/VB the/DT value/NN obtained/VBN by/IN applying/VBG the/DT utf-8/JJ transformation/NN to/TO VARoctets/NNS ,/, that/DT is/VBZ ,/, from/IN a/DT list/NN of/IN octets/NNS into/IN a/DT 21-bit/JJ value/NN ./.)
*3*let VARs be the string value whose elements are, in order, the elements in FUNCutf16encoding(VARv). 
*3*(S (Chunk let/VB VARs/NNP) be/VB the/DT string/NN value/NN whose/WP$ elements/NNS are/VBP ,/, in/IN order/NN ,/, the/DT elements/NNS in/IN (Chunk FUNCutf16encoding/NNP) (/( (Chunk VARv/NNP) )/) ./.)
*1*set VARr to the string-concatenation of the previous value of VARr and VARs. 
*1*(S (Chunk set/VBN VARr/NNP) to/TO the/DT string-concatenation/NN of/IN the/DT previous/JJ value/NN of/IN (Chunk VARr/NNP) and/CC (Chunk VARs/NNP) ./.)
*1*increase VARk by 1.      
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
ID= 18.2.6.2
Summary= decodeURI ( encodedURI )
*0*let VARuristring be ? FUNCtostring(VARencodeduri). 
*0*(S let/VB VARuristring/VBG be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARencodeduri/NNP) )/) ./.)
*0*let VARreserveduriset be a string containing one instance of each code unit valid in urireserved plus "#". 
*0*(S (Chunk let/VB VARreserveduriset/NNP) be/VB a/DT string/NN containing/VBG one/CD instance/NN of/IN each/DT code/NN unit/NN valid/JJ in/IN urireserved/JJ plus/CC ``/`` #/# ''/'' ./.)
*0*return ? FUNCdecode(VARuristring, VARreserveduriset).     
*0*(S return/NN ?/. (Chunk FUNCdecode/NNP) (/( (Chunk VARuristring/NNP) ,/, (Chunk VARreserveduriset/NNP) )/) ./.)
ID= 18.2.6.3
Summary= decodeURIComponent ( encodedURIComponent )
*0*let VARcomponentstring be ? FUNCtostring(VARencodeduricomponent). 
*0*(S let/VB VARcomponentstring/VBG be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARencodeduricomponent/NNP) )/) ./.)
*0*let VARreserveduricomponentset be the empty string. 
*0*(S (Chunk let/VB VARreserveduricomponentset/NNP) be/VB the/DT empty/JJ string/NN ./.)
*0*return ? FUNCdecode(VARcomponentstring, VARreserveduricomponentset).     
*0*(S return/NN ?/. (Chunk FUNCdecode/NNP) (/( (Chunk VARcomponentstring/NNP) ,/, (Chunk VARreserveduricomponentset/NNP) )/) ./.)
ID= 18.2.6.4
Summary= encodeURI ( uri )
*0*let VARuristring be ? FUNCtostring(VARuri). 
*0*(S let/VB VARuristring/VBG be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARuri/NNP) )/) ./.)
*0*let VARunescapeduriset be a string containing one instance of each code unit valid in urireserved and uriunescaped plus "#". 
*0*(S (Chunk let/VB VARunescapeduriset/NNP) be/VB a/DT string/NN containing/VBG one/CD instance/NN of/IN each/DT code/NN unit/NN valid/JJ in/IN urireserved/JJ and/CC uriunescaped/JJ plus/CC ``/`` #/# ''/'' ./.)
*0*return ? FUNCencode(VARuristring, VARunescapeduriset).     
*0*(S return/NN ?/. (Chunk FUNCencode/NNP) (/( (Chunk VARuristring/NNP) ,/, (Chunk VARunescapeduriset/NNP) )/) ./.)
ID= 18.2.6.5
Summary= encodeURIComponent ( uriComponent )
*0*let VARcomponentstring be ? FUNCtostring(VARuricomponent). 
*0*(S let/VB VARcomponentstring/VBG be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARuricomponent/NNP) )/) ./.)
*0*let VARunescapeduricomponentset be a string containing one instance of each code unit valid in uriunescaped. 
*0*(S (Chunk let/VB VARunescapeduricomponentset/NNP) be/VB a/DT string/NN containing/VBG one/CD instance/NN of/IN each/DT code/NN unit/NN valid/JJ in/IN uriunescaped/JJ ./.)
*0*return ? FUNCencode(VARcomponentstring, VARunescapeduricomponentset).     
*0*(S return/NN ?/. (Chunk FUNCencode/NNP) (/( (Chunk VARcomponentstring/NNP) ,/, (Chunk VARunescapeduricomponentset/NNP) )/) ./.)
ID= 19.1.1.1
Summary= Object ( [ value ] )
*0*if newtarget is neither undefined nor the active function, then
*0*(S if/IN newtarget/DT is/VBZ neither/DT undefined/JJ nor/CC the/DT active/JJ function/NN ,/, then/RB)
*1*return ? FUNCordinarycreatefromconstructor(newtarget, "%objectprototype%"). 
*1*(S return/NN ?/. (Chunk FUNCordinarycreatefromconstructor/NNP) (/( newtarget/NN ,/, ``/`` %/NN objectprototype/JJ %/NN ''/'' )/) ./.)
*0*if VARvalue is null, undefined or not supplied, return FUNCobjectcreate(%objectprototype%). 
*0*(S if/IN (Chunk VARvalue/NNP) is/VBZ null/JJ ,/, undefined/VBD or/CC not/RB supplied/VBN ,/, (Chunk return/VB FUNCobjectcreate/NNP) (/( %/NN objectprototype/IN %/NN )/) ./.)
*0*return ! FUNCtoobject(VARvalue).     
*0*(S return/NN !/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
ID= 19.1.2.1
Summary= Object.assign ( target, ...sources )
*0*let VARto be ? FUNCtoobject(VARtarget). 
*0*(S (Chunk let/VB VARto/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARtarget/NNP) )/) ./.)
*0*if only one argument was passed, return VARto. 
*0*(S if/IN only/RB one/CD argument/NN was/VBD passed/VBN ,/, (Chunk return/VB VARto/NNP) ./.)
*0*let VARsources be the list of argument values starting with the second argument. 
*0*(S let/VB VARsources/NNS be/VB the/DT list/NN of/IN argument/NN values/NNS starting/VBG with/IN the/DT second/JJ argument/NN ./.)
*0*for each element VARnextsource of VARsources, in ascending index order, do
*0*(S for/IN each/DT element/NN (Chunk VARnextsource/NNP) of/IN (Chunk VARsources/NNP) ,/, in/IN ascending/VBG index/NN order/NN ,/, do/VBP)
*1*if VARnextsource is undefined or null, let VARkeys be a new empty list. 
*1*(S if/IN (Chunk VARnextsource/NNP) is/VBZ undefined/JJ or/CC null/JJ ,/, (Chunk let/VB VARkeys/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*1*else,
*1*(S else/RB ,/,)
*2*let VARfrom be ! FUNCtoobject(VARnextsource). 
*2*(S (Chunk let/VB VARfrom/NNP) be/VB !/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARnextsource/NNP) )/) ./.)
*2*let VARkeys be ? VARfrom.[[OWNPROPERTYKEYS]](). 
*2*(S (Chunk let/VB VARkeys/NNP) be/VB ?/. (Chunk VARfrom/NNP) ./. [/VB [/JJ (Chunk OWNPROPERTYKEYS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*1*for each element VARnextkey of VARkeys in list order, do
*1*(S for/IN each/DT element/NN (Chunk VARnextkey/NNP) of/IN (Chunk VARkeys/NNP) in/IN list/NN order/NN ,/, do/VBP)
*2*let VARdesc be ? VARfrom.[[GETOWNPROPERTY]](VARnextkey). 
*2*(S (Chunk let/VB VARdesc/NNP) be/VB ?/. (Chunk VARfrom/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARnextkey/NNP) )/) ./.)
*2*if VARdesc is not undefined and VARdesc.[[ENUMERABLE]] is true, then
*2*(S if/IN (Chunk VARdesc/NNP) is/VBZ not/RB undefined/JJ and/CC (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ true/JJ ,/, then/RB)
*3*let VARpropvalue be ? FUNCget(VARfrom, VARnextkey). 
*3*(S (Chunk let/VB VARpropvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARfrom/NNP) ,/, (Chunk VARnextkey/NNP) )/) ./.)
*3*perform ? FUNCset(VARto, VARnextkey, VARpropvalue, true). 
*3*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARto/NNP) ,/, (Chunk VARnextkey/NNP) ,/, (Chunk VARpropvalue/NNP) ,/, true/JJ )/) ./.)
*0*return VARto.     
*0*(S return/NN (Chunk VARto/NNP) ./.)
ID= 19.1.2.2
Summary= Object.create ( O, Properties )
*0*if FUNCtype(VARo) is neither object nor null, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ neither/DT object/JJ nor/CC null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARobj be FUNCobjectcreate(VARo). 
*0*(S (Chunk let/VB VARobj/NNP) (Chunk be/VB FUNCobjectcreate/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*if VARproperties is not undefined, then
*0*(S if/IN VARproperties/NNS is/VBZ not/RB undefined/JJ ,/, then/RB)
*1*return ? FUNCobjectdefineproperties(VARobj, VARproperties). 
*1*(S return/NN ?/. FUNCobjectdefineproperties/NNS (/( (Chunk VARobj/NNP) ,/, (Chunk VARproperties/NNP) )/) ./.)
*0*return VARobj.     
*0*(S return/NN (Chunk VARobj/NNP) ./.)
ID= 19.1.2.3
Summary= Object.defineProperties ( O, Properties )
*0*return ? FUNCobjectdefineproperties(VARo, VARproperties).     
*0*(S return/NN ?/. FUNCobjectdefineproperties/NNS (/( (Chunk VARo/NNP) ,/, (Chunk VARproperties/NNP) )/) ./.)
ID= 19.1.2.3.1
Summary= Runtime Semantics: ObjectDefineProperties ( O, Properties )
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARprops be ? FUNCtoobject(VARproperties). 
*0*(S (Chunk let/VB VARprops/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARproperties/NNP) )/) ./.)
*0*let VARkeys be ? VARprops.[[OWNPROPERTYKEYS]](). 
*0*(S (Chunk let/VB VARkeys/NNP) be/VB ?/. (Chunk VARprops/NNP) ./. [/VB [/JJ (Chunk OWNPROPERTYKEYS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*0*let VARdescriptors be a new empty list. 
*0*(S let/VB VARdescriptors/NNS be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*for each element VARnextkey of VARkeys in list order, do
*0*(S for/IN each/DT element/NN (Chunk VARnextkey/NNP) of/IN (Chunk VARkeys/NNP) in/IN list/NN order/NN ,/, do/VBP)
*1*let VARpropdesc be ? VARprops.[[GETOWNPROPERTY]](VARnextkey). 
*1*(S (Chunk let/VB VARpropdesc/NNP) be/VB ?/. (Chunk VARprops/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARnextkey/NNP) )/) ./.)
*1*if VARpropdesc is not undefined and VARpropdesc.[[ENUMERABLE]] is true, then
*1*(S if/IN (Chunk VARpropdesc/NNP) is/VBZ not/RB undefined/JJ and/CC (Chunk VARpropdesc/NNP) ./. [/VB [/JJ (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ true/JJ ,/, then/RB)
*2*let VARdescobj be ? FUNCget(VARprops, VARnextkey). 
*2*(S (Chunk let/VB VARdescobj/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARprops/NNP) ,/, (Chunk VARnextkey/NNP) )/) ./.)
*2*let VARdesc be ? FUNCtopropertydescriptor(VARdescobj). 
*2*(S (Chunk let/VB VARdesc/NNP) be/VB ?/. (Chunk FUNCtopropertydescriptor/NNP) (/( (Chunk VARdescobj/NNP) )/) ./.)
*2*append the pair (a two element list) consisting of VARnextkey and VARdesc to the end of VARdescriptors. 
*2*(S append/VB the/DT pair/NN (/( a/DT two/CD element/JJ list/NN )/) consisting/NN of/IN (Chunk VARnextkey/NNP) and/CC (Chunk VARdesc/NNP) to/TO the/DT end/NN of/IN VARdescriptors/NNS ./.)
*0*for each VARpair from VARdescriptors in list order, do
*0*(S for/IN each/DT (Chunk VARpair/NNP) from/IN (Chunk VARdescriptors/NNP) in/IN list/NN order/NN ,/, do/VBP)
*1*let VARp be the first element of VARpair. 
*1*(S (Chunk let/VB VARp/NNP) be/VB the/DT first/JJ element/NN of/IN (Chunk VARpair/NNP) ./.)
*1*let VARdesc be the second element of VARpair. 
*1*(S (Chunk let/VB VARdesc/NNP) be/VB the/DT second/JJ element/NN of/IN (Chunk VARpair/NNP) ./.)
*1*perform ? FUNCdefinepropertyorthrow(VARo, VARp, VARdesc). 
*1*(S perform/NN ?/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARdesc/NNP) )/) ./.)
*0*return VARo.      
*0*(S return/NN (Chunk VARo/NNP) ./.)
ID= 19.1.2.4
Summary= Object.defineProperty ( O, P, Attributes )
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARkey be ? FUNCtopropertykey(VARp). 
*0*(S (Chunk let/VB VARkey/NNP) be/VB ?/. (Chunk FUNCtopropertykey/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*let VARdesc be ? FUNCtopropertydescriptor(VARattributes). 
*0*(S (Chunk let/VB VARdesc/NNP) be/VB ?/. (Chunk FUNCtopropertydescriptor/NNP) (/( (Chunk VARattributes/NNP) )/) ./.)
*0*perform ? FUNCdefinepropertyorthrow(VARo, VARkey, VARdesc). 
*0*(S perform/NN ?/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARkey/NNP) ,/, (Chunk VARdesc/NNP) )/) ./.)
*0*return VARo.     
*0*(S return/NN (Chunk VARo/NNP) ./.)
ID= 19.1.2.5
Summary= Object.entries ( O )
*0*let VARobj be ? FUNCtoobject(VARo). 
*0*(S (Chunk let/VB VARobj/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARnamelist be ? FUNCenumerableownpropertynames(VARobj, "key+value"). 
*0*(S (Chunk let/VB VARnamelist/NNP) be/VB ?/. (Chunk FUNCenumerableownpropertynames/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` key+value/VB ''/'' )/) ./.)
*0*return FUNCcreatearrayfromlist(VARnamelist).     
*0*(S return/NN (Chunk FUNCcreatearrayfromlist/NNP) (/( (Chunk VARnamelist/NNP) )/) ./.)
ID= 19.1.2.6
Summary= Object.freeze ( O )
*0*if FUNCtype(VARo) is not object, return VARo. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, (Chunk return/VB VARo/NNP) ./.)
*0*let VARstatus be ? FUNCsetintegritylevel(VARo, "frozen"). 
*0*(S (Chunk let/VB VARstatus/NNP) be/VB ?/. (Chunk FUNCsetintegritylevel/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` frozen/JJ ''/'' )/) ./.)
*0*if VARstatus is false, throw a typeerror exception. 
*0*(S if/IN (Chunk VARstatus/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARo.     
*0*(S return/NN (Chunk VARo/NNP) ./.)
ID= 19.1.2.7
Summary= Object.getOwnPropertyDescriptor ( O, P )
*0*let VARobj be ? FUNCtoobject(VARo). 
*0*(S (Chunk let/VB VARobj/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARkey be ? FUNCtopropertykey(VARp). 
*0*(S (Chunk let/VB VARkey/NNP) be/VB ?/. (Chunk FUNCtopropertykey/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*let VARdesc be ? VARobj.[[GETOWNPROPERTY]](VARkey). 
*0*(S (Chunk let/VB VARdesc/NNP) be/VB ?/. (Chunk VARobj/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARkey/NNP) )/) ./.)
*0*return FUNCfrompropertydescriptor(VARdesc).     
*0*(S return/NN (Chunk FUNCfrompropertydescriptor/NNP) (/( (Chunk VARdesc/NNP) )/) ./.)
ID= 19.1.2.8
Summary= Object.getOwnPropertyDescriptors ( O )
*0*let VARobj be ? FUNCtoobject(VARo). 
*0*(S (Chunk let/VB VARobj/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARownkeys be ? VARobj.[[OWNPROPERTYKEYS]](). 
*0*(S (Chunk let/VB VARownkeys/NNP) be/VB ?/. (Chunk VARobj/NNP) ./. [/VB [/JJ (Chunk OWNPROPERTYKEYS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*0*let VARdescriptors be ! FUNCobjectcreate(%objectprototype%). 
*0*(S let/VB VARdescriptors/NNS be/VB !/. (Chunk FUNCobjectcreate/NNP) (/( %/NN objectprototype/IN %/NN )/) ./.)
*0*for each element VARkey of VARownkeys in list order, do
*0*(S for/IN each/DT element/NN (Chunk VARkey/NNP) of/IN (Chunk VARownkeys/NNP) in/IN list/NN order/NN ,/, do/VBP)
*1*let VARdesc be ? VARobj.[[GETOWNPROPERTY]](VARkey). 
*1*(S (Chunk let/VB VARdesc/NNP) be/VB ?/. (Chunk VARobj/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARkey/NNP) )/) ./.)
*1*let VARdescriptor be ! FUNCfrompropertydescriptor(VARdesc). 
*1*(S (Chunk let/VB VARdescriptor/NNP) be/VB !/. (Chunk FUNCfrompropertydescriptor/NNP) (/( (Chunk VARdesc/NNP) )/) ./.)
*1*if VARdescriptor is not undefined, perform ! FUNCcreatedataproperty(VARdescriptors, VARkey, VARdescriptor). 
*1*(S if/IN (Chunk VARdescriptor/NNP) is/VBZ not/RB undefined/JJ ,/, perform/NN !/. (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARdescriptors/NNP) ,/, (Chunk VARkey/NNP) ,/, (Chunk VARdescriptor/NNP) )/) ./.)
*0*return VARdescriptors.     
*0*(S return/NN VARdescriptors/NNS ./.)
ID= 19.1.2.9
Summary= Object.getOwnPropertyNames ( O )
*0*return ? FUNCgetownpropertykeys(VARo, string).     
*0*(S return/NN ?/. (Chunk FUNCgetownpropertykeys/NNP) (/( (Chunk VARo/NNP) ,/, string/VBG )/) ./.)
ID= 19.1.2.10
Summary= Object.getOwnPropertySymbols ( O )
*0*return ? FUNCgetownpropertykeys(VARo, symbol).     
*0*(S return/NN ?/. (Chunk FUNCgetownpropertykeys/NNP) (/( (Chunk VARo/NNP) ,/, symbol/NN )/) ./.)
ID= 19.1.2.10.1
Summary= Runtime Semantics: GetOwnPropertyKeys ( O, Type )
*0*let VARobj be ? FUNCtoobject(VARo). 
*0*(S (Chunk let/VB VARobj/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARkeys be ? VARobj.[[OWNPROPERTYKEYS]](). 
*0*(S (Chunk let/VB VARkeys/NNP) be/VB ?/. (Chunk VARobj/NNP) ./. [/VB [/JJ (Chunk OWNPROPERTYKEYS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*0*let VARnamelist be a new empty list. 
*0*(S (Chunk let/VB VARnamelist/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*for each element VARnextkey of VARkeys in list order, do
*0*(S for/IN each/DT element/NN (Chunk VARnextkey/NNP) of/IN (Chunk VARkeys/NNP) in/IN list/NN order/NN ,/, do/VBP)
*1*if FUNCtype(VARnextkey) is VARtype, then
*1*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARnextkey/NNP) )/) (Chunk is/VBZ VARtype/NNP) ,/, then/RB)
*2*append VARnextkey as the last element of VARnamelist. 
*2*(S (Chunk append/RB VARnextkey/NNP) as/IN the/DT last/JJ element/NN of/IN (Chunk VARnamelist/NNP) ./.)
*0*return FUNCcreatearrayfromlist(VARnamelist).      
*0*(S return/NN (Chunk FUNCcreatearrayfromlist/NNP) (/( (Chunk VARnamelist/NNP) )/) ./.)
ID= 19.1.2.11
Summary= Object.getPrototypeOf ( O )
*0*let VARobj be ? FUNCtoobject(VARo). 
*0*(S (Chunk let/VB VARobj/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*return ? VARobj.[[GETPROTOTYPEOF]]().     
*0*(S return/NN ?/. (Chunk VARobj/NNP) ./. [/VB [/JJ (Chunk GETPROTOTYPEOF/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
ID= 19.1.2.12
Summary= Object.is ( value1, value2 )
*0*return FUNCsamevalue(VARvalue1, VARvalue2).     
*0*(S return/NN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARvalue1/NNP) ,/, (Chunk VARvalue2/NNP) )/) ./.)
ID= 19.1.2.13
Summary= Object.isExtensible ( O )
*0*if FUNCtype(VARo) is not object, return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, return/NN false/JJ ./.)
*0*return ? FUNCisextensible(VARo).     
*0*(S return/NN ?/. (Chunk FUNCisextensible/NNP) (/( (Chunk VARo/NNP) )/) ./.)
ID= 19.1.2.14
Summary= Object.isFrozen ( O )
*0*if FUNCtype(VARo) is not object, return true. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, return/VB true/JJ ./.)
*0*return ? FUNCtestintegritylevel(VARo, "frozen").     
*0*(S return/NN ?/. (Chunk FUNCtestintegritylevel/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` frozen/JJ ''/'' )/) ./.)
ID= 19.1.2.15
Summary= Object.isSealed ( O )
*0*if FUNCtype(VARo) is not object, return true. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, return/VB true/JJ ./.)
*0*return ? FUNCtestintegritylevel(VARo, "sealed").     
*0*(S return/NN ?/. (Chunk FUNCtestintegritylevel/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` sealed/VBD ''/'' )/) ./.)
ID= 19.1.2.16
Summary= Object.keys ( O )
*0*let VARobj be ? FUNCtoobject(VARo). 
*0*(S (Chunk let/VB VARobj/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARnamelist be ? FUNCenumerableownpropertynames(VARobj, "key"). 
*0*(S (Chunk let/VB VARnamelist/NNP) be/VB ?/. (Chunk FUNCenumerableownpropertynames/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` key/JJ ''/'' )/) ./.)
*0*return FUNCcreatearrayfromlist(VARnamelist).     
*0*(S return/NN (Chunk FUNCcreatearrayfromlist/NNP) (/( (Chunk VARnamelist/NNP) )/) ./.)
ID= 19.1.2.17
Summary= Object.preventExtensions ( O )
*0*if FUNCtype(VARo) is not object, return VARo. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, (Chunk return/VB VARo/NNP) ./.)
*0*let VARstatus be ? VARo.[[PREVENTEXTENSIONS]](). 
*0*(S (Chunk let/VB VARstatus/NNP) be/VB ?/. (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk PREVENTEXTENSIONS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*0*if VARstatus is false, throw a typeerror exception. 
*0*(S if/IN (Chunk VARstatus/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARo.     
*0*(S return/NN (Chunk VARo/NNP) ./.)
ID= 19.1.2.19
Summary= Object.seal ( O )
*0*if FUNCtype(VARo) is not object, return VARo. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, (Chunk return/VB VARo/NNP) ./.)
*0*let VARstatus be ? FUNCsetintegritylevel(VARo, "sealed"). 
*0*(S (Chunk let/VB VARstatus/NNP) be/VB ?/. (Chunk FUNCsetintegritylevel/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` sealed/VBD ''/'' )/) ./.)
*0*if VARstatus is false, throw a typeerror exception. 
*0*(S if/IN (Chunk VARstatus/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARo.     
*0*(S return/NN (Chunk VARo/NNP) ./.)
ID= 19.1.2.20
Summary= Object.setPrototypeOf ( O, proto )
*0*let VARo be ? FUNCrequireobjectcoercible(VARo). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCrequireobjectcoercible/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*if FUNCtype(VARproto) is neither object nor null, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARproto/NNP) )/) is/VBZ neither/DT object/JJ nor/CC null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if FUNCtype(VARo) is not object, return VARo. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, (Chunk return/VB VARo/NNP) ./.)
*0*let VARstatus be ? VARo.[[SETPROTOTYPEOF]](VARproto). 
*0*(S (Chunk let/VB VARstatus/NNP) be/VB ?/. (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk SETPROTOTYPEOF/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARproto/NNP) )/) ./.)
*0*if VARstatus is false, throw a typeerror exception. 
*0*(S if/IN (Chunk VARstatus/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARo.     
*0*(S return/NN (Chunk VARo/NNP) ./.)
ID= 19.1.2.21
Summary= Object.values ( O )
*0*let VARobj be ? FUNCtoobject(VARo). 
*0*(S (Chunk let/VB VARobj/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARnamelist be ? FUNCenumerableownpropertynames(VARobj, "value"). 
*0*(S (Chunk let/VB VARnamelist/NNP) be/VB ?/. (Chunk FUNCenumerableownpropertynames/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` value/NN ''/'' )/) ./.)
*0*return FUNCcreatearrayfromlist(VARnamelist).     
*0*(S return/NN (Chunk FUNCcreatearrayfromlist/NNP) (/( (Chunk VARnamelist/NNP) )/) ./.)
ID= 19.1.3.2
Summary= Object.prototype.hasOwnProperty ( V )
*0*let VARp be ? FUNCtopropertykey(VARv). 
*0*(S (Chunk let/VB VARp/NNP) be/VB ?/. (Chunk FUNCtopropertykey/NNP) (/( (Chunk VARv/NNP) )/) ./.)
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*return ? FUNChasownproperty(VARo, VARp).     
*0*(S return/NN ?/. (Chunk FUNChasownproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
ID= 19.1.3.3
Summary= Object.prototype.isPrototypeOf ( V )
*0*if FUNCtype(VARv) is not object, return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ not/RB object/JJ ,/, return/NN false/JJ ./.)
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*repeat,
*0*(S repeat/NN ,/,)
*1*let VARv be ? VARv.[[GETPROTOTYPEOF]](). 
*1*(S (Chunk let/VB VARv/NNP) be/VB ?/. (Chunk VARv/NNP) ./. [/VB [/JJ (Chunk GETPROTOTYPEOF/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*1*if VARv is null, return false. 
*1*(S if/IN (Chunk VARv/NNP) is/VBZ null/JJ ,/, return/NN false/JJ ./.)
*1*if FUNCsamevalue(VARo, VARv) is true, return true.     
*1*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARv/NNP) )/) is/VBZ true/JJ ,/, return/VB true/JJ ./.)
ID= 19.1.3.4
Summary= Object.prototype.propertyIsEnumerable ( V )
*0*let VARp be ? FUNCtopropertykey(VARv). 
*0*(S (Chunk let/VB VARp/NNP) be/VB ?/. (Chunk FUNCtopropertykey/NNP) (/( (Chunk VARv/NNP) )/) ./.)
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARdesc be ? VARo.[[GETOWNPROPERTY]](VARp). 
*0*(S (Chunk let/VB VARdesc/NNP) be/VB ?/. (Chunk VARo/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*0*if VARdesc is undefined, return false. 
*0*(S if/IN (Chunk VARdesc/NNP) is/VBZ undefined/JJ ,/, return/NN false/JJ ./.)
*0*return VARdesc.[[ENUMERABLE]].     
*0*(S return/NN (Chunk VARdesc/NNP) ./. [/VB [/JJ (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
ID= 19.1.3.5
Summary= Object.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*return ? FUNCinvoke(VARo, "tostring").     
*0*(S return/NN ?/. (Chunk FUNCinvoke/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` tostring/VBG ''/'' )/) ./.)
ID= 19.1.3.6
Summary= Object.prototype.toString ( )
*0*if the this value is undefined, return "[object undefined]". 
*0*(S if/IN the/DT this/DT value/NN is/VBZ undefined/JJ ,/, return/VB ``/`` [/JJ object/NN (Chunk undefined/VBD ]/NNP) ''/'' ./.)
*0*if the this value is null, return "[object null]". 
*0*(S if/IN the/DT this/DT value/NN is/VBZ null/JJ ,/, return/VB ``/`` [/JJ object/JJ null/NN ]/NN ''/'' ./.)
*0*let VARo be ! FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB !/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARisarray be ? FUNCisarray(VARo). 
*0*(S (Chunk let/VB VARisarray/NNP) be/VB ?/. (Chunk FUNCisarray/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*if VARisarray is true, let VARbuiltintag be "array". 
*0*(S if/IN (Chunk VARisarray/NNP) is/VBZ true/JJ ,/, (Chunk let/VB VARbuiltintag/NNP) be/VB ``/`` array/JJ ''/'' ./.)
*0*else if VARo is a string exotic object, let VARbuiltintag be "string". 
*0*(S else/RB if/IN (Chunk VARo/NNP) is/VBZ a/DT string/NN exotic/JJ object/NN ,/, (Chunk let/VB VARbuiltintag/NNP) be/VB ``/`` string/VBG ''/'' ./.)
*0*else if VARo has a [[PARAMETERMAP]] internal slot, let VARbuiltintag be "arguments". 
*0*(S else/RB if/IN (Chunk VARo/NNP) has/VBZ a/DT [/JJ [/NN (Chunk PARAMETERMAP/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, (Chunk let/VB VARbuiltintag/NNP) be/VB ``/`` arguments/NNS ''/'' ./.)
*0*else if VARo has a [[CALL]] internal method, let VARbuiltintag be "function". 
*0*(S else/RB if/IN (Chunk VARo/NNP) has/VBZ a/DT [/JJ [/NN (Chunk CALL/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ method/NN ,/, (Chunk let/VB VARbuiltintag/NNP) be/VB ``/`` function/NN ''/'' ./.)
*0*else if VARo has an [[ERRORDATA]] internal slot, let VARbuiltintag be "error". 
*0*(S else/RB if/IN (Chunk VARo/NNP) has/VBZ an/DT [/JJ [/NN (Chunk ERRORDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, (Chunk let/VB VARbuiltintag/NNP) be/VB ``/`` error/NN ''/'' ./.)
*0*else if VARo has a [[BOOLEANDATA]] internal slot, let VARbuiltintag be "boolean". 
*0*(S else/RB if/IN (Chunk VARo/NNP) has/VBZ a/DT [/JJ [/NN (Chunk BOOLEANDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, (Chunk let/VB VARbuiltintag/NNP) be/VB ``/`` boolean/JJ ''/'' ./.)
*0*else if VARo has a [[NUMBERDATA]] internal slot, let VARbuiltintag be "number". 
*0*(S else/RB if/IN (Chunk VARo/NNP) has/VBZ a/DT [/JJ [/NN (Chunk NUMBERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, (Chunk let/VB VARbuiltintag/NNP) be/VB ``/`` number/NN ''/'' ./.)
*0*else if VARo has a [[DATEVALUE]] internal slot, let VARbuiltintag be "date". 
*0*(S else/RB if/IN (Chunk VARo/NNP) has/VBZ a/DT [/JJ [/NN (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, (Chunk let/VB VARbuiltintag/NNP) be/VB ``/`` date/NN ''/'' ./.)
*0*else if VARo has a [[REGEXPMATCHER]] internal slot, let VARbuiltintag be "regexp". 
*0*(S else/RB if/IN (Chunk VARo/NNP) has/VBZ a/DT [/JJ [/NN (Chunk REGEXPMATCHER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, (Chunk let/VB VARbuiltintag/NNP) be/VB ``/`` regexp/JJ ''/'' ./.)
*0*else, let VARbuiltintag be "object". 
*0*(S else/RB ,/, (Chunk let/VB VARbuiltintag/NNP) be/VB ``/`` object/JJ ''/'' ./.)
*0*let VARtag be ? FUNCget(VARo, @@tostringtag). 
*0*(S (Chunk let/VB VARtag/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) tostringtag/NN )/) ./.)
*0*if FUNCtype(VARtag) is not string, let VARtag be VARbuiltintag. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtag/NNP) )/) is/VBZ not/RB string/VBG ,/, (Chunk let/VB VARtag/NNP) (Chunk be/VB VARbuiltintag/NNP) ./.)
*0*return the string-concatenation of "[object ", VARtag, and "]".     
*0*(S return/VB the/DT string-concatenation/NN of/IN ``/`` [/JJ object/NN ``/`` ,/, (Chunk VARtag/NNP) ,/, and/CC ``/`` ]/JJ ''/'' ./.)
ID= 19.1.3.7
Summary= Object.prototype.valueOf ( )
*0*return ? FUNCtoobject(this value).     
*0*(S return/NN ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
ID= 19.2.1.1
Summary= Function ( p1, p2, … , pn, body )
*0*let VARc be the active function object. 
*0*(S (Chunk let/VB VARc/NNP) be/VB the/DT active/JJ function/NN object/NN ./.)
*0*let VARargs be the VARargumentslist that was passed to this function by [[CALL]] or [[CONSTRUCT]]. 
*0*(S (Chunk let/VB VARargs/NNP) be/VB the/DT (Chunk VARargumentslist/NNP) that/WDT was/VBD passed/VBN to/TO this/DT function/NN by/IN (Chunk [/NNP) (Chunk [/NNP) (Chunk CALL/NNP) (Chunk ]/NNP) (Chunk ]/NNP) or/CC (Chunk [/NNP) (Chunk [/NNP) (Chunk CONSTRUCT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*return ? FUNCcreatedynamicfunction(VARc, newtarget, "normal", VARargs).     
*0*(S return/NN ?/. (Chunk FUNCcreatedynamicfunction/NNP) (/( (Chunk VARc/NNP) ,/, newtarget/NN ,/, ``/`` normal/JJ ''/'' ,/, (Chunk VARargs/NNP) )/) ./.)
ID= 19.2.1.1.1
Summary= Runtime Semantics: CreateDynamicFunction ( constructor, newTarget, kind, args )
*0*assert: the execution context stack has at least two elements. 
*0*(S assert/NN :/: the/DT execution/NN context/NN stack/NN has/VBZ at/IN least/JJS two/CD elements/NNS ./.)
*0*let VARcallercontext be the second to top element of the execution context stack. 
*0*(S (Chunk let/VB VARcallercontext/NNP) be/VB the/DT second/JJ to/TO top/VB element/NN of/IN the/DT execution/NN context/NN stack/NN ./.)
*0*let VARcallerrealm be VARcallercontext's realm. 
*0*(S (Chunk let/VB VARcallerrealm/NNP) (Chunk be/VB VARcallercontext/NNP) 's/POS realm/NN ./.)
*0*let VARcalleerealm be the current realm record. 
*0*(S (Chunk let/VB VARcalleerealm/NNP) be/VB the/DT current/JJ realm/NN record/NN ./.)
*0*perform ? FUNChostensurecancompilestrings(VARcallerrealm, VARcalleerealm). 
*0*(S perform/NN ?/. FUNChostensurecancompilestrings/NNS (/( (Chunk VARcallerrealm/NNP) ,/, (Chunk VARcalleerealm/NNP) )/) ./.)
*0*if VARnewtarget is undefined, set VARnewtarget to VARconstructor. 
*0*(S if/IN (Chunk VARnewtarget/NNP) is/VBZ undefined/JJ ,/, (Chunk set/VB VARnewtarget/NNP) to/TO (Chunk VARconstructor/NNP) ./.)
*0*if VARkind is "normal", then
*0*(S if/IN (Chunk VARkind/NNP) is/VBZ ``/`` normal/JJ ''/'' ,/, then/RB)
*1*let VARgoal be the grammar symbol functionbody[~yield, ~await]. 
*1*(S (Chunk let/VB VARgoal/NNP) be/VB the/DT grammar/NN symbol/NN functionbody/NN (Chunk [/NNP) (Chunk ~yield/NNP) ,/, (Chunk ~await/NNP) (Chunk ]/NNP) ./.)
*1*let VARparametergoal be the grammar symbol formalparameters[~yield, ~await]. 
*1*(S (Chunk let/VB VARparametergoal/NNP) be/VB the/DT grammar/NN symbol/NN formalparameters/NNS (Chunk [/VBP ~yield/NNP) ,/, (Chunk ~await/NNP) (Chunk ]/NNP) ./.)
*1*let VARfallbackproto be "%functionprototype%". 
*1*(S (Chunk let/VB VARfallbackproto/NNP) be/VB ``/`` %/NN functionprototype/JJ %/NN ''/'' ./.)
*0*else if VARkind is "generator", then
*0*(S else/RB if/IN (Chunk VARkind/NNP) is/VBZ ``/`` generator/NN ''/'' ,/, then/RB)
*1*let VARgoal be the grammar symbol generatorbody. 
*1*(S (Chunk let/VB VARgoal/NNP) be/VB the/DT grammar/NN symbol/NN generatorbody/NN ./.)
*1*let VARparametergoal be the grammar symbol formalparameters[+yield, ~await]. 
*1*(S (Chunk let/VB VARparametergoal/NNP) be/VB the/DT grammar/NN symbol/NN formalparameters/NNS (Chunk [/VBP +yield/NNP) ,/, (Chunk ~await/NNP) (Chunk ]/NNP) ./.)
*1*let VARfallbackproto be "%generator%". 
*1*(S (Chunk let/VB VARfallbackproto/NNP) be/VB ``/`` %/NN generator/NN %/NN ''/'' ./.)
*0*else if VARkind is "async", then
*0*(S else/RB if/IN (Chunk VARkind/NNP) is/VBZ ``/`` async/JJ ''/'' ,/, then/RB)
*1*assert: VARkind is "async". 
*1*(S assert/NN :/: (Chunk VARkind/NNP) is/VBZ ``/`` async/JJ ''/'' ./.)
*1*let VARgoal be the grammar symbol asyncfunctionbody. 
*1*(S (Chunk let/VB VARgoal/NNP) be/VB the/DT grammar/NN symbol/NN asyncfunctionbody/NN ./.)
*1*let VARparametergoal be the grammar symbol formalparameters[~yield, +await]. 
*1*(S (Chunk let/VB VARparametergoal/NNP) be/VB the/DT grammar/NN symbol/NN formalparameters/NNS (Chunk [/VBP ~yield/NNP) ,/, (Chunk +await/NNP) (Chunk ]/NNP) ./.)
*1*let VARfallbackproto be "%asyncfunctionprototype%". 
*1*(S (Chunk let/VB VARfallbackproto/NNP) be/VB ``/`` %/NN asyncfunctionprototype/JJ %/NN ''/'' ./.)
*0*else,
*0*(S else/RB ,/,)
*1*assert: VARkind is "async generator". 
*1*(S assert/NN :/: (Chunk VARkind/NNP) is/VBZ ``/`` async/JJ generator/NN ''/'' ./.)
*1*let VARgoal be the grammar symbol asyncgeneratorbody. 
*1*(S (Chunk let/VB VARgoal/NNP) be/VB the/DT grammar/NN symbol/NN asyncgeneratorbody/NN ./.)
*1*let VARparametergoal be the grammar symbol formalparameters[+yield, +await]. 
*1*(S (Chunk let/VB VARparametergoal/NNP) be/VB the/DT grammar/NN symbol/NN formalparameters/NNS (Chunk [/VBP +yield/NNP) ,/, (Chunk +await/NNP) (Chunk ]/NNP) ./.)
*1*let VARfallbackproto be "%asyncgenerator%". 
*1*(S (Chunk let/VB VARfallbackproto/NNP) be/VB ``/`` %/NN asyncgenerator/NN %/NN ''/'' ./.)
*0*let VARargcount be the number of elements in VARargs. 
*0*(S (Chunk let/VB VARargcount/NNP) be/VB the/DT number/NN of/IN elements/NNS in/IN (Chunk VARargs/NNP) ./.)
*0*let VARp be the empty string. 
*0*(S (Chunk let/VB VARp/NNP) be/VB the/DT empty/JJ string/NN ./.)
*0*if VARargcount = 0, let VARbodytext be the empty string. 
*0*(S if/IN (Chunk VARargcount/NNP) =/VBD 0/CD ,/, (Chunk let/VB VARbodytext/NNP) be/VB the/DT empty/JJ string/NN ./.)
*0*else if VARargcount = 1, let VARbodytext be VARargs[0]. 
*0*(S else/RB if/IN (Chunk VARargcount/NNP) =/VBD 1/CD ,/, (Chunk let/VB VARbodytext/NNP) (Chunk be/VB VARargs/NNP) (Chunk [/NNP) 0/CD ]/NN ./.)
*0*else VARargcount &gt; 1,
*0*(S (Chunk else/RB VARargcount/NNP) &/CC gt/NN ;/: 1/CD ,/,)
*1*let VARfirstarg be VARargs[0]. 
*1*(S (Chunk let/VB VARfirstarg/NNP) (Chunk be/VB VARargs/NNP) (Chunk [/NNP) 0/CD ]/NN ./.)
*1*set VARp to ? FUNCtostring(VARfirstarg). 
*1*(S (Chunk set/VBN VARp/NNP) to/TO ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARfirstarg/NNP) )/) ./.)
*1*let VARk be 1. 
*1*(S (Chunk let/VB VARk/NNP) be/VB 1/CD ./.)
*1*repeat, while VARk &lt; VARargcount-1
*1*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARargcount-1/NNP))
*2*let VARnextarg be VARargs[VARk]. 
*2*(S (Chunk let/VB VARnextarg/NNP) (Chunk be/VB VARargs/NNP) (Chunk [/NNP) (Chunk VARk/NNP) (Chunk ]/NNP) ./.)
*2*let VARnextargstring be ? FUNCtostring(VARnextarg). 
*2*(S let/VB VARnextargstring/VBG be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARnextarg/NNP) )/) ./.)
*2*set VARp to the string-concatenation of the previous value of VARp, "," (a comma), and VARnextargstring. 
*2*(S (Chunk set/VBN VARp/NNP) to/TO the/DT string-concatenation/NN of/IN the/DT previous/JJ value/NN of/IN (Chunk VARp/NNP) ,/, ``/`` ,/, ''/'' (/( a/DT comma/NN )/) ,/, and/CC (Chunk VARnextargstring/NNP) ./.)
*2*increase VARk by 1. 
*2*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*1*let VARbodytext be VARargs[VARk]. 
*1*(S (Chunk let/VB VARbodytext/NNP) (Chunk be/VB VARargs/NNP) (Chunk [/NNP) (Chunk VARk/NNP) (Chunk ]/NNP) ./.)
*0*set VARbodytext to ? FUNCtostring(VARbodytext). 
*0*(S (Chunk set/VBN VARbodytext/NNP) to/TO ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARbodytext/NNP) )/) ./.)
*0*let VARparameters be the result of parsing VARp, interpreted as utf-16 encoded unicode text as described in 6.1.4, using VARparametergoal as the goal symbol. throw a syntaxerror exception if the parse fails. 
*0*(S let/VB VARparameters/NNS be/VB the/DT result/NN of/IN (Chunk parsing/VBG VARp/NNP) ,/, interpreted/VBD as/IN utf-16/JJ encoded/VBD unicode/JJ text/NN as/IN described/VBN in/IN 6.1.4/CD ,/, (Chunk using/VBG VARparametergoal/NNP) as/IN the/DT goal/NN symbol/NN ./. throw/VB a/DT syntaxerror/NN exception/NN if/IN the/DT parse/NN fails/VBZ ./.)
*0*let VARbody be the result of parsing VARbodytext, interpreted as utf-16 encoded unicode text as described in 6.1.4, using VARgoal as the goal symbol. throw a syntaxerror exception if the parse fails. 
*0*(S (Chunk let/VB VARbody/NNP) be/VB the/DT result/NN of/IN (Chunk parsing/VBG VARbodytext/NNP) ,/, interpreted/VBD as/IN utf-16/JJ encoded/VBD unicode/JJ text/NN as/IN described/VBN in/IN 6.1.4/CD ,/, (Chunk using/VBG VARgoal/NNP) as/IN the/DT goal/NN symbol/NN ./. throw/VB a/DT syntaxerror/NN exception/NN if/IN the/DT parse/NN fails/VBZ ./.)
*0*let VARstrict be containsusestrict of VARbody. 
*0*(S (Chunk let/VB VARstrict/NNP) be/VB containsusestrict/NN of/IN (Chunk VARbody/NNP) ./.)
*0*if any static semantics errors are detected for VARparameters or VARbody, throw a syntaxerror or a referenceerror exception, depending on the type of the error. if VARstrict is true, the early error rules for uniqueformalparameters:formalparameters are applied. parsing and early error detection may be interweaved in an implementation-dependent manner. 
*0*(S if/IN any/DT static/JJ semantics/NNS errors/NNS are/VBP detected/VBN for/IN VARparameters/NNS or/CC (Chunk VARbody/NNP) ,/, throw/VBP a/DT syntaxerror/NN or/CC a/DT referenceerror/NN exception/NN ,/, depending/VBG on/IN the/DT type/NN of/IN the/DT error/NN ./. if/IN (Chunk VARstrict/NNP) is/VBZ true/JJ ,/, the/DT early/JJ error/NN rules/NNS for/IN uniqueformalparameters/NNS :/: formalparameters/NNS are/VBP applied/VBN ./. parsing/NN and/CC early/JJ error/NN detection/NN may/MD be/VB interweaved/VBN in/IN an/DT implementation-dependent/JJ manner/NN ./.)
*0*if VARstrict is true and issimpleparameterlist of VARparameters is false, throw a syntaxerror exception. 
*0*(S if/IN (Chunk VARstrict/NNP) is/VBZ true/JJ and/CC issimpleparameterlist/NN of/IN (Chunk VARparameters/NNP) is/VBZ false/JJ ,/, throw/VB a/DT syntaxerror/NN exception/NN ./.)
*0*if any element of the boundnames of VARparameters also occurs in the lexicallydeclarednames of VARbody, throw a syntaxerror exception. 
*0*(S if/IN any/DT element/NN of/IN the/DT boundnames/NNS of/IN (Chunk VARparameters/NNP) also/RB occurs/VBZ in/IN the/DT lexicallydeclarednames/NNS of/IN (Chunk VARbody/NNP) ,/, throw/VBP a/DT syntaxerror/NN exception/NN ./.)
*0*if VARbody contains supercall is true, throw a syntaxerror exception. 
*0*(S if/IN (Chunk VARbody/NNP) contains/VBZ supercall/NN is/VBZ true/JJ ,/, throw/VB a/DT syntaxerror/NN exception/NN ./.)
*0*if VARparameters contains supercall is true, throw a syntaxerror exception. 
*0*(S if/IN (Chunk VARparameters/NNP) contains/VBZ supercall/NN is/VBZ true/JJ ,/, throw/VB a/DT syntaxerror/NN exception/NN ./.)
*0*if VARbody contains superproperty is true, throw a syntaxerror exception. 
*0*(S if/IN (Chunk VARbody/NNP) contains/VBZ superproperty/NN is/VBZ true/JJ ,/, throw/VB a/DT syntaxerror/NN exception/NN ./.)
*0*if VARparameters contains superproperty is true, throw a syntaxerror exception. 
*0*(S if/IN (Chunk VARparameters/NNP) contains/VBZ superproperty/NN is/VBZ true/JJ ,/, throw/VB a/DT syntaxerror/NN exception/NN ./.)
*0*if VARkind is "generator" or "async generator", then
*0*(S if/IN (Chunk VARkind/NNP) is/VBZ ``/`` generator/NN ''/'' or/CC ``/`` async/JJ generator/NN ''/'' ,/, then/RB)
*1*if VARparameters contains yieldexpression is true, throw a syntaxerror exception. 
*1*(S if/IN (Chunk VARparameters/NNP) contains/VBZ yieldexpression/NN is/VBZ true/JJ ,/, throw/VB a/DT syntaxerror/NN exception/NN ./.)
*0*if VARkind is "async" or "async generator", then
*0*(S if/IN (Chunk VARkind/NNP) is/VBZ ``/`` async/JJ ''/'' or/CC ``/`` async/JJ generator/NN ''/'' ,/, then/RB)
*1*if VARparameters contains awaitexpression is true, throw a syntaxerror exception. 
*1*(S if/IN (Chunk VARparameters/NNP) contains/VBZ awaitexpression/NN is/VBZ true/JJ ,/, throw/VB a/DT syntaxerror/NN exception/NN ./.)
*0*if VARstrict is true, then
*0*(S if/IN (Chunk VARstrict/NNP) is/VBZ true/JJ ,/, then/RB)
*1*if boundnames of VARparameters contains any duplicate elements, throw a syntaxerror exception. 
*1*(S if/IN boundnames/NNS of/IN (Chunk VARparameters/NNP) contains/VBZ any/DT duplicate/JJ elements/NNS ,/, throw/VBP a/DT syntaxerror/NN exception/NN ./.)
*0*let VARproto be ? FUNCgetprototypefromconstructor(VARnewtarget, VARfallbackproto). 
*0*(S (Chunk let/VB VARproto/NNP) be/VB ?/. (Chunk FUNCgetprototypefromconstructor/NNP) (/( (Chunk VARnewtarget/NNP) ,/, (Chunk VARfallbackproto/NNP) )/) ./.)
*0*let VARf be FUNCfunctionallocate(VARproto, VARstrict, VARkind). 
*0*(S (Chunk let/VB VARf/NNP) (Chunk be/VB FUNCfunctionallocate/NNP) (/( (Chunk VARproto/NNP) ,/, (Chunk VARstrict/NNP) ,/, (Chunk VARkind/NNP) )/) ./.)
*0*let VARrealmf be VARf.[[REALM]]. 
*0*(S (Chunk let/VB VARrealmf/NNP) (Chunk be/VB VARf/NNP) ./. [/VB [/JJ (Chunk REALM/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARscope be VARrealmf.[[GLOBALENV]]. 
*0*(S (Chunk let/VB VARscope/NNP) (Chunk be/VB VARrealmf/NNP) ./. [/VB [/JJ (Chunk GLOBALENV/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*perform FUNCfunctioninitialize(VARf, normal, VARparameters, VARbody, VARscope). 
*0*(S perform/NN (Chunk FUNCfunctioninitialize/NNP) (/( (Chunk VARf/NNP) ,/, normal/JJ ,/, (Chunk VARparameters/NNP) ,/, (Chunk VARbody/NNP) ,/, (Chunk VARscope/NNP) )/) ./.)
*0*if VARkind is "generator", then
*0*(S if/IN (Chunk VARkind/NNP) is/VBZ ``/`` generator/NN ''/'' ,/, then/RB)
*1*let VARprototype be FUNCobjectcreate(%generatorprototype%). 
*1*(S (Chunk let/VB VARprototype/NNP) (Chunk be/VB FUNCobjectcreate/NNP) (/( %/NN generatorprototype/NN %/NN )/) ./.)
*1*perform FUNCdefinepropertyorthrow(VARf, "prototype", propertydescriptor { [[VALUE]]: VARprototype, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }). 
*1*(S perform/NN (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARf/NNP) ,/, ``/`` prototype/NN ''/'' ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: VARprototype/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) )/) ./.)
*0*else if VARkind is "async generator", then
*0*(S else/RB if/IN (Chunk VARkind/NNP) is/VBZ ``/`` async/JJ generator/NN ''/'' ,/, then/RB)
*1*let VARprototype be FUNCobjectcreate(%asyncgeneratorprototype%). 
*1*(S (Chunk let/VB VARprototype/NNP) (Chunk be/VB FUNCobjectcreate/NNP) (/( %/NN asyncgeneratorprototype/RB %/NN )/) ./.)
*1*perform FUNCdefinepropertyorthrow(VARf, "prototype", propertydescriptor { [[VALUE]]: VARprototype, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }). 
*1*(S perform/NN (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARf/NNP) ,/, ``/`` prototype/NN ''/'' ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: VARprototype/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) )/) ./.)
*0*else if VARkind is "normal", perform FUNCmakeconstructor(VARf). 
*0*(S else/RB if/IN (Chunk VARkind/NNP) is/VBZ ``/`` normal/JJ ''/'' ,/, (Chunk perform/VB FUNCmakeconstructor/NNP) (/( (Chunk VARf/NNP) )/) ./.)
*0*note: async functions are not constructable and do not have a [[CONSTRUCT]] internal method or a "prototype" property. 
*0*(S note/NN :/: async/JJ functions/NNS are/VBP not/RB constructable/JJ and/CC do/VBP not/RB have/VB a/DT [/JJ (Chunk [/NNP) (Chunk CONSTRUCT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ method/NN or/CC a/DT ``/`` prototype/NN ''/'' property/NN ./.)
*0*perform FUNCsetfunctionname(VARf, "anonymous"). 
*0*(S perform/NN (Chunk FUNCsetfunctionname/NNP) (/( (Chunk VARf/NNP) ,/, ``/`` anonymous/JJ ''/'' )/) ./.)
*0*return VARf.      
*0*(S return/NN (Chunk VARf/NNP) ./.)
ID= 19.2.3.1
Summary= Function.prototype.apply ( thisArg, argArray )
*0*if FUNCiscallable(VARfunc) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARfunc/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARargarray is undefined or null, then
*0*(S if/IN (Chunk VARargarray/NNP) is/VBZ undefined/JJ or/CC null/JJ ,/, then/RB)
*1*perform FUNCpreparefortailcall(). 
*1*(S (Chunk perform/VB FUNCpreparefortailcall/NNP) (/( )/) ./.)
*1*return ? FUNCcall(VARfunc, VARthisarg). 
*1*(S return/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARfunc/NNP) ,/, (Chunk VARthisarg/NNP) )/) ./.)
*0*let VARarglist be ? FUNCcreatelistfromarraylike(VARargarray). 
*0*(S (Chunk let/VB VARarglist/NNP) be/VB ?/. (Chunk FUNCcreatelistfromarraylike/NNP) (/( (Chunk VARargarray/NNP) )/) ./.)
*0*perform FUNCpreparefortailcall(). 
*0*(S (Chunk perform/VB FUNCpreparefortailcall/NNP) (/( )/) ./.)
*0*return ? FUNCcall(VARfunc, VARthisarg, VARarglist).     
*0*(S return/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARfunc/NNP) ,/, (Chunk VARthisarg/NNP) ,/, (Chunk VARarglist/NNP) )/) ./.)
ID= 19.2.3.2
Summary= Function.prototype.bind ( thisArg, ...args )
*0*let VARtarget be the this value. 
*0*(S (Chunk let/VB VARtarget/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCiscallable(VARtarget) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARargs be a new (possibly empty) list consisting of all of the argument values provided after VARthisarg in order. 
*0*(S (Chunk let/VB VARargs/NNP) be/VB a/DT new/JJ (/( possibly/RB empty/RB )/) list/NN consisting/VBG of/IN all/DT of/IN the/DT argument/NN values/NNS provided/VBN after/IN (Chunk VARthisarg/NNP) in/IN order/NN ./.)
*0*let VARf be ? FUNCboundfunctioncreate(VARtarget, VARthisarg, VARargs). 
*0*(S (Chunk let/VB VARf/NNP) be/VB ?/. (Chunk FUNCboundfunctioncreate/NNP) (/( (Chunk VARtarget/NNP) ,/, (Chunk VARthisarg/NNP) ,/, (Chunk VARargs/NNP) )/) ./.)
*0*let VARtargethaslength be ? FUNChasownproperty(VARtarget, "length"). 
*0*(S (Chunk let/VB VARtargethaslength/NNP) be/VB ?/. (Chunk FUNChasownproperty/NNP) (/( (Chunk VARtarget/NNP) ,/, ``/`` length/NN ''/'' )/) ./.)
*0*if VARtargethaslength is true, then
*0*(S if/IN (Chunk VARtargethaslength/NNP) is/VBZ true/JJ ,/, then/RB)
*1*let VARtargetlen be ? FUNCget(VARtarget, "length"). 
*1*(S (Chunk let/VB VARtargetlen/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARtarget/NNP) ,/, ``/`` length/NN ''/'' )/) ./.)
*1*if FUNCtype(VARtargetlen) is not number, let VARl be 0. 
*1*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtargetlen/NNP) )/) is/VBZ not/RB number/NN ,/, (Chunk let/VB VARl/NNP) be/VB 0/CD ./.)
*1*else,
*1*(S else/RB ,/,)
*2*let VARtargetlen be FUNCtointeger(VARtargetlen). 
*2*(S (Chunk let/VB VARtargetlen/NNP) (Chunk be/VB FUNCtointeger/NNP) (/( (Chunk VARtargetlen/NNP) )/) ./.)
*2*let VARl be the larger of 0 and the result of VARtargetlen minus the number of elements of VARargs. 
*2*(S (Chunk let/VB VARl/NNP) be/VB the/DT larger/JJR of/IN 0/CD and/CC the/DT result/NN of/IN (Chunk VARtargetlen/NNP) minus/CC the/DT number/NN of/IN elements/NNS of/IN (Chunk VARargs/NNP) ./.)
*0*else, let VARl be 0. 
*0*(S else/RB ,/, (Chunk let/VB VARl/NNP) be/VB 0/CD ./.)
*0*perform ! FUNCsetfunctionlength(VARf, VARl). 
*0*(S perform/NN !/. (Chunk FUNCsetfunctionlength/NNP) (/( (Chunk VARf/NNP) ,/, (Chunk VARl/NNP) )/) ./.)
*0*let VARtargetname be ? FUNCget(VARtarget, "name"). 
*0*(S (Chunk let/VB VARtargetname/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARtarget/NNP) ,/, ``/`` name/NN ''/'' )/) ./.)
*0*if FUNCtype(VARtargetname) is not string, let VARtargetname be the empty string. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtargetname/NNP) )/) is/VBZ not/RB string/VBG ,/, (Chunk let/VB VARtargetname/NNP) be/VB the/DT empty/JJ string/NN ./.)
*0*perform FUNCsetfunctionname(VARf, VARtargetname, "bound"). 
*0*(S perform/NN (Chunk FUNCsetfunctionname/NNP) (/( (Chunk VARf/NNP) ,/, (Chunk VARtargetname/NNP) ,/, ``/`` bound/NN ''/'' )/) ./.)
*0*return VARf.     
*0*(S return/NN (Chunk VARf/NNP) ./.)
ID= 19.2.3.3
Summary= Function.prototype.call ( thisArg, ...args )
*0*if FUNCiscallable(VARfunc) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARfunc/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARarglist be a new empty list. 
*0*(S (Chunk let/VB VARarglist/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*if this method was called with more than one argument, then in left to right order, starting with the second argument, append each argument as the last element of VARarglist. 
*0*(S if/IN this/DT method/NN was/VBD called/VBN with/IN more/JJR than/IN one/CD argument/NN ,/, then/RB in/IN left/VBN to/TO right/JJ order/NN ,/, starting/VBG with/IN the/DT second/JJ argument/NN ,/, append/VBP each/DT argument/NN as/IN the/DT last/JJ element/NN of/IN (Chunk VARarglist/NNP) ./.)
*0*perform FUNCpreparefortailcall(). 
*0*(S (Chunk perform/VB FUNCpreparefortailcall/NNP) (/( )/) ./.)
*0*return ? FUNCcall(VARfunc, VARthisarg, VARarglist).     
*0*(S return/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARfunc/NNP) ,/, (Chunk VARthisarg/NNP) ,/, (Chunk VARarglist/NNP) )/) ./.)
ID= 19.2.3.5
Summary= Function.prototype.toString ( )
*0*if VARfunc is a bound function exotic object, then
*0*(S if/IN (Chunk VARfunc/NNP) is/VBZ a/DT bound/NN function/NN exotic/JJ object/NN ,/, then/RB)
*1*return an implementation-dependent string source code representation of VARfunc. the representation must conform to the rules below. it is implementation-dependent whether the representation includes bound function information or information about the target function. 
*1*(S return/VB an/DT implementation-dependent/JJ string/NN source/NN code/NN representation/NN of/IN (Chunk VARfunc/NNP) ./. the/DT representation/NN must/MD conform/VB to/TO the/DT rules/NNS below/IN ./. it/PRP is/VBZ implementation-dependent/JJ whether/IN the/DT representation/NN includes/VBZ bound/IN function/NN information/NN or/CC information/NN about/IN the/DT target/NN function/NN ./.)
*0*if FUNCtype(VARfunc) is object and is either a built-in function object or has an [[ECMASCRIPTCODE]] internal slot, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARfunc/NNP) )/) is/VBZ object/JJ and/CC is/VBZ either/DT a/DT built-in/JJ function/NN object/NN or/CC has/VBZ an/DT [/JJ [/NN (Chunk ECMASCRIPTCODE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, then/RB)
*1*return an implementation-dependent string source code representation of VARfunc. the representation must conform to the rules below. 
*1*(S return/VB an/DT implementation-dependent/JJ string/NN source/NN code/NN representation/NN of/IN (Chunk VARfunc/NNP) ./. the/DT representation/NN must/MD conform/VB to/TO the/DT rules/NNS below/IN ./.)
*0*throw a typeerror exception.     
*0*(S throw/VB a/DT typeerror/NN exception/NN ./.)
ID= 19.2.3.6
Summary= Function.prototype [ @@hasInstance ] ( V )
*0*let VARf be the this value. 
*0*(S (Chunk let/VB VARf/NNP) be/VB the/DT this/DT value/NN ./.)
*0*return ? FUNCordinaryhasinstance(VARf, VARv).     
*0*(S return/NN ?/. (Chunk FUNCordinaryhasinstance/NNP) (/( (Chunk VARf/NNP) ,/, (Chunk VARv/NNP) )/) ./.)
ID= 19.3.1.1
Summary= Boolean ( value )
*0*let VARb be FUNCtoboolean(VARvalue). 
*0*(S (Chunk let/VB VARb/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*0*if newtarget is undefined, return VARb. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, (Chunk return/VB VARb/NNP) ./.)
*0*let VARo be ? FUNCordinarycreatefromconstructor(newtarget, "%booleanprototype%", « [[BOOLEANDATA]] »). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCordinarycreatefromconstructor/NNP) (/( newtarget/NN ,/, ``/`` %/NN booleanprototype/NN %/NN ''/'' ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk BOOLEANDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARo.[[BOOLEANDATA]] to VARb. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk BOOLEANDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARb/NNP) ./.)
*0*return VARo.     
*0*(S return/NN (Chunk VARo/NNP) ./.)
ID= 19.3.3.2
Summary= Boolean.prototype.toString ( )
*0*let VARb be ? thisbooleanvalue(this value). 
*0*(S (Chunk let/VB VARb/NNP) be/VB ?/. thisbooleanvalue/JJ (/( this/DT value/NN )/) ./.)
*0*if VARb is true, return "true"; else return "false".     
*0*(S if/IN (Chunk VARb/NNP) is/VBZ true/JJ ,/, return/VB ``/`` true/JJ ''/'' ;/: else/RB return/VBP ``/`` false/JJ ''/'' ./.)
ID= 19.3.3.3
Summary= Boolean.prototype.valueOf ( )
*0*return ? thisbooleanvalue(this value).     
*0*(S return/NN ?/. thisbooleanvalue/NN (/( this/DT value/NN )/) ./.)
ID= 19.4.1.1
Summary= Symbol ( [ description ] )
*0*if newtarget is not undefined, throw a typeerror exception. 
*0*(S if/IN newtarget/DT is/VBZ not/RB undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARdescription is undefined, let VARdescstring be undefined. 
*0*(S if/IN (Chunk VARdescription/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARdescstring/NNP) be/VB undefined/VBN ./.)
*0*else, let VARdescstring be ? FUNCtostring(VARdescription). 
*0*(S else/RB ,/, let/VB VARdescstring/VBG be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARdescription/NNP) )/) ./.)
*0*return a new unique symbol value whose [[DESCRIPTION]] value is VARdescstring.     
*0*(S return/VB a/DT new/JJ unique/JJ symbol/NN value/NN whose/WP$ [/JJ (Chunk [/NNP) (Chunk DESCRIPTION/NNP) (Chunk ]/NNP) (Chunk ]/NNP) value/NN is/VBZ VARdescstring/VBG ./.)
ID= 19.4.2.2
Summary= Symbol.for ( key )
*0*let VARstringkey be ? FUNCtostring(VARkey). 
*0*(S (Chunk let/VB VARstringkey/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARkey/NNP) )/) ./.)
*0*for each element VARe of the globalsymbolregistry list, do
*0*(S for/IN each/DT element/NN (Chunk VARe/NNP) of/IN the/DT globalsymbolregistry/NN list/NN ,/, do/VBP)
*1*if FUNCsamevalue(VARe.[[KEY]], VARstringkey) is true, return VARe.[[SYMBOL]]. 
*1*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARe/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARstringkey/NNP) )/) is/VBZ true/JJ ,/, return/NN (Chunk VARe/NNP) ./. [/VB [/JJ (Chunk SYMBOL/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*assert: globalsymbolregistry does not currently contain an entry for VARstringkey. 
*0*(S assert/NN :/: globalsymbolregistry/NN does/VBZ not/RB currently/RB contain/VBP an/DT entry/NN for/IN (Chunk VARstringkey/NNP) ./.)
*0*let VARnewsymbol be a new unique symbol value whose [[DESCRIPTION]] value is VARstringkey. 
*0*(S (Chunk let/VB VARnewsymbol/NNP) be/VB a/DT new/JJ unique/JJ symbol/NN value/NN whose/WP$ [/JJ (Chunk [/NNP) (Chunk DESCRIPTION/NNP) (Chunk ]/NNP) (Chunk ]/NNP) value/NN (Chunk is/VBZ VARstringkey/NNP) ./.)
*0*append the record { [[KEY]]: VARstringkey, [[SYMBOL]]: VARnewsymbol } to the globalsymbolregistry list. 
*0*(S append/VB the/DT record/NN {/( [/JJ (Chunk [/NNP) (Chunk KEY/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARstringkey/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk SYMBOL/NNP) (Chunk ]/NNP) (Chunk ]/NNP) :/: VARnewsymbol/NN }/) to/TO the/DT globalsymbolregistry/NN list/NN ./.)
*0*return VARnewsymbol.     
*0*(S return/NN (Chunk VARnewsymbol/NNP) ./.)
ID= 19.4.2.6
Summary= Symbol.keyFor ( sym )
*0*if FUNCtype(VARsym) is not symbol, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARsym/NNP) )/) is/VBZ not/RB symbol/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*for each element VARe of the globalsymbolregistry list (see 19.4.2.2), do
*0*(S for/IN each/DT element/NN (Chunk VARe/NNP) of/IN the/DT globalsymbolregistry/NN list/NN (/( see/VB 19.4.2.2/CD )/) ,/, do/VBP)
*1*if FUNCsamevalue(VARe.[[SYMBOL]], VARsym) is true, return VARe.[[KEY]]. 
*1*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARe/NNP) ./. [/VB [/JJ (Chunk SYMBOL/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARsym/NNP) )/) is/VBZ true/JJ ,/, return/NN (Chunk VARe/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*assert: globalsymbolregistry does not currently contain an entry for VARsym. 
*0*(S assert/NN :/: globalsymbolregistry/NN does/VBZ not/RB currently/RB contain/VBP an/DT entry/NN for/IN (Chunk VARsym/NNP) ./.)
*0*return undefined.     
*0*(S return/NN undefined/VBD ./.)
ID= 19.4.3.2
Summary= Symbol.prototype.toString ( )
*0*let VARsym be ? FUNCthissymbolvalue(this value). 
*0*(S (Chunk let/VB VARsym/NNP) be/VB ?/. (Chunk FUNCthissymbolvalue/NNP) (/( this/DT value/NN )/) ./.)
*0*return FUNCsymboldescriptivestring(VARsym).     
*0*(S return/NN (Chunk FUNCsymboldescriptivestring/NNP) (/( (Chunk VARsym/NNP) )/) ./.)
ID= 19.4.3.2.1
Summary= Runtime Semantics: SymbolDescriptiveString ( sym )
*0*assert: FUNCtype(VARsym) is symbol. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARsym/NNP) )/) is/VBZ symbol/NN ./.)
*0*let VARdesc be VARsym's [[DESCRIPTION]] value. 
*0*(S (Chunk let/VB VARdesc/NNP) (Chunk be/VB VARsym/NNP) 's/POS (Chunk [/NNP) (Chunk [/NNP) (Chunk DESCRIPTION/NNP) (Chunk ]/NNP) (Chunk ]/NNP) value/NN ./.)
*0*if VARdesc is undefined, let VARdesc be the empty string. 
*0*(S if/IN (Chunk VARdesc/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARdesc/NNP) be/VB the/DT empty/JJ string/NN ./.)
*0*assert: FUNCtype(VARdesc) is string. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARdesc/NNP) )/) is/VBZ string/VBG ./.)
*0*return the string-concatenation of "symbol(", VARdesc, and ")".      
*0*(S return/VB the/DT string-concatenation/NN of/IN ``/`` symbol/NN (/( ``/`` ,/, (Chunk VARdesc/NNP) ,/, and/CC ``/`` )/) ''/'' ./.)
ID= 19.4.3.3
Summary= Symbol.prototype.valueOf ( )
*0*return ? FUNCthissymbolvalue(this value).     
*0*(S return/NN ?/. (Chunk FUNCthissymbolvalue/NNP) (/( this/DT value/NN )/) ./.)
ID= 19.4.3.4
Summary= Symbol.prototype [ @@toPrimitive ] ( hint )
*0*return ? FUNCthissymbolvalue(this value).     
*0*(S return/NN ?/. (Chunk FUNCthissymbolvalue/NNP) (/( this/DT value/NN )/) ./.)
ID= 19.5.1.1
Summary= Error ( message )
*0*if newtarget is undefined, let VARnewtarget be the active function object, else let VARnewtarget be newtarget. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, (Chunk let/VB VARnewtarget/NNP) be/VB the/DT active/JJ function/NN object/NN ,/, (Chunk else/RB let/VB VARnewtarget/NNP) be/VB newtarget/VBN ./.)
*0*let VARo be ? FUNCordinarycreatefromconstructor(VARnewtarget, "%errorprototype%", « [[ERRORDATA]] »). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCordinarycreatefromconstructor/NNP) (/( (Chunk VARnewtarget/NNP) ,/, ``/`` %/NN errorprototype/JJ %/NN ''/'' ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk ERRORDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*if VARmessage is not undefined, then
*0*(S if/IN (Chunk VARmessage/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*1*let VARmsg be ? FUNCtostring(VARmessage). 
*1*(S (Chunk let/VB VARmsg/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARmessage/NNP) )/) ./.)
*1*let VARmsgdesc be the propertydescriptor { [[VALUE]]: VARmsg, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }. 
*1*(S (Chunk let/VB VARmsgdesc/NNP) be/VB the/DT propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARmsg/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ }/) ./.)
*1*perform ! FUNCdefinepropertyorthrow(VARo, "message", VARmsgdesc). 
*1*(S perform/NN !/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` message/NN ''/'' ,/, (Chunk VARmsgdesc/NNP) )/) ./.)
*0*return VARo.     
*0*(S return/NN (Chunk VARo/NNP) ./.)
ID= 19.5.3.4
Summary= Error.prototype.toString ( )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARname be ? FUNCget(VARo, "name"). 
*0*(S (Chunk let/VB VARname/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` name/NN ''/'' )/) ./.)
*0*if VARname is undefined, let VARname be "error"; otherwise let VARname be ? FUNCtostring(VARname). 
*0*(S if/IN (Chunk VARname/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARname/NNP) be/VB ``/`` error/JJ ''/'' ;/: (Chunk otherwise/RB let/VB VARname/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARname/NNP) )/) ./.)
*0*let VARmsg be ? FUNCget(VARo, "message"). 
*0*(S (Chunk let/VB VARmsg/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` message/NN ''/'' )/) ./.)
*0*if VARmsg is undefined, let VARmsg be the empty string; otherwise let VARmsg be ? FUNCtostring(VARmsg). 
*0*(S if/IN (Chunk VARmsg/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARmsg/NNP) be/VB the/DT empty/JJ string/NN ;/: (Chunk otherwise/RB let/VB VARmsg/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARmsg/NNP) )/) ./.)
*0*if VARname is the empty string, return VARmsg. 
*0*(S if/IN (Chunk VARname/NNP) is/VBZ the/DT empty/JJ string/NN ,/, return/NN (Chunk VARmsg/NNP) ./.)
*0*if VARmsg is the empty string, return VARname. 
*0*(S if/IN (Chunk VARmsg/NNP) is/VBZ the/DT empty/JJ string/NN ,/, return/NN (Chunk VARname/NNP) ./.)
*0*return the string-concatenation of VARname, the code unit 0x003a (colon), the code unit 0x0020 (space), and VARmsg.     
*0*(S return/VB the/DT string-concatenation/NN of/IN (Chunk VARname/NNP) ,/, the/DT code/NN unit/NN 0x003a/CD (/( colon/NN )/) ,/, the/DT code/NN unit/NN 0x0020/CD (/( space/NN )/) ,/, and/CC (Chunk VARmsg/NNP) ./.)
ID= 19.5.6.1.1
Summary= NativeError ( message )
*0*if newtarget is undefined, let VARnewtarget be the active function object, else let VARnewtarget be newtarget. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, (Chunk let/VB VARnewtarget/NNP) be/VB the/DT active/JJ function/NN object/NN ,/, (Chunk else/RB let/VB VARnewtarget/NNP) be/VB newtarget/VBN ./.)
*0*let VARo be ? FUNCordinarycreatefromconstructor(VARnewtarget, "%VARnativeerrorprototype%", « [[ERRORDATA]] »). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCordinarycreatefromconstructor/NNP) (/( (Chunk VARnewtarget/NNP) ,/, ``/`` %/NN VARnativeerrorprototype/JJ %/NN ''/'' ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk ERRORDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*if VARmessage is not undefined, then
*0*(S if/IN (Chunk VARmessage/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*1*let VARmsg be ? FUNCtostring(VARmessage). 
*1*(S (Chunk let/VB VARmsg/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARmessage/NNP) )/) ./.)
*1*let VARmsgdesc be the propertydescriptor { [[VALUE]]: VARmsg, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }. 
*1*(S (Chunk let/VB VARmsgdesc/NNP) be/VB the/DT propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARmsg/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ }/) ./.)
*1*perform ! FUNCdefinepropertyorthrow(VARo, "message", VARmsgdesc). 
*1*(S perform/NN !/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` message/NN ''/'' ,/, (Chunk VARmsgdesc/NNP) )/) ./.)
*0*return VARo.      
*0*(S return/NN (Chunk VARo/NNP) ./.)
ID= 20.1.1.1
Summary= Number ( value )
*0*if no arguments were passed to this function invocation, let VARn be +0. 
*0*(S if/IN no/DT arguments/NNS were/VBD passed/VBN to/TO this/DT function/NN invocation/NN ,/, (Chunk let/VB VARn/NNP) be/VB +0/VBN ./.)
*0*else, let VARn be ? FUNCtonumber(VARvalue). 
*0*(S else/RB ,/, (Chunk let/VB VARn/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*0*if newtarget is undefined, return VARn. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, return/NN (Chunk VARn/NNP) ./.)
*0*let VARo be ? FUNCordinarycreatefromconstructor(newtarget, "%numberprototype%", « [[NUMBERDATA]] »). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCordinarycreatefromconstructor/NNP) (/( newtarget/NN ,/, ``/`` %/NN numberprototype/JJ %/NN ''/'' ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk NUMBERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARo.[[NUMBERDATA]] to VARn. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk NUMBERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARn/NNP) ./.)
*0*return VARo.     
*0*(S return/NN (Chunk VARo/NNP) ./.)
ID= 20.1.2.2
Summary= Number.isFinite ( number )
*0*if FUNCtype(VARnumber) is not number, return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARnumber/NNP) )/) is/VBZ not/RB number/NN ,/, return/NN false/JJ ./.)
*0*if VARnumber is nan, +∞, or -∞, return false. 
*0*(S if/IN (Chunk VARnumber/NNP) is/VBZ nan/JJ ,/, +∞/JJ ,/, or/CC -∞/NN ,/, return/NN false/JJ ./.)
*0*otherwise, return true.     
*0*(S otherwise/RB ,/, return/NN true/JJ ./.)
ID= 20.1.2.3
Summary= Number.isInteger ( number )
*0*if FUNCtype(VARnumber) is not number, return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARnumber/NNP) )/) is/VBZ not/RB number/NN ,/, return/NN false/JJ ./.)
*0*if VARnumber is nan, +∞, or -∞, return false. 
*0*(S if/IN (Chunk VARnumber/NNP) is/VBZ nan/JJ ,/, +∞/JJ ,/, or/CC -∞/NN ,/, return/NN false/JJ ./.)
*0*let VARinteger be FUNCtointeger(VARnumber). 
*0*(S (Chunk let/VB VARinteger/NNP) (Chunk be/VB FUNCtointeger/NNP) (/( (Chunk VARnumber/NNP) )/) ./.)
*0*if VARinteger is not equal to VARnumber, return false. 
*0*(S if/IN (Chunk VARinteger/NNP) is/VBZ not/RB equal/JJ to/TO (Chunk VARnumber/NNP) ,/, return/NN false/JJ ./.)
*0*otherwise, return true.     
*0*(S otherwise/RB ,/, return/NN true/JJ ./.)
ID= 20.1.2.4
Summary= Number.isNaN ( number )
*0*if FUNCtype(VARnumber) is not number, return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARnumber/NNP) )/) is/VBZ not/RB number/NN ,/, return/NN false/JJ ./.)
*0*if VARnumber is nan, return true. 
*0*(S if/IN (Chunk VARnumber/NNP) is/VBZ nan/JJ ,/, return/VB true/JJ ./.)
*0*otherwise, return false.     
*0*(S otherwise/RB ,/, return/NN false/JJ ./.)
ID= 20.1.2.5
Summary= Number.isSafeInteger ( number )
*0*if FUNCtype(VARnumber) is not number, return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARnumber/NNP) )/) is/VBZ not/RB number/NN ,/, return/NN false/JJ ./.)
*0*if VARnumber is nan, +∞, or -∞, return false. 
*0*(S if/IN (Chunk VARnumber/NNP) is/VBZ nan/JJ ,/, +∞/JJ ,/, or/CC -∞/NN ,/, return/NN false/JJ ./.)
*0*let VARinteger be FUNCtointeger(VARnumber). 
*0*(S (Chunk let/VB VARinteger/NNP) (Chunk be/VB FUNCtointeger/NNP) (/( (Chunk VARnumber/NNP) )/) ./.)
*0*if VARinteger is not equal to VARnumber, return false. 
*0*(S if/IN (Chunk VARinteger/NNP) is/VBZ not/RB equal/JJ to/TO (Chunk VARnumber/NNP) ,/, return/NN false/JJ ./.)
*0*if abs(VARinteger) ≤ 253-1, return true. 
*0*(S if/IN abs/NNS (/( (Chunk VARinteger/NNP) )/) ≤/VBD 253-1/JJ ,/, return/VB true/JJ ./.)
*0*otherwise, return false.     
*0*(S otherwise/RB ,/, return/NN false/JJ ./.)
ID= 20.1.3.2
Summary= Number.prototype.toExponential ( fractionDigits )
*0*let VARx be ? FUNCthisnumbervalue(this value). 
*0*(S (Chunk let/VB VARx/NNP) be/VB ?/. (Chunk FUNCthisnumbervalue/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARf be ? FUNCtointeger(VARfractiondigits). 
*0*(S (Chunk let/VB VARf/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARfractiondigits/NNP) )/) ./.)
*0*assert: VARf is 0, when VARfractiondigits is undefined. 
*0*(S assert/NN :/: (Chunk VARf/NNP) is/VBZ 0/CD ,/, when/WRB VARfractiondigits/NNS is/VBZ undefined/JJ ./.)
*0*if VARx is nan, return the string "nan". 
*0*(S if/IN (Chunk VARx/NNP) is/VBZ nan/JJ ,/, return/VB the/DT string/NN ``/`` nan/JJ ''/'' ./.)
*0*let VARs be the empty string. 
*0*(S (Chunk let/VB VARs/NNP) be/VB the/DT empty/JJ string/NN ./.)
*0*if VARx &lt; 0, then
*0*(S if/IN (Chunk VARx/NNP) &/CC lt/NN ;/: 0/CD ,/, then/RB)
*1*let VARs be "-". 
*1*(S (Chunk let/VB VARs/NNP) be/VB ``/`` -/: ''/'' ./.)
*1*let VARx be -VARx. 
*1*(S (Chunk let/VB VARx/NNP) be/VB -VARx/VBN ./.)
*0*if VARx = +∞, then
*0*(S if/IN (Chunk VARx/NNP) (Chunk =/NNP) (Chunk +∞/NNP) ,/, then/RB)
*1*return the string-concatenation of VARs and "infinity". 
*1*(S return/VB the/DT string-concatenation/NN of/IN (Chunk VARs/NNP) and/CC ``/`` infinity/NN ''/'' ./.)
*0*if VARf &lt; 0 or VARf &gt; 100, throw a rangeerror exception. 
*0*(S if/IN (Chunk VARf/NNP) &/CC lt/NN ;/: 0/CD or/CC (Chunk VARf/NNP) &/CC gt/NN ;/: 100/CD ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*if VARx = 0, then
*0*(S if/IN (Chunk VARx/NNP) =/VBD 0/CD ,/, then/RB)
*1*let VARm be the string value consisting of VARf+1 occurrences of the code unit 0x0030 (digit zero). 
*1*(S (Chunk let/VB VARm/NNP) be/VB the/DT string/VBG value/NN consisting/VBG of/IN (Chunk VARf+1/NNP) occurrences/NNS of/IN the/DT code/NN unit/NN 0x0030/CD (/( digit/JJ zero/NN )/) ./.)
*1*let VARe be 0. 
*1*(S (Chunk let/VB VARe/NNP) be/VB 0/CD ./.)
*0*else VARx ≠ 0,
*0*(S (Chunk else/RB VARx/NNP) (Chunk ≠/NNP) 0/CD ,/,)
*1*if VARfractiondigits is not undefined, then
*1*(S if/IN (Chunk VARfractiondigits/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*2*let VARe and VARn be integers such that 10VARf ≤ VARn &lt; 10VARf+1 and for which the exact mathematical value of VARn × 10VARe-VARf - VARx is as close to zero as possible. if there are two such sets of VARe and VARn, pick the VARe and VARn for which VARn × 10VARe-VARf is larger. 
*2*(S let/NN (Chunk VARe/NNP) and/CC (Chunk VARn/NNP) be/VB integers/NNS such/JJ that/IN 10VARf/CD (Chunk ≤/NNP) (Chunk VARn/NNP) &/CC lt/NN ;/: 10VARf+1/CD and/CC for/IN which/WDT the/DT exact/JJ mathematical/JJ value/NN of/IN (Chunk VARn/NNP) (Chunk ×/NNP) 10VARe-VARf/JJ -/: VARx/NN is/VBZ as/RB close/JJ to/TO zero/CD as/IN possible/JJ ./. if/IN there/EX are/VBP two/CD such/JJ sets/NNS of/IN (Chunk VARe/NNP) and/CC (Chunk VARn/NNP) ,/, pick/VB the/DT (Chunk VARe/NNP) and/CC (Chunk VARn/NNP) for/IN which/WDT (Chunk VARn/NNP) (Chunk ×/NNP) 10VARe-VARf/CD is/VBZ larger/JJR ./.)
*1*else VARfractiondigits is undefined,
*1*(S (Chunk else/RB VARfractiondigits/NNP) is/VBZ undefined/JJ ,/,)
*2*let VARe, VARn, and VARf be integers such that VARf ≥ 0, 10VARf ≤ VARn &lt; 10VARf+1, the number value for VARn × 10VARe-VARf is VARx, and VARf is as small as possible. note that the decimal representation of VARn has VARf+1 digits, VARn is not divisible by 10, and the least significant digit of VARn is not necessarily uniquely determined by these criteria. 
*2*(S let/NN (Chunk VARe/NNP) ,/, (Chunk VARn/NNP) ,/, and/CC (Chunk VARf/NNP) be/VB integers/NNS such/JJ that/IN (Chunk VARf/NNP) ≥/VBD 0/CD ,/, 10VARf/CD (Chunk ≤/NNP) (Chunk VARn/NNP) &/CC lt/NN ;/: 10VARf+1/CD ,/, the/DT number/NN value/NN for/IN (Chunk VARn/NNP) (Chunk ×/NNP) 10VARe-VARf/CD (Chunk is/VBZ VARx/NNP) ,/, and/CC (Chunk VARf/NNP) is/VBZ as/RB small/JJ as/IN possible/JJ ./. note/NN that/IN the/DT decimal/JJ representation/NN of/IN (Chunk VARn/NNP) (Chunk has/VBZ VARf+1/NNP) digits/NNS ,/, (Chunk VARn/NNP) is/VBZ not/RB divisible/JJ by/IN 10/CD ,/, and/CC the/DT least/JJS significant/JJ digit/NN of/IN (Chunk VARn/NNP) is/VBZ not/RB necessarily/RB uniquely/RB determined/VBN by/IN these/DT criteria/NNS ./.)
*1*let VARm be the string value consisting of the digits of the decimal representation of VARn (in order, with no leading zeroes). 
*1*(S (Chunk let/VB VARm/NNP) be/VB the/DT string/VBG value/NN consisting/NN of/IN the/DT digits/NNS of/IN the/DT decimal/JJ representation/NN of/IN (Chunk VARn/NNP) (/( in/IN order/NN ,/, with/IN no/DT leading/VBG zeroes/NNS )/) ./.)
*0*if VARf ≠ 0, then
*0*(S if/IN (Chunk VARf/NNP) ≠/VBD 0/CD ,/, then/RB)
*1*let VARa be the first element of VARm, and let VARb be the remaining VARf elements of VARm. 
*1*(S (Chunk let/VB VARa/NNP) be/VB the/DT first/JJ element/NN of/IN (Chunk VARm/NNP) ,/, and/CC (Chunk let/VB VARb/NNP) be/VB the/DT (Chunk remaining/VBG VARf/NNP) elements/NNS of/IN (Chunk VARm/NNP) ./.)
*1*let VARm be the string-concatenation of VARa, ".", and VARb. 
*1*(S (Chunk let/VB VARm/NNP) be/VB the/DT string-concatenation/NN of/IN (Chunk VARa/NNP) ,/, ``/`` ./. ``/`` ,/, and/CC (Chunk VARb/NNP) ./.)
*0*if VARe = 0, then
*0*(S if/IN (Chunk VARe/NNP) (Chunk =/NNP) 0/CD ,/, then/RB)
*1*let VARc be "+". 
*1*(S (Chunk let/VB VARc/NNP) be/VB ``/`` +/JJ ''/'' ./.)
*1*let VARd be "0". 
*1*(S (Chunk let/VB VARd/NNP) be/VB ``/`` 0/CD ''/'' ./.)
*0*else,
*0*(S else/RB ,/,)
*1*if VARe &gt; 0, let VARc be "+". 
*1*(S if/IN (Chunk VARe/NNP) &/CC gt/NN ;/: 0/CD ,/, (Chunk let/VB VARc/NNP) be/VB ``/`` +/JJ ''/'' ./.)
*1*else VARe ≤ 0,
*1*(S (Chunk else/RB VARe/NNP) (Chunk ≤/NNP) 0/CD ,/,)
*2*let VARc be "-". 
*2*(S (Chunk let/VB VARc/NNP) be/VB ``/`` -/: ''/'' ./.)
*2*let VARe be -VARe. 
*2*(S (Chunk let/VB VARe/NNP) be/VB -VARe/VBN ./.)
*1*let VARd be the string value consisting of the digits of the decimal representation of VARe (in order, with no leading zeroes). 
*1*(S (Chunk let/VB VARd/NNP) be/VB the/DT string/VBG value/NN consisting/NN of/IN the/DT digits/NNS of/IN the/DT decimal/JJ representation/NN of/IN (Chunk VARe/NNP) (/( in/IN order/NN ,/, with/IN no/DT leading/VBG zeroes/NNS )/) ./.)
*0*let VARm be the string-concatenation of VARm, "e", VARc, and VARd. 
*0*(S (Chunk let/VB VARm/NNP) be/VB the/DT string-concatenation/NN of/IN (Chunk VARm/NNP) ,/, ``/`` e/NN ''/'' ,/, (Chunk VARc/NNP) ,/, and/CC (Chunk VARd/NNP) ./.)
*0*return the string-concatenation of VARs and VARm.     
*0*(S return/VB the/DT string-concatenation/NN of/IN (Chunk VARs/NNP) and/CC (Chunk VARm/NNP) ./.)
ID= 20.1.3.3
Summary= Number.prototype.toFixed ( fractionDigits )
*0*let VARx be ? FUNCthisnumbervalue(this value). 
*0*(S (Chunk let/VB VARx/NNP) be/VB ?/. (Chunk FUNCthisnumbervalue/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARf be ? FUNCtointeger(VARfractiondigits). (if VARfractiondigits is undefined, this step produces the value 0.) 
*0*(S (Chunk let/VB VARf/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARfractiondigits/NNP) )/) ./. (/( if/IN (Chunk VARfractiondigits/NNP) is/VBZ undefined/JJ ,/, this/DT step/NN produces/VBZ the/DT value/NN (Chunk 0/NNP) ./. )/))
*0*if VARf &lt; 0 or VARf &gt; 100, throw a rangeerror exception. 
*0*(S if/IN (Chunk VARf/NNP) &/CC lt/NN ;/: 0/CD or/CC (Chunk VARf/NNP) &/CC gt/NN ;/: 100/CD ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*if VARx is nan, return the string "nan". 
*0*(S if/IN (Chunk VARx/NNP) is/VBZ nan/JJ ,/, return/VB the/DT string/NN ``/`` nan/JJ ''/'' ./.)
*0*let VARs be the empty string. 
*0*(S (Chunk let/VB VARs/NNP) be/VB the/DT empty/JJ string/NN ./.)
*0*if VARx &lt; 0, then
*0*(S if/IN (Chunk VARx/NNP) &/CC lt/NN ;/: 0/CD ,/, then/RB)
*1*let VARs be "-". 
*1*(S (Chunk let/VB VARs/NNP) be/VB ``/`` -/: ''/'' ./.)
*1*let VARx be -VARx. 
*1*(S (Chunk let/VB VARx/NNP) be/VB -VARx/VBN ./.)
*0*if VARx ≥ 1021, then
*0*(S if/IN (Chunk VARx/NNP) (Chunk ≥/NNP) 1021/CD ,/, then/RB)
*1*let VARm be ! FUNCtostring(VARx). 
*1*(S (Chunk let/VB VARm/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARx/NNP) )/) ./.)
*0*else VARx &lt; 1021,
*0*(S (Chunk else/RB VARx/NNP) &/CC lt/NN ;/: 1021/CD ,/,)
*1*let VARn be an integer for which the exact mathematical value of VARn ÷ 10VARf - VARx is as close to zero as possible. if there are two such VARn, pick the larger VARn. 
*1*(S (Chunk let/VB VARn/NNP) be/VB an/DT integer/NN for/IN which/WDT the/DT exact/JJ mathematical/JJ value/NN of/IN (Chunk VARn/NNP) (Chunk ÷/NNP) 10VARf/CD -/: VARx/NN is/VBZ as/RB close/JJ to/TO zero/CD as/IN possible/JJ ./. if/IN there/EX are/VBP two/CD such/JJ (Chunk VARn/NNP) ,/, pick/VB the/DT larger/JJR (Chunk VARn/NNP) ./.)
*1*if VARn = 0, let VARm be the string "0". otherwise, let VARm be the string value consisting of the digits of the decimal representation of VARn (in order, with no leading zeroes). 
*1*(S if/IN (Chunk VARn/NNP) =/VBD 0/CD ,/, (Chunk let/VB VARm/NNP) be/VB the/DT string/NN ``/`` 0/CD ''/'' ./. otherwise/RB ,/, (Chunk let/VB VARm/NNP) be/VB the/DT string/VBG value/NN consisting/NN of/IN the/DT digits/NNS of/IN the/DT decimal/JJ representation/NN of/IN (Chunk VARn/NNP) (/( in/IN order/NN ,/, with/IN no/DT leading/VBG zeroes/NNS )/) ./.)
*1*if VARf ≠ 0, then
*1*(S if/IN (Chunk VARf/NNP) ≠/VBD 0/CD ,/, then/RB)
*2*let VARk be the length of VARm. 
*2*(S (Chunk let/VB VARk/NNP) be/VB the/DT length/NN of/IN (Chunk VARm/NNP) ./.)
*2*if VARk ≤ VARf, then
*2*(S if/IN (Chunk VARk/NNP) (Chunk ≤/NNP) (Chunk VARf/NNP) ,/, then/RB)
*3*let VARz be the string value consisting of VARf+1-VARk occurrences of the code unit 0x0030 (digit zero). 
*3*(S (Chunk let/VB VARz/NNP) be/VB the/DT string/VBG value/NN consisting/VBG of/IN (Chunk VARf+1-VARk/NNP) occurrences/NNS of/IN the/DT code/NN unit/NN 0x0030/CD (/( digit/JJ zero/NN )/) ./.)
*3*let VARm be the string-concatenation of VARz and VARm. 
*3*(S (Chunk let/VB VARm/NNP) be/VB the/DT string-concatenation/NN of/IN (Chunk VARz/NNP) and/CC (Chunk VARm/NNP) ./.)
*3*let VARk be VARf + 1. 
*3*(S (Chunk let/VB VARk/NNP) (Chunk be/VB VARf/NNP) (Chunk +/NNP) 1/CD ./.)
*2*let VARa be the first VARk-VARf elements of VARm, and let VARb be the remaining VARf elements of VARm. 
*2*(S (Chunk let/VB VARa/NNP) be/VB the/DT first/JJ VARk-VARf/JJ elements/NNS of/IN (Chunk VARm/NNP) ,/, and/CC (Chunk let/VB VARb/NNP) be/VB the/DT (Chunk remaining/VBG VARf/NNP) elements/NNS of/IN (Chunk VARm/NNP) ./.)
*2*let VARm be the string-concatenation of VARa, ".", and VARb. 
*2*(S (Chunk let/VB VARm/NNP) be/VB the/DT string-concatenation/NN of/IN (Chunk VARa/NNP) ,/, ``/`` ./. ``/`` ,/, and/CC (Chunk VARb/NNP) ./.)
*0*return the string-concatenation of VARs and VARm.     
*0*(S return/VB the/DT string-concatenation/NN of/IN (Chunk VARs/NNP) and/CC (Chunk VARm/NNP) ./.)
ID= 20.1.3.5
Summary= Number.prototype.toPrecision ( precision )
*0*let VARx be ? FUNCthisnumbervalue(this value). 
*0*(S (Chunk let/VB VARx/NNP) be/VB ?/. (Chunk FUNCthisnumbervalue/NNP) (/( this/DT value/NN )/) ./.)
*0*if VARprecision is undefined, return ! FUNCtostring(VARx). 
*0*(S if/IN (Chunk VARprecision/NNP) is/VBZ undefined/JJ ,/, return/NN !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARx/NNP) )/) ./.)
*0*let VARp be ? FUNCtointeger(VARprecision). 
*0*(S (Chunk let/VB VARp/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARprecision/NNP) )/) ./.)
*0*if VARx is nan, return the string "nan". 
*0*(S if/IN (Chunk VARx/NNP) is/VBZ nan/JJ ,/, return/VB the/DT string/NN ``/`` nan/JJ ''/'' ./.)
*0*let VARs be the empty string. 
*0*(S (Chunk let/VB VARs/NNP) be/VB the/DT empty/JJ string/NN ./.)
*0*if VARx &lt; 0, then
*0*(S if/IN (Chunk VARx/NNP) &/CC lt/NN ;/: 0/CD ,/, then/RB)
*1*let VARs be the code unit 0x002d (hyphen-minus). 
*1*(S (Chunk let/VB VARs/NNP) be/VB the/DT code/NN unit/NN 0x002d/CD (/( hyphen-minus/NN )/) ./.)
*1*let VARx be -VARx. 
*1*(S (Chunk let/VB VARx/NNP) be/VB -VARx/VBN ./.)
*0*if VARx = +∞, then
*0*(S if/IN (Chunk VARx/NNP) (Chunk =/NNP) (Chunk +∞/NNP) ,/, then/RB)
*1*return the string-concatenation of VARs and "infinity". 
*1*(S return/VB the/DT string-concatenation/NN of/IN (Chunk VARs/NNP) and/CC ``/`` infinity/NN ''/'' ./.)
*0*if VARp &lt; 1 or VARp &gt; 100, throw a rangeerror exception. 
*0*(S if/IN (Chunk VARp/NNP) &/CC lt/NN ;/: 1/CD or/CC (Chunk VARp/NNP) &/CC gt/NN ;/: 100/CD ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*if VARx = 0, then
*0*(S if/IN (Chunk VARx/NNP) =/VBD 0/CD ,/, then/RB)
*1*let VARm be the string value consisting of VARp occurrences of the code unit 0x0030 (digit zero). 
*1*(S (Chunk let/VB VARm/NNP) be/VB the/DT string/VBG value/NN consisting/VBG of/IN (Chunk VARp/NNP) occurrences/NNS of/IN the/DT code/NN unit/NN 0x0030/CD (/( digit/JJ zero/NN )/) ./.)
*1*let VARe be 0. 
*1*(S (Chunk let/VB VARe/NNP) be/VB 0/CD ./.)
*0*else VARx ≠ 0,
*0*(S (Chunk else/RB VARx/NNP) (Chunk ≠/NNP) 0/CD ,/,)
*1*let VARe and VARn be integers such that 10VARp-1 ≤ VARn &lt; 10VARp and for which the exact mathematical value of VARn × 10VARe-VARp+1 - VARx is as close to zero as possible. if there are two such sets of VARe and VARn, pick the VARe and VARn for which VARn × 10VARe-VARp+1 is larger. 
*1*(S let/NN (Chunk VARe/NNP) and/CC (Chunk VARn/NNP) be/VB integers/NNS such/JJ that/IN 10VARp-1/JJ (Chunk ≤/NNP) (Chunk VARn/NNP) &/CC lt/NN ;/: 10VARp/CD and/CC for/IN which/WDT the/DT exact/JJ mathematical/JJ value/NN of/IN (Chunk VARn/NNP) (Chunk ×/NNP) 10VARe-VARp+1/JJ -/: VARx/NN is/VBZ as/RB close/JJ to/TO zero/CD as/IN possible/JJ ./. if/IN there/EX are/VBP two/CD such/JJ sets/NNS of/IN (Chunk VARe/NNP) and/CC (Chunk VARn/NNP) ,/, pick/VB the/DT (Chunk VARe/NNP) and/CC (Chunk VARn/NNP) for/IN which/WDT (Chunk VARn/NNP) (Chunk ×/NNP) 10VARe-VARp+1/CD is/VBZ larger/JJR ./.)
*1*let VARm be the string value consisting of the digits of the decimal representation of VARn (in order, with no leading zeroes). 
*1*(S (Chunk let/VB VARm/NNP) be/VB the/DT string/VBG value/NN consisting/NN of/IN the/DT digits/NNS of/IN the/DT decimal/JJ representation/NN of/IN (Chunk VARn/NNP) (/( in/IN order/NN ,/, with/IN no/DT leading/VBG zeroes/NNS )/) ./.)
*1*if VARe &lt; -6 or VARe ≥ VARp, then
*1*(S if/IN (Chunk VARe/NNP) &/CC lt/NN ;/: -6/CC or/CC (Chunk VARe/NNP) (Chunk ≥/NNP) (Chunk VARp/NNP) ,/, then/RB)
*2*assert: VARe ≠ 0. 
*2*(S assert/NN :/: (Chunk VARe/NNP) ≠/VBZ 0/CD ./.)
*2*if VARp ≠ 1, then
*2*(S if/IN (Chunk VARp/NNP) (Chunk ≠/NNP) 1/CD ,/, then/RB)
*3*let VARa be the first element of VARm, and let VARb be the remaining VARp-1 elements of VARm. 
*3*(S (Chunk let/VB VARa/NNP) be/VB the/DT first/JJ element/NN of/IN (Chunk VARm/NNP) ,/, and/CC (Chunk let/VB VARb/NNP) be/VB the/DT remaining/VBG VARp-1/JJ elements/NNS of/IN (Chunk VARm/NNP) ./.)
*3*let VARm be the string-concatenation of VARa, ".", and VARb. 
*3*(S (Chunk let/VB VARm/NNP) be/VB the/DT string-concatenation/NN of/IN (Chunk VARa/NNP) ,/, ``/`` ./. ``/`` ,/, and/CC (Chunk VARb/NNP) ./.)
*2*if VARe &gt; 0, then
*2*(S if/IN (Chunk VARe/NNP) &/CC gt/NN ;/: 0/CD ,/, then/RB)
*3*let VARc be the code unit 0x002b (plus sign). 
*3*(S (Chunk let/VB VARc/NNP) be/VB the/DT code/NN unit/NN 0x002b/CD (/( plus/CC sign/NN )/) ./.)
*2*else VARe &lt; 0,
*2*(S (Chunk else/RB VARe/NNP) &/CC lt/NN ;/: 0/CD ,/,)
*3*let VARc be the code unit 0x002d (hyphen-minus). 
*3*(S (Chunk let/VB VARc/NNP) be/VB the/DT code/NN unit/NN 0x002d/CD (/( hyphen-minus/NN )/) ./.)
*3*let VARe be -VARe. 
*3*(S (Chunk let/VB VARe/NNP) be/VB -VARe/VBN ./.)
*2*let VARd be the string value consisting of the digits of the decimal representation of VARe (in order, with no leading zeroes). 
*2*(S (Chunk let/VB VARd/NNP) be/VB the/DT string/VBG value/NN consisting/NN of/IN the/DT digits/NNS of/IN the/DT decimal/JJ representation/NN of/IN (Chunk VARe/NNP) (/( in/IN order/NN ,/, with/IN no/DT leading/VBG zeroes/NNS )/) ./.)
*2*return the string-concatenation of VARs, VARm, the code unit 0x0065 (latin small letter e), VARc, and VARd. 
*2*(S return/VB the/DT string-concatenation/NN of/IN (Chunk VARs/NNP) ,/, (Chunk VARm/NNP) ,/, the/DT code/NN unit/NN 0x0065/CD (/( latin/VB small/JJ letter/NN e/NN )/) ,/, (Chunk VARc/NNP) ,/, and/CC (Chunk VARd/NNP) ./.)
*0*if VARe = VARp-1, return the string-concatenation of VARs and VARm. 
*0*(S if/IN (Chunk VARe/NNP) (Chunk =/NNP) (Chunk VARp-1/NNP) ,/, return/VB the/DT string-concatenation/NN of/IN (Chunk VARs/NNP) and/CC (Chunk VARm/NNP) ./.)
*0*if VARe ≥ 0, then
*0*(S if/IN (Chunk VARe/NNP) (Chunk ≥/NNP) 0/CD ,/, then/RB)
*1*let VARm be the string-concatenation of the first VARe+1 elements of VARm, the code unit 0x002e (full stop), and the remaining VARp- (VARe+1) elements of VARm. 
*1*(S (Chunk let/VB VARm/NNP) be/VB the/DT string-concatenation/NN of/IN the/DT first/JJ (Chunk VARe+1/NNP) elements/NNS of/IN (Chunk VARm/NNP) ,/, the/DT code/NN unit/NN 0x002e/CD (/( full/JJ stop/NN )/) ,/, and/CC the/DT (Chunk remaining/VBG VARp-/NNP) (/( (Chunk VARe+1/NNP) )/) elements/NNS of/IN (Chunk VARm/NNP) ./.)
*0*else VARe &lt; 0,
*0*(S (Chunk else/RB VARe/NNP) &/CC lt/NN ;/: 0/CD ,/,)
*1*let VARm be the string-concatenation of the code unit 0x0030 (digit zero), the code unit 0x002e (full stop), -(VARe+1) occurrences of the code unit 0x0030 (digit zero), and the string VARm. 
*1*(S (Chunk let/VB VARm/NNP) be/VB the/DT string-concatenation/NN of/IN the/DT code/NN unit/NN 0x0030/CD (/( digit/JJ zero/NN )/) ,/, the/DT code/NN unit/NN 0x002e/CD (/( full/JJ stop/NN )/) ,/, -/: (/( (Chunk VARe+1/NNP) )/) occurrences/NNS of/IN the/DT code/NN unit/NN 0x0030/CD (/( digit/JJ zero/NN )/) ,/, and/CC the/DT string/NN (Chunk VARm/NNP) ./.)
*0*return the string-concatenation of VARs and VARm.     
*0*(S return/VB the/DT string-concatenation/NN of/IN (Chunk VARs/NNP) and/CC (Chunk VARm/NNP) ./.)
ID= 20.1.3.6
Summary= Number.prototype.toString ( [ radix ] )
*0*let VARx be ? FUNCthisnumbervalue(this value). 
*0*(S (Chunk let/VB VARx/NNP) be/VB ?/. (Chunk FUNCthisnumbervalue/NNP) (/( this/DT value/NN )/) ./.)
*0*if VARradix is not present, let VARradixnumber be 10. 
*0*(S if/IN (Chunk VARradix/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARradixnumber/NNP) be/VB 10/CD ./.)
*0*else if VARradix is undefined, let VARradixnumber be 10. 
*0*(S else/RB if/IN (Chunk VARradix/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARradixnumber/NNP) be/VB 10/CD ./.)
*0*else, let VARradixnumber be ? FUNCtointeger(VARradix). 
*0*(S else/RB ,/, (Chunk let/VB VARradixnumber/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARradix/NNP) )/) ./.)
*0*if VARradixnumber &lt; 2 or VARradixnumber &gt; 36, throw a rangeerror exception. 
*0*(S if/IN (Chunk VARradixnumber/NNP) &/CC lt/NN ;/: 2/CD or/CC (Chunk VARradixnumber/NNP) &/CC gt/NN ;/: 36/CD ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*if VARradixnumber = 10, return ! FUNCtostring(VARx). 
*0*(S if/IN (Chunk VARradixnumber/NNP) (Chunk =/NNP) 10/CD ,/, return/NN !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARx/NNP) )/) ./.)
*0*return the string representation of this number value using the radix specified by VARradixnumber. letters a-z are used for digits with values 10 through 35. the precise algorithm is implementation-dependent, however the algorithm should be a generalization of that specified in 7.1.12.1.     
*0*(S return/VB the/DT string/NN representation/NN of/IN this/DT number/NN value/NN using/VBG the/DT radix/NN specified/VBN by/IN (Chunk VARradixnumber/NNP) ./. letters/NNS a-z/JJ are/VBP used/VBN for/IN digits/NNS with/IN values/NNS 10/CD through/IN 35./CD the/DT precise/NN algorithm/NN is/VBZ implementation-dependent/JJ ,/, however/RB the/DT algorithm/NN should/MD be/VB a/DT generalization/NN of/IN that/DT specified/VBN in/IN 7.1.12.1/CD ./.)
ID= 20.1.3.7
Summary= Number.prototype.valueOf ( )
*0*return ? FUNCthisnumbervalue(this value).     
*0*(S return/NN ?/. (Chunk FUNCthisnumbervalue/NNP) (/( this/DT value/NN )/) ./.)
ID= 20.2.2.11
Summary= Math.clz32 ( x )
*0*let VARn be FUNCtouint32(VARx). 
*0*(S (Chunk let/VB VARn/NNP) (Chunk be/VB FUNCtouint32/NNP) (/( (Chunk VARx/NNP) )/) ./.)
*0*let VARp be the number of leading zero bits in the 32-bit binary representation of VARn. 
*0*(S (Chunk let/VB VARp/NNP) be/VB the/DT number/NN of/IN leading/VBG zero/CD bits/NNS in/IN the/DT 32-bit/JJ binary/JJ representation/NN of/IN (Chunk VARn/NNP) ./.)
*0*return VARp.     
*0*(S return/NN (Chunk VARp/NNP) ./.)
ID= 20.2.2.17
Summary= Math.fround ( x )
*0*if VARx is nan, return nan. 
*0*(S if/IN (Chunk VARx/NNP) is/VBZ nan/JJ ,/, return/VB nan/NNS ./.)
*0*if VARx is one of +0, -0, +∞, -∞, return VARx. 
*0*(S if/IN (Chunk VARx/NNP) is/VBZ one/CD of/IN +0/NN ,/, (Chunk -0/NNP) ,/, (Chunk +∞/NNP) ,/, (Chunk -∞/NNP) ,/, return/NN (Chunk VARx/NNP) ./.)
*0*let VARx32 be the result of converting VARx to a value in ieee 754-2008 binary32 format using roundtiestoeven. 
*0*(S (Chunk let/VB VARx32/NNP) be/VB the/DT result/NN of/IN (Chunk converting/VBG VARx/NNP) to/TO a/DT value/NN in/IN ieee/JJ 754-2008/JJ binary32/NN format/NN using/VBG roundtiestoeven/NN ./.)
*0*let VARx64 be the result of converting VARx32 to a value in ieee 754-2008 binary64 format. 
*0*(S (Chunk let/VB VARx64/NNP) be/VB the/DT result/NN of/IN (Chunk converting/VBG VARx32/NNP) to/TO a/DT value/NN in/IN ieee/JJ 754-2008/JJ binary64/NN format/NN ./.)
*0*return the ecmascript number value corresponding to VARx64.     
*0*(S return/VB the/DT ecmascript/NN number/NN value/NN corresponding/VBG to/TO (Chunk VARx64/NNP) ./.)
ID= 20.2.2.19
Summary= Math.imul ( x, y )
*0*let VARa be FUNCtouint32(VARx). 
*0*(S (Chunk let/VB VARa/NNP) (Chunk be/VB FUNCtouint32/NNP) (/( (Chunk VARx/NNP) )/) ./.)
*0*let VARb be FUNCtouint32(VARy). 
*0*(S (Chunk let/VB VARb/NNP) (Chunk be/VB FUNCtouint32/NNP) (/( (Chunk VARy/NNP) )/) ./.)
*0*let VARproduct be (VARa × VARb) modulo 232. 
*0*(S (Chunk let/VB VARproduct/NNP) be/VB (/( (Chunk VARa/NNP) (Chunk ×/NNP) (Chunk VARb/NNP) )/) modulo/VBD 232/CD ./.)
*0*if VARproduct ≥ 231, return VARproduct - 232; otherwise return VARproduct.     
*0*(S if/IN (Chunk VARproduct/NNP) (Chunk ≥/NNP) 231/CD ,/, return/NN (Chunk VARproduct/NNP) -/: 232/CD ;/: (Chunk otherwise/RB return/VB VARproduct/NNP) ./.)
ID= 20.3.1.8
Summary= LocalTime ( t )
*0*return VARt + FUNClocaltza(VARt, true).     
*0*(S (Chunk return/VB VARt/NNP) (Chunk +/NNP) (Chunk FUNClocaltza/NNP) (/( (Chunk VARt/NNP) ,/, true/JJ )/) ./.)
ID= 20.3.1.9
Summary= UTC ( t )
*0*return VARt - FUNClocaltza(VARt, false).     
*0*(S (Chunk return/VB VARt/NNP) -/: (Chunk FUNClocaltza/NNP) (/( (Chunk VARt/NNP) ,/, false/RB )/) ./.)
ID= 20.3.1.11
Summary= MakeTime ( hour, min, sec, ms )
*0*if VARhour is not finite or VARmin is not finite or VARsec is not finite or VARms is not finite, return nan. 
*0*(S if/IN (Chunk VARhour/NNP) is/VBZ not/RB finite/JJ or/CC (Chunk VARmin/NNP) is/VBZ not/RB finite/JJ or/CC (Chunk VARsec/NNP) is/VBZ not/RB finite/JJ or/CC (Chunk VARms/NNP) is/VBZ not/RB finite/JJ ,/, return/VB nan/NNS ./.)
*0*let VARh be ! FUNCtointeger(VARhour). 
*0*(S (Chunk let/VB VARh/NNP) be/VB !/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARhour/NNP) )/) ./.)
*0*let VARm be ! FUNCtointeger(VARmin). 
*0*(S (Chunk let/VB VARm/NNP) be/VB !/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARmin/NNP) )/) ./.)
*0*let VARs be ! FUNCtointeger(VARsec). 
*0*(S (Chunk let/VB VARs/NNP) be/VB !/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARsec/NNP) )/) ./.)
*0*let VARmilli be ! FUNCtointeger(VARms). 
*0*(S (Chunk let/VB VARmilli/NNP) be/VB !/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARms/NNP) )/) ./.)
*0*let VARt be VARh * msperhour + VARm * msperminute + VARs * mspersecond + VARmilli, performing the arithmetic according to ieee 754-2008 rules (that is, as if using the ecmascript operators * and +). 
*0*(S (Chunk let/VB VARt/NNP) (Chunk be/VB VARh/NNP) msperminute/JJ (Chunk +/NNP) (Chunk VARs/NNP) and/CC (Chunk +/NNP) )/) ./.)
*0*return VARt.     
*0*(S return/NN (Chunk VARt/NNP) ./.)
ID= 20.3.1.12
Summary= MakeDay ( year, month, date )
*0*if VARyear is not finite or VARmonth is not finite or VARdate is not finite, return nan. 
*0*(S if/IN (Chunk VARyear/NNP) is/VBZ not/RB finite/JJ or/CC (Chunk VARmonth/NNP) is/VBZ not/RB finite/JJ or/CC (Chunk VARdate/NNP) is/VBZ not/RB finite/JJ ,/, return/VB nan/NNS ./.)
*0*let VARy be ! FUNCtointeger(VARyear). 
*0*(S (Chunk let/VB VARy/NNP) be/VB !/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARyear/NNP) )/) ./.)
*0*let VARm be ! FUNCtointeger(VARmonth). 
*0*(S (Chunk let/VB VARm/NNP) be/VB !/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARmonth/NNP) )/) ./.)
*0*let VARdt be ! FUNCtointeger(VARdate). 
*0*(S (Chunk let/VB VARdt/NNP) be/VB !/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARdate/NNP) )/) ./.)
*0*let VARym be VARy + floor(VARm / 12). 
*0*(S (Chunk let/VB VARym/NNP) (Chunk be/VB VARy/NNP) (Chunk +/NNP) floor/NN (/( (Chunk VARm/NNP) (Chunk //NNP) 12/CD )/) ./.)
*0*let VARmn be VARm modulo 12. 
*0*(S (Chunk let/VB VARmn/NNP) (Chunk be/VB VARm/NNP) modulo/NN 12/CD ./.)
*0*find a value VARt such that yearfromtime(VARt) is VARym and monthfromtime(VARt) is VARmn and FUNCdatefromtime(VARt) is 1; but if this is not possible (because some argument is out of range), return nan. 
*0*(S find/VB a/DT value/NN (Chunk VARt/NNP) such/PDT that/IN yearfromtime/NN (/( (Chunk VARt/NNP) )/) (Chunk is/VBZ VARym/NNP) and/CC monthfromtime/NN (/( (Chunk VARt/NNP) )/) (Chunk is/VBZ VARmn/NNP) and/CC (Chunk FUNCdatefromtime/NNP) (/( (Chunk VARt/NNP) )/) is/VBZ 1/CD ;/: but/CC if/IN this/DT is/VBZ not/RB possible/JJ (/( because/IN some/DT argument/NN is/VBZ out/IN of/IN range/NN )/) ,/, return/VBP nan/RB ./.)
*0*return day(VARt) + VARdt - 1.     
*0*(S return/NN day/NN (/( (Chunk VARt/NNP) )/) +/NN (Chunk VARdt/NNP) -/: 1/CD ./.)
ID= 20.3.1.13
Summary= MakeDate ( day, time )
*0*if VARday is not finite or VARtime is not finite, return nan. 
*0*(S if/IN (Chunk VARday/NNP) is/VBZ not/RB finite/JJ or/CC (Chunk VARtime/NNP) is/VBZ not/RB finite/JJ ,/, return/VB nan/NNS ./.)
*0*return VARday × msperday + VARtime.     
*0*(S return/NN (Chunk VARday/NNP) (Chunk ×/NNP) msperday/NN (Chunk +/NNP) (Chunk VARtime/NNP) ./.)
ID= 20.3.1.14
Summary= TimeClip ( time )
*0*if VARtime is not finite, return nan. 
*0*(S if/IN (Chunk VARtime/NNP) is/VBZ not/RB finite/JJ ,/, return/VB nan/NNS ./.)
*0*if abs(VARtime) &gt; 8.64 × 1015, return nan. 
*0*(S if/IN abs/NNS (/( (Chunk VARtime/NNP) )/) &/CC gt/NN ;/: 8.64/CD ×/NN 1015/CD ,/, return/NN nan/NN ./.)
*0*let VARclippedtime be ! FUNCtointeger(VARtime). 
*0*(S (Chunk let/VB VARclippedtime/NNP) be/VB !/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARtime/NNP) )/) ./.)
*0*if VARclippedtime is -0, set VARclippedtime to +0. 
*0*(S if/IN (Chunk VARclippedtime/NNP) is/VBZ -0/JJ ,/, (Chunk set/VBN VARclippedtime/NNP) to/TO +0/VB ./.)
*0*return VARclippedtime.     
*0*(S return/NN (Chunk VARclippedtime/NNP) ./.)
ID= 20.3.2.1
Summary= Date ( year, month [ , date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] )
*0*let VARnumberofargs be the number of arguments passed to this function call. 
*0*(S (Chunk let/VB VARnumberofargs/NNP) be/VB the/DT number/NN of/IN arguments/NNS passed/VBN to/TO this/DT function/NN call/NN ./.)
*0*assert: VARnumberofargs ≥ 2. 
*0*(S assert/NN :/: (Chunk VARnumberofargs/NNP) ≥/VBZ 2/CD ./.)
*0*if newtarget is undefined, then
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, then/RB)
*1*let VARnow be the number that is the time value (utc) identifying the current time. 
*1*(S (Chunk let/VB VARnow/NNP) be/VB the/DT number/NN that/WDT is/VBZ the/DT time/NN value/NN (/( utc/JJ )/) identifying/VBG the/DT current/JJ time/NN ./.)
*1*return FUNCtodatestring(VARnow). 
*1*(S return/NN (Chunk FUNCtodatestring/NNP) (/( (Chunk VARnow/NNP) )/) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARy be ? FUNCtonumber(VARyear). 
*1*(S (Chunk let/VB VARy/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARyear/NNP) )/) ./.)
*1*let VARm be ? FUNCtonumber(VARmonth). 
*1*(S (Chunk let/VB VARm/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARmonth/NNP) )/) ./.)
*1*if VARdate is present, let VARdt be ? FUNCtonumber(VARdate); else let VARdt be 1. 
*1*(S if/IN (Chunk VARdate/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARdt/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARdate/NNP) )/) ;/: else/JJ let/NN (Chunk VARdt/NNP) be/VB 1/CD ./.)
*1*if VARhours is present, let VARh be ? FUNCtonumber(VARhours); else let VARh be 0. 
*1*(S if/IN (Chunk VARhours/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARh/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARhours/NNP) )/) ;/: else/JJ (Chunk let/VB VARh/NNP) be/VB 0/CD ./.)
*1*if VARminutes is present, let VARmin be ? FUNCtonumber(VARminutes); else let VARmin be 0. 
*1*(S if/IN (Chunk VARminutes/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARmin/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARminutes/NNP) )/) ;/: else/JJ (Chunk let/VB VARmin/NNP) be/VB 0/CD ./.)
*1*if VARseconds is present, let VARs be ? FUNCtonumber(VARseconds); else let VARs be 0. 
*1*(S if/IN (Chunk VARseconds/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARseconds/NNP) )/) ;/: else/JJ let/NN (Chunk VARs/NNP) be/VB 0/CD ./.)
*1*if VARms is present, let VARmilli be ? FUNCtonumber(VARms); else let VARmilli be 0. 
*1*(S if/IN (Chunk VARms/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARmilli/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARms/NNP) )/) ;/: else/JJ (Chunk let/VB VARmilli/NNP) be/VB 0/CD ./.)
*1*if VARy is not nan and 0 ≤ FUNCtointeger(VARy) ≤ 99, let VARyr be 1900+FUNCtointeger(VARy); otherwise, let VARyr be VARy. 
*1*(S if/IN (Chunk VARy/NNP) is/VBZ not/RB nan/JJ and/CC 0/CD ≤/NN (Chunk FUNCtointeger/NNP) (/( (Chunk VARy/NNP) )/) ≤/VBD 99/CD ,/, (Chunk let/VB VARyr/NNP) be/VB 1900+FUNCtointeger/CD (/( (Chunk VARy/NNP) )/) ;/: otherwise/RB ,/, (Chunk let/VB VARyr/NNP) (Chunk be/VB VARy/NNP) ./.)
*1*let VARfinaldate be FUNCmakedate(FUNCmakeday(VARyr, VARm, VARdt), FUNCmaketime(VARh, VARmin, VARs, VARmilli)). 
*1*(S (Chunk let/VB VARfinaldate/NNP) (Chunk be/VB FUNCmakedate/NNP) (/( (Chunk FUNCmakeday/NNP) (/( (Chunk VARyr/NNP) ,/, (Chunk VARm/NNP) ,/, (Chunk VARdt/NNP) )/) ,/, (Chunk FUNCmaketime/NNP) (/( (Chunk VARh/NNP) ,/, (Chunk VARmin/NNP) ,/, (Chunk VARs/NNP) ,/, (Chunk VARmilli/NNP) )/) )/) ./.)
*1*let VARo be ? FUNCordinarycreatefromconstructor(newtarget, "%dateprototype%", « [[DATEVALUE]] »). 
*1*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCordinarycreatefromconstructor/NNP) (/( newtarget/NN ,/, ``/`` %/NN dateprototype/NN %/NN ''/'' ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*1*set VARo.[[DATEVALUE]] to FUNCtimeclip(FUNCutc(VARfinaldate)). 
*1*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk FUNCtimeclip/NNP) (/( (Chunk FUNCutc/NNP) (/( (Chunk VARfinaldate/NNP) )/) )/) ./.)
*1*return VARo.     
*1*(S return/NN (Chunk VARo/NNP) ./.)
ID= 20.3.2.2
Summary= Date ( value )
*0*let VARnumberofargs be the number of arguments passed to this function call. 
*0*(S (Chunk let/VB VARnumberofargs/NNP) be/VB the/DT number/NN of/IN arguments/NNS passed/VBN to/TO this/DT function/NN call/NN ./.)
*0*assert: VARnumberofargs = 1. 
*0*(S assert/NN :/: (Chunk VARnumberofargs/NNP) =/VBZ 1/CD ./.)
*0*if newtarget is undefined, then
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, then/RB)
*1*let VARnow be the number that is the time value (utc) identifying the current time. 
*1*(S (Chunk let/VB VARnow/NNP) be/VB the/DT number/NN that/WDT is/VBZ the/DT time/NN value/NN (/( utc/JJ )/) identifying/VBG the/DT current/JJ time/NN ./.)
*1*return FUNCtodatestring(VARnow). 
*1*(S return/NN (Chunk FUNCtodatestring/NNP) (/( (Chunk VARnow/NNP) )/) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*if FUNCtype(VARvalue) is object and VARvalue has a [[DATEVALUE]] internal slot, then
*1*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARvalue/NNP) )/) is/VBZ object/JJ and/CC (Chunk VARvalue/NNP) has/VBZ a/DT [/JJ [/NN (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, then/RB)
*2*let VARtv be thistimevalue(VARvalue). 
*2*(S (Chunk let/VB VARtv/NNP) be/VB thistimevalue/JJ (/( (Chunk VARvalue/NNP) )/) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*let VARv be ? FUNCtoprimitive(VARvalue). 
*2*(S (Chunk let/VB VARv/NNP) be/VB ?/. (Chunk FUNCtoprimitive/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*2*if FUNCtype(VARv) is string, then
*2*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ string/VBG ,/, then/RB)
*3*assert: the next step never returns an abrupt completion because VARv is a string value. 
*3*(S assert/NN :/: the/DT next/JJ step/NN never/RB returns/VBZ an/DT abrupt/JJ completion/NN because/IN (Chunk VARv/NNP) is/VBZ a/DT string/VBG value/NN ./.)
*3*let VARtv be the result of parsing VARv as a date, in exactly the same manner as for the parse method (20.3.3.2). 
*3*(S (Chunk let/VB VARtv/NNP) be/VB the/DT result/NN of/IN (Chunk parsing/VBG VARv/NNP) as/IN a/DT date/NN ,/, in/IN exactly/RB the/DT same/JJ manner/NN as/IN for/IN the/DT parse/NN method/NN (/( 20.3.3.2/CD )/) ./.)
*2*else,
*2*(S else/RB ,/,)
*3*let VARtv be ? FUNCtonumber(VARv). 
*3*(S (Chunk let/VB VARtv/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARv/NNP) )/) ./.)
*1*let VARo be ? FUNCordinarycreatefromconstructor(newtarget, "%dateprototype%", « [[DATEVALUE]] »). 
*1*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCordinarycreatefromconstructor/NNP) (/( newtarget/NN ,/, ``/`` %/NN dateprototype/NN %/NN ''/'' ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*1*set VARo.[[DATEVALUE]] to FUNCtimeclip(VARtv). 
*1*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk FUNCtimeclip/NNP) (/( (Chunk VARtv/NNP) )/) ./.)
*1*return VARo.     
*1*(S return/NN (Chunk VARo/NNP) ./.)
ID= 20.3.2.3
Summary= Date ( )
*0*let VARnumberofargs be the number of arguments passed to this function call. 
*0*(S (Chunk let/VB VARnumberofargs/NNP) be/VB the/DT number/NN of/IN arguments/NNS passed/VBN to/TO this/DT function/NN call/NN ./.)
*0*assert: VARnumberofargs = 0. 
*0*(S assert/NN :/: (Chunk VARnumberofargs/NNP) =/VBZ 0/CD ./.)
*0*if newtarget is undefined, then
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, then/RB)
*1*let VARnow be the number that is the time value (utc) identifying the current time. 
*1*(S (Chunk let/VB VARnow/NNP) be/VB the/DT number/NN that/WDT is/VBZ the/DT time/NN value/NN (/( utc/JJ )/) identifying/VBG the/DT current/JJ time/NN ./.)
*1*return FUNCtodatestring(VARnow). 
*1*(S return/NN (Chunk FUNCtodatestring/NNP) (/( (Chunk VARnow/NNP) )/) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARo be ? FUNCordinarycreatefromconstructor(newtarget, "%dateprototype%", « [[DATEVALUE]] »). 
*1*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCordinarycreatefromconstructor/NNP) (/( newtarget/NN ,/, ``/`` %/NN dateprototype/NN %/NN ''/'' ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*1*set VARo.[[DATEVALUE]] to the time value (utc) identifying the current time. 
*1*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO the/DT time/NN value/NN (/( utc/JJ )/) identifying/VBG the/DT current/JJ time/NN ./.)
*1*return VARo.     
*1*(S return/NN (Chunk VARo/NNP) ./.)
ID= 20.3.3.4
Summary= Date.UTC ( year [ , month [ , date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] ] )
*0*let VARy be ? FUNCtonumber(VARyear). 
*0*(S (Chunk let/VB VARy/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARyear/NNP) )/) ./.)
*0*if VARmonth is present, let VARm be ? FUNCtonumber(VARmonth); else let VARm be 0. 
*0*(S if/IN (Chunk VARmonth/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARm/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARmonth/NNP) )/) ;/: else/JJ (Chunk let/VB VARm/NNP) be/VB 0/CD ./.)
*0*if VARdate is present, let VARdt be ? FUNCtonumber(VARdate); else let VARdt be 1. 
*0*(S if/IN (Chunk VARdate/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARdt/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARdate/NNP) )/) ;/: else/JJ let/NN (Chunk VARdt/NNP) be/VB 1/CD ./.)
*0*if VARhours is present, let VARh be ? FUNCtonumber(VARhours); else let VARh be 0. 
*0*(S if/IN (Chunk VARhours/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARh/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARhours/NNP) )/) ;/: else/JJ (Chunk let/VB VARh/NNP) be/VB 0/CD ./.)
*0*if VARminutes is present, let VARmin be ? FUNCtonumber(VARminutes); else let VARmin be 0. 
*0*(S if/IN (Chunk VARminutes/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARmin/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARminutes/NNP) )/) ;/: else/JJ (Chunk let/VB VARmin/NNP) be/VB 0/CD ./.)
*0*if VARseconds is present, let VARs be ? FUNCtonumber(VARseconds); else let VARs be 0. 
*0*(S if/IN (Chunk VARseconds/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARseconds/NNP) )/) ;/: else/JJ let/NN (Chunk VARs/NNP) be/VB 0/CD ./.)
*0*if VARms is present, let VARmilli be ? FUNCtonumber(VARms); else let VARmilli be 0. 
*0*(S if/IN (Chunk VARms/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARmilli/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARms/NNP) )/) ;/: else/JJ (Chunk let/VB VARmilli/NNP) be/VB 0/CD ./.)
*0*if VARy is not nan and 0 ≤ FUNCtointeger(VARy) ≤ 99, let VARyr be 1900+FUNCtointeger(VARy); otherwise, let VARyr be VARy. 
*0*(S if/IN (Chunk VARy/NNP) is/VBZ not/RB nan/JJ and/CC 0/CD ≤/NN (Chunk FUNCtointeger/NNP) (/( (Chunk VARy/NNP) )/) ≤/VBD 99/CD ,/, (Chunk let/VB VARyr/NNP) be/VB 1900+FUNCtointeger/CD (/( (Chunk VARy/NNP) )/) ;/: otherwise/RB ,/, (Chunk let/VB VARyr/NNP) (Chunk be/VB VARy/NNP) ./.)
*0*return FUNCtimeclip(FUNCmakedate(FUNCmakeday(VARyr, VARm, VARdt), FUNCmaketime(VARh, VARmin, VARs, VARmilli))).     
*0*(S return/NN (Chunk FUNCtimeclip/NNP) (/( (Chunk FUNCmakedate/NNP) (/( (Chunk FUNCmakeday/NNP) (/( (Chunk VARyr/NNP) ,/, (Chunk VARm/NNP) ,/, (Chunk VARdt/NNP) )/) ,/, (Chunk FUNCmaketime/NNP) (/( (Chunk VARh/NNP) ,/, (Chunk VARmin/NNP) ,/, (Chunk VARs/NNP) ,/, (Chunk VARmilli/NNP) )/) )/) )/) ./.)
ID= 20.3.4.2
Summary= Date.prototype.getDate ( )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*if VARt is nan, return nan. 
*0*(S if/IN (Chunk VARt/NNP) is/VBZ nan/JJ ,/, return/VB nan/NNS ./.)
*0*return FUNCdatefromtime(FUNClocaltime(VARt)).     
*0*(S return/NN (Chunk FUNCdatefromtime/NNP) (/( (Chunk FUNClocaltime/NNP) (/( (Chunk VARt/NNP) )/) )/) ./.)
ID= 20.3.4.3
Summary= Date.prototype.getDay ( )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*if VARt is nan, return nan. 
*0*(S if/IN (Chunk VARt/NNP) is/VBZ nan/JJ ,/, return/VB nan/NNS ./.)
*0*return FUNCweekday(FUNClocaltime(VARt)).     
*0*(S return/NN (Chunk FUNCweekday/NNP) (/( (Chunk FUNClocaltime/NNP) (/( (Chunk VARt/NNP) )/) )/) ./.)
ID= 20.3.4.4
Summary= Date.prototype.getFullYear ( )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*if VARt is nan, return nan. 
*0*(S if/IN (Chunk VARt/NNP) is/VBZ nan/JJ ,/, return/VB nan/NNS ./.)
*0*return yearfromtime(FUNClocaltime(VARt)).     
*0*(S return/NN yearfromtime/NN (/( (Chunk FUNClocaltime/NNP) (/( (Chunk VARt/NNP) )/) )/) ./.)
ID= 20.3.4.5
Summary= Date.prototype.getHours ( )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*if VARt is nan, return nan. 
*0*(S if/IN (Chunk VARt/NNP) is/VBZ nan/JJ ,/, return/VB nan/NNS ./.)
*0*return hourfromtime(FUNClocaltime(VARt)).     
*0*(S return/NN hourfromtime/NN (/( (Chunk FUNClocaltime/NNP) (/( (Chunk VARt/NNP) )/) )/) ./.)
ID= 20.3.4.6
Summary= Date.prototype.getMilliseconds ( )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*if VARt is nan, return nan. 
*0*(S if/IN (Chunk VARt/NNP) is/VBZ nan/JJ ,/, return/VB nan/NNS ./.)
*0*return msfromtime(FUNClocaltime(VARt)).     
*0*(S return/NN msfromtime/NN (/( (Chunk FUNClocaltime/NNP) (/( (Chunk VARt/NNP) )/) )/) ./.)
ID= 20.3.4.7
Summary= Date.prototype.getMinutes ( )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*if VARt is nan, return nan. 
*0*(S if/IN (Chunk VARt/NNP) is/VBZ nan/JJ ,/, return/VB nan/NNS ./.)
*0*return minfromtime(FUNClocaltime(VARt)).     
*0*(S return/NN minfromtime/NN (/( (Chunk FUNClocaltime/NNP) (/( (Chunk VARt/NNP) )/) )/) ./.)
ID= 20.3.4.8
Summary= Date.prototype.getMonth ( )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*if VARt is nan, return nan. 
*0*(S if/IN (Chunk VARt/NNP) is/VBZ nan/JJ ,/, return/VB nan/NNS ./.)
*0*return monthfromtime(FUNClocaltime(VARt)).     
*0*(S return/NN monthfromtime/NN (/( (Chunk FUNClocaltime/NNP) (/( (Chunk VARt/NNP) )/) )/) ./.)
ID= 20.3.4.9
Summary= Date.prototype.getSeconds ( )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*if VARt is nan, return nan. 
*0*(S if/IN (Chunk VARt/NNP) is/VBZ nan/JJ ,/, return/VB nan/NNS ./.)
*0*return secfromtime(FUNClocaltime(VARt)).     
*0*(S return/NN secfromtime/NN (/( (Chunk FUNClocaltime/NNP) (/( (Chunk VARt/NNP) )/) )/) ./.)
ID= 20.3.4.10
Summary= Date.prototype.getTime ( )
*0*return ? thistimevalue(this value).     
*0*(S return/NN ?/. thistimevalue/NN (/( this/DT value/NN )/) ./.)
ID= 20.3.4.11
Summary= Date.prototype.getTimezoneOffset ( )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*if VARt is nan, return nan. 
*0*(S if/IN (Chunk VARt/NNP) is/VBZ nan/JJ ,/, return/VB nan/NNS ./.)
*0*return (VARt - FUNClocaltime(VARt)) / msperminute.     
*0*(S return/NN (/( (Chunk VARt/NNP) -/: (Chunk FUNClocaltime/NNP) (/( (Chunk VARt/NNP) )/) )/) //$ msperminute/NN ./.)
ID= 20.3.4.12
Summary= Date.prototype.getUTCDate ( )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*if VARt is nan, return nan. 
*0*(S if/IN (Chunk VARt/NNP) is/VBZ nan/JJ ,/, return/VB nan/NNS ./.)
*0*return FUNCdatefromtime(VARt).     
*0*(S return/NN (Chunk FUNCdatefromtime/NNP) (/( (Chunk VARt/NNP) )/) ./.)
ID= 20.3.4.13
Summary= Date.prototype.getUTCDay ( )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*if VARt is nan, return nan. 
*0*(S if/IN (Chunk VARt/NNP) is/VBZ nan/JJ ,/, return/VB nan/NNS ./.)
*0*return FUNCweekday(VARt).     
*0*(S return/NN (Chunk FUNCweekday/NNP) (/( (Chunk VARt/NNP) )/) ./.)
ID= 20.3.4.14
Summary= Date.prototype.getUTCFullYear ( )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*if VARt is nan, return nan. 
*0*(S if/IN (Chunk VARt/NNP) is/VBZ nan/JJ ,/, return/VB nan/NNS ./.)
*0*return yearfromtime(VARt).     
*0*(S return/NN yearfromtime/NN (/( (Chunk VARt/NNP) )/) ./.)
ID= 20.3.4.15
Summary= Date.prototype.getUTCHours ( )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*if VARt is nan, return nan. 
*0*(S if/IN (Chunk VARt/NNP) is/VBZ nan/JJ ,/, return/VB nan/NNS ./.)
*0*return hourfromtime(VARt).     
*0*(S return/NN hourfromtime/NN (/( (Chunk VARt/NNP) )/) ./.)
ID= 20.3.4.16
Summary= Date.prototype.getUTCMilliseconds ( )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*if VARt is nan, return nan. 
*0*(S if/IN (Chunk VARt/NNP) is/VBZ nan/JJ ,/, return/VB nan/NNS ./.)
*0*return msfromtime(VARt).     
*0*(S return/NN msfromtime/NN (/( (Chunk VARt/NNP) )/) ./.)
ID= 20.3.4.17
Summary= Date.prototype.getUTCMinutes ( )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*if VARt is nan, return nan. 
*0*(S if/IN (Chunk VARt/NNP) is/VBZ nan/JJ ,/, return/VB nan/NNS ./.)
*0*return minfromtime(VARt).     
*0*(S return/NN minfromtime/NN (/( (Chunk VARt/NNP) )/) ./.)
ID= 20.3.4.18
Summary= Date.prototype.getUTCMonth ( )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*if VARt is nan, return nan. 
*0*(S if/IN (Chunk VARt/NNP) is/VBZ nan/JJ ,/, return/VB nan/NNS ./.)
*0*return monthfromtime(VARt).     
*0*(S return/NN monthfromtime/NN (/( (Chunk VARt/NNP) )/) ./.)
ID= 20.3.4.19
Summary= Date.prototype.getUTCSeconds ( )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*if VARt is nan, return nan. 
*0*(S if/IN (Chunk VARt/NNP) is/VBZ nan/JJ ,/, return/VB nan/NNS ./.)
*0*return secfromtime(VARt).     
*0*(S return/NN secfromtime/NN (/( (Chunk VARt/NNP) )/) ./.)
ID= 20.3.4.20
Summary= Date.prototype.setDate ( date )
*0*let VARt be FUNClocaltime(? thistimevalue(this value)). 
*0*(S (Chunk let/VB VARt/NNP) (Chunk be/VB FUNClocaltime/NNP) (/( ?/. thistimevalue/NN (/( this/DT value/NN )/) )/) ./.)
*0*let VARdt be ? FUNCtonumber(VARdate). 
*0*(S (Chunk let/VB VARdt/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARdate/NNP) )/) ./.)
*0*let VARnewdate be FUNCmakedate(FUNCmakeday(yearfromtime(VARt), monthfromtime(VARt), VARdt), timewithinday(VARt)). 
*0*(S (Chunk let/VB VARnewdate/NNP) (Chunk be/VB FUNCmakedate/NNP) (/( (Chunk FUNCmakeday/NNP) (/( yearfromtime/NN (/( (Chunk VARt/NNP) )/) ,/, monthfromtime/FW (/( (Chunk VARt/NNP) )/) ,/, (Chunk VARdt/NNP) )/) ,/, timewithinday/JJ (/( (Chunk VARt/NNP) )/) )/) ./.)
*0*let VARu be FUNCtimeclip(FUNCutc(VARnewdate)). 
*0*(S (Chunk let/VB VARu/NNP) (Chunk be/VB FUNCtimeclip/NNP) (/( (Chunk FUNCutc/NNP) (/( (Chunk VARnewdate/NNP) )/) )/) ./.)
*0*set the [[DATEVALUE]] internal slot of this date object to VARu. 
*0*(S set/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN of/IN this/DT date/NN object/NN to/TO (Chunk VARu/NNP) ./.)
*0*return VARu.     
*0*(S return/NN (Chunk VARu/NNP) ./.)
ID= 20.3.4.21
Summary= Date.prototype.setFullYear ( year [ , month [ , date ] ] )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*if VARt is nan, let VARt be +0; otherwise, let VARt be FUNClocaltime(VARt). 
*0*(S if/IN (Chunk VARt/NNP) is/VBZ nan/JJ ,/, (Chunk let/VB VARt/NNP) be/VB +0/VBN ;/: otherwise/RB ,/, (Chunk let/VB VARt/NNP) (Chunk be/VB FUNClocaltime/NNP) (/( (Chunk VARt/NNP) )/) ./.)
*0*let VARy be ? FUNCtonumber(VARyear). 
*0*(S (Chunk let/VB VARy/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARyear/NNP) )/) ./.)
*0*if VARmonth is not present, let VARm be monthfromtime(VARt); otherwise, let VARm be ? FUNCtonumber(VARmonth). 
*0*(S if/IN (Chunk VARmonth/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARm/NNP) be/VB monthfromtime/JJ (/( (Chunk VARt/NNP) )/) ;/: otherwise/RB ,/, (Chunk let/VB VARm/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARmonth/NNP) )/) ./.)
*0*if VARdate is not present, let VARdt be FUNCdatefromtime(VARt); otherwise, let VARdt be ? FUNCtonumber(VARdate). 
*0*(S if/IN (Chunk VARdate/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARdt/NNP) (Chunk be/VB FUNCdatefromtime/NNP) (/( (Chunk VARt/NNP) )/) ;/: otherwise/RB ,/, (Chunk let/VB VARdt/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARdate/NNP) )/) ./.)
*0*let VARnewdate be FUNCmakedate(FUNCmakeday(VARy, VARm, VARdt), timewithinday(VARt)). 
*0*(S (Chunk let/VB VARnewdate/NNP) (Chunk be/VB FUNCmakedate/NNP) (/( (Chunk FUNCmakeday/NNP) (/( (Chunk VARy/NNP) ,/, (Chunk VARm/NNP) ,/, (Chunk VARdt/NNP) )/) ,/, timewithinday/JJ (/( (Chunk VARt/NNP) )/) )/) ./.)
*0*let VARu be FUNCtimeclip(FUNCutc(VARnewdate)). 
*0*(S (Chunk let/VB VARu/NNP) (Chunk be/VB FUNCtimeclip/NNP) (/( (Chunk FUNCutc/NNP) (/( (Chunk VARnewdate/NNP) )/) )/) ./.)
*0*set the [[DATEVALUE]] internal slot of this date object to VARu. 
*0*(S set/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN of/IN this/DT date/NN object/NN to/TO (Chunk VARu/NNP) ./.)
*0*return VARu.     
*0*(S return/NN (Chunk VARu/NNP) ./.)
ID= 20.3.4.22
Summary= Date.prototype.setHours ( hour [ , min [ , sec [ , ms ] ] ] )
*0*let VARt be FUNClocaltime(? thistimevalue(this value)). 
*0*(S (Chunk let/VB VARt/NNP) (Chunk be/VB FUNClocaltime/NNP) (/( ?/. thistimevalue/NN (/( this/DT value/NN )/) )/) ./.)
*0*let VARh be ? FUNCtonumber(VARhour). 
*0*(S (Chunk let/VB VARh/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARhour/NNP) )/) ./.)
*0*if VARmin is not present, let VARm be minfromtime(VARt); otherwise, let VARm be ? FUNCtonumber(VARmin). 
*0*(S if/IN (Chunk VARmin/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARm/NNP) be/VB minfromtime/JJ (/( (Chunk VARt/NNP) )/) ;/: otherwise/RB ,/, (Chunk let/VB VARm/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARmin/NNP) )/) ./.)
*0*if VARsec is not present, let VARs be secfromtime(VARt); otherwise, let VARs be ? FUNCtonumber(VARsec). 
*0*(S if/IN (Chunk VARsec/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARs/NNP) be/VB secfromtime/JJ (/( (Chunk VARt/NNP) )/) ;/: otherwise/RB ,/, (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARsec/NNP) )/) ./.)
*0*if VARms is not present, let VARmilli be msfromtime(VARt); otherwise, let VARmilli be ? FUNCtonumber(VARms). 
*0*(S if/IN (Chunk VARms/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARmilli/NNP) be/VB msfromtime/JJ (/( (Chunk VARt/NNP) )/) ;/: otherwise/RB ,/, (Chunk let/VB VARmilli/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARms/NNP) )/) ./.)
*0*let VARdate be FUNCmakedate(day(VARt), FUNCmaketime(VARh, VARm, VARs, VARmilli)). 
*0*(S (Chunk let/VB VARdate/NNP) (Chunk be/VB FUNCmakedate/NNP) (/( day/NN (/( (Chunk VARt/NNP) )/) ,/, (Chunk FUNCmaketime/NNP) (/( (Chunk VARh/NNP) ,/, (Chunk VARm/NNP) ,/, (Chunk VARs/NNP) ,/, (Chunk VARmilli/NNP) )/) )/) ./.)
*0*let VARu be FUNCtimeclip(FUNCutc(VARdate)). 
*0*(S (Chunk let/VB VARu/NNP) (Chunk be/VB FUNCtimeclip/NNP) (/( (Chunk FUNCutc/NNP) (/( (Chunk VARdate/NNP) )/) )/) ./.)
*0*set the [[DATEVALUE]] internal slot of this date object to VARu. 
*0*(S set/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN of/IN this/DT date/NN object/NN to/TO (Chunk VARu/NNP) ./.)
*0*return VARu.     
*0*(S return/NN (Chunk VARu/NNP) ./.)
ID= 20.3.4.23
Summary= Date.prototype.setMilliseconds ( ms )
*0*let VARt be FUNClocaltime(? thistimevalue(this value)). 
*0*(S (Chunk let/VB VARt/NNP) (Chunk be/VB FUNClocaltime/NNP) (/( ?/. thistimevalue/NN (/( this/DT value/NN )/) )/) ./.)
*0*let VARms be ? FUNCtonumber(VARms). 
*0*(S (Chunk let/VB VARms/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARms/NNP) )/) ./.)
*0*let VARtime be FUNCmaketime(hourfromtime(VARt), minfromtime(VARt), secfromtime(VARt), VARms). 
*0*(S (Chunk let/VB VARtime/NNP) (Chunk be/VB FUNCmaketime/NNP) (/( hourfromtime/NN (/( (Chunk VARt/NNP) )/) ,/, minfromtime/FW (/( (Chunk VARt/NNP) )/) ,/, secfromtime/RB (/( (Chunk VARt/NNP) )/) ,/, (Chunk VARms/NNP) )/) ./.)
*0*let VARu be FUNCtimeclip(FUNCutc(FUNCmakedate(day(VARt), VARtime))). 
*0*(S (Chunk let/VB VARu/NNP) (Chunk be/VB FUNCtimeclip/NNP) (/( (Chunk FUNCutc/NNP) (/( (Chunk FUNCmakedate/NNP) (/( day/NN (/( (Chunk VARt/NNP) )/) ,/, (Chunk VARtime/NNP) )/) )/) )/) ./.)
*0*set the [[DATEVALUE]] internal slot of this date object to VARu. 
*0*(S set/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN of/IN this/DT date/NN object/NN to/TO (Chunk VARu/NNP) ./.)
*0*return VARu.     
*0*(S return/NN (Chunk VARu/NNP) ./.)
ID= 20.3.4.24
Summary= Date.prototype.setMinutes ( min [ , sec [ , ms ] ] )
*0*let VARt be FUNClocaltime(? thistimevalue(this value)). 
*0*(S (Chunk let/VB VARt/NNP) (Chunk be/VB FUNClocaltime/NNP) (/( ?/. thistimevalue/NN (/( this/DT value/NN )/) )/) ./.)
*0*let VARm be ? FUNCtonumber(VARmin). 
*0*(S (Chunk let/VB VARm/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARmin/NNP) )/) ./.)
*0*if VARsec is not present, let VARs be secfromtime(VARt); otherwise, let VARs be ? FUNCtonumber(VARsec). 
*0*(S if/IN (Chunk VARsec/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARs/NNP) be/VB secfromtime/JJ (/( (Chunk VARt/NNP) )/) ;/: otherwise/RB ,/, (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARsec/NNP) )/) ./.)
*0*if VARms is not present, let VARmilli be msfromtime(VARt); otherwise, let VARmilli be ? FUNCtonumber(VARms). 
*0*(S if/IN (Chunk VARms/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARmilli/NNP) be/VB msfromtime/JJ (/( (Chunk VARt/NNP) )/) ;/: otherwise/RB ,/, (Chunk let/VB VARmilli/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARms/NNP) )/) ./.)
*0*let VARdate be FUNCmakedate(day(VARt), FUNCmaketime(hourfromtime(VARt), VARm, VARs, VARmilli)). 
*0*(S (Chunk let/VB VARdate/NNP) (Chunk be/VB FUNCmakedate/NNP) (/( day/NN (/( (Chunk VARt/NNP) )/) ,/, (Chunk FUNCmaketime/NNP) (/( hourfromtime/NN (/( (Chunk VARt/NNP) )/) ,/, (Chunk VARm/NNP) ,/, (Chunk VARs/NNP) ,/, (Chunk VARmilli/NNP) )/) )/) ./.)
*0*let VARu be FUNCtimeclip(FUNCutc(VARdate)). 
*0*(S (Chunk let/VB VARu/NNP) (Chunk be/VB FUNCtimeclip/NNP) (/( (Chunk FUNCutc/NNP) (/( (Chunk VARdate/NNP) )/) )/) ./.)
*0*set the [[DATEVALUE]] internal slot of this date object to VARu. 
*0*(S set/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN of/IN this/DT date/NN object/NN to/TO (Chunk VARu/NNP) ./.)
*0*return VARu.     
*0*(S return/NN (Chunk VARu/NNP) ./.)
ID= 20.3.4.25
Summary= Date.prototype.setMonth ( month [ , date ] )
*0*let VARt be FUNClocaltime(? thistimevalue(this value)). 
*0*(S (Chunk let/VB VARt/NNP) (Chunk be/VB FUNClocaltime/NNP) (/( ?/. thistimevalue/NN (/( this/DT value/NN )/) )/) ./.)
*0*let VARm be ? FUNCtonumber(VARmonth). 
*0*(S (Chunk let/VB VARm/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARmonth/NNP) )/) ./.)
*0*if VARdate is not present, let VARdt be FUNCdatefromtime(VARt); otherwise, let VARdt be ? FUNCtonumber(VARdate). 
*0*(S if/IN (Chunk VARdate/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARdt/NNP) (Chunk be/VB FUNCdatefromtime/NNP) (/( (Chunk VARt/NNP) )/) ;/: otherwise/RB ,/, (Chunk let/VB VARdt/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARdate/NNP) )/) ./.)
*0*let VARnewdate be FUNCmakedate(FUNCmakeday(yearfromtime(VARt), VARm, VARdt), timewithinday(VARt)). 
*0*(S (Chunk let/VB VARnewdate/NNP) (Chunk be/VB FUNCmakedate/NNP) (/( (Chunk FUNCmakeday/NNP) (/( yearfromtime/NN (/( (Chunk VARt/NNP) )/) ,/, (Chunk VARm/NNP) ,/, (Chunk VARdt/NNP) )/) ,/, timewithinday/JJ (/( (Chunk VARt/NNP) )/) )/) ./.)
*0*let VARu be FUNCtimeclip(FUNCutc(VARnewdate)). 
*0*(S (Chunk let/VB VARu/NNP) (Chunk be/VB FUNCtimeclip/NNP) (/( (Chunk FUNCutc/NNP) (/( (Chunk VARnewdate/NNP) )/) )/) ./.)
*0*set the [[DATEVALUE]] internal slot of this date object to VARu. 
*0*(S set/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN of/IN this/DT date/NN object/NN to/TO (Chunk VARu/NNP) ./.)
*0*return VARu.     
*0*(S return/NN (Chunk VARu/NNP) ./.)
ID= 20.3.4.26
Summary= Date.prototype.setSeconds ( sec [ , ms ] )
*0*let VARt be FUNClocaltime(? thistimevalue(this value)). 
*0*(S (Chunk let/VB VARt/NNP) (Chunk be/VB FUNClocaltime/NNP) (/( ?/. thistimevalue/NN (/( this/DT value/NN )/) )/) ./.)
*0*let VARs be ? FUNCtonumber(VARsec). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARsec/NNP) )/) ./.)
*0*if VARms is not present, let VARmilli be msfromtime(VARt); otherwise, let VARmilli be ? FUNCtonumber(VARms). 
*0*(S if/IN (Chunk VARms/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARmilli/NNP) be/VB msfromtime/JJ (/( (Chunk VARt/NNP) )/) ;/: otherwise/RB ,/, (Chunk let/VB VARmilli/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARms/NNP) )/) ./.)
*0*let VARdate be FUNCmakedate(day(VARt), FUNCmaketime(hourfromtime(VARt), minfromtime(VARt), VARs, VARmilli)). 
*0*(S (Chunk let/VB VARdate/NNP) (Chunk be/VB FUNCmakedate/NNP) (/( day/NN (/( (Chunk VARt/NNP) )/) ,/, (Chunk FUNCmaketime/NNP) (/( hourfromtime/NN (/( (Chunk VARt/NNP) )/) ,/, minfromtime/FW (/( (Chunk VARt/NNP) )/) ,/, (Chunk VARs/NNP) ,/, (Chunk VARmilli/NNP) )/) )/) ./.)
*0*let VARu be FUNCtimeclip(FUNCutc(VARdate)). 
*0*(S (Chunk let/VB VARu/NNP) (Chunk be/VB FUNCtimeclip/NNP) (/( (Chunk FUNCutc/NNP) (/( (Chunk VARdate/NNP) )/) )/) ./.)
*0*set the [[DATEVALUE]] internal slot of this date object to VARu. 
*0*(S set/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN of/IN this/DT date/NN object/NN to/TO (Chunk VARu/NNP) ./.)
*0*return VARu.     
*0*(S return/NN (Chunk VARu/NNP) ./.)
ID= 20.3.4.27
Summary= Date.prototype.setTime ( time )
*0*perform ? thistimevalue(this value). 
*0*(S perform/NN ?/. thistimevalue/NN (/( this/DT value/NN )/) ./.)
*0*let VARt be ? FUNCtonumber(VARtime). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARtime/NNP) )/) ./.)
*0*let VARv be FUNCtimeclip(VARt). 
*0*(S (Chunk let/VB VARv/NNP) (Chunk be/VB FUNCtimeclip/NNP) (/( (Chunk VARt/NNP) )/) ./.)
*0*set the [[DATEVALUE]] internal slot of this date object to VARv. 
*0*(S set/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN of/IN this/DT date/NN object/NN to/TO (Chunk VARv/NNP) ./.)
*0*return VARv.     
*0*(S return/NN (Chunk VARv/NNP) ./.)
ID= 20.3.4.28
Summary= Date.prototype.setUTCDate ( date )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*let VARdt be ? FUNCtonumber(VARdate). 
*0*(S (Chunk let/VB VARdt/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARdate/NNP) )/) ./.)
*0*let VARnewdate be FUNCmakedate(FUNCmakeday(yearfromtime(VARt), monthfromtime(VARt), VARdt), timewithinday(VARt)). 
*0*(S (Chunk let/VB VARnewdate/NNP) (Chunk be/VB FUNCmakedate/NNP) (/( (Chunk FUNCmakeday/NNP) (/( yearfromtime/NN (/( (Chunk VARt/NNP) )/) ,/, monthfromtime/FW (/( (Chunk VARt/NNP) )/) ,/, (Chunk VARdt/NNP) )/) ,/, timewithinday/JJ (/( (Chunk VARt/NNP) )/) )/) ./.)
*0*let VARv be FUNCtimeclip(VARnewdate). 
*0*(S (Chunk let/VB VARv/NNP) (Chunk be/VB FUNCtimeclip/NNP) (/( (Chunk VARnewdate/NNP) )/) ./.)
*0*set the [[DATEVALUE]] internal slot of this date object to VARv. 
*0*(S set/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN of/IN this/DT date/NN object/NN to/TO (Chunk VARv/NNP) ./.)
*0*return VARv.     
*0*(S return/NN (Chunk VARv/NNP) ./.)
ID= 20.3.4.29
Summary= Date.prototype.setUTCFullYear ( year [ , month [ , date ] ] )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*if VARt is nan, let VARt be +0. 
*0*(S if/IN (Chunk VARt/NNP) is/VBZ nan/JJ ,/, (Chunk let/VB VARt/NNP) be/VB +0/VBN ./.)
*0*let VARy be ? FUNCtonumber(VARyear). 
*0*(S (Chunk let/VB VARy/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARyear/NNP) )/) ./.)
*0*if VARmonth is not present, let VARm be monthfromtime(VARt); otherwise, let VARm be ? FUNCtonumber(VARmonth). 
*0*(S if/IN (Chunk VARmonth/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARm/NNP) be/VB monthfromtime/JJ (/( (Chunk VARt/NNP) )/) ;/: otherwise/RB ,/, (Chunk let/VB VARm/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARmonth/NNP) )/) ./.)
*0*if VARdate is not present, let VARdt be FUNCdatefromtime(VARt); otherwise, let VARdt be ? FUNCtonumber(VARdate). 
*0*(S if/IN (Chunk VARdate/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARdt/NNP) (Chunk be/VB FUNCdatefromtime/NNP) (/( (Chunk VARt/NNP) )/) ;/: otherwise/RB ,/, (Chunk let/VB VARdt/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARdate/NNP) )/) ./.)
*0*let VARnewdate be FUNCmakedate(FUNCmakeday(VARy, VARm, VARdt), timewithinday(VARt)). 
*0*(S (Chunk let/VB VARnewdate/NNP) (Chunk be/VB FUNCmakedate/NNP) (/( (Chunk FUNCmakeday/NNP) (/( (Chunk VARy/NNP) ,/, (Chunk VARm/NNP) ,/, (Chunk VARdt/NNP) )/) ,/, timewithinday/JJ (/( (Chunk VARt/NNP) )/) )/) ./.)
*0*let VARv be FUNCtimeclip(VARnewdate). 
*0*(S (Chunk let/VB VARv/NNP) (Chunk be/VB FUNCtimeclip/NNP) (/( (Chunk VARnewdate/NNP) )/) ./.)
*0*set the [[DATEVALUE]] internal slot of this date object to VARv. 
*0*(S set/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN of/IN this/DT date/NN object/NN to/TO (Chunk VARv/NNP) ./.)
*0*return VARv.     
*0*(S return/NN (Chunk VARv/NNP) ./.)
ID= 20.3.4.30
Summary= Date.prototype.setUTCHours ( hour [ , min [ , sec [ , ms ] ] ] )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*let VARh be ? FUNCtonumber(VARhour). 
*0*(S (Chunk let/VB VARh/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARhour/NNP) )/) ./.)
*0*if VARmin is not present, let VARm be minfromtime(VARt); otherwise, let VARm be ? FUNCtonumber(VARmin). 
*0*(S if/IN (Chunk VARmin/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARm/NNP) be/VB minfromtime/JJ (/( (Chunk VARt/NNP) )/) ;/: otherwise/RB ,/, (Chunk let/VB VARm/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARmin/NNP) )/) ./.)
*0*if VARsec is not present, let VARs be secfromtime(VARt); otherwise, let VARs be ? FUNCtonumber(VARsec). 
*0*(S if/IN (Chunk VARsec/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARs/NNP) be/VB secfromtime/JJ (/( (Chunk VARt/NNP) )/) ;/: otherwise/RB ,/, (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARsec/NNP) )/) ./.)
*0*if VARms is not present, let VARmilli be msfromtime(VARt); otherwise, let VARmilli be ? FUNCtonumber(VARms). 
*0*(S if/IN (Chunk VARms/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARmilli/NNP) be/VB msfromtime/JJ (/( (Chunk VARt/NNP) )/) ;/: otherwise/RB ,/, (Chunk let/VB VARmilli/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARms/NNP) )/) ./.)
*0*let VARnewdate be FUNCmakedate(day(VARt), FUNCmaketime(VARh, VARm, VARs, VARmilli)). 
*0*(S (Chunk let/VB VARnewdate/NNP) (Chunk be/VB FUNCmakedate/NNP) (/( day/NN (/( (Chunk VARt/NNP) )/) ,/, (Chunk FUNCmaketime/NNP) (/( (Chunk VARh/NNP) ,/, (Chunk VARm/NNP) ,/, (Chunk VARs/NNP) ,/, (Chunk VARmilli/NNP) )/) )/) ./.)
*0*let VARv be FUNCtimeclip(VARnewdate). 
*0*(S (Chunk let/VB VARv/NNP) (Chunk be/VB FUNCtimeclip/NNP) (/( (Chunk VARnewdate/NNP) )/) ./.)
*0*set the [[DATEVALUE]] internal slot of this date object to VARv. 
*0*(S set/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN of/IN this/DT date/NN object/NN to/TO (Chunk VARv/NNP) ./.)
*0*return VARv.     
*0*(S return/NN (Chunk VARv/NNP) ./.)
ID= 20.3.4.31
Summary= Date.prototype.setUTCMilliseconds ( ms )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*let VARmilli be ? FUNCtonumber(VARms). 
*0*(S (Chunk let/VB VARmilli/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARms/NNP) )/) ./.)
*0*let VARtime be FUNCmaketime(hourfromtime(VARt), minfromtime(VARt), secfromtime(VARt), VARmilli). 
*0*(S (Chunk let/VB VARtime/NNP) (Chunk be/VB FUNCmaketime/NNP) (/( hourfromtime/NN (/( (Chunk VARt/NNP) )/) ,/, minfromtime/FW (/( (Chunk VARt/NNP) )/) ,/, secfromtime/RB (/( (Chunk VARt/NNP) )/) ,/, (Chunk VARmilli/NNP) )/) ./.)
*0*let VARv be FUNCtimeclip(FUNCmakedate(day(VARt), VARtime)). 
*0*(S (Chunk let/VB VARv/NNP) (Chunk be/VB FUNCtimeclip/NNP) (/( (Chunk FUNCmakedate/NNP) (/( day/NN (/( (Chunk VARt/NNP) )/) ,/, (Chunk VARtime/NNP) )/) )/) ./.)
*0*set the [[DATEVALUE]] internal slot of this date object to VARv. 
*0*(S set/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN of/IN this/DT date/NN object/NN to/TO (Chunk VARv/NNP) ./.)
*0*return VARv.     
*0*(S return/NN (Chunk VARv/NNP) ./.)
ID= 20.3.4.32
Summary= Date.prototype.setUTCMinutes ( min [ , sec [ , ms ] ] )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*let VARm be ? FUNCtonumber(VARmin). 
*0*(S (Chunk let/VB VARm/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARmin/NNP) )/) ./.)
*0*if VARsec is not present, let VARs be secfromtime(VARt). 
*0*(S if/IN (Chunk VARsec/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARs/NNP) be/VB secfromtime/JJ (/( (Chunk VARt/NNP) )/) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARs be ? FUNCtonumber(VARsec). 
*1*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARsec/NNP) )/) ./.)
*0*if VARms is not present, let VARmilli be msfromtime(VARt). 
*0*(S if/IN (Chunk VARms/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARmilli/NNP) be/VB msfromtime/JJ (/( (Chunk VARt/NNP) )/) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARmilli be ? FUNCtonumber(VARms). 
*1*(S (Chunk let/VB VARmilli/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARms/NNP) )/) ./.)
*0*let VARdate be FUNCmakedate(day(VARt), FUNCmaketime(hourfromtime(VARt), VARm, VARs, VARmilli)). 
*0*(S (Chunk let/VB VARdate/NNP) (Chunk be/VB FUNCmakedate/NNP) (/( day/NN (/( (Chunk VARt/NNP) )/) ,/, (Chunk FUNCmaketime/NNP) (/( hourfromtime/NN (/( (Chunk VARt/NNP) )/) ,/, (Chunk VARm/NNP) ,/, (Chunk VARs/NNP) ,/, (Chunk VARmilli/NNP) )/) )/) ./.)
*0*let VARv be FUNCtimeclip(VARdate). 
*0*(S (Chunk let/VB VARv/NNP) (Chunk be/VB FUNCtimeclip/NNP) (/( (Chunk VARdate/NNP) )/) ./.)
*0*set the [[DATEVALUE]] internal slot of this date object to VARv. 
*0*(S set/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN of/IN this/DT date/NN object/NN to/TO (Chunk VARv/NNP) ./.)
*0*return VARv.     
*0*(S return/NN (Chunk VARv/NNP) ./.)
ID= 20.3.4.33
Summary= Date.prototype.setUTCMonth ( month [ , date ] )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*let VARm be ? FUNCtonumber(VARmonth). 
*0*(S (Chunk let/VB VARm/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARmonth/NNP) )/) ./.)
*0*if VARdate is not present, let VARdt be FUNCdatefromtime(VARt). 
*0*(S if/IN (Chunk VARdate/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARdt/NNP) (Chunk be/VB FUNCdatefromtime/NNP) (/( (Chunk VARt/NNP) )/) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARdt be ? FUNCtonumber(VARdate). 
*1*(S (Chunk let/VB VARdt/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARdate/NNP) )/) ./.)
*0*let VARnewdate be FUNCmakedate(FUNCmakeday(yearfromtime(VARt), VARm, VARdt), timewithinday(VARt)). 
*0*(S (Chunk let/VB VARnewdate/NNP) (Chunk be/VB FUNCmakedate/NNP) (/( (Chunk FUNCmakeday/NNP) (/( yearfromtime/NN (/( (Chunk VARt/NNP) )/) ,/, (Chunk VARm/NNP) ,/, (Chunk VARdt/NNP) )/) ,/, timewithinday/JJ (/( (Chunk VARt/NNP) )/) )/) ./.)
*0*let VARv be FUNCtimeclip(VARnewdate). 
*0*(S (Chunk let/VB VARv/NNP) (Chunk be/VB FUNCtimeclip/NNP) (/( (Chunk VARnewdate/NNP) )/) ./.)
*0*set the [[DATEVALUE]] internal slot of this date object to VARv. 
*0*(S set/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN of/IN this/DT date/NN object/NN to/TO (Chunk VARv/NNP) ./.)
*0*return VARv.     
*0*(S return/NN (Chunk VARv/NNP) ./.)
ID= 20.3.4.34
Summary= Date.prototype.setUTCSeconds ( sec [ , ms ] )
*0*let VARt be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARt/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*let VARs be ? FUNCtonumber(VARsec). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARsec/NNP) )/) ./.)
*0*if VARms is not present, let VARmilli be msfromtime(VARt). 
*0*(S if/IN (Chunk VARms/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARmilli/NNP) be/VB msfromtime/JJ (/( (Chunk VARt/NNP) )/) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARmilli be ? FUNCtonumber(VARms). 
*1*(S (Chunk let/VB VARmilli/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARms/NNP) )/) ./.)
*0*let VARdate be FUNCmakedate(day(VARt), FUNCmaketime(hourfromtime(VARt), minfromtime(VARt), VARs, VARmilli)). 
*0*(S (Chunk let/VB VARdate/NNP) (Chunk be/VB FUNCmakedate/NNP) (/( day/NN (/( (Chunk VARt/NNP) )/) ,/, (Chunk FUNCmaketime/NNP) (/( hourfromtime/NN (/( (Chunk VARt/NNP) )/) ,/, minfromtime/FW (/( (Chunk VARt/NNP) )/) ,/, (Chunk VARs/NNP) ,/, (Chunk VARmilli/NNP) )/) )/) ./.)
*0*let VARv be FUNCtimeclip(VARdate). 
*0*(S (Chunk let/VB VARv/NNP) (Chunk be/VB FUNCtimeclip/NNP) (/( (Chunk VARdate/NNP) )/) ./.)
*0*set the [[DATEVALUE]] internal slot of this date object to VARv. 
*0*(S set/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk DATEVALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN of/IN this/DT date/NN object/NN to/TO (Chunk VARv/NNP) ./.)
*0*return VARv.     
*0*(S return/NN (Chunk VARv/NNP) ./.)
ID= 20.3.4.35
Summary= Date.prototype.toDateString ( )
*0*let VARo be this date object. 
*0*(S (Chunk let/VB VARo/NNP) be/VB this/DT date/NN object/NN ./.)
*0*let VARtv be ? thistimevalue(VARo). 
*0*(S (Chunk let/VB VARtv/NNP) be/VB ?/. thistimevalue/JJ (/( (Chunk VARo/NNP) )/) ./.)
*0*if VARtv is nan, return "invalid date". 
*0*(S if/IN (Chunk VARtv/NNP) is/VBZ nan/JJ ,/, return/VB ``/`` invalid/JJ date/NN ''/'' ./.)
*0*let VARt be FUNClocaltime(VARtv). 
*0*(S (Chunk let/VB VARt/NNP) (Chunk be/VB FUNClocaltime/NNP) (/( (Chunk VARtv/NNP) )/) ./.)
*0*return FUNCdatestring(VARt).     
*0*(S return/NN (Chunk FUNCdatestring/NNP) (/( (Chunk VARt/NNP) )/) ./.)
ID= 20.3.4.37
Summary= Date.prototype.toJSON ( key )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARtv be ? FUNCtoprimitive(VARo, hint number). 
*0*(S (Chunk let/VB VARtv/NNP) be/VB ?/. (Chunk FUNCtoprimitive/NNP) (/( (Chunk VARo/NNP) ,/, hint/NN number/NN )/) ./.)
*0*if FUNCtype(VARtv) is number and VARtv is not finite, return null. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtv/NNP) )/) is/VBZ number/NN and/CC (Chunk VARtv/NNP) is/VBZ not/RB finite/JJ ,/, return/JJ null/NN ./.)
*0*return ? FUNCinvoke(VARo, "toisostring").     
*0*(S return/NN ?/. (Chunk FUNCinvoke/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` toisostring/VBG ''/'' )/) ./.)
ID= 20.3.4.41
Summary= Date.prototype.toString ( )
*0*let VARtv be ? thistimevalue(this value). 
*0*(S (Chunk let/VB VARtv/NNP) be/VB ?/. thistimevalue/JJ (/( this/DT value/NN )/) ./.)
*0*return FUNCtodatestring(VARtv).     
*0*(S return/NN (Chunk FUNCtodatestring/NNP) (/( (Chunk VARtv/NNP) )/) ./.)
ID= 20.3.4.41.1
Summary= Runtime Semantics: TimeString ( tv )
*0*assert: FUNCtype(VARtv) is number. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARtv/NNP) )/) is/VBZ number/NN ./.)
*0*assert: VARtv is not nan. 
*0*(S assert/NN :/: (Chunk VARtv/NNP) is/VBZ not/RB nan/JJ ./.)
*0*let VARhour be the string representation of hourfromtime(VARtv), formatted as a two-digit decimal number, padded to the left with a zero if necessary. 
*0*(S (Chunk let/VB VARhour/NNP) be/VB the/DT string/JJ representation/NN of/IN hourfromtime/NN (/( (Chunk VARtv/NNP) )/) ,/, formatted/VBN as/IN a/DT two-digit/JJ decimal/JJ number/NN ,/, padded/VBD to/TO the/DT left/NN with/IN a/DT zero/NN if/IN necessary/JJ ./.)
*0*let VARminute be the string representation of minfromtime(VARtv), formatted as a two-digit decimal number, padded to the left with a zero if necessary. 
*0*(S (Chunk let/VB VARminute/NNP) be/VB the/DT string/JJ representation/NN of/IN minfromtime/NN (/( (Chunk VARtv/NNP) )/) ,/, formatted/VBN as/IN a/DT two-digit/JJ decimal/JJ number/NN ,/, padded/VBD to/TO the/DT left/NN with/IN a/DT zero/NN if/IN necessary/JJ ./.)
*0*let VARsecond be the string representation of secfromtime(VARtv), formatted as a two-digit decimal number, padded to the left with a zero if necessary. 
*0*(S (Chunk let/VB VARsecond/NNP) be/VB the/DT string/JJ representation/NN of/IN secfromtime/NN (/( (Chunk VARtv/NNP) )/) ,/, formatted/VBN as/IN a/DT two-digit/JJ decimal/JJ number/NN ,/, padded/VBD to/TO the/DT left/NN with/IN a/DT zero/NN if/IN necessary/JJ ./.)
*0*return the string-concatenation of VARhour, ":", VARminute, ":", VARsecond, the code unit 0x0020 (space), and "gmt".      
*0*(S return/VB the/DT string-concatenation/NN of/IN (Chunk VARhour/NNP) ,/, ``/`` :/: ''/'' ,/, (Chunk VARminute/NNP) ,/, ``/`` :/: ''/'' ,/, (Chunk VARsecond/NNP) ,/, the/DT code/NN unit/NN 0x0020/CD (/( space/NN )/) ,/, and/CC ``/`` gmt/NN ''/'' ./.)
ID= 20.3.4.41.2
Summary= Runtime Semantics: DateString ( tv )
*0*assert: FUNCtype(VARtv) is number. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARtv/NNP) )/) is/VBZ number/NN ./.)
*0*assert: VARtv is not nan. 
*0*(S assert/NN :/: (Chunk VARtv/NNP) is/VBZ not/RB nan/JJ ./.)
*0*let VARweekday be the name of the entry in FUNCtable 46 with the number weekday(VARtv). 
*0*(S (Chunk let/VB VARweekday/NNP) be/VB the/DT name/NN of/IN the/DT entry/NN in/IN FUNCtable/JJ 46/CD with/IN the/DT number/NN weekday/NN (/( (Chunk VARtv/NNP) )/) ./.)
*0*let VARmonth be the name of the entry in FUNCtable 47 with the number monthfromtime(VARtv). 
*0*(S (Chunk let/VB VARmonth/NNP) be/VB the/DT name/NN of/IN the/DT entry/NN in/IN FUNCtable/JJ 47/CD with/IN the/DT number/NN monthfromtime/NN (/( (Chunk VARtv/NNP) )/) ./.)
*0*let VARday be the string representation of FUNCdatefromtime(VARtv), formatted as a two-digit decimal number, padded to the left with a zero if necessary. 
*0*(S (Chunk let/VB VARday/NNP) be/VB the/DT string/JJ representation/NN of/IN (Chunk FUNCdatefromtime/NNP) (/( (Chunk VARtv/NNP) )/) ,/, formatted/VBN as/IN a/DT two-digit/JJ decimal/JJ number/NN ,/, padded/VBD to/TO the/DT left/NN with/IN a/DT zero/NN if/IN necessary/JJ ./.)
*0*let VARyear be the string representation of yearfromtime(VARtv), formatted as a decimal number of at least four digits, padded to the left with zeroes if necessary. 
*0*(S (Chunk let/VB VARyear/NNP) be/VB the/DT string/JJ representation/NN of/IN yearfromtime/NN (/( (Chunk VARtv/NNP) )/) ,/, formatted/VBN as/IN a/DT decimal/JJ number/NN of/IN at/IN least/JJS four/CD digits/NNS ,/, padded/VBD to/TO the/DT left/NN with/IN zeroes/NNS if/IN necessary/JJ ./.)
*0*return the string-concatenation of VARweekday, the code unit 0x0020 (space), VARmonth, the code unit 0x0020 (space), VARday, the code unit 0x0020 (space), and VARyear.      
*0*(S return/VB the/DT string-concatenation/NN of/IN (Chunk VARweekday/NNP) ,/, the/DT code/NN unit/NN 0x0020/CD (/( space/NN )/) ,/, (Chunk VARmonth/NNP) ,/, the/DT code/NN unit/NN 0x0020/CD (/( space/NN )/) ,/, (Chunk VARday/NNP) ,/, the/DT code/NN unit/NN 0x0020/CD (/( space/NN )/) ,/, and/CC (Chunk VARyear/NNP) ./.)
ID= 20.3.4.41.3
Summary= Runtime Semantics: TimeZoneString ( tv )
*0*assert: FUNCtype(VARtv) is number. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARtv/NNP) )/) is/VBZ number/NN ./.)
*0*assert: VARtv is not nan. 
*0*(S assert/NN :/: (Chunk VARtv/NNP) is/VBZ not/RB nan/JJ ./.)
*0*let VARoffset be FUNClocaltza(VARtv, true). 
*0*(S (Chunk let/VB VARoffset/NNP) (Chunk be/VB FUNClocaltza/NNP) (/( (Chunk VARtv/NNP) ,/, true/JJ )/) ./.)
*0*if VARoffset ≥ 0, let VARoffsetsign be "+"; otherwise, let VARoffsetsign be "-". 
*0*(S if/IN (Chunk VARoffset/NNP) ≥/VBD 0/CD ,/, (Chunk let/VB VARoffsetsign/NNP) be/VB ``/`` +/JJ ''/'' ;/: otherwise/RB ,/, (Chunk let/VB VARoffsetsign/NNP) be/VB ``/`` -/: ''/'' ./.)
*0*let VARoffsetmin be the string representation of minfromtime(abs(VARoffset)), formatted as a two-digit decimal number, padded to the left with a zero if necessary. 
*0*(S (Chunk let/VB VARoffsetmin/NNP) be/VB the/DT string/JJ representation/NN of/IN minfromtime/NN (/( abs/JJ (/( (Chunk VARoffset/NNP) )/) )/) ,/, formatted/VBN as/IN a/DT two-digit/JJ decimal/JJ number/NN ,/, padded/VBD to/TO the/DT left/NN with/IN a/DT zero/NN if/IN necessary/JJ ./.)
*0*let VARoffsethour be the string representation of hourfromtime(abs(VARoffset)), formatted as a two-digit decimal number, padded to the left with a zero if necessary. 
*0*(S (Chunk let/VB VARoffsethour/NNP) be/VB the/DT string/JJ representation/NN of/IN hourfromtime/NN (/( abs/JJ (/( (Chunk VARoffset/NNP) )/) )/) ,/, formatted/VBN as/IN a/DT two-digit/JJ decimal/JJ number/NN ,/, padded/VBD to/TO the/DT left/NN with/IN a/DT zero/NN if/IN necessary/JJ ./.)
*0*let VARtzname be an implementation-defined string that is either the empty string or the string-concatenation of the code unit 0x0020 (space), the code unit 0x0028 (left parenthesis), an implementation-dependent timezone name, and the code unit 0x0029 (right parenthesis). 
*0*(S (Chunk let/VB VARtzname/NNP) be/VB an/DT implementation-defined/JJ string/NN that/WDT is/VBZ either/CC the/DT empty/JJ string/NN or/CC the/DT string-concatenation/NN of/IN the/DT code/NN unit/NN 0x0020/CD (/( space/NN )/) ,/, the/DT code/NN unit/NN 0x0028/CD (/( left/JJ parenthesis/NN )/) ,/, an/DT implementation-dependent/JJ timezone/NN name/NN ,/, and/CC the/DT code/NN unit/NN 0x0029/CD (/( right/JJ parenthesis/NN )/) ./.)
*0*return the string-concatenation of VARoffsetsign, VARoffsethour, VARoffsetmin, and VARtzname.      
*0*(S return/VB the/DT string-concatenation/NN of/IN (Chunk VARoffsetsign/NNP) ,/, (Chunk VARoffsethour/NNP) ,/, (Chunk VARoffsetmin/NNP) ,/, and/CC (Chunk VARtzname/NNP) ./.)
ID= 20.3.4.41.4
Summary= Runtime Semantics: ToDateString ( tv )
*0*assert: FUNCtype(VARtv) is number. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARtv/NNP) )/) is/VBZ number/NN ./.)
*0*if VARtv is nan, return "invalid date". 
*0*(S if/IN (Chunk VARtv/NNP) is/VBZ nan/JJ ,/, return/VB ``/`` invalid/JJ date/NN ''/'' ./.)
*0*let VARt be FUNClocaltime(VARtv). 
*0*(S (Chunk let/VB VARt/NNP) (Chunk be/VB FUNClocaltime/NNP) (/( (Chunk VARtv/NNP) )/) ./.)
*0*return the FUNCstring-concatenation of datestring(VARt), the code unit 0x0020 (space), FUNCtimestring(VARt), and FUNCtimezonestring(VARtv).      
*0*(S return/VB the/DT (Chunk FUNCstring-concatenation/NNP) of/IN datestring/VBG (/( (Chunk VARt/NNP) )/) ,/, the/DT code/NN unit/NN 0x0020/CD (/( space/NN )/) ,/, (Chunk FUNCtimestring/NNP) (/( (Chunk VARt/NNP) )/) ,/, and/CC (Chunk FUNCtimezonestring/NNP) (/( (Chunk VARtv/NNP) )/) ./.)
ID= 20.3.4.42
Summary= Date.prototype.toTimeString ( )
*0*let VARo be this date object. 
*0*(S (Chunk let/VB VARo/NNP) be/VB this/DT date/NN object/NN ./.)
*0*let VARtv be ? thistimevalue(VARo). 
*0*(S (Chunk let/VB VARtv/NNP) be/VB ?/. thistimevalue/JJ (/( (Chunk VARo/NNP) )/) ./.)
*0*if VARtv is nan, return "invalid date". 
*0*(S if/IN (Chunk VARtv/NNP) is/VBZ nan/JJ ,/, return/VB ``/`` invalid/JJ date/NN ''/'' ./.)
*0*let VARt be FUNClocaltime(VARtv). 
*0*(S (Chunk let/VB VARt/NNP) (Chunk be/VB FUNClocaltime/NNP) (/( (Chunk VARtv/NNP) )/) ./.)
*0*return the FUNCstring-concatenation of timestring(VARt) and FUNCtimezonestring(VARtv).     
*0*(S return/VB the/DT (Chunk FUNCstring-concatenation/NNP) of/IN timestring/VBG (/( (Chunk VARt/NNP) )/) and/CC (Chunk FUNCtimezonestring/NNP) (/( (Chunk VARtv/NNP) )/) ./.)
ID= 20.3.4.43
Summary= Date.prototype.toUTCString ( )
*0*let VARo be this date object. 
*0*(S (Chunk let/VB VARo/NNP) be/VB this/DT date/NN object/NN ./.)
*0*let VARtv be ? thistimevalue(VARo). 
*0*(S (Chunk let/VB VARtv/NNP) be/VB ?/. thistimevalue/JJ (/( (Chunk VARo/NNP) )/) ./.)
*0*if VARtv is nan, return "invalid date". 
*0*(S if/IN (Chunk VARtv/NNP) is/VBZ nan/JJ ,/, return/VB ``/`` invalid/JJ date/NN ''/'' ./.)
*0*let VARweekday be the name of the entry in FUNCtable 46 with the number weekday(VARtv). 
*0*(S (Chunk let/VB VARweekday/NNP) be/VB the/DT name/NN of/IN the/DT entry/NN in/IN FUNCtable/JJ 46/CD with/IN the/DT number/NN weekday/NN (/( (Chunk VARtv/NNP) )/) ./.)
*0*let VARmonth be the name of the entry in FUNCtable 47 with the number monthfromtime(VARtv). 
*0*(S (Chunk let/VB VARmonth/NNP) be/VB the/DT name/NN of/IN the/DT entry/NN in/IN FUNCtable/JJ 47/CD with/IN the/DT number/NN monthfromtime/NN (/( (Chunk VARtv/NNP) )/) ./.)
*0*let VARday be the string representation of FUNCdatefromtime(VARtv), formatted as a two-digit decimal number, padded to the left with a zero if necessary. 
*0*(S (Chunk let/VB VARday/NNP) be/VB the/DT string/JJ representation/NN of/IN (Chunk FUNCdatefromtime/NNP) (/( (Chunk VARtv/NNP) )/) ,/, formatted/VBN as/IN a/DT two-digit/JJ decimal/JJ number/NN ,/, padded/VBD to/TO the/DT left/NN with/IN a/DT zero/NN if/IN necessary/JJ ./.)
*0*let VARyear be the string representation of yearfromtime(VARtv), formatted as a decimal number of at least four digits, padded to the left with zeroes if necessary. 
*0*(S (Chunk let/VB VARyear/NNP) be/VB the/DT string/JJ representation/NN of/IN yearfromtime/NN (/( (Chunk VARtv/NNP) )/) ,/, formatted/VBN as/IN a/DT decimal/JJ number/NN of/IN at/IN least/JJS four/CD digits/NNS ,/, padded/VBD to/TO the/DT left/NN with/IN zeroes/NNS if/IN necessary/JJ ./.)
*0*return the FUNCstring-concatenation of VARweekday, ",", the code unit 0x0020 (space), VARday, the code unit 0x0020 (space), VARmonth, the code unit 0x0020 (space), VARyear, the code unit 0x0020 (space), and timestring(VARtv).     
*0*(S return/VB the/DT (Chunk FUNCstring-concatenation/NNP) of/IN (Chunk VARweekday/NNP) ,/, ``/`` ,/, ''/'' ,/, the/DT code/NN unit/NN 0x0020/CD (/( space/NN )/) ,/, (Chunk VARday/NNP) ,/, the/DT code/NN unit/NN 0x0020/CD (/( space/NN )/) ,/, (Chunk VARmonth/NNP) ,/, the/DT code/NN unit/NN 0x0020/CD (/( space/NN )/) ,/, (Chunk VARyear/NNP) ,/, the/DT code/NN unit/NN 0x0020/CD (/( space/NN )/) ,/, and/CC timestring/VBG (/( (Chunk VARtv/NNP) )/) ./.)
ID= 20.3.4.44
Summary= Date.prototype.valueOf ( )
*0*return ? thistimevalue(this value).     
*0*(S return/NN ?/. thistimevalue/NN (/( this/DT value/NN )/) ./.)
ID= 20.3.4.45
Summary= Date.prototype [ @@toPrimitive ] ( hint )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARhint is the string value "string" or the string value "default", then
*0*(S if/IN (Chunk VARhint/NNP) is/VBZ the/DT string/VBG value/NN ``/`` string/NN ''/'' or/CC the/DT string/NN value/NN ``/`` default/NN ''/'' ,/, then/RB)
*1*let VARtryfirst be "string". 
*1*(S (Chunk let/VB VARtryfirst/NNP) be/VB ``/`` string/VBG ''/'' ./.)
*0*else if VARhint is the string value "number", then
*0*(S else/RB if/IN (Chunk VARhint/NNP) is/VBZ the/DT string/VBG value/NN ``/`` number/NN ''/'' ,/, then/RB)
*1*let VARtryfirst be "number". 
*1*(S (Chunk let/VB VARtryfirst/NNP) be/VB ``/`` number/NN ''/'' ./.)
*0*else, throw a typeerror exception. 
*0*(S else/RB ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return ? FUNCordinarytoprimitive(VARo, VARtryfirst).     
*0*(S return/NN ?/. (Chunk FUNCordinarytoprimitive/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARtryfirst/NNP) )/) ./.)
ID= 21.1.1.1
Summary= String ( value )
*0*if no arguments were passed to this function invocation, let VARs be "". 
*0*(S if/IN no/DT arguments/NNS were/VBD passed/VBN to/TO this/DT function/NN invocation/NN ,/, (Chunk let/VB VARs/NNP) be/VB ``/`` ''/'' ./.)
*0*else,
*0*(S else/RB ,/,)
*1*if newtarget is undefined and FUNCtype(VARvalue) is symbol, return FUNCsymboldescriptivestring(VARvalue). 
*1*(S if/IN newtarget/DT is/VBZ undefined/JJ and/CC (Chunk FUNCtype/NNP) (/( (Chunk VARvalue/NNP) )/) is/VBZ symbol/JJ ,/, (Chunk return/VB FUNCsymboldescriptivestring/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*1*let VARs be ? FUNCtostring(VARvalue). 
*1*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*0*if newtarget is undefined, return VARs. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, return/JJ (Chunk VARs/NNP) ./.)
*0*return ? FUNCstringcreate(VARs, ? FUNCgetprototypefromconstructor(newtarget, "%stringprototype%")).     
*0*(S return/NN ?/. (Chunk FUNCstringcreate/NNP) (/( (Chunk VARs/NNP) ,/, ?/. (Chunk FUNCgetprototypefromconstructor/NNP) (/( newtarget/NN ,/, ``/`` %/NN stringprototype/JJ %/NN ''/'' )/) )/) ./.)
ID= 21.1.2.1
Summary= String.fromCharCode ( ...codeUnits )
*0*let VARcodeunits be a list containing the arguments passed to this function. 
*0*(S (Chunk let/VB VARcodeunits/NNP) be/VB a/DT list/NN containing/VBG the/DT arguments/NNS passed/VBN to/TO this/DT function/NN ./.)
*0*let VARlength be the number of elements in VARcodeunits. 
*0*(S (Chunk let/VB VARlength/NNP) be/VB the/DT number/NN of/IN elements/NNS in/IN (Chunk VARcodeunits/NNP) ./.)
*0*let VARelements be a new empty list. 
*0*(S let/VB VARelements/NNS be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARnextindex be 0. 
*0*(S (Chunk let/VB VARnextindex/NNP) be/VB 0/CD ./.)
*0*repeat, while VARnextindex &lt; VARlength
*0*(S repeat/NN ,/, while/IN (Chunk VARnextindex/NNP) &/CC lt/NN ;/: (Chunk VARlength/NNP))
*1*let VARnext be VARcodeunits[VARnextindex]. 
*1*(S (Chunk let/VB VARnext/NNP) (Chunk be/VB VARcodeunits/NNP) (Chunk [/NNP) (Chunk VARnextindex/NNP) (Chunk ]/NNP) ./.)
*1*let VARnextcu be ? FUNCtouint16(VARnext). 
*1*(S (Chunk let/VB VARnextcu/NNP) be/VB ?/. (Chunk FUNCtouint16/NNP) (/( (Chunk VARnext/NNP) )/) ./.)
*1*append VARnextcu to the end of VARelements. 
*1*(S append/NN (Chunk VARnextcu/NNP) to/TO the/DT end/NN of/IN VARelements/NNS ./.)
*1*let VARnextindex be VARnextindex + 1. 
*1*(S (Chunk let/VB VARnextindex/NNP) (Chunk be/VB VARnextindex/NNP) (Chunk +/NNP) 1/CD ./.)
*0*return the string value whose elements are, in order, the elements in the list VARelements. if VARlength is 0, the empty string is returned.     
*0*(S return/VB the/DT string/NN value/NN whose/WP$ elements/NNS are/VBP ,/, in/IN order/NN ,/, the/DT elements/NNS in/IN the/DT list/NN (Chunk VARelements/NNP) ./. if/IN (Chunk VARlength/NNP) is/VBZ 0/CD ,/, the/DT empty/JJ string/NN is/VBZ returned/VBN ./.)
ID= 21.1.2.2
Summary= String.fromCodePoint ( ...codePoints )
*0*let VARcodepoints be a list containing the arguments passed to this function. 
*0*(S let/VB VARcodepoints/NNS be/VB a/DT list/NN containing/VBG the/DT arguments/NNS passed/VBN to/TO this/DT function/NN ./.)
*0*let VARlength be the number of elements in VARcodepoints. 
*0*(S (Chunk let/VB VARlength/NNP) be/VB the/DT number/NN of/IN elements/NNS in/IN VARcodepoints/NNS ./.)
*0*let VARelements be a new empty list. 
*0*(S let/VB VARelements/NNS be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARnextindex be 0. 
*0*(S (Chunk let/VB VARnextindex/NNP) be/VB 0/CD ./.)
*0*repeat, while VARnextindex &lt; VARlength
*0*(S repeat/NN ,/, while/IN (Chunk VARnextindex/NNP) &/CC lt/NN ;/: (Chunk VARlength/NNP))
*1*let VARnext be VARcodepoints[VARnextindex]. 
*1*(S (Chunk let/VB VARnext/NNP) (Chunk be/VB VARcodepoints/NNP) (Chunk [/NNP) (Chunk VARnextindex/NNP) (Chunk ]/NNP) ./.)
*1*let VARnextcp be ? FUNCtonumber(VARnext). 
*1*(S (Chunk let/VB VARnextcp/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARnext/NNP) )/) ./.)
*1*if FUNCsamevalue(VARnextcp, FUNCtointeger(VARnextcp)) is false, throw a rangeerror exception. 
*1*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARnextcp/NNP) ,/, (Chunk FUNCtointeger/NNP) (/( (Chunk VARnextcp/NNP) )/) )/) is/VBZ false/JJ ,/, throw/VB a/DT rangeerror/NN exception/NN ./.)
*1*if VARnextcp &lt; 0 or VARnextcp &gt; 0x10ffff, throw a rangeerror exception. 
*1*(S if/IN (Chunk VARnextcp/NNP) &/CC lt/NN ;/: 0/CD or/CC (Chunk VARnextcp/NNP) &/CC gt/NN ;/: 0x10ffff/CD ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*1*append the elements of the utf16encoding of VARnextcp to the end of VARelements. 
*1*(S append/VB the/DT elements/NNS of/IN the/DT utf16encoding/NN of/IN (Chunk VARnextcp/NNP) to/TO the/DT end/NN of/IN VARelements/NNS ./.)
*1*let VARnextindex be VARnextindex + 1. 
*1*(S (Chunk let/VB VARnextindex/NNP) (Chunk be/VB VARnextindex/NNP) (Chunk +/NNP) 1/CD ./.)
*0*return the string value whose elements are, in order, the elements in the list VARelements. if VARlength is 0, the empty string is returned.     
*0*(S return/VB the/DT string/NN value/NN whose/WP$ elements/NNS are/VBP ,/, in/IN order/NN ,/, the/DT elements/NNS in/IN the/DT list/NN (Chunk VARelements/NNP) ./. if/IN (Chunk VARlength/NNP) is/VBZ 0/CD ,/, the/DT empty/JJ string/NN is/VBZ returned/VBN ./.)
ID= 21.1.2.4
Summary= String.raw ( template, ...substitutions )
*0*let VARsubstitutions be a list consisting of all of the arguments passed to this function, starting with the second argument. if fewer than two arguments were passed, the list is empty. 
*0*(S (Chunk let/VB VARsubstitutions/NNP) be/VB a/DT list/NN consisting/NN of/IN all/DT of/IN the/DT arguments/NNS passed/VBN to/TO this/DT function/NN ,/, starting/VBG with/IN the/DT second/JJ argument/NN ./. if/IN fewer/JJR than/IN two/CD arguments/NNS were/VBD passed/VBN ,/, the/DT list/NN is/VBZ empty/JJ ./.)
*0*let VARnumberofsubstitutions be the number of elements in VARsubstitutions. 
*0*(S (Chunk let/VB VARnumberofsubstitutions/NNP) be/VB the/DT number/NN of/IN elements/NNS in/IN (Chunk VARsubstitutions/NNP) ./.)
*0*let VARcooked be ? FUNCtoobject(VARtemplate). 
*0*(S (Chunk let/VB VARcooked/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARtemplate/NNP) )/) ./.)
*0*let VARraw be ? FUNCtoobject(? FUNCget(VARcooked, "raw")). 
*0*(S (Chunk let/VB VARraw/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARcooked/NNP) ,/, ``/`` raw/JJ ''/'' )/) )/) ./.)
*0*let VARliteralsegments be ? FUNCtolength(? FUNCget(VARraw, "length")). 
*0*(S let/VB VARliteralsegments/NNS be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARraw/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*if VARliteralsegments ≤ 0, return the empty string. 
*0*(S if/IN VARliteralsegments/NNS ≤/VBP 0/CD ,/, return/VBP the/DT empty/JJ string/NN ./.)
*0*let VARstringelements be a new empty list. 
*0*(S let/VB VARstringelements/NNS be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARnextindex be 0. 
*0*(S (Chunk let/VB VARnextindex/NNP) be/VB 0/CD ./.)
*0*repeat,
*0*(S repeat/NN ,/,)
*1*let VARnextkey be ! FUNCtostring(VARnextindex). 
*1*(S (Chunk let/VB VARnextkey/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARnextindex/NNP) )/) ./.)
*1*let VARnextseg be ? FUNCtostring(? FUNCget(VARraw, VARnextkey)). 
*1*(S (Chunk let/VB VARnextseg/NNP) be/VB ?/. FUNCtostring/VBG (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARraw/NNP) ,/, (Chunk VARnextkey/NNP) )/) )/) ./.)
*1*append in order the code unit elements of VARnextseg to the end of VARstringelements. 
*1*(S append/NN in/IN order/NN the/DT code/NN unit/NN elements/NNS of/IN (Chunk VARnextseg/NNP) to/TO the/DT end/NN of/IN VARstringelements/NNS ./.)
*1*if VARnextindex + 1 = VARliteralsegments, then
*1*(S if/IN (Chunk VARnextindex/NNP) +/VBD 1/CD =/JJ VARliteralsegments/NNS ,/, then/RB)
*2*return the string value whose code units are, in order, the elements in the list VARstringelements. if VARstringelements has no elements, the empty string is returned. 
*2*(S return/VB the/DT string/NN value/NN whose/WP$ code/NN units/NNS are/VBP ,/, in/IN order/NN ,/, the/DT elements/NNS in/IN the/DT list/NN (Chunk VARstringelements/NNP) ./. if/IN (Chunk VARstringelements/NNP) has/VBZ no/DT elements/NNS ,/, the/DT empty/JJ string/NN is/VBZ returned/VBN ./.)
*1*if VARnextindex &lt; VARnumberofsubstitutions, let VARnext be VARsubstitutions[VARnextindex]. 
*1*(S if/IN (Chunk VARnextindex/NNP) &/CC lt/NN ;/: (Chunk VARnumberofsubstitutions/NNP) ,/, (Chunk let/VB VARnext/NNP) (Chunk be/VB VARsubstitutions/NNP) (Chunk [/NNP) (Chunk VARnextindex/NNP) (Chunk ]/NNP) ./.)
*1*else, let VARnext be the empty string. 
*1*(S else/RB ,/, (Chunk let/VB VARnext/NNP) be/VB the/DT empty/JJ string/NN ./.)
*1*let VARnextsub be ? FUNCtostring(VARnext). 
*1*(S (Chunk let/VB VARnextsub/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARnext/NNP) )/) ./.)
*1*append in order the code unit elements of VARnextsub to the end of VARstringelements. 
*1*(S append/NN in/IN order/NN the/DT code/NN unit/NN elements/NNS of/IN (Chunk VARnextsub/NNP) to/TO the/DT end/NN of/IN VARstringelements/NNS ./.)
*1*let VARnextindex be VARnextindex + 1.     
*1*(S (Chunk let/VB VARnextindex/NNP) (Chunk be/VB VARnextindex/NNP) (Chunk +/NNP) 1/CD ./.)
ID= 21.1.3.1
Summary= String.prototype.charAt ( pos )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARposition be ? FUNCtointeger(VARpos). 
*0*(S (Chunk let/VB VARposition/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARpos/NNP) )/) ./.)
*0*let VARsize be the length of VARs. 
*0*(S (Chunk let/VB VARsize/NNP) be/VB the/DT length/NN of/IN (Chunk VARs/NNP) ./.)
*0*if VARposition &lt; 0 or VARposition ≥ VARsize, return the empty string. 
*0*(S if/IN (Chunk VARposition/NNP) &/CC lt/NN ;/: 0/CD or/CC (Chunk VARposition/NNP) (Chunk ≥/NNP) (Chunk VARsize/NNP) ,/, return/VBP the/DT empty/JJ string/NN ./.)
*0*return the string value of length 1, containing one code unit from VARs, namely the code unit at index VARposition.     
*0*(S return/VB the/DT string/VBG value/NN of/IN length/NN 1/CD ,/, containing/VBG one/CD code/NN unit/NN from/IN (Chunk VARs/NNP) ,/, namely/RB the/DT code/NN unit/NN at/IN index/NN (Chunk VARposition/NNP) ./.)
ID= 21.1.3.2
Summary= String.prototype.charCodeAt ( pos )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARposition be ? FUNCtointeger(VARpos). 
*0*(S (Chunk let/VB VARposition/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARpos/NNP) )/) ./.)
*0*let VARsize be the length of VARs. 
*0*(S (Chunk let/VB VARsize/NNP) be/VB the/DT length/NN of/IN (Chunk VARs/NNP) ./.)
*0*if VARposition &lt; 0 or VARposition ≥ VARsize, return nan. 
*0*(S if/IN (Chunk VARposition/NNP) &/CC lt/NN ;/: 0/CD or/CC (Chunk VARposition/NNP) (Chunk ≥/NNP) (Chunk VARsize/NNP) ,/, return/NN nan/NN ./.)
*0*return a value of number type, whose value is the numeric value of the code unit at index VARposition within the string VARs.     
*0*(S return/VB a/DT value/NN of/IN number/NN type/NN ,/, whose/WP$ value/NN is/VBZ the/DT numeric/JJ value/NN of/IN the/DT code/NN unit/NN at/IN index/NN (Chunk VARposition/NNP) within/IN the/DT string/NN (Chunk VARs/NNP) ./.)
ID= 21.1.3.3
Summary= String.prototype.codePointAt ( pos )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARposition be ? FUNCtointeger(VARpos). 
*0*(S (Chunk let/VB VARposition/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARpos/NNP) )/) ./.)
*0*let VARsize be the length of VARs. 
*0*(S (Chunk let/VB VARsize/NNP) be/VB the/DT length/NN of/IN (Chunk VARs/NNP) ./.)
*0*if VARposition &lt; 0 or VARposition ≥ VARsize, return undefined. 
*0*(S if/IN (Chunk VARposition/NNP) &/CC lt/NN ;/: 0/CD or/CC (Chunk VARposition/NNP) (Chunk ≥/NNP) (Chunk VARsize/NNP) ,/, return/NN undefined/VBD ./.)
*0*let VARfirst be the numeric value of the code unit at index VARposition within the string VARs. 
*0*(S (Chunk let/VB VARfirst/NNP) be/VB the/DT numeric/JJ value/NN of/IN the/DT code/NN unit/NN at/IN index/NN (Chunk VARposition/NNP) within/IN the/DT string/NN (Chunk VARs/NNP) ./.)
*0*if VARfirst &lt; 0xd800 or VARfirst &gt; 0xdbff or VARposition+1 = VARsize, return VARfirst. 
*0*(S if/IN (Chunk VARfirst/NNP) &/CC lt/NN ;/: 0xd800/CD or/CC (Chunk VARfirst/NNP) &/CC gt/NN ;/: 0xdbff/CD or/CC (Chunk VARposition+1/NNP) (Chunk =/NNP) (Chunk VARsize/NNP) ,/, return/NN (Chunk VARfirst/NNP) ./.)
*0*let VARsecond be the numeric value of the code unit at index VARposition+1 within the string VARs. 
*0*(S (Chunk let/VB VARsecond/NNP) be/VB the/DT numeric/JJ value/NN of/IN the/DT code/NN unit/NN at/IN index/NN (Chunk VARposition+1/NNP) within/IN the/DT string/NN (Chunk VARs/NNP) ./.)
*0*if VARsecond &lt; 0xdc00 or VARsecond &gt; 0xdfff, return VARfirst. 
*0*(S if/IN (Chunk VARsecond/NNP) &/CC lt/NN ;/: 0xdc00/CD or/CC (Chunk VARsecond/NNP) &/CC gt/NN ;/: 0xdfff/CD ,/, return/NN (Chunk VARfirst/NNP) ./.)
*0*return FUNCutf16decode(VARfirst, VARsecond).     
*0*(S return/NN (Chunk FUNCutf16decode/NNP) (/( (Chunk VARfirst/NNP) ,/, (Chunk VARsecond/NNP) )/) ./.)
ID= 21.1.3.4
Summary= String.prototype.concat ( ...args )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARargs be a list whose elements are the arguments passed to this function. 
*0*(S (Chunk let/VB VARargs/NNP) be/VB a/DT list/NN whose/WP$ elements/NNS are/VBP the/DT arguments/NNS passed/VBN to/TO this/DT function/NN ./.)
*0*let VARr be VARs. 
*0*(S (Chunk let/VB VARr/NNP) (Chunk be/VB VARs/NNP) ./.)
*0*repeat, while VARargs is not empty
*0*(S repeat/NN ,/, while/IN (Chunk VARargs/NNP) is/VBZ not/RB empty/JJ)
*1*remove the first element from VARargs and let VARnext be the value of that element. 
*1*(S remove/VB the/DT first/JJ element/NN from/IN (Chunk VARargs/NNP) and/CC (Chunk let/VB VARnext/NNP) be/VB the/DT value/NN of/IN that/DT element/NN ./.)
*1*let VARnextstring be ? FUNCtostring(VARnext). 
*1*(S let/VB VARnextstring/VBG be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARnext/NNP) )/) ./.)
*1*set VARr to the string-concatenation of the previous value of VARr and VARnextstring. 
*1*(S (Chunk set/VBN VARr/NNP) to/TO the/DT string-concatenation/NN of/IN the/DT previous/JJ value/NN of/IN (Chunk VARr/NNP) and/CC (Chunk VARnextstring/NNP) ./.)
*0*return VARr.     
*0*(S return/NN (Chunk VARr/NNP) ./.)
ID= 21.1.3.6
Summary= String.prototype.endsWith ( searchString [ , endPosition ] )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARisregexp be ? FUNCisregexp(VARsearchstring). 
*0*(S (Chunk let/VB VARisregexp/NNP) be/VB ?/. (Chunk FUNCisregexp/NNP) (/( VARsearchstring/VBG )/) ./.)
*0*if VARisregexp is true, throw a typeerror exception. 
*0*(S if/IN (Chunk VARisregexp/NNP) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARsearchstr be ? FUNCtostring(VARsearchstring). 
*0*(S (Chunk let/VB VARsearchstr/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( VARsearchstring/VBG )/) ./.)
*0*let VARlen be the length of VARs. 
*0*(S (Chunk let/VB VARlen/NNP) be/VB the/DT length/NN of/IN (Chunk VARs/NNP) ./.)
*0*if VARendposition is undefined, let VARpos be VARlen, else let VARpos be ? FUNCtointeger(VARendposition). 
*0*(S if/IN (Chunk VARendposition/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARpos/NNP) (Chunk be/VB VARlen/NNP) ,/, (Chunk else/RB let/VB VARpos/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARendposition/NNP) )/) ./.)
*0*let VARend be min(max(VARpos, 0), VARlen). 
*0*(S (Chunk let/VB VARend/NNP) be/VB min/VBN (/( max/NN (/( (Chunk VARpos/NNP) ,/, 0/CD )/) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*let VARsearchlength be the length of VARsearchstr. 
*0*(S (Chunk let/VB VARsearchlength/NNP) be/VB the/DT length/NN of/IN (Chunk VARsearchstr/NNP) ./.)
*0*let VARstart be VARend - VARsearchlength. 
*0*(S (Chunk let/VB VARstart/NNP) (Chunk be/VB VARend/NNP) -/: VARsearchlength/NN ./.)
*0*if VARstart is less than 0, return false. 
*0*(S if/IN (Chunk VARstart/NNP) is/VBZ less/JJR than/IN 0/CD ,/, return/NN false/JJ ./.)
*0*if the sequence of elements of VARs starting at VARstart of length VARsearchlength is the same as the full element sequence of VARsearchstr, return true. 
*0*(S if/IN the/DT sequence/NN of/IN elements/NNS of/IN (Chunk VARs/NNP) starting/VBG at/IN (Chunk VARstart/NNP) of/IN length/NN (Chunk VARsearchlength/NNP) is/VBZ the/DT same/JJ as/IN the/DT full/JJ element/NN sequence/NN of/IN (Chunk VARsearchstr/NNP) ,/, return/NN true/JJ ./.)
*0*otherwise, return false.     
*0*(S otherwise/RB ,/, return/NN false/JJ ./.)
ID= 21.1.3.7
Summary= String.prototype.includes ( searchString [ , position ] )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARisregexp be ? FUNCisregexp(VARsearchstring). 
*0*(S (Chunk let/VB VARisregexp/NNP) be/VB ?/. (Chunk FUNCisregexp/NNP) (/( VARsearchstring/VBG )/) ./.)
*0*if VARisregexp is true, throw a typeerror exception. 
*0*(S if/IN (Chunk VARisregexp/NNP) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARsearchstr be ? FUNCtostring(VARsearchstring). 
*0*(S (Chunk let/VB VARsearchstr/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( VARsearchstring/VBG )/) ./.)
*0*let VARpos be ? FUNCtointeger(VARposition). (if VARposition is undefined, this step produces the value 0.) 
*0*(S (Chunk let/VB VARpos/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARposition/NNP) )/) ./. (/( if/IN (Chunk VARposition/NNP) is/VBZ undefined/JJ ,/, this/DT step/NN produces/VBZ the/DT value/NN (Chunk 0/NNP) ./. )/))
*0*let VARlen be the length of VARs. 
*0*(S (Chunk let/VB VARlen/NNP) be/VB the/DT length/NN of/IN (Chunk VARs/NNP) ./.)
*0*let VARstart be min(max(VARpos, 0), VARlen). 
*0*(S (Chunk let/VB VARstart/NNP) be/VB min/VBN (/( max/NN (/( (Chunk VARpos/NNP) ,/, 0/CD )/) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*let VARsearchlen be the length of VARsearchstr. 
*0*(S (Chunk let/VB VARsearchlen/NNP) be/VB the/DT length/NN of/IN (Chunk VARsearchstr/NNP) ./.)
*0*if there exists any integer VARk not smaller than VARstart such that VARk + VARsearchlen is not greater than VARlen, and for all nonnegative integers VARj less than VARsearchlen, the code unit at index VARk+VARj within VARs is the same as the code unit at index VARj within VARsearchstr, return true; but if there is no such integer VARk, return false.     
*0*(S if/IN there/EX exists/VBZ any/DT integer/NN (Chunk VARk/NNP) not/RB smaller/JJR than/IN (Chunk VARstart/NNP) such/JJ that/IN (Chunk VARk/NNP) (Chunk +/NNP) (Chunk VARsearchlen/NNP) is/VBZ not/RB greater/JJR than/IN (Chunk VARlen/NNP) ,/, and/CC for/IN all/DT nonnegative/JJ integers/NNS (Chunk VARj/NNP) less/JJR than/IN (Chunk VARsearchlen/NNP) ,/, the/DT code/NN unit/NN at/IN index/NN (Chunk VARk+VARj/NNP) within/IN (Chunk VARs/NNP) is/VBZ the/DT same/JJ as/IN the/DT code/NN unit/NN at/IN index/NN (Chunk VARj/NNP) within/IN (Chunk VARsearchstr/NNP) ,/, return/NN true/JJ ;/: but/CC if/IN there/EX is/VBZ no/DT such/JJ integer/NN (Chunk VARk/NNP) ,/, return/NN false/JJ ./.)
ID= 21.1.3.8
Summary= String.prototype.indexOf ( searchString [ , position ] )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARsearchstr be ? FUNCtostring(VARsearchstring). 
*0*(S (Chunk let/VB VARsearchstr/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( VARsearchstring/VBG )/) ./.)
*0*let VARpos be ? FUNCtointeger(VARposition). (if VARposition is undefined, this step produces the value 0.) 
*0*(S (Chunk let/VB VARpos/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARposition/NNP) )/) ./. (/( if/IN (Chunk VARposition/NNP) is/VBZ undefined/JJ ,/, this/DT step/NN produces/VBZ the/DT value/NN (Chunk 0/NNP) ./. )/))
*0*let VARlen be the length of VARs. 
*0*(S (Chunk let/VB VARlen/NNP) be/VB the/DT length/NN of/IN (Chunk VARs/NNP) ./.)
*0*let VARstart be min(max(VARpos, 0), VARlen). 
*0*(S (Chunk let/VB VARstart/NNP) be/VB min/VBN (/( max/NN (/( (Chunk VARpos/NNP) ,/, 0/CD )/) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*let VARsearchlen be the length of VARsearchstr. 
*0*(S (Chunk let/VB VARsearchlen/NNP) be/VB the/DT length/NN of/IN (Chunk VARsearchstr/NNP) ./.)
*0*return the smallest possible integer VARk not smaller than VARstart such that VARk+VARsearchlen is not greater than VARlen, and for all nonnegative integers VARj less than VARsearchlen, the code unit at index VARk+VARj within VARs is the same as the code unit at index VARj within VARsearchstr; but if there is no such integer VARk, return the value -1.     
*0*(S return/VB the/DT smallest/JJS possible/JJ integer/NN (Chunk VARk/NNP) not/RB smaller/JJR than/IN (Chunk VARstart/NNP) such/JJ that/IN (Chunk VARk+VARsearchlen/NNP) is/VBZ not/RB greater/JJR than/IN (Chunk VARlen/NNP) ,/, and/CC for/IN all/DT nonnegative/JJ integers/NNS (Chunk VARj/NNP) less/JJR than/IN (Chunk VARsearchlen/NNP) ,/, the/DT code/NN unit/NN at/IN index/NN (Chunk VARk+VARj/NNP) within/IN (Chunk VARs/NNP) is/VBZ the/DT same/JJ as/IN the/DT code/NN unit/NN at/IN index/NN (Chunk VARj/NNP) within/IN (Chunk VARsearchstr/NNP) ;/: but/CC if/IN there/EX is/VBZ no/DT such/JJ integer/NN (Chunk VARk/NNP) ,/, return/VBP the/DT value/NN (Chunk -1/NNP) ./.)
ID= 21.1.3.9
Summary= String.prototype.lastIndexOf ( searchString [ , position ] )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARsearchstr be ? FUNCtostring(VARsearchstring). 
*0*(S (Chunk let/VB VARsearchstr/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( VARsearchstring/VBG )/) ./.)
*0*let VARnumpos be ? FUNCtonumber(VARposition). (if VARposition is undefined, this step produces the value nan.) 
*0*(S (Chunk let/VB VARnumpos/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARposition/NNP) )/) ./. (/( if/IN (Chunk VARposition/NNP) is/VBZ undefined/JJ ,/, this/DT step/NN produces/VBZ the/DT value/NN nan/RB ./. )/))
*0*if VARnumpos is nan, let VARpos be +∞; otherwise, let VARpos be FUNCtointeger(VARnumpos). 
*0*(S if/IN (Chunk VARnumpos/NNP) is/VBZ nan/JJ ,/, (Chunk let/VB VARpos/NNP) be/VB +∞/VBN ;/: otherwise/RB ,/, (Chunk let/VB VARpos/NNP) (Chunk be/VB FUNCtointeger/NNP) (/( (Chunk VARnumpos/NNP) )/) ./.)
*0*let VARlen be the length of VARs. 
*0*(S (Chunk let/VB VARlen/NNP) be/VB the/DT length/NN of/IN (Chunk VARs/NNP) ./.)
*0*let VARstart be min(max(VARpos, 0), VARlen). 
*0*(S (Chunk let/VB VARstart/NNP) be/VB min/VBN (/( max/NN (/( (Chunk VARpos/NNP) ,/, 0/CD )/) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*let VARsearchlen be the length of VARsearchstr. 
*0*(S (Chunk let/VB VARsearchlen/NNP) be/VB the/DT length/NN of/IN (Chunk VARsearchstr/NNP) ./.)
*0*return the largest possible nonnegative integer VARk not larger than VARstart such that VARk+VARsearchlen is not greater than VARlen, and for all nonnegative integers VARj less than VARsearchlen, the code unit at index VARk+VARj within VARs is the same as the code unit at index VARj within VARsearchstr; but if there is no such integer VARk, return the value -1.     
*0*(S return/VB the/DT largest/JJS possible/JJ nonnegative/JJ integer/NN (Chunk VARk/NNP) not/RB larger/JJR than/IN (Chunk VARstart/NNP) such/JJ that/IN (Chunk VARk+VARsearchlen/NNP) is/VBZ not/RB greater/JJR than/IN (Chunk VARlen/NNP) ,/, and/CC for/IN all/DT nonnegative/JJ integers/NNS (Chunk VARj/NNP) less/JJR than/IN (Chunk VARsearchlen/NNP) ,/, the/DT code/NN unit/NN at/IN index/NN (Chunk VARk+VARj/NNP) within/IN (Chunk VARs/NNP) is/VBZ the/DT same/JJ as/IN the/DT code/NN unit/NN at/IN index/NN (Chunk VARj/NNP) within/IN (Chunk VARsearchstr/NNP) ;/: but/CC if/IN there/EX is/VBZ no/DT such/JJ integer/NN (Chunk VARk/NNP) ,/, return/VBP the/DT value/NN (Chunk -1/NNP) ./.)
ID= 21.1.3.10
Summary= String.prototype.localeCompare ( that [ , reserved1 [ , reserved2 ] ] )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARthat be ? FUNCtostring(VARthat).     
*0*(S (Chunk let/VB VARthat/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARthat/NNP) )/) ./.)
ID= 21.1.3.11
Summary= String.prototype.match ( regexp )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*if VARregexp is neither undefined nor null, then
*0*(S if/IN (Chunk VARregexp/NNP) is/VBZ neither/DT undefined/JJ nor/CC null/JJ ,/, then/RB)
*1*let VARmatcher be ? FUNCgetmethod(VARregexp, @@match). 
*1*(S (Chunk let/VB VARmatcher/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARregexp/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) match/NN )/) ./.)
*1*if VARmatcher is not undefined, then
*1*(S if/IN (Chunk VARmatcher/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*2*return ? FUNCcall(VARmatcher, VARregexp, « VARo »). 
*2*(S return/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARmatcher/NNP) ,/, (Chunk VARregexp/NNP) ,/, (Chunk «/NNP) (Chunk VARo/NNP) (Chunk »/NNP) )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARrx be ? FUNCregexpcreate(VARregexp, undefined). 
*0*(S (Chunk let/VB VARrx/NNP) be/VB ?/. (Chunk FUNCregexpcreate/NNP) (/( (Chunk VARregexp/NNP) ,/, undefined/VBD )/) ./.)
*0*return ? FUNCinvoke(VARrx, @@match, « VARs »).     
*0*(S return/NN ?/. (Chunk FUNCinvoke/NNP) (/( (Chunk VARrx/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) match/NN ,/, (Chunk «/NNP) (Chunk VARs/NNP) (Chunk »/NNP) )/) ./.)
ID= 21.1.3.12
Summary= String.prototype.normalize ( [ form ] )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*if VARform is not present or VARform is undefined, let VARform be "nfc". 
*0*(S if/IN (Chunk VARform/NNP) is/VBZ not/RB present/JJ or/CC (Chunk VARform/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARform/NNP) be/VB ``/`` nfc/JJ ''/'' ./.)
*0*let VARf be ? FUNCtostring(VARform). 
*0*(S (Chunk let/VB VARf/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARform/NNP) )/) ./.)
*0*if VARf is not one of "nfc", "nfd", "nfkc", or "nfkd", throw a rangeerror exception. 
*0*(S if/IN (Chunk VARf/NNP) is/VBZ not/RB one/CD of/IN ``/`` nfc/JJ ''/'' ,/, ``/`` nfd/NN ''/'' ,/, ``/`` nfkc/NN ''/'' ,/, or/CC ``/`` nfkd/JJ ''/'' ,/, throw/VB a/DT rangeerror/NN exception/NN ./.)
*0*let VARns be the string value that is the result of normalizing VARs into the normalization form named by VARf as specified in https://unicode.org/reports/tr15/. 
*0*(S (Chunk let/VB VARns/NNP) be/VB the/DT string/VBG value/NN that/WDT is/VBZ the/DT result/NN of/IN (Chunk normalizing/VBG VARs/NNP) into/IN the/DT normalization/NN form/NN named/VBN by/IN (Chunk VARf/NNP) as/IN specified/VBN in/IN https/NN :/: //unicode.org/reports/tr15//NN ./.)
*0*return VARns.     
*0*(S return/NN (Chunk VARns/NNP) ./.)
ID= 21.1.3.13
Summary= String.prototype.padEnd ( maxLength [ , fillString ] )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARintmaxlength be ? FUNCtolength(VARmaxlength). 
*0*(S (Chunk let/VB VARintmaxlength/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( (Chunk VARmaxlength/NNP) )/) ./.)
*0*let VARstringlength be the length of VARs. 
*0*(S (Chunk let/VB VARstringlength/NNP) be/VB the/DT length/NN of/IN (Chunk VARs/NNP) ./.)
*0*if VARintmaxlength is not greater than VARstringlength, return VARs. 
*0*(S if/IN (Chunk VARintmaxlength/NNP) is/VBZ not/RB greater/JJR than/IN (Chunk VARstringlength/NNP) ,/, return/NN (Chunk VARs/NNP) ./.)
*0*if VARfillstring is undefined, let VARfiller be the string value consisting solely of the code unit 0x0020 (space). 
*0*(S if/IN (Chunk VARfillstring/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARfiller/NNP) be/VB the/DT string/VBG value/NN consisting/VBG solely/RB of/IN the/DT code/NN unit/NN 0x0020/CD (/( space/NN )/) ./.)
*0*else, let VARfiller be ? FUNCtostring(VARfillstring). 
*0*(S else/RB ,/, (Chunk let/VB VARfiller/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( VARfillstring/VBG )/) ./.)
*0*if VARfiller is the empty string, return VARs. 
*0*(S if/IN (Chunk VARfiller/NNP) is/VBZ the/DT empty/JJ string/NN ,/, return/NN (Chunk VARs/NNP) ./.)
*0*let VARfilllen be VARintmaxlength - VARstringlength. 
*0*(S (Chunk let/VB VARfilllen/NNP) (Chunk be/VB VARintmaxlength/NNP) -/: VARstringlength/NN ./.)
*0*let VARtruncatedstringfiller be the string value consisting of repeated concatenations of VARfiller truncated to length VARfilllen. 
*0*(S (Chunk let/VB VARtruncatedstringfiller/NNP) be/VB the/DT string/VBG value/NN consisting/VBG of/IN repeated/JJ concatenations/NNS of/IN (Chunk VARfiller/NNP) truncated/VBD to/TO (Chunk length/VB VARfilllen/NNP) ./.)
*0*return the string-concatenation of VARs and VARtruncatedstringfiller.     
*0*(S return/VB the/DT string-concatenation/NN of/IN (Chunk VARs/NNP) and/CC (Chunk VARtruncatedstringfiller/NNP) ./.)
ID= 21.1.3.14
Summary= String.prototype.padStart ( maxLength [ , fillString ] )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARintmaxlength be ? FUNCtolength(VARmaxlength). 
*0*(S (Chunk let/VB VARintmaxlength/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( (Chunk VARmaxlength/NNP) )/) ./.)
*0*let VARstringlength be the length of VARs. 
*0*(S (Chunk let/VB VARstringlength/NNP) be/VB the/DT length/NN of/IN (Chunk VARs/NNP) ./.)
*0*if VARintmaxlength is not greater than VARstringlength, return VARs. 
*0*(S if/IN (Chunk VARintmaxlength/NNP) is/VBZ not/RB greater/JJR than/IN (Chunk VARstringlength/NNP) ,/, return/NN (Chunk VARs/NNP) ./.)
*0*if VARfillstring is undefined, let VARfiller be the string value consisting solely of the code unit 0x0020 (space). 
*0*(S if/IN (Chunk VARfillstring/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARfiller/NNP) be/VB the/DT string/VBG value/NN consisting/VBG solely/RB of/IN the/DT code/NN unit/NN 0x0020/CD (/( space/NN )/) ./.)
*0*else, let VARfiller be ? FUNCtostring(VARfillstring). 
*0*(S else/RB ,/, (Chunk let/VB VARfiller/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( VARfillstring/VBG )/) ./.)
*0*if VARfiller is the empty string, return VARs. 
*0*(S if/IN (Chunk VARfiller/NNP) is/VBZ the/DT empty/JJ string/NN ,/, return/NN (Chunk VARs/NNP) ./.)
*0*let VARfilllen be VARintmaxlength - VARstringlength. 
*0*(S (Chunk let/VB VARfilllen/NNP) (Chunk be/VB VARintmaxlength/NNP) -/: VARstringlength/NN ./.)
*0*let VARtruncatedstringfiller be the string value consisting of repeated concatenations of VARfiller truncated to length VARfilllen. 
*0*(S (Chunk let/VB VARtruncatedstringfiller/NNP) be/VB the/DT string/VBG value/NN consisting/VBG of/IN repeated/JJ concatenations/NNS of/IN (Chunk VARfiller/NNP) truncated/VBD to/TO (Chunk length/VB VARfilllen/NNP) ./.)
*0*return the string-concatenation of VARtruncatedstringfiller and VARs.     
*0*(S return/VB the/DT string-concatenation/NN of/IN (Chunk VARtruncatedstringfiller/NNP) and/CC (Chunk VARs/NNP) ./.)
ID= 21.1.3.15
Summary= String.prototype.repeat ( count )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARn be ? FUNCtointeger(VARcount). 
*0*(S (Chunk let/VB VARn/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARcount/NNP) )/) ./.)
*0*if VARn &lt; 0, throw a rangeerror exception. 
*0*(S if/IN (Chunk VARn/NNP) &/CC lt/NN ;/: 0/CD ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*if VARn is +∞, throw a rangeerror exception. 
*0*(S if/IN (Chunk VARn/NNP) (Chunk is/VBZ +∞/NNP) ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*let VARt be the string value that is made from VARn copies of VARs appended together. if VARn is 0, VARt is the empty string. 
*0*(S (Chunk let/VB VARt/NNP) be/VB the/DT string/VBG value/NN that/WDT is/VBZ made/VBN from/IN (Chunk VARn/NNP) copies/NNS of/IN (Chunk VARs/NNP) appended/VBD together/RB ./. if/IN (Chunk VARn/NNP) is/VBZ 0/CD ,/, (Chunk VARt/NNP) is/VBZ the/DT empty/JJ string/NN ./.)
*0*return VARt.     
*0*(S return/NN (Chunk VARt/NNP) ./.)
ID= 21.1.3.16
Summary= String.prototype.replace ( searchValue, replaceValue )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*if VARsearchvalue is neither undefined nor null, then
*0*(S if/IN (Chunk VARsearchvalue/NNP) is/VBZ neither/DT undefined/JJ nor/CC null/JJ ,/, then/RB)
*1*let VARreplacer be ? FUNCgetmethod(VARsearchvalue, @@replace). 
*1*(S (Chunk let/VB VARreplacer/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARsearchvalue/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) replace/VB )/) ./.)
*1*if VARreplacer is not undefined, then
*1*(S if/IN (Chunk VARreplacer/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*2*return ? FUNCcall(VARreplacer, VARsearchvalue, « VARo, VARreplacevalue »). 
*2*(S return/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARreplacer/NNP) ,/, (Chunk VARsearchvalue/NNP) ,/, (Chunk «/NNP) (Chunk VARo/NNP) ,/, (Chunk VARreplacevalue/NNP) (Chunk »/NNP) )/) ./.)
*0*let VARstring be ? FUNCtostring(VARo). 
*0*(S let/VB VARstring/VBG be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARsearchstring be ? FUNCtostring(VARsearchvalue). 
*0*(S let/VB VARsearchstring/VBG be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARsearchvalue/NNP) )/) ./.)
*0*let VARfunctionalreplace be FUNCiscallable(VARreplacevalue). 
*0*(S (Chunk let/VB VARfunctionalreplace/NNP) (Chunk be/VB FUNCiscallable/NNP) (/( (Chunk VARreplacevalue/NNP) )/) ./.)
*0*if VARfunctionalreplace is false, then
*0*(S if/IN (Chunk VARfunctionalreplace/NNP) is/VBZ false/JJ ,/, then/RB)
*1*let VARreplacevalue be ? FUNCtostring(VARreplacevalue). 
*1*(S (Chunk let/VB VARreplacevalue/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARreplacevalue/NNP) )/) ./.)
*0*search VARstring for the first occurrence of VARsearchstring and let VARpos be the index within VARstring of the first code unit of the matched substring and let VARmatched be VARsearchstring. if no occurrences of VARsearchstring were found, return VARstring. 
*0*(S search/NN VARstring/VBG for/IN the/DT first/JJ occurrence/NN of/IN (Chunk VARsearchstring/NNP) and/CC (Chunk let/VB VARpos/NNP) be/VB the/DT index/NN within/IN (Chunk VARstring/NNP) of/IN the/DT first/JJ code/NN unit/NN of/IN the/DT matched/JJ substring/NN and/CC (Chunk let/VB VARmatched/NNP) (Chunk be/VB VARsearchstring/NNP) ./. if/IN no/DT occurrences/NNS of/IN (Chunk VARsearchstring/NNP) were/VBD found/VBN ,/, (Chunk return/VB VARstring/NNP) ./.)
*0*if VARfunctionalreplace is true, then
*0*(S if/IN (Chunk VARfunctionalreplace/NNP) is/VBZ true/JJ ,/, then/RB)
*1*let VARreplvalue be ? FUNCcall(VARreplacevalue, undefined, « VARmatched, VARpos, VARstring »). 
*1*(S (Chunk let/VB VARreplvalue/NNP) be/VB ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARreplacevalue/NNP) ,/, undefined/VBD ,/, (Chunk «/NNP) (Chunk VARmatched/NNP) ,/, (Chunk VARpos/NNP) ,/, (Chunk VARstring/NNP) (Chunk »/NNP) )/) ./.)
*1*let VARreplstr be ? FUNCtostring(VARreplvalue). 
*1*(S (Chunk let/VB VARreplstr/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARreplvalue/NNP) )/) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARcaptures be a new empty list. 
*1*(S (Chunk let/VB VARcaptures/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*1*let VARreplstr be FUNCgetsubstitution(VARmatched, VARstring, VARpos, VARcaptures, undefined, VARreplacevalue). 
*1*(S (Chunk let/VB VARreplstr/NNP) (Chunk be/VB FUNCgetsubstitution/NNP) (/( (Chunk VARmatched/NNP) ,/, (Chunk VARstring/NNP) ,/, (Chunk VARpos/NNP) ,/, (Chunk VARcaptures/NNP) ,/, undefined/VBD ,/, (Chunk VARreplacevalue/NNP) )/) ./.)
*0*let VARtailpos be VARpos + the number of code units in VARmatched. 
*0*(S (Chunk let/VB VARtailpos/NNP) (Chunk be/VB VARpos/NNP) (Chunk +/NNP) the/DT number/NN of/IN code/JJ units/NNS in/IN (Chunk VARmatched/NNP) ./.)
*0*let VARnewstring be the string-concatenation of the first VARpos code units of VARstring, VARreplstr, and the trailing substring of VARstring starting at index VARtailpos. if VARpos is 0, the first element of the concatenation will be the empty string. 
*0*(S (Chunk let/VB VARnewstring/NNP) be/VB the/DT string-concatenation/NN of/IN the/DT first/JJ (Chunk VARpos/NNP) code/NN units/NNS of/IN (Chunk VARstring/NNP) ,/, (Chunk VARreplstr/NNP) ,/, and/CC the/DT trailing/VBG substring/NN of/IN VARstring/VBG starting/VBG at/IN index/NN (Chunk VARtailpos/NNP) ./. if/IN (Chunk VARpos/NNP) is/VBZ 0/CD ,/, the/DT first/JJ element/NN of/IN the/DT concatenation/NN will/MD be/VB the/DT empty/JJ string/NN ./.)
*0*return VARnewstring.     
*0*(S return/NN (Chunk VARnewstring/NNP) ./.)
ID= 21.1.3.16.1
Summary= Runtime Semantics: GetSubstitution ( matched, str, position, captures, namedCaptures, replacement )
*0*assert: FUNCtype(VARmatched) is string. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARmatched/NNP) )/) is/VBZ string/VBG ./.)
*0*let VARmatchlength be the number of code units in VARmatched. 
*0*(S (Chunk let/VB VARmatchlength/NNP) be/VB the/DT number/NN of/IN code/JJ units/NNS in/IN (Chunk VARmatched/NNP) ./.)
*0*assert: FUNCtype(VARstr) is string. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARstr/NNP) )/) is/VBZ string/VBG ./.)
*0*let VARstringlength be the number of code units in VARstr. 
*0*(S (Chunk let/VB VARstringlength/NNP) be/VB the/DT number/NN of/IN code/JJ units/NNS in/IN (Chunk VARstr/NNP) ./.)
*0*assert: VARposition is a nonnegative integer. 
*0*(S assert/NN :/: VARposition/NN is/VBZ a/DT nonnegative/JJ integer/NN ./.)
*0*assert: VARposition ≤ VARstringlength. 
*0*(S assert/NN :/: (Chunk VARposition/NNP) (Chunk ≤/NNP) (Chunk VARstringlength/NNP) ./.)
*0*assert: VARcaptures is a possibly empty list of strings. 
*0*(S assert/NN :/: VARcaptures/NNS is/VBZ a/DT possibly/RB empty/JJ list/NN of/IN strings/NNS ./.)
*0*assert: FUNCtype(VARreplacement) is string. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARreplacement/NNP) )/) is/VBZ string/VBG ./.)
*0*let VARtailpos be VARposition + VARmatchlength. 
*0*(S (Chunk let/VB VARtailpos/NNP) (Chunk be/VB VARposition/NNP) (Chunk +/NNP) (Chunk VARmatchlength/NNP) ./.)
*0*let VARm be the number of elements in VARcaptures. 
*0*(S (Chunk let/VB VARm/NNP) be/VB the/DT number/NN of/IN elements/NNS in/IN (Chunk VARcaptures/NNP) ./.)
*0*if VARnamedcaptures is not undefined, then
*0*(S if/IN (Chunk VARnamedcaptures/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*1*set VARnamedcaptures to ? FUNCtoobject(VARnamedcaptures). 
*1*(S set/NN VARnamedcaptures/NNS to/TO ?/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARnamedcaptures/NNP) )/) ./.)
*0*let VARresult be the string value derived from VARreplacement by copying code unit elements from VARreplacement to VARresult while performing replacements as specified in table 48. these $ replacements are done left-to-right, and, once such a replacement is performed, the new replacement text is not subject to further replacements. 
*0*(S (Chunk let/VB VARresult/NNP) be/VB the/DT string/VBG value/NN derived/VBN from/IN (Chunk VARreplacement/NNP) by/IN copying/VBG code/NN unit/NN elements/NNS from/IN (Chunk VARreplacement/NNP) to/TO (Chunk VARresult/NNP) while/IN performing/VBG replacements/NNS as/IN specified/VBN in/IN table/JJ 48./CD these/DT $/$ replacements/NNS are/VBP done/VBN left-to-right/JJ ,/, and/CC ,/, once/RB such/JJ a/DT replacement/NN is/VBZ performed/VBN ,/, the/DT new/JJ replacement/NN text/NN is/VBZ not/RB subject/JJ to/TO further/JJ replacements/NNS ./.)
*0*return VARresult.      
*0*(S return/NN (Chunk VARresult/NNP) ./.)
ID= 21.1.3.17
Summary= String.prototype.search ( regexp )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*if VARregexp is neither undefined nor null, then
*0*(S if/IN (Chunk VARregexp/NNP) is/VBZ neither/DT undefined/JJ nor/CC null/JJ ,/, then/RB)
*1*let VARsearcher be ? FUNCgetmethod(VARregexp, @@search). 
*1*(S (Chunk let/VB VARsearcher/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARregexp/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) search/NN )/) ./.)
*1*if VARsearcher is not undefined, then
*1*(S if/IN (Chunk VARsearcher/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*2*return ? FUNCcall(VARsearcher, VARregexp, « VARo »). 
*2*(S return/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARsearcher/NNP) ,/, (Chunk VARregexp/NNP) ,/, (Chunk «/NNP) (Chunk VARo/NNP) (Chunk »/NNP) )/) ./.)
*0*let VARstring be ? FUNCtostring(VARo). 
*0*(S let/VB VARstring/VBG be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARrx be ? FUNCregexpcreate(VARregexp, undefined). 
*0*(S (Chunk let/VB VARrx/NNP) be/VB ?/. (Chunk FUNCregexpcreate/NNP) (/( (Chunk VARregexp/NNP) ,/, undefined/VBD )/) ./.)
*0*return ? FUNCinvoke(VARrx, @@search, « VARstring »).     
*0*(S return/NN ?/. (Chunk FUNCinvoke/NNP) (/( (Chunk VARrx/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) search/NN ,/, (Chunk «/NNP) (Chunk VARstring/NNP) (Chunk »/NNP) )/) ./.)
ID= 21.1.3.18
Summary= String.prototype.slice ( start, end )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARlen be the length of VARs. 
*0*(S (Chunk let/VB VARlen/NNP) be/VB the/DT length/NN of/IN (Chunk VARs/NNP) ./.)
*0*let VARintstart be ? FUNCtointeger(VARstart). 
*0*(S (Chunk let/VB VARintstart/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARstart/NNP) )/) ./.)
*0*if VARend is undefined, let VARintend be VARlen; else let VARintend be ? FUNCtointeger(VARend). 
*0*(S if/IN (Chunk VARend/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARintend/NNP) (Chunk be/VB VARlen/NNP) ;/: else/JJ (Chunk let/VB VARintend/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARend/NNP) )/) ./.)
*0*if VARintstart &lt; 0, let VARfrom be max(VARlen + VARintstart, 0); otherwise let VARfrom be min(VARintstart, VARlen). 
*0*(S if/IN (Chunk VARintstart/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARfrom/NNP) be/VB max/VBN (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARintstart/NNP) ,/, 0/CD )/) ;/: (Chunk otherwise/RB let/VB VARfrom/NNP) be/VB min/VBN (/( (Chunk VARintstart/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*if VARintend &lt; 0, let VARto be max(VARlen + VARintend, 0); otherwise let VARto be min(VARintend, VARlen). 
*0*(S if/IN (Chunk VARintend/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARto/NNP) be/VB max/VBN (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARintend/NNP) ,/, 0/CD )/) ;/: (Chunk otherwise/RB let/VB VARto/NNP) be/VB min/VBN (/( (Chunk VARintend/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*let VARspan be max(VARto - VARfrom, 0). 
*0*(S (Chunk let/VB VARspan/NNP) be/VB max/VBN (/( (Chunk VARto/NNP) -/: (Chunk VARfrom/NNP) ,/, 0/CD )/) ./.)
*0*return the string value containing VARspan consecutive elements from VARs beginning with the element at index VARfrom.     
*0*(S return/VB the/DT string/NN value/NN (Chunk containing/VBG VARspan/NNP) consecutive/JJ elements/NNS from/IN (Chunk VARs/NNP) beginning/VBG with/IN the/DT element/NN at/IN index/NN (Chunk VARfrom/NNP) ./.)
ID= 21.1.3.19
Summary= String.prototype.split ( separator, limit )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*if VARseparator is neither undefined nor null, then
*0*(S if/IN (Chunk VARseparator/NNP) is/VBZ neither/DT undefined/JJ nor/CC null/JJ ,/, then/RB)
*1*let VARsplitter be ? FUNCgetmethod(VARseparator, @@split). 
*1*(S (Chunk let/VB VARsplitter/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARseparator/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) split/NN )/) ./.)
*1*if VARsplitter is not undefined, then
*1*(S if/IN (Chunk VARsplitter/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*2*return ? FUNCcall(VARsplitter, VARseparator, « VARo, VARlimit »). 
*2*(S return/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARsplitter/NNP) ,/, (Chunk VARseparator/NNP) ,/, (Chunk «/NNP) (Chunk VARo/NNP) ,/, (Chunk VARlimit/NNP) (Chunk »/NNP) )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARa be ! FUNCarraycreate(0). 
*0*(S (Chunk let/VB VARa/NNP) be/VB !/. (Chunk FUNCarraycreate/NNP) (/( 0/CD )/) ./.)
*0*let VARlengtha be 0. 
*0*(S (Chunk let/VB VARlengtha/NNP) be/VB 0/CD ./.)
*0*if VARlimit is undefined, let VARlim be 232-1; else let VARlim be ? FUNCtouint32(VARlimit). 
*0*(S if/IN (Chunk VARlimit/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARlim/NNP) be/VB 232-1/JJ ;/: else/JJ (Chunk let/VB VARlim/NNP) be/VB ?/. (Chunk FUNCtouint32/NNP) (/( (Chunk VARlimit/NNP) )/) ./.)
*0*let VARs be the length of VARs. 
*0*(S (Chunk let/VB VARs/NNP) be/VB the/DT length/NN of/IN (Chunk VARs/NNP) ./.)
*0*let VARp be 0. 
*0*(S (Chunk let/VB VARp/NNP) be/VB 0/CD ./.)
*0*let VARr be ? FUNCtostring(VARseparator). 
*0*(S (Chunk let/VB VARr/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARseparator/NNP) )/) ./.)
*0*if VARlim = 0, return VARa. 
*0*(S if/IN (Chunk VARlim/NNP) =/VBD 0/CD ,/, return/NN (Chunk VARa/NNP) ./.)
*0*if VARseparator is undefined, then
*0*(S if/IN (Chunk VARseparator/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*perform ! FUNCcreatedataproperty(VARa, "0", VARs). 
*1*(S perform/NN !/. (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` 0/CD ''/'' ,/, (Chunk VARs/NNP) )/) ./.)
*1*return VARa. 
*1*(S return/NN (Chunk VARa/NNP) ./.)
*0*if VARs = 0, then
*0*(S if/IN (Chunk VARs/NNP) =/VBD 0/CD ,/, then/RB)
*1*let VARz be FUNCsplitmatch(VARs, 0, VARr). 
*1*(S (Chunk let/VB VARz/NNP) (Chunk be/VB FUNCsplitmatch/NNP) (/( (Chunk VARs/NNP) ,/, 0/CD ,/, (Chunk VARr/NNP) )/) ./.)
*1*if VARz is not false, return VARa. 
*1*(S if/IN (Chunk VARz/NNP) is/VBZ not/RB false/JJ ,/, return/JJ (Chunk VARa/NNP) ./.)
*1*perform ! FUNCcreatedataproperty(VARa, "0", VARs). 
*1*(S perform/NN !/. (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` 0/CD ''/'' ,/, (Chunk VARs/NNP) )/) ./.)
*1*return VARa. 
*1*(S return/NN (Chunk VARa/NNP) ./.)
*0*let VARq be VARp. 
*0*(S (Chunk let/VB VARq/NNP) (Chunk be/VB VARp/NNP) ./.)
*0*repeat, while VARq ≠ VARs
*0*(S repeat/NN ,/, while/IN (Chunk VARq/NNP) (Chunk ≠/NNP) (Chunk VARs/NNP))
*1*let VARe be FUNCsplitmatch(VARs, VARq, VARr). 
*1*(S (Chunk let/VB VARe/NNP) (Chunk be/VB FUNCsplitmatch/NNP) (/( (Chunk VARs/NNP) ,/, (Chunk VARq/NNP) ,/, (Chunk VARr/NNP) )/) ./.)
*1*if VARe is false, let VARq be VARq+1. 
*1*(S if/IN (Chunk VARe/NNP) is/VBZ false/JJ ,/, (Chunk let/VB VARq/NNP) (Chunk be/VB VARq+1/NNP) ./.)
*1*else VARe is an integer index ≤ VARs,
*1*(S (Chunk else/RB VARe/NNP) is/VBZ an/DT integer/NN index/NN (Chunk ≤/NNP) (Chunk VARs/NNP) ,/,)
*2*if VARe = VARp, let VARq be VARq+1. 
*2*(S if/IN (Chunk VARe/NNP) (Chunk =/NNP) (Chunk VARp/NNP) ,/, (Chunk let/VB VARq/NNP) (Chunk be/VB VARq+1/NNP) ./.)
*2*else VARe ≠ VARp,
*2*(S (Chunk else/RB VARe/NNP) (Chunk ≠/NNP) (Chunk VARp/NNP) ,/,)
*3*let VARt be the string value equal to the substring of VARs consisting of the code units at indices VARp (inclusive) through VARq (exclusive). 
*3*(S (Chunk let/VB VARt/NNP) be/VB the/DT string/VBG value/NN equal/JJ to/TO the/DT substring/NN of/IN (Chunk VARs/NNP) consisting/VBG of/IN the/DT code/NN units/NNS at/IN indices/NNS (Chunk VARp/NNP) (/( inclusive/JJ )/) through/IN (Chunk VARq/NNP) (/( exclusive/JJ )/) ./.)
*3*perform ! FUNCcreatedataproperty(VARa, ! FUNCtostring(VARlengtha), VARt). 
*3*(S perform/NN !/. (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARa/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARlengtha/NNP) )/) ,/, (Chunk VARt/NNP) )/) ./.)
*3*increment VARlengtha by 1. 
*3*(S increment/NN (Chunk VARlengtha/NNP) by/IN 1/CD ./.)
*3*if VARlengtha = VARlim, return VARa. 
*3*(S if/IN (Chunk VARlengtha/NNP) (Chunk =/NNP) (Chunk VARlim/NNP) ,/, return/NN (Chunk VARa/NNP) ./.)
*3*let VARp be VARe. 
*3*(S (Chunk let/VB VARp/NNP) (Chunk be/VB VARe/NNP) ./.)
*3*let VARq be VARp. 
*3*(S (Chunk let/VB VARq/NNP) (Chunk be/VB VARp/NNP) ./.)
*0*let VARt be the string value equal to the substring of VARs consisting of the code units at indices VARp (inclusive) through VARs (exclusive). 
*0*(S (Chunk let/VB VARt/NNP) be/VB the/DT string/VBG value/NN equal/JJ to/TO the/DT substring/NN of/IN (Chunk VARs/NNP) consisting/VBG of/IN the/DT code/NN units/NNS at/IN indices/NNS (Chunk VARp/NNP) (/( inclusive/JJ )/) through/IN (Chunk VARs/NNP) (/( exclusive/JJ )/) ./.)
*0*perform ! FUNCcreatedataproperty(VARa, ! FUNCtostring(VARlengtha), VARt). 
*0*(S perform/NN !/. (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARa/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARlengtha/NNP) )/) ,/, (Chunk VARt/NNP) )/) ./.)
*0*return VARa.     
*0*(S return/NN (Chunk VARa/NNP) ./.)
ID= 21.1.3.19.1
Summary= Runtime Semantics: SplitMatch ( S, q, R )
*0*assert: FUNCtype(VARr) is string. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARr/NNP) )/) is/VBZ string/VBG ./.)
*0*let VARr be the number of code units in VARr. 
*0*(S (Chunk let/VB VARr/NNP) be/VB the/DT number/NN of/IN code/JJ units/NNS in/IN (Chunk VARr/NNP) ./.)
*0*let VARs be the number of code units in VARs. 
*0*(S (Chunk let/VB VARs/NNP) be/VB the/DT number/NN of/IN code/JJ units/NNS in/IN (Chunk VARs/NNP) ./.)
*0*if VARq+VARr &gt; VARs, return false. 
*0*(S if/IN (Chunk VARq+VARr/NNP) &/CC gt/NN ;/: (Chunk VARs/NNP) ,/, return/NN false/JJ ./.)
*0*if there exists an integer VARi between 0 (inclusive) and VARr (exclusive) such that the code unit at index VARq+VARi within VARs is different from the code unit at index VARi within VARr, return false. 
*0*(S if/IN there/EX exists/VBZ an/DT integer/NN (Chunk VARi/NNP) between/IN 0/CD (/( inclusive/JJ )/) and/CC (Chunk VARr/NNP) (/( exclusive/JJ )/) such/JJ that/IN the/DT code/NN unit/NN at/IN index/NN (Chunk VARq+VARi/NNP) within/IN (Chunk VARs/NNP) is/VBZ different/JJ from/IN the/DT code/NN unit/NN at/IN index/NN (Chunk VARi/NNP) within/IN (Chunk VARr/NNP) ,/, return/NN false/JJ ./.)
*0*return VARq+VARr.      
*0*(S return/NN (Chunk VARq+VARr/NNP) ./.)
ID= 21.1.3.20
Summary= String.prototype.startsWith ( searchString [ , position ] )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARisregexp be ? FUNCisregexp(VARsearchstring). 
*0*(S (Chunk let/VB VARisregexp/NNP) be/VB ?/. (Chunk FUNCisregexp/NNP) (/( VARsearchstring/VBG )/) ./.)
*0*if VARisregexp is true, throw a typeerror exception. 
*0*(S if/IN (Chunk VARisregexp/NNP) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARsearchstr be ? FUNCtostring(VARsearchstring). 
*0*(S (Chunk let/VB VARsearchstr/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( VARsearchstring/VBG )/) ./.)
*0*let VARpos be ? FUNCtointeger(VARposition). (if VARposition is undefined, this step produces the value 0.) 
*0*(S (Chunk let/VB VARpos/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARposition/NNP) )/) ./. (/( if/IN (Chunk VARposition/NNP) is/VBZ undefined/JJ ,/, this/DT step/NN produces/VBZ the/DT value/NN (Chunk 0/NNP) ./. )/))
*0*let VARlen be the length of VARs. 
*0*(S (Chunk let/VB VARlen/NNP) be/VB the/DT length/NN of/IN (Chunk VARs/NNP) ./.)
*0*let VARstart be min(max(VARpos, 0), VARlen). 
*0*(S (Chunk let/VB VARstart/NNP) be/VB min/VBN (/( max/NN (/( (Chunk VARpos/NNP) ,/, 0/CD )/) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*let VARsearchlength be the length of VARsearchstr. 
*0*(S (Chunk let/VB VARsearchlength/NNP) be/VB the/DT length/NN of/IN (Chunk VARsearchstr/NNP) ./.)
*0*if VARsearchlength+VARstart is greater than VARlen, return false. 
*0*(S if/IN (Chunk VARsearchlength+VARstart/NNP) is/VBZ greater/JJR than/IN (Chunk VARlen/NNP) ,/, return/NN false/JJ ./.)
*0*if the sequence of elements of VARs starting at VARstart of length VARsearchlength is the same as the full element sequence of VARsearchstr, return true. 
*0*(S if/IN the/DT sequence/NN of/IN elements/NNS of/IN (Chunk VARs/NNP) starting/VBG at/IN (Chunk VARstart/NNP) of/IN length/NN (Chunk VARsearchlength/NNP) is/VBZ the/DT same/JJ as/IN the/DT full/JJ element/NN sequence/NN of/IN (Chunk VARsearchstr/NNP) ,/, return/NN true/JJ ./.)
*0*otherwise, return false.     
*0*(S otherwise/RB ,/, return/NN false/JJ ./.)
ID= 21.1.3.21
Summary= String.prototype.substring ( start, end )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARlen be the length of VARs. 
*0*(S (Chunk let/VB VARlen/NNP) be/VB the/DT length/NN of/IN (Chunk VARs/NNP) ./.)
*0*let VARintstart be ? FUNCtointeger(VARstart). 
*0*(S (Chunk let/VB VARintstart/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARstart/NNP) )/) ./.)
*0*if VARend is undefined, let VARintend be VARlen; else let VARintend be ? FUNCtointeger(VARend). 
*0*(S if/IN (Chunk VARend/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARintend/NNP) (Chunk be/VB VARlen/NNP) ;/: else/JJ (Chunk let/VB VARintend/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARend/NNP) )/) ./.)
*0*let VARfinalstart be min(max(VARintstart, 0), VARlen). 
*0*(S (Chunk let/VB VARfinalstart/NNP) be/VB min/VBN (/( max/NN (/( (Chunk VARintstart/NNP) ,/, 0/CD )/) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*let VARfinalend be min(max(VARintend, 0), VARlen). 
*0*(S (Chunk let/VB VARfinalend/NNP) be/VB min/VBN (/( max/NN (/( (Chunk VARintend/NNP) ,/, 0/CD )/) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*let VARfrom be min(VARfinalstart, VARfinalend). 
*0*(S (Chunk let/VB VARfrom/NNP) be/VB min/VBN (/( (Chunk VARfinalstart/NNP) ,/, (Chunk VARfinalend/NNP) )/) ./.)
*0*let VARto be max(VARfinalstart, VARfinalend). 
*0*(S (Chunk let/VB VARto/NNP) be/VB max/VBN (/( (Chunk VARfinalstart/NNP) ,/, (Chunk VARfinalend/NNP) )/) ./.)
*0*return the string value whose length is VARto - VARfrom, containing code units from VARs, namely the code units with indices VARfrom through VARto - 1, in ascending order.     
*0*(S return/VB the/DT string/NN value/NN whose/WP$ length/NN (Chunk is/VBZ VARto/NNP) -/: VARfrom/NN ,/, containing/VBG code/NN units/NNS from/IN (Chunk VARs/NNP) ,/, namely/RB the/DT code/NN units/NNS with/IN indices/NNS (Chunk VARfrom/NNP) through/IN (Chunk VARto/NNP) -/: 1/CD ,/, in/IN ascending/VBG order/NN ./.)
ID= 21.1.3.24
Summary= String.prototype.toLowerCase ( )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARcplist be a list containing in order the code points as defined in 6.1.4 of VARs, starting at the first element of VARs. 
*0*(S (Chunk let/VB VARcplist/NNP) be/VB a/DT list/NN containing/VBG in/IN order/NN the/DT code/NN points/NNS as/IN defined/VBN in/IN 6.1.4/CD of/IN (Chunk VARs/NNP) ,/, starting/VBG at/IN the/DT first/JJ element/NN of/IN (Chunk VARs/NNP) ./.)
*0*let VARculist be a list where the elements are the result of tolowercase(VARcplist), according to the unicode default case conversion algorithm. 
*0*(S (Chunk let/VB VARculist/NNP) be/VB a/DT list/NN where/WRB the/DT elements/NNS are/VBP the/DT result/NN of/IN tolowercase/NN (/( (Chunk VARcplist/NNP) )/) ,/, according/VBG to/TO the/DT unicode/NN default/NN case/NN conversion/NN algorithm/NN ./.)
*0*let VARl be the string value whose elements are the utf16encoding of the code points of VARculist. 
*0*(S (Chunk let/VB VARl/NNP) be/VB the/DT string/NN value/NN whose/WP$ elements/NNS are/VBP the/DT utf16encoding/NN of/IN the/DT code/NN points/NNS of/IN (Chunk VARculist/NNP) ./.)
*0*return VARl.     
*0*(S return/NN (Chunk VARl/NNP) ./.)
ID= 21.1.3.25
Summary= String.prototype.toString ( )
*0*return ? FUNCthisstringvalue(this value).     
*0*(S return/NN ?/. (Chunk FUNCthisstringvalue/NNP) (/( this/DT value/NN )/) ./.)
ID= 21.1.3.27
Summary= String.prototype.trim ( )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARt be the string value that is a copy of VARs with both leading and trailing white space removed. the definition of white space is the union of whitespace and lineterminator. when determining whether a unicode code point is in unicode general category “space_separator” (“zs”), code unit sequences are interpreted as utf-16 encoded code point sequences as specified in 6.1.4. 
*0*(S (Chunk let/VB VARt/NNP) be/VB the/DT string/VBG value/NN that/WDT is/VBZ a/DT copy/NN of/IN (Chunk VARs/NNP) with/IN both/DT leading/VBG and/CC trailing/VBG white/JJ space/NN removed/VBN ./. the/DT definition/NN of/IN white/JJ space/NN is/VBZ the/DT union/NN of/IN whitespace/NN and/CC lineterminator/NN ./. when/WRB determining/VBG whether/IN a/DT unicode/JJ code/NN point/NN is/VBZ in/IN unicode/JJ general/JJ category/NN (Chunk “/NNP) space_separator/NN (Chunk ”/NNP) (/( (Chunk “/NNP) (Chunk zs/NNP) (Chunk ”/NNP) )/) ,/, code/JJ unit/NN sequences/NNS are/VBP interpreted/VBN as/IN utf-16/JJ encoded/VBD code/NN point/NN sequences/NNS as/IN specified/VBN in/IN 6.1.4/CD ./.)
*0*return VARt.     
*0*(S return/NN (Chunk VARt/NNP) ./.)
ID= 21.1.3.28
Summary= String.prototype.valueOf ( )
*0*return ? FUNCthisstringvalue(this value).     
*0*(S return/NN ?/. (Chunk FUNCthisstringvalue/NNP) (/( this/DT value/NN )/) ./.)
ID= 21.1.3.29
Summary= String.prototype [ @@iterator ] ( )
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. FUNCrequireobjectcoercible/JJ (/( this/DT value/NN )/) ./.)
*0*let VARs be ? FUNCtostring(VARo). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*return FUNCcreatestringiterator(VARs).     
*0*(S return/NN (Chunk FUNCcreatestringiterator/NNP) (/( (Chunk VARs/NNP) )/) ./.)
ID= 21.1.5.1
Summary= CreateStringIterator ( string )
*0*assert: FUNCtype(VARstring) is string. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( VARstring/VBG )/) is/VBZ string/VBG ./.)
*0*let VARiterator be FUNCobjectcreate(%stringiteratorprototype%, « [[ITERATEDSTRING]], [[STRINGITERATORNEXTINDEX]] »). 
*0*(S (Chunk let/VB VARiterator/NNP) (Chunk be/VB FUNCobjectcreate/NNP) (/( %/NN stringiteratorprototype/NN %/NN ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk ITERATEDSTRING/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk STRINGITERATORNEXTINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARiterator.[[ITERATEDSTRING]] to VARstring. 
*0*(S (Chunk set/VBN VARiterator/NNP) ./. [/VB [/JJ (Chunk ITERATEDSTRING/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARstring/NNP) ./.)
*0*set VARiterator.[[STRINGITERATORNEXTINDEX]] to 0. 
*0*(S (Chunk set/VBN VARiterator/NNP) ./. [/VB [/JJ (Chunk STRINGITERATORNEXTINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO 0/CD ./.)
*0*return VARiterator.     
*0*(S return/NN (Chunk VARiterator/NNP) ./.)
ID= 21.1.5.2.1
Summary= %StringIteratorPrototype%.next ( )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARo does not have all of the internal slots of a string iterator instance (21.1.5.3), throw a typeerror exception. 
*0*(S if/IN (Chunk VARo/NNP) does/VBZ not/RB have/VB all/DT of/IN the/DT internal/JJ slots/NNS of/IN a/DT string/NN iterator/NN instance/NN (/( 21.1.5.3/CD )/) ,/, throw/VBP a/DT typeerror/NN exception/NN ./.)
*0*let VARs be VARo.[[ITERATEDSTRING]]. 
*0*(S (Chunk let/VB VARs/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk ITERATEDSTRING/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARs is undefined, return FUNCcreateiterresultobject(undefined, true). 
*0*(S if/IN (Chunk VARs/NNP) is/VBZ undefined/JJ ,/, (Chunk return/VB FUNCcreateiterresultobject/NNP) (/( undefined/JJ ,/, true/JJ )/) ./.)
*0*let VARposition be VARo.[[STRINGITERATORNEXTINDEX]]. 
*0*(S (Chunk let/VB VARposition/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk STRINGITERATORNEXTINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARlen be the length of VARs. 
*0*(S (Chunk let/VB VARlen/NNP) be/VB the/DT length/NN of/IN (Chunk VARs/NNP) ./.)
*0*if VARposition ≥ VARlen, then
*0*(S if/IN (Chunk VARposition/NNP) (Chunk ≥/NNP) (Chunk VARlen/NNP) ,/, then/RB)
*1*set VARo.[[ITERATEDSTRING]] to undefined. 
*1*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk ITERATEDSTRING/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO undefined/VB ./.)
*1*return FUNCcreateiterresultobject(undefined, true). 
*1*(S return/NN (Chunk FUNCcreateiterresultobject/NNP) (/( undefined/JJ ,/, true/JJ )/) ./.)
*0*let VARfirst be the numeric value of the code unit at index VARposition within VARs. 
*0*(S (Chunk let/VB VARfirst/NNP) be/VB the/DT numeric/JJ value/NN of/IN the/DT code/NN unit/NN at/IN index/NN (Chunk VARposition/NNP) within/IN (Chunk VARs/NNP) ./.)
*0*if VARfirst &lt; 0xd800 or VARfirst &gt; 0xdbff or VARposition+1 = VARlen, let VARresultstring be the string value consisting of the single code unit VARfirst. 
*0*(S if/IN (Chunk VARfirst/NNP) &/CC lt/NN ;/: 0xd800/CD or/CC (Chunk VARfirst/NNP) &/CC gt/NN ;/: 0xdbff/CD or/CC (Chunk VARposition+1/NNP) (Chunk =/NNP) (Chunk VARlen/NNP) ,/, (Chunk let/VB VARresultstring/NNP) be/VB the/DT string/VBG value/NN consisting/NN of/IN the/DT single/JJ code/NN unit/NN (Chunk VARfirst/NNP) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARsecond be the numeric value of the code unit at index VARposition+1 within the string VARs. 
*1*(S (Chunk let/VB VARsecond/NNP) be/VB the/DT numeric/JJ value/NN of/IN the/DT code/NN unit/NN at/IN index/NN (Chunk VARposition+1/NNP) within/IN the/DT string/NN (Chunk VARs/NNP) ./.)
*1*if VARsecond &lt; 0xdc00 or VARsecond &gt; 0xdfff, let VARresultstring be the string value consisting of the single code unit VARfirst. 
*1*(S if/IN (Chunk VARsecond/NNP) &/CC lt/NN ;/: 0xdc00/CD or/CC (Chunk VARsecond/NNP) &/CC gt/NN ;/: 0xdfff/CD ,/, (Chunk let/VB VARresultstring/NNP) be/VB the/DT string/VBG value/NN consisting/NN of/IN the/DT single/JJ code/NN unit/NN (Chunk VARfirst/NNP) ./.)
*1*else, let VARresultstring be the string-concatenation of the code unit VARfirst and the code unit VARsecond. 
*1*(S else/RB ,/, (Chunk let/VB VARresultstring/NNP) be/VB the/DT string-concatenation/NN of/IN the/DT code/NN unit/NN (Chunk VARfirst/NNP) and/CC the/DT code/NN unit/NN (Chunk VARsecond/NNP) ./.)
*0*let VARresultsize be the number of code units in VARresultstring. 
*0*(S (Chunk let/VB VARresultsize/NNP) be/VB the/DT number/NN of/IN code/JJ units/NNS in/IN (Chunk VARresultstring/NNP) ./.)
*0*set VARo.[[STRINGITERATORNEXTINDEX]] to VARposition + VARresultsize. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk STRINGITERATORNEXTINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARposition/NNP) (Chunk +/NNP) (Chunk VARresultsize/NNP) ./.)
*0*return FUNCcreateiterresultobject(VARresultstring, false).      
*0*(S return/NN (Chunk FUNCcreateiterresultobject/NNP) (/( (Chunk VARresultstring/NNP) ,/, false/RB )/) ./.)
ID= 21.2.2.5.1
Summary= Runtime Semantics: RepeatMatcher ( m, min, max, greedy, x, c, parenIndex, parenCount )
*0*if VARmax is zero, return VARc(VARx). 
*0*(S if/IN (Chunk VARmax/NNP) is/VBZ zero/CD ,/, return/NN (Chunk VARc/NNP) (/( (Chunk VARx/NNP) )/) ./.)
*0*let VARd be an internal continuation closure that takes one state argument VARy and performs the following steps when evaluated:
*0*(S (Chunk let/VB VARd/NNP) be/VB an/DT internal/JJ continuation/NN closure/NN that/WDT takes/VBZ one/CD state/NN argument/NN (Chunk VARy/NNP) and/CC performs/VBZ the/DT following/JJ steps/NNS when/WRB evaluated/VBN :/:)
*1*if VARmin is zero and VARy's VARendindex is equal to VARx's VARendindex, return failure. 
*1*(S if/IN (Chunk VARmin/NNP) is/VBZ zero/CD and/CC (Chunk VARy/NNP) 's/POS (Chunk VARendindex/NNP) is/VBZ equal/JJ to/TO (Chunk VARx/NNP) 's/POS (Chunk VARendindex/NNP) ,/, return/NN failure/NN ./.)
*1*if VARmin is zero, let VARmin2 be zero; otherwise let VARmin2 be VARmin-1. 
*1*(S if/IN (Chunk VARmin/NNP) is/VBZ zero/CD ,/, (Chunk let/VB VARmin2/NNP) be/VB zero/CD ;/: (Chunk otherwise/RB let/VB VARmin2/NNP) (Chunk be/VB VARmin-1/NNP) ./.)
*1*if VARmax is ∞, let VARmax2 be ∞; otherwise let VARmax2 be VARmax-1. 
*1*(S if/IN (Chunk VARmax/NNP) is/VBZ ∞/JJ ,/, (Chunk let/VB VARmax2/NNP) be/VB ∞/VBN ;/: (Chunk otherwise/RB let/VB VARmax2/NNP) (Chunk be/VB VARmax-1/NNP) ./.)
*1*call FUNCrepeatmatcher(VARm, VARmin2, VARmax2, VARgreedy, VARy, VARc, VARparenindex, VARparencount) and return its result. 
*1*(S call/NN (Chunk FUNCrepeatmatcher/NNP) (/( (Chunk VARm/NNP) ,/, (Chunk VARmin2/NNP) ,/, (Chunk VARmax2/NNP) ,/, (Chunk VARgreedy/NNP) ,/, (Chunk VARy/NNP) ,/, (Chunk VARc/NNP) ,/, (Chunk VARparenindex/NNP) ,/, (Chunk VARparencount/NNP) )/) and/CC return/VB its/PRP$ result/NN ./.)
*0*let VARcap be a copy of VARx's VARcaptures list. 
*0*(S (Chunk let/VB VARcap/NNP) be/VB a/DT copy/NN of/IN (Chunk VARx/NNP) 's/POS (Chunk VARcaptures/NNP) list/NN ./.)
*0*for each integer VARk that satisfies VARparenindex &lt; VARk and VARk ≤ VARparenindex+VARparencount, set VARcap[VARk] to undefined. 
*0*(S for/IN each/DT integer/NN (Chunk VARk/NNP) that/IN (Chunk satisfies/VBZ VARparenindex/NNP) &/CC lt/NN ;/: (Chunk VARk/NNP) and/CC (Chunk VARk/NNP) (Chunk ≤/NNP) (Chunk VARparenindex+VARparencount/NNP) ,/, (Chunk set/VBD VARcap/NNP) (Chunk [/NNP) (Chunk VARk/NNP) (Chunk ]/NNP) to/TO undefined/VB ./.)
*0*let VARe be VARx's VARendindex. 
*0*(S (Chunk let/VB VARe/NNP) (Chunk be/VB VARx/NNP) 's/POS (Chunk VARendindex/NNP) ./.)
*0*let VARxr be the state (VARe, VARcap). 
*0*(S (Chunk let/VB VARxr/NNP) be/VB the/DT state/NN (/( (Chunk VARe/NNP) ,/, (Chunk VARcap/NNP) )/) ./.)
*0*if VARmin is not zero, return VARm(VARxr, VARd). 
*0*(S if/IN (Chunk VARmin/NNP) is/VBZ not/RB zero/CD ,/, return/NN (Chunk VARm/NNP) (/( (Chunk VARxr/NNP) ,/, (Chunk VARd/NNP) )/) ./.)
*0*if VARgreedy is false, then
*0*(S if/IN (Chunk VARgreedy/NNP) is/VBZ false/JJ ,/, then/RB)
*1*call VARc(VARx) and let VARz be its result. 
*1*(S call/NN (Chunk VARc/NNP) (/( (Chunk VARx/NNP) )/) and/CC (Chunk let/VB VARz/NNP) be/VB its/PRP$ result/NN ./.)
*1*if VARz is not failure, return VARz. 
*1*(S if/IN (Chunk VARz/NNP) is/VBZ not/RB failure/JJ ,/, return/NN (Chunk VARz/NNP) ./.)
*1*call VARm(VARxr, VARd) and return its result. 
*1*(S call/NN (Chunk VARm/NNP) (/( (Chunk VARxr/NNP) ,/, (Chunk VARd/NNP) )/) and/CC return/VB its/PRP$ result/NN ./.)
*0*call VARm(VARxr, VARd) and let VARz be its result. 
*0*(S call/NN (Chunk VARm/NNP) (/( (Chunk VARxr/NNP) ,/, (Chunk VARd/NNP) )/) and/CC (Chunk let/VB VARz/NNP) be/VB its/PRP$ result/NN ./.)
*0*if VARz is not failure, return VARz. 
*0*(S if/IN (Chunk VARz/NNP) is/VBZ not/RB failure/JJ ,/, return/NN (Chunk VARz/NNP) ./.)
*0*call VARc(VARx) and return its result.      
*0*(S call/NN (Chunk VARc/NNP) (/( (Chunk VARx/NNP) )/) and/CC return/VB its/PRP$ result/NN ./.)
ID= 21.2.2.6.1
Summary= Runtime Semantics: WordCharacters ( )
*0*let VARa be a set of characters containing the sixty-three characters:      abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789_ 
*0*(S (Chunk let/VB VARa/NNP) be/VB a/DT set/NN of/IN characters/NNS containing/VBG the/DT sixty-three/JJ characters/NNS :/: abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789_/NN)
*0*let VARu be an empty set. 
*0*(S (Chunk let/VB VARu/NNP) be/VB an/DT empty/JJ set/NN ./.)
*0*for each character VARc not in set VARa where FUNCcanonicalize(VARc) is in VARa, add VARc to VARu. 
*0*(S for/IN each/DT character/NN (Chunk VARc/NNP) not/RB in/IN set/NN (Chunk VARa/NNP) where/WRB (Chunk FUNCcanonicalize/NNP) (/( (Chunk VARc/NNP) )/) is/VBZ in/IN (Chunk VARa/NNP) ,/, (Chunk add/VB VARc/NNP) to/TO (Chunk VARu/NNP) ./.)
*0*assert: unless VARunicode and VARignorecase are both true, VARu is empty. 
*0*(S assert/NN :/: unless/IN (Chunk VARunicode/NNP) and/CC (Chunk VARignorecase/NNP) are/VBP both/DT true/JJ ,/, (Chunk VARu/NNP) is/VBZ empty/JJ ./.)
*0*add the characters in set VARu to set VARa. 
*0*(S add/VB the/DT characters/NNS in/IN set/NN (Chunk VARu/NNP) to/TO (Chunk set/VB VARa/NNP) ./.)
*0*return VARa.      
*0*(S return/NN (Chunk VARa/NNP) ./.)
ID= 21.2.2.6.2
Summary= Runtime Semantics: IsWordChar ( e )
*0*if VARe is -1 or VARe is VARinputlength, return false. 
*0*(S if/IN (Chunk VARe/NNP) is/VBZ -1/JJ or/CC (Chunk VARe/NNP) (Chunk is/VBZ VARinputlength/NNP) ,/, return/NN false/JJ ./.)
*0*let VARc be the character VARinput[VARe]. 
*0*(S (Chunk let/VB VARc/NNP) be/VB the/DT character/NN (Chunk VARinput/NNP) (Chunk [/NNP) (Chunk VARe/NNP) (Chunk ]/NNP) ./.)
*0*let VARwordchars be the result of ! FUNCwordcharacters(). 
*0*(S (Chunk let/VB VARwordchars/NNP) be/VB the/DT result/NN of/IN !/. (Chunk FUNCwordcharacters/NNP) (/( )/) ./.)
*0*if VARc is in VARwordchars, return true. 
*0*(S if/IN (Chunk VARc/NNP) is/VBZ in/IN (Chunk VARwordchars/NNP) ,/, return/NN true/JJ ./.)
*0*return false.      
*0*(S return/NN false/JJ ./.)
ID= 21.2.2.8.1
Summary= Runtime Semantics: CharacterSetMatcher ( A, invert, direction )
*0*return an internal matcher closure that takes two arguments, a state VARx and a continuation VARc, and performs the following steps when evaluated:
*0*(S return/VB an/DT internal/JJ matcher/NN closure/NN that/WDT takes/VBZ two/CD arguments/NNS ,/, a/DT state/NN (Chunk VARx/NNP) and/CC a/DT continuation/NN (Chunk VARc/NNP) ,/, and/CC performs/VBZ the/DT following/JJ steps/NNS when/WRB evaluated/VBN :/:)
*1*let VARe be VARx's VARendindex. 
*1*(S (Chunk let/VB VARe/NNP) (Chunk be/VB VARx/NNP) 's/POS (Chunk VARendindex/NNP) ./.)
*1*let VARf be VARe + VARdirection. 
*1*(S (Chunk let/VB VARf/NNP) (Chunk be/VB VARe/NNP) (Chunk +/NNP) (Chunk VARdirection/NNP) ./.)
*1*if VARf &lt; 0 or VARf &gt; VARinputlength, return failure. 
*1*(S if/IN (Chunk VARf/NNP) &/CC lt/NN ;/: 0/CD or/CC (Chunk VARf/NNP) &/CC gt/NN ;/: (Chunk VARinputlength/NNP) ,/, return/NN failure/NN ./.)
*1*let VARindex be min(VARe, VARf). 
*1*(S (Chunk let/VB VARindex/NNP) be/VB min/VBN (/( (Chunk VARe/NNP) ,/, (Chunk VARf/NNP) )/) ./.)
*1*let VARch be the character VARinput[VARindex]. 
*1*(S (Chunk let/VB VARch/NNP) be/VB the/DT character/NN (Chunk VARinput/NNP) (Chunk [/NNP) (Chunk VARindex/NNP) (Chunk ]/NNP) ./.)
*1*let VARcc be FUNCcanonicalize(VARch). 
*1*(S (Chunk let/VB VARcc/NNP) (Chunk be/VB FUNCcanonicalize/NNP) (/( (Chunk VARch/NNP) )/) ./.)
*1*if VARinvert is false, then
*1*(S if/IN (Chunk VARinvert/NNP) is/VBZ false/JJ ,/, then/RB)
*2*if there does not exist a member VARa of set VARa such that FUNCcanonicalize(VARa) is VARcc, return failure. 
*2*(S if/IN there/EX does/VBZ not/RB exist/VB a/DT member/NN (Chunk VARa/NNP) of/IN (Chunk set/VBN VARa/NNP) such/JJ that/IN (Chunk FUNCcanonicalize/NNP) (/( (Chunk VARa/NNP) )/) (Chunk is/VBZ VARcc/NNP) ,/, return/NN failure/NN ./.)
*1*else,
*1*(S else/RB ,/,)
*2*assert: VARinvert is true. 
*2*(S assert/NN :/: (Chunk VARinvert/NNP) is/VBZ true/JJ ./.)
*2*if there exists a member VARa of set VARa such that FUNCcanonicalize(VARa) is VARcc, return failure. 
*2*(S if/IN there/EX exists/VBZ a/DT member/NN (Chunk VARa/NNP) of/IN (Chunk set/VBN VARa/NNP) such/JJ that/IN (Chunk FUNCcanonicalize/NNP) (/( (Chunk VARa/NNP) )/) (Chunk is/VBZ VARcc/NNP) ,/, return/NN failure/NN ./.)
*1*let VARcap be VARx's VARcaptures list. 
*1*(S (Chunk let/VB VARcap/NNP) (Chunk be/VB VARx/NNP) 's/POS (Chunk VARcaptures/NNP) list/NN ./.)
*1*let VARy be the state (VARf, VARcap). 
*1*(S (Chunk let/VB VARy/NNP) be/VB the/DT state/NN (/( (Chunk VARf/NNP) ,/, (Chunk VARcap/NNP) )/) ./.)
*1*call VARc(VARy) and return its result.      
*1*(S call/NN (Chunk VARc/NNP) (/( (Chunk VARy/NNP) )/) and/CC return/VB its/PRP$ result/NN ./.)
ID= 21.2.2.8.2
Summary= Runtime Semantics: Canonicalize ( ch )
*0*if VARignorecase is false, return VARch. 
*0*(S if/IN (Chunk VARignorecase/NNP) is/VBZ false/JJ ,/, return/JJ (Chunk VARch/NNP) ./.)
*0*if VARunicode is true, then
*0*(S if/IN (Chunk VARunicode/NNP) is/VBZ true/JJ ,/, then/RB)
*1*if the file casefolding.txt of the unicode character database provides a simple or common case folding mapping for VARch, return the result of applying that mapping to VARch. 
*1*(S if/IN the/DT file/NN casefolding.txt/NN of/IN the/DT unicode/JJ character/NN database/NN provides/VBZ a/DT simple/JJ or/CC common/JJ case/NN folding/VBG mapping/NN for/IN (Chunk VARch/NNP) ,/, return/VBP the/DT result/NN of/IN applying/VBG that/IN mapping/VBG to/TO (Chunk VARch/NNP) ./.)
*1*return VARch. 
*1*(S return/NN (Chunk VARch/NNP) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*assert: VARch is a utf-16 code unit. 
*1*(S assert/NN :/: (Chunk VARch/NNP) is/VBZ a/DT utf-16/JJ code/NN unit/NN ./.)
*1*let VARs be the string value consisting of the single code unit VARch. 
*1*(S (Chunk let/VB VARs/NNP) be/VB the/DT string/VBG value/NN consisting/NN of/IN the/DT single/JJ code/NN unit/NN (Chunk VARch/NNP) ./.)
*1*let VARu be the same result produced as if by performing the algorithm for string.prototype.touppercase using VARs as the this value. 
*1*(S (Chunk let/VB VARu/NNP) be/VB the/DT same/JJ result/NN produced/VBN as/IN if/IN by/IN performing/VBG the/DT algorithm/NN for/IN string.prototype.touppercase/NN (Chunk using/VBG VARs/NNP) as/IN the/DT this/DT value/NN ./.)
*1*assert: VARu is a string value. 
*1*(S assert/NN :/: (Chunk VARu/NNP) is/VBZ a/DT string/VBG value/NN ./.)
*1*if VARu does not consist of a single code unit, return VARch. 
*1*(S if/IN (Chunk VARu/NNP) does/VBZ not/RB consist/VB of/IN a/DT single/JJ code/NN unit/NN ,/, return/NN (Chunk VARch/NNP) ./.)
*1*let VARcu be VARu's single code unit element. 
*1*(S (Chunk let/VB VARcu/NNP) (Chunk be/VB VARu/NNP) 's/POS single/JJ code/NN unit/NN element/NN ./.)
*1*if the numeric value of VARch ≥ 128 and the numeric value of VARcu &lt; 128, return VARch. 
*1*(S if/IN the/DT numeric/JJ value/NN of/IN (Chunk VARch/NNP) (Chunk ≥/NNP) 128/CD and/CC the/DT numeric/JJ value/NN of/IN (Chunk VARcu/NNP) &/CC lt/NN ;/: 128/CD ,/, return/NN (Chunk VARch/NNP) ./.)
*1*return VARcu.      
*1*(S return/NN (Chunk VARcu/NNP) ./.)
ID= 21.2.2.8.3
Summary= Runtime Semantics: UnicodeMatchProperty ( p )
*0*assert: VARp is a list of unicode code points that is identical to a list of unicode code points that is a unicode property name or property alias listed in the “property name and aliases” column of table 51 or table 52. 
*0*(S assert/NN :/: (Chunk VARp/NNP) is/VBZ a/DT list/NN of/IN unicode/JJ code/NN points/NNS that/WDT is/VBZ identical/JJ to/TO a/DT list/NN of/IN unicode/JJ code/NN points/NNS that/WDT is/VBZ a/DT unicode/JJ property/NN name/NN or/CC property/NN alias/NNS listed/VBN in/IN the/DT (Chunk “/NNP) property/NN name/NN and/CC aliases/VBZ ”/JJ column/NN of/IN table/JJ 51/CD or/CC table/JJ 52/CD ./.)
*0*let VARc be the canonical property name of VARp as given in the “canonical property name” column of the corresponding row. 
*0*(S (Chunk let/VB VARc/NNP) be/VB the/DT canonical/JJ property/NN name/NN of/IN (Chunk VARp/NNP) as/IN given/VBN in/IN the/DT (Chunk “/NNP) canonical/JJ property/NN name/NN (Chunk ”/NNP) column/NN of/IN the/DT corresponding/JJ row/NN ./.)
*0*return the list of unicode code points of VARc.      
*0*(S return/VB the/DT list/NN of/IN unicode/JJ code/NN points/NNS of/IN (Chunk VARc/NNP) ./.)
ID= 21.2.2.8.4
Summary= Runtime Semantics: UnicodeMatchPropertyValue ( p, v )
*0*assert: VARp is a list of unicode code points that is identical to a list of unicode code points that is a canonical, unaliased unicode property name listed in the “canonical property name” column of table 51. 
*0*(S assert/NN :/: (Chunk VARp/NNP) is/VBZ a/DT list/NN of/IN unicode/JJ code/NN points/NNS that/WDT is/VBZ identical/JJ to/TO a/DT list/NN of/IN unicode/JJ code/NN points/NNS that/WDT is/VBZ a/DT canonical/JJ ,/, unaliased/JJ unicode/JJ property/NN name/NN listed/VBN in/IN the/DT (Chunk “/NNP) canonical/JJ property/NN name/NN (Chunk ”/NNP) column/NN of/IN table/JJ 51/CD ./.)
*0*assert: VARv is a list of unicode code points that is identical to a list of unicode code points that is a property value or property value alias for unicode property VARp listed in the “property value and aliases” column of table 53 or table 54. 
*0*(S assert/NN :/: (Chunk VARv/NNP) is/VBZ a/DT list/NN of/IN unicode/JJ code/NN points/NNS that/WDT is/VBZ identical/JJ to/TO a/DT list/NN of/IN unicode/JJ code/NN points/NNS that/WDT is/VBZ a/DT property/NN value/NN or/CC property/NN value/NN alias/NN for/IN unicode/JJ property/NN (Chunk VARp/NNP) listed/VBN in/IN the/DT (Chunk “/NNP) property/NN value/NN and/CC aliases/VBZ ”/JJ column/NN of/IN table/JJ 53/CD or/CC table/JJ 54/CD ./.)
*0*let VARvalue be the canonical property value of VARv as given in the “canonical property value” column of the corresponding row. 
*0*(S (Chunk let/VB VARvalue/NNP) be/VB the/DT canonical/JJ property/NN value/NN of/IN (Chunk VARv/NNP) as/IN given/VBN in/IN the/DT (Chunk “/NNP) canonical/JJ property/NN value/NN (Chunk ”/NNP) column/NN of/IN the/DT corresponding/JJ row/NN ./.)
*0*return the list of unicode code points of VARvalue.      
*0*(S return/VB the/DT list/NN of/IN unicode/JJ code/NN points/NNS of/IN (Chunk VARvalue/NNP) ./.)
ID= 21.2.2.9.1
Summary= Runtime Semantics: BackreferenceMatcher ( n, direction )
*0*return an internal matcher closure that takes two arguments, a state VARx and a continuation VARc, and performs the following steps:
*0*(S return/VB an/DT internal/JJ matcher/NN closure/NN that/WDT takes/VBZ two/CD arguments/NNS ,/, a/DT state/NN (Chunk VARx/NNP) and/CC a/DT continuation/NN (Chunk VARc/NNP) ,/, and/CC performs/VBZ the/DT following/JJ steps/NNS :/:)
*1*let VARcap be VARx's VARcaptures list. 
*1*(S (Chunk let/VB VARcap/NNP) (Chunk be/VB VARx/NNP) 's/POS (Chunk VARcaptures/NNP) list/NN ./.)
*1*let VARs be VARcap[VARn]. 
*1*(S (Chunk let/VB VARs/NNP) (Chunk be/VB VARcap/NNP) (Chunk [/NNP) (Chunk VARn/NNP) (Chunk ]/NNP) ./.)
*1*if VARs is undefined, return VARc(VARx). 
*1*(S if/IN (Chunk VARs/NNP) is/VBZ undefined/JJ ,/, (Chunk return/VB VARc/NNP) (/( (Chunk VARx/NNP) )/) ./.)
*1*let VARe be VARx's VARendindex. 
*1*(S (Chunk let/VB VARe/NNP) (Chunk be/VB VARx/NNP) 's/POS (Chunk VARendindex/NNP) ./.)
*1*let VARlen be the number of elements in VARs. 
*1*(S (Chunk let/VB VARlen/NNP) be/VB the/DT number/NN of/IN elements/NNS in/IN (Chunk VARs/NNP) ./.)
*1*let VARf be VARe + VARdirection × VARlen. 
*1*(S (Chunk let/VB VARf/NNP) (Chunk be/VB VARe/NNP) (Chunk +/NNP) (Chunk VARdirection/NNP) (Chunk ×/NNP) (Chunk VARlen/NNP) ./.)
*1*if VARf &lt; 0 or VARf &gt; VARinputlength, return failure. 
*1*(S if/IN (Chunk VARf/NNP) &/CC lt/NN ;/: 0/CD or/CC (Chunk VARf/NNP) &/CC gt/NN ;/: (Chunk VARinputlength/NNP) ,/, return/NN failure/NN ./.)
*1*let VARg be min(VARe, VARf). 
*1*(S (Chunk let/VB VARg/NNP) be/VB min/VBN (/( (Chunk VARe/NNP) ,/, (Chunk VARf/NNP) )/) ./.)
*1*if there exists an integer VARi between 0 (inclusive) and VARlen (exclusive) such that FUNCcanonicalize(VARs[VARi]) is not the same character value as FUNCcanonicalize(VARinput[VARg + VARi]), return failure. 
*1*(S if/IN there/EX exists/VBZ an/DT integer/NN (Chunk VARi/NNP) between/IN 0/CD (/( inclusive/JJ )/) and/CC (Chunk VARlen/NNP) (/( exclusive/JJ )/) such/JJ that/IN (Chunk FUNCcanonicalize/NNP) (/( (Chunk VARs/NNP) (Chunk [/NNP) (Chunk VARi/NNP) (Chunk ]/NNP) )/) is/VBZ not/RB the/DT same/JJ character/NN value/NN as/IN (Chunk FUNCcanonicalize/NNP) (/( (Chunk VARinput/NNP) (Chunk [/NNP) (Chunk VARg/NNP) (Chunk +/NNP) (Chunk VARi/NNP) (Chunk ]/NNP) )/) ,/, return/JJ failure/NN ./.)
*1*let VARy be the state (VARf, VARcap). 
*1*(S (Chunk let/VB VARy/NNP) be/VB the/DT state/NN (/( (Chunk VARf/NNP) ,/, (Chunk VARcap/NNP) )/) ./.)
*1*call VARc(VARy) and return its result.      
*1*(S call/NN (Chunk VARc/NNP) (/( (Chunk VARy/NNP) )/) and/CC return/VB its/PRP$ result/NN ./.)
ID= 21.2.2.15.1
Summary= Runtime Semantics: CharacterRange ( A, B )
*0*assert: VARa and VARb each contain exactly one character. 
*0*(S assert/NN :/: (Chunk VARa/NNP) and/CC (Chunk VARb/NNP) each/DT contain/NN exactly/RB one/CD character/NN ./.)
*0*let VARa be the one character in charset VARa. 
*0*(S (Chunk let/VB VARa/NNP) be/VB the/DT one/CD character/NN in/IN charset/NN (Chunk VARa/NNP) ./.)
*0*let VARb be the one character in charset VARb. 
*0*(S (Chunk let/VB VARb/NNP) be/VB the/DT one/CD character/NN in/IN charset/NN (Chunk VARb/NNP) ./.)
*0*let VARi be the character value of character VARa. 
*0*(S (Chunk let/VB VARi/NNP) be/VB the/DT character/NN value/NN of/IN character/NN (Chunk VARa/NNP) ./.)
*0*let VARj be the character value of character VARb. 
*0*(S (Chunk let/VB VARj/NNP) be/VB the/DT character/NN value/NN of/IN character/NN (Chunk VARb/NNP) ./.)
*0*assert: VARi ≤ VARj. 
*0*(S assert/NN :/: (Chunk VARi/NNP) (Chunk ≤/NNP) (Chunk VARj/NNP) ./.)
*0*return the set containing all characters numbered VARi through VARj, inclusive.      
*0*(S return/VB the/DT set/NN containing/VBG all/DT characters/NNS (Chunk numbered/VBD VARi/NNP) through/IN (Chunk VARj/NNP) ,/, inclusive/NN ./.)
ID= 21.2.3.1
Summary= RegExp ( pattern, flags )
*0*let VARpatternisregexp be ? FUNCisregexp(VARpattern). 
*0*(S (Chunk let/VB VARpatternisregexp/NNP) be/VB ?/. (Chunk FUNCisregexp/NNP) (/( (Chunk VARpattern/NNP) )/) ./.)
*0*if newtarget is undefined, then
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, then/RB)
*1*let VARnewtarget be the active function object. 
*1*(S (Chunk let/VB VARnewtarget/NNP) be/VB the/DT active/JJ function/NN object/NN ./.)
*1*if VARpatternisregexp is true and VARflags is undefined, then
*1*(S if/IN (Chunk VARpatternisregexp/NNP) is/VBZ true/JJ and/CC (Chunk VARflags/NNP) is/VBZ undefined/VBN ,/, then/RB)
*2*let VARpatternconstructor be ? FUNCget(VARpattern, "constructor"). 
*2*(S (Chunk let/VB VARpatternconstructor/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARpattern/NNP) ,/, ``/`` constructor/NN ''/'' )/) ./.)
*2*if FUNCsamevalue(VARnewtarget, VARpatternconstructor) is true, return VARpattern. 
*2*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARnewtarget/NNP) ,/, (Chunk VARpatternconstructor/NNP) )/) is/VBZ true/JJ ,/, return/JJ (Chunk VARpattern/NNP) ./.)
*0*else, let VARnewtarget be newtarget. 
*0*(S else/RB ,/, (Chunk let/VB VARnewtarget/NNP) be/VB newtarget/VBN ./.)
*0*if FUNCtype(VARpattern) is object and VARpattern has a [[REGEXPMATCHER]] internal slot, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARpattern/NNP) )/) is/VBZ object/JJ and/CC (Chunk VARpattern/NNP) has/VBZ a/DT [/JJ [/NN (Chunk REGEXPMATCHER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, then/RB)
*1*let VARp be VARpattern.[[ORIGINALSOURCE]]. 
*1*(S (Chunk let/VB VARp/NNP) (Chunk be/VB VARpattern/NNP) ./. [/VB [/JJ (Chunk ORIGINALSOURCE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*if VARflags is undefined, let VARf be VARpattern.[[ORIGINALFLAGS]]. 
*1*(S if/IN (Chunk VARflags/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARf/NNP) (Chunk be/VB VARpattern/NNP) ./. [/VB [/JJ (Chunk ORIGINALFLAGS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*else, let VARf be VARflags. 
*1*(S else/RB ,/, (Chunk let/VB VARf/NNP) (Chunk be/VB VARflags/NNP) ./.)
*0*else if VARpatternisregexp is true, then
*0*(S else/RB if/IN (Chunk VARpatternisregexp/NNP) is/VBZ true/JJ ,/, then/RB)
*1*let VARp be ? FUNCget(VARpattern, "source"). 
*1*(S (Chunk let/VB VARp/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARpattern/NNP) ,/, ``/`` source/NN ''/'' )/) ./.)
*1*if VARflags is undefined, then
*1*(S if/IN (Chunk VARflags/NNP) is/VBZ undefined/VBN ,/, then/RB)
*2*let VARf be ? FUNCget(VARpattern, "flags"). 
*2*(S (Chunk let/VB VARf/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARpattern/NNP) ,/, ``/`` flags/NNS ''/'' )/) ./.)
*1*else, let VARf be VARflags. 
*1*(S else/RB ,/, (Chunk let/VB VARf/NNP) (Chunk be/VB VARflags/NNP) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARp be VARpattern. 
*1*(S (Chunk let/VB VARp/NNP) (Chunk be/VB VARpattern/NNP) ./.)
*1*let VARf be VARflags. 
*1*(S (Chunk let/VB VARf/NNP) (Chunk be/VB VARflags/NNP) ./.)
*0*let VARo be ? FUNCregexpalloc(VARnewtarget). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCregexpalloc/NNP) (/( (Chunk VARnewtarget/NNP) )/) ./.)
*0*return ? FUNCregexpinitialize(VARo, VARp, VARf).     
*0*(S return/NN ?/. (Chunk FUNCregexpinitialize/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARf/NNP) )/) ./.)
ID= 21.2.3.2.1
Summary= Runtime Semantics: RegExpAlloc ( newTarget )
*0*let VARobj be ? FUNCordinarycreatefromconstructor(VARnewtarget, "%regexpprototype%", « [[REGEXPMATCHER]], [[ORIGINALSOURCE]], [[ORIGINALFLAGS]] »). 
*0*(S (Chunk let/VB VARobj/NNP) be/VB ?/. (Chunk FUNCordinarycreatefromconstructor/NNP) (/( (Chunk VARnewtarget/NNP) ,/, ``/`` %/NN regexpprototype/NN %/NN ''/'' ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk REGEXPMATCHER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ORIGINALSOURCE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ORIGINALFLAGS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*perform ! FUNCdefinepropertyorthrow(VARobj, "lastindex", propertydescriptor { [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }). 
*0*(S perform/NN !/. (Chunk FUNCdefinepropertyorthrow/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` lastindex/NN ''/'' ,/, propertydescriptor/NN {/( [/JJ (Chunk [/NNP) (Chunk WRITABLE/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk ENUMERABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ ,/, [/JJ (Chunk [/NNP) (Chunk CONFIGURABLE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) )/) ./.)
*0*return VARobj.      
*0*(S return/NN (Chunk VARobj/NNP) ./.)
ID= 21.2.3.2.2
Summary= Runtime Semantics: RegExpInitialize ( obj, pattern, flags )
*0*if VARpattern is undefined, let VARp be the empty string. 
*0*(S if/IN (Chunk VARpattern/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARp/NNP) be/VB the/DT empty/JJ string/NN ./.)
*0*else, let VARp be ? FUNCtostring(VARpattern). 
*0*(S else/RB ,/, (Chunk let/VB VARp/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARpattern/NNP) )/) ./.)
*0*if VARflags is undefined, let VARf be the empty string. 
*0*(S if/IN (Chunk VARflags/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARf/NNP) be/VB the/DT empty/JJ string/NN ./.)
*0*else, let VARf be ? FUNCtostring(VARflags). 
*0*(S else/RB ,/, (Chunk let/VB VARf/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARflags/NNP) )/) ./.)
*0*if VARf contains any code unit other than "g", "i", "m", "s", "u", or "y" or if it contains the same code unit more than once, throw a syntaxerror exception. 
*0*(S if/IN (Chunk VARf/NNP) contains/VBZ any/DT code/NN unit/NN other/JJ than/IN ``/`` g/JJ ''/'' ,/, ``/`` i/NN ''/'' ,/, ``/`` m/NN ''/'' ,/, ``/`` s/NN ''/'' ,/, ``/`` u/JJ ''/'' ,/, or/CC ``/`` y/JJ ''/'' or/CC if/IN it/PRP contains/VBZ the/DT same/JJ code/NN unit/NN more/RBR than/IN once/RB ,/, throw/VB a/DT syntaxerror/NN exception/NN ./.)
*0*if VARf contains "u", let VARbmp be false; else let VARbmp be true. 
*0*(S if/IN (Chunk VARf/NNP) contains/VBZ ``/`` u/JJ ''/'' ,/, (Chunk let/VB VARbmp/NNP) be/VB false/JJ ;/: else/JJ (Chunk let/VB VARbmp/NNP) be/VB true/JJ ./.)
*0*if VARbmp is true, then
*0*(S if/IN (Chunk VARbmp/NNP) is/VBZ true/JJ ,/, then/RB)
*1*parse VARp using the grammars in 21.2.1 and interpreting each of its 16-bit elements as a unicode bmp code point. utf-16 decoding is not applied to the elements. the goal symbol for the parse is pattern[~u, ~n]. if the result of parsing contains a groupname, reparse with the goal symbol pattern[~u, +n] and use this result instead. throw a syntaxerror exception if VARp did not conform to the grammar, if any elements of VARp were not matched by the parse, or if any early error conditions exist. 
*1*(S parse/NN (Chunk VARp/NNP) using/VBG the/DT grammars/NNS in/IN 21.2.1/CD and/CC interpreting/VBG each/DT of/IN its/PRP$ 16-bit/JJ elements/NNS as/IN a/DT unicode/JJ bmp/NN code/NN point/NN ./. utf-16/JJ decoding/NN is/VBZ not/RB applied/VBN to/TO the/DT elements/NNS ./. the/DT goal/NN symbol/NN for/IN the/DT parse/NN is/VBZ pattern/JJ (Chunk [/NNP) (Chunk ~u/NNP) ,/, (Chunk ~n/NNP) (Chunk ]/NNP) ./. if/IN the/DT result/NN of/IN parsing/VBG contains/NNS a/DT groupname/NN ,/, reparse/NN with/IN the/DT goal/NN symbol/NN pattern/NN (Chunk [/NNP) (Chunk ~u/NNP) ,/, (Chunk +n/NNP) (Chunk ]/NNP) and/CC use/VB this/DT result/NN instead/RB ./. throw/VB a/DT syntaxerror/NN exception/NN if/IN (Chunk VARp/NNP) did/VBD not/RB conform/VB to/TO the/DT grammar/NN ,/, if/IN any/DT elements/NNS of/IN (Chunk VARp/NNP) were/VBD not/RB matched/VBN by/IN the/DT parse/NN ,/, or/CC if/IN any/DT early/JJ error/NN conditions/NNS exist/VBP ./.)
*1*let VARpatterncharacters be a list whose elements are the code unit elements of VARp. 
*1*(S (Chunk let/VB VARpatterncharacters/NNP) be/VB a/DT list/NN whose/WP$ elements/NNS are/VBP the/DT code/NN unit/NN elements/NNS of/IN (Chunk VARp/NNP) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*parse VARp using the grammars in 21.2.1 and interpreting VARp as utf-16 encoded unicode code points (6.1.4). the goal symbol for the parse is pattern[+u, +n]. throw a syntaxerror exception if VARp did not conform to the grammar, if any elements of VARp were not matched by the parse, or if any early error conditions exist. 
*1*(S parse/NN (Chunk VARp/NNP) using/VBG the/DT grammars/NNS in/IN 21.2.1/CD and/CC (Chunk interpreting/VBG VARp/NNP) as/IN utf-16/JJ encoded/VBD unicode/JJ code/NN points/NNS (/( 6.1.4/CD )/) ./. the/DT goal/NN symbol/NN for/IN the/DT parse/NN is/VBZ pattern/JJ (Chunk [/NNP) (Chunk +u/NNP) ,/, (Chunk +n/NNP) (Chunk ]/NNP) ./. throw/VB a/DT syntaxerror/NN exception/NN if/IN (Chunk VARp/NNP) did/VBD not/RB conform/VB to/TO the/DT grammar/NN ,/, if/IN any/DT elements/NNS of/IN (Chunk VARp/NNP) were/VBD not/RB matched/VBN by/IN the/DT parse/NN ,/, or/CC if/IN any/DT early/JJ error/NN conditions/NNS exist/VBP ./.)
*1*let VARpatterncharacters be a list whose elements are the code points resulting from applying utf-16 decoding to VARp's sequence of elements. 
*1*(S (Chunk let/VB VARpatterncharacters/NNP) be/VB a/DT list/NN whose/WP$ elements/NNS are/VBP the/DT code/NN points/NNS resulting/VBG from/IN applying/VBG utf-16/JJ decoding/NN to/TO (Chunk VARp/NNP) 's/POS sequence/NN of/IN elements/NNS ./.)
*0*set VARobj.[[ORIGINALSOURCE]] to VARp. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk ORIGINALSOURCE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARp/NNP) ./.)
*0*set VARobj.[[ORIGINALFLAGS]] to VARf. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk ORIGINALFLAGS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARf/NNP) ./.)
*0*set VARobj.[[REGEXPMATCHER]] to the internal procedure that evaluates the above parse of VARp by applying the semantics provided in 21.2.2 using VARpatterncharacters as the pattern's list of sourcecharacter values and VARf as the flag parameters. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk REGEXPMATCHER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO the/DT internal/JJ procedure/NN that/WDT evaluates/VBZ the/DT above/JJ parse/NN of/IN (Chunk VARp/NNP) by/IN applying/VBG the/DT semantics/NNS provided/VBD in/IN 21.2.2/CD using/VBG VARpatterncharacters/NNS as/IN the/DT pattern/NN 's/POS list/NN of/IN sourcecharacter/NN values/NNS and/CC (Chunk VARf/NNP) as/IN the/DT flag/NN parameters/NNS ./.)
*0*perform ? FUNCset(VARobj, "lastindex", 0, true). 
*0*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` lastindex/NN ''/'' ,/, 0/CD ,/, true/JJ )/) ./.)
*0*return VARobj.      
*0*(S return/NN (Chunk VARobj/NNP) ./.)
ID= 21.2.3.2.3
Summary= Runtime Semantics: RegExpCreate ( P, F )
*0*let VARobj be ? FUNCregexpalloc(%regexp%). 
*0*(S (Chunk let/VB VARobj/NNP) be/VB ?/. (Chunk FUNCregexpalloc/NNP) (/( %/NN regexp/NN %/NN )/) ./.)
*0*return ? FUNCregexpinitialize(VARobj, VARp, VARf).      
*0*(S return/NN ?/. (Chunk FUNCregexpinitialize/NNP) (/( (Chunk VARobj/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARf/NNP) )/) ./.)
ID= 21.2.3.2.4
Summary= Runtime Semantics: EscapeRegExpPattern ( P, F )
*0*let VARs be a string in the form of a pattern[~u] (pattern[+u] if VARf contains "u") equivalent to VARp interpreted as utf-16 encoded unicode code points (6.1.4), in which certain code points are escaped as described below. VARs may or may not be identical to VARp; however, the internal procedure that would result from evaluating VARs as a pattern[~u] (pattern[+u] if VARf contains "u") must behave identically to the internal procedure given by the constructed object's [[REGEXPMATCHER]] internal slot. multiple calls to this abstract operation using the same values for VARp and VARf must produce identical results. 
*0*(S (Chunk let/VB VARs/NNP) be/VB a/DT string/NN in/IN the/DT form/NN of/IN a/DT pattern/NN (Chunk [/NNP) (Chunk ~u/NNP) (Chunk ]/NNP) (/( pattern/JJ (Chunk [/NNP) (Chunk +u/NNP) (Chunk ]/NNP) if/IN (Chunk VARf/NNP) contains/VBZ ``/`` u/JJ ''/'' )/) equivalent/NN to/TO (Chunk VARp/NNP) interpreted/VBN as/IN utf-16/JJ encoded/VBD unicode/JJ code/NN points/NNS (/( 6.1.4/CD )/) ,/, in/IN which/WDT certain/JJ code/NN points/NNS are/VBP escaped/VBN as/IN described/VBN below/IN ./. (Chunk VARs/NNP) may/MD or/CC may/MD not/RB be/VB identical/JJ to/TO (Chunk VARp/NNP) ;/: however/RB ,/, the/DT internal/JJ procedure/NN that/WDT would/MD result/VB from/IN (Chunk evaluating/VBG VARs/NNP) as/IN a/DT pattern/NN (Chunk [/NNP) (Chunk ~u/NNP) (Chunk ]/NNP) (/( pattern/JJ (Chunk [/NNP) (Chunk +u/NNP) (Chunk ]/NNP) if/IN (Chunk VARf/NNP) contains/VBZ ``/`` u/JJ ''/'' )/) must/MD behave/VB identically/RB to/TO the/DT internal/JJ procedure/NN given/VBN by/IN the/DT constructed/JJ object/NN 's/POS (Chunk [/NNP) (Chunk [/NNP) (Chunk REGEXPMATCHER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./. multiple/JJ calls/VBZ to/TO this/DT abstract/JJ operation/NN using/VBG the/DT same/JJ values/NNS for/IN (Chunk VARp/NNP) and/CC (Chunk VARf/NNP) must/MD produce/VB identical/JJ results/NNS ./.)
*0*the code points / or any lineterminator occurring in the pattern shall be escaped in VARs as necessary to ensure that the string-concatenation of "/", VARs, "/", and VARf can be parsed (in an appropriate lexical context) as a regularexpressionliteral that behaves identically to the constructed regular expression. for example, if VARp is "/", then VARs could be "\/" or "\u002f", among other possibilities, but not "/", because /// followed by VARf would be parsed as a singlelinecomment rather than a regularexpressionliteral. if VARp is the empty string, this specification can be met by letting VARs be "(?:)". 
*0*(S the/DT code/NN points/NNS //CD or/CC any/DT lineterminator/NN occurring/VBG in/IN the/DT pattern/NN shall/MD be/VB escaped/VBN in/IN (Chunk VARs/NNP) as/IN necessary/JJ to/TO ensure/VB that/IN the/DT string-concatenation/NN of/IN ``/`` //JJ ''/'' ,/, (Chunk VARs/NNP) ,/, ``/`` //NN ''/'' ,/, and/CC (Chunk VARf/NNP) can/MD be/VB parsed/VBN (/( in/IN an/DT appropriate/JJ lexical/JJ context/NN )/) as/IN a/DT regularexpressionliteral/JJ that/WDT behaves/VBZ identically/RB to/TO the/DT constructed/VBN regular/JJ expression/NN ./. for/IN example/NN ,/, if/IN (Chunk VARp/NNP) is/VBZ ``/`` //JJ ''/'' ,/, (Chunk then/RB VARs/NNP) could/MD be/VB ``/`` \//JJ ''/'' or/CC ``/`` \u002f/JJ ''/'' ,/, among/IN other/JJ possibilities/NNS ,/, but/CC not/RB ``/`` //JJ ''/'' ,/, because/IN ////NN followed/VBN by/IN (Chunk VARf/NNP) would/MD be/VB parsed/VBN as/IN a/DT singlelinecomment/NN rather/RB than/IN a/DT regularexpressionliteral/JJ ./. if/IN (Chunk VARp/NNP) is/VBZ the/DT empty/JJ string/NN ,/, this/DT specification/NN can/MD be/VB met/VBN by/IN (Chunk letting/VBG VARs/NNP) be/VB ``/`` (/( ?/. :/: )/) ''/'' ./.)
*0*return VARs.      
*0*(S return/NN (Chunk VARs/NNP) ./.)
ID= 21.2.5.2
Summary= RegExp.prototype.exec ( string )
*0*let VARr be the this value. 
*0*(S (Chunk let/VB VARr/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARr) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARr/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARr does not have a [[REGEXPMATCHER]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARr/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk REGEXPMATCHER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARs be ? FUNCtostring(VARstring). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( VARstring/VBG )/) ./.)
*0*return ? FUNCregexpbuiltinexec(VARr, VARs).     
*0*(S return/NN ?/. (Chunk FUNCregexpbuiltinexec/NNP) (/( (Chunk VARr/NNP) ,/, (Chunk VARs/NNP) )/) ./.)
ID= 21.2.5.2.1
Summary= Runtime Semantics: RegExpExec ( R, S )
*0*assert: FUNCtype(VARr) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARr/NNP) )/) is/VBZ object/JJ ./.)
*0*assert: FUNCtype(VARs) is string. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARs/NNP) )/) is/VBZ string/VBG ./.)
*0*let VARexec be ? FUNCget(VARr, "exec"). 
*0*(S (Chunk let/VB VARexec/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARr/NNP) ,/, ``/`` exec/NN ''/'' )/) ./.)
*0*if FUNCiscallable(VARexec) is true, then
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARexec/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*let VARresult be ? FUNCcall(VARexec, VARr, « VARs »). 
*1*(S (Chunk let/VB VARresult/NNP) be/VB ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARexec/NNP) ,/, (Chunk VARr/NNP) ,/, (Chunk «/NNP) (Chunk VARs/NNP) (Chunk »/NNP) )/) ./.)
*1*if FUNCtype(VARresult) is neither object or null, throw a typeerror exception. 
*1*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARresult/NNP) )/) is/VBZ neither/JJ object/NN or/CC null/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*return VARresult. 
*1*(S return/NN (Chunk VARresult/NNP) ./.)
*0*if VARr does not have a [[REGEXPMATCHER]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARr/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk REGEXPMATCHER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return ? FUNCregexpbuiltinexec(VARr, VARs).      
*0*(S return/NN ?/. (Chunk FUNCregexpbuiltinexec/NNP) (/( (Chunk VARr/NNP) ,/, (Chunk VARs/NNP) )/) ./.)
ID= 21.2.5.2.2
Summary= Runtime Semantics: RegExpBuiltinExec ( R, S )
*0*assert: VARr is an initialized regexp instance. 
*0*(S assert/NN :/: (Chunk VARr/NNP) is/VBZ an/DT initialized/JJ regexp/NN instance/NN ./.)
*0*assert: FUNCtype(VARs) is string. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARs/NNP) )/) is/VBZ string/VBG ./.)
*0*let VARlength be the number of code units in VARs. 
*0*(S (Chunk let/VB VARlength/NNP) be/VB the/DT number/NN of/IN code/JJ units/NNS in/IN (Chunk VARs/NNP) ./.)
*0*let VARlastindex be ? FUNCtolength(? FUNCget(VARr, "lastindex")). 
*0*(S (Chunk let/VB VARlastindex/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARr/NNP) ,/, ``/`` lastindex/NN ''/'' )/) )/) ./.)
*0*let VARflags be VARr.[[ORIGINALFLAGS]]. 
*0*(S (Chunk let/VB VARflags/NNP) (Chunk be/VB VARr/NNP) ./. [/VB [/JJ (Chunk ORIGINALFLAGS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARflags contains "g", let VARglobal be true, else let VARglobal be false. 
*0*(S if/IN (Chunk VARflags/NNP) contains/VBZ ``/`` g/NN ''/'' ,/, (Chunk let/VB VARglobal/NNP) be/VB true/JJ ,/, else/JJ let/NN (Chunk VARglobal/NNP) be/VB false/JJ ./.)
*0*if VARflags contains "y", let VARsticky be true, else let VARsticky be false. 
*0*(S if/IN (Chunk VARflags/NNP) contains/VBZ ``/`` y/NN ''/'' ,/, (Chunk let/VB VARsticky/NNP) be/VB true/JJ ,/, else/JJ let/NN (Chunk VARsticky/NNP) be/VB false/JJ ./.)
*0*if VARglobal is false and VARsticky is false, set VARlastindex to 0. 
*0*(S if/IN (Chunk VARglobal/NNP) is/VBZ false/JJ and/CC (Chunk VARsticky/NNP) is/VBZ false/JJ ,/, (Chunk set/VBN VARlastindex/NNP) to/TO 0/CD ./.)
*0*let VARmatcher be VARr.[[REGEXPMATCHER]]. 
*0*(S (Chunk let/VB VARmatcher/NNP) (Chunk be/VB VARr/NNP) ./. [/VB [/JJ (Chunk REGEXPMATCHER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARflags contains "u", let VARfullunicode be true, else let VARfullunicode be false. 
*0*(S if/IN (Chunk VARflags/NNP) contains/VBZ ``/`` u/JJ ''/'' ,/, (Chunk let/VB VARfullunicode/NNP) be/VB true/JJ ,/, else/JJ let/NN (Chunk VARfullunicode/NNP) be/VB false/JJ ./.)
*0*let VARmatchsucceeded be false. 
*0*(S (Chunk let/VB VARmatchsucceeded/NNP) be/VB false/JJ ./.)
*0*repeat, while VARmatchsucceeded is false
*0*(S repeat/NN ,/, while/IN VARmatchsucceeded/VBN is/VBZ false/JJ)
*1*if VARlastindex &gt; VARlength, then
*1*(S if/IN (Chunk VARlastindex/NNP) &/CC gt/NN ;/: (Chunk VARlength/NNP) ,/, then/RB)
*2*if VARglobal is true or VARsticky is true, then
*2*(S if/IN (Chunk VARglobal/NNP) is/VBZ true/JJ or/CC (Chunk VARsticky/NNP) is/VBZ true/JJ ,/, then/RB)
*3*perform ? FUNCset(VARr, "lastindex", 0, true). 
*3*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARr/NNP) ,/, ``/`` lastindex/NN ''/'' ,/, 0/CD ,/, true/JJ )/) ./.)
*2*return null. 
*2*(S return/NN null/NN ./.)
*1*let VARr be VARmatcher(VARs, VARlastindex). 
*1*(S (Chunk let/VB VARr/NNP) (Chunk be/VB VARmatcher/NNP) (/( (Chunk VARs/NNP) ,/, (Chunk VARlastindex/NNP) )/) ./.)
*1*if VARr is failure, then
*1*(S if/IN (Chunk VARr/NNP) is/VBZ failure/NN ,/, then/RB)
*2*if VARsticky is true, then
*2*(S if/IN (Chunk VARsticky/NNP) is/VBZ true/JJ ,/, then/RB)
*3*perform ? FUNCset(VARr, "lastindex", 0, true). 
*3*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARr/NNP) ,/, ``/`` lastindex/NN ''/'' ,/, 0/CD ,/, true/JJ )/) ./.)
*3*return null. 
*3*(S return/NN null/NN ./.)
*2*set VARlastindex to FUNCadvancestringindex(VARs, VARlastindex, VARfullunicode). 
*2*(S set/VBN VARlastindex/NN to/TO (Chunk FUNCadvancestringindex/NNP) (/( (Chunk VARs/NNP) ,/, (Chunk VARlastindex/NNP) ,/, (Chunk VARfullunicode/NNP) )/) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*assert: VARr is a state. 
*2*(S assert/NN :/: (Chunk VARr/NNP) is/VBZ a/DT state/NN ./.)
*2*set VARmatchsucceeded to true. 
*2*(S set/NN VARmatchsucceeded/VBD to/TO true/JJ ./.)
*0*let VARe be VARr's VARendindex value. 
*0*(S (Chunk let/VB VARe/NNP) (Chunk be/VB VARr/NNP) 's/POS (Chunk VARendindex/NNP) value/NN ./.)
*0*if VARfullunicode is true, then
*0*(S if/IN (Chunk VARfullunicode/NNP) is/VBZ true/JJ ,/, then/RB)
*1*VARe is an index into the VARinput character list, derived from VARs, matched by VARmatcher. let VAReutf be the smallest index into VARs that corresponds to the character at element VARe of VARinput. if VARe is greater than or equal to the number of elements in VARinput, then VAReutf is the number of code units in VARs. 
*1*(S (Chunk VARe/NNP) is/VBZ an/DT index/NN into/IN the/DT (Chunk VARinput/NNP) character/NN list/NN ,/, derived/VBN from/IN (Chunk VARs/NNP) ,/, matched/VBN by/IN (Chunk VARmatcher/NNP) ./. (Chunk let/VB VAReutf/NNP) be/VB the/DT smallest/JJS index/NN into/IN (Chunk VARs/NNP) that/WDT corresponds/VBZ to/TO the/DT character/NN at/IN element/JJ (Chunk VARe/NNP) of/IN (Chunk VARinput/NNP) ./. if/IN (Chunk VARe/NNP) is/VBZ greater/JJR than/IN or/CC equal/JJ to/TO the/DT number/NN of/IN elements/NNS in/IN (Chunk VARinput/NNP) ,/, (Chunk then/RB VAReutf/NNP) is/VBZ the/DT number/NN of/IN code/JJ units/NNS in/IN (Chunk VARs/NNP) ./.)
*1*set VARe to VAReutf. 
*1*(S (Chunk set/VBN VARe/NNP) to/TO (Chunk VAReutf/NNP) ./.)
*0*if VARglobal is true or VARsticky is true, then
*0*(S if/IN (Chunk VARglobal/NNP) is/VBZ true/JJ or/CC (Chunk VARsticky/NNP) is/VBZ true/JJ ,/, then/RB)
*1*perform ? FUNCset(VARr, "lastindex", VARe, true). 
*1*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARr/NNP) ,/, ``/`` lastindex/NN ''/'' ,/, (Chunk VARe/NNP) ,/, true/JJ )/) ./.)
*0*let VARn be the number of elements in VARr's VARcaptures list. (this is the same value as 21.2.2.1's VARncapturingparens.) 
*0*(S (Chunk let/VB VARn/NNP) be/VB the/DT number/NN of/IN elements/NNS in/IN (Chunk VARr/NNP) 's/POS (Chunk VARcaptures/NNP) list/NN ./. (/( this/DT is/VBZ the/DT same/JJ value/NN as/IN 21.2.2.1/CD 's/POS (Chunk VARncapturingparens/NNP) ./. )/))
*0*assert: VARn &lt; 232-1. 
*0*(S assert/NN :/: (Chunk VARn/NNP) &/CC lt/NN ;/: 232-1/JJ ./.)
*0*let VARa be ! FUNCarraycreate(VARn + 1). 
*0*(S (Chunk let/VB VARa/NNP) be/VB !/. (Chunk FUNCarraycreate/NNP) (/( (Chunk VARn/NNP) (Chunk +/NNP) 1/CD )/) ./.)
*0*assert: the value of VARa's "length" property is VARn + 1. 
*0*(S assert/NN :/: the/DT value/NN of/IN (Chunk VARa/NNP) 's/POS ``/`` length/NN ''/'' property/NN (Chunk is/VBZ VARn/NNP) (Chunk +/NNP) 1/CD ./.)
*0*perform ! FUNCcreatedataproperty(VARa, "index", VARlastindex). 
*0*(S perform/NN !/. (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` index/NN ''/'' ,/, (Chunk VARlastindex/NNP) )/) ./.)
*0*perform ! FUNCcreatedataproperty(VARa, "input", VARs). 
*0*(S perform/NN !/. (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` input/NN ''/'' ,/, (Chunk VARs/NNP) )/) ./.)
*0*let VARmatchedsubstr be the matched substring (i.e. the portion of VARs between offset VARlastindex inclusive and offset VARe exclusive). 
*0*(S (Chunk let/VB VARmatchedsubstr/NNP) be/VB the/DT matched/JJ substring/NN (/( i.e/NN ./. the/DT portion/NN of/IN (Chunk VARs/NNP) between/IN (Chunk offset/VBN VARlastindex/NNP) inclusive/JJ and/CC (Chunk offset/VBN VARe/NNP) exclusive/JJ )/) ./.)
*0*perform ! FUNCcreatedataproperty(VARa, "0", VARmatchedsubstr). 
*0*(S perform/NN !/. (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` 0/CD ''/'' ,/, (Chunk VARmatchedsubstr/NNP) )/) ./.)
*0*if VARr contains any groupname, then
*0*(S if/IN (Chunk VARr/NNP) contains/VBZ any/DT groupname/NN ,/, then/RB)
*1*let VARgroups be FUNCobjectcreate(null). 
*1*(S (Chunk let/VB VARgroups/NNP) (Chunk be/VB FUNCobjectcreate/NNP) (/( null/NN )/) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARgroups be undefined. 
*1*(S (Chunk let/VB VARgroups/NNP) be/VB undefined/VBN ./.)
*0*perform ! FUNCcreatedataproperty(VARa, "groups", VARgroups). 
*0*(S perform/NN !/. (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` groups/NNS ''/'' ,/, (Chunk VARgroups/NNP) )/) ./.)
*0*for each integer VARi such that VARi &gt; 0 and VARi ≤ VARn, do
*0*(S for/IN each/DT integer/NN (Chunk VARi/NNP) such/JJ that/IN (Chunk VARi/NNP) &/CC gt/NN ;/: 0/CD and/CC (Chunk VARi/NNP) (Chunk ≤/NNP) (Chunk VARn/NNP) ,/, do/VBP)
*1*let VARcapturei be VARith element of VARr's VARcaptures list. 
*1*(S (Chunk let/VB VARcapturei/NNP) (Chunk be/VB VARith/NNP) element/NN of/IN (Chunk VARr/NNP) 's/POS (Chunk VARcaptures/NNP) list/NN ./.)
*1*if VARcapturei is undefined, let VARcapturedvalue be undefined. 
*1*(S if/IN (Chunk VARcapturei/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARcapturedvalue/NNP) be/VB undefined/VBN ./.)
*1*else if VARfullunicode is true, then
*1*(S else/RB if/IN (Chunk VARfullunicode/NNP) is/VBZ true/JJ ,/, then/RB)
*2*assert: VARcapturei is a list of code points. 
*2*(S assert/NN :/: (Chunk VARcapturei/NNP) is/VBZ a/DT list/NN of/IN code/NN points/NNS ./.)
*2*let VARcapturedvalue be the string value whose code units are the utf16encoding of the code points of VARcapturei. 
*2*(S (Chunk let/VB VARcapturedvalue/NNP) be/VB the/DT string/NN value/NN whose/WP$ code/NN units/NNS are/VBP the/DT utf16encoding/NN of/IN the/DT code/NN points/NNS of/IN (Chunk VARcapturei/NNP) ./.)
*1*else VARfullunicode is false,
*1*(S (Chunk else/RB VARfullunicode/NNP) is/VBZ false/JJ ,/,)
*2*assert: VARcapturei is a list of code units. 
*2*(S assert/NN :/: (Chunk VARcapturei/NNP) is/VBZ a/DT list/NN of/IN code/JJ units/NNS ./.)
*2*let VARcapturedvalue be the string value consisting of the code units of VARcapturei. 
*2*(S (Chunk let/VB VARcapturedvalue/NNP) be/VB the/DT string/VBG value/NN consisting/NN of/IN the/DT code/NN units/NNS of/IN (Chunk VARcapturei/NNP) ./.)
*1*perform ! FUNCcreatedataproperty(VARa, ! FUNCtostring(VARi), VARcapturedvalue). 
*1*(S perform/NN !/. (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARa/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARi/NNP) )/) ,/, (Chunk VARcapturedvalue/NNP) )/) ./.)
*1*if the VARith capture of VARr was defined with a groupname, then
*1*(S if/IN the/DT (Chunk VARith/NNP) capture/NN of/IN (Chunk VARr/NNP) was/VBD defined/VBN with/IN a/DT groupname/NN ,/, then/RB)
*2*let VARs be the stringvalue of the corresponding regexpidentifiername. 
*2*(S (Chunk let/VB VARs/NNP) be/VB the/DT stringvalue/NN of/IN the/DT corresponding/JJ regexpidentifiername/NN ./.)
*2*perform ! FUNCcreatedataproperty(VARgroups, VARs, VARcapturedvalue). 
*2*(S perform/NN !/. (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARgroups/NNP) ,/, (Chunk VARs/NNP) ,/, (Chunk VARcapturedvalue/NNP) )/) ./.)
*0*return VARa.      
*0*(S return/NN (Chunk VARa/NNP) ./.)
ID= 21.2.5.2.3
Summary= AdvanceStringIndex ( S, index, unicode )
*0*assert: FUNCtype(VARs) is string. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARs/NNP) )/) is/VBZ string/VBG ./.)
*0*assert: VARindex is an integer such that 0≤VARindex≤253-1. 
*0*(S assert/NN :/: VARindex/NN is/VBZ an/DT integer/NN such/JJ that/IN 0≤VARindex≤253-1/NN ./.)
*0*assert: FUNCtype(VARunicode) is boolean. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARunicode/NNP) )/) is/VBZ boolean/JJ ./.)
*0*if VARunicode is false, return VARindex+1. 
*0*(S if/IN (Chunk VARunicode/NNP) is/VBZ false/JJ ,/, return/JJ (Chunk VARindex+1/NNP) ./.)
*0*let VARlength be the number of code units in VARs. 
*0*(S (Chunk let/VB VARlength/NNP) be/VB the/DT number/NN of/IN code/JJ units/NNS in/IN (Chunk VARs/NNP) ./.)
*0*if VARindex+1 ≥ VARlength, return VARindex+1. 
*0*(S if/IN (Chunk VARindex+1/NNP) (Chunk ≥/NNP) (Chunk VARlength/NNP) ,/, return/NN (Chunk VARindex+1/NNP) ./.)
*0*let VARfirst be the numeric value of the code unit at index VARindex within VARs. 
*0*(S (Chunk let/VB VARfirst/NNP) be/VB the/DT numeric/JJ value/NN of/IN the/DT code/NN unit/NN at/IN index/NN (Chunk VARindex/NNP) within/IN (Chunk VARs/NNP) ./.)
*0*if VARfirst &lt; 0xd800 or VARfirst &gt; 0xdbff, return VARindex+1. 
*0*(S if/IN (Chunk VARfirst/NNP) &/CC lt/NN ;/: 0xd800/CD or/CC (Chunk VARfirst/NNP) &/CC gt/NN ;/: 0xdbff/CD ,/, return/NN (Chunk VARindex+1/NNP) ./.)
*0*let VARsecond be the numeric value of the code unit at index VARindex+1 within VARs. 
*0*(S (Chunk let/VB VARsecond/NNP) be/VB the/DT numeric/JJ value/NN of/IN the/DT code/NN unit/NN at/IN index/NN (Chunk VARindex+1/NNP) within/IN (Chunk VARs/NNP) ./.)
*0*if VARsecond &lt; 0xdc00 or VARsecond &gt; 0xdfff, return VARindex+1. 
*0*(S if/IN (Chunk VARsecond/NNP) &/CC lt/NN ;/: 0xdc00/CD or/CC (Chunk VARsecond/NNP) &/CC gt/NN ;/: 0xdfff/CD ,/, return/NN (Chunk VARindex+1/NNP) ./.)
*0*return VARindex+2.      
*0*(S return/NN (Chunk VARindex+2/NNP) ./.)
ID= 21.2.5.7
Summary= RegExp.prototype [ @@match ] ( string )
*0*let VARrx be the this value. 
*0*(S (Chunk let/VB VARrx/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARrx) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARrx/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARs be ? FUNCtostring(VARstring). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( VARstring/VBG )/) ./.)
*0*let VARglobal be FUNCtoboolean(? FUNCget(VARrx, "global")). 
*0*(S (Chunk let/VB VARglobal/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARrx/NNP) ,/, ``/`` global/JJ ''/'' )/) )/) ./.)
*0*if VARglobal is false, then
*0*(S if/IN (Chunk VARglobal/NNP) is/VBZ false/JJ ,/, then/RB)
*1*return ? FUNCregexpexec(VARrx, VARs). 
*1*(S return/NN ?/. (Chunk FUNCregexpexec/NNP) (/( (Chunk VARrx/NNP) ,/, (Chunk VARs/NNP) )/) ./.)
*0*else VARglobal is true,
*0*(S (Chunk else/RB VARglobal/NNP) is/VBZ true/JJ ,/,)
*1*let VARfullunicode be FUNCtoboolean(? FUNCget(VARrx, "unicode")). 
*1*(S (Chunk let/VB VARfullunicode/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARrx/NNP) ,/, ``/`` unicode/JJ ''/'' )/) )/) ./.)
*1*perform ? FUNCset(VARrx, "lastindex", 0, true). 
*1*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARrx/NNP) ,/, ``/`` lastindex/NN ''/'' ,/, 0/CD ,/, true/JJ )/) ./.)
*1*let VARa be ! FUNCarraycreate(0). 
*1*(S (Chunk let/VB VARa/NNP) be/VB !/. (Chunk FUNCarraycreate/NNP) (/( 0/CD )/) ./.)
*1*let VARn be 0. 
*1*(S (Chunk let/VB VARn/NNP) be/VB 0/CD ./.)
*1*repeat,
*1*(S repeat/NN ,/,)
*2*let VARresult be ? FUNCregexpexec(VARrx, VARs). 
*2*(S (Chunk let/VB VARresult/NNP) be/VB ?/. (Chunk FUNCregexpexec/NNP) (/( (Chunk VARrx/NNP) ,/, (Chunk VARs/NNP) )/) ./.)
*2*if VARresult is null, then
*2*(S if/IN (Chunk VARresult/NNP) is/VBZ null/RB ,/, then/RB)
*3*if VARn=0, return null. 
*3*(S if/IN (Chunk VARn=0/NNP) ,/, return/NN null/NN ./.)
*3*return VARa. 
*3*(S return/NN (Chunk VARa/NNP) ./.)
*2*else VARresult is not null,
*2*(S (Chunk else/RB VARresult/NNP) is/VBZ not/RB null/JJ ,/,)
*3*let VARmatchstr be ? FUNCtostring(? FUNCget(VARresult, "0")). 
*3*(S (Chunk let/VB VARmatchstr/NNP) be/VB ?/. FUNCtostring/VBG (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARresult/NNP) ,/, ``/`` 0/CD ''/'' )/) )/) ./.)
*3*let VARstatus be FUNCcreatedataproperty(VARa, ! FUNCtostring(VARn), VARmatchstr). 
*3*(S (Chunk let/VB VARstatus/NNP) (Chunk be/VB FUNCcreatedataproperty/NNP) (/( (Chunk VARa/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARn/NNP) )/) ,/, (Chunk VARmatchstr/NNP) )/) ./.)
*3*assert: VARstatus is true. 
*3*(S assert/NN :/: (Chunk VARstatus/NNP) is/VBZ true/JJ ./.)
*3*if VARmatchstr is the empty string, then
*3*(S if/IN (Chunk VARmatchstr/NNP) is/VBZ the/DT empty/JJ string/NN ,/, then/RB)
*4*let VARthisindex be ? FUNCtolength(? FUNCget(VARrx, "lastindex")). 
*4*(S (Chunk let/VB VARthisindex/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARrx/NNP) ,/, ``/`` lastindex/NN ''/'' )/) )/) ./.)
*4*let VARnextindex be FUNCadvancestringindex(VARs, VARthisindex, VARfullunicode). 
*4*(S (Chunk let/VB VARnextindex/NNP) (Chunk be/VB FUNCadvancestringindex/NNP) (/( (Chunk VARs/NNP) ,/, (Chunk VARthisindex/NNP) ,/, (Chunk VARfullunicode/NNP) )/) ./.)
*4*perform ? FUNCset(VARrx, "lastindex", VARnextindex, true). 
*4*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARrx/NNP) ,/, ``/`` lastindex/NN ''/'' ,/, (Chunk VARnextindex/NNP) ,/, true/JJ )/) ./.)
*3*increment VARn.     
*3*(S increment/NN (Chunk VARn/NNP) ./.)
ID= 21.2.5.9
Summary= RegExp.prototype [ @@replace ] ( string, replaceValue )
*0*let VARrx be the this value. 
*0*(S (Chunk let/VB VARrx/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARrx) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARrx/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARs be ? FUNCtostring(VARstring). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( VARstring/VBG )/) ./.)
*0*let VARlengths be the number of code unit elements in VARs. 
*0*(S (Chunk let/VB VARlengths/NNP) be/VB the/DT number/NN of/IN code/JJ unit/NN elements/NNS in/IN (Chunk VARs/NNP) ./.)
*0*let VARfunctionalreplace be FUNCiscallable(VARreplacevalue). 
*0*(S (Chunk let/VB VARfunctionalreplace/NNP) (Chunk be/VB FUNCiscallable/NNP) (/( (Chunk VARreplacevalue/NNP) )/) ./.)
*0*if VARfunctionalreplace is false, then
*0*(S if/IN (Chunk VARfunctionalreplace/NNP) is/VBZ false/JJ ,/, then/RB)
*1*let VARreplacevalue be ? FUNCtostring(VARreplacevalue). 
*1*(S (Chunk let/VB VARreplacevalue/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARreplacevalue/NNP) )/) ./.)
*0*let VARglobal be FUNCtoboolean(? FUNCget(VARrx, "global")). 
*0*(S (Chunk let/VB VARglobal/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARrx/NNP) ,/, ``/`` global/JJ ''/'' )/) )/) ./.)
*0*if VARglobal is true, then
*0*(S if/IN (Chunk VARglobal/NNP) is/VBZ true/JJ ,/, then/RB)
*1*let VARfullunicode be FUNCtoboolean(? FUNCget(VARrx, "unicode")). 
*1*(S (Chunk let/VB VARfullunicode/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARrx/NNP) ,/, ``/`` unicode/JJ ''/'' )/) )/) ./.)
*1*perform ? FUNCset(VARrx, "lastindex", 0, true). 
*1*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARrx/NNP) ,/, ``/`` lastindex/NN ''/'' ,/, 0/CD ,/, true/JJ )/) ./.)
*0*let VARresults be a new empty list. 
*0*(S (Chunk let/VB VARresults/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARdone be false. 
*0*(S (Chunk let/VB VARdone/NNP) be/VB false/JJ ./.)
*0*repeat, while VARdone is false
*0*(S repeat/NN ,/, while/IN (Chunk VARdone/NNP) is/VBZ false/JJ)
*1*let VARresult be ? FUNCregexpexec(VARrx, VARs). 
*1*(S (Chunk let/VB VARresult/NNP) be/VB ?/. (Chunk FUNCregexpexec/NNP) (/( (Chunk VARrx/NNP) ,/, (Chunk VARs/NNP) )/) ./.)
*1*if VARresult is null, set VARdone to true. 
*1*(S if/IN (Chunk VARresult/NNP) is/VBZ null/JJ ,/, (Chunk set/VB VARdone/NNP) to/TO true/JJ ./.)
*1*else VARresult is not null,
*1*(S (Chunk else/RB VARresult/NNP) is/VBZ not/RB null/JJ ,/,)
*2*append VARresult to the end of VARresults. 
*2*(S (Chunk append/RB VARresult/NNP) to/TO the/DT end/NN of/IN (Chunk VARresults/NNP) ./.)
*2*if VARglobal is false, set VARdone to true. 
*2*(S if/IN (Chunk VARglobal/NNP) is/VBZ false/JJ ,/, (Chunk set/VB VARdone/NNP) to/TO true/JJ ./.)
*2*else,
*2*(S else/RB ,/,)
*3*let VARmatchstr be ? FUNCtostring(? FUNCget(VARresult, "0")). 
*3*(S (Chunk let/VB VARmatchstr/NNP) be/VB ?/. FUNCtostring/VBG (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARresult/NNP) ,/, ``/`` 0/CD ''/'' )/) )/) ./.)
*3*if VARmatchstr is the empty string, then
*3*(S if/IN (Chunk VARmatchstr/NNP) is/VBZ the/DT empty/JJ string/NN ,/, then/RB)
*4*let VARthisindex be ? FUNCtolength(? FUNCget(VARrx, "lastindex")). 
*4*(S (Chunk let/VB VARthisindex/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARrx/NNP) ,/, ``/`` lastindex/NN ''/'' )/) )/) ./.)
*4*let VARnextindex be FUNCadvancestringindex(VARs, VARthisindex, VARfullunicode). 
*4*(S (Chunk let/VB VARnextindex/NNP) (Chunk be/VB FUNCadvancestringindex/NNP) (/( (Chunk VARs/NNP) ,/, (Chunk VARthisindex/NNP) ,/, (Chunk VARfullunicode/NNP) )/) ./.)
*4*perform ? FUNCset(VARrx, "lastindex", VARnextindex, true). 
*4*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARrx/NNP) ,/, ``/`` lastindex/NN ''/'' ,/, (Chunk VARnextindex/NNP) ,/, true/JJ )/) ./.)
*0*let VARaccumulatedresult be the empty string value. 
*0*(S (Chunk let/VB VARaccumulatedresult/NNP) be/VB the/DT empty/JJ string/NN value/NN ./.)
*0*let VARnextsourceposition be 0. 
*0*(S (Chunk let/VB VARnextsourceposition/NNP) be/VB 0/CD ./.)
*0*for each VARresult in VARresults, do
*0*(S for/IN each/DT (Chunk VARresult/NNP) in/IN (Chunk VARresults/NNP) ,/, do/VBP)
*1*let VARncaptures be ? FUNCtolength(? FUNCget(VARresult, "length")). 
*1*(S let/VB VARncaptures/NNS be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARresult/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*1*let VARncaptures be max(VARncaptures - 1, 0). 
*1*(S (Chunk let/VB VARncaptures/NNP) be/VB max/VBN (/( (Chunk VARncaptures/NNP) -/: 1/CD ,/, 0/CD )/) ./.)
*1*let VARmatched be ? FUNCtostring(? FUNCget(VARresult, "0")). 
*1*(S (Chunk let/VB VARmatched/NNP) be/VB ?/. FUNCtostring/VBG (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARresult/NNP) ,/, ``/`` 0/CD ''/'' )/) )/) ./.)
*1*let VARmatchlength be the number of code units in VARmatched. 
*1*(S (Chunk let/VB VARmatchlength/NNP) be/VB the/DT number/NN of/IN code/JJ units/NNS in/IN (Chunk VARmatched/NNP) ./.)
*1*let VARposition be ? FUNCtointeger(? FUNCget(VARresult, "index")). 
*1*(S (Chunk let/VB VARposition/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARresult/NNP) ,/, ``/`` index/NN ''/'' )/) )/) ./.)
*1*let VARposition be max(min(VARposition, VARlengths), 0). 
*1*(S (Chunk let/VB VARposition/NNP) be/VB max/VBN (/( min/NN (/( (Chunk VARposition/NNP) ,/, (Chunk VARlengths/NNP) )/) ,/, 0/CD )/) ./.)
*1*let VARn be 1. 
*1*(S (Chunk let/VB VARn/NNP) be/VB 1/CD ./.)
*1*let VARcaptures be a new empty list. 
*1*(S (Chunk let/VB VARcaptures/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*1*repeat, while VARn ≤ VARncaptures
*1*(S repeat/NN ,/, while/IN (Chunk VARn/NNP) (Chunk ≤/NNP) (Chunk VARncaptures/NNP))
*2*let VARcapn be ? FUNCget(VARresult, ! FUNCtostring(VARn)). 
*2*(S (Chunk let/VB VARcapn/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARresult/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARn/NNP) )/) )/) ./.)
*2*if VARcapn is not undefined, then
*2*(S if/IN (Chunk VARcapn/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*3*let VARcapn be ? FUNCtostring(VARcapn). 
*3*(S (Chunk let/VB VARcapn/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARcapn/NNP) )/) ./.)
*2*append VARcapn as the last element of VARcaptures. 
*2*(S (Chunk append/RB VARcapn/NNP) as/IN the/DT last/JJ element/NN of/IN VARcaptures/NNS ./.)
*2*let VARn be VARn+1. 
*2*(S (Chunk let/VB VARn/NNP) (Chunk be/VB VARn+1/NNP) ./.)
*1*let VARnamedcaptures be ? FUNCget(VARresult, "groups"). 
*1*(S let/VB VARnamedcaptures/NNS be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARresult/NNP) ,/, ``/`` groups/NNS ''/'' )/) ./.)
*1*if VARfunctionalreplace is true, then
*1*(S if/IN (Chunk VARfunctionalreplace/NNP) is/VBZ true/JJ ,/, then/RB)
*2*let VARreplacerargs be « VARmatched ». 
*2*(S (Chunk let/VB VARreplacerargs/NNP) (Chunk be/VB «/VBN VARmatched/NNP) (Chunk »/NNP) ./.)
*2*append in list order the elements of VARcaptures to the end of the list VARreplacerargs. 
*2*(S append/NN in/IN list/NN order/NN the/DT elements/NNS of/IN VARcaptures/NNS to/TO the/DT end/NN of/IN the/DT list/NN (Chunk VARreplacerargs/NNP) ./.)
*2*append VARposition and VARs to VARreplacerargs. 
*2*(S append/JJ (Chunk VARposition/NNP) and/CC (Chunk VARs/NNP) to/TO (Chunk VARreplacerargs/NNP) ./.)
*2*if VARnamedcaptures is not undefined, then
*2*(S if/IN (Chunk VARnamedcaptures/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*3*append VARnamedcaptures as the last element of VARreplacerargs. 
*3*(S append/NN VARnamedcaptures/VBZ as/IN the/DT last/JJ element/NN of/IN (Chunk VARreplacerargs/NNP) ./.)
*2*let VARreplvalue be ? FUNCcall(VARreplacevalue, undefined, VARreplacerargs). 
*2*(S (Chunk let/VB VARreplvalue/NNP) be/VB ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARreplacevalue/NNP) ,/, undefined/VBD ,/, (Chunk VARreplacerargs/NNP) )/) ./.)
*2*let VARreplacement be ? FUNCtostring(VARreplvalue). 
*2*(S (Chunk let/VB VARreplacement/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARreplvalue/NNP) )/) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*let VARreplacement be FUNCgetsubstitution(VARmatched, VARs, VARposition, VARcaptures, VARnamedcaptures, VARreplacevalue). 
*2*(S (Chunk let/VB VARreplacement/NNP) (Chunk be/VB FUNCgetsubstitution/NNP) (/( (Chunk VARmatched/NNP) ,/, (Chunk VARs/NNP) ,/, (Chunk VARposition/NNP) ,/, (Chunk VARcaptures/NNP) ,/, (Chunk VARnamedcaptures/NNP) ,/, (Chunk VARreplacevalue/NNP) )/) ./.)
*1*if VARposition ≥ VARnextsourceposition, then
*1*(S if/IN (Chunk VARposition/NNP) (Chunk ≥/NNP) (Chunk VARnextsourceposition/NNP) ,/, then/RB)
*2*note: VARposition should not normally move backwards. if it does, it is an indication of an ill-behaving regexp subclass or use of an access triggered side-effect to change the global flag or other characteristics of VARrx. in such cases, the corresponding substitution is ignored. 
*2*(S note/NN :/: VARposition/NN should/MD not/RB normally/RB move/VB backwards/NNS ./. if/IN it/PRP does/VBZ ,/, it/PRP is/VBZ an/DT indication/NN of/IN an/DT ill-behaving/JJ regexp/NN subclass/NN or/CC use/NN of/IN an/DT access/NN triggered/VBD side-effect/JJ to/TO change/VB the/DT global/JJ flag/NN or/CC other/JJ characteristics/NNS of/IN (Chunk VARrx/NNP) ./. in/IN such/JJ cases/NNS ,/, the/DT corresponding/JJ substitution/NN is/VBZ ignored/VBN ./.)
*2*let VARaccumulatedresult be the string-concatenation of the current value of VARaccumulatedresult, the substring of VARs consisting of the code units from VARnextsourceposition (inclusive) up to VARposition (exclusive), and VARreplacement. 
*2*(S (Chunk let/VB VARaccumulatedresult/NNP) be/VB the/DT string-concatenation/NN of/IN the/DT current/JJ value/NN of/IN (Chunk VARaccumulatedresult/NNP) ,/, the/DT substring/NN of/IN (Chunk VARs/NNP) consisting/VBG of/IN the/DT code/NN units/NNS from/IN (Chunk VARnextsourceposition/NNP) (/( inclusive/NN )/) up/IN to/TO (Chunk VARposition/NNP) (/( exclusive/JJ )/) ,/, and/CC (Chunk VARreplacement/NNP) ./.)
*2*let VARnextsourceposition be VARposition + VARmatchlength. 
*2*(S (Chunk let/VB VARnextsourceposition/NNP) (Chunk be/VB VARposition/NNP) (Chunk +/NNP) (Chunk VARmatchlength/NNP) ./.)
*0*if VARnextsourceposition ≥ VARlengths, return VARaccumulatedresult. 
*0*(S if/IN (Chunk VARnextsourceposition/NNP) (Chunk ≥/NNP) (Chunk VARlengths/NNP) ,/, return/NN (Chunk VARaccumulatedresult/NNP) ./.)
*0*return the string-concatenation of VARaccumulatedresult and the substring of VARs consisting of the code units from VARnextsourceposition (inclusive) up through the final code unit of VARs (inclusive).     
*0*(S return/VB the/DT string-concatenation/NN of/IN (Chunk VARaccumulatedresult/NNP) and/CC the/DT substring/NN of/IN (Chunk VARs/NNP) consisting/VBG of/IN the/DT code/NN units/NNS from/IN (Chunk VARnextsourceposition/NNP) (/( inclusive/NN )/) up/RP through/IN the/DT final/JJ code/NN unit/NN of/IN (Chunk VARs/NNP) (/( inclusive/JJ )/) ./.)
ID= 21.2.5.10
Summary= RegExp.prototype [ @@search ] ( string )
*0*let VARrx be the this value. 
*0*(S (Chunk let/VB VARrx/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARrx) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARrx/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARs be ? FUNCtostring(VARstring). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( VARstring/VBG )/) ./.)
*0*let VARpreviouslastindex be ? FUNCget(VARrx, "lastindex"). 
*0*(S (Chunk let/VB VARpreviouslastindex/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARrx/NNP) ,/, ``/`` lastindex/NN ''/'' )/) ./.)
*0*if FUNCsamevalue(VARpreviouslastindex, 0) is false, then
*0*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARpreviouslastindex/NNP) ,/, 0/CD )/) is/VBZ false/JJ ,/, then/RB)
*1*perform ? FUNCset(VARrx, "lastindex", 0, true). 
*1*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARrx/NNP) ,/, ``/`` lastindex/NN ''/'' ,/, 0/CD ,/, true/JJ )/) ./.)
*0*let VARresult be ? FUNCregexpexec(VARrx, VARs). 
*0*(S (Chunk let/VB VARresult/NNP) be/VB ?/. (Chunk FUNCregexpexec/NNP) (/( (Chunk VARrx/NNP) ,/, (Chunk VARs/NNP) )/) ./.)
*0*let VARcurrentlastindex be ? FUNCget(VARrx, "lastindex"). 
*0*(S (Chunk let/VB VARcurrentlastindex/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARrx/NNP) ,/, ``/`` lastindex/NN ''/'' )/) ./.)
*0*if FUNCsamevalue(VARcurrentlastindex, VARpreviouslastindex) is false, then
*0*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARcurrentlastindex/NNP) ,/, (Chunk VARpreviouslastindex/NNP) )/) is/VBZ false/JJ ,/, then/RB)
*1*perform ? FUNCset(VARrx, "lastindex", VARpreviouslastindex, true). 
*1*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARrx/NNP) ,/, ``/`` lastindex/NN ''/'' ,/, (Chunk VARpreviouslastindex/NNP) ,/, true/JJ )/) ./.)
*0*if VARresult is null, return -1. 
*0*(S if/IN (Chunk VARresult/NNP) is/VBZ null/JJ ,/, (Chunk return/VB -1/NNP) ./.)
*0*return ? FUNCget(VARresult, "index").     
*0*(S return/NN ?/. (Chunk FUNCget/NNP) (/( (Chunk VARresult/NNP) ,/, ``/`` index/NN ''/'' )/) ./.)
ID= 21.2.5.12
Summary= RegExp.prototype [ @@split ] ( string, limit )
*0*let VARrx be the this value. 
*0*(S (Chunk let/VB VARrx/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARrx) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARrx/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARs be ? FUNCtostring(VARstring). 
*0*(S (Chunk let/VB VARs/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( VARstring/VBG )/) ./.)
*0*let VARc be ? FUNCspeciesconstructor(VARrx, %regexp%). 
*0*(S (Chunk let/VB VARc/NNP) be/VB ?/. (Chunk FUNCspeciesconstructor/NNP) (/( (Chunk VARrx/NNP) ,/, %/NN regexp/NN %/NN )/) ./.)
*0*let VARflags be ? FUNCtostring(? FUNCget(VARrx, "flags")). 
*0*(S (Chunk let/VB VARflags/NNP) be/VB ?/. FUNCtostring/VBG (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARrx/NNP) ,/, ``/`` flags/NNS ''/'' )/) )/) ./.)
*0*if VARflags contains "u", let VARunicodematching be true. 
*0*(S if/IN (Chunk VARflags/NNP) contains/VBZ ``/`` u/JJ ''/'' ,/, (Chunk let/VB VARunicodematching/NNP) be/VB true/JJ ./.)
*0*else, let VARunicodematching be false. 
*0*(S else/RB ,/, (Chunk let/VB VARunicodematching/NNP) be/VB false/JJ ./.)
*0*if VARflags contains "y", let VARnewflags be VARflags. 
*0*(S if/IN (Chunk VARflags/NNP) contains/VBZ ``/`` y/NN ''/'' ,/, (Chunk let/VB VARnewflags/NNP) (Chunk be/VB VARflags/NNP) ./.)
*0*else, let VARnewflags be the string-concatenation of VARflags and "y". 
*0*(S else/RB ,/, (Chunk let/VB VARnewflags/NNP) be/VB the/DT string-concatenation/NN of/IN (Chunk VARflags/NNP) and/CC ``/`` y/NN ''/'' ./.)
*0*let VARsplitter be ? FUNCconstruct(VARc, « VARrx, VARnewflags »). 
*0*(S (Chunk let/VB VARsplitter/NNP) be/VB ?/. (Chunk FUNCconstruct/NNP) (/( (Chunk VARc/NNP) ,/, (Chunk «/NNP) (Chunk VARrx/NNP) ,/, (Chunk VARnewflags/NNP) (Chunk »/NNP) )/) ./.)
*0*let VARa be ! FUNCarraycreate(0). 
*0*(S (Chunk let/VB VARa/NNP) be/VB !/. (Chunk FUNCarraycreate/NNP) (/( 0/CD )/) ./.)
*0*let VARlengtha be 0. 
*0*(S (Chunk let/VB VARlengtha/NNP) be/VB 0/CD ./.)
*0*if VARlimit is undefined, let VARlim be 232-1; else let VARlim be ? FUNCtouint32(VARlimit). 
*0*(S if/IN (Chunk VARlimit/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARlim/NNP) be/VB 232-1/JJ ;/: else/JJ (Chunk let/VB VARlim/NNP) be/VB ?/. (Chunk FUNCtouint32/NNP) (/( (Chunk VARlimit/NNP) )/) ./.)
*0*let VARsize be the length of VARs. 
*0*(S (Chunk let/VB VARsize/NNP) be/VB the/DT length/NN of/IN (Chunk VARs/NNP) ./.)
*0*let VARp be 0. 
*0*(S (Chunk let/VB VARp/NNP) be/VB 0/CD ./.)
*0*if VARlim = 0, return VARa. 
*0*(S if/IN (Chunk VARlim/NNP) =/VBD 0/CD ,/, return/NN (Chunk VARa/NNP) ./.)
*0*if VARsize = 0, then
*0*(S if/IN (Chunk VARsize/NNP) (Chunk =/NNP) 0/CD ,/, then/RB)
*1*let VARz be ? FUNCregexpexec(VARsplitter, VARs). 
*1*(S (Chunk let/VB VARz/NNP) be/VB ?/. (Chunk FUNCregexpexec/NNP) (/( (Chunk VARsplitter/NNP) ,/, (Chunk VARs/NNP) )/) ./.)
*1*if VARz is not null, return VARa. 
*1*(S if/IN (Chunk VARz/NNP) is/VBZ not/RB null/JJ ,/, (Chunk return/VB VARa/NNP) ./.)
*1*perform ! FUNCcreatedataproperty(VARa, "0", VARs). 
*1*(S perform/NN !/. (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` 0/CD ''/'' ,/, (Chunk VARs/NNP) )/) ./.)
*1*return VARa. 
*1*(S return/NN (Chunk VARa/NNP) ./.)
*0*let VARq be VARp. 
*0*(S (Chunk let/VB VARq/NNP) (Chunk be/VB VARp/NNP) ./.)
*0*repeat, while VARq &lt; VARsize
*0*(S repeat/NN ,/, while/IN (Chunk VARq/NNP) &/CC lt/NN ;/: VARsize/VB)
*1*perform ? FUNCset(VARsplitter, "lastindex", VARq, true). 
*1*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARsplitter/NNP) ,/, ``/`` lastindex/NN ''/'' ,/, (Chunk VARq/NNP) ,/, true/JJ )/) ./.)
*1*let VARz be ? FUNCregexpexec(VARsplitter, VARs). 
*1*(S (Chunk let/VB VARz/NNP) be/VB ?/. (Chunk FUNCregexpexec/NNP) (/( (Chunk VARsplitter/NNP) ,/, (Chunk VARs/NNP) )/) ./.)
*1*if VARz is null, let VARq be FUNCadvancestringindex(VARs, VARq, VARunicodematching). 
*1*(S if/IN (Chunk VARz/NNP) is/VBZ null/JJ ,/, (Chunk let/VB VARq/NNP) (Chunk be/VB FUNCadvancestringindex/NNP) (/( (Chunk VARs/NNP) ,/, (Chunk VARq/NNP) ,/, (Chunk VARunicodematching/NNP) )/) ./.)
*1*else VARz is not null,
*1*(S (Chunk else/RB VARz/NNP) is/VBZ not/RB null/JJ ,/,)
*2*let VARe be ? FUNCtolength(? FUNCget(VARsplitter, "lastindex")). 
*2*(S (Chunk let/VB VARe/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARsplitter/NNP) ,/, ``/`` lastindex/NN ''/'' )/) )/) ./.)
*2*let VARe be min(VARe, VARsize). 
*2*(S (Chunk let/VB VARe/NNP) be/VB min/VBN (/( (Chunk VARe/NNP) ,/, (Chunk VARsize/NNP) )/) ./.)
*2*if VARe = VARp, let VARq be FUNCadvancestringindex(VARs, VARq, VARunicodematching). 
*2*(S if/IN (Chunk VARe/NNP) (Chunk =/NNP) (Chunk VARp/NNP) ,/, (Chunk let/VB VARq/NNP) (Chunk be/VB FUNCadvancestringindex/NNP) (/( (Chunk VARs/NNP) ,/, (Chunk VARq/NNP) ,/, (Chunk VARunicodematching/NNP) )/) ./.)
*2*else VARe ≠ VARp,
*2*(S (Chunk else/RB VARe/NNP) (Chunk ≠/NNP) (Chunk VARp/NNP) ,/,)
*3*let VARt be the string value equal to the substring of VARs consisting of the elements at indices VARp (inclusive) through VARq (exclusive). 
*3*(S (Chunk let/VB VARt/NNP) be/VB the/DT string/VBG value/NN equal/JJ to/TO the/DT substring/NN of/IN (Chunk VARs/NNP) consisting/VBG of/IN the/DT elements/NNS at/IN indices/NNS (Chunk VARp/NNP) (/( inclusive/JJ )/) through/IN (Chunk VARq/NNP) (/( exclusive/JJ )/) ./.)
*3*perform ! FUNCcreatedataproperty(VARa, ! FUNCtostring(VARlengtha), VARt). 
*3*(S perform/NN !/. (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARa/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARlengtha/NNP) )/) ,/, (Chunk VARt/NNP) )/) ./.)
*3*let VARlengtha be VARlengtha + 1. 
*3*(S (Chunk let/VB VARlengtha/NNP) (Chunk be/VB VARlengtha/NNP) (Chunk +/NNP) 1/CD ./.)
*3*if VARlengtha = VARlim, return VARa. 
*3*(S if/IN (Chunk VARlengtha/NNP) (Chunk =/NNP) (Chunk VARlim/NNP) ,/, return/NN (Chunk VARa/NNP) ./.)
*3*let VARp be VARe. 
*3*(S (Chunk let/VB VARp/NNP) (Chunk be/VB VARe/NNP) ./.)
*3*let VARnumberofcaptures be ? FUNCtolength(? FUNCget(VARz, "length")). 
*3*(S let/VB VARnumberofcaptures/NNS be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARz/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*3*let VARnumberofcaptures be max(VARnumberofcaptures-1, 0). 
*3*(S (Chunk let/VB VARnumberofcaptures/NNP) be/VB max/VBN (/( (Chunk VARnumberofcaptures-1/NNP) ,/, 0/CD )/) ./.)
*3*let VARi be 1. 
*3*(S (Chunk let/VB VARi/NNP) be/VB 1/CD ./.)
*3*repeat, while VARi ≤ VARnumberofcaptures,
*3*(S repeat/NN ,/, while/IN (Chunk VARi/NNP) (Chunk ≤/NNP) (Chunk VARnumberofcaptures/NNP) ,/,)
*4*let VARnextcapture be ? FUNCget(VARz, ! FUNCtostring(VARi)). 
*4*(S (Chunk let/VB VARnextcapture/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARz/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARi/NNP) )/) )/) ./.)
*4*perform ! FUNCcreatedataproperty(VARa, ! FUNCtostring(VARlengtha), VARnextcapture). 
*4*(S perform/NN !/. (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARa/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARlengtha/NNP) )/) ,/, (Chunk VARnextcapture/NNP) )/) ./.)
*4*let VARi be VARi + 1. 
*4*(S (Chunk let/VB VARi/NNP) (Chunk be/VB VARi/NNP) (Chunk +/NNP) 1/CD ./.)
*4*let VARlengtha be VARlengtha + 1. 
*4*(S (Chunk let/VB VARlengtha/NNP) (Chunk be/VB VARlengtha/NNP) (Chunk +/NNP) 1/CD ./.)
*4*if VARlengtha = VARlim, return VARa. 
*4*(S if/IN (Chunk VARlengtha/NNP) (Chunk =/NNP) (Chunk VARlim/NNP) ,/, return/NN (Chunk VARa/NNP) ./.)
*3*let VARq be VARp. 
*3*(S (Chunk let/VB VARq/NNP) (Chunk be/VB VARp/NNP) ./.)
*0*let VARt be the string value equal to the substring of VARs consisting of the elements at indices VARp (inclusive) through VARsize (exclusive). 
*0*(S (Chunk let/VB VARt/NNP) be/VB the/DT string/VBG value/NN equal/JJ to/TO the/DT substring/NN of/IN (Chunk VARs/NNP) consisting/VBG of/IN the/DT elements/NNS at/IN indices/NNS (Chunk VARp/NNP) (/( inclusive/JJ )/) through/IN (Chunk VARsize/NNP) (/( exclusive/JJ )/) ./.)
*0*perform ! FUNCcreatedataproperty(VARa, ! FUNCtostring(VARlengtha), VARt). 
*0*(S perform/NN !/. (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARa/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARlengtha/NNP) )/) ,/, (Chunk VARt/NNP) )/) ./.)
*0*return VARa.     
*0*(S return/NN (Chunk VARa/NNP) ./.)
ID= 21.2.5.14
Summary= RegExp.prototype.test ( S )
*0*let VARr be the this value. 
*0*(S (Chunk let/VB VARr/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARr) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARr/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARstring be ? FUNCtostring(VARs). 
*0*(S let/VB VARstring/VBG be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARs/NNP) )/) ./.)
*0*let VARmatch be ? FUNCregexpexec(VARr, VARstring). 
*0*(S (Chunk let/VB VARmatch/NNP) be/VB ?/. (Chunk FUNCregexpexec/NNP) (/( (Chunk VARr/NNP) ,/, (Chunk VARstring/NNP) )/) ./.)
*0*if VARmatch is not null, return true; else return false.     
*0*(S if/IN (Chunk VARmatch/NNP) is/VBZ not/RB null/JJ ,/, return/VB true/JJ ;/: else/RB return/NN false/JJ ./.)
ID= 21.2.5.15
Summary= RegExp.prototype.toString ( )
*0*let VARr be the this value. 
*0*(S (Chunk let/VB VARr/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARr) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARr/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARpattern be ? FUNCtostring(? FUNCget(VARr, "source")). 
*0*(S (Chunk let/VB VARpattern/NNP) be/VB ?/. FUNCtostring/VBG (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARr/NNP) ,/, ``/`` source/NN ''/'' )/) )/) ./.)
*0*let VARflags be ? FUNCtostring(? FUNCget(VARr, "flags")). 
*0*(S (Chunk let/VB VARflags/NNP) be/VB ?/. FUNCtostring/VBG (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARr/NNP) ,/, ``/`` flags/NNS ''/'' )/) )/) ./.)
*0*let VARresult be the string-concatenation of "/", VARpattern, "/", and VARflags. 
*0*(S (Chunk let/VB VARresult/NNP) be/VB the/DT string-concatenation/NN of/IN ``/`` //JJ ''/'' ,/, (Chunk VARpattern/NNP) ,/, ``/`` //NN ''/'' ,/, and/CC (Chunk VARflags/NNP) ./.)
*0*return VARresult.     
*0*(S return/NN (Chunk VARresult/NNP) ./.)
ID= 22.1.1.1
Summary= Array ( )
*0*let VARnumberofargs be the number of arguments passed to this function call. 
*0*(S (Chunk let/VB VARnumberofargs/NNP) be/VB the/DT number/NN of/IN arguments/NNS passed/VBN to/TO this/DT function/NN call/NN ./.)
*0*assert: VARnumberofargs = 0. 
*0*(S assert/NN :/: (Chunk VARnumberofargs/NNP) =/VBZ 0/CD ./.)
*0*if newtarget is undefined, let VARnewtarget be the active function object, else let VARnewtarget be newtarget. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, (Chunk let/VB VARnewtarget/NNP) be/VB the/DT active/JJ function/NN object/NN ,/, (Chunk else/RB let/VB VARnewtarget/NNP) be/VB newtarget/VBN ./.)
*0*let VARproto be ? FUNCgetprototypefromconstructor(VARnewtarget, "%arrayprototype%"). 
*0*(S (Chunk let/VB VARproto/NNP) be/VB ?/. (Chunk FUNCgetprototypefromconstructor/NNP) (/( (Chunk VARnewtarget/NNP) ,/, ``/`` %/NN arrayprototype/JJ %/NN ''/'' )/) ./.)
*0*return ! FUNCarraycreate(0, VARproto).     
*0*(S return/NN !/. (Chunk FUNCarraycreate/NNP) (/( 0/CD ,/, (Chunk VARproto/NNP) )/) ./.)
ID= 22.1.1.2
Summary= Array ( len )
*0*let VARnumberofargs be the number of arguments passed to this function call. 
*0*(S (Chunk let/VB VARnumberofargs/NNP) be/VB the/DT number/NN of/IN arguments/NNS passed/VBN to/TO this/DT function/NN call/NN ./.)
*0*assert: VARnumberofargs = 1. 
*0*(S assert/NN :/: (Chunk VARnumberofargs/NNP) =/VBZ 1/CD ./.)
*0*if newtarget is undefined, let VARnewtarget be the active function object, else let VARnewtarget be newtarget. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, (Chunk let/VB VARnewtarget/NNP) be/VB the/DT active/JJ function/NN object/NN ,/, (Chunk else/RB let/VB VARnewtarget/NNP) be/VB newtarget/VBN ./.)
*0*let VARproto be ? FUNCgetprototypefromconstructor(VARnewtarget, "%arrayprototype%"). 
*0*(S (Chunk let/VB VARproto/NNP) be/VB ?/. (Chunk FUNCgetprototypefromconstructor/NNP) (/( (Chunk VARnewtarget/NNP) ,/, ``/`` %/NN arrayprototype/JJ %/NN ''/'' )/) ./.)
*0*let VARarray be ! FUNCarraycreate(0, VARproto). 
*0*(S (Chunk let/VB VARarray/NNP) be/VB !/. (Chunk FUNCarraycreate/NNP) (/( 0/CD ,/, (Chunk VARproto/NNP) )/) ./.)
*0*if FUNCtype(VARlen) is not number, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARlen/NNP) )/) is/VBZ not/RB number/NN ,/, then/RB)
*1*let VARdefinestatus be FUNCcreatedataproperty(VARarray, "0", VARlen). 
*1*(S (Chunk let/VB VARdefinestatus/NNP) (Chunk be/VB FUNCcreatedataproperty/NNP) (/( (Chunk VARarray/NNP) ,/, ``/`` 0/CD ''/'' ,/, (Chunk VARlen/NNP) )/) ./.)
*1*assert: VARdefinestatus is true. 
*1*(S assert/NN :/: (Chunk VARdefinestatus/NNP) is/VBZ true/JJ ./.)
*1*let VARintlen be 1. 
*1*(S (Chunk let/VB VARintlen/NNP) be/VB 1/CD ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARintlen be FUNCtouint32(VARlen). 
*1*(S (Chunk let/VB VARintlen/NNP) (Chunk be/VB FUNCtouint32/NNP) (/( (Chunk VARlen/NNP) )/) ./.)
*1*if VARintlen ≠ VARlen, throw a rangeerror exception. 
*1*(S if/IN (Chunk VARintlen/NNP) (Chunk ≠/NNP) (Chunk VARlen/NNP) ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*perform ! FUNCset(VARarray, "length", VARintlen, true). 
*0*(S perform/NN !/. (Chunk FUNCset/NNP) (/( (Chunk VARarray/NNP) ,/, ``/`` length/NN ''/'' ,/, (Chunk VARintlen/NNP) ,/, true/JJ )/) ./.)
*0*return VARarray.     
*0*(S return/NN (Chunk VARarray/NNP) ./.)
ID= 22.1.1.3
Summary= Array ( ...items )
*0*let VARnumberofargs be the number of arguments passed to this function call. 
*0*(S (Chunk let/VB VARnumberofargs/NNP) be/VB the/DT number/NN of/IN arguments/NNS passed/VBN to/TO this/DT function/NN call/NN ./.)
*0*assert: VARnumberofargs ≥ 2. 
*0*(S assert/NN :/: (Chunk VARnumberofargs/NNP) ≥/VBZ 2/CD ./.)
*0*if newtarget is undefined, let VARnewtarget be the active function object, else let VARnewtarget be newtarget. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, (Chunk let/VB VARnewtarget/NNP) be/VB the/DT active/JJ function/NN object/NN ,/, (Chunk else/RB let/VB VARnewtarget/NNP) be/VB newtarget/VBN ./.)
*0*let VARproto be ? FUNCgetprototypefromconstructor(VARnewtarget, "%arrayprototype%"). 
*0*(S (Chunk let/VB VARproto/NNP) be/VB ?/. (Chunk FUNCgetprototypefromconstructor/NNP) (/( (Chunk VARnewtarget/NNP) ,/, ``/`` %/NN arrayprototype/JJ %/NN ''/'' )/) ./.)
*0*let VARarray be ? FUNCarraycreate(VARnumberofargs, VARproto). 
*0*(S (Chunk let/VB VARarray/NNP) be/VB ?/. (Chunk FUNCarraycreate/NNP) (/( (Chunk VARnumberofargs/NNP) ,/, (Chunk VARproto/NNP) )/) ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*let VARitems be a zero-origined list containing the argument items in order. 
*0*(S (Chunk let/VB VARitems/NNP) be/VB a/DT zero-origined/JJ list/NN containing/VBG the/DT argument/NN items/NNS in/IN order/NN ./.)
*0*repeat, while VARk &lt; VARnumberofargs
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARnumberofargs/NNP))
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*let VARitemk be VARitems[VARk]. 
*1*(S (Chunk let/VB VARitemk/NNP) (Chunk be/VB VARitems/NNP) (Chunk [/NNP) (Chunk VARk/NNP) (Chunk ]/NNP) ./.)
*1*let VARdefinestatus be FUNCcreatedataproperty(VARarray, VARpk, VARitemk). 
*1*(S (Chunk let/VB VARdefinestatus/NNP) (Chunk be/VB FUNCcreatedataproperty/NNP) (/( (Chunk VARarray/NNP) ,/, (Chunk VARpk/NNP) ,/, (Chunk VARitemk/NNP) )/) ./.)
*1*assert: VARdefinestatus is true. 
*1*(S assert/NN :/: (Chunk VARdefinestatus/NNP) is/VBZ true/JJ ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*assert: the value of VARarray's length property is VARnumberofargs. 
*0*(S assert/NN :/: the/DT value/NN of/IN (Chunk VARarray/NNP) 's/POS length/NN property/NN (Chunk is/VBZ VARnumberofargs/NNP) ./.)
*0*return VARarray.     
*0*(S return/NN (Chunk VARarray/NNP) ./.)
ID= 22.1.2.1
Summary= Array.from ( items [ , mapfn [ , thisArg ] ] )
*0*let VARc be the this value. 
*0*(S (Chunk let/VB VARc/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if VARmapfn is undefined, let VARmapping be false. 
*0*(S if/IN (Chunk VARmapfn/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARmapping/NNP) be/VB false/JJ ./.)
*0*else,
*0*(S else/RB ,/,)
*1*if FUNCiscallable(VARmapfn) is false, throw a typeerror exception. 
*1*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARmapfn/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*1*(S if/IN (Chunk VARthisarg/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARt/NNP) (Chunk be/VB VARthisarg/NNP) ;/: else/JJ (Chunk let/VB VARt/NNP) be/VB undefined/VBN ./.)
*1*let VARmapping be true. 
*1*(S (Chunk let/VB VARmapping/NNP) be/VB true/JJ ./.)
*0*let VARusingiterator be ? FUNCgetmethod(VARitems, @@iterator). 
*0*(S (Chunk let/VB VARusingiterator/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARitems/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) iterator/NN )/) ./.)
*0*if VARusingiterator is not undefined, then
*0*(S if/IN (Chunk VARusingiterator/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*1*if FUNCisconstructor(VARc) is true, then
*1*(S if/IN (Chunk FUNCisconstructor/NNP) (/( (Chunk VARc/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*let VARa be ? FUNCconstruct(VARc). 
*2*(S (Chunk let/VB VARa/NNP) be/VB ?/. (Chunk FUNCconstruct/NNP) (/( (Chunk VARc/NNP) )/) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*let VARa be ! FUNCarraycreate(0). 
*2*(S (Chunk let/VB VARa/NNP) be/VB !/. (Chunk FUNCarraycreate/NNP) (/( 0/CD )/) ./.)
*1*let VARiteratorrecord be ? FUNCgetiterator(VARitems, sync, VARusingiterator). 
*1*(S (Chunk let/VB VARiteratorrecord/NNP) be/VB ?/. (Chunk FUNCgetiterator/NNP) (/( (Chunk VARitems/NNP) ,/, sync/NN ,/, (Chunk VARusingiterator/NNP) )/) ./.)
*1*let VARk be 0. 
*1*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*1*repeat,
*1*(S repeat/NN ,/,)
*2*if VARk ≥ 253-1, then
*2*(S if/IN (Chunk VARk/NNP) (Chunk ≥/NNP) 253-1/CD ,/, then/RB)
*3*let VARerror be FUNCthrowcompletion(a newly created typeerror object). 
*3*(S (Chunk let/VB VARerror/NNP) (Chunk be/VB FUNCthrowcompletion/NNP) (/( a/DT newly/RB created/VBN typeerror/NN object/NN )/) ./.)
*3*return ? FUNCiteratorclose(VARiteratorrecord, VARerror). 
*3*(S return/NN ?/. (Chunk FUNCiteratorclose/NNP) (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARerror/NNP) )/) ./.)
*2*let VARpk be ! FUNCtostring(VARk). 
*2*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*2*let VARnext be ? FUNCiteratorstep(VARiteratorrecord). 
*2*(S (Chunk let/VB VARnext/NNP) be/VB ?/. (Chunk FUNCiteratorstep/NNP) (/( (Chunk VARiteratorrecord/NNP) )/) ./.)
*2*if VARnext is false, then
*2*(S if/IN (Chunk VARnext/NNP) is/VBZ false/JJ ,/, then/RB)
*3*perform ? FUNCset(VARa, "length", VARk, true). 
*3*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` length/NN ''/'' ,/, (Chunk VARk/NNP) ,/, true/JJ )/) ./.)
*3*return VARa. 
*3*(S return/NN (Chunk VARa/NNP) ./.)
*2*let VARnextvalue be ? FUNCiteratorvalue(VARnext). 
*2*(S (Chunk let/VB VARnextvalue/NNP) be/VB ?/. (Chunk FUNCiteratorvalue/NNP) (/( (Chunk VARnext/NNP) )/) ./.)
*2*if VARmapping is true, then
*2*(S if/IN (Chunk VARmapping/NNP) is/VBZ true/JJ ,/, then/RB)
*3*let VARmappedvalue be FUNCcall(VARmapfn, VARt, « VARnextvalue, VARk »). 
*3*(S (Chunk let/VB VARmappedvalue/NNP) (Chunk be/VB FUNCcall/NNP) (/( (Chunk VARmapfn/NNP) ,/, (Chunk VARt/NNP) ,/, (Chunk «/NNP) (Chunk VARnextvalue/NNP) ,/, (Chunk VARk/NNP) (Chunk »/NNP) )/) ./.)
*3*if VARmappedvalue is an FUNCabrupt completion, return ? iteratorclose(VARiteratorrecord, VARmappedvalue). 
*3*(S if/IN (Chunk VARmappedvalue/NNP) is/VBZ an/DT (Chunk FUNCabrupt/NNP) completion/NN ,/, return/VB ?/. iteratorclose/JJ (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARmappedvalue/NNP) )/) ./.)
*3*let VARmappedvalue be VARmappedvalue.[[VALUE]]. 
*3*(S (Chunk let/VB VARmappedvalue/NNP) (Chunk be/VB VARmappedvalue/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*2*else, let VARmappedvalue be VARnextvalue. 
*2*(S else/RB ,/, (Chunk let/VB VARmappedvalue/NNP) (Chunk be/VB VARnextvalue/NNP) ./.)
*2*let VARdefinestatus be FUNCcreatedatapropertyorthrow(VARa, VARpk, VARmappedvalue). 
*2*(S (Chunk let/VB VARdefinestatus/NNP) (Chunk be/VB FUNCcreatedatapropertyorthrow/NNP) (/( (Chunk VARa/NNP) ,/, (Chunk VARpk/NNP) ,/, (Chunk VARmappedvalue/NNP) )/) ./.)
*2*if VARdefinestatus is an FUNCabrupt completion, return ? iteratorclose(VARiteratorrecord, VARdefinestatus). 
*2*(S if/IN (Chunk VARdefinestatus/NNP) is/VBZ an/DT (Chunk FUNCabrupt/NNP) completion/NN ,/, return/VB ?/. iteratorclose/JJ (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARdefinestatus/NNP) )/) ./.)
*2*increase VARk by 1. 
*2*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*note: VARitems is not an iterable so assume it is an array-like object. 
*0*(S note/NN :/: (Chunk VARitems/NNP) is/VBZ not/RB an/DT iterable/JJ so/RB assume/IN it/PRP is/VBZ an/DT array-like/JJ object/NN ./.)
*0*let VARarraylike be ! FUNCtoobject(VARitems). 
*0*(S (Chunk let/VB VARarraylike/NNP) be/VB !/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARitems/NNP) )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARarraylike, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARarraylike/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*if FUNCisconstructor(VARc) is true, then
*0*(S if/IN (Chunk FUNCisconstructor/NNP) (/( (Chunk VARc/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*let VARa be ? FUNCconstruct(VARc, « VARlen »). 
*1*(S (Chunk let/VB VARa/NNP) be/VB ?/. (Chunk FUNCconstruct/NNP) (/( (Chunk VARc/NNP) ,/, (Chunk «/NNP) (Chunk VARlen/NNP) (Chunk »/NNP) )/) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARa be ? FUNCarraycreate(VARlen). 
*1*(S (Chunk let/VB VARa/NNP) be/VB ?/. (Chunk FUNCarraycreate/NNP) (/( (Chunk VARlen/NNP) )/) ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*repeat, while VARk &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*let VARkvalue be ? FUNCget(VARarraylike, VARpk). 
*1*(S (Chunk let/VB VARkvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARarraylike/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*1*if VARmapping is true, then
*1*(S if/IN (Chunk VARmapping/NNP) is/VBZ true/JJ ,/, then/RB)
*2*let VARmappedvalue be ? FUNCcall(VARmapfn, VARt, « VARkvalue, VARk »). 
*2*(S (Chunk let/VB VARmappedvalue/NNP) be/VB ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARmapfn/NNP) ,/, (Chunk VARt/NNP) ,/, (Chunk «/NNP) (Chunk VARkvalue/NNP) ,/, (Chunk VARk/NNP) (Chunk »/NNP) )/) ./.)
*1*else, let VARmappedvalue be VARkvalue. 
*1*(S else/RB ,/, (Chunk let/VB VARmappedvalue/NNP) (Chunk be/VB VARkvalue/NNP) ./.)
*1*perform ? FUNCcreatedatapropertyorthrow(VARa, VARpk, VARmappedvalue). 
*1*(S perform/NN ?/. (Chunk FUNCcreatedatapropertyorthrow/NNP) (/( (Chunk VARa/NNP) ,/, (Chunk VARpk/NNP) ,/, (Chunk VARmappedvalue/NNP) )/) ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*perform ? FUNCset(VARa, "length", VARlen, true). 
*0*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` length/NN ''/'' ,/, (Chunk VARlen/NNP) ,/, true/JJ )/) ./.)
*0*return VARa.     
*0*(S return/NN (Chunk VARa/NNP) ./.)
ID= 22.1.2.2
Summary= Array.isArray ( arg )
*0*return ? FUNCisarray(VARarg).     
*0*(S return/NN ?/. (Chunk FUNCisarray/NNP) (/( (Chunk VARarg/NNP) )/) ./.)
ID= 22.1.2.3
Summary= Array.of ( ...items )
*0*let VARlen be the actual number of arguments passed to this function. 
*0*(S (Chunk let/VB VARlen/NNP) be/VB the/DT actual/JJ number/NN of/IN arguments/NNS passed/VBN to/TO this/DT function/NN ./.)
*0*let VARitems be the list of arguments passed to this function. 
*0*(S (Chunk let/VB VARitems/NNP) be/VB the/DT list/NN of/IN arguments/NNS passed/VBN to/TO this/DT function/NN ./.)
*0*let VARc be the this value. 
*0*(S (Chunk let/VB VARc/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCisconstructor(VARc) is true, then
*0*(S if/IN (Chunk FUNCisconstructor/NNP) (/( (Chunk VARc/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*let VARa be ? FUNCconstruct(VARc, « VARlen »). 
*1*(S (Chunk let/VB VARa/NNP) be/VB ?/. (Chunk FUNCconstruct/NNP) (/( (Chunk VARc/NNP) ,/, (Chunk «/NNP) (Chunk VARlen/NNP) (Chunk »/NNP) )/) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARa be ? FUNCarraycreate(VARlen). 
*1*(S (Chunk let/VB VARa/NNP) be/VB ?/. (Chunk FUNCarraycreate/NNP) (/( (Chunk VARlen/NNP) )/) ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*repeat, while VARk &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*let VARkvalue be VARitems[VARk]. 
*1*(S (Chunk let/VB VARkvalue/NNP) (Chunk be/VB VARitems/NNP) (Chunk [/NNP) (Chunk VARk/NNP) (Chunk ]/NNP) ./.)
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*perform ? FUNCcreatedatapropertyorthrow(VARa, VARpk, VARkvalue). 
*1*(S perform/NN ?/. (Chunk FUNCcreatedatapropertyorthrow/NNP) (/( (Chunk VARa/NNP) ,/, (Chunk VARpk/NNP) ,/, (Chunk VARkvalue/NNP) )/) ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*perform ? FUNCset(VARa, "length", VARlen, true). 
*0*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` length/NN ''/'' ,/, (Chunk VARlen/NNP) ,/, true/JJ )/) ./.)
*0*return VARa.     
*0*(S return/NN (Chunk VARa/NNP) ./.)
ID= 22.1.3.1
Summary= Array.prototype.concat ( ...arguments )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARa be ? FUNCarrayspeciescreate(VARo, 0). 
*0*(S (Chunk let/VB VARa/NNP) be/VB ?/. (Chunk FUNCarrayspeciescreate/NNP) (/( (Chunk VARo/NNP) ,/, 0/CD )/) ./.)
*0*let VARn be 0. 
*0*(S (Chunk let/VB VARn/NNP) be/VB 0/CD ./.)
*0*let VARitems be a list whose first element is VARo and whose subsequent elements are, in left to right order, the arguments that were passed to this function invocation. 
*0*(S (Chunk let/VB VARitems/NNP) be/VB a/DT list/NN whose/WP$ first/JJ element/NN (Chunk is/VBZ VARo/NNP) and/CC whose/WP$ subsequent/JJ elements/NNS are/VBP ,/, in/IN left/VBN to/TO right/JJ order/NN ,/, the/DT arguments/NNS that/WDT were/VBD passed/VBN to/TO this/DT function/NN invocation/NN ./.)
*0*repeat, while VARitems is not empty
*0*(S repeat/NN ,/, while/IN (Chunk VARitems/NNP) is/VBZ not/RB empty/JJ)
*1*remove the first element from VARitems and let VARe be the value of the element. 
*1*(S remove/VB the/DT first/JJ element/NN from/IN (Chunk VARitems/NNP) and/CC (Chunk let/VB VARe/NNP) be/VB the/DT value/NN of/IN the/DT element/NN ./.)
*1*let VARspreadable be ? FUNCisconcatspreadable(VARe). 
*1*(S let/VB VARspreadable/JJ be/VB ?/. (Chunk FUNCisconcatspreadable/NNP) (/( (Chunk VARe/NNP) )/) ./.)
*1*if VARspreadable is true, then
*1*(S if/IN (Chunk VARspreadable/NNP) is/VBZ true/JJ ,/, then/RB)
*2*let VARk be 0. 
*2*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*2*let VARlen be ? FUNCtolength(? FUNCget(VARe, "length")). 
*2*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARe/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*2*if VARn + VARlen &gt; 253-1, throw a typeerror exception. 
*2*(S if/IN (Chunk VARn/NNP) (Chunk +/NNP) (Chunk VARlen/NNP) &/CC gt/NN ;/: 253-1/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*2*repeat, while VARk &lt; VARlen
*2*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*3*let VARp be ! FUNCtostring(VARk). 
*3*(S (Chunk let/VB VARp/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*3*let VARexists be ? FUNChasproperty(VARe, VARp). 
*3*(S let/VB VARexists/NNS be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARe/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
*3*if VARexists is true, then
*3*(S if/IN VARexists/NNS is/VBZ true/JJ ,/, then/RB)
*4*let VARsubelement be ? FUNCget(VARe, VARp). 
*4*(S (Chunk let/VB VARsubelement/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARe/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
*4*perform ? FUNCcreatedatapropertyorthrow(VARa, ! FUNCtostring(VARn), VARsubelement). 
*4*(S perform/NN ?/. (Chunk FUNCcreatedatapropertyorthrow/NNP) (/( (Chunk VARa/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARn/NNP) )/) ,/, (Chunk VARsubelement/NNP) )/) ./.)
*3*increase VARn by 1. 
*3*(S increase/NN (Chunk VARn/NNP) by/IN 1/CD ./.)
*3*increase VARk by 1. 
*3*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*1*else VARe is added as a single item rather than spread,
*1*(S (Chunk else/RB VARe/NNP) is/VBZ added/VBN as/IN a/DT single/JJ item/NN rather/RB than/IN spread/NN ,/,)
*2*if VARn≥253-1, throw a typeerror exception. 
*2*(S if/IN (Chunk VARn≥253-1/NNP) ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*2*perform ? FUNCcreatedatapropertyorthrow(VARa, ! FUNCtostring(VARn), VARe). 
*2*(S perform/NN ?/. (Chunk FUNCcreatedatapropertyorthrow/NNP) (/( (Chunk VARa/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARn/NNP) )/) ,/, (Chunk VARe/NNP) )/) ./.)
*2*increase VARn by 1. 
*2*(S increase/NN (Chunk VARn/NNP) by/IN 1/CD ./.)
*0*perform ? FUNCset(VARa, "length", VARn, true). 
*0*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` length/NN ''/'' ,/, (Chunk VARn/NNP) ,/, true/JJ )/) ./.)
*0*return VARa.     
*0*(S return/NN (Chunk VARa/NNP) ./.)
ID= 22.1.3.1.1
Summary= Runtime Semantics: IsConcatSpreadable ( O )
*0*if FUNCtype(VARo) is not object, return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, return/NN false/JJ ./.)
*0*let VARspreadable be ? FUNCget(VARo, @@isconcatspreadable). 
*0*(S let/VB VARspreadable/JJ be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) isconcatspreadable/JJ )/) ./.)
*0*if VARspreadable is not undefined, return FUNCtoboolean(VARspreadable). 
*0*(S if/IN (Chunk VARspreadable/NNP) is/VBZ not/RB undefined/JJ ,/, return/JJ (Chunk FUNCtoboolean/NNP) (/( (Chunk VARspreadable/NNP) )/) ./.)
*0*return ? FUNCisarray(VARo).      
*0*(S return/NN ?/. (Chunk FUNCisarray/NNP) (/( (Chunk VARo/NNP) )/) ./.)
ID= 22.1.3.3
Summary= Array.prototype.copyWithin ( target, start [ , end ] )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*let VARrelativetarget be ? FUNCtointeger(VARtarget). 
*0*(S (Chunk let/VB VARrelativetarget/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARtarget/NNP) )/) ./.)
*0*if VARrelativetarget &lt; 0, let VARto be max((VARlen + VARrelativetarget), 0); else let VARto be min(VARrelativetarget, VARlen). 
*0*(S if/IN (Chunk VARrelativetarget/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARto/NNP) be/VB max/VBN (/( (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARrelativetarget/NNP) )/) ,/, 0/CD )/) ;/: else/JJ (Chunk let/VB VARto/NNP) be/VB min/VBN (/( (Chunk VARrelativetarget/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*let VARrelativestart be ? FUNCtointeger(VARstart). 
*0*(S (Chunk let/VB VARrelativestart/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARstart/NNP) )/) ./.)
*0*if VARrelativestart &lt; 0, let VARfrom be max((VARlen + VARrelativestart), 0); else let VARfrom be min(VARrelativestart, VARlen). 
*0*(S if/IN (Chunk VARrelativestart/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARfrom/NNP) be/VB max/VBN (/( (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARrelativestart/NNP) )/) ,/, 0/CD )/) ;/: else/JJ let/NN (Chunk VARfrom/NNP) be/VB min/VBN (/( (Chunk VARrelativestart/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*if VARend is undefined, let VARrelativeend be VARlen; else let VARrelativeend be ? FUNCtointeger(VARend). 
*0*(S if/IN (Chunk VARend/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARrelativeend/NNP) (Chunk be/VB VARlen/NNP) ;/: else/JJ (Chunk let/VB VARrelativeend/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARend/NNP) )/) ./.)
*0*if VARrelativeend &lt; 0, let VARfinal be max((VARlen + VARrelativeend), 0); else let VARfinal be min(VARrelativeend, VARlen). 
*0*(S if/IN (Chunk VARrelativeend/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARfinal/NNP) be/VB max/VBN (/( (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARrelativeend/NNP) )/) ,/, 0/CD )/) ;/: else/JJ (Chunk let/VB VARfinal/NNP) be/VB min/VBN (/( (Chunk VARrelativeend/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*let VARcount be min(VARfinal-VARfrom, VARlen-VARto). 
*0*(S (Chunk let/VB VARcount/NNP) be/VB min/VBN (/( VARfinal-VARfrom/JJ ,/, (Chunk VARlen-VARto/NNP) )/) ./.)
*0*if VARfrom&lt;VARto and VARto&lt;VARfrom+VARcount, then
*0*(S if/IN (Chunk VARfrom/NNP) &/CC lt/NN ;/: (Chunk VARto/NNP) and/CC (Chunk VARto/NNP) &/CC lt/NN ;/: (Chunk VARfrom+VARcount/NNP) ,/, then/RB)
*1*let VARdirection be -1. 
*1*(S (Chunk let/VB VARdirection/NNP) be/VB -1/VBN ./.)
*1*let VARfrom be VARfrom + VARcount - 1. 
*1*(S (Chunk let/VB VARfrom/NNP) (Chunk be/VB VARfrom/NNP) (Chunk +/NNP) (Chunk VARcount/NNP) -/: 1/CD ./.)
*1*let VARto be VARto + VARcount - 1. 
*1*(S (Chunk let/VB VARto/NNP) (Chunk be/VB VARto/NNP) (Chunk +/NNP) (Chunk VARcount/NNP) -/: 1/CD ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARdirection be 1. 
*1*(S (Chunk let/VB VARdirection/NNP) be/VB 1/CD ./.)
*0*repeat, while VARcount &gt; 0
*0*(S repeat/NN ,/, while/IN (Chunk VARcount/NNP) &/CC gt/NN ;/: 0/CD)
*1*let VARfromkey be ! FUNCtostring(VARfrom). 
*1*(S (Chunk let/VB VARfromkey/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARfrom/NNP) )/) ./.)
*1*let VARtokey be ! FUNCtostring(VARto). 
*1*(S (Chunk let/VB VARtokey/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARto/NNP) )/) ./.)
*1*let VARfrompresent be ? FUNChasproperty(VARo, VARfromkey). 
*1*(S (Chunk let/VB VARfrompresent/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARfromkey/NNP) )/) ./.)
*1*if VARfrompresent is true, then
*1*(S if/IN (Chunk VARfrompresent/NNP) is/VBZ true/JJ ,/, then/RB)
*2*let VARfromval be ? FUNCget(VARo, VARfromkey). 
*2*(S (Chunk let/VB VARfromval/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARfromkey/NNP) )/) ./.)
*2*perform ? FUNCset(VARo, VARtokey, VARfromval, true). 
*2*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARtokey/NNP) ,/, (Chunk VARfromval/NNP) ,/, true/JJ )/) ./.)
*1*else VARfrompresent is false,
*1*(S (Chunk else/RB VARfrompresent/NNP) is/VBZ false/JJ ,/,)
*2*perform ? FUNCdeletepropertyorthrow(VARo, VARtokey). 
*2*(S perform/NN ?/. (Chunk FUNCdeletepropertyorthrow/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARtokey/NNP) )/) ./.)
*1*let VARfrom be VARfrom + VARdirection. 
*1*(S (Chunk let/VB VARfrom/NNP) (Chunk be/VB VARfrom/NNP) (Chunk +/NNP) (Chunk VARdirection/NNP) ./.)
*1*let VARto be VARto + VARdirection. 
*1*(S (Chunk let/VB VARto/NNP) (Chunk be/VB VARto/NNP) (Chunk +/NNP) (Chunk VARdirection/NNP) ./.)
*1*let VARcount be VARcount - 1. 
*1*(S (Chunk let/VB VARcount/NNP) (Chunk be/VB VARcount/NNP) -/: 1/CD ./.)
*0*return VARo.     
*0*(S return/NN (Chunk VARo/NNP) ./.)
ID= 22.1.3.4
Summary= Array.prototype.entries ( )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*return FUNCcreatearrayiterator(VARo, "key+value").     
*0*(S return/NN (Chunk FUNCcreatearrayiterator/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` key+value/VB ''/'' )/) ./.)
ID= 22.1.3.5
Summary= Array.prototype.every ( callbackfn [ , thisArg ] )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARcallbackfn/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*(S if/IN (Chunk VARthisarg/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARt/NNP) (Chunk be/VB VARthisarg/NNP) ;/: else/JJ (Chunk let/VB VARt/NNP) be/VB undefined/VBN ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*repeat, while VARk &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*let VARkpresent be ? FUNChasproperty(VARo, VARpk). 
*1*(S (Chunk let/VB VARkpresent/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*1*if VARkpresent is true, then
*1*(S if/IN (Chunk VARkpresent/NNP) is/VBZ true/JJ ,/, then/RB)
*2*let VARkvalue be ? FUNCget(VARo, VARpk). 
*2*(S (Chunk let/VB VARkvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*2*let VARtestresult be FUNCtoboolean(? FUNCcall(VARcallbackfn, VARt, « VARkvalue, VARk, VARo »)). 
*2*(S (Chunk let/VB VARtestresult/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARcallbackfn/NNP) ,/, (Chunk VARt/NNP) ,/, (Chunk «/NNP) (Chunk VARkvalue/NNP) ,/, (Chunk VARk/NNP) ,/, (Chunk VARo/NNP) (Chunk »/NNP) )/) )/) ./.)
*2*if VARtestresult is false, return false. 
*2*(S if/IN (Chunk VARtestresult/NNP) is/VBZ false/JJ ,/, return/NN false/JJ ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*return true.     
*0*(S return/NN true/JJ ./.)
ID= 22.1.3.6
Summary= Array.prototype.fill ( value [ , start [ , end ] ] )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*let VARrelativestart be ? FUNCtointeger(VARstart). 
*0*(S (Chunk let/VB VARrelativestart/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARstart/NNP) )/) ./.)
*0*if VARrelativestart &lt; 0, let VARk be max((VARlen + VARrelativestart), 0); else let VARk be min(VARrelativestart, VARlen). 
*0*(S if/IN (Chunk VARrelativestart/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARk/NNP) be/VB max/VBN (/( (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARrelativestart/NNP) )/) ,/, 0/CD )/) ;/: else/JJ let/NN (Chunk VARk/NNP) be/VB min/VBN (/( (Chunk VARrelativestart/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*if VARend is undefined, let VARrelativeend be VARlen; else let VARrelativeend be ? FUNCtointeger(VARend). 
*0*(S if/IN (Chunk VARend/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARrelativeend/NNP) (Chunk be/VB VARlen/NNP) ;/: else/JJ (Chunk let/VB VARrelativeend/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARend/NNP) )/) ./.)
*0*if VARrelativeend &lt; 0, let VARfinal be max((VARlen + VARrelativeend), 0); else let VARfinal be min(VARrelativeend, VARlen). 
*0*(S if/IN (Chunk VARrelativeend/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARfinal/NNP) be/VB max/VBN (/( (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARrelativeend/NNP) )/) ,/, 0/CD )/) ;/: else/JJ (Chunk let/VB VARfinal/NNP) be/VB min/VBN (/( (Chunk VARrelativeend/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*repeat, while VARk &lt; VARfinal
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARfinal/NNP))
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*perform ? FUNCset(VARo, VARpk, VARvalue, true). 
*1*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) ,/, (Chunk VARvalue/NNP) ,/, true/JJ )/) ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*return VARo.     
*0*(S return/NN (Chunk VARo/NNP) ./.)
ID= 22.1.3.7
Summary= Array.prototype.filter ( callbackfn [ , thisArg ] )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARcallbackfn/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*(S if/IN (Chunk VARthisarg/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARt/NNP) (Chunk be/VB VARthisarg/NNP) ;/: else/JJ (Chunk let/VB VARt/NNP) be/VB undefined/VBN ./.)
*0*let VARa be ? FUNCarrayspeciescreate(VARo, 0). 
*0*(S (Chunk let/VB VARa/NNP) be/VB ?/. (Chunk FUNCarrayspeciescreate/NNP) (/( (Chunk VARo/NNP) ,/, 0/CD )/) ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*let VARto be 0. 
*0*(S (Chunk let/VB VARto/NNP) be/VB 0/CD ./.)
*0*repeat, while VARk &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*let VARkpresent be ? FUNChasproperty(VARo, VARpk). 
*1*(S (Chunk let/VB VARkpresent/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*1*if VARkpresent is true, then
*1*(S if/IN (Chunk VARkpresent/NNP) is/VBZ true/JJ ,/, then/RB)
*2*let VARkvalue be ? FUNCget(VARo, VARpk). 
*2*(S (Chunk let/VB VARkvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*2*let VARselected be FUNCtoboolean(? FUNCcall(VARcallbackfn, VARt, « VARkvalue, VARk, VARo »)). 
*2*(S (Chunk let/VB VARselected/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARcallbackfn/NNP) ,/, (Chunk VARt/NNP) ,/, (Chunk «/NNP) (Chunk VARkvalue/NNP) ,/, (Chunk VARk/NNP) ,/, (Chunk VARo/NNP) (Chunk »/NNP) )/) )/) ./.)
*2*if VARselected is true, then
*2*(S if/IN VARselected/VBN is/VBZ true/JJ ,/, then/RB)
*3*perform ? FUNCcreatedatapropertyorthrow(VARa, ! FUNCtostring(VARto), VARkvalue). 
*3*(S perform/NN ?/. (Chunk FUNCcreatedatapropertyorthrow/NNP) (/( (Chunk VARa/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARto/NNP) )/) ,/, (Chunk VARkvalue/NNP) )/) ./.)
*3*increase VARto by 1. 
*3*(S increase/NN (Chunk VARto/NNP) by/IN 1/CD ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*return VARa.     
*0*(S return/NN (Chunk VARa/NNP) ./.)
ID= 22.1.3.8
Summary= Array.prototype.find ( predicate [ , thisArg ] )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*if FUNCiscallable(VARpredicate) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARpredicate/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*(S if/IN (Chunk VARthisarg/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARt/NNP) (Chunk be/VB VARthisarg/NNP) ;/: else/JJ (Chunk let/VB VARt/NNP) be/VB undefined/VBN ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*repeat, while VARk &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*let VARkvalue be ? FUNCget(VARo, VARpk). 
*1*(S (Chunk let/VB VARkvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*1*let VARtestresult be FUNCtoboolean(? FUNCcall(VARpredicate, VARt, « VARkvalue, VARk, VARo »)). 
*1*(S (Chunk let/VB VARtestresult/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARpredicate/NNP) ,/, (Chunk VARt/NNP) ,/, (Chunk «/NNP) (Chunk VARkvalue/NNP) ,/, (Chunk VARk/NNP) ,/, (Chunk VARo/NNP) (Chunk »/NNP) )/) )/) ./.)
*1*if VARtestresult is true, return VARkvalue. 
*1*(S if/IN (Chunk VARtestresult/NNP) is/VBZ true/JJ ,/, (Chunk return/VB VARkvalue/NNP) ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*return undefined.     
*0*(S return/NN undefined/VBD ./.)
ID= 22.1.3.9
Summary= Array.prototype.findIndex ( predicate [ , thisArg ] )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*if FUNCiscallable(VARpredicate) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARpredicate/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*(S if/IN (Chunk VARthisarg/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARt/NNP) (Chunk be/VB VARthisarg/NNP) ;/: else/JJ (Chunk let/VB VARt/NNP) be/VB undefined/VBN ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*repeat, while VARk &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*let VARkvalue be ? FUNCget(VARo, VARpk). 
*1*(S (Chunk let/VB VARkvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*1*let VARtestresult be FUNCtoboolean(? FUNCcall(VARpredicate, VARt, « VARkvalue, VARk, VARo »)). 
*1*(S (Chunk let/VB VARtestresult/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARpredicate/NNP) ,/, (Chunk VARt/NNP) ,/, (Chunk «/NNP) (Chunk VARkvalue/NNP) ,/, (Chunk VARk/NNP) ,/, (Chunk VARo/NNP) (Chunk »/NNP) )/) )/) ./.)
*1*if VARtestresult is true, return VARk. 
*1*(S if/IN (Chunk VARtestresult/NNP) is/VBZ true/JJ ,/, return/JJ (Chunk VARk/NNP) ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*return -1.     
*0*(S return/NN -1/NN ./.)
ID= 22.1.3.10
Summary= Array.prototype.forEach ( callbackfn [ , thisArg ] )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARcallbackfn/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*(S if/IN (Chunk VARthisarg/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARt/NNP) (Chunk be/VB VARthisarg/NNP) ;/: else/JJ (Chunk let/VB VARt/NNP) be/VB undefined/VBN ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*repeat, while VARk &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*let VARkpresent be ? FUNChasproperty(VARo, VARpk). 
*1*(S (Chunk let/VB VARkpresent/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*1*if VARkpresent is true, then
*1*(S if/IN (Chunk VARkpresent/NNP) is/VBZ true/JJ ,/, then/RB)
*2*let VARkvalue be ? FUNCget(VARo, VARpk). 
*2*(S (Chunk let/VB VARkvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*2*perform ? FUNCcall(VARcallbackfn, VARt, « VARkvalue, VARk, VARo »). 
*2*(S perform/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARcallbackfn/NNP) ,/, (Chunk VARt/NNP) ,/, (Chunk «/NNP) (Chunk VARkvalue/NNP) ,/, (Chunk VARk/NNP) ,/, (Chunk VARo/NNP) (Chunk »/NNP) )/) ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*return undefined.     
*0*(S return/NN undefined/VBD ./.)
ID= 22.1.3.11
Summary= Array.prototype.includes ( searchElement [ , fromIndex ] )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*if VARlen is 0, return false. 
*0*(S if/IN (Chunk VARlen/NNP) is/VBZ 0/CD ,/, return/NN false/JJ ./.)
*0*let VARn be ? FUNCtointeger(VARfromindex). (if VARfromindex is undefined, this step produces the value 0.) 
*0*(S (Chunk let/VB VARn/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARfromindex/NNP) )/) ./. (/( if/IN (Chunk VARfromindex/NNP) is/VBZ undefined/JJ ,/, this/DT step/NN produces/VBZ the/DT value/NN (Chunk 0/NNP) ./. )/))
*0*if VARn ≥ 0, then
*0*(S if/IN (Chunk VARn/NNP) ≥/VBD 0/CD ,/, then/RB)
*1*let VARk be VARn. 
*1*(S (Chunk let/VB VARk/NNP) (Chunk be/VB VARn/NNP) ./.)
*0*else VARn &lt; 0,
*0*(S (Chunk else/RB VARn/NNP) &/CC lt/NN ;/: 0/CD ,/,)
*1*let VARk be VARlen + VARn. 
*1*(S (Chunk let/VB VARk/NNP) (Chunk be/VB VARlen/NNP) (Chunk +/NNP) (Chunk VARn/NNP) ./.)
*1*if VARk &lt; 0, let VARk be 0. 
*1*(S if/IN (Chunk VARk/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*repeat, while VARk &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*let VARelementk be the result of ? FUNCget(VARo, ! FUNCtostring(VARk)). 
*1*(S (Chunk let/VB VARelementk/NNP) be/VB the/DT result/NN of/IN ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) )/) ./.)
*1*if FUNCsamevaluezero(VARsearchelement, VARelementk) is true, return true. 
*1*(S if/IN (Chunk FUNCsamevaluezero/NNP) (/( (Chunk VARsearchelement/NNP) ,/, (Chunk VARelementk/NNP) )/) is/VBZ true/JJ ,/, return/VB true/JJ ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 22.1.3.12
Summary= Array.prototype.indexOf ( searchElement [ , fromIndex ] )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*if VARlen is 0, return -1. 
*0*(S if/IN (Chunk VARlen/NNP) is/VBZ 0/CD ,/, return/NN -1/NN ./.)
*0*let VARn be ? FUNCtointeger(VARfromindex). (if VARfromindex is undefined, this step produces the value 0.) 
*0*(S (Chunk let/VB VARn/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARfromindex/NNP) )/) ./. (/( if/IN (Chunk VARfromindex/NNP) is/VBZ undefined/JJ ,/, this/DT step/NN produces/VBZ the/DT value/NN (Chunk 0/NNP) ./. )/))
*0*if VARn ≥ VARlen, return -1. 
*0*(S if/IN (Chunk VARn/NNP) (Chunk ≥/NNP) (Chunk VARlen/NNP) ,/, return/NN -1/NN ./.)
*0*if VARn ≥ 0, then
*0*(S if/IN (Chunk VARn/NNP) ≥/VBD 0/CD ,/, then/RB)
*1*if VARn is -0, let VARk be +0; else let VARk be VARn. 
*1*(S if/IN (Chunk VARn/NNP) is/VBZ -0/JJ ,/, (Chunk let/VB VARk/NNP) be/VB +0/VBN ;/: else/JJ let/NN (Chunk VARk/NNP) (Chunk be/VB VARn/NNP) ./.)
*0*else VARn &lt; 0,
*0*(S (Chunk else/RB VARn/NNP) &/CC lt/NN ;/: 0/CD ,/,)
*1*let VARk be VARlen + VARn. 
*1*(S (Chunk let/VB VARk/NNP) (Chunk be/VB VARlen/NNP) (Chunk +/NNP) (Chunk VARn/NNP) ./.)
*1*if VARk &lt; 0, let VARk be 0. 
*1*(S if/IN (Chunk VARk/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*repeat, while VARk &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*let VARkpresent be ? FUNChasproperty(VARo, ! FUNCtostring(VARk)). 
*1*(S (Chunk let/VB VARkpresent/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARo/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) )/) ./.)
*1*if VARkpresent is true, then
*1*(S if/IN (Chunk VARkpresent/NNP) is/VBZ true/JJ ,/, then/RB)
*2*let VARelementk be ? FUNCget(VARo, ! FUNCtostring(VARk)). 
*2*(S (Chunk let/VB VARelementk/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) )/) ./.)
*2*let VARsame be the result of performing strict equality comparison VARsearchelement === VARelementk. 
*2*(S (Chunk let/VB VARsame/NNP) be/VB the/DT result/NN of/IN performing/VBG strict/JJ equality/NN comparison/NN (Chunk VARsearchelement/NNP) (Chunk ===/NNP) (Chunk VARelementk/NNP) ./.)
*2*if VARsame is true, return VARk. 
*2*(S if/IN (Chunk VARsame/NNP) is/VBZ true/JJ ,/, return/JJ (Chunk VARk/NNP) ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*return -1.     
*0*(S return/NN -1/NN ./.)
ID= 22.1.3.13
Summary= Array.prototype.join ( separator )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*if VARseparator is undefined, let VARsep be the single-element string ",". 
*0*(S if/IN (Chunk VARseparator/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARsep/NNP) be/VB the/DT single-element/JJ string/NN ``/`` ,/, ''/'' ./.)
*0*else, let VARsep be ? FUNCtostring(VARseparator). 
*0*(S else/RB ,/, (Chunk let/VB VARsep/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARseparator/NNP) )/) ./.)
*0*let VARr be the empty string. 
*0*(S (Chunk let/VB VARr/NNP) be/VB the/DT empty/JJ string/NN ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*repeat, while VARk &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*if VARk &gt; 0, let VARr be the string-concatenation of VARr and VARsep. 
*1*(S if/IN (Chunk VARk/NNP) &/CC gt/NN ;/: 0/CD ,/, (Chunk let/VB VARr/NNP) be/VB the/DT string-concatenation/NN of/IN (Chunk VARr/NNP) and/CC (Chunk VARsep/NNP) ./.)
*1*let VARelement be ? FUNCget(VARo, ! FUNCtostring(VARk)). 
*1*(S (Chunk let/VB VARelement/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) )/) ./.)
*1*if VARelement is undefined or null, let VARnext be the empty string; otherwise, let VARnext be ? FUNCtostring(VARelement). 
*1*(S if/IN (Chunk VARelement/NNP) is/VBZ undefined/JJ or/CC null/JJ ,/, (Chunk let/VB VARnext/NNP) be/VB the/DT empty/JJ string/NN ;/: otherwise/RB ,/, (Chunk let/VB VARnext/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARelement/NNP) )/) ./.)
*1*set VARr to the string-concatenation of VARr and VARnext. 
*1*(S (Chunk set/VBN VARr/NNP) to/TO the/DT string-concatenation/NN of/IN (Chunk VARr/NNP) and/CC (Chunk VARnext/NNP) ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*return VARr.     
*0*(S return/NN (Chunk VARr/NNP) ./.)
ID= 22.1.3.14
Summary= Array.prototype.keys ( )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*return FUNCcreatearrayiterator(VARo, "key").     
*0*(S return/NN (Chunk FUNCcreatearrayiterator/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` key/JJ ''/'' )/) ./.)
ID= 22.1.3.15
Summary= Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*if VARlen is 0, return -1. 
*0*(S if/IN (Chunk VARlen/NNP) is/VBZ 0/CD ,/, return/NN -1/NN ./.)
*0*if VARfromindex is present, let VARn be ? FUNCtointeger(VARfromindex); else let VARn be VARlen-1. 
*0*(S if/IN (Chunk VARfromindex/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARn/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARfromindex/NNP) )/) ;/: else/JJ let/NN (Chunk VARn/NNP) (Chunk be/VB VARlen-1/NNP) ./.)
*0*if VARn ≥ 0, then
*0*(S if/IN (Chunk VARn/NNP) ≥/VBD 0/CD ,/, then/RB)
*1*if VARn is -0, let VARk be +0; else let VARk be min(VARn, VARlen - 1). 
*1*(S if/IN (Chunk VARn/NNP) is/VBZ -0/JJ ,/, (Chunk let/VB VARk/NNP) be/VB +0/VBN ;/: else/JJ let/NN (Chunk VARk/NNP) be/VB min/VBN (/( (Chunk VARn/NNP) ,/, (Chunk VARlen/NNP) -/: 1/CD )/) ./.)
*0*else VARn &lt; 0,
*0*(S (Chunk else/RB VARn/NNP) &/CC lt/NN ;/: 0/CD ,/,)
*1*let VARk be VARlen + VARn. 
*1*(S (Chunk let/VB VARk/NNP) (Chunk be/VB VARlen/NNP) (Chunk +/NNP) (Chunk VARn/NNP) ./.)
*0*repeat, while VARk ≥ 0
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) ≥/VBD 0/CD)
*1*let VARkpresent be ? FUNChasproperty(VARo, ! FUNCtostring(VARk)). 
*1*(S (Chunk let/VB VARkpresent/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARo/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) )/) ./.)
*1*if VARkpresent is true, then
*1*(S if/IN (Chunk VARkpresent/NNP) is/VBZ true/JJ ,/, then/RB)
*2*let VARelementk be ? FUNCget(VARo, ! FUNCtostring(VARk)). 
*2*(S (Chunk let/VB VARelementk/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) )/) ./.)
*2*let VARsame be the result of performing strict equality comparison VARsearchelement === VARelementk. 
*2*(S (Chunk let/VB VARsame/NNP) be/VB the/DT result/NN of/IN performing/VBG strict/JJ equality/NN comparison/NN (Chunk VARsearchelement/NNP) (Chunk ===/NNP) (Chunk VARelementk/NNP) ./.)
*2*if VARsame is true, return VARk. 
*2*(S if/IN (Chunk VARsame/NNP) is/VBZ true/JJ ,/, return/JJ (Chunk VARk/NNP) ./.)
*1*decrease VARk by 1. 
*1*(S decrease/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*return -1.     
*0*(S return/NN -1/NN ./.)
ID= 22.1.3.16
Summary= Array.prototype.map ( callbackfn [ , thisArg ] )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARcallbackfn/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*(S if/IN (Chunk VARthisarg/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARt/NNP) (Chunk be/VB VARthisarg/NNP) ;/: else/JJ (Chunk let/VB VARt/NNP) be/VB undefined/VBN ./.)
*0*let VARa be ? FUNCarrayspeciescreate(VARo, VARlen). 
*0*(S (Chunk let/VB VARa/NNP) be/VB ?/. (Chunk FUNCarrayspeciescreate/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*repeat, while VARk &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*let VARkpresent be ? FUNChasproperty(VARo, VARpk). 
*1*(S (Chunk let/VB VARkpresent/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*1*if VARkpresent is true, then
*1*(S if/IN (Chunk VARkpresent/NNP) is/VBZ true/JJ ,/, then/RB)
*2*let VARkvalue be ? FUNCget(VARo, VARpk). 
*2*(S (Chunk let/VB VARkvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*2*let VARmappedvalue be ? FUNCcall(VARcallbackfn, VARt, « VARkvalue, VARk, VARo »). 
*2*(S (Chunk let/VB VARmappedvalue/NNP) be/VB ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARcallbackfn/NNP) ,/, (Chunk VARt/NNP) ,/, (Chunk «/NNP) (Chunk VARkvalue/NNP) ,/, (Chunk VARk/NNP) ,/, (Chunk VARo/NNP) (Chunk »/NNP) )/) ./.)
*2*perform ? FUNCcreatedatapropertyorthrow(VARa, VARpk, VARmappedvalue). 
*2*(S perform/NN ?/. (Chunk FUNCcreatedatapropertyorthrow/NNP) (/( (Chunk VARa/NNP) ,/, (Chunk VARpk/NNP) ,/, (Chunk VARmappedvalue/NNP) )/) ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*return VARa.     
*0*(S return/NN (Chunk VARa/NNP) ./.)
ID= 22.1.3.17
Summary= Array.prototype.pop ( )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*if VARlen is zero, then
*0*(S if/IN (Chunk VARlen/NNP) is/VBZ zero/CD ,/, then/RB)
*1*perform ? FUNCset(VARo, "length", 0, true). 
*1*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' ,/, 0/CD ,/, true/JJ )/) ./.)
*1*return undefined. 
*1*(S return/NN undefined/VBD ./.)
*0*else VARlen &gt; 0,
*0*(S (Chunk else/RB VARlen/NNP) &/CC gt/NN ;/: 0/CD ,/,)
*1*let VARnewlen be VARlen-1. 
*1*(S (Chunk let/VB VARnewlen/NNP) (Chunk be/VB VARlen-1/NNP) ./.)
*1*let VARindex be ! FUNCtostring(VARnewlen). 
*1*(S (Chunk let/VB VARindex/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARnewlen/NNP) )/) ./.)
*1*let VARelement be ? FUNCget(VARo, VARindex). 
*1*(S (Chunk let/VB VARelement/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARindex/NNP) )/) ./.)
*1*perform ? FUNCdeletepropertyorthrow(VARo, VARindex). 
*1*(S perform/NN ?/. (Chunk FUNCdeletepropertyorthrow/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARindex/NNP) )/) ./.)
*1*perform ? FUNCset(VARo, "length", VARnewlen, true). 
*1*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' ,/, (Chunk VARnewlen/NNP) ,/, true/JJ )/) ./.)
*1*return VARelement.     
*1*(S return/NN (Chunk VARelement/NNP) ./.)
ID= 22.1.3.18
Summary= Array.prototype.push ( ...items )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*let VARitems be a list whose elements are, in left to right order, the arguments that were passed to this function invocation. 
*0*(S (Chunk let/VB VARitems/NNP) be/VB a/DT list/NN whose/WP$ elements/NNS are/VBP ,/, in/IN left/VBN to/TO right/JJ order/NN ,/, the/DT arguments/NNS that/WDT were/VBD passed/VBN to/TO this/DT function/NN invocation/NN ./.)
*0*let VARargcount be the number of elements in VARitems. 
*0*(S (Chunk let/VB VARargcount/NNP) be/VB the/DT number/NN of/IN elements/NNS in/IN (Chunk VARitems/NNP) ./.)
*0*if VARlen + VARargcount &gt; 253-1, throw a typeerror exception. 
*0*(S if/IN (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARargcount/NNP) &/CC gt/NN ;/: 253-1/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*repeat, while VARitems is not empty
*0*(S repeat/NN ,/, while/IN (Chunk VARitems/NNP) is/VBZ not/RB empty/JJ)
*1*remove the first element from VARitems and let VARe be the value of the element. 
*1*(S remove/VB the/DT first/JJ element/NN from/IN (Chunk VARitems/NNP) and/CC (Chunk let/VB VARe/NNP) be/VB the/DT value/NN of/IN the/DT element/NN ./.)
*1*perform ? FUNCset(VARo, ! FUNCtostring(VARlen), VARe, true). 
*1*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARlen/NNP) )/) ,/, (Chunk VARe/NNP) ,/, true/JJ )/) ./.)
*1*let VARlen be VARlen+1. 
*1*(S (Chunk let/VB VARlen/NNP) (Chunk be/VB VARlen+1/NNP) ./.)
*0*perform ? FUNCset(VARo, "length", VARlen, true). 
*0*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' ,/, (Chunk VARlen/NNP) ,/, true/JJ )/) ./.)
*0*return VARlen.     
*0*(S return/NN (Chunk VARlen/NNP) ./.)
ID= 22.1.3.19
Summary= Array.prototype.reduce ( callbackfn [ , initialValue ] )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARcallbackfn/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARlen is 0 and VARinitialvalue is not present, throw a typeerror exception. 
*0*(S if/IN (Chunk VARlen/NNP) is/VBZ 0/CD and/CC (Chunk VARinitialvalue/NNP) is/VBZ not/RB present/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*let VARaccumulator be undefined. 
*0*(S (Chunk let/VB VARaccumulator/NNP) be/VB undefined/VBN ./.)
*0*if VARinitialvalue is present, then
*0*(S if/IN (Chunk VARinitialvalue/NNP) is/VBZ present/JJ ,/, then/RB)
*1*set VARaccumulator to VARinitialvalue. 
*1*(S (Chunk set/VBN VARaccumulator/NNP) to/TO (Chunk VARinitialvalue/NNP) ./.)
*0*else VARinitialvalue is not present,
*0*(S (Chunk else/RB VARinitialvalue/NNP) is/VBZ not/RB present/JJ ,/,)
*1*let VARkpresent be false. 
*1*(S (Chunk let/VB VARkpresent/NNP) be/VB false/JJ ./.)
*1*repeat, while VARkpresent is false and VARk &lt; VARlen
*1*(S repeat/NN ,/, while/IN (Chunk VARkpresent/NNP) is/VBZ false/JJ and/CC (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*2*let VARpk be ! FUNCtostring(VARk). 
*2*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*2*let VARkpresent be ? FUNChasproperty(VARo, VARpk). 
*2*(S (Chunk let/VB VARkpresent/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*2*if VARkpresent is true, then
*2*(S if/IN (Chunk VARkpresent/NNP) is/VBZ true/JJ ,/, then/RB)
*3*set VARaccumulator to ? FUNCget(VARo, VARpk). 
*3*(S set/VBN VARaccumulator/NN to/TO ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*2*increase VARk by 1. 
*2*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*1*if VARkpresent is false, throw a typeerror exception. 
*1*(S if/IN (Chunk VARkpresent/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*repeat, while VARk &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*let VARkpresent be ? FUNChasproperty(VARo, VARpk). 
*1*(S (Chunk let/VB VARkpresent/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*1*if VARkpresent is true, then
*1*(S if/IN (Chunk VARkpresent/NNP) is/VBZ true/JJ ,/, then/RB)
*2*let VARkvalue be ? FUNCget(VARo, VARpk). 
*2*(S (Chunk let/VB VARkvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*2*set VARaccumulator to ? FUNCcall(VARcallbackfn, undefined, « VARaccumulator, VARkvalue, VARk, VARo »). 
*2*(S set/VBN VARaccumulator/NN to/TO ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARcallbackfn/NNP) ,/, undefined/VBD ,/, (Chunk «/NNP) (Chunk VARaccumulator/NNP) ,/, (Chunk VARkvalue/NNP) ,/, (Chunk VARk/NNP) ,/, (Chunk VARo/NNP) (Chunk »/NNP) )/) ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*return VARaccumulator.     
*0*(S return/NN (Chunk VARaccumulator/NNP) ./.)
ID= 22.1.3.20
Summary= Array.prototype.reduceRight ( callbackfn [ , initialValue ] )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARcallbackfn/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARlen is 0 and VARinitialvalue is not present, throw a typeerror exception. 
*0*(S if/IN (Chunk VARlen/NNP) is/VBZ 0/CD and/CC (Chunk VARinitialvalue/NNP) is/VBZ not/RB present/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARk be VARlen-1. 
*0*(S (Chunk let/VB VARk/NNP) (Chunk be/VB VARlen-1/NNP) ./.)
*0*let VARaccumulator be undefined. 
*0*(S (Chunk let/VB VARaccumulator/NNP) be/VB undefined/VBN ./.)
*0*if VARinitialvalue is present, then
*0*(S if/IN (Chunk VARinitialvalue/NNP) is/VBZ present/JJ ,/, then/RB)
*1*set VARaccumulator to VARinitialvalue. 
*1*(S (Chunk set/VBN VARaccumulator/NNP) to/TO (Chunk VARinitialvalue/NNP) ./.)
*0*else VARinitialvalue is not present,
*0*(S (Chunk else/RB VARinitialvalue/NNP) is/VBZ not/RB present/JJ ,/,)
*1*let VARkpresent be false. 
*1*(S (Chunk let/VB VARkpresent/NNP) be/VB false/JJ ./.)
*1*repeat, while VARkpresent is false and VARk ≥ 0
*1*(S repeat/NN ,/, while/IN (Chunk VARkpresent/NNP) is/VBZ false/JJ and/CC (Chunk VARk/NNP) (Chunk ≥/NNP) 0/CD)
*2*let VARpk be ! FUNCtostring(VARk). 
*2*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*2*let VARkpresent be ? FUNChasproperty(VARo, VARpk). 
*2*(S (Chunk let/VB VARkpresent/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*2*if VARkpresent is true, then
*2*(S if/IN (Chunk VARkpresent/NNP) is/VBZ true/JJ ,/, then/RB)
*3*set VARaccumulator to ? FUNCget(VARo, VARpk). 
*3*(S set/VBN VARaccumulator/NN to/TO ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*2*decrease VARk by 1. 
*2*(S decrease/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*1*if VARkpresent is false, throw a typeerror exception. 
*1*(S if/IN (Chunk VARkpresent/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*repeat, while VARk ≥ 0
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) ≥/VBD 0/CD)
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*let VARkpresent be ? FUNChasproperty(VARo, VARpk). 
*1*(S (Chunk let/VB VARkpresent/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*1*if VARkpresent is true, then
*1*(S if/IN (Chunk VARkpresent/NNP) is/VBZ true/JJ ,/, then/RB)
*2*let VARkvalue be ? FUNCget(VARo, VARpk). 
*2*(S (Chunk let/VB VARkvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*2*set VARaccumulator to ? FUNCcall(VARcallbackfn, undefined, « VARaccumulator, VARkvalue, VARk, VARo »). 
*2*(S set/VBN VARaccumulator/NN to/TO ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARcallbackfn/NNP) ,/, undefined/VBD ,/, (Chunk «/NNP) (Chunk VARaccumulator/NNP) ,/, (Chunk VARkvalue/NNP) ,/, (Chunk VARk/NNP) ,/, (Chunk VARo/NNP) (Chunk »/NNP) )/) ./.)
*1*decrease VARk by 1. 
*1*(S decrease/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*return VARaccumulator.     
*0*(S return/NN (Chunk VARaccumulator/NNP) ./.)
ID= 22.1.3.21
Summary= Array.prototype.reverse ( )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*let VARmiddle be floor(VARlen/2). 
*0*(S (Chunk let/VB VARmiddle/NNP) be/VB floor/NN (/( (Chunk VARlen/2/NNP) )/) ./.)
*0*let VARlower be 0. 
*0*(S (Chunk let/VB VARlower/NNP) be/VB 0/CD ./.)
*0*repeat, while VARlower ≠ VARmiddle
*0*(S repeat/NN ,/, while/IN (Chunk VARlower/NNP) (Chunk ≠/NNP) (Chunk VARmiddle/NNP))
*1*let VARupper be VARlen - VARlower - 1. 
*1*(S (Chunk let/VB VARupper/NNP) (Chunk be/VB VARlen/NNP) -/: (Chunk VARlower/NNP) -/: 1/CD ./.)
*1*let VARupperp be ! FUNCtostring(VARupper). 
*1*(S (Chunk let/VB VARupperp/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARupper/NNP) )/) ./.)
*1*let VARlowerp be ! FUNCtostring(VARlower). 
*1*(S (Chunk let/VB VARlowerp/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARlower/NNP) )/) ./.)
*1*let VARlowerexists be ? FUNChasproperty(VARo, VARlowerp). 
*1*(S let/VB VARlowerexists/NNS be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARlowerp/NNP) )/) ./.)
*1*if VARlowerexists is true, then
*1*(S if/IN VARlowerexists/NNS is/VBZ true/JJ ,/, then/RB)
*2*let VARlowervalue be ? FUNCget(VARo, VARlowerp). 
*2*(S (Chunk let/VB VARlowervalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARlowerp/NNP) )/) ./.)
*1*let VARupperexists be ? FUNChasproperty(VARo, VARupperp). 
*1*(S let/VB VARupperexists/NNS be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARupperp/NNP) )/) ./.)
*1*if VARupperexists is true, then
*1*(S if/IN VARupperexists/NNS is/VBZ true/JJ ,/, then/RB)
*2*let VARuppervalue be ? FUNCget(VARo, VARupperp). 
*2*(S (Chunk let/VB VARuppervalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARupperp/NNP) )/) ./.)
*1*if VARlowerexists is true and VARupperexists is true, then
*1*(S if/IN VARlowerexists/NNS is/VBZ true/JJ and/CC VARupperexists/NNS is/VBZ true/JJ ,/, then/RB)
*2*perform ? FUNCset(VARo, VARlowerp, VARuppervalue, true). 
*2*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARlowerp/NNP) ,/, (Chunk VARuppervalue/NNP) ,/, true/JJ )/) ./.)
*2*perform ? FUNCset(VARo, VARupperp, VARlowervalue, true). 
*2*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARupperp/NNP) ,/, (Chunk VARlowervalue/NNP) ,/, true/JJ )/) ./.)
*1*else if VARlowerexists is false and VARupperexists is true, then
*1*(S else/RB if/IN VARlowerexists/NNS is/VBZ false/JJ and/CC VARupperexists/NNS is/VBZ true/JJ ,/, then/RB)
*2*perform ? FUNCset(VARo, VARlowerp, VARuppervalue, true). 
*2*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARlowerp/NNP) ,/, (Chunk VARuppervalue/NNP) ,/, true/JJ )/) ./.)
*2*perform ? FUNCdeletepropertyorthrow(VARo, VARupperp). 
*2*(S perform/NN ?/. (Chunk FUNCdeletepropertyorthrow/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARupperp/NNP) )/) ./.)
*1*else if VARlowerexists is true and VARupperexists is false, then
*1*(S else/RB if/IN VARlowerexists/NNS is/VBZ true/JJ and/CC VARupperexists/NNS is/VBZ false/JJ ,/, then/RB)
*2*perform ? FUNCdeletepropertyorthrow(VARo, VARlowerp). 
*2*(S perform/NN ?/. (Chunk FUNCdeletepropertyorthrow/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARlowerp/NNP) )/) ./.)
*2*perform ? FUNCset(VARo, VARupperp, VARlowervalue, true). 
*2*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARupperp/NNP) ,/, (Chunk VARlowervalue/NNP) ,/, true/JJ )/) ./.)
*1*else both VARlowerexists and VARupperexists are false,
*1*(S else/RB both/DT VARlowerexists/NNS and/CC VARupperexists/NNS are/VBP false/JJ ,/,)
*2*no action is required. 
*2*(S no/DT action/NN is/VBZ required/VBN ./.)
*1*increase VARlower by 1. 
*1*(S increase/NN (Chunk VARlower/NNP) by/IN 1/CD ./.)
*0*return VARo.     
*0*(S return/NN (Chunk VARo/NNP) ./.)
ID= 22.1.3.22
Summary= Array.prototype.shift ( )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*if VARlen is zero, then
*0*(S if/IN (Chunk VARlen/NNP) is/VBZ zero/CD ,/, then/RB)
*1*perform ? FUNCset(VARo, "length", 0, true). 
*1*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' ,/, 0/CD ,/, true/JJ )/) ./.)
*1*return undefined. 
*1*(S return/NN undefined/VBD ./.)
*0*let VARfirst be ? FUNCget(VARo, "0"). 
*0*(S (Chunk let/VB VARfirst/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` 0/CD ''/'' )/) ./.)
*0*let VARk be 1. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 1/CD ./.)
*0*repeat, while VARk &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*let VARfrom be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARfrom/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*let VARto be ! FUNCtostring(VARk-1). 
*1*(S (Chunk let/VB VARto/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk-1/NNP) )/) ./.)
*1*let VARfrompresent be ? FUNChasproperty(VARo, VARfrom). 
*1*(S (Chunk let/VB VARfrompresent/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARfrom/NNP) )/) ./.)
*1*if VARfrompresent is true, then
*1*(S if/IN (Chunk VARfrompresent/NNP) is/VBZ true/JJ ,/, then/RB)
*2*let VARfromval be ? FUNCget(VARo, VARfrom). 
*2*(S (Chunk let/VB VARfromval/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARfrom/NNP) )/) ./.)
*2*perform ? FUNCset(VARo, VARto, VARfromval, true). 
*2*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARto/NNP) ,/, (Chunk VARfromval/NNP) ,/, true/JJ )/) ./.)
*1*else VARfrompresent is false,
*1*(S (Chunk else/RB VARfrompresent/NNP) is/VBZ false/JJ ,/,)
*2*perform ? FUNCdeletepropertyorthrow(VARo, VARto). 
*2*(S perform/NN ?/. (Chunk FUNCdeletepropertyorthrow/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARto/NNP) )/) ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*perform ? FUNCdeletepropertyorthrow(VARo, ! FUNCtostring(VARlen-1)). 
*0*(S perform/NN ?/. (Chunk FUNCdeletepropertyorthrow/NNP) (/( (Chunk VARo/NNP) ,/, !/. FUNCtostring/VBG (/( (Chunk VARlen-1/NNP) )/) )/) ./.)
*0*perform ? FUNCset(VARo, "length", VARlen-1, true). 
*0*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' ,/, (Chunk VARlen-1/NNP) ,/, true/JJ )/) ./.)
*0*return VARfirst.     
*0*(S return/NN (Chunk VARfirst/NNP) ./.)
ID= 22.1.3.23
Summary= Array.prototype.slice ( start, end )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*let VARrelativestart be ? FUNCtointeger(VARstart). 
*0*(S (Chunk let/VB VARrelativestart/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARstart/NNP) )/) ./.)
*0*if VARrelativestart &lt; 0, let VARk be max((VARlen + VARrelativestart), 0); else let VARk be min(VARrelativestart, VARlen). 
*0*(S if/IN (Chunk VARrelativestart/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARk/NNP) be/VB max/VBN (/( (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARrelativestart/NNP) )/) ,/, 0/CD )/) ;/: else/JJ let/NN (Chunk VARk/NNP) be/VB min/VBN (/( (Chunk VARrelativestart/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*if VARend is undefined, let VARrelativeend be VARlen; else let VARrelativeend be ? FUNCtointeger(VARend). 
*0*(S if/IN (Chunk VARend/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARrelativeend/NNP) (Chunk be/VB VARlen/NNP) ;/: else/JJ (Chunk let/VB VARrelativeend/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARend/NNP) )/) ./.)
*0*if VARrelativeend &lt; 0, let VARfinal be max((VARlen + VARrelativeend), 0); else let VARfinal be min(VARrelativeend, VARlen). 
*0*(S if/IN (Chunk VARrelativeend/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARfinal/NNP) be/VB max/VBN (/( (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARrelativeend/NNP) )/) ,/, 0/CD )/) ;/: else/JJ (Chunk let/VB VARfinal/NNP) be/VB min/VBN (/( (Chunk VARrelativeend/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*let VARcount be max(VARfinal - VARk, 0). 
*0*(S (Chunk let/VB VARcount/NNP) be/VB max/VBN (/( (Chunk VARfinal/NNP) -/: (Chunk VARk/NNP) ,/, 0/CD )/) ./.)
*0*let VARa be ? FUNCarrayspeciescreate(VARo, VARcount). 
*0*(S (Chunk let/VB VARa/NNP) be/VB ?/. (Chunk FUNCarrayspeciescreate/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARcount/NNP) )/) ./.)
*0*let VARn be 0. 
*0*(S (Chunk let/VB VARn/NNP) be/VB 0/CD ./.)
*0*repeat, while VARk &lt; VARfinal
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARfinal/NNP))
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*let VARkpresent be ? FUNChasproperty(VARo, VARpk). 
*1*(S (Chunk let/VB VARkpresent/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*1*if VARkpresent is true, then
*1*(S if/IN (Chunk VARkpresent/NNP) is/VBZ true/JJ ,/, then/RB)
*2*let VARkvalue be ? FUNCget(VARo, VARpk). 
*2*(S (Chunk let/VB VARkvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*2*perform ? FUNCcreatedatapropertyorthrow(VARa, ! FUNCtostring(VARn), VARkvalue). 
*2*(S perform/NN ?/. (Chunk FUNCcreatedatapropertyorthrow/NNP) (/( (Chunk VARa/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARn/NNP) )/) ,/, (Chunk VARkvalue/NNP) )/) ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*1*increase VARn by 1. 
*1*(S increase/NN (Chunk VARn/NNP) by/IN 1/CD ./.)
*0*perform ? FUNCset(VARa, "length", VARn, true). 
*0*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` length/NN ''/'' ,/, (Chunk VARn/NNP) ,/, true/JJ )/) ./.)
*0*return VARa.     
*0*(S return/NN (Chunk VARa/NNP) ./.)
ID= 22.1.3.24
Summary= Array.prototype.some ( callbackfn [ , thisArg ] )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARcallbackfn/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*(S if/IN (Chunk VARthisarg/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARt/NNP) (Chunk be/VB VARthisarg/NNP) ;/: else/JJ (Chunk let/VB VARt/NNP) be/VB undefined/VBN ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*repeat, while VARk &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*let VARkpresent be ? FUNChasproperty(VARo, VARpk). 
*1*(S (Chunk let/VB VARkpresent/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*1*if VARkpresent is true, then
*1*(S if/IN (Chunk VARkpresent/NNP) is/VBZ true/JJ ,/, then/RB)
*2*let VARkvalue be ? FUNCget(VARo, VARpk). 
*2*(S (Chunk let/VB VARkvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*2*let VARtestresult be FUNCtoboolean(? FUNCcall(VARcallbackfn, VARt, « VARkvalue, VARk, VARo »)). 
*2*(S (Chunk let/VB VARtestresult/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARcallbackfn/NNP) ,/, (Chunk VARt/NNP) ,/, (Chunk «/NNP) (Chunk VARkvalue/NNP) ,/, (Chunk VARk/NNP) ,/, (Chunk VARo/NNP) (Chunk »/NNP) )/) )/) ./.)
*2*if VARtestresult is true, return true. 
*2*(S if/IN (Chunk VARtestresult/NNP) is/VBZ true/JJ ,/, return/VB true/JJ ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 22.1.3.25
Summary= Array.prototype.sort ( comparefn )
*0*if VARcomparefn is not undefined and FUNCiscallable(VARcomparefn) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk VARcomparefn/NNP) is/VBZ not/RB undefined/JJ and/CC FUNCiscallable/JJ (/( (Chunk VARcomparefn/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARobj be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARobj/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARobj, "length")).     
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARobj/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
ID= 22.1.3.25.1
Summary= Runtime Semantics: SortCompare ( x, y )
*0*if VARx and VARy are both undefined, return +0. 
*0*(S if/IN (Chunk VARx/NNP) and/CC (Chunk VARy/NNP) are/VBP both/DT undefined/JJ ,/, (Chunk return/VB +0/NNP) ./.)
*0*if VARx is undefined, return 1. 
*0*(S if/IN (Chunk VARx/NNP) is/VBZ undefined/JJ ,/, return/VB 1/CD ./.)
*0*if VARy is undefined, return -1. 
*0*(S if/IN (Chunk VARy/NNP) is/VBZ undefined/JJ ,/, (Chunk return/VB -1/NNP) ./.)
*0*if VARcomparefn is not undefined, then
*0*(S if/IN (Chunk VARcomparefn/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*1*let VARv be ? FUNCtonumber(? FUNCcall(VARcomparefn, undefined, « VARx, VARy »)). 
*1*(S (Chunk let/VB VARv/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARcomparefn/NNP) ,/, undefined/VBD ,/, (Chunk «/NNP) (Chunk VARx/NNP) ,/, (Chunk VARy/NNP) (Chunk »/NNP) )/) )/) ./.)
*1*if VARv is nan, return +0. 
*1*(S if/IN (Chunk VARv/NNP) is/VBZ nan/JJ ,/, (Chunk return/VB +0/NNP) ./.)
*1*return VARv. 
*1*(S return/NN (Chunk VARv/NNP) ./.)
*0*let VARxstring be ? FUNCtostring(VARx). 
*0*(S let/VB VARxstring/VBG be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARx/NNP) )/) ./.)
*0*let VARystring be ? FUNCtostring(VARy). 
*0*(S let/VB VARystring/VBG be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARy/NNP) )/) ./.)
*0*let VARxsmaller be the result of performing abstract relational comparison VARxstring &lt; VARystring. 
*0*(S (Chunk let/VB VARxsmaller/NNP) be/VB the/DT result/NN of/IN performing/VBG abstract/JJ relational/JJ comparison/NN (Chunk VARxstring/NNP) &/CC lt/NN ;/: (Chunk VARystring/NNP) ./.)
*0*if VARxsmaller is true, return -1. 
*0*(S if/IN (Chunk VARxsmaller/NNP) is/VBZ true/JJ ,/, (Chunk return/VB -1/NNP) ./.)
*0*let VARysmaller be the result of performing abstract relational comparison VARystring &lt; VARxstring. 
*0*(S (Chunk let/VB VARysmaller/NNP) be/VB the/DT result/NN of/IN performing/VBG abstract/JJ relational/JJ comparison/NN (Chunk VARystring/NNP) &/CC lt/NN ;/: (Chunk VARxstring/NNP) ./.)
*0*if VARysmaller is true, return 1. 
*0*(S if/IN (Chunk VARysmaller/NNP) is/VBZ true/JJ ,/, return/VB 1/CD ./.)
*0*return +0.      
*0*(S return/NN +0/NN ./.)
ID= 22.1.3.26
Summary= Array.prototype.splice ( start, deleteCount, ...items )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*let VARrelativestart be ? FUNCtointeger(VARstart). 
*0*(S (Chunk let/VB VARrelativestart/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARstart/NNP) )/) ./.)
*0*if VARrelativestart &lt; 0, let VARactualstart be max((VARlen + VARrelativestart), 0); else let VARactualstart be min(VARrelativestart, VARlen). 
*0*(S if/IN (Chunk VARrelativestart/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARactualstart/NNP) be/VB max/VBN (/( (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARrelativestart/NNP) )/) ,/, 0/CD )/) ;/: else/JJ (Chunk let/VB VARactualstart/NNP) be/VB min/VBN (/( (Chunk VARrelativestart/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*if the number of actual arguments is 0, then
*0*(S if/IN the/DT number/NN of/IN actual/JJ arguments/NNS is/VBZ 0/CD ,/, then/RB)
*1*let VARinsertcount be 0. 
*1*(S (Chunk let/VB VARinsertcount/NNP) be/VB 0/CD ./.)
*1*let VARactualdeletecount be 0. 
*1*(S (Chunk let/VB VARactualdeletecount/NNP) be/VB 0/CD ./.)
*0*else if the number of actual arguments is 1, then
*0*(S else/RB if/IN the/DT number/NN of/IN actual/JJ arguments/NNS is/VBZ 1/CD ,/, then/RB)
*1*let VARinsertcount be 0. 
*1*(S (Chunk let/VB VARinsertcount/NNP) be/VB 0/CD ./.)
*1*let VARactualdeletecount be VARlen - VARactualstart. 
*1*(S (Chunk let/VB VARactualdeletecount/NNP) (Chunk be/VB VARlen/NNP) -/: (Chunk VARactualstart/NNP) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARinsertcount be the number of actual arguments minus 2. 
*1*(S (Chunk let/VB VARinsertcount/NNP) be/VB the/DT number/NN of/IN actual/JJ arguments/NNS minus/CC 2/CD ./.)
*1*let VARdc be ? FUNCtointeger(VARdeletecount). 
*1*(S (Chunk let/VB VARdc/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARdeletecount/NNP) )/) ./.)
*1*let VARactualdeletecount be min(max(VARdc, 0), VARlen - VARactualstart). 
*1*(S (Chunk let/VB VARactualdeletecount/NNP) be/VB min/VBN (/( max/NN (/( (Chunk VARdc/NNP) ,/, 0/CD )/) ,/, (Chunk VARlen/NNP) -/: (Chunk VARactualstart/NNP) )/) ./.)
*0*if VARlen+VARinsertcount-VARactualdeletecount &gt; 253-1, throw a typeerror exception. 
*0*(S if/IN (Chunk VARlen+VARinsertcount-VARactualdeletecount/NNP) &/CC gt/NN ;/: 253-1/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARa be ? FUNCarrayspeciescreate(VARo, VARactualdeletecount). 
*0*(S (Chunk let/VB VARa/NNP) be/VB ?/. (Chunk FUNCarrayspeciescreate/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARactualdeletecount/NNP) )/) ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*repeat, while VARk &lt; VARactualdeletecount
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARactualdeletecount/NNP))
*1*let VARfrom be ! FUNCtostring(VARactualstart+VARk). 
*1*(S (Chunk let/VB VARfrom/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARactualstart+VARk/NNP) )/) ./.)
*1*let VARfrompresent be ? FUNChasproperty(VARo, VARfrom). 
*1*(S (Chunk let/VB VARfrompresent/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARfrom/NNP) )/) ./.)
*1*if VARfrompresent is true, then
*1*(S if/IN (Chunk VARfrompresent/NNP) is/VBZ true/JJ ,/, then/RB)
*2*let VARfromvalue be ? FUNCget(VARo, VARfrom). 
*2*(S (Chunk let/VB VARfromvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARfrom/NNP) )/) ./.)
*2*perform ? FUNCcreatedatapropertyorthrow(VARa, ! FUNCtostring(VARk), VARfromvalue). 
*2*(S perform/NN ?/. (Chunk FUNCcreatedatapropertyorthrow/NNP) (/( (Chunk VARa/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ,/, (Chunk VARfromvalue/NNP) )/) ./.)
*1*increment VARk by 1. 
*1*(S increment/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*perform ? FUNCset(VARa, "length", VARactualdeletecount, true). 
*0*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` length/NN ''/'' ,/, (Chunk VARactualdeletecount/NNP) ,/, true/JJ )/) ./.)
*0*let VARitems be a list whose elements are, in left to right order, the portion of the actual argument list starting with the third argument. the list is empty if fewer than three arguments were passed. 
*0*(S (Chunk let/VB VARitems/NNP) be/VB a/DT list/NN whose/WP$ elements/NNS are/VBP ,/, in/IN left/VBN to/TO right/JJ order/NN ,/, the/DT portion/NN of/IN the/DT actual/JJ argument/NN list/NN starting/VBG with/IN the/DT third/JJ argument/NN ./. the/DT list/NN is/VBZ empty/JJ if/IN fewer/JJR than/IN three/CD arguments/NNS were/VBD passed/VBN ./.)
*0*let VARitemcount be the number of elements in VARitems. 
*0*(S (Chunk let/VB VARitemcount/NNP) be/VB the/DT number/NN of/IN elements/NNS in/IN (Chunk VARitems/NNP) ./.)
*0*if VARitemcount &lt; VARactualdeletecount, then
*0*(S if/IN (Chunk VARitemcount/NNP) &/CC lt/NN ;/: (Chunk VARactualdeletecount/NNP) ,/, then/RB)
*1*let VARk be VARactualstart. 
*1*(S (Chunk let/VB VARk/NNP) (Chunk be/VB VARactualstart/NNP) ./.)
*1*repeat, while VARk &lt; (VARlen - VARactualdeletecount)
*1*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (/( (Chunk VARlen/NNP) -/: VARactualdeletecount/NN )/))
*2*let VARfrom be ! FUNCtostring(VARk+VARactualdeletecount). 
*2*(S (Chunk let/VB VARfrom/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk+VARactualdeletecount/NNP) )/) ./.)
*2*let VARto be ! FUNCtostring(VARk+VARitemcount). 
*2*(S (Chunk let/VB VARto/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk+VARitemcount/NNP) )/) ./.)
*2*let VARfrompresent be ? FUNChasproperty(VARo, VARfrom). 
*2*(S (Chunk let/VB VARfrompresent/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARfrom/NNP) )/) ./.)
*2*if VARfrompresent is true, then
*2*(S if/IN (Chunk VARfrompresent/NNP) is/VBZ true/JJ ,/, then/RB)
*3*let VARfromvalue be ? FUNCget(VARo, VARfrom). 
*3*(S (Chunk let/VB VARfromvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARfrom/NNP) )/) ./.)
*3*perform ? FUNCset(VARo, VARto, VARfromvalue, true). 
*3*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARto/NNP) ,/, (Chunk VARfromvalue/NNP) ,/, true/JJ )/) ./.)
*2*else VARfrompresent is false,
*2*(S (Chunk else/RB VARfrompresent/NNP) is/VBZ false/JJ ,/,)
*3*perform ? FUNCdeletepropertyorthrow(VARo, VARto). 
*3*(S perform/NN ?/. (Chunk FUNCdeletepropertyorthrow/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARto/NNP) )/) ./.)
*2*increase VARk by 1. 
*2*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*1*let VARk be VARlen. 
*1*(S (Chunk let/VB VARk/NNP) (Chunk be/VB VARlen/NNP) ./.)
*1*repeat, while VARk &gt; (VARlen - VARactualdeletecount + VARitemcount)
*1*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC gt/NN ;/: (/( (Chunk VARlen/NNP) -/: (Chunk VARactualdeletecount/NNP) (Chunk +/NNP) (Chunk VARitemcount/NNP) )/))
*2*perform ? FUNCdeletepropertyorthrow(VARo, ! FUNCtostring(VARk-1)). 
*2*(S perform/NN ?/. (Chunk FUNCdeletepropertyorthrow/NNP) (/( (Chunk VARo/NNP) ,/, !/. FUNCtostring/VBG (/( (Chunk VARk-1/NNP) )/) )/) ./.)
*2*decrease VARk by 1. 
*2*(S decrease/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*else if VARitemcount &gt; VARactualdeletecount, then
*0*(S else/RB if/IN (Chunk VARitemcount/NNP) &/CC gt/NN ;/: (Chunk VARactualdeletecount/NNP) ,/, then/RB)
*1*let VARk be (VARlen - VARactualdeletecount). 
*1*(S (Chunk let/VB VARk/NNP) be/VB (/( (Chunk VARlen/NNP) -/: VARactualdeletecount/NN )/) ./.)
*1*repeat, while VARk &gt; VARactualstart
*1*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC gt/NN ;/: (Chunk VARactualstart/NNP))
*2*let VARfrom be ! FUNCtostring(VARk + VARactualdeletecount - 1). 
*2*(S (Chunk let/VB VARfrom/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) (Chunk +/NNP) (Chunk VARactualdeletecount/NNP) -/: 1/CD )/) ./.)
*2*let VARto be ! FUNCtostring(VARk + VARitemcount - 1). 
*2*(S (Chunk let/VB VARto/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) (Chunk +/NNP) (Chunk VARitemcount/NNP) -/: 1/CD )/) ./.)
*2*let VARfrompresent be ? FUNChasproperty(VARo, VARfrom). 
*2*(S (Chunk let/VB VARfrompresent/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARfrom/NNP) )/) ./.)
*2*if VARfrompresent is true, then
*2*(S if/IN (Chunk VARfrompresent/NNP) is/VBZ true/JJ ,/, then/RB)
*3*let VARfromvalue be ? FUNCget(VARo, VARfrom). 
*3*(S (Chunk let/VB VARfromvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARfrom/NNP) )/) ./.)
*3*perform ? FUNCset(VARo, VARto, VARfromvalue, true). 
*3*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARto/NNP) ,/, (Chunk VARfromvalue/NNP) ,/, true/JJ )/) ./.)
*2*else VARfrompresent is false,
*2*(S (Chunk else/RB VARfrompresent/NNP) is/VBZ false/JJ ,/,)
*3*perform ? FUNCdeletepropertyorthrow(VARo, VARto). 
*3*(S perform/NN ?/. (Chunk FUNCdeletepropertyorthrow/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARto/NNP) )/) ./.)
*2*decrease VARk by 1. 
*2*(S decrease/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*let VARk be VARactualstart. 
*0*(S (Chunk let/VB VARk/NNP) (Chunk be/VB VARactualstart/NNP) ./.)
*0*repeat, while VARitems is not empty
*0*(S repeat/NN ,/, while/IN (Chunk VARitems/NNP) is/VBZ not/RB empty/JJ)
*1*remove the first element from VARitems and let VARe be the value of that element. 
*1*(S remove/VB the/DT first/JJ element/NN from/IN (Chunk VARitems/NNP) and/CC (Chunk let/VB VARe/NNP) be/VB the/DT value/NN of/IN that/DT element/NN ./.)
*1*perform ? FUNCset(VARo, ! FUNCtostring(VARk), VARe, true). 
*1*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ,/, (Chunk VARe/NNP) ,/, true/JJ )/) ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*perform ? FUNCset(VARo, "length", VARlen - VARactualdeletecount + VARitemcount, true). 
*0*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' ,/, (Chunk VARlen/NNP) -/: (Chunk VARactualdeletecount/NNP) (Chunk +/NNP) (Chunk VARitemcount/NNP) ,/, true/JJ )/) ./.)
*0*return VARa.     
*0*(S return/NN (Chunk VARa/NNP) ./.)
ID= 22.1.3.27
Summary= Array.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
*0*let VARarray be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARarray/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARarray, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARarray/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*let VARseparator be the string value for the list-separator string appropriate for the host environment's current locale (this is derived in an implementation-defined way). 
*0*(S (Chunk let/VB VARseparator/NNP) be/VB the/DT string/NN value/NN for/IN the/DT list-separator/JJ string/NN appropriate/NN for/IN the/DT host/NN environment/NN 's/POS current/JJ locale/NN (/( this/DT is/VBZ derived/VBN in/IN an/DT implementation-defined/JJ way/NN )/) ./.)
*0*let VARr be the empty string. 
*0*(S (Chunk let/VB VARr/NNP) be/VB the/DT empty/JJ string/NN ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*repeat, while VARk &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*if VARk &gt; 0, then
*1*(S if/IN (Chunk VARk/NNP) &/CC gt/NN ;/: 0/CD ,/, then/RB)
*2*set VARr to the string-concatenation of VARr and VARseparator. 
*2*(S (Chunk set/VBN VARr/NNP) to/TO the/DT string-concatenation/NN of/IN (Chunk VARr/NNP) and/CC (Chunk VARseparator/NNP) ./.)
*1*let VARnextelement be ? FUNCget(VARarray, ! FUNCtostring(VARk)). 
*1*(S (Chunk let/VB VARnextelement/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARarray/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) )/) ./.)
*1*if VARnextelement is not undefined or null, then
*1*(S if/IN (Chunk VARnextelement/NNP) is/VBZ not/RB undefined/JJ or/CC null/JJ ,/, then/RB)
*2*let VARs be ? FUNCtostring(? FUNCinvoke(VARnextelement, "tolocalestring")). 
*2*(S (Chunk let/VB VARs/NNP) be/VB ?/. FUNCtostring/VBG (/( ?/. (Chunk FUNCinvoke/NNP) (/( (Chunk VARnextelement/NNP) ,/, ``/`` tolocalestring/VBG ''/'' )/) )/) ./.)
*2*set VARr to the string-concatenation of VARr and VARs. 
*2*(S (Chunk set/VBN VARr/NNP) to/TO the/DT string-concatenation/NN of/IN (Chunk VARr/NNP) and/CC (Chunk VARs/NNP) ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*return VARr.     
*0*(S return/NN (Chunk VARr/NNP) ./.)
ID= 22.1.3.28
Summary= Array.prototype.toString ( )
*0*let VARarray be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARarray/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARfunc be ? FUNCget(VARarray, "join"). 
*0*(S (Chunk let/VB VARfunc/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARarray/NNP) ,/, ``/`` join/NN ''/'' )/) ./.)
*0*if FUNCiscallable(VARfunc) is false, let VARfunc be the intrinsic function %objproto_tostring%. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARfunc/NNP) )/) is/VBZ false/JJ ,/, (Chunk let/VB VARfunc/NNP) be/VB the/DT intrinsic/JJ function/NN %/NN objproto_tostring/VBG %/NN ./.)
*0*return ? FUNCcall(VARfunc, VARarray).     
*0*(S return/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARfunc/NNP) ,/, (Chunk VARarray/NNP) )/) ./.)
ID= 22.1.3.29
Summary= Array.prototype.unshift ( ...items )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*let VARargcount be the number of actual arguments. 
*0*(S (Chunk let/VB VARargcount/NNP) be/VB the/DT number/NN of/IN actual/JJ arguments/NNS ./.)
*0*if VARargcount &gt; 0, then
*0*(S if/IN (Chunk VARargcount/NNP) &/CC gt/NN ;/: 0/CD ,/, then/RB)
*1*if VARlen+VARargcount &gt; 253-1, throw a typeerror exception. 
*1*(S if/IN (Chunk VARlen+VARargcount/NNP) &/CC gt/NN ;/: 253-1/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*let VARk be VARlen. 
*1*(S (Chunk let/VB VARk/NNP) (Chunk be/VB VARlen/NNP) ./.)
*1*repeat, while VARk &gt; 0,
*1*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC gt/NN ;/: 0/CD ,/,)
*2*let VARfrom be ! FUNCtostring(VARk-1). 
*2*(S (Chunk let/VB VARfrom/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk-1/NNP) )/) ./.)
*2*let VARto be ! FUNCtostring(VARk+VARargcount-1). 
*2*(S (Chunk let/VB VARto/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk+VARargcount-1/NNP) )/) ./.)
*2*let VARfrompresent be ? FUNChasproperty(VARo, VARfrom). 
*2*(S (Chunk let/VB VARfrompresent/NNP) be/VB ?/. (Chunk FUNChasproperty/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARfrom/NNP) )/) ./.)
*2*if VARfrompresent is true, then
*2*(S if/IN (Chunk VARfrompresent/NNP) is/VBZ true/JJ ,/, then/RB)
*3*let VARfromvalue be ? FUNCget(VARo, VARfrom). 
*3*(S (Chunk let/VB VARfromvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARfrom/NNP) )/) ./.)
*3*perform ? FUNCset(VARo, VARto, VARfromvalue, true). 
*3*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARto/NNP) ,/, (Chunk VARfromvalue/NNP) ,/, true/JJ )/) ./.)
*2*else VARfrompresent is false,
*2*(S (Chunk else/RB VARfrompresent/NNP) is/VBZ false/JJ ,/,)
*3*perform ? FUNCdeletepropertyorthrow(VARo, VARto). 
*3*(S perform/NN ?/. (Chunk FUNCdeletepropertyorthrow/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARto/NNP) )/) ./.)
*2*decrease VARk by 1. 
*2*(S decrease/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*1*let VARj be 0. 
*1*(S (Chunk let/VB VARj/NNP) be/VB 0/CD ./.)
*1*let VARitems be a list whose elements are, in left to right order, the arguments that were passed to this function invocation. 
*1*(S (Chunk let/VB VARitems/NNP) be/VB a/DT list/NN whose/WP$ elements/NNS are/VBP ,/, in/IN left/VBN to/TO right/JJ order/NN ,/, the/DT arguments/NNS that/WDT were/VBD passed/VBN to/TO this/DT function/NN invocation/NN ./.)
*1*repeat, while VARitems is not empty
*1*(S repeat/NN ,/, while/IN (Chunk VARitems/NNP) is/VBZ not/RB empty/JJ)
*2*remove the first element from VARitems and let VARe be the value of that element. 
*2*(S remove/VB the/DT first/JJ element/NN from/IN (Chunk VARitems/NNP) and/CC (Chunk let/VB VARe/NNP) be/VB the/DT value/NN of/IN that/DT element/NN ./.)
*2*perform ? FUNCset(VARo, ! FUNCtostring(VARj), VARe, true). 
*2*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARj/NNP) )/) ,/, (Chunk VARe/NNP) ,/, true/JJ )/) ./.)
*2*increase VARj by 1. 
*2*(S increase/NN (Chunk VARj/NNP) by/IN 1/CD ./.)
*0*perform ? FUNCset(VARo, "length", VARlen+VARargcount, true). 
*0*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` length/NN ''/'' ,/, (Chunk VARlen+VARargcount/NNP) ,/, true/JJ )/) ./.)
*0*return VARlen+VARargcount.     
*0*(S return/NN (Chunk VARlen+VARargcount/NNP) ./.)
ID= 22.1.3.30
Summary= Array.prototype.values ( )
*0*let VARo be ? FUNCtoobject(this value). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( this/DT value/NN )/) ./.)
*0*return FUNCcreatearrayiterator(VARo, "value").     
*0*(S return/NN (Chunk FUNCcreatearrayiterator/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` value/NN ''/'' )/) ./.)
ID= 22.1.5.1
Summary= CreateArrayIterator ( array, kind )
*0*assert: FUNCtype(VARarray) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARarray/NNP) )/) is/VBZ object/JJ ./.)
*0*let VARiterator be FUNCobjectcreate(%arrayiteratorprototype%, « [[ITERATEDOBJECT]], [[ARRAYITERATORNEXTINDEX]], [[ARRAYITERATIONKIND]] »). 
*0*(S (Chunk let/VB VARiterator/NNP) (Chunk be/VB FUNCobjectcreate/NNP) (/( %/NN arrayiteratorprototype/NN %/NN ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk ITERATEDOBJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ARRAYITERATORNEXTINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ARRAYITERATIONKIND/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARiterator.[[ITERATEDOBJECT]] to VARarray. 
*0*(S (Chunk set/VBN VARiterator/NNP) ./. [/VB [/JJ (Chunk ITERATEDOBJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARarray/NNP) ./.)
*0*set VARiterator.[[ARRAYITERATORNEXTINDEX]] to 0. 
*0*(S (Chunk set/VBN VARiterator/NNP) ./. [/VB [/JJ (Chunk ARRAYITERATORNEXTINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO 0/CD ./.)
*0*set VARiterator.[[ARRAYITERATIONKIND]] to VARkind. 
*0*(S (Chunk set/VBN VARiterator/NNP) ./. [/VB [/JJ (Chunk ARRAYITERATIONKIND/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARkind/NNP) ./.)
*0*return VARiterator.     
*0*(S return/NN (Chunk VARiterator/NNP) ./.)
ID= 22.1.5.2.1
Summary= %ArrayIteratorPrototype%.next ( )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARo does not have all of the internal slots of an array iterator instance (22.1.5.3), throw a typeerror exception. 
*0*(S if/IN (Chunk VARo/NNP) does/VBZ not/RB have/VB all/DT of/IN the/DT internal/JJ slots/NNS of/IN an/DT array/NN iterator/NN instance/NN (/( 22.1.5.3/CD )/) ,/, throw/VBP a/DT typeerror/NN exception/NN ./.)
*0*let VARa be VARo.[[ITERATEDOBJECT]]. 
*0*(S (Chunk let/VB VARa/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk ITERATEDOBJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARa is undefined, return FUNCcreateiterresultobject(undefined, true). 
*0*(S if/IN (Chunk VARa/NNP) is/VBZ undefined/JJ ,/, (Chunk return/VB FUNCcreateiterresultobject/NNP) (/( undefined/JJ ,/, true/JJ )/) ./.)
*0*let VARindex be VARo.[[ARRAYITERATORNEXTINDEX]]. 
*0*(S (Chunk let/VB VARindex/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYITERATORNEXTINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARitemkind be VARo.[[ARRAYITERATIONKIND]]. 
*0*(S (Chunk let/VB VARitemkind/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYITERATIONKIND/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARa has a [[TYPEDARRAYNAME]] internal slot, then
*0*(S if/IN (Chunk VARa/NNP) has/VBZ a/DT [/JJ [/NN (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, then/RB)
*1*if FUNCisdetachedbuffer(VARa.[[VIEWEDARRAYBUFFER]]) is true, throw a typeerror exception. 
*1*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARa/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*let VARlen be VARa.[[ARRAYLENGTH]]. 
*1*(S (Chunk let/VB VARlen/NNP) (Chunk be/VB VARa/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARlen be ? FUNCtolength(? FUNCget(VARa, "length")). 
*1*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARa/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*if VARindex ≥ VARlen, then
*0*(S if/IN (Chunk VARindex/NNP) (Chunk ≥/NNP) (Chunk VARlen/NNP) ,/, then/RB)
*1*set VARo.[[ITERATEDOBJECT]] to undefined. 
*1*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk ITERATEDOBJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO undefined/VB ./.)
*1*return FUNCcreateiterresultobject(undefined, true). 
*1*(S return/NN (Chunk FUNCcreateiterresultobject/NNP) (/( undefined/JJ ,/, true/JJ )/) ./.)
*0*set VARo.[[ARRAYITERATORNEXTINDEX]] to VARindex+1. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYITERATORNEXTINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARindex+1/NNP) ./.)
*0*if VARitemkind is "key", return FUNCcreateiterresultobject(VARindex, false). 
*0*(S if/IN (Chunk VARitemkind/NNP) is/VBZ ``/`` key/JJ ''/'' ,/, (Chunk return/VB FUNCcreateiterresultobject/NNP) (/( (Chunk VARindex/NNP) ,/, false/RB )/) ./.)
*0*let VARelementkey be ! FUNCtostring(VARindex). 
*0*(S (Chunk let/VB VARelementkey/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARindex/NNP) )/) ./.)
*0*let VARelementvalue be ? FUNCget(VARa, VARelementkey). 
*0*(S (Chunk let/VB VARelementvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARa/NNP) ,/, (Chunk VARelementkey/NNP) )/) ./.)
*0*if VARitemkind is "value", let VARresult be VARelementvalue. 
*0*(S if/IN (Chunk VARitemkind/NNP) is/VBZ ``/`` value/NN ''/'' ,/, (Chunk let/VB VARresult/NNP) (Chunk be/VB VARelementvalue/NNP) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*assert: VARitemkind is "key+value". 
*1*(S assert/NN :/: (Chunk VARitemkind/NNP) is/VBZ ``/`` key+value/JJ ''/'' ./.)
*1*let VARresult be FUNCcreatearrayfromlist(« VARindex, VARelementvalue »). 
*1*(S (Chunk let/VB VARresult/NNP) (Chunk be/VB FUNCcreatearrayfromlist/NNP) (/( (Chunk «/NNP) (Chunk VARindex/NNP) ,/, (Chunk VARelementvalue/NNP) (Chunk »/NNP) )/) ./.)
*0*return FUNCcreateiterresultobject(VARresult, false).      
*0*(S return/NN (Chunk FUNCcreateiterresultobject/NNP) (/( (Chunk VARresult/NNP) ,/, false/RB )/) ./.)
ID= 22.2.1.1
Summary= %TypedArray% ( )
*0*throw a typeerror exception.     
*0*(S throw/VB a/DT typeerror/NN exception/NN ./.)
ID= 22.2.2.1
Summary= %TypedArray%.from ( source [ , mapfn [ , thisArg ] ] )
*0*let VARc be the this value. 
*0*(S (Chunk let/VB VARc/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCisconstructor(VARc) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisconstructor/NNP) (/( (Chunk VARc/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARmapfn is present and VARmapfn is not undefined, then
*0*(S if/IN (Chunk VARmapfn/NNP) is/VBZ present/JJ and/CC (Chunk VARmapfn/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*1*if FUNCiscallable(VARmapfn) is false, throw a typeerror exception. 
*1*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARmapfn/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*let VARmapping be true. 
*1*(S (Chunk let/VB VARmapping/NNP) be/VB true/JJ ./.)
*0*else, let VARmapping be false. 
*0*(S else/RB ,/, (Chunk let/VB VARmapping/NNP) be/VB false/JJ ./.)
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*(S if/IN (Chunk VARthisarg/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARt/NNP) (Chunk be/VB VARthisarg/NNP) ;/: else/JJ (Chunk let/VB VARt/NNP) be/VB undefined/VBN ./.)
*0*let VARusingiterator be ? FUNCgetmethod(VARsource, @@iterator). 
*0*(S (Chunk let/VB VARusingiterator/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARsource/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) iterator/NN )/) ./.)
*0*if VARusingiterator is not undefined, then
*0*(S if/IN (Chunk VARusingiterator/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*1*let VARvalues be ? FUNCiterabletolist(VARsource, VARusingiterator). 
*1*(S (Chunk let/VB VARvalues/NNP) be/VB ?/. (Chunk FUNCiterabletolist/NNP) (/( (Chunk VARsource/NNP) ,/, (Chunk VARusingiterator/NNP) )/) ./.)
*1*let VARlen be the number of elements in VARvalues. 
*1*(S (Chunk let/VB VARlen/NNP) be/VB the/DT number/NN of/IN elements/NNS in/IN (Chunk VARvalues/NNP) ./.)
*1*let VARtargetobj be ? typedarraycreate(VARc, « VARlen »). 
*1*(S (Chunk let/VB VARtargetobj/NNP) be/VB ?/. typedarraycreate/NN (/( (Chunk VARc/NNP) ,/, (Chunk «/NNP) (Chunk VARlen/NNP) (Chunk »/NNP) )/) ./.)
*1*let VARk be 0. 
*1*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*1*repeat, while VARk &lt; VARlen
*1*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*2*let VARpk be ! FUNCtostring(VARk). 
*2*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*2*let VARkvalue be the first element of VARvalues and remove that element from VARvalues. 
*2*(S (Chunk let/VB VARkvalue/NNP) be/VB the/DT first/JJ element/NN of/IN (Chunk VARvalues/NNP) and/CC remove/VB that/DT element/NN from/IN (Chunk VARvalues/NNP) ./.)
*2*if VARmapping is true, then
*2*(S if/IN (Chunk VARmapping/NNP) is/VBZ true/JJ ,/, then/RB)
*3*let VARmappedvalue be ? FUNCcall(VARmapfn, VARt, « VARkvalue, VARk »). 
*3*(S (Chunk let/VB VARmappedvalue/NNP) be/VB ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARmapfn/NNP) ,/, (Chunk VARt/NNP) ,/, (Chunk «/NNP) (Chunk VARkvalue/NNP) ,/, (Chunk VARk/NNP) (Chunk »/NNP) )/) ./.)
*2*else, let VARmappedvalue be VARkvalue. 
*2*(S else/RB ,/, (Chunk let/VB VARmappedvalue/NNP) (Chunk be/VB VARkvalue/NNP) ./.)
*2*perform ? FUNCset(VARtargetobj, VARpk, VARmappedvalue, true). 
*2*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARtargetobj/NNP) ,/, (Chunk VARpk/NNP) ,/, (Chunk VARmappedvalue/NNP) ,/, true/JJ )/) ./.)
*2*increase VARk by 1. 
*2*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*1*assert: VARvalues is now an empty list. 
*1*(S assert/NN :/: VARvalues/NNS is/VBZ now/RB an/DT empty/JJ list/NN ./.)
*1*return VARtargetobj. 
*1*(S return/NN (Chunk VARtargetobj/NNP) ./.)
*0*note: VARsource is not an iterable so assume it is already an array-like object. 
*0*(S note/NN :/: VARsource/NN is/VBZ not/RB an/DT iterable/JJ so/RB assume/IN it/PRP is/VBZ already/RB an/DT array-like/JJ object/NN ./.)
*0*let VARarraylike be ! FUNCtoobject(VARsource). 
*0*(S (Chunk let/VB VARarraylike/NNP) be/VB !/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARsource/NNP) )/) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARarraylike, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARarraylike/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*let VARtargetobj be ? typedarraycreate(VARc, « VARlen »). 
*0*(S (Chunk let/VB VARtargetobj/NNP) be/VB ?/. typedarraycreate/NN (/( (Chunk VARc/NNP) ,/, (Chunk «/NNP) (Chunk VARlen/NNP) (Chunk »/NNP) )/) ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*repeat, while VARk &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*let VARkvalue be ? FUNCget(VARarraylike, VARpk). 
*1*(S (Chunk let/VB VARkvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARarraylike/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*1*if VARmapping is true, then
*1*(S if/IN (Chunk VARmapping/NNP) is/VBZ true/JJ ,/, then/RB)
*2*let VARmappedvalue be ? FUNCcall(VARmapfn, VARt, « VARkvalue, VARk »). 
*2*(S (Chunk let/VB VARmappedvalue/NNP) be/VB ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARmapfn/NNP) ,/, (Chunk VARt/NNP) ,/, (Chunk «/NNP) (Chunk VARkvalue/NNP) ,/, (Chunk VARk/NNP) (Chunk »/NNP) )/) ./.)
*1*else, let VARmappedvalue be VARkvalue. 
*1*(S else/RB ,/, (Chunk let/VB VARmappedvalue/NNP) (Chunk be/VB VARkvalue/NNP) ./.)
*1*perform ? FUNCset(VARtargetobj, VARpk, VARmappedvalue, true). 
*1*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARtargetobj/NNP) ,/, (Chunk VARpk/NNP) ,/, (Chunk VARmappedvalue/NNP) ,/, true/JJ )/) ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*return VARtargetobj.     
*0*(S return/NN (Chunk VARtargetobj/NNP) ./.)
ID= 22.2.2.1.1
Summary= Runtime Semantics: IterableToList ( items, method )
*0*let VARiteratorrecord be ? FUNCgetiterator(VARitems, sync, VARmethod). 
*0*(S (Chunk let/VB VARiteratorrecord/NNP) be/VB ?/. (Chunk FUNCgetiterator/NNP) (/( (Chunk VARitems/NNP) ,/, sync/NN ,/, (Chunk VARmethod/NNP) )/) ./.)
*0*let VARvalues be a new empty list. 
*0*(S (Chunk let/VB VARvalues/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARnext be true. 
*0*(S (Chunk let/VB VARnext/NNP) be/VB true/JJ ./.)
*0*repeat, while VARnext is not false
*0*(S repeat/NN ,/, while/IN (Chunk VARnext/NNP) is/VBZ not/RB false/JJ)
*1*set VARnext to ? FUNCiteratorstep(VARiteratorrecord). 
*1*(S (Chunk set/VBN VARnext/NNP) to/TO ?/. (Chunk FUNCiteratorstep/NNP) (/( (Chunk VARiteratorrecord/NNP) )/) ./.)
*1*if VARnext is not false, then
*1*(S if/IN (Chunk VARnext/NNP) is/VBZ not/RB false/JJ ,/, then/RB)
*2*let VARnextvalue be ? FUNCiteratorvalue(VARnext). 
*2*(S (Chunk let/VB VARnextvalue/NNP) be/VB ?/. (Chunk FUNCiteratorvalue/NNP) (/( (Chunk VARnext/NNP) )/) ./.)
*2*append VARnextvalue to the end of the list VARvalues. 
*2*(S (Chunk append/VB VARnextvalue/NNP) to/TO the/DT end/NN of/IN the/DT list/NN (Chunk VARvalues/NNP) ./.)
*0*return VARvalues.      
*0*(S return/NN VARvalues/NNS ./.)
ID= 22.2.2.2
Summary= %TypedArray%.of ( ...items )
*0*let VARlen be the actual number of arguments passed to this function. 
*0*(S (Chunk let/VB VARlen/NNP) be/VB the/DT actual/JJ number/NN of/IN arguments/NNS passed/VBN to/TO this/DT function/NN ./.)
*0*let VARitems be the list of arguments passed to this function. 
*0*(S (Chunk let/VB VARitems/NNP) be/VB the/DT list/NN of/IN arguments/NNS passed/VBN to/TO this/DT function/NN ./.)
*0*let VARc be the this value. 
*0*(S (Chunk let/VB VARc/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCisconstructor(VARc) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisconstructor/NNP) (/( (Chunk VARc/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARnewobj be ? typedarraycreate(VARc, « VARlen »). 
*0*(S (Chunk let/VB VARnewobj/NNP) be/VB ?/. typedarraycreate/NN (/( (Chunk VARc/NNP) ,/, (Chunk «/NNP) (Chunk VARlen/NNP) (Chunk »/NNP) )/) ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*repeat, while VARk &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*let VARkvalue be VARitems[VARk]. 
*1*(S (Chunk let/VB VARkvalue/NNP) (Chunk be/VB VARitems/NNP) (Chunk [/NNP) (Chunk VARk/NNP) (Chunk ]/NNP) ./.)
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*perform ? FUNCset(VARnewobj, VARpk, VARkvalue, true). 
*1*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARnewobj/NNP) ,/, (Chunk VARpk/NNP) ,/, (Chunk VARkvalue/NNP) ,/, true/JJ )/) ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*return VARnewobj.     
*0*(S return/NN (Chunk VARnewobj/NNP) ./.)
ID= 22.2.3.5
Summary= %TypedArray%.prototype.copyWithin ( target, start [ , end ] )
*0*let VARo be this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB this/DT value/NN ./.)
*0*perform ? FUNCvalidatetypedarray(VARo). 
*0*(S perform/NN ?/. (Chunk FUNCvalidatetypedarray/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARlen be VARo.[[ARRAYLENGTH]]. 
*0*(S (Chunk let/VB VARlen/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARrelativetarget be ? FUNCtointeger(VARtarget). 
*0*(S (Chunk let/VB VARrelativetarget/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARtarget/NNP) )/) ./.)
*0*if VARrelativetarget &lt; 0, let VARto be max((VARlen + VARrelativetarget), 0); else let VARto be min(VARrelativetarget, VARlen). 
*0*(S if/IN (Chunk VARrelativetarget/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARto/NNP) be/VB max/VBN (/( (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARrelativetarget/NNP) )/) ,/, 0/CD )/) ;/: else/JJ (Chunk let/VB VARto/NNP) be/VB min/VBN (/( (Chunk VARrelativetarget/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*let VARrelativestart be ? FUNCtointeger(VARstart). 
*0*(S (Chunk let/VB VARrelativestart/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARstart/NNP) )/) ./.)
*0*if VARrelativestart &lt; 0, let VARfrom be max((VARlen + VARrelativestart), 0); else let VARfrom be min(VARrelativestart, VARlen). 
*0*(S if/IN (Chunk VARrelativestart/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARfrom/NNP) be/VB max/VBN (/( (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARrelativestart/NNP) )/) ,/, 0/CD )/) ;/: else/JJ let/NN (Chunk VARfrom/NNP) be/VB min/VBN (/( (Chunk VARrelativestart/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*if VARend is undefined, let VARrelativeend be VARlen; else let VARrelativeend be ? FUNCtointeger(VARend). 
*0*(S if/IN (Chunk VARend/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARrelativeend/NNP) (Chunk be/VB VARlen/NNP) ;/: else/JJ (Chunk let/VB VARrelativeend/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARend/NNP) )/) ./.)
*0*if VARrelativeend &lt; 0, let VARfinal be max((VARlen + VARrelativeend), 0); else let VARfinal be min(VARrelativeend, VARlen). 
*0*(S if/IN (Chunk VARrelativeend/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARfinal/NNP) be/VB max/VBN (/( (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARrelativeend/NNP) )/) ,/, 0/CD )/) ;/: else/JJ (Chunk let/VB VARfinal/NNP) be/VB min/VBN (/( (Chunk VARrelativeend/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*let VARcount be min(VARfinal-VARfrom, VARlen-VARto). 
*0*(S (Chunk let/VB VARcount/NNP) be/VB min/VBN (/( VARfinal-VARfrom/JJ ,/, (Chunk VARlen-VARto/NNP) )/) ./.)
*0*if VARcount &gt; 0, then
*0*(S if/IN (Chunk VARcount/NNP) &/CC gt/NN ;/: 0/CD ,/, then/RB)
*1*note: the copying must be performed in a manner that preserves the bit-level encoding of the source data. 
*1*(S note/NN :/: the/DT copying/NN must/MD be/VB performed/VBN in/IN a/DT manner/NN that/WDT preserves/VBZ the/DT bit-level/JJ encoding/NN of/IN the/DT source/NN data/NNS ./.)
*1*let VARbuffer be VARo.[[VIEWEDARRAYBUFFER]]. 
*1*(S (Chunk let/VB VARbuffer/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*if FUNCisdetachedbuffer(VARbuffer) is true, throw a typeerror exception. 
*1*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARbuffer/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*let VARtypedarrayname be the string value of VARo.[[TYPEDARRAYNAME]]. 
*1*(S (Chunk let/VB VARtypedarrayname/NNP) be/VB the/DT string/VBG value/NN of/IN (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*let VARelementsize be the number value of the element size value specified in table 56 for VARtypedarrayname. 
*1*(S (Chunk let/VB VARelementsize/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN (Chunk VARtypedarrayname/NNP) ./.)
*1*let VARbyteoffset be VARo.[[BYTEOFFSET]]. 
*1*(S (Chunk let/VB VARbyteoffset/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*let VARtobyteindex be VARto × VARelementsize + VARbyteoffset. 
*1*(S (Chunk let/VB VARtobyteindex/NNP) (Chunk be/VB VARto/NNP) (Chunk ×/NNP) (Chunk VARelementsize/NNP) (Chunk +/NNP) (Chunk VARbyteoffset/NNP) ./.)
*1*let VARfrombyteindex be VARfrom × VARelementsize + VARbyteoffset. 
*1*(S (Chunk let/VB VARfrombyteindex/NNP) (Chunk be/VB VARfrom/NNP) (Chunk ×/NNP) (Chunk VARelementsize/NNP) (Chunk +/NNP) (Chunk VARbyteoffset/NNP) ./.)
*1*let VARcountbytes be VARcount × VARelementsize. 
*1*(S (Chunk let/VB VARcountbytes/NNP) (Chunk be/VB VARcount/NNP) (Chunk ×/NNP) (Chunk VARelementsize/NNP) ./.)
*1*if VARfrombyteindex&lt;VARtobyteindex and VARtobyteindex&lt;VARfrombyteindex+VARcountbytes, then
*1*(S if/IN (Chunk VARfrombyteindex/NNP) &/CC lt/NN ;/: (Chunk VARtobyteindex/NNP) and/CC (Chunk VARtobyteindex/NNP) &/CC lt/NN ;/: (Chunk VARfrombyteindex+VARcountbytes/NNP) ,/, then/RB)
*2*let VARdirection be -1. 
*2*(S (Chunk let/VB VARdirection/NNP) be/VB -1/VBN ./.)
*2*let VARfrombyteindex be VARfrombyteindex + VARcountbytes - 1. 
*2*(S (Chunk let/VB VARfrombyteindex/NNP) (Chunk be/VB VARfrombyteindex/NNP) (Chunk +/NNP) (Chunk VARcountbytes/NNP) -/: 1/CD ./.)
*2*let VARtobyteindex be VARtobyteindex + VARcountbytes - 1. 
*2*(S (Chunk let/VB VARtobyteindex/NNP) (Chunk be/VB VARtobyteindex/NNP) (Chunk +/NNP) (Chunk VARcountbytes/NNP) -/: 1/CD ./.)
*1*else,
*1*(S else/RB ,/,)
*2*let VARdirection be 1. 
*2*(S (Chunk let/VB VARdirection/NNP) be/VB 1/CD ./.)
*1*repeat, while VARcountbytes &gt; 0
*1*(S repeat/NN ,/, while/IN (Chunk VARcountbytes/NNP) &/CC gt/NN ;/: 0/CD)
*2*let VARvalue be FUNCgetvaluefrombuffer(VARbuffer, VARfrombyteindex, "uint8", true, "unordered"). 
*2*(S (Chunk let/VB VARvalue/NNP) (Chunk be/VB FUNCgetvaluefrombuffer/NNP) (/( (Chunk VARbuffer/NNP) ,/, (Chunk VARfrombyteindex/NNP) ,/, ``/`` uint8/JJ ''/'' ,/, true/JJ ,/, ``/`` unordered/JJ ''/'' )/) ./.)
*2*perform FUNCsetvalueinbuffer(VARbuffer, VARtobyteindex, "uint8", VARvalue, true, "unordered"). 
*2*(S perform/NN (Chunk FUNCsetvalueinbuffer/NNP) (/( (Chunk VARbuffer/NNP) ,/, (Chunk VARtobyteindex/NNP) ,/, ``/`` uint8/JJ ''/'' ,/, (Chunk VARvalue/NNP) ,/, true/JJ ,/, ``/`` unordered/JJ ''/'' )/) ./.)
*2*let VARfrombyteindex be VARfrombyteindex + VARdirection. 
*2*(S (Chunk let/VB VARfrombyteindex/NNP) (Chunk be/VB VARfrombyteindex/NNP) (Chunk +/NNP) (Chunk VARdirection/NNP) ./.)
*2*let VARtobyteindex be VARtobyteindex + VARdirection. 
*2*(S (Chunk let/VB VARtobyteindex/NNP) (Chunk be/VB VARtobyteindex/NNP) (Chunk +/NNP) (Chunk VARdirection/NNP) ./.)
*2*let VARcountbytes be VARcountbytes - 1. 
*2*(S (Chunk let/VB VARcountbytes/NNP) (Chunk be/VB VARcountbytes/NNP) -/: 1/CD ./.)
*0*return VARo.     
*0*(S return/NN (Chunk VARo/NNP) ./.)
ID= 22.2.3.5.1
Summary= Runtime Semantics: ValidateTypedArray ( O )
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARo does not have a [[TYPEDARRAYNAME]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARo/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: VARo has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*(S assert/NN :/: (Chunk VARo/NNP) has/VBZ a/DT [/JJ [/NN (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*let VARbuffer be VARo.[[VIEWEDARRAYBUFFER]]. 
*0*(S (Chunk let/VB VARbuffer/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if FUNCisdetachedbuffer(VARbuffer) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARbuffer/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARbuffer.      
*0*(S return/NN (Chunk VARbuffer/NNP) ./.)
ID= 22.2.3.6
Summary= %TypedArray%.prototype.entries ( )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*perform ? FUNCvalidatetypedarray(VARo). 
*0*(S perform/NN ?/. (Chunk FUNCvalidatetypedarray/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*return FUNCcreatearrayiterator(VARo, "key+value").     
*0*(S return/NN (Chunk FUNCcreatearrayiterator/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` key+value/VB ''/'' )/) ./.)
ID= 22.2.3.8
Summary= %TypedArray%.prototype.fill ( value [ , start [ , end ] ] )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*perform ? FUNCvalidatetypedarray(VARo). 
*0*(S perform/NN ?/. (Chunk FUNCvalidatetypedarray/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARlen be VARo.[[ARRAYLENGTH]]. 
*0*(S (Chunk let/VB VARlen/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARvalue be ? FUNCtonumber(VARvalue). 
*0*(S (Chunk let/VB VARvalue/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*0*let VARrelativestart be ? FUNCtointeger(VARstart). 
*0*(S (Chunk let/VB VARrelativestart/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARstart/NNP) )/) ./.)
*0*if VARrelativestart &lt; 0, let VARk be max((VARlen + VARrelativestart), 0); else let VARk be min(VARrelativestart, VARlen). 
*0*(S if/IN (Chunk VARrelativestart/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARk/NNP) be/VB max/VBN (/( (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARrelativestart/NNP) )/) ,/, 0/CD )/) ;/: else/JJ let/NN (Chunk VARk/NNP) be/VB min/VBN (/( (Chunk VARrelativestart/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*if VARend is undefined, let VARrelativeend be VARlen; else let VARrelativeend be ? FUNCtointeger(VARend). 
*0*(S if/IN (Chunk VARend/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARrelativeend/NNP) (Chunk be/VB VARlen/NNP) ;/: else/JJ (Chunk let/VB VARrelativeend/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARend/NNP) )/) ./.)
*0*if VARrelativeend &lt; 0, let VARfinal be max((VARlen + VARrelativeend), 0); else let VARfinal be min(VARrelativeend, VARlen). 
*0*(S if/IN (Chunk VARrelativeend/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARfinal/NNP) be/VB max/VBN (/( (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARrelativeend/NNP) )/) ,/, 0/CD )/) ;/: else/JJ (Chunk let/VB VARfinal/NNP) be/VB min/VBN (/( (Chunk VARrelativeend/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*if FUNCisdetachedbuffer(VARo.[[VIEWEDARRAYBUFFER]]) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*repeat, while VARk &lt; VARfinal
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARfinal/NNP))
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*perform ! FUNCset(VARo, VARpk, VARvalue, true). 
*1*(S perform/NN !/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) ,/, (Chunk VARvalue/NNP) ,/, true/JJ )/) ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*return VARo.     
*0*(S return/NN (Chunk VARo/NNP) ./.)
ID= 22.2.3.9
Summary= %TypedArray%.prototype.filter ( callbackfn [ , thisArg ] )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*perform ? FUNCvalidatetypedarray(VARo). 
*0*(S perform/NN ?/. (Chunk FUNCvalidatetypedarray/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARlen be VARo.[[ARRAYLENGTH]]. 
*0*(S (Chunk let/VB VARlen/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARcallbackfn/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*(S if/IN (Chunk VARthisarg/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARt/NNP) (Chunk be/VB VARthisarg/NNP) ;/: else/JJ (Chunk let/VB VARt/NNP) be/VB undefined/VBN ./.)
*0*let VARkept be a new empty list. 
*0*(S (Chunk let/VB VARkept/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*let VARcaptured be 0. 
*0*(S (Chunk let/VB VARcaptured/NNP) be/VB 0/CD ./.)
*0*repeat, while VARk &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*let VARkvalue be ? FUNCget(VARo, VARpk). 
*1*(S (Chunk let/VB VARkvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*1*let VARselected be FUNCtoboolean(? FUNCcall(VARcallbackfn, VARt, « VARkvalue, VARk, VARo »)). 
*1*(S (Chunk let/VB VARselected/NNP) (Chunk be/VB FUNCtoboolean/NNP) (/( ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARcallbackfn/NNP) ,/, (Chunk VARt/NNP) ,/, (Chunk «/NNP) (Chunk VARkvalue/NNP) ,/, (Chunk VARk/NNP) ,/, (Chunk VARo/NNP) (Chunk »/NNP) )/) )/) ./.)
*1*if VARselected is true, then
*1*(S if/IN VARselected/VBN is/VBZ true/JJ ,/, then/RB)
*2*append VARkvalue to the end of VARkept. 
*2*(S (Chunk append/VB VARkvalue/NNP) to/TO the/DT end/NN of/IN (Chunk VARkept/NNP) ./.)
*2*increase VARcaptured by 1. 
*2*(S increase/NN VARcaptured/VBN by/IN 1/CD ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*let VARa be ? typedarrayspeciescreate(VARo, « VARcaptured »). 
*0*(S (Chunk let/VB VARa/NNP) be/VB ?/. typedarrayspeciescreate/NN (/( (Chunk VARo/NNP) ,/, (Chunk «/NNP) (Chunk VARcaptured/NNP) (Chunk »/NNP) )/) ./.)
*0*let VARn be 0. 
*0*(S (Chunk let/VB VARn/NNP) be/VB 0/CD ./.)
*0*for each element VARe of VARkept, do
*0*(S for/IN each/DT element/NN (Chunk VARe/NNP) of/IN (Chunk VARkept/NNP) ,/, do/VBP)
*1*perform ! FUNCset(VARa, ! FUNCtostring(VARn), VARe, true). 
*1*(S perform/NN !/. (Chunk FUNCset/NNP) (/( (Chunk VARa/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARn/NNP) )/) ,/, (Chunk VARe/NNP) ,/, true/JJ )/) ./.)
*1*increment VARn by 1. 
*1*(S increment/NN (Chunk VARn/NNP) by/IN 1/CD ./.)
*0*return VARa.     
*0*(S return/NN (Chunk VARa/NNP) ./.)
ID= 22.2.3.16
Summary= %TypedArray%.prototype.keys ( )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*perform ? FUNCvalidatetypedarray(VARo). 
*0*(S perform/NN ?/. (Chunk FUNCvalidatetypedarray/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*return FUNCcreatearrayiterator(VARo, "key").     
*0*(S return/NN (Chunk FUNCcreatearrayiterator/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` key/JJ ''/'' )/) ./.)
ID= 22.2.3.19
Summary= %TypedArray%.prototype.map ( callbackfn [ , thisArg ] )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*perform ? FUNCvalidatetypedarray(VARo). 
*0*(S perform/NN ?/. (Chunk FUNCvalidatetypedarray/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARlen be VARo.[[ARRAYLENGTH]]. 
*0*(S (Chunk let/VB VARlen/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARcallbackfn/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*(S if/IN (Chunk VARthisarg/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARt/NNP) (Chunk be/VB VARthisarg/NNP) ;/: else/JJ (Chunk let/VB VARt/NNP) be/VB undefined/VBN ./.)
*0*let VARa be ? typedarrayspeciescreate(VARo, « VARlen »). 
*0*(S (Chunk let/VB VARa/NNP) be/VB ?/. typedarrayspeciescreate/NN (/( (Chunk VARo/NNP) ,/, (Chunk «/NNP) (Chunk VARlen/NNP) (Chunk »/NNP) )/) ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*repeat, while VARk &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*let VARkvalue be ? FUNCget(VARo, VARpk). 
*1*(S (Chunk let/VB VARkvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*1*let VARmappedvalue be ? FUNCcall(VARcallbackfn, VARt, « VARkvalue, VARk, VARo »). 
*1*(S (Chunk let/VB VARmappedvalue/NNP) be/VB ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARcallbackfn/NNP) ,/, (Chunk VARt/NNP) ,/, (Chunk «/NNP) (Chunk VARkvalue/NNP) ,/, (Chunk VARk/NNP) ,/, (Chunk VARo/NNP) (Chunk »/NNP) )/) ./.)
*1*perform ? FUNCset(VARa, VARpk, VARmappedvalue, true). 
*1*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARa/NNP) ,/, (Chunk VARpk/NNP) ,/, (Chunk VARmappedvalue/NNP) ,/, true/JJ )/) ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*return VARa.     
*0*(S return/NN (Chunk VARa/NNP) ./.)
ID= 22.2.3.23
Summary= %TypedArray%.prototype.set ( overloaded [ , offset ] )
*0*assert: VARarray is any ecmascript language value other than an object with a [[TYPEDARRAYNAME]] internal slot. if it is such an object, the definition in 22.2.3.23.2 applies. 
*0*(S assert/NN :/: (Chunk VARarray/NNP) is/VBZ any/DT ecmascript/JJ language/NN value/NN other/JJ than/IN an/DT object/NN with/IN a/DT [/JJ [/NN (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./. if/IN it/PRP is/VBZ such/JJ an/DT object/NN ,/, the/DT definition/NN in/IN 22.2.3.23.2/CD applies/NNS ./.)
*0*let VARtarget be the this value. 
*0*(S (Chunk let/VB VARtarget/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARtarget does not have a [[TYPEDARRAYNAME]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARtarget/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: VARtarget has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*(S assert/NN :/: (Chunk VARtarget/NNP) has/VBZ a/DT [/JJ [/NN (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*let VARtargetoffset be ? FUNCtointeger(VARoffset). 
*0*(S (Chunk let/VB VARtargetoffset/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARoffset/NNP) )/) ./.)
*0*if VARtargetoffset &lt; 0, throw a rangeerror exception. 
*0*(S if/IN (Chunk VARtargetoffset/NNP) &/CC lt/NN ;/: 0/CD ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*let VARtargetbuffer be VARtarget.[[VIEWEDARRAYBUFFER]]. 
*0*(S (Chunk let/VB VARtargetbuffer/NNP) (Chunk be/VB VARtarget/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if FUNCisdetachedbuffer(VARtargetbuffer) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARtargetbuffer/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARtargetlength be VARtarget.[[ARRAYLENGTH]]. 
*0*(S (Chunk let/VB VARtargetlength/NNP) (Chunk be/VB VARtarget/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtargetname be the string value of VARtarget.[[TYPEDARRAYNAME]]. 
*0*(S (Chunk let/VB VARtargetname/NNP) be/VB the/DT string/VBG value/NN of/IN (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtargetelementsize be the number value of the element size value specified in table 56 for VARtargetname. 
*0*(S (Chunk let/VB VARtargetelementsize/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN (Chunk VARtargetname/NNP) ./.)
*0*let VARtargettype be the string value of the element type value in table 56 for VARtargetname. 
*0*(S (Chunk let/VB VARtargettype/NNP) be/VB the/DT string/VBG value/NN of/IN the/DT element/NN type/NN value/NN in/IN table/JJ 56/CD for/IN (Chunk VARtargetname/NNP) ./.)
*0*let VARtargetbyteoffset be VARtarget.[[BYTEOFFSET]]. 
*0*(S (Chunk let/VB VARtargetbyteoffset/NNP) (Chunk be/VB VARtarget/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARsrc be ? FUNCtoobject(VARarray). 
*0*(S (Chunk let/VB VARsrc/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARarray/NNP) )/) ./.)
*0*let VARsrclength be ? FUNCtolength(? FUNCget(VARsrc, "length")). 
*0*(S (Chunk let/VB VARsrclength/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARsrc/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*if VARsrclength + VARtargetoffset &gt; VARtargetlength, throw a rangeerror exception. 
*0*(S if/IN (Chunk VARsrclength/NNP) (Chunk +/NNP) (Chunk VARtargetoffset/NNP) &/CC gt/NN ;/: (Chunk VARtargetlength/NNP) ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*let VARtargetbyteindex be VARtargetoffset × VARtargetelementsize + VARtargetbyteoffset. 
*0*(S (Chunk let/VB VARtargetbyteindex/NNP) (Chunk be/VB VARtargetoffset/NNP) (Chunk ×/NNP) (Chunk VARtargetelementsize/NNP) (Chunk +/NNP) (Chunk VARtargetbyteoffset/NNP) ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*let VARlimit be VARtargetbyteindex + VARtargetelementsize × VARsrclength. 
*0*(S (Chunk let/VB VARlimit/NNP) (Chunk be/VB VARtargetbyteindex/NNP) (Chunk +/NNP) (Chunk VARtargetelementsize/NNP) (Chunk ×/NNP) (Chunk VARsrclength/NNP) ./.)
*0*repeat, while VARtargetbyteindex &lt; VARlimit
*0*(S repeat/NN ,/, while/IN (Chunk VARtargetbyteindex/NNP) &/CC lt/NN ;/: (Chunk VARlimit/NNP))
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*let VARknumber be ? FUNCtonumber(? FUNCget(VARsrc, VARpk)). 
*1*(S (Chunk let/VB VARknumber/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARsrc/NNP) ,/, (Chunk VARpk/NNP) )/) )/) ./.)
*1*if FUNCisdetachedbuffer(VARtargetbuffer) is true, throw a typeerror exception. 
*1*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARtargetbuffer/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*perform FUNCsetvalueinbuffer(VARtargetbuffer, VARtargetbyteindex, VARtargettype, VARknumber, true, "unordered"). 
*1*(S perform/NN (Chunk FUNCsetvalueinbuffer/NNP) (/( (Chunk VARtargetbuffer/NNP) ,/, (Chunk VARtargetbyteindex/NNP) ,/, (Chunk VARtargettype/NNP) ,/, (Chunk VARknumber/NNP) ,/, true/JJ ,/, ``/`` unordered/JJ ''/'' )/) ./.)
*1*set VARk to VARk + 1. 
*1*(S (Chunk set/VBN VARk/NNP) to/TO (Chunk VARk/NNP) (Chunk +/NNP) 1/CD ./.)
*1*set VARtargetbyteindex to VARtargetbyteindex + VARtargetelementsize. 
*1*(S set/VBN VARtargetbyteindex/NN to/TO (Chunk VARtargetbyteindex/NNP) (Chunk +/NNP) (Chunk VARtargetelementsize/NNP) ./.)
*0*return undefined.      
*0*(S return/NN undefined/VBD ./.)
ID= 22.2.3.23.1
Summary= %TypedArray%.prototype.set ( array [ , offset ] )
*0*assert: VARarray is any ecmascript language value other than an object with a [[TYPEDARRAYNAME]] internal slot. if it is such an object, the definition in 22.2.3.23.2 applies. 
*0*(S assert/NN :/: (Chunk VARarray/NNP) is/VBZ any/DT ecmascript/JJ language/NN value/NN other/JJ than/IN an/DT object/NN with/IN a/DT [/JJ [/NN (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./. if/IN it/PRP is/VBZ such/JJ an/DT object/NN ,/, the/DT definition/NN in/IN 22.2.3.23.2/CD applies/NNS ./.)
*0*let VARtarget be the this value. 
*0*(S (Chunk let/VB VARtarget/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARtarget does not have a [[TYPEDARRAYNAME]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARtarget/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: VARtarget has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*(S assert/NN :/: (Chunk VARtarget/NNP) has/VBZ a/DT [/JJ [/NN (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*let VARtargetoffset be ? FUNCtointeger(VARoffset). 
*0*(S (Chunk let/VB VARtargetoffset/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARoffset/NNP) )/) ./.)
*0*if VARtargetoffset &lt; 0, throw a rangeerror exception. 
*0*(S if/IN (Chunk VARtargetoffset/NNP) &/CC lt/NN ;/: 0/CD ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*let VARtargetbuffer be VARtarget.[[VIEWEDARRAYBUFFER]]. 
*0*(S (Chunk let/VB VARtargetbuffer/NNP) (Chunk be/VB VARtarget/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if FUNCisdetachedbuffer(VARtargetbuffer) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARtargetbuffer/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARtargetlength be VARtarget.[[ARRAYLENGTH]]. 
*0*(S (Chunk let/VB VARtargetlength/NNP) (Chunk be/VB VARtarget/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtargetname be the string value of VARtarget.[[TYPEDARRAYNAME]]. 
*0*(S (Chunk let/VB VARtargetname/NNP) be/VB the/DT string/VBG value/NN of/IN (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtargetelementsize be the number value of the element size value specified in table 56 for VARtargetname. 
*0*(S (Chunk let/VB VARtargetelementsize/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN (Chunk VARtargetname/NNP) ./.)
*0*let VARtargettype be the string value of the element type value in table 56 for VARtargetname. 
*0*(S (Chunk let/VB VARtargettype/NNP) be/VB the/DT string/VBG value/NN of/IN the/DT element/NN type/NN value/NN in/IN table/JJ 56/CD for/IN (Chunk VARtargetname/NNP) ./.)
*0*let VARtargetbyteoffset be VARtarget.[[BYTEOFFSET]]. 
*0*(S (Chunk let/VB VARtargetbyteoffset/NNP) (Chunk be/VB VARtarget/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARsrc be ? FUNCtoobject(VARarray). 
*0*(S (Chunk let/VB VARsrc/NNP) be/VB ?/. (Chunk FUNCtoobject/NNP) (/( (Chunk VARarray/NNP) )/) ./.)
*0*let VARsrclength be ? FUNCtolength(? FUNCget(VARsrc, "length")). 
*0*(S (Chunk let/VB VARsrclength/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARsrc/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*if VARsrclength + VARtargetoffset &gt; VARtargetlength, throw a rangeerror exception. 
*0*(S if/IN (Chunk VARsrclength/NNP) (Chunk +/NNP) (Chunk VARtargetoffset/NNP) &/CC gt/NN ;/: (Chunk VARtargetlength/NNP) ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*let VARtargetbyteindex be VARtargetoffset × VARtargetelementsize + VARtargetbyteoffset. 
*0*(S (Chunk let/VB VARtargetbyteindex/NNP) (Chunk be/VB VARtargetoffset/NNP) (Chunk ×/NNP) (Chunk VARtargetelementsize/NNP) (Chunk +/NNP) (Chunk VARtargetbyteoffset/NNP) ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*let VARlimit be VARtargetbyteindex + VARtargetelementsize × VARsrclength. 
*0*(S (Chunk let/VB VARlimit/NNP) (Chunk be/VB VARtargetbyteindex/NNP) (Chunk +/NNP) (Chunk VARtargetelementsize/NNP) (Chunk ×/NNP) (Chunk VARsrclength/NNP) ./.)
*0*repeat, while VARtargetbyteindex &lt; VARlimit
*0*(S repeat/NN ,/, while/IN (Chunk VARtargetbyteindex/NNP) &/CC lt/NN ;/: (Chunk VARlimit/NNP))
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*let VARknumber be ? FUNCtonumber(? FUNCget(VARsrc, VARpk)). 
*1*(S (Chunk let/VB VARknumber/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARsrc/NNP) ,/, (Chunk VARpk/NNP) )/) )/) ./.)
*1*if FUNCisdetachedbuffer(VARtargetbuffer) is true, throw a typeerror exception. 
*1*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARtargetbuffer/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*perform FUNCsetvalueinbuffer(VARtargetbuffer, VARtargetbyteindex, VARtargettype, VARknumber, true, "unordered"). 
*1*(S perform/NN (Chunk FUNCsetvalueinbuffer/NNP) (/( (Chunk VARtargetbuffer/NNP) ,/, (Chunk VARtargetbyteindex/NNP) ,/, (Chunk VARtargettype/NNP) ,/, (Chunk VARknumber/NNP) ,/, true/JJ ,/, ``/`` unordered/JJ ''/'' )/) ./.)
*1*set VARk to VARk + 1. 
*1*(S (Chunk set/VBN VARk/NNP) to/TO (Chunk VARk/NNP) (Chunk +/NNP) 1/CD ./.)
*1*set VARtargetbyteindex to VARtargetbyteindex + VARtargetelementsize. 
*1*(S set/VBN VARtargetbyteindex/NN to/TO (Chunk VARtargetbyteindex/NNP) (Chunk +/NNP) (Chunk VARtargetelementsize/NNP) ./.)
*0*return undefined.      
*0*(S return/NN undefined/VBD ./.)
ID= 22.2.3.23.2
Summary= %TypedArray%.prototype.set ( typedArray [ , offset ] )
*0*assert: VARtypedarray has a [[TYPEDARRAYNAME]] internal slot. if it does not, the definition in 22.2.3.23.1 applies. 
*0*(S assert/NN :/: VARtypedarray/NN has/VBZ a/DT [/JJ [/NN (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./. if/IN it/PRP does/VBZ not/RB ,/, the/DT definition/NN in/IN 22.2.3.23.1/CD applies/NNS ./.)
*0*let VARtarget be the this value. 
*0*(S (Chunk let/VB VARtarget/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARtarget does not have a [[TYPEDARRAYNAME]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARtarget/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: VARtarget has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*(S assert/NN :/: (Chunk VARtarget/NNP) has/VBZ a/DT [/JJ [/NN (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*let VARtargetoffset be ? FUNCtointeger(VARoffset). 
*0*(S (Chunk let/VB VARtargetoffset/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARoffset/NNP) )/) ./.)
*0*if VARtargetoffset &lt; 0, throw a rangeerror exception. 
*0*(S if/IN (Chunk VARtargetoffset/NNP) &/CC lt/NN ;/: 0/CD ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*let VARtargetbuffer be VARtarget.[[VIEWEDARRAYBUFFER]]. 
*0*(S (Chunk let/VB VARtargetbuffer/NNP) (Chunk be/VB VARtarget/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if FUNCisdetachedbuffer(VARtargetbuffer) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARtargetbuffer/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARtargetlength be VARtarget.[[ARRAYLENGTH]]. 
*0*(S (Chunk let/VB VARtargetlength/NNP) (Chunk be/VB VARtarget/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARsrcbuffer be VARtypedarray.[[VIEWEDARRAYBUFFER]]. 
*0*(S (Chunk let/VB VARsrcbuffer/NNP) (Chunk be/VB VARtypedarray/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if FUNCisdetachedbuffer(VARsrcbuffer) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARsrcbuffer/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARtargetname be the string value of VARtarget.[[TYPEDARRAYNAME]]. 
*0*(S (Chunk let/VB VARtargetname/NNP) be/VB the/DT string/VBG value/NN of/IN (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtargettype be the string value of the element type value in table 56 for VARtargetname. 
*0*(S (Chunk let/VB VARtargettype/NNP) be/VB the/DT string/VBG value/NN of/IN the/DT element/NN type/NN value/NN in/IN table/JJ 56/CD for/IN (Chunk VARtargetname/NNP) ./.)
*0*let VARtargetelementsize be the number value of the element size value specified in table 56 for VARtargetname. 
*0*(S (Chunk let/VB VARtargetelementsize/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN (Chunk VARtargetname/NNP) ./.)
*0*let VARtargetbyteoffset be VARtarget.[[BYTEOFFSET]]. 
*0*(S (Chunk let/VB VARtargetbyteoffset/NNP) (Chunk be/VB VARtarget/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARsrcname be the string value of VARtypedarray.[[TYPEDARRAYNAME]]. 
*0*(S (Chunk let/VB VARsrcname/NNP) be/VB the/DT string/VBG value/NN of/IN (Chunk VARtypedarray/NNP) ./. [/VB [/JJ (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARsrctype be the string value of the element type value in table 56 for VARsrcname. 
*0*(S (Chunk let/VB VARsrctype/NNP) be/VB the/DT string/VBG value/NN of/IN the/DT element/NN type/NN value/NN in/IN table/JJ 56/CD for/IN (Chunk VARsrcname/NNP) ./.)
*0*let VARsrcelementsize be the number value of the element size value specified in table 56 for VARsrcname. 
*0*(S (Chunk let/VB VARsrcelementsize/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN (Chunk VARsrcname/NNP) ./.)
*0*let VARsrclength be VARtypedarray.[[ARRAYLENGTH]]. 
*0*(S (Chunk let/VB VARsrclength/NNP) (Chunk be/VB VARtypedarray/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARsrcbyteoffset be VARtypedarray.[[BYTEOFFSET]]. 
*0*(S (Chunk let/VB VARsrcbyteoffset/NNP) (Chunk be/VB VARtypedarray/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARsrclength + VARtargetoffset &gt; VARtargetlength, throw a rangeerror exception. 
*0*(S if/IN (Chunk VARsrclength/NNP) (Chunk +/NNP) (Chunk VARtargetoffset/NNP) &/CC gt/NN ;/: (Chunk VARtargetlength/NNP) ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*if both FUNCissharedarraybuffer(VARsrcbuffer) and FUNCissharedarraybuffer(VARtargetbuffer) are true, then
*0*(S if/IN both/DT (Chunk FUNCissharedarraybuffer/NNP) (/( (Chunk VARsrcbuffer/NNP) )/) and/CC (Chunk FUNCissharedarraybuffer/NNP) (/( (Chunk VARtargetbuffer/NNP) )/) are/VBP true/JJ ,/, then/RB)
*1*if VARsrcbuffer.[[ARRAYBUFFERDATA]] and VARtargetbuffer.[[ARRAYBUFFERDATA]] are the same shared data block values, let VARsame be true; else let VARsame be false. 
*1*(S if/IN (Chunk VARsrcbuffer/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) and/CC (Chunk VARtargetbuffer/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) are/VBP the/DT same/JJ shared/VBN data/NNS block/NN values/NNS ,/, (Chunk let/VB VARsame/NNP) be/VB true/JJ ;/: else/JJ let/NN (Chunk VARsame/NNP) be/VB false/JJ ./.)
*0*else, let VARsame be FUNCsamevalue(VARsrcbuffer, VARtargetbuffer). 
*0*(S else/RB ,/, (Chunk let/VB VARsame/NNP) (Chunk be/VB FUNCsamevalue/NNP) (/( (Chunk VARsrcbuffer/NNP) ,/, (Chunk VARtargetbuffer/NNP) )/) ./.)
*0*if VARsame is true, then
*0*(S if/IN (Chunk VARsame/NNP) is/VBZ true/JJ ,/, then/RB)
*1*let VARsrcbytelength be VARtypedarray.[[BYTELENGTH]]. 
*1*(S (Chunk let/VB VARsrcbytelength/NNP) (Chunk be/VB VARtypedarray/NNP) ./. [/VB [/JJ (Chunk BYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*let VARsrcbuffer be ? FUNCclonearraybuffer(VARsrcbuffer, VARsrcbyteoffset, VARsrcbytelength, %arraybuffer%). 
*1*(S (Chunk let/VB VARsrcbuffer/NNP) be/VB ?/. (Chunk FUNCclonearraybuffer/NNP) (/( (Chunk VARsrcbuffer/NNP) ,/, (Chunk VARsrcbyteoffset/NNP) ,/, (Chunk VARsrcbytelength/NNP) ,/, %/NN arraybuffer/NN %/NN )/) ./.)
*1*note: %arraybuffer% is used to clone VARsrcbuffer because is it known to not have any observable side-effects. 
*1*(S note/NN :/: %/NN arraybuffer/NN %/NN is/VBZ used/VBN to/TO (Chunk clone/VB VARsrcbuffer/NNP) because/IN is/VBZ it/PRP known/VBN to/TO not/RB have/VB any/DT observable/JJ side-effects/NNS ./.)
*1*let VARsrcbyteindex be 0. 
*1*(S (Chunk let/VB VARsrcbyteindex/NNP) be/VB 0/CD ./.)
*0*else, let VARsrcbyteindex be VARsrcbyteoffset. 
*0*(S else/RB ,/, (Chunk let/VB VARsrcbyteindex/NNP) (Chunk be/VB VARsrcbyteoffset/NNP) ./.)
*0*let VARtargetbyteindex be VARtargetoffset × VARtargetelementsize + VARtargetbyteoffset. 
*0*(S (Chunk let/VB VARtargetbyteindex/NNP) (Chunk be/VB VARtargetoffset/NNP) (Chunk ×/NNP) (Chunk VARtargetelementsize/NNP) (Chunk +/NNP) (Chunk VARtargetbyteoffset/NNP) ./.)
*0*let VARlimit be VARtargetbyteindex + VARtargetelementsize × VARsrclength. 
*0*(S (Chunk let/VB VARlimit/NNP) (Chunk be/VB VARtargetbyteindex/NNP) (Chunk +/NNP) (Chunk VARtargetelementsize/NNP) (Chunk ×/NNP) (Chunk VARsrclength/NNP) ./.)
*0*if FUNCsamevalue(VARsrctype, VARtargettype) is true, then
*0*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARsrctype/NNP) ,/, (Chunk VARtargettype/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*note: if VARsrctype and VARtargettype are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data. 
*1*(S note/NN :/: if/IN (Chunk VARsrctype/NNP) and/CC (Chunk VARtargettype/NNP) are/VBP the/DT same/JJ ,/, the/DT transfer/NN must/MD be/VB performed/VBN in/IN a/DT manner/NN that/WDT preserves/VBZ the/DT bit-level/JJ encoding/NN of/IN the/DT source/NN data/NNS ./.)
*1*repeat, while VARtargetbyteindex &lt; VARlimit
*1*(S repeat/NN ,/, while/IN (Chunk VARtargetbyteindex/NNP) &/CC lt/NN ;/: (Chunk VARlimit/NNP))
*2*let VARvalue be FUNCgetvaluefrombuffer(VARsrcbuffer, VARsrcbyteindex, "uint8", true, "unordered"). 
*2*(S (Chunk let/VB VARvalue/NNP) (Chunk be/VB FUNCgetvaluefrombuffer/NNP) (/( (Chunk VARsrcbuffer/NNP) ,/, (Chunk VARsrcbyteindex/NNP) ,/, ``/`` uint8/JJ ''/'' ,/, true/JJ ,/, ``/`` unordered/JJ ''/'' )/) ./.)
*2*perform FUNCsetvalueinbuffer(VARtargetbuffer, VARtargetbyteindex, "uint8", VARvalue, true, "unordered"). 
*2*(S perform/NN (Chunk FUNCsetvalueinbuffer/NNP) (/( (Chunk VARtargetbuffer/NNP) ,/, (Chunk VARtargetbyteindex/NNP) ,/, ``/`` uint8/JJ ''/'' ,/, (Chunk VARvalue/NNP) ,/, true/JJ ,/, ``/`` unordered/JJ ''/'' )/) ./.)
*2*set VARsrcbyteindex to VARsrcbyteindex + 1. 
*2*(S set/VBN VARsrcbyteindex/NN to/TO (Chunk VARsrcbyteindex/NNP) (Chunk +/NNP) 1/CD ./.)
*2*set VARtargetbyteindex to VARtargetbyteindex + 1. 
*2*(S set/VBN VARtargetbyteindex/NN to/TO (Chunk VARtargetbyteindex/NNP) (Chunk +/NNP) 1/CD ./.)
*0*else,
*0*(S else/RB ,/,)
*1*repeat, while VARtargetbyteindex &lt; VARlimit
*1*(S repeat/NN ,/, while/IN (Chunk VARtargetbyteindex/NNP) &/CC lt/NN ;/: (Chunk VARlimit/NNP))
*2*let VARvalue be FUNCgetvaluefrombuffer(VARsrcbuffer, VARsrcbyteindex, VARsrctype, true, "unordered"). 
*2*(S (Chunk let/VB VARvalue/NNP) (Chunk be/VB FUNCgetvaluefrombuffer/NNP) (/( (Chunk VARsrcbuffer/NNP) ,/, (Chunk VARsrcbyteindex/NNP) ,/, (Chunk VARsrctype/NNP) ,/, true/JJ ,/, ``/`` unordered/JJ ''/'' )/) ./.)
*2*perform FUNCsetvalueinbuffer(VARtargetbuffer, VARtargetbyteindex, VARtargettype, VARvalue, true, "unordered"). 
*2*(S perform/NN (Chunk FUNCsetvalueinbuffer/NNP) (/( (Chunk VARtargetbuffer/NNP) ,/, (Chunk VARtargetbyteindex/NNP) ,/, (Chunk VARtargettype/NNP) ,/, (Chunk VARvalue/NNP) ,/, true/JJ ,/, ``/`` unordered/JJ ''/'' )/) ./.)
*2*set VARsrcbyteindex to VARsrcbyteindex + VARsrcelementsize. 
*2*(S set/VBN VARsrcbyteindex/NN to/TO (Chunk VARsrcbyteindex/NNP) (Chunk +/NNP) (Chunk VARsrcelementsize/NNP) ./.)
*2*set VARtargetbyteindex to VARtargetbyteindex + VARtargetelementsize. 
*2*(S set/VBN VARtargetbyteindex/NN to/TO (Chunk VARtargetbyteindex/NNP) (Chunk +/NNP) (Chunk VARtargetelementsize/NNP) ./.)
*0*return undefined.      
*0*(S return/NN undefined/VBD ./.)
ID= 22.2.3.24
Summary= %TypedArray%.prototype.slice ( start, end )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*perform ? FUNCvalidatetypedarray(VARo). 
*0*(S perform/NN ?/. (Chunk FUNCvalidatetypedarray/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*let VARlen be VARo.[[ARRAYLENGTH]]. 
*0*(S (Chunk let/VB VARlen/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARrelativestart be ? FUNCtointeger(VARstart). 
*0*(S (Chunk let/VB VARrelativestart/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARstart/NNP) )/) ./.)
*0*if VARrelativestart &lt; 0, let VARk be max((VARlen + VARrelativestart), 0); else let VARk be min(VARrelativestart, VARlen). 
*0*(S if/IN (Chunk VARrelativestart/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARk/NNP) be/VB max/VBN (/( (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARrelativestart/NNP) )/) ,/, 0/CD )/) ;/: else/JJ let/NN (Chunk VARk/NNP) be/VB min/VBN (/( (Chunk VARrelativestart/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*if VARend is undefined, let VARrelativeend be VARlen; else let VARrelativeend be ? FUNCtointeger(VARend). 
*0*(S if/IN (Chunk VARend/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARrelativeend/NNP) (Chunk be/VB VARlen/NNP) ;/: else/JJ (Chunk let/VB VARrelativeend/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARend/NNP) )/) ./.)
*0*if VARrelativeend &lt; 0, let VARfinal be max((VARlen + VARrelativeend), 0); else let VARfinal be min(VARrelativeend, VARlen). 
*0*(S if/IN (Chunk VARrelativeend/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARfinal/NNP) be/VB max/VBN (/( (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARrelativeend/NNP) )/) ,/, 0/CD )/) ;/: else/JJ (Chunk let/VB VARfinal/NNP) be/VB min/VBN (/( (Chunk VARrelativeend/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*let VARcount be max(VARfinal - VARk, 0). 
*0*(S (Chunk let/VB VARcount/NNP) be/VB max/VBN (/( (Chunk VARfinal/NNP) -/: (Chunk VARk/NNP) ,/, 0/CD )/) ./.)
*0*let VARa be ? typedarrayspeciescreate(VARo, « VARcount »). 
*0*(S (Chunk let/VB VARa/NNP) be/VB ?/. typedarrayspeciescreate/NN (/( (Chunk VARo/NNP) ,/, (Chunk «/NNP) (Chunk VARcount/NNP) (Chunk »/NNP) )/) ./.)
*0*let VARsrcname be the string value of VARo.[[TYPEDARRAYNAME]]. 
*0*(S (Chunk let/VB VARsrcname/NNP) be/VB the/DT string/VBG value/NN of/IN (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARsrctype be the string value of the element type value in table 56 for VARsrcname. 
*0*(S (Chunk let/VB VARsrctype/NNP) be/VB the/DT string/VBG value/NN of/IN the/DT element/NN type/NN value/NN in/IN table/JJ 56/CD for/IN (Chunk VARsrcname/NNP) ./.)
*0*let VARtargetname be the string value of VARa.[[TYPEDARRAYNAME]]. 
*0*(S (Chunk let/VB VARtargetname/NNP) be/VB the/DT string/VBG value/NN of/IN (Chunk VARa/NNP) ./. [/VB [/JJ (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtargettype be the string value of the element type value in table 56 for VARtargetname. 
*0*(S (Chunk let/VB VARtargettype/NNP) be/VB the/DT string/VBG value/NN of/IN the/DT element/NN type/NN value/NN in/IN table/JJ 56/CD for/IN (Chunk VARtargetname/NNP) ./.)
*0*if FUNCsamevalue(VARsrctype, VARtargettype) is false, then
*0*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARsrctype/NNP) ,/, (Chunk VARtargettype/NNP) )/) is/VBZ false/JJ ,/, then/RB)
*1*let VARn be 0. 
*1*(S (Chunk let/VB VARn/NNP) be/VB 0/CD ./.)
*1*repeat, while VARk &lt; VARfinal
*1*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARfinal/NNP))
*2*let VARpk be ! FUNCtostring(VARk). 
*2*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*2*let VARkvalue be ? FUNCget(VARo, VARpk). 
*2*(S (Chunk let/VB VARkvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*2*perform ! FUNCset(VARa, ! FUNCtostring(VARn), VARkvalue). 
*2*(S perform/NN !/. (Chunk FUNCset/NNP) (/( (Chunk VARa/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARn/NNP) )/) ,/, (Chunk VARkvalue/NNP) )/) ./.)
*2*increase VARk by 1. 
*2*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*2*increase VARn by 1. 
*2*(S increase/NN (Chunk VARn/NNP) by/IN 1/CD ./.)
*0*else if VARcount &gt; 0, then
*0*(S else/RB if/IN (Chunk VARcount/NNP) &/CC gt/NN ;/: 0/CD ,/, then/RB)
*1*let VARsrcbuffer be VARo.[[VIEWEDARRAYBUFFER]]. 
*1*(S (Chunk let/VB VARsrcbuffer/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*if FUNCisdetachedbuffer(VARsrcbuffer) is true, throw a typeerror exception. 
*1*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARsrcbuffer/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*let VARtargetbuffer be VARa.[[VIEWEDARRAYBUFFER]]. 
*1*(S (Chunk let/VB VARtargetbuffer/NNP) (Chunk be/VB VARa/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*let VARelementsize be the number value of the element size value specified in table 56 for VARsrctype. 
*1*(S (Chunk let/VB VARelementsize/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN (Chunk VARsrctype/NNP) ./.)
*1*note: if VARsrctype and VARtargettype are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data. 
*1*(S note/NN :/: if/IN (Chunk VARsrctype/NNP) and/CC (Chunk VARtargettype/NNP) are/VBP the/DT same/JJ ,/, the/DT transfer/NN must/MD be/VB performed/VBN in/IN a/DT manner/NN that/WDT preserves/VBZ the/DT bit-level/JJ encoding/NN of/IN the/DT source/NN data/NNS ./.)
*1*let VARsrcbyteoffet be VARo.[[BYTEOFFSET]]. 
*1*(S (Chunk let/VB VARsrcbyteoffet/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*let VARtargetbyteindex be VARa.[[BYTEOFFSET]]. 
*1*(S (Chunk let/VB VARtargetbyteindex/NNP) (Chunk be/VB VARa/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*let VARsrcbyteindex be (VARk × VARelementsize) + VARsrcbyteoffet. 
*1*(S (Chunk let/VB VARsrcbyteindex/NNP) be/VB (/( (Chunk VARk/NNP) (Chunk ×/NNP) (Chunk VARelementsize/NNP) )/) (Chunk +/VBP VARsrcbyteoffet/NNP) ./.)
*1*let VARlimit be VARtargetbyteindex + VARcount × VARelementsize. 
*1*(S (Chunk let/VB VARlimit/NNP) (Chunk be/VB VARtargetbyteindex/NNP) (Chunk +/NNP) (Chunk VARcount/NNP) (Chunk ×/NNP) (Chunk VARelementsize/NNP) ./.)
*1*repeat, while VARtargetbyteindex &lt; VARlimit
*1*(S repeat/NN ,/, while/IN (Chunk VARtargetbyteindex/NNP) &/CC lt/NN ;/: (Chunk VARlimit/NNP))
*2*let VARvalue be FUNCgetvaluefrombuffer(VARsrcbuffer, VARsrcbyteindex, "uint8", true, "unordered"). 
*2*(S (Chunk let/VB VARvalue/NNP) (Chunk be/VB FUNCgetvaluefrombuffer/NNP) (/( (Chunk VARsrcbuffer/NNP) ,/, (Chunk VARsrcbyteindex/NNP) ,/, ``/`` uint8/JJ ''/'' ,/, true/JJ ,/, ``/`` unordered/JJ ''/'' )/) ./.)
*2*perform FUNCsetvalueinbuffer(VARtargetbuffer, VARtargetbyteindex, "uint8", VARvalue, true, "unordered"). 
*2*(S perform/NN (Chunk FUNCsetvalueinbuffer/NNP) (/( (Chunk VARtargetbuffer/NNP) ,/, (Chunk VARtargetbyteindex/NNP) ,/, ``/`` uint8/JJ ''/'' ,/, (Chunk VARvalue/NNP) ,/, true/JJ ,/, ``/`` unordered/JJ ''/'' )/) ./.)
*2*increase VARsrcbyteindex by 1. 
*2*(S increase/NN (Chunk VARsrcbyteindex/NNP) by/IN 1/CD ./.)
*2*increase VARtargetbyteindex by 1. 
*2*(S increase/NN (Chunk VARtargetbyteindex/NNP) by/IN 1/CD ./.)
*0*return VARa.     
*0*(S return/NN (Chunk VARa/NNP) ./.)
ID= 22.2.3.26
Summary= %TypedArray%.prototype.sort ( comparefn )
*0*if VARcomparefn is not undefined and FUNCiscallable(VARcomparefn) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk VARcomparefn/NNP) is/VBZ not/RB undefined/JJ and/CC FUNCiscallable/JJ (/( (Chunk VARcomparefn/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARobj be the this value. 
*0*(S (Chunk let/VB VARobj/NNP) be/VB the/DT this/DT value/NN ./.)
*0*let VARbuffer be ? FUNCvalidatetypedarray(VARobj). 
*0*(S (Chunk let/VB VARbuffer/NNP) be/VB ?/. (Chunk FUNCvalidatetypedarray/NNP) (/( (Chunk VARobj/NNP) )/) ./.)
*0*let VARlen be VARobj.[[ARRAYLENGTH]].     
*0*(S (Chunk let/VB VARlen/NNP) (Chunk be/VB VARobj/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
ID= 22.2.3.27
Summary= %TypedArray%.prototype.subarray ( begin, end )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARo does not have a [[TYPEDARRAYNAME]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARo/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: VARo has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*(S assert/NN :/: (Chunk VARo/NNP) has/VBZ a/DT [/JJ [/NN (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*let VARbuffer be VARo.[[VIEWEDARRAYBUFFER]]. 
*0*(S (Chunk let/VB VARbuffer/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARsrclength be VARo.[[ARRAYLENGTH]]. 
*0*(S (Chunk let/VB VARsrclength/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARrelativebegin be ? FUNCtointeger(VARbegin). 
*0*(S (Chunk let/VB VARrelativebegin/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARbegin/NNP) )/) ./.)
*0*if VARrelativebegin &lt; 0, let VARbeginindex be max((VARsrclength + VARrelativebegin), 0); else let VARbeginindex be min(VARrelativebegin, VARsrclength). 
*0*(S if/IN (Chunk VARrelativebegin/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARbeginindex/NNP) be/VB max/VBN (/( (/( (Chunk VARsrclength/NNP) (Chunk +/NNP) (Chunk VARrelativebegin/NNP) )/) ,/, 0/CD )/) ;/: else/JJ (Chunk let/VB VARbeginindex/NNP) be/VB min/VBN (/( (Chunk VARrelativebegin/NNP) ,/, (Chunk VARsrclength/NNP) )/) ./.)
*0*if VARend is undefined, let VARrelativeend be VARsrclength; else, let VARrelativeend be ? FUNCtointeger(VARend). 
*0*(S if/IN (Chunk VARend/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARrelativeend/NNP) (Chunk be/VB VARsrclength/NNP) ;/: else/RB ,/, (Chunk let/VB VARrelativeend/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARend/NNP) )/) ./.)
*0*if VARrelativeend &lt; 0, let VARendindex be max((VARsrclength + VARrelativeend), 0); else let VARendindex be min(VARrelativeend, VARsrclength). 
*0*(S if/IN (Chunk VARrelativeend/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARendindex/NNP) be/VB max/VBN (/( (/( (Chunk VARsrclength/NNP) (Chunk +/NNP) (Chunk VARrelativeend/NNP) )/) ,/, 0/CD )/) ;/: else/JJ (Chunk let/VB VARendindex/NNP) be/VB min/VBN (/( (Chunk VARrelativeend/NNP) ,/, (Chunk VARsrclength/NNP) )/) ./.)
*0*let VARnewlength be max(VARendindex - VARbeginindex, 0). 
*0*(S (Chunk let/VB VARnewlength/NNP) be/VB max/VBN (/( (Chunk VARendindex/NNP) -/: VARbeginindex/NN ,/, 0/CD )/) ./.)
*0*let VARconstructorname be the string value of VARo.[[TYPEDARRAYNAME]]. 
*0*(S (Chunk let/VB VARconstructorname/NNP) be/VB the/DT string/VBG value/NN of/IN (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARelementsize be the number value of the element size value specified in table 56 for VARconstructorname. 
*0*(S (Chunk let/VB VARelementsize/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN (Chunk VARconstructorname/NNP) ./.)
*0*let VARsrcbyteoffset be VARo.[[BYTEOFFSET]]. 
*0*(S (Chunk let/VB VARsrcbyteoffset/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARbeginbyteoffset be VARsrcbyteoffset + VARbeginindex × VARelementsize. 
*0*(S (Chunk let/VB VARbeginbyteoffset/NNP) (Chunk be/VB VARsrcbyteoffset/NNP) (Chunk +/NNP) (Chunk VARbeginindex/NNP) (Chunk ×/NNP) (Chunk VARelementsize/NNP) ./.)
*0*let VARargumentslist be « VARbuffer, VARbeginbyteoffset, VARnewlength ». 
*0*(S (Chunk let/VB VARargumentslist/NNP) be/VB «/JJ (Chunk VARbuffer/NNP) ,/, (Chunk VARbeginbyteoffset/NNP) ,/, (Chunk VARnewlength/NNP) (Chunk »/NNP) ./.)
*0*return ? typedarrayspeciescreate(VARo, VARargumentslist).     
*0*(S return/NN ?/. typedarrayspeciescreate/NN (/( (Chunk VARo/NNP) ,/, (Chunk VARargumentslist/NNP) )/) ./.)
ID= 22.2.3.30
Summary= %TypedArray%.prototype.values ( )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*perform ? FUNCvalidatetypedarray(VARo). 
*0*(S perform/NN ?/. (Chunk FUNCvalidatetypedarray/NNP) (/( (Chunk VARo/NNP) )/) ./.)
*0*return FUNCcreatearrayiterator(VARo, "value").     
*0*(S return/NN (Chunk FUNCcreatearrayiterator/NNP) (/( (Chunk VARo/NNP) ,/, ``/`` value/NN ''/'' )/) ./.)
ID= 22.2.4.1
Summary= TypedArray ( )
*0*if newtarget is undefined, throw a typeerror exception. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARconstructorname be the string value of the constructor name value specified in table 56 for this VARtypedarray constructor. 
*0*(S (Chunk let/VB VARconstructorname/NNP) be/VB the/DT string/VBG value/NN of/IN the/DT constructor/NN name/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN this/DT (Chunk VARtypedarray/NNP) constructor/NN ./.)
*0*return ? FUNCallocatetypedarray(VARconstructorname, newtarget, "%VARtypedarrayprototype%", 0).     
*0*(S return/NN ?/. (Chunk FUNCallocatetypedarray/NNP) (/( (Chunk VARconstructorname/NNP) ,/, newtarget/NN ,/, ``/`` %/NN VARtypedarrayprototype/JJ %/NN ''/'' ,/, 0/CD )/) ./.)
ID= 22.2.4.2
Summary= TypedArray ( length )
*0*assert: FUNCtype(VARlength) is not object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARlength/NNP) )/) is/VBZ not/RB object/JJ ./.)
*0*if newtarget is undefined, throw a typeerror exception. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARelementlength be ? FUNCtoindex(VARlength). 
*0*(S (Chunk let/VB VARelementlength/NNP) be/VB ?/. (Chunk FUNCtoindex/NNP) (/( (Chunk VARlength/NNP) )/) ./.)
*0*let VARconstructorname be the string value of the constructor name value specified in table 56 for this VARtypedarray constructor. 
*0*(S (Chunk let/VB VARconstructorname/NNP) be/VB the/DT string/VBG value/NN of/IN the/DT constructor/NN name/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN this/DT (Chunk VARtypedarray/NNP) constructor/NN ./.)
*0*return ? FUNCallocatetypedarray(VARconstructorname, newtarget, "%VARtypedarrayprototype%", VARelementlength).     
*0*(S return/NN ?/. (Chunk FUNCallocatetypedarray/NNP) (/( (Chunk VARconstructorname/NNP) ,/, newtarget/NN ,/, ``/`` %/NN VARtypedarrayprototype/JJ %/NN ''/'' ,/, (Chunk VARelementlength/NNP) )/) ./.)
ID= 22.2.4.2.1
Summary= Runtime Semantics: AllocateTypedArray ( constructorName, newTarget, defaultProto [ , length ] )
*0*let VARproto be ? FUNCgetprototypefromconstructor(VARnewtarget, VARdefaultproto). 
*0*(S (Chunk let/VB VARproto/NNP) be/VB ?/. (Chunk FUNCgetprototypefromconstructor/NNP) (/( (Chunk VARnewtarget/NNP) ,/, (Chunk VARdefaultproto/NNP) )/) ./.)
*0*let VARobj be FUNCintegerindexedobjectcreate(VARproto, « [[VIEWEDARRAYBUFFER]], [[TYPEDARRAYNAME]], [[BYTELENGTH]], [[BYTEOFFSET]], [[ARRAYLENGTH]] »). 
*0*(S (Chunk let/VB VARobj/NNP) (Chunk be/VB FUNCintegerindexedobjectcreate/NNP) (/( (Chunk VARproto/NNP) ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk BYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*assert: VARobj.[[VIEWEDARRAYBUFFER]] is undefined. 
*0*(S assert/NN :/: (Chunk VARobj/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ undefined/VBN ./.)
*0*set VARobj.[[TYPEDARRAYNAME]] to VARconstructorname. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARconstructorname/NNP) ./.)
*0*if VARlength is not present, then
*0*(S if/IN (Chunk VARlength/NNP) is/VBZ not/RB present/JJ ,/, then/RB)
*1*set VARobj.[[BYTELENGTH]] to 0. 
*1*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk BYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO 0/CD ./.)
*1*set VARobj.[[BYTEOFFSET]] to 0. 
*1*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO 0/CD ./.)
*1*set VARobj.[[ARRAYLENGTH]] to 0. 
*1*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO 0/CD ./.)
*0*else,
*0*(S else/RB ,/,)
*1*perform ? FUNCallocatetypedarraybuffer(VARobj, VARlength). 
*1*(S perform/NN ?/. (Chunk FUNCallocatetypedarraybuffer/NNP) (/( (Chunk VARobj/NNP) ,/, (Chunk VARlength/NNP) )/) ./.)
*0*return VARobj.      
*0*(S return/NN (Chunk VARobj/NNP) ./.)
ID= 22.2.4.2.2
Summary= Runtime Semantics: AllocateTypedArrayBuffer ( O, length )
*0*assert: VARo is an object that has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*(S assert/NN :/: (Chunk VARo/NNP) is/VBZ an/DT object/NN that/WDT has/VBZ a/DT [/JJ [/NN (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*assert: VARo.[[VIEWEDARRAYBUFFER]] is undefined. 
*0*(S assert/NN :/: (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ undefined/VBN ./.)
*0*assert: VARlength ≥ 0. 
*0*(S assert/NN :/: (Chunk VARlength/NNP) ≥/VBZ 0/CD ./.)
*0*let VARconstructorname be the string value of VARo.[[TYPEDARRAYNAME]]. 
*0*(S (Chunk let/VB VARconstructorname/NNP) be/VB the/DT string/VBG value/NN of/IN (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARelementsize be the element size value in table 56 for VARconstructorname. 
*0*(S (Chunk let/VB VARelementsize/NNP) be/VB the/DT element/JJ size/NN value/NN in/IN table/JJ 56/CD for/IN (Chunk VARconstructorname/NNP) ./.)
*0*let VARbytelength be VARelementsize × VARlength. 
*0*(S (Chunk let/VB VARbytelength/NNP) (Chunk be/VB VARelementsize/NNP) (Chunk ×/NNP) (Chunk VARlength/NNP) ./.)
*0*let VARdata be ? FUNCallocatearraybuffer(%arraybuffer%, VARbytelength). 
*0*(S (Chunk let/VB VARdata/NNP) be/VB ?/. (Chunk FUNCallocatearraybuffer/NNP) (/( %/NN arraybuffer/NN %/NN ,/, (Chunk VARbytelength/NNP) )/) ./.)
*0*set VARo.[[VIEWEDARRAYBUFFER]] to VARdata. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARdata/NNP) ./.)
*0*set VARo.[[BYTELENGTH]] to VARbytelength. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk BYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARbytelength/NNP) ./.)
*0*set VARo.[[BYTEOFFSET]] to 0. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO 0/CD ./.)
*0*set VARo.[[ARRAYLENGTH]] to VARlength. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARlength/NNP) ./.)
*0*return VARo.      
*0*(S return/NN (Chunk VARo/NNP) ./.)
ID= 22.2.4.3
Summary= TypedArray ( typedArray )
*0*assert: FUNCtype(VARtypedarray) is object and VARtypedarray has a [[TYPEDARRAYNAME]] internal slot. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARtypedarray/NNP) )/) is/VBZ object/JJ and/CC (Chunk VARtypedarray/NNP) has/VBZ a/DT [/JJ [/NN (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*if newtarget is undefined, throw a typeerror exception. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARconstructorname be the string value of the constructor name value specified in table 56 for this VARtypedarray constructor. 
*0*(S (Chunk let/VB VARconstructorname/NNP) be/VB the/DT string/VBG value/NN of/IN the/DT constructor/NN name/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN this/DT (Chunk VARtypedarray/NNP) constructor/NN ./.)
*0*let VARo be ? FUNCallocatetypedarray(VARconstructorname, newtarget, "%VARtypedarrayprototype%"). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCallocatetypedarray/NNP) (/( (Chunk VARconstructorname/NNP) ,/, newtarget/NN ,/, ``/`` %/NN VARtypedarrayprototype/JJ %/NN ''/'' )/) ./.)
*0*let VARsrcarray be VARtypedarray. 
*0*(S (Chunk let/VB VARsrcarray/NNP) (Chunk be/VB VARtypedarray/NNP) ./.)
*0*let VARsrcdata be VARsrcarray.[[VIEWEDARRAYBUFFER]]. 
*0*(S (Chunk let/VB VARsrcdata/NNP) (Chunk be/VB VARsrcarray/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if FUNCisdetachedbuffer(VARsrcdata) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARsrcdata/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARelementtype be the string value of the element type value in table 56 for VARconstructorname. 
*0*(S (Chunk let/VB VARelementtype/NNP) be/VB the/DT string/VBG value/NN of/IN the/DT element/NN type/NN value/NN in/IN table/JJ 56/CD for/IN (Chunk VARconstructorname/NNP) ./.)
*0*let VARelementlength be VARsrcarray.[[ARRAYLENGTH]]. 
*0*(S (Chunk let/VB VARelementlength/NNP) (Chunk be/VB VARsrcarray/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARsrcname be the string value of VARsrcarray.[[TYPEDARRAYNAME]]. 
*0*(S (Chunk let/VB VARsrcname/NNP) be/VB the/DT string/VBG value/NN of/IN (Chunk VARsrcarray/NNP) ./. [/VB [/JJ (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARsrctype be the string value of the element type value in table 56 for VARsrcname. 
*0*(S (Chunk let/VB VARsrctype/NNP) be/VB the/DT string/VBG value/NN of/IN the/DT element/NN type/NN value/NN in/IN table/JJ 56/CD for/IN (Chunk VARsrcname/NNP) ./.)
*0*let VARsrcelementsize be the element size value in table 56 for VARsrcname. 
*0*(S (Chunk let/VB VARsrcelementsize/NNP) be/VB the/DT element/JJ size/NN value/NN in/IN table/JJ 56/CD for/IN (Chunk VARsrcname/NNP) ./.)
*0*let VARsrcbyteoffset be VARsrcarray.[[BYTEOFFSET]]. 
*0*(S (Chunk let/VB VARsrcbyteoffset/NNP) (Chunk be/VB VARsrcarray/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARelementsize be the element size value in table 56 for VARconstructorname. 
*0*(S (Chunk let/VB VARelementsize/NNP) be/VB the/DT element/JJ size/NN value/NN in/IN table/JJ 56/CD for/IN (Chunk VARconstructorname/NNP) ./.)
*0*let VARbytelength be VARelementsize × VARelementlength. 
*0*(S (Chunk let/VB VARbytelength/NNP) (Chunk be/VB VARelementsize/NNP) (Chunk ×/NNP) (Chunk VARelementlength/NNP) ./.)
*0*if FUNCissharedarraybuffer(VARsrcdata) is false, then
*0*(S if/IN (Chunk FUNCissharedarraybuffer/NNP) (/( (Chunk VARsrcdata/NNP) )/) is/VBZ false/JJ ,/, then/RB)
*1*let VARbufferconstructor be ? FUNCspeciesconstructor(VARsrcdata, %arraybuffer%). 
*1*(S (Chunk let/VB VARbufferconstructor/NNP) be/VB ?/. (Chunk FUNCspeciesconstructor/NNP) (/( (Chunk VARsrcdata/NNP) ,/, %/NN arraybuffer/NN %/NN )/) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARbufferconstructor be %arraybuffer%. 
*1*(S (Chunk let/VB VARbufferconstructor/NNP) be/VB %/NN arraybuffer/NN %/NN ./.)
*0*if FUNCsamevalue(VARelementtype, VARsrctype) is true, then
*0*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARelementtype/NNP) ,/, (Chunk VARsrctype/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*if FUNCisdetachedbuffer(VARsrcdata) is true, throw a typeerror exception. 
*1*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARsrcdata/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*let VARdata be ? FUNCclonearraybuffer(VARsrcdata, VARsrcbyteoffset, VARbytelength, VARbufferconstructor). 
*1*(S (Chunk let/VB VARdata/NNP) be/VB ?/. (Chunk FUNCclonearraybuffer/NNP) (/( (Chunk VARsrcdata/NNP) ,/, (Chunk VARsrcbyteoffset/NNP) ,/, (Chunk VARbytelength/NNP) ,/, (Chunk VARbufferconstructor/NNP) )/) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARdata be ? FUNCallocatearraybuffer(VARbufferconstructor, VARbytelength). 
*1*(S (Chunk let/VB VARdata/NNP) be/VB ?/. (Chunk FUNCallocatearraybuffer/NNP) (/( (Chunk VARbufferconstructor/NNP) ,/, (Chunk VARbytelength/NNP) )/) ./.)
*1*if FUNCisdetachedbuffer(VARsrcdata) is true, throw a typeerror exception. 
*1*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARsrcdata/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*1*let VARsrcbyteindex be VARsrcbyteoffset. 
*1*(S (Chunk let/VB VARsrcbyteindex/NNP) (Chunk be/VB VARsrcbyteoffset/NNP) ./.)
*1*let VARtargetbyteindex be 0. 
*1*(S (Chunk let/VB VARtargetbyteindex/NNP) be/VB 0/CD ./.)
*1*let VARcount be VARelementlength. 
*1*(S (Chunk let/VB VARcount/NNP) (Chunk be/VB VARelementlength/NNP) ./.)
*1*repeat, while VARcount &gt; 0
*1*(S repeat/NN ,/, while/IN (Chunk VARcount/NNP) &/CC gt/NN ;/: 0/CD)
*2*let VARvalue be FUNCgetvaluefrombuffer(VARsrcdata, VARsrcbyteindex, VARsrctype, true, "unordered"). 
*2*(S (Chunk let/VB VARvalue/NNP) (Chunk be/VB FUNCgetvaluefrombuffer/NNP) (/( (Chunk VARsrcdata/NNP) ,/, (Chunk VARsrcbyteindex/NNP) ,/, (Chunk VARsrctype/NNP) ,/, true/JJ ,/, ``/`` unordered/JJ ''/'' )/) ./.)
*2*perform FUNCsetvalueinbuffer(VARdata, VARtargetbyteindex, VARelementtype, VARvalue, true, "unordered"). 
*2*(S perform/NN (Chunk FUNCsetvalueinbuffer/NNP) (/( (Chunk VARdata/NNP) ,/, (Chunk VARtargetbyteindex/NNP) ,/, (Chunk VARelementtype/NNP) ,/, (Chunk VARvalue/NNP) ,/, true/JJ ,/, ``/`` unordered/JJ ''/'' )/) ./.)
*2*set VARsrcbyteindex to VARsrcbyteindex + VARsrcelementsize. 
*2*(S set/VBN VARsrcbyteindex/NN to/TO (Chunk VARsrcbyteindex/NNP) (Chunk +/NNP) (Chunk VARsrcelementsize/NNP) ./.)
*2*set VARtargetbyteindex to VARtargetbyteindex + VARelementsize. 
*2*(S set/VBN VARtargetbyteindex/NN to/TO (Chunk VARtargetbyteindex/NNP) (Chunk +/NNP) (Chunk VARelementsize/NNP) ./.)
*2*decrement VARcount by 1. 
*2*(S decrement/NN (Chunk VARcount/NNP) by/IN 1/CD ./.)
*0*set VARo.[[VIEWEDARRAYBUFFER]] to VARdata. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARdata/NNP) ./.)
*0*set VARo.[[BYTELENGTH]] to VARbytelength. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk BYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARbytelength/NNP) ./.)
*0*set VARo.[[BYTEOFFSET]] to 0. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO 0/CD ./.)
*0*set VARo.[[ARRAYLENGTH]] to VARelementlength. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARelementlength/NNP) ./.)
*0*return VARo.     
*0*(S return/NN (Chunk VARo/NNP) ./.)
ID= 22.2.4.4
Summary= TypedArray ( object )
*0*assert: FUNCtype(VARobject) is object and VARobject does not have either a [[TYPEDARRAYNAME]] or an [[ARRAYBUFFERDATA]] internal slot. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARobject/NNP) )/) is/VBZ object/JJ and/CC (Chunk VARobject/NNP) does/VBZ not/RB have/VB either/CC a/DT [/JJ [/NN (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) or/CC an/DT [/JJ [/NN (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*if newtarget is undefined, throw a typeerror exception. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARconstructorname be the string value of the constructor name value specified in table 56 for this VARtypedarray constructor. 
*0*(S (Chunk let/VB VARconstructorname/NNP) be/VB the/DT string/VBG value/NN of/IN the/DT constructor/NN name/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN this/DT (Chunk VARtypedarray/NNP) constructor/NN ./.)
*0*let VARo be ? FUNCallocatetypedarray(VARconstructorname, newtarget, "%VARtypedarrayprototype%"). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCallocatetypedarray/NNP) (/( (Chunk VARconstructorname/NNP) ,/, newtarget/NN ,/, ``/`` %/NN VARtypedarrayprototype/JJ %/NN ''/'' )/) ./.)
*0*let VARusingiterator be ? FUNCgetmethod(VARobject, @@iterator). 
*0*(S (Chunk let/VB VARusingiterator/NNP) be/VB ?/. (Chunk FUNCgetmethod/NNP) (/( (Chunk VARobject/NNP) ,/, (Chunk @/NNP) (Chunk @/NNP) iterator/NN )/) ./.)
*0*if VARusingiterator is not undefined, then
*0*(S if/IN (Chunk VARusingiterator/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*1*let VARvalues be ? FUNCiterabletolist(VARobject, VARusingiterator). 
*1*(S (Chunk let/VB VARvalues/NNP) be/VB ?/. (Chunk FUNCiterabletolist/NNP) (/( (Chunk VARobject/NNP) ,/, (Chunk VARusingiterator/NNP) )/) ./.)
*1*let VARlen be the number of elements in VARvalues. 
*1*(S (Chunk let/VB VARlen/NNP) be/VB the/DT number/NN of/IN elements/NNS in/IN (Chunk VARvalues/NNP) ./.)
*1*perform ? FUNCallocatetypedarraybuffer(VARo, VARlen). 
*1*(S perform/NN ?/. (Chunk FUNCallocatetypedarraybuffer/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*1*let VARk be 0. 
*1*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*1*repeat, while VARk &lt; VARlen
*1*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*2*let VARpk be ! FUNCtostring(VARk). 
*2*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*2*let VARkvalue be the first element of VARvalues and remove that element from VARvalues. 
*2*(S (Chunk let/VB VARkvalue/NNP) be/VB the/DT first/JJ element/NN of/IN (Chunk VARvalues/NNP) and/CC remove/VB that/DT element/NN from/IN (Chunk VARvalues/NNP) ./.)
*2*perform ? FUNCset(VARo, VARpk, VARkvalue, true). 
*2*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) ,/, (Chunk VARkvalue/NNP) ,/, true/JJ )/) ./.)
*2*increase VARk by 1. 
*2*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*1*assert: VARvalues is now an empty list. 
*1*(S assert/NN :/: VARvalues/NNS is/VBZ now/RB an/DT empty/JJ list/NN ./.)
*1*return VARo. 
*1*(S return/NN (Chunk VARo/NNP) ./.)
*0*note: VARobject is not an iterable so assume it is already an array-like object. 
*0*(S note/NN :/: (Chunk VARobject/NNP) is/VBZ not/RB an/DT iterable/JJ so/RB assume/IN it/PRP is/VBZ already/RB an/DT array-like/JJ object/NN ./.)
*0*let VARarraylike be VARobject. 
*0*(S (Chunk let/VB VARarraylike/NNP) (Chunk be/VB VARobject/NNP) ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARarraylike, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARarraylike/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*perform ? FUNCallocatetypedarraybuffer(VARo, VARlen). 
*0*(S perform/NN ?/. (Chunk FUNCallocatetypedarraybuffer/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*let VARk be 0. 
*0*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*0*repeat, while VARk &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*let VARpk be ! FUNCtostring(VARk). 
*1*(S (Chunk let/VB VARpk/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) ./.)
*1*let VARkvalue be ? FUNCget(VARarraylike, VARpk). 
*1*(S (Chunk let/VB VARkvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARarraylike/NNP) ,/, (Chunk VARpk/NNP) )/) ./.)
*1*perform ? FUNCset(VARo, VARpk, VARkvalue, true). 
*1*(S perform/NN ?/. (Chunk FUNCset/NNP) (/( (Chunk VARo/NNP) ,/, (Chunk VARpk/NNP) ,/, (Chunk VARkvalue/NNP) ,/, true/JJ )/) ./.)
*1*increase VARk by 1. 
*1*(S increase/NN (Chunk VARk/NNP) by/IN 1/CD ./.)
*0*return VARo.     
*0*(S return/NN (Chunk VARo/NNP) ./.)
ID= 22.2.4.5
Summary= TypedArray ( buffer [ , byteOffset [ , length ] ] )
*0*assert: FUNCtype(VARbuffer) is object and VARbuffer has an [[ARRAYBUFFERDATA]] internal slot. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARbuffer/NNP) )/) is/VBZ object/JJ and/CC (Chunk VARbuffer/NNP) has/VBZ an/DT [/JJ [/NN (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*if newtarget is undefined, throw a typeerror exception. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARconstructorname be the string value of the constructor name value specified in table 56 for this VARtypedarray constructor. 
*0*(S (Chunk let/VB VARconstructorname/NNP) be/VB the/DT string/VBG value/NN of/IN the/DT constructor/NN name/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN this/DT (Chunk VARtypedarray/NNP) constructor/NN ./.)
*0*let VARo be ? FUNCallocatetypedarray(VARconstructorname, newtarget, "%VARtypedarrayprototype%"). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCallocatetypedarray/NNP) (/( (Chunk VARconstructorname/NNP) ,/, newtarget/NN ,/, ``/`` %/NN VARtypedarrayprototype/JJ %/NN ''/'' )/) ./.)
*0*let VARelementsize be the number value of the element size value in table 56 for VARconstructorname. 
*0*(S (Chunk let/VB VARelementsize/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN value/NN in/IN table/JJ 56/CD for/IN (Chunk VARconstructorname/NNP) ./.)
*0*let VARoffset be ? FUNCtoindex(VARbyteoffset). 
*0*(S (Chunk let/VB VARoffset/NNP) be/VB ?/. (Chunk FUNCtoindex/NNP) (/( (Chunk VARbyteoffset/NNP) )/) ./.)
*0*if VARoffset modulo VARelementsize ≠ 0, throw a rangeerror exception. 
*0*(S if/IN (Chunk VARoffset/NNP) modulo/FW (Chunk VARelementsize/NNP) (Chunk ≠/NNP) 0/CD ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*if VARlength is present and VARlength is not undefined, then
*0*(S if/IN (Chunk VARlength/NNP) is/VBZ present/JJ and/CC (Chunk VARlength/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*1*let VARnewlength be ? FUNCtoindex(VARlength). 
*1*(S (Chunk let/VB VARnewlength/NNP) be/VB ?/. (Chunk FUNCtoindex/NNP) (/( (Chunk VARlength/NNP) )/) ./.)
*0*if FUNCisdetachedbuffer(VARbuffer) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARbuffer/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARbufferbytelength be VARbuffer.[[ARRAYBUFFERBYTELENGTH]]. 
*0*(S (Chunk let/VB VARbufferbytelength/NNP) (Chunk be/VB VARbuffer/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERBYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARlength is either not present or undefined, then
*0*(S if/IN (Chunk VARlength/NNP) is/VBZ either/RB not/RB present/JJ or/CC undefined/JJ ,/, then/RB)
*1*if VARbufferbytelength modulo VARelementsize ≠ 0, throw a rangeerror exception. 
*1*(S if/IN (Chunk VARbufferbytelength/NNP) modulo/FW (Chunk VARelementsize/NNP) (Chunk ≠/NNP) 0/CD ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*1*let VARnewbytelength be VARbufferbytelength - VARoffset. 
*1*(S (Chunk let/VB VARnewbytelength/NNP) (Chunk be/VB VARbufferbytelength/NNP) -/: VARoffset/NN ./.)
*1*if VARnewbytelength &lt; 0, throw a rangeerror exception. 
*1*(S if/IN (Chunk VARnewbytelength/NNP) &/CC lt/NN ;/: 0/CD ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARnewbytelength be VARnewlength × VARelementsize. 
*1*(S (Chunk let/VB VARnewbytelength/NNP) (Chunk be/VB VARnewlength/NNP) (Chunk ×/NNP) (Chunk VARelementsize/NNP) ./.)
*1*if VARoffset+VARnewbytelength &gt; VARbufferbytelength, throw a rangeerror exception. 
*1*(S if/IN (Chunk VARoffset+VARnewbytelength/NNP) &/CC gt/NN ;/: (Chunk VARbufferbytelength/NNP) ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*set VARo.[[VIEWEDARRAYBUFFER]] to VARbuffer. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARbuffer/NNP) ./.)
*0*set VARo.[[BYTELENGTH]] to VARnewbytelength. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk BYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARnewbytelength/NNP) ./.)
*0*set VARo.[[BYTEOFFSET]] to VARoffset. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARoffset/NNP) ./.)
*0*set VARo.[[ARRAYLENGTH]] to VARnewbytelength / VARelementsize. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARnewbytelength/NNP) (Chunk //NNP) (Chunk VARelementsize/NNP) ./.)
*0*return VARo.     
*0*(S return/NN (Chunk VARo/NNP) ./.)
ID= 22.2.4.6
Summary= TypedArrayCreate ( constructor, argumentList )
*0*let VARnewtypedarray be ? FUNCconstruct(VARconstructor, VARargumentlist). 
*0*(S (Chunk let/VB VARnewtypedarray/NNP) be/VB ?/. (Chunk FUNCconstruct/NNP) (/( (Chunk VARconstructor/NNP) ,/, (Chunk VARargumentlist/NNP) )/) ./.)
*0*perform ? FUNCvalidatetypedarray(VARnewtypedarray). 
*0*(S perform/NN ?/. (Chunk FUNCvalidatetypedarray/NNP) (/( (Chunk VARnewtypedarray/NNP) )/) ./.)
*0*if VARargumentlist is a list of a single number, then
*0*(S if/IN (Chunk VARargumentlist/NNP) is/VBZ a/DT list/NN of/IN a/DT single/JJ number/NN ,/, then/RB)
*1*if VARnewtypedarray.[[ARRAYLENGTH]] &lt; VARargumentlist[0], throw a typeerror exception. 
*1*(S if/IN (Chunk VARnewtypedarray/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) &/CC lt/NN ;/: (Chunk VARargumentlist/NNP) [/VBD 0/CD ]/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARnewtypedarray.     
*0*(S return/NN (Chunk VARnewtypedarray/NNP) ./.)
ID= 22.2.4.7
Summary= TypedArraySpeciesCreate ( exemplar, argumentList )
*0*assert: VARexemplar is an object that has a [[TYPEDARRAYNAME]] internal slot. 
*0*(S assert/NN :/: (Chunk VARexemplar/NNP) is/VBZ an/DT object/NN that/WDT has/VBZ a/DT [/JJ [/NN (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*let VARdefaultconstructor be the intrinsic object listed in column one of table 56 for VARexemplar.[[TYPEDARRAYNAME]]. 
*0*(S (Chunk let/VB VARdefaultconstructor/NNP) be/VB the/DT intrinsic/JJ object/NN listed/VBN in/IN column/NN one/CD of/IN table/JJ 56/CD for/IN (Chunk VARexemplar/NNP) ./. [/VB [/JJ (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARconstructor be ? FUNCspeciesconstructor(VARexemplar, VARdefaultconstructor). 
*0*(S (Chunk let/VB VARconstructor/NNP) be/VB ?/. (Chunk FUNCspeciesconstructor/NNP) (/( (Chunk VARexemplar/NNP) ,/, (Chunk VARdefaultconstructor/NNP) )/) ./.)
*0*return ? typedarraycreate(VARconstructor, VARargumentlist).     
*0*(S return/NN ?/. typedarraycreate/NN (/( (Chunk VARconstructor/NNP) ,/, (Chunk VARargumentlist/NNP) )/) ./.)
ID= 23.1.1.1
Summary= Map ( [ iterable ] )
*0*if newtarget is undefined, throw a typeerror exception. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARmap be ? FUNCordinarycreatefromconstructor(newtarget, "%mapprototype%", « [[MAPDATA]] »). 
*0*(S (Chunk let/VB VARmap/NNP) be/VB ?/. (Chunk FUNCordinarycreatefromconstructor/NNP) (/( newtarget/NN ,/, ``/`` %/NN mapprototype/NN %/NN ''/'' ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk MAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARmap.[[MAPDATA]] to a new empty list. 
*0*(S (Chunk set/VBN VARmap/NNP) ./. [/VB [/JJ (Chunk MAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO a/DT new/JJ empty/JJ list/NN ./.)
*0*if VARiterable is not present, let VARiterable be undefined. 
*0*(S if/IN (Chunk VARiterable/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARiterable/NNP) be/VB undefined/VBN ./.)
*0*if VARiterable is either undefined or null, return VARmap. 
*0*(S if/IN (Chunk VARiterable/NNP) is/VBZ either/RB undefined/JJ or/CC null/JJ ,/, (Chunk return/VB VARmap/NNP) ./.)
*0*let VARadder be ? FUNCget(VARmap, "set"). 
*0*(S (Chunk let/VB VARadder/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARmap/NNP) ,/, ``/`` set/VB ''/'' )/) ./.)
*0*if FUNCiscallable(VARadder) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARadder/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARiteratorrecord be ? FUNCgetiterator(VARiterable). 
*0*(S (Chunk let/VB VARiteratorrecord/NNP) be/VB ?/. (Chunk FUNCgetiterator/NNP) (/( (Chunk VARiterable/NNP) )/) ./.)
*0*repeat,
*0*(S repeat/NN ,/,)
*1*let VARnext be ? FUNCiteratorstep(VARiteratorrecord). 
*1*(S (Chunk let/VB VARnext/NNP) be/VB ?/. (Chunk FUNCiteratorstep/NNP) (/( (Chunk VARiteratorrecord/NNP) )/) ./.)
*1*if VARnext is false, return VARmap. 
*1*(S if/IN (Chunk VARnext/NNP) is/VBZ false/JJ ,/, return/JJ (Chunk VARmap/NNP) ./.)
*1*let VARnextitem be ? FUNCiteratorvalue(VARnext). 
*1*(S (Chunk let/VB VARnextitem/NNP) be/VB ?/. (Chunk FUNCiteratorvalue/NNP) (/( (Chunk VARnext/NNP) )/) ./.)
*1*if FUNCtype(VARnextitem) is not object, then
*1*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARnextitem/NNP) )/) is/VBZ not/RB object/JJ ,/, then/RB)
*2*let VARerror be FUNCthrowcompletion(a newly created typeerror object). 
*2*(S (Chunk let/VB VARerror/NNP) (Chunk be/VB FUNCthrowcompletion/NNP) (/( a/DT newly/RB created/VBN typeerror/NN object/NN )/) ./.)
*2*return ? FUNCiteratorclose(VARiteratorrecord, VARerror). 
*2*(S return/NN ?/. (Chunk FUNCiteratorclose/NNP) (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARerror/NNP) )/) ./.)
*1*let VARk be FUNCget(VARnextitem, "0"). 
*1*(S (Chunk let/VB VARk/NNP) (Chunk be/VB FUNCget/NNP) (/( (Chunk VARnextitem/NNP) ,/, ``/`` 0/CD ''/'' )/) ./.)
*1*if VARk is an FUNCabrupt completion, return ? iteratorclose(VARiteratorrecord, VARk). 
*1*(S if/IN (Chunk VARk/NNP) is/VBZ an/DT (Chunk FUNCabrupt/NNP) completion/NN ,/, return/VB ?/. iteratorclose/JJ (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARk/NNP) )/) ./.)
*1*let VARv be FUNCget(VARnextitem, "1"). 
*1*(S (Chunk let/VB VARv/NNP) (Chunk be/VB FUNCget/NNP) (/( (Chunk VARnextitem/NNP) ,/, ``/`` 1/CD ''/'' )/) ./.)
*1*if VARv is an FUNCabrupt completion, return ? iteratorclose(VARiteratorrecord, VARv). 
*1*(S if/IN (Chunk VARv/NNP) is/VBZ an/DT (Chunk FUNCabrupt/NNP) completion/NN ,/, return/VB ?/. iteratorclose/JJ (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARv/NNP) )/) ./.)
*1*let VARstatus be FUNCcall(VARadder, VARmap, « VARk.[[VALUE]], VARv.[[VALUE]] »). 
*1*(S (Chunk let/VB VARstatus/NNP) (Chunk be/VB FUNCcall/NNP) (/( (Chunk VARadder/NNP) ,/, (Chunk VARmap/NNP) ,/, (Chunk «/NNP) (Chunk VARk/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARv/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*1*if VARstatus is an FUNCabrupt completion, return ? iteratorclose(VARiteratorrecord, VARstatus).     
*1*(S if/IN (Chunk VARstatus/NNP) is/VBZ an/DT (Chunk FUNCabrupt/NNP) completion/NN ,/, return/VB ?/. iteratorclose/JJ (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARstatus/NNP) )/) ./.)
ID= 23.1.3.1
Summary= Map.prototype.clear ( )
*0*let VARm be the this value. 
*0*(S (Chunk let/VB VARm/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARm) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARm/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARm does not have a [[MAPDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARm/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk MAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARentries be the list that is VARm.[[MAPDATA]]. 
*0*(S let/VB VARentries/NNS be/VB the/DT list/NN that/WDT (Chunk is/VBZ VARm/NNP) ./. [/VB [/JJ (Chunk MAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*for each record { [[KEY]], [[VALUE]] } VARp that is an element of VARentries, do
*0*(S for/IN each/DT record/NN {/( [/JJ (Chunk [/NNP) (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) }/) (Chunk VARp/NNP) that/WDT is/VBZ an/DT element/NN of/IN VARentries/NNS ,/, do/VBP)
*1*set VARp.[[KEY]] to empty. 
*1*(S (Chunk set/VBN VARp/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO empty/VB ./.)
*1*set VARp.[[VALUE]] to empty. 
*1*(S (Chunk set/VBN VARp/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO empty/VB ./.)
*0*return undefined.     
*0*(S return/NN undefined/VBD ./.)
ID= 23.1.3.3
Summary= Map.prototype.delete ( key )
*0*let VARm be the this value. 
*0*(S (Chunk let/VB VARm/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARm) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARm/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARm does not have a [[MAPDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARm/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk MAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARentries be the list that is VARm.[[MAPDATA]]. 
*0*(S let/VB VARentries/NNS be/VB the/DT list/NN that/WDT (Chunk is/VBZ VARm/NNP) ./. [/VB [/JJ (Chunk MAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*for each record { [[KEY]], [[VALUE]] } VARp that is an element of VARentries, do
*0*(S for/IN each/DT record/NN {/( [/JJ (Chunk [/NNP) (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) }/) (Chunk VARp/NNP) that/WDT is/VBZ an/DT element/NN of/IN VARentries/NNS ,/, do/VBP)
*1*if VARp.[[KEY]] is not empty and FUNCsamevaluezero(VARp.[[KEY]], VARkey) is true, then
*1*(S if/IN (Chunk VARp/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB empty/JJ and/CC (Chunk FUNCsamevaluezero/NNP) (/( (Chunk VARp/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARkey/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*set VARp.[[KEY]] to empty. 
*2*(S (Chunk set/VBN VARp/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO empty/VB ./.)
*2*set VARp.[[VALUE]] to empty. 
*2*(S (Chunk set/VBN VARp/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO empty/VB ./.)
*2*return true. 
*2*(S return/NN true/JJ ./.)
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 23.1.3.4
Summary= Map.prototype.entries ( )
*0*let VARm be the this value. 
*0*(S (Chunk let/VB VARm/NNP) be/VB the/DT this/DT value/NN ./.)
*0*return ? FUNCcreatemapiterator(VARm, "key+value").     
*0*(S return/NN ?/. (Chunk FUNCcreatemapiterator/NNP) (/( (Chunk VARm/NNP) ,/, ``/`` key+value/VB ''/'' )/) ./.)
ID= 23.1.3.5
Summary= Map.prototype.forEach ( callbackfn [ , thisArg ] )
*0*let VARm be the this value. 
*0*(S (Chunk let/VB VARm/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARm) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARm/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARm does not have a [[MAPDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARm/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk MAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARcallbackfn/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*(S if/IN (Chunk VARthisarg/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARt/NNP) (Chunk be/VB VARthisarg/NNP) ;/: else/JJ (Chunk let/VB VARt/NNP) be/VB undefined/VBN ./.)
*0*let VARentries be the list that is VARm.[[MAPDATA]]. 
*0*(S let/VB VARentries/NNS be/VB the/DT list/NN that/WDT (Chunk is/VBZ VARm/NNP) ./. [/VB [/JJ (Chunk MAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*for each record { [[KEY]], [[VALUE]] } VARe that is an element of VARentries, in original key insertion order, do
*0*(S for/IN each/DT record/NN {/( [/JJ (Chunk [/NNP) (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) }/) (Chunk VARe/NNP) that/WDT is/VBZ an/DT element/NN of/IN VARentries/NNS ,/, in/IN original/JJ key/JJ insertion/NN order/NN ,/, do/VBP)
*1*if VARe.[[KEY]] is not empty, then
*1*(S if/IN (Chunk VARe/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB empty/JJ ,/, then/RB)
*2*perform ? FUNCcall(VARcallbackfn, VARt, « VARe.[[VALUE]], VARe.[[KEY]], VARm »). 
*2*(S perform/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARcallbackfn/NNP) ,/, (Chunk VARt/NNP) ,/, (Chunk «/NNP) (Chunk VARe/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARe/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARm/NNP) (Chunk »/NNP) )/) ./.)
*0*return undefined.     
*0*(S return/NN undefined/VBD ./.)
ID= 23.1.3.6
Summary= Map.prototype.get ( key )
*0*let VARm be the this value. 
*0*(S (Chunk let/VB VARm/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARm) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARm/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARm does not have a [[MAPDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARm/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk MAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARentries be the list that is VARm.[[MAPDATA]]. 
*0*(S let/VB VARentries/NNS be/VB the/DT list/NN that/WDT (Chunk is/VBZ VARm/NNP) ./. [/VB [/JJ (Chunk MAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*for each record { [[KEY]], [[VALUE]] } VARp that is an element of VARentries, do
*0*(S for/IN each/DT record/NN {/( [/JJ (Chunk [/NNP) (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) }/) (Chunk VARp/NNP) that/WDT is/VBZ an/DT element/NN of/IN VARentries/NNS ,/, do/VBP)
*1*if VARp.[[KEY]] is not empty and FUNCsamevaluezero(VARp.[[KEY]], VARkey) is true, return VARp.[[VALUE]]. 
*1*(S if/IN (Chunk VARp/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB empty/JJ and/CC (Chunk FUNCsamevaluezero/NNP) (/( (Chunk VARp/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARkey/NNP) )/) is/VBZ true/JJ ,/, (Chunk return/VB VARp/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*return undefined.     
*0*(S return/NN undefined/VBD ./.)
ID= 23.1.3.7
Summary= Map.prototype.has ( key )
*0*let VARm be the this value. 
*0*(S (Chunk let/VB VARm/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARm) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARm/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARm does not have a [[MAPDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARm/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk MAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARentries be the list that is VARm.[[MAPDATA]]. 
*0*(S let/VB VARentries/NNS be/VB the/DT list/NN that/WDT (Chunk is/VBZ VARm/NNP) ./. [/VB [/JJ (Chunk MAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*for each record { [[KEY]], [[VALUE]] } VARp that is an element of VARentries, do
*0*(S for/IN each/DT record/NN {/( [/JJ (Chunk [/NNP) (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) }/) (Chunk VARp/NNP) that/WDT is/VBZ an/DT element/NN of/IN VARentries/NNS ,/, do/VBP)
*1*if VARp.[[KEY]] is not empty and FUNCsamevaluezero(VARp.[[KEY]], VARkey) is true, return true. 
*1*(S if/IN (Chunk VARp/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB empty/JJ and/CC (Chunk FUNCsamevaluezero/NNP) (/( (Chunk VARp/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARkey/NNP) )/) is/VBZ true/JJ ,/, return/VB true/JJ ./.)
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 23.1.3.8
Summary= Map.prototype.keys ( )
*0*let VARm be the this value. 
*0*(S (Chunk let/VB VARm/NNP) be/VB the/DT this/DT value/NN ./.)
*0*return ? FUNCcreatemapiterator(VARm, "key").     
*0*(S return/NN ?/. (Chunk FUNCcreatemapiterator/NNP) (/( (Chunk VARm/NNP) ,/, ``/`` key/JJ ''/'' )/) ./.)
ID= 23.1.3.9
Summary= Map.prototype.set ( key, value )
*0*let VARm be the this value. 
*0*(S (Chunk let/VB VARm/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARm) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARm/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARm does not have a [[MAPDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARm/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk MAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARentries be the list that is VARm.[[MAPDATA]]. 
*0*(S let/VB VARentries/NNS be/VB the/DT list/NN that/WDT (Chunk is/VBZ VARm/NNP) ./. [/VB [/JJ (Chunk MAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*for each record { [[KEY]], [[VALUE]] } VARp that is an element of VARentries, do
*0*(S for/IN each/DT record/NN {/( [/JJ (Chunk [/NNP) (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) }/) (Chunk VARp/NNP) that/WDT is/VBZ an/DT element/NN of/IN VARentries/NNS ,/, do/VBP)
*1*if VARp.[[KEY]] is not empty and FUNCsamevaluezero(VARp.[[KEY]], VARkey) is true, then
*1*(S if/IN (Chunk VARp/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB empty/JJ and/CC (Chunk FUNCsamevaluezero/NNP) (/( (Chunk VARp/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARkey/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*set VARp.[[VALUE]] to VARvalue. 
*2*(S (Chunk set/VBN VARp/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARvalue/NNP) ./.)
*2*return VARm. 
*2*(S return/NN (Chunk VARm/NNP) ./.)
*0*if VARkey is -0, let VARkey be +0. 
*0*(S if/IN (Chunk VARkey/NNP) is/VBZ -0/JJ ,/, (Chunk let/VB VARkey/NNP) be/VB +0/VBN ./.)
*0*let VARp be the record { [[KEY]]: VARkey, [[VALUE]]: VARvalue }. 
*0*(S (Chunk let/VB VARp/NNP) be/VB the/DT record/NN {/( [/JJ (Chunk [/NNP) (Chunk KEY/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARkey/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARvalue/NNP) }/) ./.)
*0*append VARp as the last element of VARentries. 
*0*(S (Chunk append/RB VARp/NNP) as/IN the/DT last/JJ element/NN of/IN VARentries/NNS ./.)
*0*return VARm.     
*0*(S return/NN (Chunk VARm/NNP) ./.)
ID= 23.1.3.11
Summary= Map.prototype.values ( )
*0*let VARm be the this value. 
*0*(S (Chunk let/VB VARm/NNP) be/VB the/DT this/DT value/NN ./.)
*0*return ? FUNCcreatemapiterator(VARm, "value").     
*0*(S return/NN ?/. (Chunk FUNCcreatemapiterator/NNP) (/( (Chunk VARm/NNP) ,/, ``/`` value/NN ''/'' )/) ./.)
ID= 23.1.5.1
Summary= CreateMapIterator ( map, kind )
*0*if FUNCtype(VARmap) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARmap/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARmap does not have a [[MAPDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARmap/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk MAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARiterator be FUNCobjectcreate(%mapiteratorprototype%, « [[MAP]], [[MAPNEXTINDEX]], [[MAPITERATIONKIND]] »). 
*0*(S (Chunk let/VB VARiterator/NNP) (Chunk be/VB FUNCobjectcreate/NNP) (/( %/NN mapiteratorprototype/NN %/NN ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk MAP/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk MAPNEXTINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk MAPITERATIONKIND/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARiterator.[[MAP]] to VARmap. 
*0*(S (Chunk set/VBN VARiterator/NNP) ./. [/VB [/JJ (Chunk MAP/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARmap/NNP) ./.)
*0*set VARiterator.[[MAPNEXTINDEX]] to 0. 
*0*(S (Chunk set/VBN VARiterator/NNP) ./. [/VB [/JJ (Chunk MAPNEXTINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO 0/CD ./.)
*0*set VARiterator.[[MAPITERATIONKIND]] to VARkind. 
*0*(S (Chunk set/VBN VARiterator/NNP) ./. [/VB [/JJ (Chunk MAPITERATIONKIND/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARkind/NNP) ./.)
*0*return VARiterator.     
*0*(S return/NN (Chunk VARiterator/NNP) ./.)
ID= 23.1.5.2.1
Summary= %MapIteratorPrototype%.next ( )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARo does not have all of the internal slots of a map iterator instance (23.1.5.3), throw a typeerror exception. 
*0*(S if/IN (Chunk VARo/NNP) does/VBZ not/RB have/VB all/DT of/IN the/DT internal/JJ slots/NNS of/IN a/DT map/NN iterator/NN instance/NN (/( 23.1.5.3/CD )/) ,/, throw/VBP a/DT typeerror/NN exception/NN ./.)
*0*let VARm be VARo.[[MAP]]. 
*0*(S (Chunk let/VB VARm/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk MAP/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARindex be VARo.[[MAPNEXTINDEX]]. 
*0*(S (Chunk let/VB VARindex/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk MAPNEXTINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARitemkind be VARo.[[MAPITERATIONKIND]]. 
*0*(S (Chunk let/VB VARitemkind/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk MAPITERATIONKIND/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARm is undefined, return FUNCcreateiterresultobject(undefined, true). 
*0*(S if/IN (Chunk VARm/NNP) is/VBZ undefined/JJ ,/, (Chunk return/VB FUNCcreateiterresultobject/NNP) (/( undefined/JJ ,/, true/JJ )/) ./.)
*0*assert: VARm has a [[MAPDATA]] internal slot. 
*0*(S assert/NN :/: (Chunk VARm/NNP) has/VBZ a/DT [/JJ [/NN (Chunk MAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*let VARentries be the list that is VARm.[[MAPDATA]]. 
*0*(S let/VB VARentries/NNS be/VB the/DT list/NN that/WDT (Chunk is/VBZ VARm/NNP) ./. [/VB [/JJ (Chunk MAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARnumentries be the number of elements of VARentries. 
*0*(S let/VB VARnumentries/NNS be/VB the/DT number/NN of/IN elements/NNS of/IN VARentries/NNS ./.)
*0*note: VARnumentries must be redetermined each time this method is evaluated. 
*0*(S note/NN :/: VARnumentries/NNS must/MD be/VB redetermined/VBN each/DT time/NN this/DT method/NN is/VBZ evaluated/VBN ./.)
*0*repeat, while VARindex is less than VARnumentries,
*0*(S repeat/NN ,/, while/IN (Chunk VARindex/NNP) is/VBZ less/JJR than/IN VARnumentries/NNS ,/,)
*1*let VARe be the record { [[KEY]], [[VALUE]] } that is the value of VARentries[VARindex]. 
*1*(S (Chunk let/VB VARe/NNP) be/VB the/DT record/NN {/( [/JJ (Chunk [/NNP) (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) }/) that/WDT is/VBZ the/DT value/NN of/IN (Chunk VARentries/NNP) (Chunk [/NNP) (Chunk VARindex/NNP) (Chunk ]/NNP) ./.)
*1*set VARindex to VARindex+1. 
*1*(S set/VBN VARindex/NN to/TO (Chunk VARindex+1/NNP) ./.)
*1*set VARo.[[MAPNEXTINDEX]] to VARindex. 
*1*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk MAPNEXTINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARindex/NNP) ./.)
*1*if VARe.[[KEY]] is not empty, then
*1*(S if/IN (Chunk VARe/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB empty/JJ ,/, then/RB)
*2*if VARitemkind is "key", let VARresult be VARe.[[KEY]]. 
*2*(S if/IN (Chunk VARitemkind/NNP) is/VBZ ``/`` key/JJ ''/'' ,/, (Chunk let/VB VARresult/NNP) (Chunk be/VB VARe/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*2*else if VARitemkind is "value", let VARresult be VARe.[[VALUE]]. 
*2*(S else/RB if/IN (Chunk VARitemkind/NNP) is/VBZ ``/`` value/NN ''/'' ,/, (Chunk let/VB VARresult/NNP) (Chunk be/VB VARe/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*2*else,
*2*(S else/RB ,/,)
*3*assert: VARitemkind is "key+value". 
*3*(S assert/NN :/: (Chunk VARitemkind/NNP) is/VBZ ``/`` key+value/JJ ''/'' ./.)
*3*let VARresult be FUNCcreatearrayfromlist(« VARe.[[KEY]], VARe.[[VALUE]] »). 
*3*(S (Chunk let/VB VARresult/NNP) (Chunk be/VB FUNCcreatearrayfromlist/NNP) (/( (Chunk «/NNP) (Chunk VARe/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARe/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*2*return FUNCcreateiterresultobject(VARresult, false). 
*2*(S return/NN (Chunk FUNCcreateiterresultobject/NNP) (/( (Chunk VARresult/NNP) ,/, false/RB )/) ./.)
*0*set VARo.[[MAP]] to undefined. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk MAP/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO undefined/VB ./.)
*0*return FUNCcreateiterresultobject(undefined, true).      
*0*(S return/NN (Chunk FUNCcreateiterresultobject/NNP) (/( undefined/JJ ,/, true/JJ )/) ./.)
ID= 23.2.1.1
Summary= Set ( [ iterable ] )
*0*if newtarget is undefined, throw a typeerror exception. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARset be ? FUNCordinarycreatefromconstructor(newtarget, "%setprototype%", « [[SETDATA]] »). 
*0*(S (Chunk let/VB VARset/NNP) be/VB ?/. (Chunk FUNCordinarycreatefromconstructor/NNP) (/( newtarget/NN ,/, ``/`` %/NN setprototype/JJ %/NN ''/'' ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk SETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARset.[[SETDATA]] to a new empty list. 
*0*(S (Chunk set/VBN VARset/NNP) ./. [/VB [/JJ (Chunk SETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO a/DT new/JJ empty/JJ list/NN ./.)
*0*if VARiterable is not present, let VARiterable be undefined. 
*0*(S if/IN (Chunk VARiterable/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARiterable/NNP) be/VB undefined/VBN ./.)
*0*if VARiterable is either undefined or null, return VARset. 
*0*(S if/IN (Chunk VARiterable/NNP) is/VBZ either/RB undefined/JJ or/CC null/JJ ,/, return/JJ (Chunk VARset/NNP) ./.)
*0*let VARadder be ? FUNCget(VARset, "add"). 
*0*(S (Chunk let/VB VARadder/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARset/NNP) ,/, ``/`` add/VB ''/'' )/) ./.)
*0*if FUNCiscallable(VARadder) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARadder/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARiteratorrecord be ? FUNCgetiterator(VARiterable). 
*0*(S (Chunk let/VB VARiteratorrecord/NNP) be/VB ?/. (Chunk FUNCgetiterator/NNP) (/( (Chunk VARiterable/NNP) )/) ./.)
*0*repeat,
*0*(S repeat/NN ,/,)
*1*let VARnext be ? FUNCiteratorstep(VARiteratorrecord). 
*1*(S (Chunk let/VB VARnext/NNP) be/VB ?/. (Chunk FUNCiteratorstep/NNP) (/( (Chunk VARiteratorrecord/NNP) )/) ./.)
*1*if VARnext is false, return VARset. 
*1*(S if/IN (Chunk VARnext/NNP) is/VBZ false/JJ ,/, return/JJ (Chunk VARset/NNP) ./.)
*1*let VARnextvalue be ? FUNCiteratorvalue(VARnext). 
*1*(S (Chunk let/VB VARnextvalue/NNP) be/VB ?/. (Chunk FUNCiteratorvalue/NNP) (/( (Chunk VARnext/NNP) )/) ./.)
*1*let VARstatus be FUNCcall(VARadder, VARset, « VARnextvalue.[[VALUE]] »). 
*1*(S (Chunk let/VB VARstatus/NNP) (Chunk be/VB FUNCcall/NNP) (/( (Chunk VARadder/NNP) ,/, (Chunk VARset/NNP) ,/, (Chunk «/NNP) (Chunk VARnextvalue/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*1*if VARstatus is an FUNCabrupt completion, return ? iteratorclose(VARiteratorrecord, VARstatus).     
*1*(S if/IN (Chunk VARstatus/NNP) is/VBZ an/DT (Chunk FUNCabrupt/NNP) completion/NN ,/, return/VB ?/. iteratorclose/JJ (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARstatus/NNP) )/) ./.)
ID= 23.2.3.1
Summary= Set.prototype.add ( value )
*0*let VARs be the this value. 
*0*(S (Chunk let/VB VARs/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARs) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARs/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARs does not have a [[SETDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARs/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk SETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARentries be the list that is VARs.[[SETDATA]]. 
*0*(S let/VB VARentries/NNS be/VB the/DT list/NN that/WDT (Chunk is/VBZ VARs/NNP) ./. [/VB [/JJ (Chunk SETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*for each VARe that is an element of VARentries, do
*0*(S for/IN each/DT (Chunk VARe/NNP) that/WDT is/VBZ an/DT element/NN of/IN VARentries/NNS ,/, do/VBP)
*1*if VARe is not empty and FUNCsamevaluezero(VARe, VARvalue) is true, then
*1*(S if/IN (Chunk VARe/NNP) is/VBZ not/RB empty/JJ and/CC (Chunk FUNCsamevaluezero/NNP) (/( (Chunk VARe/NNP) ,/, (Chunk VARvalue/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*return VARs. 
*2*(S return/NN (Chunk VARs/NNP) ./.)
*0*if VARvalue is -0, let VARvalue be +0. 
*0*(S if/IN (Chunk VARvalue/NNP) is/VBZ -0/JJ ,/, (Chunk let/VB VARvalue/NNP) be/VB +0/VBN ./.)
*0*append VARvalue as the last element of VARentries. 
*0*(S (Chunk append/RB VARvalue/NNP) as/IN the/DT last/JJ element/NN of/IN VARentries/NNS ./.)
*0*return VARs.     
*0*(S return/NN (Chunk VARs/NNP) ./.)
ID= 23.2.3.2
Summary= Set.prototype.clear ( )
*0*let VARs be the this value. 
*0*(S (Chunk let/VB VARs/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARs) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARs/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARs does not have a [[SETDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARs/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk SETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARentries be the list that is VARs.[[SETDATA]]. 
*0*(S let/VB VARentries/NNS be/VB the/DT list/NN that/WDT (Chunk is/VBZ VARs/NNP) ./. [/VB [/JJ (Chunk SETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*for each VARe that is an element of VARentries, do
*0*(S for/IN each/DT (Chunk VARe/NNP) that/WDT is/VBZ an/DT element/NN of/IN VARentries/NNS ,/, do/VBP)
*1*replace the element of VARentries whose value is VARe with an element whose value is empty. 
*1*(S replace/VB the/DT element/NN of/IN VARentries/NNS whose/WP$ value/NN (Chunk is/VBZ VARe/NNP) with/IN an/DT element/NN whose/WP$ value/NN is/VBZ empty/JJ ./.)
*0*return undefined.     
*0*(S return/NN undefined/VBD ./.)
ID= 23.2.3.4
Summary= Set.prototype.delete ( value )
*0*let VARs be the this value. 
*0*(S (Chunk let/VB VARs/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARs) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARs/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARs does not have a [[SETDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARs/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk SETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARentries be the list that is VARs.[[SETDATA]]. 
*0*(S let/VB VARentries/NNS be/VB the/DT list/NN that/WDT (Chunk is/VBZ VARs/NNP) ./. [/VB [/JJ (Chunk SETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*for each VARe that is an element of VARentries, do
*0*(S for/IN each/DT (Chunk VARe/NNP) that/WDT is/VBZ an/DT element/NN of/IN VARentries/NNS ,/, do/VBP)
*1*if VARe is not empty and FUNCsamevaluezero(VARe, VARvalue) is true, then
*1*(S if/IN (Chunk VARe/NNP) is/VBZ not/RB empty/JJ and/CC (Chunk FUNCsamevaluezero/NNP) (/( (Chunk VARe/NNP) ,/, (Chunk VARvalue/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*replace the element of VARentries whose value is VARe with an element whose value is empty. 
*2*(S replace/VB the/DT element/NN of/IN VARentries/NNS whose/WP$ value/NN (Chunk is/VBZ VARe/NNP) with/IN an/DT element/NN whose/WP$ value/NN is/VBZ empty/JJ ./.)
*2*return true. 
*2*(S return/NN true/JJ ./.)
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 23.2.3.5
Summary= Set.prototype.entries ( )
*0*let VARs be the this value. 
*0*(S (Chunk let/VB VARs/NNP) be/VB the/DT this/DT value/NN ./.)
*0*return ? FUNCcreatesetiterator(VARs, "key+value").     
*0*(S return/NN ?/. (Chunk FUNCcreatesetiterator/NNP) (/( (Chunk VARs/NNP) ,/, ``/`` key+value/VB ''/'' )/) ./.)
ID= 23.2.3.6
Summary= Set.prototype.forEach ( callbackfn [ , thisArg ] )
*0*let VARs be the this value. 
*0*(S (Chunk let/VB VARs/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARs) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARs/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARs does not have a [[SETDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARs/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk SETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARcallbackfn/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*(S if/IN (Chunk VARthisarg/NNP) is/VBZ present/JJ ,/, (Chunk let/VB VARt/NNP) (Chunk be/VB VARthisarg/NNP) ;/: else/JJ (Chunk let/VB VARt/NNP) be/VB undefined/VBN ./.)
*0*let VARentries be the list that is VARs.[[SETDATA]]. 
*0*(S let/VB VARentries/NNS be/VB the/DT list/NN that/WDT (Chunk is/VBZ VARs/NNP) ./. [/VB [/JJ (Chunk SETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*for each VARe that is an element of VARentries, in original insertion order, do
*0*(S for/IN each/DT (Chunk VARe/NNP) that/WDT is/VBZ an/DT element/NN of/IN VARentries/NNS ,/, in/IN original/JJ insertion/NN order/NN ,/, do/VBP)
*1*if VARe is not empty, then
*1*(S if/IN (Chunk VARe/NNP) is/VBZ not/RB empty/JJ ,/, then/RB)
*2*perform ? FUNCcall(VARcallbackfn, VARt, « VARe, VARe, VARs »). 
*2*(S perform/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARcallbackfn/NNP) ,/, (Chunk VARt/NNP) ,/, (Chunk «/NNP) (Chunk VARe/NNP) ,/, (Chunk VARe/NNP) ,/, (Chunk VARs/NNP) (Chunk »/NNP) )/) ./.)
*0*return undefined.     
*0*(S return/NN undefined/VBD ./.)
ID= 23.2.3.7
Summary= Set.prototype.has ( value )
*0*let VARs be the this value. 
*0*(S (Chunk let/VB VARs/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARs) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARs/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARs does not have a [[SETDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARs/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk SETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARentries be the list that is VARs.[[SETDATA]]. 
*0*(S let/VB VARentries/NNS be/VB the/DT list/NN that/WDT (Chunk is/VBZ VARs/NNP) ./. [/VB [/JJ (Chunk SETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*for each VARe that is an element of VARentries, do
*0*(S for/IN each/DT (Chunk VARe/NNP) that/WDT is/VBZ an/DT element/NN of/IN VARentries/NNS ,/, do/VBP)
*1*if VARe is not empty and FUNCsamevaluezero(VARe, VARvalue) is true, return true. 
*1*(S if/IN (Chunk VARe/NNP) is/VBZ not/RB empty/JJ and/CC (Chunk FUNCsamevaluezero/NNP) (/( (Chunk VARe/NNP) ,/, (Chunk VARvalue/NNP) )/) is/VBZ true/JJ ,/, return/VB true/JJ ./.)
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 23.2.3.10
Summary= Set.prototype.values ( )
*0*let VARs be the this value. 
*0*(S (Chunk let/VB VARs/NNP) be/VB the/DT this/DT value/NN ./.)
*0*return ? FUNCcreatesetiterator(VARs, "value").     
*0*(S return/NN ?/. (Chunk FUNCcreatesetiterator/NNP) (/( (Chunk VARs/NNP) ,/, ``/`` value/NN ''/'' )/) ./.)
ID= 23.2.5.1
Summary= CreateSetIterator ( set, kind )
*0*if FUNCtype(VARset) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARset/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARset does not have a [[SETDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARset/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk SETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARiterator be FUNCobjectcreate(%setiteratorprototype%, « [[ITERATEDSET]], [[SETNEXTINDEX]], [[SETITERATIONKIND]] »). 
*0*(S (Chunk let/VB VARiterator/NNP) (Chunk be/VB FUNCobjectcreate/NNP) (/( %/NN setiteratorprototype/NN %/NN ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk ITERATEDSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk SETNEXTINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk SETITERATIONKIND/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARiterator.[[ITERATEDSET]] to VARset. 
*0*(S (Chunk set/VBN VARiterator/NNP) ./. [/VB [/JJ (Chunk ITERATEDSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARset/NNP) ./.)
*0*set VARiterator.[[SETNEXTINDEX]] to 0. 
*0*(S (Chunk set/VBN VARiterator/NNP) ./. [/VB [/JJ (Chunk SETNEXTINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO 0/CD ./.)
*0*set VARiterator.[[SETITERATIONKIND]] to VARkind. 
*0*(S (Chunk set/VBN VARiterator/NNP) ./. [/VB [/JJ (Chunk SETITERATIONKIND/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARkind/NNP) ./.)
*0*return VARiterator.     
*0*(S return/NN (Chunk VARiterator/NNP) ./.)
ID= 23.2.5.2.1
Summary= %SetIteratorPrototype%.next ( )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARo does not have all of the internal slots of a set iterator instance (23.2.5.3), throw a typeerror exception. 
*0*(S if/IN (Chunk VARo/NNP) does/VBZ not/RB have/VB all/DT of/IN the/DT internal/JJ slots/NNS of/IN a/DT set/NN iterator/NN instance/NN (/( 23.2.5.3/CD )/) ,/, throw/VBP a/DT typeerror/NN exception/NN ./.)
*0*let VARs be VARo.[[ITERATEDSET]]. 
*0*(S (Chunk let/VB VARs/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk ITERATEDSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARindex be VARo.[[SETNEXTINDEX]]. 
*0*(S (Chunk let/VB VARindex/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk SETNEXTINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARitemkind be VARo.[[SETITERATIONKIND]]. 
*0*(S (Chunk let/VB VARitemkind/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk SETITERATIONKIND/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARs is undefined, return FUNCcreateiterresultobject(undefined, true). 
*0*(S if/IN (Chunk VARs/NNP) is/VBZ undefined/JJ ,/, (Chunk return/VB FUNCcreateiterresultobject/NNP) (/( undefined/JJ ,/, true/JJ )/) ./.)
*0*assert: VARs has a [[SETDATA]] internal slot. 
*0*(S assert/NN :/: (Chunk VARs/NNP) has/VBZ a/DT [/JJ [/NN (Chunk SETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*let VARentries be the list that is VARs.[[SETDATA]]. 
*0*(S let/VB VARentries/NNS be/VB the/DT list/NN that/WDT (Chunk is/VBZ VARs/NNP) ./. [/VB [/JJ (Chunk SETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARnumentries be the number of elements of VARentries. 
*0*(S let/VB VARnumentries/NNS be/VB the/DT number/NN of/IN elements/NNS of/IN VARentries/NNS ./.)
*0*note: VARnumentries must be redetermined each time this method is evaluated. 
*0*(S note/NN :/: VARnumentries/NNS must/MD be/VB redetermined/VBN each/DT time/NN this/DT method/NN is/VBZ evaluated/VBN ./.)
*0*repeat, while VARindex is less than VARnumentries,
*0*(S repeat/NN ,/, while/IN (Chunk VARindex/NNP) is/VBZ less/JJR than/IN VARnumentries/NNS ,/,)
*1*let VARe be VARentries[VARindex]. 
*1*(S (Chunk let/VB VARe/NNP) (Chunk be/VB VARentries/NNP) (Chunk [/NNP) (Chunk VARindex/NNP) (Chunk ]/NNP) ./.)
*1*set VARindex to VARindex+1. 
*1*(S set/VBN VARindex/NN to/TO (Chunk VARindex+1/NNP) ./.)
*1*set VARo.[[SETNEXTINDEX]] to VARindex. 
*1*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk SETNEXTINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARindex/NNP) ./.)
*1*if VARe is not empty, then
*1*(S if/IN (Chunk VARe/NNP) is/VBZ not/RB empty/JJ ,/, then/RB)
*2*if VARitemkind is "key+value", then
*2*(S if/IN (Chunk VARitemkind/NNP) is/VBZ ``/`` key+value/JJ ''/'' ,/, then/RB)
*3*return FUNCcreateiterresultobject(FUNCcreatearrayfromlist(« VARe, VARe »), false). 
*3*(S return/NN (Chunk FUNCcreateiterresultobject/NNP) (/( (Chunk FUNCcreatearrayfromlist/NNP) (/( (Chunk «/NNP) (Chunk VARe/NNP) ,/, (Chunk VARe/NNP) (Chunk »/NNP) )/) ,/, false/JJ )/) ./.)
*2*return FUNCcreateiterresultobject(VARe, false). 
*2*(S return/NN (Chunk FUNCcreateiterresultobject/NNP) (/( (Chunk VARe/NNP) ,/, false/RB )/) ./.)
*0*set VARo.[[ITERATEDSET]] to undefined. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk ITERATEDSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO undefined/VB ./.)
*0*return FUNCcreateiterresultobject(undefined, true).      
*0*(S return/NN (Chunk FUNCcreateiterresultobject/NNP) (/( undefined/JJ ,/, true/JJ )/) ./.)
ID= 23.3.1.1
Summary= WeakMap ( [ iterable ] )
*0*if newtarget is undefined, throw a typeerror exception. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARmap be ? FUNCordinarycreatefromconstructor(newtarget, "%weakmapprototype%", « [[WEAKMAPDATA]] »). 
*0*(S (Chunk let/VB VARmap/NNP) be/VB ?/. (Chunk FUNCordinarycreatefromconstructor/NNP) (/( newtarget/NN ,/, ``/`` %/NN weakmapprototype/NN %/NN ''/'' ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk WEAKMAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARmap.[[WEAKMAPDATA]] to a new empty list. 
*0*(S (Chunk set/VBN VARmap/NNP) ./. [/VB [/JJ (Chunk WEAKMAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO a/DT new/JJ empty/JJ list/NN ./.)
*0*if VARiterable is not present, let VARiterable be undefined. 
*0*(S if/IN (Chunk VARiterable/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARiterable/NNP) be/VB undefined/VBN ./.)
*0*if VARiterable is either undefined or null, return VARmap. 
*0*(S if/IN (Chunk VARiterable/NNP) is/VBZ either/RB undefined/JJ or/CC null/JJ ,/, (Chunk return/VB VARmap/NNP) ./.)
*0*let VARadder be ? FUNCget(VARmap, "set"). 
*0*(S (Chunk let/VB VARadder/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARmap/NNP) ,/, ``/`` set/VB ''/'' )/) ./.)
*0*if FUNCiscallable(VARadder) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARadder/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARiteratorrecord be ? FUNCgetiterator(VARiterable). 
*0*(S (Chunk let/VB VARiteratorrecord/NNP) be/VB ?/. (Chunk FUNCgetiterator/NNP) (/( (Chunk VARiterable/NNP) )/) ./.)
*0*repeat,
*0*(S repeat/NN ,/,)
*1*let VARnext be ? FUNCiteratorstep(VARiterrecord). 
*1*(S (Chunk let/VB VARnext/NNP) be/VB ?/. (Chunk FUNCiteratorstep/NNP) (/( (Chunk VARiterrecord/NNP) )/) ./.)
*1*if VARnext is false, return VARmap. 
*1*(S if/IN (Chunk VARnext/NNP) is/VBZ false/JJ ,/, return/JJ (Chunk VARmap/NNP) ./.)
*1*let VARnextitem be ? FUNCiteratorvalue(VARnext). 
*1*(S (Chunk let/VB VARnextitem/NNP) be/VB ?/. (Chunk FUNCiteratorvalue/NNP) (/( (Chunk VARnext/NNP) )/) ./.)
*1*if FUNCtype(VARnextitem) is not object, then
*1*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARnextitem/NNP) )/) is/VBZ not/RB object/JJ ,/, then/RB)
*2*let VARerror be FUNCthrowcompletion(a newly created typeerror object). 
*2*(S (Chunk let/VB VARerror/NNP) (Chunk be/VB FUNCthrowcompletion/NNP) (/( a/DT newly/RB created/VBN typeerror/NN object/NN )/) ./.)
*2*return ? FUNCiteratorclose(VARiteratorrecord, VARerror). 
*2*(S return/NN ?/. (Chunk FUNCiteratorclose/NNP) (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARerror/NNP) )/) ./.)
*1*let VARk be FUNCget(VARnextitem, "0"). 
*1*(S (Chunk let/VB VARk/NNP) (Chunk be/VB FUNCget/NNP) (/( (Chunk VARnextitem/NNP) ,/, ``/`` 0/CD ''/'' )/) ./.)
*1*if VARk is an FUNCabrupt completion, return ? iteratorclose(VARiteratorrecord, VARk). 
*1*(S if/IN (Chunk VARk/NNP) is/VBZ an/DT (Chunk FUNCabrupt/NNP) completion/NN ,/, return/VB ?/. iteratorclose/JJ (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARk/NNP) )/) ./.)
*1*let VARv be FUNCget(VARnextitem, "1"). 
*1*(S (Chunk let/VB VARv/NNP) (Chunk be/VB FUNCget/NNP) (/( (Chunk VARnextitem/NNP) ,/, ``/`` 1/CD ''/'' )/) ./.)
*1*if VARv is an FUNCabrupt completion, return ? iteratorclose(VARiteratorrecord, VARv). 
*1*(S if/IN (Chunk VARv/NNP) is/VBZ an/DT (Chunk FUNCabrupt/NNP) completion/NN ,/, return/VB ?/. iteratorclose/JJ (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARv/NNP) )/) ./.)
*1*let VARstatus be FUNCcall(VARadder, VARmap, « VARk.[[VALUE]], VARv.[[VALUE]] »). 
*1*(S (Chunk let/VB VARstatus/NNP) (Chunk be/VB FUNCcall/NNP) (/( (Chunk VARadder/NNP) ,/, (Chunk VARmap/NNP) ,/, (Chunk «/NNP) (Chunk VARk/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARv/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*1*if VARstatus is an FUNCabrupt completion, return ? iteratorclose(VARiteratorrecord, VARstatus).     
*1*(S if/IN (Chunk VARstatus/NNP) is/VBZ an/DT (Chunk FUNCabrupt/NNP) completion/NN ,/, return/VB ?/. iteratorclose/JJ (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARstatus/NNP) )/) ./.)
ID= 23.3.3.2
Summary= WeakMap.prototype.delete ( key )
*0*let VARm be the this value. 
*0*(S (Chunk let/VB VARm/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARm) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARm/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARm does not have a [[WEAKMAPDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARm/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk WEAKMAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARentries be the list that is VARm.[[WEAKMAPDATA]]. 
*0*(S let/VB VARentries/NNS be/VB the/DT list/NN that/WDT (Chunk is/VBZ VARm/NNP) ./. [/VB [/JJ (Chunk WEAKMAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if FUNCtype(VARkey) is not object, return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARkey/NNP) )/) is/VBZ not/RB object/JJ ,/, return/NN false/JJ ./.)
*0*for each record { [[KEY]], [[VALUE]] } VARp that is an element of VARentries, do
*0*(S for/IN each/DT record/NN {/( [/JJ (Chunk [/NNP) (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) }/) (Chunk VARp/NNP) that/WDT is/VBZ an/DT element/NN of/IN VARentries/NNS ,/, do/VBP)
*1*if VARp.[[KEY]] is not empty and FUNCsamevalue(VARp.[[KEY]], VARkey) is true, then
*1*(S if/IN (Chunk VARp/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB empty/JJ and/CC (Chunk FUNCsamevalue/NNP) (/( (Chunk VARp/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARkey/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*set VARp.[[KEY]] to empty. 
*2*(S (Chunk set/VBN VARp/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO empty/VB ./.)
*2*set VARp.[[VALUE]] to empty. 
*2*(S (Chunk set/VBN VARp/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO empty/VB ./.)
*2*return true. 
*2*(S return/NN true/JJ ./.)
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 23.3.3.3
Summary= WeakMap.prototype.get ( key )
*0*let VARm be the this value. 
*0*(S (Chunk let/VB VARm/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARm) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARm/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARm does not have a [[WEAKMAPDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARm/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk WEAKMAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARentries be the list that is VARm.[[WEAKMAPDATA]]. 
*0*(S let/VB VARentries/NNS be/VB the/DT list/NN that/WDT (Chunk is/VBZ VARm/NNP) ./. [/VB [/JJ (Chunk WEAKMAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if FUNCtype(VARkey) is not object, return undefined. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARkey/NNP) )/) is/VBZ not/RB object/JJ ,/, return/NN undefined/VBD ./.)
*0*for each record { [[KEY]], [[VALUE]] } VARp that is an element of VARentries, do
*0*(S for/IN each/DT record/NN {/( [/JJ (Chunk [/NNP) (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) }/) (Chunk VARp/NNP) that/WDT is/VBZ an/DT element/NN of/IN VARentries/NNS ,/, do/VBP)
*1*if VARp.[[KEY]] is not empty and FUNCsamevalue(VARp.[[KEY]], VARkey) is true, return VARp.[[VALUE]]. 
*1*(S if/IN (Chunk VARp/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB empty/JJ and/CC (Chunk FUNCsamevalue/NNP) (/( (Chunk VARp/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARkey/NNP) )/) is/VBZ true/JJ ,/, (Chunk return/VB VARp/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*return undefined.     
*0*(S return/NN undefined/VBD ./.)
ID= 23.3.3.4
Summary= WeakMap.prototype.has ( key )
*0*let VARm be the this value. 
*0*(S (Chunk let/VB VARm/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARm) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARm/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARm does not have a [[WEAKMAPDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARm/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk WEAKMAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARentries be the list that is VARm.[[WEAKMAPDATA]]. 
*0*(S let/VB VARentries/NNS be/VB the/DT list/NN that/WDT (Chunk is/VBZ VARm/NNP) ./. [/VB [/JJ (Chunk WEAKMAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if FUNCtype(VARkey) is not object, return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARkey/NNP) )/) is/VBZ not/RB object/JJ ,/, return/NN false/JJ ./.)
*0*for each record { [[KEY]], [[VALUE]] } VARp that is an element of VARentries, do
*0*(S for/IN each/DT record/NN {/( [/JJ (Chunk [/NNP) (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) }/) (Chunk VARp/NNP) that/WDT is/VBZ an/DT element/NN of/IN VARentries/NNS ,/, do/VBP)
*1*if VARp.[[KEY]] is not empty and FUNCsamevalue(VARp.[[KEY]], VARkey) is true, return true. 
*1*(S if/IN (Chunk VARp/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB empty/JJ and/CC (Chunk FUNCsamevalue/NNP) (/( (Chunk VARp/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARkey/NNP) )/) is/VBZ true/JJ ,/, return/VB true/JJ ./.)
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 23.3.3.5
Summary= WeakMap.prototype.set ( key, value )
*0*let VARm be the this value. 
*0*(S (Chunk let/VB VARm/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARm) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARm/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARm does not have a [[WEAKMAPDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARm/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk WEAKMAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARentries be the list that is VARm.[[WEAKMAPDATA]]. 
*0*(S let/VB VARentries/NNS be/VB the/DT list/NN that/WDT (Chunk is/VBZ VARm/NNP) ./. [/VB [/JJ (Chunk WEAKMAPDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if FUNCtype(VARkey) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARkey/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*for each record { [[KEY]], [[VALUE]] } VARp that is an element of VARentries, do
*0*(S for/IN each/DT record/NN {/( [/JJ (Chunk [/NNP) (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) }/) (Chunk VARp/NNP) that/WDT is/VBZ an/DT element/NN of/IN VARentries/NNS ,/, do/VBP)
*1*if VARp.[[KEY]] is not empty and FUNCsamevalue(VARp.[[KEY]], VARkey) is true, then
*1*(S if/IN (Chunk VARp/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB empty/JJ and/CC (Chunk FUNCsamevalue/NNP) (/( (Chunk VARp/NNP) ./. [/VB [/JJ (Chunk KEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARkey/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*set VARp.[[VALUE]] to VARvalue. 
*2*(S (Chunk set/VBN VARp/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARvalue/NNP) ./.)
*2*return VARm. 
*2*(S return/NN (Chunk VARm/NNP) ./.)
*0*let VARp be the record { [[KEY]]: VARkey, [[VALUE]]: VARvalue }. 
*0*(S (Chunk let/VB VARp/NNP) be/VB the/DT record/NN {/( [/JJ (Chunk [/NNP) (Chunk KEY/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARkey/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARvalue/NNP) }/) ./.)
*0*append VARp as the last element of VARentries. 
*0*(S (Chunk append/RB VARp/NNP) as/IN the/DT last/JJ element/NN of/IN VARentries/NNS ./.)
*0*return VARm.     
*0*(S return/NN (Chunk VARm/NNP) ./.)
ID= 23.4.1.1
Summary= WeakSet ( [ iterable ] )
*0*if newtarget is undefined, throw a typeerror exception. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARset be ? FUNCordinarycreatefromconstructor(newtarget, "%weaksetprototype%", « [[WEAKSETDATA]] »). 
*0*(S (Chunk let/VB VARset/NNP) be/VB ?/. (Chunk FUNCordinarycreatefromconstructor/NNP) (/( newtarget/NN ,/, ``/`` %/NN weaksetprototype/NN %/NN ''/'' ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk WEAKSETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARset.[[WEAKSETDATA]] to a new empty list. 
*0*(S (Chunk set/VBN VARset/NNP) ./. [/VB [/JJ (Chunk WEAKSETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO a/DT new/JJ empty/JJ list/NN ./.)
*0*if VARiterable is not present, let VARiterable be undefined. 
*0*(S if/IN (Chunk VARiterable/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARiterable/NNP) be/VB undefined/VBN ./.)
*0*if VARiterable is either undefined or null, return VARset. 
*0*(S if/IN (Chunk VARiterable/NNP) is/VBZ either/RB undefined/JJ or/CC null/JJ ,/, return/JJ (Chunk VARset/NNP) ./.)
*0*let VARadder be ? FUNCget(VARset, "add"). 
*0*(S (Chunk let/VB VARadder/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARset/NNP) ,/, ``/`` add/VB ''/'' )/) ./.)
*0*if FUNCiscallable(VARadder) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARadder/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARiteratorrecord be ? FUNCgetiterator(VARiterable). 
*0*(S (Chunk let/VB VARiteratorrecord/NNP) be/VB ?/. (Chunk FUNCgetiterator/NNP) (/( (Chunk VARiterable/NNP) )/) ./.)
*0*repeat,
*0*(S repeat/NN ,/,)
*1*let VARnext be ? FUNCiteratorstep(VARiteratorrecord). 
*1*(S (Chunk let/VB VARnext/NNP) be/VB ?/. (Chunk FUNCiteratorstep/NNP) (/( (Chunk VARiteratorrecord/NNP) )/) ./.)
*1*if VARnext is false, return VARset. 
*1*(S if/IN (Chunk VARnext/NNP) is/VBZ false/JJ ,/, return/JJ (Chunk VARset/NNP) ./.)
*1*let VARnextvalue be ? FUNCiteratorvalue(VARnext). 
*1*(S (Chunk let/VB VARnextvalue/NNP) be/VB ?/. (Chunk FUNCiteratorvalue/NNP) (/( (Chunk VARnext/NNP) )/) ./.)
*1*let VARstatus be FUNCcall(VARadder, VARset, « VARnextvalue »). 
*1*(S (Chunk let/VB VARstatus/NNP) (Chunk be/VB FUNCcall/NNP) (/( (Chunk VARadder/NNP) ,/, (Chunk VARset/NNP) ,/, (Chunk «/NNP) (Chunk VARnextvalue/NNP) (Chunk »/NNP) )/) ./.)
*1*if VARstatus is an FUNCabrupt completion, return ? iteratorclose(VARiteratorrecord, VARstatus).     
*1*(S if/IN (Chunk VARstatus/NNP) is/VBZ an/DT (Chunk FUNCabrupt/NNP) completion/NN ,/, return/VB ?/. iteratorclose/JJ (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARstatus/NNP) )/) ./.)
ID= 23.4.3.1
Summary= WeakSet.prototype.add ( value )
*0*let VARs be the this value. 
*0*(S (Chunk let/VB VARs/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARs) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARs/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARs does not have a [[WEAKSETDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARs/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk WEAKSETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if FUNCtype(VARvalue) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARvalue/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARentries be the list that is VARs.[[WEAKSETDATA]]. 
*0*(S let/VB VARentries/NNS be/VB the/DT list/NN that/WDT (Chunk is/VBZ VARs/NNP) ./. [/VB [/JJ (Chunk WEAKSETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*for each VARe that is an element of VARentries, do
*0*(S for/IN each/DT (Chunk VARe/NNP) that/WDT is/VBZ an/DT element/NN of/IN VARentries/NNS ,/, do/VBP)
*1*if VARe is not empty and FUNCsamevalue(VARe, VARvalue) is true, then
*1*(S if/IN (Chunk VARe/NNP) is/VBZ not/RB empty/JJ and/CC (Chunk FUNCsamevalue/NNP) (/( (Chunk VARe/NNP) ,/, (Chunk VARvalue/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*return VARs. 
*2*(S return/NN (Chunk VARs/NNP) ./.)
*0*append VARvalue as the last element of VARentries. 
*0*(S (Chunk append/RB VARvalue/NNP) as/IN the/DT last/JJ element/NN of/IN VARentries/NNS ./.)
*0*return VARs.     
*0*(S return/NN (Chunk VARs/NNP) ./.)
ID= 23.4.3.3
Summary= WeakSet.prototype.delete ( value )
*0*let VARs be the this value. 
*0*(S (Chunk let/VB VARs/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARs) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARs/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARs does not have a [[WEAKSETDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARs/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk WEAKSETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if FUNCtype(VARvalue) is not object, return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARvalue/NNP) )/) is/VBZ not/RB object/JJ ,/, return/NN false/JJ ./.)
*0*let VARentries be the list that is VARs.[[WEAKSETDATA]]. 
*0*(S let/VB VARentries/NNS be/VB the/DT list/NN that/WDT (Chunk is/VBZ VARs/NNP) ./. [/VB [/JJ (Chunk WEAKSETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*for each VARe that is an element of VARentries, do
*0*(S for/IN each/DT (Chunk VARe/NNP) that/WDT is/VBZ an/DT element/NN of/IN VARentries/NNS ,/, do/VBP)
*1*if VARe is not empty and FUNCsamevalue(VARe, VARvalue) is true, then
*1*(S if/IN (Chunk VARe/NNP) is/VBZ not/RB empty/JJ and/CC (Chunk FUNCsamevalue/NNP) (/( (Chunk VARe/NNP) ,/, (Chunk VARvalue/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*replace the element of VARentries whose value is VARe with an element whose value is empty. 
*2*(S replace/VB the/DT element/NN of/IN VARentries/NNS whose/WP$ value/NN (Chunk is/VBZ VARe/NNP) with/IN an/DT element/NN whose/WP$ value/NN is/VBZ empty/JJ ./.)
*2*return true. 
*2*(S return/NN true/JJ ./.)
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 23.4.3.4
Summary= WeakSet.prototype.has ( value )
*0*let VARs be the this value. 
*0*(S (Chunk let/VB VARs/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARs) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARs/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARs does not have a [[WEAKSETDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARs/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk WEAKSETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARentries be the list that is VARs.[[WEAKSETDATA]]. 
*0*(S let/VB VARentries/NNS be/VB the/DT list/NN that/WDT (Chunk is/VBZ VARs/NNP) ./. [/VB [/JJ (Chunk WEAKSETDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if FUNCtype(VARvalue) is not object, return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARvalue/NNP) )/) is/VBZ not/RB object/JJ ,/, return/NN false/JJ ./.)
*0*for each VARe that is an element of VARentries, do
*0*(S for/IN each/DT (Chunk VARe/NNP) that/WDT is/VBZ an/DT element/NN of/IN VARentries/NNS ,/, do/VBP)
*1*if VARe is not empty and FUNCsamevalue(VARe, VARvalue) is true, return true. 
*1*(S if/IN (Chunk VARe/NNP) is/VBZ not/RB empty/JJ and/CC (Chunk FUNCsamevalue/NNP) (/( (Chunk VARe/NNP) ,/, (Chunk VARvalue/NNP) )/) is/VBZ true/JJ ,/, return/VB true/JJ ./.)
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 24.1.1.1
Summary= AllocateArrayBuffer ( constructor, byteLength )
*0*let VARobj be ? FUNCordinarycreatefromconstructor(VARconstructor, "%arraybufferprototype%", « [[ARRAYBUFFERDATA]], [[ARRAYBUFFERBYTELENGTH]], [[ARRAYBUFFERDETACHKEY]] »). 
*0*(S (Chunk let/VB VARobj/NNP) be/VB ?/. (Chunk FUNCordinarycreatefromconstructor/NNP) (/( (Chunk VARconstructor/NNP) ,/, ``/`` %/NN arraybufferprototype/JJ %/NN ''/'' ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ARRAYBUFFERBYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ARRAYBUFFERDETACHKEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*assert: VARbytelength is an integer value ≥ 0. 
*0*(S assert/NN :/: (Chunk VARbytelength/NNP) is/VBZ an/DT integer/NN value/NN ≥/VBD 0/CD ./.)
*0*let VARblock be ? FUNCcreatebytedatablock(VARbytelength). 
*0*(S (Chunk let/VB VARblock/NNP) be/VB ?/. (Chunk FUNCcreatebytedatablock/NNP) (/( (Chunk VARbytelength/NNP) )/) ./.)
*0*set VARobj.[[ARRAYBUFFERDATA]] to VARblock. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARblock/NNP) ./.)
*0*set VARobj.[[ARRAYBUFFERBYTELENGTH]] to VARbytelength. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERBYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARbytelength/NNP) ./.)
*0*return VARobj.     
*0*(S return/NN (Chunk VARobj/NNP) ./.)
ID= 24.1.1.2
Summary= IsDetachedBuffer ( arrayBuffer )
*0*assert: FUNCtype(VARarraybuffer) is object and it has an [[ARRAYBUFFERDATA]] internal slot. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARarraybuffer/NNP) )/) is/VBZ object/JJ and/CC it/PRP has/VBZ an/DT [/JJ [/NN (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*if VARarraybuffer.[[ARRAYBUFFERDATA]] is null, return true. 
*0*(S if/IN (Chunk VARarraybuffer/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ null/JJ ,/, return/VB true/JJ ./.)
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 24.1.1.3
Summary= DetachArrayBuffer ( arrayBuffer [ , key ] )
*0*assert: FUNCtype(VARarraybuffer) is object and it has [[ARRAYBUFFERDATA]], [[ARRAYBUFFERBYTELENGTH]], and [[ARRAYBUFFERDETACHKEY]] internal slots. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARarraybuffer/NNP) )/) is/VBZ object/JJ and/CC it/PRP (Chunk has/VBZ [/VBN [/NNP) (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ARRAYBUFFERBYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, and/CC (Chunk [/NNP) (Chunk [/NNP) (Chunk ARRAYBUFFERDETACHKEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slots/NNS ./.)
*0*assert: FUNCissharedarraybuffer(VARarraybuffer) is false. 
*0*(S assert/NN :/: (Chunk FUNCissharedarraybuffer/NNP) (/( (Chunk VARarraybuffer/NNP) )/) is/VBZ false/JJ ./.)
*0*if VARkey is not present, set VARkey to undefined. 
*0*(S if/IN (Chunk VARkey/NNP) is/VBZ not/RB present/JJ ,/, (Chunk set/VBN VARkey/NNP) to/TO undefined/VB ./.)
*0*if FUNCsamevalue(VARarraybuffer.[[ARRAYBUFFERDETACHKEY]], VARkey) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARarraybuffer/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDETACHKEY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARkey/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*set VARarraybuffer.[[ARRAYBUFFERDATA]] to null. 
*0*(S (Chunk set/VBN VARarraybuffer/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO null/VB ./.)
*0*set VARarraybuffer.[[ARRAYBUFFERBYTELENGTH]] to 0. 
*0*(S (Chunk set/VBN VARarraybuffer/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERBYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO 0/CD ./.)
*0*return FUNCnormalcompletion(null).     
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( null/NN )/) ./.)
ID= 24.1.1.4
Summary= CloneArrayBuffer ( srcBuffer, srcByteOffset, srcLength, cloneConstructor )
*0*assert: FUNCtype(VARsrcbuffer) is object and it has an [[ARRAYBUFFERDATA]] internal slot. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARsrcbuffer/NNP) )/) is/VBZ object/JJ and/CC it/PRP has/VBZ an/DT [/JJ [/NN (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*assert: FUNCisconstructor(VARcloneconstructor) is true. 
*0*(S assert/NN :/: (Chunk FUNCisconstructor/NNP) (/( (Chunk VARcloneconstructor/NNP) )/) is/VBZ true/JJ ./.)
*0*let VARtargetbuffer be ? FUNCallocatearraybuffer(VARcloneconstructor, VARsrclength). 
*0*(S (Chunk let/VB VARtargetbuffer/NNP) be/VB ?/. (Chunk FUNCallocatearraybuffer/NNP) (/( (Chunk VARcloneconstructor/NNP) ,/, (Chunk VARsrclength/NNP) )/) ./.)
*0*if FUNCisdetachedbuffer(VARsrcbuffer) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARsrcbuffer/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARsrcblock be VARsrcbuffer.[[ARRAYBUFFERDATA]]. 
*0*(S (Chunk let/VB VARsrcblock/NNP) (Chunk be/VB VARsrcbuffer/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtargetblock be VARtargetbuffer.[[ARRAYBUFFERDATA]]. 
*0*(S (Chunk let/VB VARtargetblock/NNP) (Chunk be/VB VARtargetbuffer/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*perform FUNCcopydatablockbytes(VARtargetblock, 0, VARsrcblock, VARsrcbyteoffset, VARsrclength). 
*0*(S perform/NN FUNCcopydatablockbytes/NNS (/( (Chunk VARtargetblock/NNP) ,/, 0/CD ,/, (Chunk VARsrcblock/NNP) ,/, (Chunk VARsrcbyteoffset/NNP) ,/, (Chunk VARsrclength/NNP) )/) ./.)
*0*return VARtargetbuffer.     
*0*(S return/NN (Chunk VARtargetbuffer/NNP) ./.)
ID= 24.1.1.5
Summary= RawBytesToNumber ( type, rawBytes, isLittleEndian )
*0*let VARelementsize be the number value of the element size value specified in table 56 for element type VARtype. 
*0*(S (Chunk let/VB VARelementsize/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN element/NN type/NN (Chunk VARtype/NNP) ./.)
*0*if VARislittleendian is false, reverse the order of the elements of VARrawbytes. 
*0*(S if/IN VARislittleendian/JJ is/VBZ false/JJ ,/, reverse/VB the/DT order/NN of/IN the/DT elements/NNS of/IN VARrawbytes/NNS ./.)
*0*if VARtype is "float32", then
*0*(S if/IN (Chunk VARtype/NNP) is/VBZ ``/`` float32/JJ ''/'' ,/, then/RB)
*1*let VARvalue be the byte elements of VARrawbytes concatenated and interpreted as a little-endian bit string encoding of an ieee 754-2008 binary32 value. 
*1*(S (Chunk let/VB VARvalue/NNP) be/VB the/DT byte/JJ elements/NNS of/IN (Chunk VARrawbytes/NNP) concatenated/VBD and/CC interpreted/VBD as/IN a/DT little-endian/JJ bit/NN string/VBG encoding/NN of/IN an/DT ieee/JJ 754-2008/JJ binary32/NN value/NN ./.)
*1*if VARvalue is an ieee 754-2008 binary32 nan value, return the nan number value. 
*1*(S if/IN (Chunk VARvalue/NNP) is/VBZ an/DT ieee/JJ 754-2008/JJ binary32/NN nan/IN value/NN ,/, return/VB the/DT nan/JJ number/NN value/NN ./.)
*1*return the number value that corresponds to VARvalue. 
*1*(S return/VB the/DT number/NN value/NN that/WDT corresponds/VBZ to/TO (Chunk VARvalue/NNP) ./.)
*0*if VARtype is "float64", then
*0*(S if/IN (Chunk VARtype/NNP) is/VBZ ``/`` float64/JJ ''/'' ,/, then/RB)
*1*let VARvalue be the byte elements of VARrawbytes concatenated and interpreted as a little-endian bit string encoding of an ieee 754-2008 binary64 value. 
*1*(S (Chunk let/VB VARvalue/NNP) be/VB the/DT byte/JJ elements/NNS of/IN (Chunk VARrawbytes/NNP) concatenated/VBD and/CC interpreted/VBD as/IN a/DT little-endian/JJ bit/NN string/VBG encoding/NN of/IN an/DT ieee/JJ 754-2008/JJ binary64/NN value/NN ./.)
*1*if VARvalue is an ieee 754-2008 binary64 nan value, return the nan number value. 
*1*(S if/IN (Chunk VARvalue/NNP) is/VBZ an/DT ieee/JJ 754-2008/JJ binary64/NN nan/IN value/NN ,/, return/VB the/DT nan/JJ number/NN value/NN ./.)
*1*return the number value that corresponds to VARvalue. 
*1*(S return/VB the/DT number/NN value/NN that/WDT corresponds/VBZ to/TO (Chunk VARvalue/NNP) ./.)
*0*if the first code unit of VARtype is the code unit 0x0055 (latin capital letter u), then
*0*(S if/IN the/DT first/JJ code/NN unit/NN of/IN (Chunk VARtype/NNP) is/VBZ the/DT code/NN unit/NN 0x0055/CD (/( latin/JJ capital/NN letter/NN u/NN )/) ,/, then/RB)
*1*let VARintvalue be the byte elements of VARrawbytes concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number. 
*1*(S (Chunk let/VB VARintvalue/NNP) be/VB the/DT byte/JJ elements/NNS of/IN (Chunk VARrawbytes/NNP) concatenated/VBD and/CC interpreted/VBD as/IN a/DT bit/NN string/VBG encoding/NN of/IN an/DT unsigned/JJ little-endian/JJ binary/JJ number/NN ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARintvalue be the byte elements of VARrawbytes concatenated and interpreted as a bit string encoding of a binary little-endian 2's complement number of bit length VARelementsize × 8. 
*1*(S (Chunk let/VB VARintvalue/NNP) be/VB the/DT byte/JJ elements/NNS of/IN (Chunk VARrawbytes/NNP) concatenated/VBD and/CC interpreted/VBD as/IN a/DT bit/NN string/VBG encoding/NN of/IN a/DT binary/JJ little-endian/JJ 2/CD 's/POS complement/JJ number/NN of/IN bit/NN length/JJ (Chunk VARelementsize/NNP) ×/NN 8/CD ./.)
*0*return the number value that corresponds to VARintvalue.     
*0*(S return/VB the/DT number/NN value/NN that/WDT corresponds/VBZ to/TO (Chunk VARintvalue/NNP) ./.)
ID= 24.1.1.6
Summary= GetValueFromBuffer ( arrayBuffer, byteIndex, type, isTypedArray, order [ , isLittleEndian ] )
*0*assert: FUNCisdetachedbuffer(VARarraybuffer) is false. 
*0*(S assert/NN :/: (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARarraybuffer/NNP) )/) is/VBZ false/JJ ./.)
*0*assert: there are sufficient bytes in VARarraybuffer starting at VARbyteindex to represent a value of VARtype. 
*0*(S assert/NN :/: there/EX are/VBP sufficient/JJ bytes/NNS in/IN (Chunk VARarraybuffer/NNP) starting/VBG at/IN (Chunk VARbyteindex/NNP) to/TO represent/VB a/DT value/NN of/IN (Chunk VARtype/NNP) ./.)
*0*assert: VARbyteindex is an integer value ≥ 0. 
*0*(S assert/NN :/: VARbyteindex/NN is/VBZ an/DT integer/NN value/NN ≥/VBD 0/CD ./.)
*0*let VARblock be VARarraybuffer.[[ARRAYBUFFERDATA]]. 
*0*(S (Chunk let/VB VARblock/NNP) (Chunk be/VB VARarraybuffer/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARelementsize be the number value of the element size value specified in table 56 for element type VARtype. 
*0*(S (Chunk let/VB VARelementsize/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN element/NN type/NN (Chunk VARtype/NNP) ./.)
*0*if FUNCissharedarraybuffer(VARarraybuffer) is true, then
*0*(S if/IN (Chunk FUNCissharedarraybuffer/NNP) (/( (Chunk VARarraybuffer/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*let VARexecution be the [[CANDIDATEEXECUTION]] field of the surrounding agent's agent record. 
*1*(S (Chunk let/VB VARexecution/NNP) be/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk CANDIDATEEXECUTION/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN of/IN the/DT surrounding/VBG agent/NN 's/POS agent/NN record/NN ./.)
*1*let VAReventlist be the [[EVENTLIST]] field of the element in VARexecution.[[EVENTLISTS]] whose [[AGENTSIGNIFIER]] is FUNCagentsignifier(). 
*1*(S (Chunk let/VB VAReventlist/NNP) be/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk EVENTLIST/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN of/IN the/DT element/NN in/IN (Chunk VARexecution/NNP) ./. [/VB [/JJ (Chunk EVENTLISTS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) whose/WP$ (Chunk [/NNP) (Chunk [/NNP) (Chunk AGENTSIGNIFIER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk is/VBZ FUNCagentsignifier/NNP) (/( )/) ./.)
*1*if VARistypedarray is true and VARtype is "int8", "uint8", "int16", "uint16", "int32", or "uint32", let VARnotear be true; otherwise let VARnotear be false. 
*1*(S if/IN (Chunk VARistypedarray/NNP) is/VBZ true/JJ and/CC (Chunk VARtype/NNP) is/VBZ ``/`` int8/JJ ''/'' ,/, ``/`` uint8/JJ ''/'' ,/, ``/`` int16/NN ''/'' ,/, ``/`` uint16/JJ ''/'' ,/, ``/`` int32/NN ''/'' ,/, or/CC ``/`` uint32/JJ ''/'' ,/, (Chunk let/VB VARnotear/NNP) be/VB true/JJ ;/: (Chunk otherwise/RB let/VB VARnotear/NNP) be/VB false/JJ ./.)
*1*let VARrawvalue be a list of length VARelementsize of nondeterministically chosen byte values. 
*1*(S (Chunk let/VB VARrawvalue/NNP) be/VB a/DT list/NN of/IN length/JJ (Chunk VARelementsize/NNP) of/IN nondeterministically/RB chosen/VBN byte/NN values/NNS ./.)
*1*note: in implementations, VARrawvalue is the result of a non-atomic or atomic read instruction on the underlying hardware. the nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency. 
*1*(S note/NN :/: in/IN implementations/NNS ,/, (Chunk VARrawvalue/NNP) is/VBZ the/DT result/NN of/IN a/DT non-atomic/JJ or/CC atomic/JJ read/JJ instruction/NN on/IN the/DT underlying/JJ hardware/NN ./. the/DT nondeterminism/NN is/VBZ a/DT semantic/JJ prescription/NN of/IN the/DT memory/NN model/NN to/TO describe/VB observable/JJ behaviour/NN of/IN hardware/NN with/IN weak/JJ consistency/NN ./.)
*1*let VARreadevent be readsharedmemory { [[ORDER]]: VARorder, [[NOTEAR]]: VARnotear, [[BLOCK]]: VARblock, [[BYTEINDEX]]: VARbyteindex, [[ELEMENTSIZE]]: VARelementsize }. 
*1*(S (Chunk let/VB VARreadevent/NNP) be/VB readsharedmemory/JJ {/( [/JJ [/NN (Chunk ORDER/NNP) (Chunk ]/NNP) ]/NN :/: VARorder/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk NOTEAR/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARnotear/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk BLOCK/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARblock/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk BYTEINDEX/NNP) (Chunk ]/NNP) ]/NN :/: VARbyteindex/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ELEMENTSIZE/NNP) (Chunk ]/NNP) ]/NN :/: VARelementsize/VB }/) ./.)
*1*append VARreadevent to VAReventlist. 
*1*(S (Chunk append/VB VARreadevent/NNP) to/TO (Chunk VAReventlist/NNP) ./.)
*1*append chosen value record { [[EVENT]]: VARreadevent, [[CHOSENVALUE]]: VARrawvalue } to VARexecution.[[CHOSENVALUES]]. 
*1*(S append/NN chosen/VBZ value/NN record/NN {/( [/JJ [/FW (Chunk EVENT/NNP) (Chunk ]/NNP) ]/NN :/: VARreadevent/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk CHOSENVALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARrawvalue/NNP) }/) to/TO (Chunk VARexecution/NNP) ./. [/VB [/JJ (Chunk CHOSENVALUES/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*else, let VARrawvalue be a list of VARelementsize containing, in order, the VARelementsize sequence of bytes starting with VARblock[VARbyteindex]. 
*0*(S else/RB ,/, (Chunk let/VB VARrawvalue/NNP) be/VB a/DT list/NN of/IN (Chunk VARelementsize/NNP) containing/NN ,/, in/IN order/NN ,/, the/DT (Chunk VARelementsize/NNP) sequence/NN of/IN bytes/NNS starting/VBG with/IN (Chunk VARblock/NNP) (Chunk [/NNP) (Chunk VARbyteindex/NNP) (Chunk ]/NNP) ./.)
*0*if VARislittleendian is not present, set VARislittleendian to the value of the [[LITTLEENDIAN]] field of the surrounding agent's agent record. 
*0*(S if/IN (Chunk VARislittleendian/NNP) is/VBZ not/RB present/JJ ,/, set/VBN VARislittleendian/JJ to/TO the/DT value/NN of/IN the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk LITTLEENDIAN/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN of/IN the/DT surrounding/VBG agent/NN 's/POS agent/NN record/NN ./.)
*0*return FUNCrawbytestonumber(VARtype, VARrawvalue, VARislittleendian).     
*0*(S return/NN (Chunk FUNCrawbytestonumber/NNP) (/( (Chunk VARtype/NNP) ,/, (Chunk VARrawvalue/NNP) ,/, (Chunk VARislittleendian/NNP) )/) ./.)
ID= 24.1.1.7
Summary= NumberToRawBytes ( type, value, isLittleEndian )
*0*if VARtype is "float32", then
*0*(S if/IN (Chunk VARtype/NNP) is/VBZ ``/`` float32/JJ ''/'' ,/, then/RB)
*1*let VARrawbytes be a list containing the 4 bytes that are the result of converting VARvalue to ieee 754-2008 binary32 format using “round to nearest, ties to even” rounding mode. if VARislittleendian is false, the bytes are arranged in big endian order. otherwise, the bytes are arranged in little endian order. if VARvalue is nan, VARrawbytes may be set to any implementation chosen ieee 754-2008 binary32 format not-a-number encoding. an implementation must always choose the same encoding for each implementation distinguishable nan value. 
*1*(S (Chunk let/VB VARrawbytes/NNP) be/VB a/DT list/NN containing/VBG the/DT 4/CD bytes/NNS that/WDT are/VBP the/DT result/NN of/IN (Chunk converting/VBG VARvalue/NNP) to/TO ieee/VB 754-2008/JJ binary32/NN format/NN using/VBG “/JJ round/NN to/TO nearest/JJS ,/, ties/NNS to/TO even/RB ”/VB rounding/VBG mode/NN ./. if/IN VARislittleendian/JJ is/VBZ false/JJ ,/, the/DT bytes/NNS are/VBP arranged/VBN in/IN big/JJ endian/JJ order/NN ./. otherwise/RB ,/, the/DT bytes/NNS are/VBP arranged/VBN in/IN little/JJ endian/JJ order/NN ./. if/IN (Chunk VARvalue/NNP) is/VBZ nan/JJ ,/, VARrawbytes/NNS may/MD be/VB set/VBN to/TO any/DT implementation/NN chosen/VBN ieee/JJ 754-2008/JJ binary32/NN format/JJ not-a-number/JJ encoding/NN ./. an/DT implementation/NN must/MD always/RB choose/VB the/DT same/JJ encoding/NN for/IN each/DT implementation/NN distinguishable/JJ nan/JJ value/NN ./.)
*0*else if VARtype is "float64", then
*0*(S else/RB if/IN (Chunk VARtype/NNP) is/VBZ ``/`` float64/JJ ''/'' ,/, then/RB)
*1*let VARrawbytes be a list containing the 8 bytes that are the ieee 754-2008 binary64 format encoding of VARvalue. if VARislittleendian is false, the bytes are arranged in big endian order. otherwise, the bytes are arranged in little endian order. if VARvalue is nan, VARrawbytes may be set to any implementation chosen ieee 754-2008 binary64 format not-a-number encoding. an implementation must always choose the same encoding for each implementation distinguishable nan value. 
*1*(S (Chunk let/VB VARrawbytes/NNP) be/VB a/DT list/NN containing/VBG the/DT 8/CD bytes/NNS that/WDT are/VBP the/DT ieee/JJ 754-2008/JJ binary64/NN format/NN encoding/NN of/IN (Chunk VARvalue/NNP) ./. if/IN VARislittleendian/JJ is/VBZ false/JJ ,/, the/DT bytes/NNS are/VBP arranged/VBN in/IN big/JJ endian/JJ order/NN ./. otherwise/RB ,/, the/DT bytes/NNS are/VBP arranged/VBN in/IN little/JJ endian/JJ order/NN ./. if/IN (Chunk VARvalue/NNP) is/VBZ nan/JJ ,/, VARrawbytes/NNS may/MD be/VB set/VBN to/TO any/DT implementation/NN chosen/VBN ieee/JJ 754-2008/JJ binary64/NN format/JJ not-a-number/JJ encoding/NN ./. an/DT implementation/NN must/MD always/RB choose/VB the/DT same/JJ encoding/NN for/IN each/DT implementation/NN distinguishable/JJ nan/JJ value/NN ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARn be the number value of the element size specified in table 56 for element type VARtype. 
*1*(S (Chunk let/VB VARn/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN specified/VBN in/IN table/JJ 56/CD for/IN element/NN type/NN (Chunk VARtype/NNP) ./.)
*1*let VARconvop be the abstract operation named in the conversion operation column in table 56 for element type VARtype. 
*1*(S (Chunk let/VB VARconvop/NNP) be/VB the/DT abstract/JJ operation/NN named/VBN in/IN the/DT conversion/NN operation/NN column/NN in/IN table/JJ 56/CD for/IN element/NN type/NN (Chunk VARtype/NNP) ./.)
*1*let VARintvalue be VARconvop(VARvalue). 
*1*(S (Chunk let/VB VARintvalue/NNP) (Chunk be/VB VARconvop/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*1*if VARintvalue ≥ 0, then
*1*(S if/IN (Chunk VARintvalue/NNP) ≥/VBD 0/CD ,/, then/RB)
*2*let VARrawbytes be a list containing the VARn-byte binary encoding of VARintvalue. if VARislittleendian is false, the bytes are ordered in big endian order. otherwise, the bytes are ordered in little endian order. 
*2*(S (Chunk let/VB VARrawbytes/NNP) be/VB a/DT list/NN containing/VBG the/DT (Chunk VARn-byte/NNP) binary/JJ encoding/NN of/IN (Chunk VARintvalue/NNP) ./. if/IN VARislittleendian/JJ is/VBZ false/JJ ,/, the/DT bytes/NNS are/VBP ordered/VBN in/IN big/JJ endian/JJ order/NN ./. otherwise/RB ,/, the/DT bytes/NNS are/VBP ordered/VBN in/IN little/JJ endian/JJ order/NN ./.)
*1*else,
*1*(S else/RB ,/,)
*2*let VARrawbytes be a list containing the VARn-byte binary 2's complement encoding of VARintvalue. if VARislittleendian is false, the bytes are ordered in big endian order. otherwise, the bytes are ordered in little endian order. 
*2*(S (Chunk let/VB VARrawbytes/NNP) be/VB a/DT list/NN containing/VBG the/DT (Chunk VARn-byte/NNP) binary/JJ 2/CD 's/POS complement/JJ encoding/NN of/IN (Chunk VARintvalue/NNP) ./. if/IN VARislittleendian/JJ is/VBZ false/JJ ,/, the/DT bytes/NNS are/VBP ordered/VBN in/IN big/JJ endian/JJ order/NN ./. otherwise/RB ,/, the/DT bytes/NNS are/VBP ordered/VBN in/IN little/JJ endian/JJ order/NN ./.)
*0*return VARrawbytes.     
*0*(S return/NN VARrawbytes/NNS ./.)
ID= 24.1.1.8
Summary= SetValueInBuffer ( arrayBuffer, byteIndex, type, value, isTypedArray, order [ , isLittleEndian ] )
*0*assert: FUNCisdetachedbuffer(VARarraybuffer) is false. 
*0*(S assert/NN :/: (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARarraybuffer/NNP) )/) is/VBZ false/JJ ./.)
*0*assert: there are sufficient bytes in VARarraybuffer starting at VARbyteindex to represent a value of VARtype. 
*0*(S assert/NN :/: there/EX are/VBP sufficient/JJ bytes/NNS in/IN (Chunk VARarraybuffer/NNP) starting/VBG at/IN (Chunk VARbyteindex/NNP) to/TO represent/VB a/DT value/NN of/IN (Chunk VARtype/NNP) ./.)
*0*assert: VARbyteindex is an integer value ≥ 0. 
*0*(S assert/NN :/: VARbyteindex/NN is/VBZ an/DT integer/NN value/NN ≥/VBD 0/CD ./.)
*0*assert: FUNCtype(VARvalue) is number. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARvalue/NNP) )/) is/VBZ number/NN ./.)
*0*let VARblock be VARarraybuffer.[[ARRAYBUFFERDATA]]. 
*0*(S (Chunk let/VB VARblock/NNP) (Chunk be/VB VARarraybuffer/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARelementsize be the number value of the element size value specified in table 56 for element type VARtype. 
*0*(S (Chunk let/VB VARelementsize/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN element/NN type/NN (Chunk VARtype/NNP) ./.)
*0*if VARislittleendian is not present, set VARislittleendian to the value of the [[LITTLEENDIAN]] field of the surrounding agent's agent record. 
*0*(S if/IN (Chunk VARislittleendian/NNP) is/VBZ not/RB present/JJ ,/, set/VBN VARislittleendian/JJ to/TO the/DT value/NN of/IN the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk LITTLEENDIAN/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN of/IN the/DT surrounding/VBG agent/NN 's/POS agent/NN record/NN ./.)
*0*let VARrawbytes be FUNCnumbertorawbytes(VARtype, VARvalue, VARislittleendian). 
*0*(S (Chunk let/VB VARrawbytes/NNP) (Chunk be/VB FUNCnumbertorawbytes/NNP) (/( (Chunk VARtype/NNP) ,/, (Chunk VARvalue/NNP) ,/, (Chunk VARislittleendian/NNP) )/) ./.)
*0*if FUNCissharedarraybuffer(VARarraybuffer) is true, then
*0*(S if/IN (Chunk FUNCissharedarraybuffer/NNP) (/( (Chunk VARarraybuffer/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*let VARexecution be the [[CANDIDATEEXECUTION]] field of the surrounding agent's agent record. 
*1*(S (Chunk let/VB VARexecution/NNP) be/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk CANDIDATEEXECUTION/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN of/IN the/DT surrounding/VBG agent/NN 's/POS agent/NN record/NN ./.)
*1*let VAReventlist be the [[EVENTLIST]] field of the element in VARexecution.[[EVENTLISTS]] whose [[AGENTSIGNIFIER]] is FUNCagentsignifier(). 
*1*(S (Chunk let/VB VAReventlist/NNP) be/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk EVENTLIST/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN of/IN the/DT element/NN in/IN (Chunk VARexecution/NNP) ./. [/VB [/JJ (Chunk EVENTLISTS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) whose/WP$ (Chunk [/NNP) (Chunk [/NNP) (Chunk AGENTSIGNIFIER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk is/VBZ FUNCagentsignifier/NNP) (/( )/) ./.)
*1*if VARistypedarray is true and VARtype is "int8", "uint8", "int16", "uint16", "int32", or "uint32", let VARnotear be true; otherwise let VARnotear be false. 
*1*(S if/IN (Chunk VARistypedarray/NNP) is/VBZ true/JJ and/CC (Chunk VARtype/NNP) is/VBZ ``/`` int8/JJ ''/'' ,/, ``/`` uint8/JJ ''/'' ,/, ``/`` int16/NN ''/'' ,/, ``/`` uint16/JJ ''/'' ,/, ``/`` int32/NN ''/'' ,/, or/CC ``/`` uint32/JJ ''/'' ,/, (Chunk let/VB VARnotear/NNP) be/VB true/JJ ;/: (Chunk otherwise/RB let/VB VARnotear/NNP) be/VB false/JJ ./.)
*1*append writesharedmemory { [[ORDER]]: VARorder, [[NOTEAR]]: VARnotear, [[BLOCK]]: VARblock, [[BYTEINDEX]]: VARbyteindex, [[ELEMENTSIZE]]: VARelementsize, [[PAYLOAD]]: VARrawbytes } to VAReventlist. 
*1*(S append/RB writesharedmemory/JJ {/( [/JJ [/NN (Chunk ORDER/NNP) (Chunk ]/NNP) ]/NN :/: VARorder/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk NOTEAR/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARnotear/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk BLOCK/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARblock/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk BYTEINDEX/NNP) (Chunk ]/NNP) ]/NN :/: VARbyteindex/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ELEMENTSIZE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARelementsize/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk PAYLOAD/NNP) (Chunk ]/NNP) ]/NN :/: VARrawbytes/NNS }/) to/TO (Chunk VAReventlist/NNP) ./.)
*0*else, store the individual bytes of VARrawbytes into VARblock, in order, starting at VARblock[VARbyteindex]. 
*0*(S else/RB ,/, store/VBD the/DT individual/JJ bytes/NNS of/IN (Chunk VARrawbytes/NNP) into/IN (Chunk VARblock/NNP) ,/, in/IN order/NN ,/, starting/VBG at/IN (Chunk VARblock/NNP) (Chunk [/NNP) (Chunk VARbyteindex/NNP) (Chunk ]/NNP) ./.)
*0*return FUNCnormalcompletion(undefined).     
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( undefined/JJ )/) ./.)
ID= 24.1.1.9
Summary= GetModifySetValueInBuffer ( arrayBuffer, byteIndex, type, value, op [ , isLittleEndian ] )
*0*assert: FUNCissharedarraybuffer(VARarraybuffer) is true. 
*0*(S assert/NN :/: (Chunk FUNCissharedarraybuffer/NNP) (/( (Chunk VARarraybuffer/NNP) )/) is/VBZ true/JJ ./.)
*0*assert: there are sufficient bytes in VARarraybuffer starting at VARbyteindex to represent a value of VARtype. 
*0*(S assert/NN :/: there/EX are/VBP sufficient/JJ bytes/NNS in/IN (Chunk VARarraybuffer/NNP) starting/VBG at/IN (Chunk VARbyteindex/NNP) to/TO represent/VB a/DT value/NN of/IN (Chunk VARtype/NNP) ./.)
*0*assert: VARbyteindex is an integer value ≥ 0. 
*0*(S assert/NN :/: VARbyteindex/NN is/VBZ an/DT integer/NN value/NN ≥/VBD 0/CD ./.)
*0*assert: FUNCtype(VARvalue) is number. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARvalue/NNP) )/) is/VBZ number/NN ./.)
*0*let VARblock be VARarraybuffer.[[ARRAYBUFFERDATA]]. 
*0*(S (Chunk let/VB VARblock/NNP) (Chunk be/VB VARarraybuffer/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARelementsize be the number value of the element size value specified in table 56 for element type VARtype. 
*0*(S (Chunk let/VB VARelementsize/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN element/NN type/NN (Chunk VARtype/NNP) ./.)
*0*if VARislittleendian is not present, set VARislittleendian to the value of the [[LITTLEENDIAN]] field of the surrounding agent's agent record. 
*0*(S if/IN (Chunk VARislittleendian/NNP) is/VBZ not/RB present/JJ ,/, set/VBN VARislittleendian/JJ to/TO the/DT value/NN of/IN the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk LITTLEENDIAN/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN of/IN the/DT surrounding/VBG agent/NN 's/POS agent/NN record/NN ./.)
*0*let VARrawbytes be FUNCnumbertorawbytes(VARtype, VARvalue, VARislittleendian). 
*0*(S (Chunk let/VB VARrawbytes/NNP) (Chunk be/VB FUNCnumbertorawbytes/NNP) (/( (Chunk VARtype/NNP) ,/, (Chunk VARvalue/NNP) ,/, (Chunk VARislittleendian/NNP) )/) ./.)
*0*let VARexecution be the [[CANDIDATEEXECUTION]] field of the surrounding agent's agent record. 
*0*(S (Chunk let/VB VARexecution/NNP) be/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk CANDIDATEEXECUTION/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN of/IN the/DT surrounding/VBG agent/NN 's/POS agent/NN record/NN ./.)
*0*let VAReventlist be the [[EVENTLIST]] field of the element in VARexecution.[[EVENTLISTS]] whose [[AGENTSIGNIFIER]] is FUNCagentsignifier(). 
*0*(S (Chunk let/VB VAReventlist/NNP) be/VB the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk EVENTLIST/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN of/IN the/DT element/NN in/IN (Chunk VARexecution/NNP) ./. [/VB [/JJ (Chunk EVENTLISTS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) whose/WP$ (Chunk [/NNP) (Chunk [/NNP) (Chunk AGENTSIGNIFIER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk is/VBZ FUNCagentsignifier/NNP) (/( )/) ./.)
*0*let VARrawbytesread be a list of length VARelementsize of nondeterministically chosen byte values. 
*0*(S (Chunk let/VB VARrawbytesread/NNP) be/VB a/DT list/NN of/IN length/JJ (Chunk VARelementsize/NNP) of/IN nondeterministically/RB chosen/VBN byte/NN values/NNS ./.)
*0*note: in implementations, VARrawbytesread is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. the nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency. 
*0*(S note/NN :/: in/IN implementations/NNS ,/, (Chunk VARrawbytesread/NNP) is/VBZ the/DT result/NN of/IN a/DT load-link/JJ ,/, of/IN a/DT load-exclusive/JJ ,/, or/CC of/IN an/DT operand/NN of/IN a/DT read-modify-write/JJ instruction/NN on/IN the/DT underlying/JJ hardware/NN ./. the/DT nondeterminism/NN is/VBZ a/DT semantic/JJ prescription/NN of/IN the/DT memory/NN model/NN to/TO describe/VB observable/JJ behaviour/NN of/IN hardware/NN with/IN weak/JJ consistency/NN ./.)
*0*let VARrmwevent be readmodifywritesharedmemory { [[ORDER]]: "seqcst", [[NOTEAR]]: true, [[BLOCK]]: VARblock, [[BYTEINDEX]]: VARbyteindex, [[ELEMENTSIZE]]: VARelementsize, [[PAYLOAD]]: VARrawbytes, [[MODIFYOP]]: VARop }. 
*0*(S (Chunk let/VB VARrmwevent/NNP) be/VB readmodifywritesharedmemory/JJ {/( [/JJ [/NN (Chunk ORDER/NNP) (Chunk ]/NNP) ]/NN :/: ``/`` seqcst/NN ''/'' ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk NOTEAR/NNP) (Chunk ]/NNP) ]/NN :/: true/JJ ,/, [/JJ (Chunk [/NNP) (Chunk BLOCK/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARblock/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk BYTEINDEX/NNP) (Chunk ]/NNP) ]/NN :/: VARbyteindex/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ELEMENTSIZE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARelementsize/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk PAYLOAD/NNP) (Chunk ]/NNP) ]/NN :/: VARrawbytes/NNS ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk MODIFYOP/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARop/NNP) }/) ./.)
*0*append VARrmwevent to VAReventlist. 
*0*(S (Chunk append/VB VARrmwevent/NNP) to/TO (Chunk VAReventlist/NNP) ./.)
*0*append chosen value record { [[EVENT]]: VARrmwevent, [[CHOSENVALUE]]: VARrawbytesread } to VARexecution.[[CHOSENVALUES]]. 
*0*(S append/NN chosen/VBZ value/NN record/NN {/( [/JJ [/FW (Chunk EVENT/NNP) (Chunk ]/NNP) ]/NN :/: VARrmwevent/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk CHOSENVALUE/NNP) (Chunk ]/NNP) ]/NN :/: VARrawbytesread/NN }/) to/TO (Chunk VARexecution/NNP) ./. [/VB [/JJ (Chunk CHOSENVALUES/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*return FUNCrawbytestonumber(VARtype, VARrawbytesread, VARislittleendian).     
*0*(S return/NN (Chunk FUNCrawbytestonumber/NNP) (/( (Chunk VARtype/NNP) ,/, (Chunk VARrawbytesread/NNP) ,/, (Chunk VARislittleendian/NNP) )/) ./.)
ID= 24.1.2.1
Summary= ArrayBuffer ( length )
*0*if newtarget is undefined, throw a typeerror exception. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARbytelength be ? FUNCtoindex(VARlength). 
*0*(S (Chunk let/VB VARbytelength/NNP) be/VB ?/. (Chunk FUNCtoindex/NNP) (/( (Chunk VARlength/NNP) )/) ./.)
*0*return ? FUNCallocatearraybuffer(newtarget, VARbytelength).     
*0*(S return/NN ?/. (Chunk FUNCallocatearraybuffer/NNP) (/( newtarget/NN ,/, (Chunk VARbytelength/NNP) )/) ./.)
ID= 24.1.3.1
Summary= ArrayBuffer.isView ( arg )
*0*if FUNCtype(VARarg) is not object, return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARarg/NNP) )/) is/VBZ not/RB object/JJ ,/, return/NN false/JJ ./.)
*0*if VARarg has a [[VIEWEDARRAYBUFFER]] internal slot, return true. 
*0*(S if/IN (Chunk VARarg/NNP) has/VBZ a/DT [/JJ [/NN (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, return/NN true/JJ ./.)
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 24.1.4.3
Summary= ArrayBuffer.prototype.slice ( start, end )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARo does not have an [[ARRAYBUFFERDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARo/NNP) does/VBZ not/RB have/VB an/DT [/JJ [/NN (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if FUNCissharedarraybuffer(VARo) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCissharedarraybuffer/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if FUNCisdetachedbuffer(VARo) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARlen be VARo.[[ARRAYBUFFERBYTELENGTH]]. 
*0*(S (Chunk let/VB VARlen/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERBYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARrelativestart be ? FUNCtointeger(VARstart). 
*0*(S (Chunk let/VB VARrelativestart/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARstart/NNP) )/) ./.)
*0*if VARrelativestart &lt; 0, let VARfirst be max((VARlen + VARrelativestart), 0); else let VARfirst be min(VARrelativestart, VARlen). 
*0*(S if/IN (Chunk VARrelativestart/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARfirst/NNP) be/VB max/VBN (/( (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARrelativestart/NNP) )/) ,/, 0/CD )/) ;/: else/JJ (Chunk let/VB VARfirst/NNP) be/VB min/VBN (/( (Chunk VARrelativestart/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*if VARend is undefined, let VARrelativeend be VARlen; else let VARrelativeend be ? FUNCtointeger(VARend). 
*0*(S if/IN (Chunk VARend/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARrelativeend/NNP) (Chunk be/VB VARlen/NNP) ;/: else/JJ (Chunk let/VB VARrelativeend/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARend/NNP) )/) ./.)
*0*if VARrelativeend &lt; 0, let VARfinal be max((VARlen + VARrelativeend), 0); else let VARfinal be min(VARrelativeend, VARlen). 
*0*(S if/IN (Chunk VARrelativeend/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARfinal/NNP) be/VB max/VBN (/( (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARrelativeend/NNP) )/) ,/, 0/CD )/) ;/: else/JJ (Chunk let/VB VARfinal/NNP) be/VB min/VBN (/( (Chunk VARrelativeend/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*let VARnewlen be max(VARfinal-VARfirst, 0). 
*0*(S (Chunk let/VB VARnewlen/NNP) be/VB max/VBN (/( (Chunk VARfinal-VARfirst/NNP) ,/, 0/CD )/) ./.)
*0*let VARctor be ? FUNCspeciesconstructor(VARo, %arraybuffer%). 
*0*(S (Chunk let/VB VARctor/NNP) be/VB ?/. (Chunk FUNCspeciesconstructor/NNP) (/( (Chunk VARo/NNP) ,/, %/NN arraybuffer/NN %/NN )/) ./.)
*0*let VARnew be ? FUNCconstruct(VARctor, « VARnewlen »). 
*0*(S (Chunk let/VB VARnew/NNP) be/VB ?/. (Chunk FUNCconstruct/NNP) (/( (Chunk VARctor/NNP) ,/, (Chunk «/NNP) (Chunk VARnewlen/NNP) (Chunk »/NNP) )/) ./.)
*0*if VARnew does not have an [[ARRAYBUFFERDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARnew/NNP) does/VBZ not/RB have/VB an/DT [/JJ [/NN (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if FUNCissharedarraybuffer(VARnew) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCissharedarraybuffer/NNP) (/( (Chunk VARnew/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if FUNCisdetachedbuffer(VARnew) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARnew/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if FUNCsamevalue(VARnew, VARo) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARnew/NNP) ,/, (Chunk VARo/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARnew.[[ARRAYBUFFERBYTELENGTH]] &lt; VARnewlen, throw a typeerror exception. 
*0*(S if/IN (Chunk VARnew/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERBYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) &/CC lt/NN ;/: (Chunk VARnewlen/NNP) ,/, throw/VBP a/DT typeerror/NN exception/NN ./.)
*0*note: side-effects of the above steps may have detached VARo. 
*0*(S note/NN :/: side-effects/NNS of/IN the/DT above/JJ steps/NNS may/MD (Chunk have/VB detached/VBN VARo/NNP) ./.)
*0*if FUNCisdetachedbuffer(VARo) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARfrombuf be VARo.[[ARRAYBUFFERDATA]]. 
*0*(S (Chunk let/VB VARfrombuf/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtobuf be VARnew.[[ARRAYBUFFERDATA]]. 
*0*(S (Chunk let/VB VARtobuf/NNP) (Chunk be/VB VARnew/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*perform FUNCcopydatablockbytes(VARtobuf, 0, VARfrombuf, VARfirst, VARnewlen). 
*0*(S perform/NN FUNCcopydatablockbytes/NNS (/( (Chunk VARtobuf/NNP) ,/, 0/CD ,/, (Chunk VARfrombuf/NNP) ,/, (Chunk VARfirst/NNP) ,/, (Chunk VARnewlen/NNP) )/) ./.)
*0*return VARnew.     
*0*(S return/NN (Chunk VARnew/NNP) ./.)
ID= 24.2.1.1
Summary= AllocateSharedArrayBuffer ( constructor, byteLength )
*0*let VARobj be ? FUNCordinarycreatefromconstructor(VARconstructor, "%sharedarraybufferprototype%", « [[ARRAYBUFFERDATA]], [[ARRAYBUFFERBYTELENGTH]] »). 
*0*(S (Chunk let/VB VARobj/NNP) be/VB ?/. (Chunk FUNCordinarycreatefromconstructor/NNP) (/( (Chunk VARconstructor/NNP) ,/, ``/`` %/NN sharedarraybufferprototype/JJ %/NN ''/'' ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ARRAYBUFFERBYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*assert: VARbytelength is a nonnegative integer. 
*0*(S assert/NN :/: (Chunk VARbytelength/NNP) is/VBZ a/DT nonnegative/JJ integer/NN ./.)
*0*let VARblock be ? FUNCcreatesharedbytedatablock(VARbytelength). 
*0*(S (Chunk let/VB VARblock/NNP) be/VB ?/. (Chunk FUNCcreatesharedbytedatablock/NNP) (/( (Chunk VARbytelength/NNP) )/) ./.)
*0*set VARobj.[[ARRAYBUFFERDATA]] to VARblock. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARblock/NNP) ./.)
*0*set VARobj.[[ARRAYBUFFERBYTELENGTH]] to VARbytelength. 
*0*(S (Chunk set/VBN VARobj/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERBYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARbytelength/NNP) ./.)
*0*return VARobj.     
*0*(S return/NN (Chunk VARobj/NNP) ./.)
ID= 24.2.1.2
Summary= IsSharedArrayBuffer ( obj )
*0*assert: FUNCtype(VARobj) is object and it has an [[ARRAYBUFFERDATA]] internal slot. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARobj/NNP) )/) is/VBZ object/JJ and/CC it/PRP has/VBZ an/DT [/JJ [/NN (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*let VARbufferdata be VARobj.[[ARRAYBUFFERDATA]]. 
*0*(S (Chunk let/VB VARbufferdata/NNP) (Chunk be/VB VARobj/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARbufferdata is null, return false. 
*0*(S if/IN (Chunk VARbufferdata/NNP) is/VBZ null/JJ ,/, return/NN false/JJ ./.)
*0*if VARbufferdata is a data block, return false. 
*0*(S if/IN (Chunk VARbufferdata/NNP) is/VBZ a/DT data/NN block/NN ,/, return/NN false/JJ ./.)
*0*assert: VARbufferdata is a shared data block. 
*0*(S assert/NN :/: (Chunk VARbufferdata/NNP) is/VBZ a/DT shared/VBN data/NN block/NN ./.)
*0*return true.     
*0*(S return/NN true/JJ ./.)
ID= 24.2.2.1
Summary= SharedArrayBuffer ( length )
*0*if newtarget is undefined, throw a typeerror exception. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARbytelength be ? FUNCtoindex(VARlength). 
*0*(S (Chunk let/VB VARbytelength/NNP) be/VB ?/. (Chunk FUNCtoindex/NNP) (/( (Chunk VARlength/NNP) )/) ./.)
*0*return ? FUNCallocatesharedarraybuffer(newtarget, VARbytelength).     
*0*(S return/NN ?/. (Chunk FUNCallocatesharedarraybuffer/NNP) (/( newtarget/NN ,/, (Chunk VARbytelength/NNP) )/) ./.)
ID= 24.2.4.3
Summary= SharedArrayBuffer.prototype.slice ( start, end )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARo does not have an [[ARRAYBUFFERDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARo/NNP) does/VBZ not/RB have/VB an/DT [/JJ [/NN (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if FUNCissharedarraybuffer(VARo) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCissharedarraybuffer/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARlen be VARo.[[ARRAYBUFFERBYTELENGTH]]. 
*0*(S (Chunk let/VB VARlen/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERBYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARrelativestart be ? FUNCtointeger(VARstart). 
*0*(S (Chunk let/VB VARrelativestart/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARstart/NNP) )/) ./.)
*0*if VARrelativestart &lt; 0, let VARfirst be max((VARlen + VARrelativestart), 0); else let VARfirst be min(VARrelativestart, VARlen). 
*0*(S if/IN (Chunk VARrelativestart/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARfirst/NNP) be/VB max/VBN (/( (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARrelativestart/NNP) )/) ,/, 0/CD )/) ;/: else/JJ (Chunk let/VB VARfirst/NNP) be/VB min/VBN (/( (Chunk VARrelativestart/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*if VARend is undefined, let VARrelativeend be VARlen; else let VARrelativeend be ? FUNCtointeger(VARend). 
*0*(S if/IN (Chunk VARend/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARrelativeend/NNP) (Chunk be/VB VARlen/NNP) ;/: else/JJ (Chunk let/VB VARrelativeend/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARend/NNP) )/) ./.)
*0*if VARrelativeend &lt; 0, let VARfinal be max((VARlen + VARrelativeend), 0); else let VARfinal be min(VARrelativeend, VARlen). 
*0*(S if/IN (Chunk VARrelativeend/NNP) &/CC lt/NN ;/: 0/CD ,/, (Chunk let/VB VARfinal/NNP) be/VB max/VBN (/( (/( (Chunk VARlen/NNP) (Chunk +/NNP) (Chunk VARrelativeend/NNP) )/) ,/, 0/CD )/) ;/: else/JJ (Chunk let/VB VARfinal/NNP) be/VB min/VBN (/( (Chunk VARrelativeend/NNP) ,/, (Chunk VARlen/NNP) )/) ./.)
*0*let VARnewlen be max(VARfinal - VARfirst, 0). 
*0*(S (Chunk let/VB VARnewlen/NNP) be/VB max/VBN (/( (Chunk VARfinal/NNP) -/: (Chunk VARfirst/NNP) ,/, 0/CD )/) ./.)
*0*let VARctor be ? FUNCspeciesconstructor(VARo, %sharedarraybuffer%). 
*0*(S (Chunk let/VB VARctor/NNP) be/VB ?/. (Chunk FUNCspeciesconstructor/NNP) (/( (Chunk VARo/NNP) ,/, %/NN sharedarraybuffer/NN %/NN )/) ./.)
*0*let VARnew be ? FUNCconstruct(VARctor, « VARnewlen »). 
*0*(S (Chunk let/VB VARnew/NNP) be/VB ?/. (Chunk FUNCconstruct/NNP) (/( (Chunk VARctor/NNP) ,/, (Chunk «/NNP) (Chunk VARnewlen/NNP) (Chunk »/NNP) )/) ./.)
*0*if VARnew does not have an [[ARRAYBUFFERDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARnew/NNP) does/VBZ not/RB have/VB an/DT [/JJ [/NN (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if FUNCissharedarraybuffer(VARnew) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCissharedarraybuffer/NNP) (/( (Chunk VARnew/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARnew.[[ARRAYBUFFERDATA]] and VARo.[[ARRAYBUFFERDATA]] are the same shared data block values, throw a typeerror exception. 
*0*(S if/IN (Chunk VARnew/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) and/CC (Chunk VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) are/VBP the/DT same/JJ shared/VBN data/NNS block/NN values/NNS ,/, throw/VBP a/DT typeerror/NN exception/NN ./.)
*0*if VARnew.[[ARRAYBUFFERBYTELENGTH]] &lt; VARnewlen, throw a typeerror exception. 
*0*(S if/IN (Chunk VARnew/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERBYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) &/CC lt/NN ;/: (Chunk VARnewlen/NNP) ,/, throw/VBP a/DT typeerror/NN exception/NN ./.)
*0*let VARfrombuf be VARo.[[ARRAYBUFFERDATA]]. 
*0*(S (Chunk let/VB VARfrombuf/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtobuf be VARnew.[[ARRAYBUFFERDATA]]. 
*0*(S (Chunk let/VB VARtobuf/NNP) (Chunk be/VB VARnew/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*perform FUNCcopydatablockbytes(VARtobuf, 0, VARfrombuf, VARfirst, VARnewlen). 
*0*(S perform/NN FUNCcopydatablockbytes/NNS (/( (Chunk VARtobuf/NNP) ,/, 0/CD ,/, (Chunk VARfrombuf/NNP) ,/, (Chunk VARfirst/NNP) ,/, (Chunk VARnewlen/NNP) )/) ./.)
*0*return VARnew.     
*0*(S return/NN (Chunk VARnew/NNP) ./.)
ID= 24.3.1.1
Summary= GetViewValue ( view, requestIndex, isLittleEndian, type )
*0*if FUNCtype(VARview) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARview/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARview does not have a [[DATAVIEW]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARview/NNP) does/VBZ not/RB have/VB a/DT [/JJ (Chunk [/NNP) (Chunk DATAVIEW/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: VARview has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*(S assert/NN :/: (Chunk VARview/NNP) has/VBZ a/DT [/JJ [/NN (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*let VARgetindex be ? FUNCtoindex(VARrequestindex). 
*0*(S (Chunk let/VB VARgetindex/NNP) be/VB ?/. (Chunk FUNCtoindex/NNP) (/( (Chunk VARrequestindex/NNP) )/) ./.)
*0*set VARislittleendian to FUNCtoboolean(VARislittleendian). 
*0*(S set/NN (Chunk VARislittleendian/NNP) to/TO (Chunk FUNCtoboolean/NNP) (/( (Chunk VARislittleendian/NNP) )/) ./.)
*0*let VARbuffer be VARview.[[VIEWEDARRAYBUFFER]]. 
*0*(S (Chunk let/VB VARbuffer/NNP) (Chunk be/VB VARview/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if FUNCisdetachedbuffer(VARbuffer) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARbuffer/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARviewoffset be VARview.[[BYTEOFFSET]]. 
*0*(S (Chunk let/VB VARviewoffset/NNP) (Chunk be/VB VARview/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARviewsize be VARview.[[BYTELENGTH]]. 
*0*(S (Chunk let/VB VARviewsize/NNP) (Chunk be/VB VARview/NNP) ./. [/VB [/JJ (Chunk BYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARelementsize be the number value of the element size value specified in table 56 for element type VARtype. 
*0*(S (Chunk let/VB VARelementsize/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN element/NN type/NN (Chunk VARtype/NNP) ./.)
*0*if VARgetindex + VARelementsize &gt; VARviewsize, throw a rangeerror exception. 
*0*(S if/IN (Chunk VARgetindex/NNP) (Chunk +/NNP) (Chunk VARelementsize/NNP) &/CC gt/NN ;/: (Chunk VARviewsize/NNP) ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*let VARbufferindex be VARgetindex + VARviewoffset. 
*0*(S (Chunk let/VB VARbufferindex/NNP) (Chunk be/VB VARgetindex/NNP) (Chunk +/NNP) (Chunk VARviewoffset/NNP) ./.)
*0*return FUNCgetvaluefrombuffer(VARbuffer, VARbufferindex, VARtype, false, "unordered", VARislittleendian).     
*0*(S return/NN (Chunk FUNCgetvaluefrombuffer/NNP) (/( (Chunk VARbuffer/NNP) ,/, (Chunk VARbufferindex/NNP) ,/, (Chunk VARtype/NNP) ,/, false/RB ,/, ``/`` unordered/JJ ''/'' ,/, (Chunk VARislittleendian/NNP) )/) ./.)
ID= 24.3.1.2
Summary= SetViewValue ( view, requestIndex, isLittleEndian, type, value )
*0*if FUNCtype(VARview) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARview/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARview does not have a [[DATAVIEW]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARview/NNP) does/VBZ not/RB have/VB a/DT [/JJ (Chunk [/NNP) (Chunk DATAVIEW/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: VARview has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*(S assert/NN :/: (Chunk VARview/NNP) has/VBZ a/DT [/JJ [/NN (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*let VARgetindex be ? FUNCtoindex(VARrequestindex). 
*0*(S (Chunk let/VB VARgetindex/NNP) be/VB ?/. (Chunk FUNCtoindex/NNP) (/( (Chunk VARrequestindex/NNP) )/) ./.)
*0*let VARnumbervalue be ? FUNCtonumber(VARvalue). 
*0*(S (Chunk let/VB VARnumbervalue/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*0*set VARislittleendian to FUNCtoboolean(VARislittleendian). 
*0*(S set/NN (Chunk VARislittleendian/NNP) to/TO (Chunk FUNCtoboolean/NNP) (/( (Chunk VARislittleendian/NNP) )/) ./.)
*0*let VARbuffer be VARview.[[VIEWEDARRAYBUFFER]]. 
*0*(S (Chunk let/VB VARbuffer/NNP) (Chunk be/VB VARview/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if FUNCisdetachedbuffer(VARbuffer) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARbuffer/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARviewoffset be VARview.[[BYTEOFFSET]]. 
*0*(S (Chunk let/VB VARviewoffset/NNP) (Chunk be/VB VARview/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARviewsize be VARview.[[BYTELENGTH]]. 
*0*(S (Chunk let/VB VARviewsize/NNP) (Chunk be/VB VARview/NNP) ./. [/VB [/JJ (Chunk BYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARelementsize be the number value of the element size value specified in table 56 for element type VARtype. 
*0*(S (Chunk let/VB VARelementsize/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN element/NN type/NN (Chunk VARtype/NNP) ./.)
*0*if VARgetindex + VARelementsize &gt; VARviewsize, throw a rangeerror exception. 
*0*(S if/IN (Chunk VARgetindex/NNP) (Chunk +/NNP) (Chunk VARelementsize/NNP) &/CC gt/NN ;/: (Chunk VARviewsize/NNP) ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*let VARbufferindex be VARgetindex + VARviewoffset. 
*0*(S (Chunk let/VB VARbufferindex/NNP) (Chunk be/VB VARgetindex/NNP) (Chunk +/NNP) (Chunk VARviewoffset/NNP) ./.)
*0*return FUNCsetvalueinbuffer(VARbuffer, VARbufferindex, VARtype, VARnumbervalue, false, "unordered", VARislittleendian).     
*0*(S return/NN (Chunk FUNCsetvalueinbuffer/NNP) (/( (Chunk VARbuffer/NNP) ,/, (Chunk VARbufferindex/NNP) ,/, (Chunk VARtype/NNP) ,/, (Chunk VARnumbervalue/NNP) ,/, false/RB ,/, ``/`` unordered/JJ ''/'' ,/, (Chunk VARislittleendian/NNP) )/) ./.)
ID= 24.3.2.1
Summary= DataView ( buffer [ , byteOffset [ , byteLength  ] ] )
*0*if newtarget is undefined, throw a typeerror exception. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if FUNCtype(VARbuffer) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARbuffer/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARbuffer does not have an [[ARRAYBUFFERDATA]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARbuffer/NNP) does/VBZ not/RB have/VB an/DT [/JJ [/NN (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARoffset be ? FUNCtoindex(VARbyteoffset). 
*0*(S (Chunk let/VB VARoffset/NNP) be/VB ?/. (Chunk FUNCtoindex/NNP) (/( (Chunk VARbyteoffset/NNP) )/) ./.)
*0*if FUNCisdetachedbuffer(VARbuffer) is true, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisdetachedbuffer/NNP) (/( (Chunk VARbuffer/NNP) )/) is/VBZ true/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARbufferbytelength be VARbuffer.[[ARRAYBUFFERBYTELENGTH]]. 
*0*(S (Chunk let/VB VARbufferbytelength/NNP) (Chunk be/VB VARbuffer/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERBYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARoffset &gt; VARbufferbytelength, throw a rangeerror exception. 
*0*(S if/IN (Chunk VARoffset/NNP) &/CC gt/NN ;/: (Chunk VARbufferbytelength/NNP) ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*if VARbytelength is either not present or undefined, then
*0*(S if/IN (Chunk VARbytelength/NNP) is/VBZ either/RB not/RB present/JJ or/CC undefined/JJ ,/, then/RB)
*1*let VARviewbytelength be VARbufferbytelength - VARoffset. 
*1*(S (Chunk let/VB VARviewbytelength/NNP) (Chunk be/VB VARbufferbytelength/NNP) -/: VARoffset/NN ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARviewbytelength be ? FUNCtoindex(VARbytelength). 
*1*(S (Chunk let/VB VARviewbytelength/NNP) be/VB ?/. (Chunk FUNCtoindex/NNP) (/( (Chunk VARbytelength/NNP) )/) ./.)
*1*if VARoffset+VARviewbytelength &gt; VARbufferbytelength, throw a rangeerror exception. 
*1*(S if/IN (Chunk VARoffset+VARviewbytelength/NNP) &/CC gt/NN ;/: (Chunk VARbufferbytelength/NNP) ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*let VARo be ? FUNCordinarycreatefromconstructor(newtarget, "%dataviewprototype%", « [[DATAVIEW]], [[VIEWEDARRAYBUFFER]], [[BYTELENGTH]], [[BYTEOFFSET]] »). 
*0*(S (Chunk let/VB VARo/NNP) be/VB ?/. (Chunk FUNCordinarycreatefromconstructor/NNP) (/( newtarget/NN ,/, ``/`` %/NN dataviewprototype/NN %/NN ''/'' ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk DATAVIEW/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk BYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARo.[[VIEWEDARRAYBUFFER]] to VARbuffer. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARbuffer/NNP) ./.)
*0*set VARo.[[BYTELENGTH]] to VARviewbytelength. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk BYTELENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARviewbytelength/NNP) ./.)
*0*set VARo.[[BYTEOFFSET]] to VARoffset. 
*0*(S (Chunk set/VBN VARo/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARoffset/NNP) ./.)
*0*return VARo.     
*0*(S return/NN (Chunk VARo/NNP) ./.)
ID= 24.3.4.5
Summary= DataView.prototype.getFloat32 ( byteOffset [ , littleEndian ] )
*0*let VARv be the this value. 
*0*(S (Chunk let/VB VARv/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*(S if/IN (Chunk VARlittleendian/NNP) is/VBZ not/RB present/JJ ,/, let/VB VARlittleendian/JJ be/VB false/JJ ./.)
*0*return ? FUNCgetviewvalue(VARv, VARbyteoffset, VARlittleendian, "float32").     
*0*(S return/NN ?/. (Chunk FUNCgetviewvalue/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARbyteoffset/NNP) ,/, (Chunk VARlittleendian/NNP) ,/, ``/`` float32/NN ''/'' )/) ./.)
ID= 24.3.4.6
Summary= DataView.prototype.getFloat64 ( byteOffset [ , littleEndian ] )
*0*let VARv be the this value. 
*0*(S (Chunk let/VB VARv/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*(S if/IN (Chunk VARlittleendian/NNP) is/VBZ not/RB present/JJ ,/, let/VB VARlittleendian/JJ be/VB false/JJ ./.)
*0*return ? FUNCgetviewvalue(VARv, VARbyteoffset, VARlittleendian, "float64").     
*0*(S return/NN ?/. (Chunk FUNCgetviewvalue/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARbyteoffset/NNP) ,/, (Chunk VARlittleendian/NNP) ,/, ``/`` float64/NN ''/'' )/) ./.)
ID= 24.3.4.7
Summary= DataView.prototype.getInt8 ( byteOffset )
*0*let VARv be the this value. 
*0*(S (Chunk let/VB VARv/NNP) be/VB the/DT this/DT value/NN ./.)
*0*return ? FUNCgetviewvalue(VARv, VARbyteoffset, true, "int8").     
*0*(S return/NN ?/. (Chunk FUNCgetviewvalue/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARbyteoffset/NNP) ,/, true/JJ ,/, ``/`` int8/NN ''/'' )/) ./.)
ID= 24.3.4.8
Summary= DataView.prototype.getInt16 ( byteOffset [ , littleEndian ] )
*0*let VARv be the this value. 
*0*(S (Chunk let/VB VARv/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*(S if/IN (Chunk VARlittleendian/NNP) is/VBZ not/RB present/JJ ,/, let/VB VARlittleendian/JJ be/VB false/JJ ./.)
*0*return ? FUNCgetviewvalue(VARv, VARbyteoffset, VARlittleendian, "int16").     
*0*(S return/NN ?/. (Chunk FUNCgetviewvalue/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARbyteoffset/NNP) ,/, (Chunk VARlittleendian/NNP) ,/, ``/`` int16/NN ''/'' )/) ./.)
ID= 24.3.4.9
Summary= DataView.prototype.getInt32 ( byteOffset [ , littleEndian ] )
*0*let VARv be the this value. 
*0*(S (Chunk let/VB VARv/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*(S if/IN (Chunk VARlittleendian/NNP) is/VBZ not/RB present/JJ ,/, let/VB VARlittleendian/JJ be/VB false/JJ ./.)
*0*return ? FUNCgetviewvalue(VARv, VARbyteoffset, VARlittleendian, "int32").     
*0*(S return/NN ?/. (Chunk FUNCgetviewvalue/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARbyteoffset/NNP) ,/, (Chunk VARlittleendian/NNP) ,/, ``/`` int32/NN ''/'' )/) ./.)
ID= 24.3.4.10
Summary= DataView.prototype.getUint8 ( byteOffset )
*0*let VARv be the this value. 
*0*(S (Chunk let/VB VARv/NNP) be/VB the/DT this/DT value/NN ./.)
*0*return ? FUNCgetviewvalue(VARv, VARbyteoffset, true, "uint8").     
*0*(S return/NN ?/. (Chunk FUNCgetviewvalue/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARbyteoffset/NNP) ,/, true/JJ ,/, ``/`` uint8/JJ ''/'' )/) ./.)
ID= 24.3.4.11
Summary= DataView.prototype.getUint16 ( byteOffset [ , littleEndian ] )
*0*let VARv be the this value. 
*0*(S (Chunk let/VB VARv/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*(S if/IN (Chunk VARlittleendian/NNP) is/VBZ not/RB present/JJ ,/, let/VB VARlittleendian/JJ be/VB false/JJ ./.)
*0*return ? FUNCgetviewvalue(VARv, VARbyteoffset, VARlittleendian, "uint16").     
*0*(S return/NN ?/. (Chunk FUNCgetviewvalue/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARbyteoffset/NNP) ,/, (Chunk VARlittleendian/NNP) ,/, ``/`` uint16/JJ ''/'' )/) ./.)
ID= 24.3.4.12
Summary= DataView.prototype.getUint32 ( byteOffset [ , littleEndian ] )
*0*let VARv be the this value. 
*0*(S (Chunk let/VB VARv/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*(S if/IN (Chunk VARlittleendian/NNP) is/VBZ not/RB present/JJ ,/, let/VB VARlittleendian/JJ be/VB false/JJ ./.)
*0*return ? FUNCgetviewvalue(VARv, VARbyteoffset, VARlittleendian, "uint32").     
*0*(S return/NN ?/. (Chunk FUNCgetviewvalue/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARbyteoffset/NNP) ,/, (Chunk VARlittleendian/NNP) ,/, ``/`` uint32/JJ ''/'' )/) ./.)
ID= 24.3.4.13
Summary= DataView.prototype.setFloat32 ( byteOffset, value [ , littleEndian ] )
*0*let VARv be the this value. 
*0*(S (Chunk let/VB VARv/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*(S if/IN (Chunk VARlittleendian/NNP) is/VBZ not/RB present/JJ ,/, let/VB VARlittleendian/JJ be/VB false/JJ ./.)
*0*return ? FUNCsetviewvalue(VARv, VARbyteoffset, VARlittleendian, "float32", VARvalue).     
*0*(S return/NN ?/. (Chunk FUNCsetviewvalue/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARbyteoffset/NNP) ,/, (Chunk VARlittleendian/NNP) ,/, ``/`` float32/NN ''/'' ,/, (Chunk VARvalue/NNP) )/) ./.)
ID= 24.3.4.14
Summary= DataView.prototype.setFloat64 ( byteOffset, value [ , littleEndian ] )
*0*let VARv be the this value. 
*0*(S (Chunk let/VB VARv/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*(S if/IN (Chunk VARlittleendian/NNP) is/VBZ not/RB present/JJ ,/, let/VB VARlittleendian/JJ be/VB false/JJ ./.)
*0*return ? FUNCsetviewvalue(VARv, VARbyteoffset, VARlittleendian, "float64", VARvalue).     
*0*(S return/NN ?/. (Chunk FUNCsetviewvalue/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARbyteoffset/NNP) ,/, (Chunk VARlittleendian/NNP) ,/, ``/`` float64/NN ''/'' ,/, (Chunk VARvalue/NNP) )/) ./.)
ID= 24.3.4.15
Summary= DataView.prototype.setInt8 ( byteOffset, value )
*0*let VARv be the this value. 
*0*(S (Chunk let/VB VARv/NNP) be/VB the/DT this/DT value/NN ./.)
*0*return ? FUNCsetviewvalue(VARv, VARbyteoffset, true, "int8", VARvalue).     
*0*(S return/NN ?/. (Chunk FUNCsetviewvalue/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARbyteoffset/NNP) ,/, true/JJ ,/, ``/`` int8/NN ''/'' ,/, (Chunk VARvalue/NNP) )/) ./.)
ID= 24.3.4.16
Summary= DataView.prototype.setInt16 ( byteOffset, value [ , littleEndian ] )
*0*let VARv be the this value. 
*0*(S (Chunk let/VB VARv/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*(S if/IN (Chunk VARlittleendian/NNP) is/VBZ not/RB present/JJ ,/, let/VB VARlittleendian/JJ be/VB false/JJ ./.)
*0*return ? FUNCsetviewvalue(VARv, VARbyteoffset, VARlittleendian, "int16", VARvalue).     
*0*(S return/NN ?/. (Chunk FUNCsetviewvalue/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARbyteoffset/NNP) ,/, (Chunk VARlittleendian/NNP) ,/, ``/`` int16/NN ''/'' ,/, (Chunk VARvalue/NNP) )/) ./.)
ID= 24.3.4.17
Summary= DataView.prototype.setInt32 ( byteOffset, value [ , littleEndian ] )
*0*let VARv be the this value. 
*0*(S (Chunk let/VB VARv/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*(S if/IN (Chunk VARlittleendian/NNP) is/VBZ not/RB present/JJ ,/, let/VB VARlittleendian/JJ be/VB false/JJ ./.)
*0*return ? FUNCsetviewvalue(VARv, VARbyteoffset, VARlittleendian, "int32", VARvalue).     
*0*(S return/NN ?/. (Chunk FUNCsetviewvalue/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARbyteoffset/NNP) ,/, (Chunk VARlittleendian/NNP) ,/, ``/`` int32/NN ''/'' ,/, (Chunk VARvalue/NNP) )/) ./.)
ID= 24.3.4.18
Summary= DataView.prototype.setUint8 ( byteOffset, value )
*0*let VARv be the this value. 
*0*(S (Chunk let/VB VARv/NNP) be/VB the/DT this/DT value/NN ./.)
*0*return ? FUNCsetviewvalue(VARv, VARbyteoffset, true, "uint8", VARvalue).     
*0*(S return/NN ?/. (Chunk FUNCsetviewvalue/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARbyteoffset/NNP) ,/, true/JJ ,/, ``/`` uint8/JJ ''/'' ,/, (Chunk VARvalue/NNP) )/) ./.)
ID= 24.3.4.19
Summary= DataView.prototype.setUint16 ( byteOffset, value [ , littleEndian ] )
*0*let VARv be the this value. 
*0*(S (Chunk let/VB VARv/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*(S if/IN (Chunk VARlittleendian/NNP) is/VBZ not/RB present/JJ ,/, let/VB VARlittleendian/JJ be/VB false/JJ ./.)
*0*return ? FUNCsetviewvalue(VARv, VARbyteoffset, VARlittleendian, "uint16", VARvalue).     
*0*(S return/NN ?/. (Chunk FUNCsetviewvalue/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARbyteoffset/NNP) ,/, (Chunk VARlittleendian/NNP) ,/, ``/`` uint16/JJ ''/'' ,/, (Chunk VARvalue/NNP) )/) ./.)
ID= 24.3.4.20
Summary= DataView.prototype.setUint32 ( byteOffset, value [ , littleEndian ] )
*0*let VARv be the this value. 
*0*(S (Chunk let/VB VARv/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*(S if/IN (Chunk VARlittleendian/NNP) is/VBZ not/RB present/JJ ,/, let/VB VARlittleendian/JJ be/VB false/JJ ./.)
*0*return ? FUNCsetviewvalue(VARv, VARbyteoffset, VARlittleendian, "uint32", VARvalue).     
*0*(S return/NN ?/. (Chunk FUNCsetviewvalue/NNP) (/( (Chunk VARv/NNP) ,/, (Chunk VARbyteoffset/NNP) ,/, (Chunk VARlittleendian/NNP) ,/, ``/`` uint32/JJ ''/'' ,/, (Chunk VARvalue/NNP) )/) ./.)
ID= 24.4.1.1
Summary= ValidateSharedIntegerTypedArray ( typedArray [ , onlyInt32 ] )
*0*if VARonlyint32 is not present, set VARonlyint32 to false. 
*0*(S if/IN (Chunk VARonlyint32/NNP) is/VBZ not/RB present/JJ ,/, (Chunk set/VBN VARonlyint32/NNP) to/TO false/VB ./.)
*0*if FUNCtype(VARtypedarray) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtypedarray/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARtypedarray does not have a [[TYPEDARRAYNAME]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARtypedarray/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARtypename be VARtypedarray.[[TYPEDARRAYNAME]]. 
*0*(S (Chunk let/VB VARtypename/NNP) (Chunk be/VB VARtypedarray/NNP) ./. [/VB [/JJ (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARonlyint32 is true, then
*0*(S if/IN (Chunk VARonlyint32/NNP) is/VBZ true/JJ ,/, then/RB)
*1*if VARtypename is not "int32array", throw a typeerror exception. 
*1*(S if/IN (Chunk VARtypename/NNP) is/VBZ not/RB ``/`` int32array/NN ''/'' ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*else,
*0*(S else/RB ,/,)
*1*if VARtypename is not "int8array", "uint8array", "int16array", "uint16array", "int32array", or "uint32array", throw a typeerror exception. 
*1*(S if/IN (Chunk VARtypename/NNP) is/VBZ not/RB ``/`` int8array/NN ''/'' ,/, ``/`` uint8array/NN ''/'' ,/, ``/`` int16array/NN ''/'' ,/, ``/`` uint16array/NN ''/'' ,/, ``/`` int32array/NN ''/'' ,/, or/CC ``/`` uint32array/JJ ''/'' ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: VARtypedarray has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*(S assert/NN :/: VARtypedarray/NN has/VBZ a/DT [/JJ [/NN (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*let VARbuffer be VARtypedarray.[[VIEWEDARRAYBUFFER]]. 
*0*(S (Chunk let/VB VARbuffer/NNP) (Chunk be/VB VARtypedarray/NNP) ./. [/VB [/JJ (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if FUNCissharedarraybuffer(VARbuffer) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCissharedarraybuffer/NNP) (/( (Chunk VARbuffer/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARbuffer.     
*0*(S return/NN (Chunk VARbuffer/NNP) ./.)
ID= 24.4.1.2
Summary= ValidateAtomicAccess ( typedArray, requestIndex )
*0*assert: VARtypedarray is an object that has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*(S assert/NN :/: (Chunk VARtypedarray/NNP) is/VBZ an/DT object/NN that/WDT has/VBZ a/DT [/JJ [/NN (Chunk VIEWEDARRAYBUFFER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*let VARaccessindex be ? FUNCtoindex(VARrequestindex). 
*0*(S (Chunk let/VB VARaccessindex/NNP) be/VB ?/. (Chunk FUNCtoindex/NNP) (/( (Chunk VARrequestindex/NNP) )/) ./.)
*0*let VARlength be VARtypedarray.[[ARRAYLENGTH]]. 
*0*(S (Chunk let/VB VARlength/NNP) (Chunk be/VB VARtypedarray/NNP) ./. [/VB [/JJ (Chunk ARRAYLENGTH/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*assert: VARaccessindex ≥ 0. 
*0*(S assert/NN :/: (Chunk VARaccessindex/NNP) ≥/VBD 0/CD ./.)
*0*if VARaccessindex ≥ VARlength, throw a rangeerror exception. 
*0*(S if/IN (Chunk VARaccessindex/NNP) (Chunk ≥/NNP) (Chunk VARlength/NNP) ,/, throw/VBP a/DT rangeerror/NN exception/NN ./.)
*0*return VARaccessindex.     
*0*(S return/NN (Chunk VARaccessindex/NNP) ./.)
ID= 24.4.1.3
Summary= GetWaiterList ( block, i )
*0*assert: VARblock is a shared data block. 
*0*(S assert/NN :/: (Chunk VARblock/NNP) is/VBZ a/DT shared/VBN data/NN block/NN ./.)
*0*assert: VARi and VARi+3 are valid byte offsets within the memory of VARblock. 
*0*(S assert/NN :/: (Chunk VARi/NNP) and/CC (Chunk VARi+3/NNP) are/VBP valid/JJ byte/JJ offsets/NNS within/IN the/DT memory/NN of/IN (Chunk VARblock/NNP) ./.)
*0*assert: VARi is divisible by 4. 
*0*(S assert/NN :/: (Chunk VARi/NNP) is/VBZ divisible/JJ by/IN 4/CD ./.)
*0*return the waiterlist that is referenced by the pair (VARblock, VARi).     
*0*(S return/VB the/DT waiterlist/NN that/WDT is/VBZ referenced/VBN by/IN the/DT pair/NN (/( (Chunk VARblock/NNP) ,/, (Chunk VARi/NNP) )/) ./.)
ID= 24.4.1.4
Summary= EnterCriticalSection ( WL )
*0*assert: the calling agent is not in the critical section for any waiterlist. 
*0*(S assert/NN :/: the/DT calling/VBG agent/NN is/VBZ not/RB in/IN the/DT critical/JJ section/NN for/IN any/DT waiterlist/NN ./.)
*0*wait until no agent is in the critical section for VARwl, then enter the critical section for VARwl (without allowing any other agent to enter).     
*0*(S wait/NN until/IN no/DT agent/NN is/VBZ in/IN the/DT critical/JJ section/NN for/IN (Chunk VARwl/NNP) ,/, then/RB enter/VB the/DT critical/JJ section/NN for/IN (Chunk VARwl/NNP) (/( without/IN allowing/VBG any/DT other/JJ agent/NN to/TO enter/NN )/) ./.)
ID= 24.4.1.5
Summary= LeaveCriticalSection ( WL )
*0*assert: the calling agent is in the critical section for VARwl. 
*0*(S assert/NN :/: the/DT calling/VBG agent/NN is/VBZ in/IN the/DT critical/JJ section/NN for/IN (Chunk VARwl/NNP) ./.)
*0*leave the critical section for VARwl.     
*0*(S leave/VB the/DT critical/JJ section/NN for/IN (Chunk VARwl/NNP) ./.)
ID= 24.4.1.6
Summary= AddWaiter ( WL, W )
*0*assert: the calling agent is in the critical section for VARwl. 
*0*(S assert/NN :/: the/DT calling/VBG agent/NN is/VBZ in/IN the/DT critical/JJ section/NN for/IN (Chunk VARwl/NNP) ./.)
*0*assert: VARw is not on the list of waiters in any waiterlist. 
*0*(S assert/NN :/: (Chunk VARw/NNP) is/VBZ not/RB on/IN the/DT list/NN of/IN waiters/NNS in/IN any/DT waiterlist/NN ./.)
*0*add VARw to the end of the list of waiters in VARwl.     
*0*(S (Chunk add/VB VARw/NNP) to/TO the/DT end/NN of/IN the/DT list/NN of/IN waiters/NNS in/IN (Chunk VARwl/NNP) ./.)
ID= 24.4.1.7
Summary= RemoveWaiter ( WL, W )
*0*assert: the calling agent is in the critical section for VARwl. 
*0*(S assert/NN :/: the/DT calling/VBG agent/NN is/VBZ in/IN the/DT critical/JJ section/NN for/IN (Chunk VARwl/NNP) ./.)
*0*assert: VARw is on the list of waiters in VARwl. 
*0*(S assert/NN :/: (Chunk VARw/NNP) is/VBZ on/IN the/DT list/NN of/IN waiters/NNS in/IN (Chunk VARwl/NNP) ./.)
*0*remove VARw from the list of waiters in VARwl.     
*0*(S (Chunk remove/VB VARw/NNP) from/IN the/DT list/NN of/IN waiters/NNS in/IN (Chunk VARwl/NNP) ./.)
ID= 24.4.1.8
Summary= RemoveWaiters ( WL, c )
*0*assert: the calling agent is in the critical section for VARwl. 
*0*(S assert/NN :/: the/DT calling/VBG agent/NN is/VBZ in/IN the/DT critical/JJ section/NN for/IN (Chunk VARwl/NNP) ./.)
*0*let VARl be a new empty list. 
*0*(S (Chunk let/VB VARl/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARs be a reference to the list of waiters in VARwl. 
*0*(S (Chunk let/VB VARs/NNP) be/VB a/DT reference/NN to/TO the/DT list/NN of/IN waiters/NNS in/IN (Chunk VARwl/NNP) ./.)
*0*repeat, while VARc &gt; 0 and VARs is not an empty list,
*0*(S repeat/NN ,/, while/IN (Chunk VARc/NNP) &/CC gt/NN ;/: 0/CD and/CC (Chunk VARs/NNP) is/VBZ not/RB an/DT empty/JJ list/NN ,/,)
*1*let VARw be the first waiter in VARs. 
*1*(S (Chunk let/VB VARw/NNP) be/VB the/DT first/JJ waiter/NN in/IN (Chunk VARs/NNP) ./.)
*1*add VARw to the end of VARl. 
*1*(S (Chunk add/VB VARw/NNP) to/TO the/DT end/NN of/IN (Chunk VARl/NNP) ./.)
*1*remove VARw from VARs. 
*1*(S (Chunk remove/VB VARw/NNP) from/IN (Chunk VARs/NNP) ./.)
*1*subtract 1 from VARc. 
*1*(S subtract/JJ 1/CD from/IN (Chunk VARc/NNP) ./.)
*0*return VARl.     
*0*(S return/NN (Chunk VARl/NNP) ./.)
ID= 24.4.1.9
Summary= Suspend ( WL, W, timeout )
*0*assert: the calling agent is in the critical section for VARwl. 
*0*(S assert/NN :/: the/DT calling/VBG agent/NN is/VBZ in/IN the/DT critical/JJ section/NN for/IN (Chunk VARwl/NNP) ./.)
*0*assert: VARw is equal to FUNCagentsignifier(). 
*0*(S assert/NN :/: (Chunk VARw/NNP) is/VBZ equal/JJ to/TO (Chunk FUNCagentsignifier/NNP) (/( )/) ./.)
*0*assert: VARw is on the list of waiters in VARwl. 
*0*(S assert/NN :/: (Chunk VARw/NNP) is/VBZ on/IN the/DT list/NN of/IN waiters/NNS in/IN (Chunk VARwl/NNP) ./.)
*0*assert: FUNCagentcansuspend() is true. 
*0*(S assert/NN :/: (Chunk FUNCagentcansuspend/NNP) (/( )/) is/VBZ true/JJ ./.)
*0*perform FUNCleavecriticalsection(VARwl) and suspend VARw for up to VARtimeout milliseconds, performing the combined operation in such a way that a wakeup that arrives after the critical section is exited but before the suspension takes effect is not lost. VARw can wake up either because the timeout expired or because it was woken explicitly by another agent calling FUNCwakewaiter(VARwl, VARw), and not for any other reasons at all. 
*0*(S perform/NN (Chunk FUNCleavecriticalsection/NNP) (/( (Chunk VARwl/NNP) )/) and/CC (Chunk suspend/VBP VARw/NNP) for/IN up/RB to/TO (Chunk VARtimeout/NNP) milliseconds/NNS ,/, performing/VBG the/DT combined/JJ operation/NN in/IN such/JJ a/DT way/NN that/IN a/DT wakeup/NN that/WDT arrives/VBZ after/IN the/DT critical/JJ section/NN is/VBZ exited/VBN but/CC before/IN the/DT suspension/NN takes/VBZ effect/NN is/VBZ not/RB lost/VBN ./. (Chunk VARw/NNP) can/MD wake/VB up/RP either/RB because/IN the/DT timeout/NN expired/VBD or/CC because/IN it/PRP was/VBD woken/VBN explicitly/RB by/IN another/DT agent/NN (Chunk calling/VBG FUNCwakewaiter/NNP) (/( (Chunk VARwl/NNP) ,/, (Chunk VARw/NNP) )/) ,/, and/CC not/RB for/IN any/DT other/JJ reasons/NNS at/IN all/DT ./.)
*0*perform FUNCentercriticalsection(VARwl). 
*0*(S perform/NN (Chunk FUNCentercriticalsection/NNP) (/( (Chunk VARwl/NNP) )/) ./.)
*0*if VARw was woken explicitly by another agent calling FUNCwakewaiter(VARwl, VARw), return true. 
*0*(S if/IN (Chunk VARw/NNP) was/VBD woken/VBN explicitly/RB by/IN another/DT agent/NN (Chunk calling/VBG FUNCwakewaiter/NNP) (/( (Chunk VARwl/NNP) ,/, (Chunk VARw/NNP) )/) ,/, return/VBP true/JJ ./.)
*0*return false.     
*0*(S return/NN false/JJ ./.)
ID= 24.4.1.10
Summary= WakeWaiter ( WL, W )
*0*assert: the calling agent is in the critical section for VARwl. 
*0*(S assert/NN :/: the/DT calling/VBG agent/NN is/VBZ in/IN the/DT critical/JJ section/NN for/IN (Chunk VARwl/NNP) ./.)
*0*assert: VARw is on the list of waiters in VARwl. 
*0*(S assert/NN :/: (Chunk VARw/NNP) is/VBZ on/IN the/DT list/NN of/IN waiters/NNS in/IN (Chunk VARwl/NNP) ./.)
*0*wake the agent VARw.     
*0*(S wake/VB the/DT agent/NN (Chunk VARw/NNP) ./.)
ID= 24.4.1.11
Summary= AtomicReadModifyWrite ( typedArray, index, value, op )
*0*let VARbuffer be ? FUNCvalidatesharedintegertypedarray(VARtypedarray). 
*0*(S (Chunk let/VB VARbuffer/NNP) be/VB ?/. (Chunk FUNCvalidatesharedintegertypedarray/NNP) (/( (Chunk VARtypedarray/NNP) )/) ./.)
*0*let VARi be ? FUNCvalidateatomicaccess(VARtypedarray, VARindex). 
*0*(S (Chunk let/VB VARi/NNP) be/VB ?/. (Chunk FUNCvalidateatomicaccess/NNP) (/( (Chunk VARtypedarray/NNP) ,/, (Chunk VARindex/NNP) )/) ./.)
*0*let VARv be ? FUNCtointeger(VARvalue). 
*0*(S (Chunk let/VB VARv/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*0*let VARarraytypename be VARtypedarray.[[TYPEDARRAYNAME]]. 
*0*(S (Chunk let/VB VARarraytypename/NNP) (Chunk be/VB VARtypedarray/NNP) ./. [/VB [/JJ (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARelementsize be the number value of the element size value specified in table 56 for VARarraytypename. 
*0*(S (Chunk let/VB VARelementsize/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN (Chunk VARarraytypename/NNP) ./.)
*0*let VARelementtype be the string value of the element type value in table 56 for VARarraytypename. 
*0*(S (Chunk let/VB VARelementtype/NNP) be/VB the/DT string/VBG value/NN of/IN the/DT element/NN type/NN value/NN in/IN table/JJ 56/CD for/IN (Chunk VARarraytypename/NNP) ./.)
*0*let VARoffset be VARtypedarray.[[BYTEOFFSET]]. 
*0*(S (Chunk let/VB VARoffset/NNP) (Chunk be/VB VARtypedarray/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARindexedposition be (VARi × VARelementsize) + VARoffset. 
*0*(S (Chunk let/VB VARindexedposition/NNP) be/VB (/( (Chunk VARi/NNP) (Chunk ×/NNP) (Chunk VARelementsize/NNP) )/) +/NN (Chunk VARoffset/NNP) ./.)
*0*return FUNCgetmodifysetvalueinbuffer(VARbuffer, VARindexedposition, VARelementtype, VARv, VARop).     
*0*(S return/NN (Chunk FUNCgetmodifysetvalueinbuffer/NNP) (/( (Chunk VARbuffer/NNP) ,/, (Chunk VARindexedposition/NNP) ,/, (Chunk VARelementtype/NNP) ,/, (Chunk VARv/NNP) ,/, (Chunk VARop/NNP) )/) ./.)
ID= 24.4.1.12
Summary= AtomicLoad ( typedArray, index )
*0*let VARbuffer be ? FUNCvalidatesharedintegertypedarray(VARtypedarray). 
*0*(S (Chunk let/VB VARbuffer/NNP) be/VB ?/. (Chunk FUNCvalidatesharedintegertypedarray/NNP) (/( (Chunk VARtypedarray/NNP) )/) ./.)
*0*let VARi be ? FUNCvalidateatomicaccess(VARtypedarray, VARindex). 
*0*(S (Chunk let/VB VARi/NNP) be/VB ?/. (Chunk FUNCvalidateatomicaccess/NNP) (/( (Chunk VARtypedarray/NNP) ,/, (Chunk VARindex/NNP) )/) ./.)
*0*let VARarraytypename be VARtypedarray.[[TYPEDARRAYNAME]]. 
*0*(S (Chunk let/VB VARarraytypename/NNP) (Chunk be/VB VARtypedarray/NNP) ./. [/VB [/JJ (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARelementsize be the number value of the element size value specified in table 56 for VARarraytypename. 
*0*(S (Chunk let/VB VARelementsize/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN (Chunk VARarraytypename/NNP) ./.)
*0*let VARelementtype be the string value of the element type value in table 56 for VARarraytypename. 
*0*(S (Chunk let/VB VARelementtype/NNP) be/VB the/DT string/VBG value/NN of/IN the/DT element/NN type/NN value/NN in/IN table/JJ 56/CD for/IN (Chunk VARarraytypename/NNP) ./.)
*0*let VARoffset be VARtypedarray.[[BYTEOFFSET]]. 
*0*(S (Chunk let/VB VARoffset/NNP) (Chunk be/VB VARtypedarray/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARindexedposition be (VARi × VARelementsize) + VARoffset. 
*0*(S (Chunk let/VB VARindexedposition/NNP) be/VB (/( (Chunk VARi/NNP) (Chunk ×/NNP) (Chunk VARelementsize/NNP) )/) +/NN (Chunk VARoffset/NNP) ./.)
*0*return FUNCgetvaluefrombuffer(VARbuffer, VARindexedposition, VARelementtype, true, "seqcst").     
*0*(S return/NN (Chunk FUNCgetvaluefrombuffer/NNP) (/( (Chunk VARbuffer/NNP) ,/, (Chunk VARindexedposition/NNP) ,/, (Chunk VARelementtype/NNP) ,/, true/JJ ,/, ``/`` seqcst/NN ''/'' )/) ./.)
ID= 24.4.2
Summary= Atomics.add ( typedArray, index, value )
*0*return ? FUNCatomicreadmodifywrite(VARtypedarray, VARindex, VARvalue, add).    
*0*(S return/NN ?/. (Chunk FUNCatomicreadmodifywrite/NNP) (/( (Chunk VARtypedarray/NNP) ,/, (Chunk VARindex/NNP) ,/, (Chunk VARvalue/NNP) ,/, add/NN )/) ./.)
ID= 24.4.3
Summary= Atomics.and ( typedArray, index, value )
*0*return ? FUNCatomicreadmodifywrite(VARtypedarray, VARindex, VARvalue, and).    
*0*(S return/NN ?/. (Chunk FUNCatomicreadmodifywrite/NNP) (/( (Chunk VARtypedarray/NNP) ,/, (Chunk VARindex/NNP) ,/, (Chunk VARvalue/NNP) ,/, and/CC )/) ./.)
ID= 24.4.4
Summary= Atomics.compareExchange ( typedArray, index, expectedValue, replacementValue )
*0*let VARbuffer be ? FUNCvalidatesharedintegertypedarray(VARtypedarray). 
*0*(S (Chunk let/VB VARbuffer/NNP) be/VB ?/. (Chunk FUNCvalidatesharedintegertypedarray/NNP) (/( (Chunk VARtypedarray/NNP) )/) ./.)
*0*let VARi be ? FUNCvalidateatomicaccess(VARtypedarray, VARindex). 
*0*(S (Chunk let/VB VARi/NNP) be/VB ?/. (Chunk FUNCvalidateatomicaccess/NNP) (/( (Chunk VARtypedarray/NNP) ,/, (Chunk VARindex/NNP) )/) ./.)
*0*let VARexpected be ? FUNCtointeger(VARexpectedvalue). 
*0*(S (Chunk let/VB VARexpected/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARexpectedvalue/NNP) )/) ./.)
*0*let VARreplacement be ? FUNCtointeger(VARreplacementvalue). 
*0*(S (Chunk let/VB VARreplacement/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARreplacementvalue/NNP) )/) ./.)
*0*let VARarraytypename be VARtypedarray.[[TYPEDARRAYNAME]]. 
*0*(S (Chunk let/VB VARarraytypename/NNP) (Chunk be/VB VARtypedarray/NNP) ./. [/VB [/JJ (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARelementtype be the string value of the element type value in table 56 for VARarraytypename. 
*0*(S (Chunk let/VB VARelementtype/NNP) be/VB the/DT string/VBG value/NN of/IN the/DT element/NN type/NN value/NN in/IN table/JJ 56/CD for/IN (Chunk VARarraytypename/NNP) ./.)
*0*let VARislittleendian be the value of the [[LITTLEENDIAN]] field of the surrounding agent's agent record. 
*0*(S let/VB VARislittleendian/JJ be/VB the/DT value/NN of/IN the/DT (Chunk [/NNP) (Chunk [/NNP) (Chunk LITTLEENDIAN/NNP) (Chunk ]/NNP) (Chunk ]/NNP) field/NN of/IN the/DT surrounding/VBG agent/NN 's/POS agent/NN record/NN ./.)
*0*let VARexpectedbytes be FUNCnumbertorawbytes(VARelementtype, VARexpected, VARislittleendian). 
*0*(S (Chunk let/VB VARexpectedbytes/NNP) (Chunk be/VB FUNCnumbertorawbytes/NNP) (/( (Chunk VARelementtype/NNP) ,/, (Chunk VARexpected/NNP) ,/, (Chunk VARislittleendian/NNP) )/) ./.)
*0*let VARelementsize be the number value of the element size value specified in table 56 for VARarraytypename. 
*0*(S (Chunk let/VB VARelementsize/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN (Chunk VARarraytypename/NNP) ./.)
*0*let VARoffset be VARtypedarray.[[BYTEOFFSET]]. 
*0*(S (Chunk let/VB VARoffset/NNP) (Chunk be/VB VARtypedarray/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARindexedposition be (VARi × VARelementsize) + VARoffset. 
*0*(S (Chunk let/VB VARindexedposition/NNP) be/VB (/( (Chunk VARi/NNP) (Chunk ×/NNP) (Chunk VARelementsize/NNP) )/) +/NN (Chunk VARoffset/NNP) ./.)
*0*let compareexchange denote a semantic function of two list of byte values arguments that returns the second argument if the first argument is element-wise equal to VARexpectedbytes. 
*0*(S let/VB compareexchange/NN denote/VB a/DT semantic/JJ function/NN of/IN two/CD list/NN of/IN byte/NN values/NNS arguments/NNS that/WDT returns/VBZ the/DT second/JJ argument/NN if/IN the/DT first/JJ argument/NN is/VBZ element-wise/JJ equal/JJ to/TO VARexpectedbytes/NNS ./.)
*0*return FUNCgetmodifysetvalueinbuffer(VARbuffer, VARindexedposition, VARelementtype, VARreplacement, compareexchange).    
*0*(S return/NN (Chunk FUNCgetmodifysetvalueinbuffer/NNP) (/( (Chunk VARbuffer/NNP) ,/, (Chunk VARindexedposition/NNP) ,/, (Chunk VARelementtype/NNP) ,/, (Chunk VARreplacement/NNP) ,/, compareexchange/NN )/) ./.)
ID= 24.4.5
Summary= Atomics.exchange ( typedArray, index, value )
*0*return ? FUNCatomicreadmodifywrite(VARtypedarray, VARindex, VARvalue, second).    
*0*(S return/NN ?/. (Chunk FUNCatomicreadmodifywrite/NNP) (/( (Chunk VARtypedarray/NNP) ,/, (Chunk VARindex/NNP) ,/, (Chunk VARvalue/NNP) ,/, second/NN )/) ./.)
ID= 24.4.6
Summary= Atomics.isLockFree ( size )
*0*let VARn be ? FUNCtointeger(VARsize). 
*0*(S (Chunk let/VB VARn/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARsize/NNP) )/) ./.)
*0*let VARar be the agent record of the surrounding agent. 
*0*(S (Chunk let/VB VARar/NNP) be/VB the/DT agent/NN record/NN of/IN the/DT surrounding/VBG agent/NN ./.)
*0*if VARn equals 1, return VARar.[[ISLOCKFREE1]]. 
*0*(S if/IN (Chunk VARn/NNP) equals/VBZ 1/CD ,/, return/NN (Chunk VARar/NNP) ./. [/VB [/JJ (Chunk ISLOCKFREE1/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARn equals 2, return VARar.[[ISLOCKFREE2]]. 
*0*(S if/IN (Chunk VARn/NNP) equals/VBZ 2/CD ,/, return/NN (Chunk VARar/NNP) ./. [/VB [/JJ (Chunk ISLOCKFREE2/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARn equals 4, return true. 
*0*(S if/IN (Chunk VARn/NNP) equals/VBZ 4/CD ,/, return/NN true/JJ ./.)
*0*return false.    
*0*(S return/NN false/JJ ./.)
ID= 24.4.7
Summary= Atomics.load ( typedArray, index )
*0*return ? FUNCatomicload(VARtypedarray, VARindex).    
*0*(S return/NN ?/. (Chunk FUNCatomicload/NNP) (/( (Chunk VARtypedarray/NNP) ,/, (Chunk VARindex/NNP) )/) ./.)
ID= 24.4.8
Summary= Atomics.or ( typedArray, index, value )
*0*return ? FUNCatomicreadmodifywrite(VARtypedarray, VARindex, VARvalue, or).    
*0*(S return/NN ?/. (Chunk FUNCatomicreadmodifywrite/NNP) (/( (Chunk VARtypedarray/NNP) ,/, (Chunk VARindex/NNP) ,/, (Chunk VARvalue/NNP) ,/, or/CC )/) ./.)
ID= 24.4.9
Summary= Atomics.store ( typedArray, index, value )
*0*let VARbuffer be ? FUNCvalidatesharedintegertypedarray(VARtypedarray). 
*0*(S (Chunk let/VB VARbuffer/NNP) be/VB ?/. (Chunk FUNCvalidatesharedintegertypedarray/NNP) (/( (Chunk VARtypedarray/NNP) )/) ./.)
*0*let VARi be ? FUNCvalidateatomicaccess(VARtypedarray, VARindex). 
*0*(S (Chunk let/VB VARi/NNP) be/VB ?/. (Chunk FUNCvalidateatomicaccess/NNP) (/( (Chunk VARtypedarray/NNP) ,/, (Chunk VARindex/NNP) )/) ./.)
*0*let VARv be ? FUNCtointeger(VARvalue). 
*0*(S (Chunk let/VB VARv/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*0*let VARarraytypename be VARtypedarray.[[TYPEDARRAYNAME]]. 
*0*(S (Chunk let/VB VARarraytypename/NNP) (Chunk be/VB VARtypedarray/NNP) ./. [/VB [/JJ (Chunk TYPEDARRAYNAME/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARelementsize be the number value of the element size value specified in table 56 for VARarraytypename. 
*0*(S (Chunk let/VB VARelementsize/NNP) be/VB the/DT number/NN value/NN of/IN the/DT element/NN size/NN value/NN specified/VBN in/IN table/JJ 56/CD for/IN (Chunk VARarraytypename/NNP) ./.)
*0*let VARelementtype be the string value of the element type value in table 56 for VARarraytypename. 
*0*(S (Chunk let/VB VARelementtype/NNP) be/VB the/DT string/VBG value/NN of/IN the/DT element/NN type/NN value/NN in/IN table/JJ 56/CD for/IN (Chunk VARarraytypename/NNP) ./.)
*0*let VARoffset be VARtypedarray.[[BYTEOFFSET]]. 
*0*(S (Chunk let/VB VARoffset/NNP) (Chunk be/VB VARtypedarray/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARindexedposition be (VARi × VARelementsize) + VARoffset. 
*0*(S (Chunk let/VB VARindexedposition/NNP) be/VB (/( (Chunk VARi/NNP) (Chunk ×/NNP) (Chunk VARelementsize/NNP) )/) +/NN (Chunk VARoffset/NNP) ./.)
*0*perform FUNCsetvalueinbuffer(VARbuffer, VARindexedposition, VARelementtype, VARv, true, "seqcst"). 
*0*(S perform/NN (Chunk FUNCsetvalueinbuffer/NNP) (/( (Chunk VARbuffer/NNP) ,/, (Chunk VARindexedposition/NNP) ,/, (Chunk VARelementtype/NNP) ,/, (Chunk VARv/NNP) ,/, true/JJ ,/, ``/`` seqcst/NN ''/'' )/) ./.)
*0*return VARv.    
*0*(S return/NN (Chunk VARv/NNP) ./.)
ID= 24.4.10
Summary= Atomics.sub ( typedArray, index, value )
*0*return ? FUNCatomicreadmodifywrite(VARtypedarray, VARindex, VARvalue, subtract).    
*0*(S return/NN ?/. (Chunk FUNCatomicreadmodifywrite/NNP) (/( (Chunk VARtypedarray/NNP) ,/, (Chunk VARindex/NNP) ,/, (Chunk VARvalue/NNP) ,/, subtract/NN )/) ./.)
ID= 24.4.11
Summary= Atomics.wait ( typedArray, index, value, timeout )
*0*let VARbuffer be ? FUNCvalidatesharedintegertypedarray(VARtypedarray, true). 
*0*(S (Chunk let/VB VARbuffer/NNP) be/VB ?/. (Chunk FUNCvalidatesharedintegertypedarray/NNP) (/( (Chunk VARtypedarray/NNP) ,/, true/JJ )/) ./.)
*0*let VARi be ? FUNCvalidateatomicaccess(VARtypedarray, VARindex). 
*0*(S (Chunk let/VB VARi/NNP) be/VB ?/. (Chunk FUNCvalidateatomicaccess/NNP) (/( (Chunk VARtypedarray/NNP) ,/, (Chunk VARindex/NNP) )/) ./.)
*0*let VARv be ? FUNCtoint32(VARvalue). 
*0*(S (Chunk let/VB VARv/NNP) be/VB ?/. (Chunk FUNCtoint32/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*0*let VARq be ? FUNCtonumber(VARtimeout). 
*0*(S (Chunk let/VB VARq/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARtimeout/NNP) )/) ./.)
*0*if VARq is nan, let VARt be +∞, else let VARt be max(VARq, 0). 
*0*(S if/IN (Chunk VARq/NNP) is/VBZ nan/JJ ,/, (Chunk let/VB VARt/NNP) be/VB +∞/VBN ,/, (Chunk else/RB let/VB VARt/NNP) be/VB max/VBN (/( (Chunk VARq/NNP) ,/, 0/CD )/) ./.)
*0*let VARb be FUNCagentcansuspend(). 
*0*(S (Chunk let/VB VARb/NNP) (Chunk be/VB FUNCagentcansuspend/NNP) (/( )/) ./.)
*0*if VARb is false, throw a typeerror exception. 
*0*(S if/IN (Chunk VARb/NNP) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARblock be VARbuffer.[[ARRAYBUFFERDATA]]. 
*0*(S (Chunk let/VB VARblock/NNP) (Chunk be/VB VARbuffer/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARoffset be VARtypedarray.[[BYTEOFFSET]]. 
*0*(S (Chunk let/VB VARoffset/NNP) (Chunk be/VB VARtypedarray/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARindexedposition be (VARi × 4) + VARoffset. 
*0*(S (Chunk let/VB VARindexedposition/NNP) be/VB (/( (Chunk VARi/NNP) (Chunk ×/NNP) 4/CD )/) +/NN (Chunk VARoffset/NNP) ./.)
*0*let VARwl be FUNCgetwaiterlist(VARblock, VARindexedposition). 
*0*(S (Chunk let/VB VARwl/NNP) (Chunk be/VB FUNCgetwaiterlist/NNP) (/( (Chunk VARblock/NNP) ,/, (Chunk VARindexedposition/NNP) )/) ./.)
*0*perform FUNCentercriticalsection(VARwl). 
*0*(S perform/NN (Chunk FUNCentercriticalsection/NNP) (/( (Chunk VARwl/NNP) )/) ./.)
*0*let VARw be ! FUNCatomicload(VARtypedarray, VARi). 
*0*(S (Chunk let/VB VARw/NNP) be/VB !/. (Chunk FUNCatomicload/NNP) (/( (Chunk VARtypedarray/NNP) ,/, (Chunk VARi/NNP) )/) ./.)
*0*if VARv is not equal to VARw, then
*0*(S if/IN (Chunk VARv/NNP) is/VBZ not/RB equal/JJ to/TO (Chunk VARw/NNP) ,/, then/RB)
*1*perform FUNCleavecriticalsection(VARwl). 
*1*(S perform/NN (Chunk FUNCleavecriticalsection/NNP) (/( (Chunk VARwl/NNP) )/) ./.)
*1*return the string "not-equal". 
*1*(S return/VB the/DT string/NN ``/`` not-equal/JJ ''/'' ./.)
*0*let VARw be FUNCagentsignifier(). 
*0*(S (Chunk let/VB VARw/NNP) (Chunk be/VB FUNCagentsignifier/NNP) (/( )/) ./.)
*0*perform FUNCaddwaiter(VARwl, VARw). 
*0*(S perform/NN (Chunk FUNCaddwaiter/NNP) (/( (Chunk VARwl/NNP) ,/, (Chunk VARw/NNP) )/) ./.)
*0*let VARawoken be FUNCsuspend(VARwl, VARw, VARt). 
*0*(S (Chunk let/VB VARawoken/NNP) (Chunk be/VB FUNCsuspend/NNP) (/( (Chunk VARwl/NNP) ,/, (Chunk VARw/NNP) ,/, (Chunk VARt/NNP) )/) ./.)
*0*if VARawoken is true, then
*0*(S if/IN (Chunk VARawoken/NNP) is/VBZ true/JJ ,/, then/RB)
*1*assert: VARw is not on the list of waiters in VARwl. 
*1*(S assert/NN :/: (Chunk VARw/NNP) is/VBZ not/RB on/IN the/DT list/NN of/IN waiters/NNS in/IN (Chunk VARwl/NNP) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*perform FUNCremovewaiter(VARwl, VARw). 
*1*(S perform/NN (Chunk FUNCremovewaiter/NNP) (/( (Chunk VARwl/NNP) ,/, (Chunk VARw/NNP) )/) ./.)
*0*perform FUNCleavecriticalsection(VARwl). 
*0*(S perform/NN (Chunk FUNCleavecriticalsection/NNP) (/( (Chunk VARwl/NNP) )/) ./.)
*0*if VARawoken is true, return the string "ok". 
*0*(S if/IN (Chunk VARawoken/NNP) is/VBZ true/JJ ,/, return/VB the/DT string/NN ``/`` ok/JJ ''/'' ./.)
*0*return the string "timed-out".    
*0*(S return/VB the/DT string/NN ``/`` timed-out/JJ ''/'' ./.)
ID= 24.4.12
Summary= Atomics.wake ( typedArray, index, count )
*0*let VARbuffer be ? FUNCvalidatesharedintegertypedarray(VARtypedarray, true). 
*0*(S (Chunk let/VB VARbuffer/NNP) be/VB ?/. (Chunk FUNCvalidatesharedintegertypedarray/NNP) (/( (Chunk VARtypedarray/NNP) ,/, true/JJ )/) ./.)
*0*let VARi be ? FUNCvalidateatomicaccess(VARtypedarray, VARindex). 
*0*(S (Chunk let/VB VARi/NNP) be/VB ?/. (Chunk FUNCvalidateatomicaccess/NNP) (/( (Chunk VARtypedarray/NNP) ,/, (Chunk VARindex/NNP) )/) ./.)
*0*if VARcount is undefined, let VARc be +∞. 
*0*(S if/IN (Chunk VARcount/NNP) is/VBZ undefined/JJ ,/, (Chunk let/VB VARc/NNP) be/VB +∞/VBN ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARintcount be ? FUNCtointeger(VARcount). 
*1*(S (Chunk let/VB VARintcount/NNP) be/VB ?/. (Chunk FUNCtointeger/NNP) (/( (Chunk VARcount/NNP) )/) ./.)
*1*let VARc be max(VARintcount, 0). 
*1*(S (Chunk let/VB VARc/NNP) be/VB max/VBN (/( (Chunk VARintcount/NNP) ,/, 0/CD )/) ./.)
*0*let VARblock be VARbuffer.[[ARRAYBUFFERDATA]]. 
*0*(S (Chunk let/VB VARblock/NNP) (Chunk be/VB VARbuffer/NNP) ./. [/VB [/JJ (Chunk ARRAYBUFFERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARoffset be VARtypedarray.[[BYTEOFFSET]]. 
*0*(S (Chunk let/VB VARoffset/NNP) (Chunk be/VB VARtypedarray/NNP) ./. [/VB [/JJ (Chunk BYTEOFFSET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARindexedposition be (VARi × 4) + VARoffset. 
*0*(S (Chunk let/VB VARindexedposition/NNP) be/VB (/( (Chunk VARi/NNP) (Chunk ×/NNP) 4/CD )/) +/NN (Chunk VARoffset/NNP) ./.)
*0*let VARwl be FUNCgetwaiterlist(VARblock, VARindexedposition). 
*0*(S (Chunk let/VB VARwl/NNP) (Chunk be/VB FUNCgetwaiterlist/NNP) (/( (Chunk VARblock/NNP) ,/, (Chunk VARindexedposition/NNP) )/) ./.)
*0*let VARn be 0. 
*0*(S (Chunk let/VB VARn/NNP) be/VB 0/CD ./.)
*0*perform FUNCentercriticalsection(VARwl). 
*0*(S perform/NN (Chunk FUNCentercriticalsection/NNP) (/( (Chunk VARwl/NNP) )/) ./.)
*0*let VARs be FUNCremovewaiters(VARwl, VARc). 
*0*(S (Chunk let/VB VARs/NNP) (Chunk be/VB FUNCremovewaiters/NNP) (/( (Chunk VARwl/NNP) ,/, (Chunk VARc/NNP) )/) ./.)
*0*repeat, while VARs is not an empty list,
*0*(S repeat/NN ,/, while/IN (Chunk VARs/NNP) is/VBZ not/RB an/DT empty/JJ list/NN ,/,)
*1*let VARw be the first agent in VARs. 
*1*(S (Chunk let/VB VARw/NNP) be/VB the/DT first/JJ agent/NN in/IN (Chunk VARs/NNP) ./.)
*1*remove VARw from the front of VARs. 
*1*(S (Chunk remove/VB VARw/NNP) from/IN the/DT front/NN of/IN (Chunk VARs/NNP) ./.)
*1*perform FUNCwakewaiter(VARwl, VARw). 
*1*(S perform/NN (Chunk FUNCwakewaiter/NNP) (/( (Chunk VARwl/NNP) ,/, (Chunk VARw/NNP) )/) ./.)
*1*add 1 to VARn. 
*1*(S add/RB 1/CD to/TO (Chunk VARn/NNP) ./.)
*0*perform FUNCleavecriticalsection(VARwl). 
*0*(S perform/NN (Chunk FUNCleavecriticalsection/NNP) (/( (Chunk VARwl/NNP) )/) ./.)
*0*return VARn.    
*0*(S return/NN (Chunk VARn/NNP) ./.)
ID= 24.4.13
Summary= Atomics.xor ( typedArray, index, value )
*0*return ? FUNCatomicreadmodifywrite(VARtypedarray, VARindex, VARvalue, xor).    
*0*(S return/NN ?/. (Chunk FUNCatomicreadmodifywrite/NNP) (/( (Chunk VARtypedarray/NNP) ,/, (Chunk VARindex/NNP) ,/, (Chunk VARvalue/NNP) ,/, (Chunk xor/NNP) )/) ./.)
ID= 24.5.1
Summary= JSON.parse ( text [ , reviver ] )
*0*let VARjtext be ? FUNCtostring(VARtext). 
*0*(S (Chunk let/VB VARjtext/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARtext/NNP) )/) ./.)
*0*parse VARjtext interpreted as utf-16 encoded unicode points (6.1.4) as a json text as specified in ecma-404. throw a syntaxerror exception if VARjtext is not a valid json text as defined in that specification. 
*0*(S parse/NN (Chunk VARjtext/NNP) interpreted/VBD as/IN utf-16/JJ encoded/VBD unicode/JJ points/NNS (/( 6.1.4/CD )/) as/IN a/DT json/NN text/NN as/IN specified/VBN in/IN ecma-404/NN ./. throw/VB a/DT syntaxerror/NN exception/NN if/IN (Chunk VARjtext/NNP) is/VBZ not/RB a/DT valid/JJ json/NN text/NN as/IN defined/VBN in/IN that/DT specification/NN ./.)
*0*let VARscripttext be the string-concatenation of "(", VARjtext, and ");". 
*0*(S (Chunk let/VB VARscripttext/NNP) be/VB the/DT string-concatenation/NN of/IN ``/`` (/( ``/`` ,/, (Chunk VARjtext/NNP) ,/, and/CC ``/`` )/) ;/: ''/'' ./.)
*0*let VARcompletion be the result of parsing and evaluating VARscripttext as if it was the source text of an ecmascript script, but using the alternative definition of doublestringcharacter provided below. the extended propertydefinitionevaluation semantics defined in b.3.1 must not be used during the evaluation. 
*0*(S (Chunk let/VB VARcompletion/NNP) be/VB the/DT result/NN of/IN parsing/NN and/CC (Chunk evaluating/VBG VARscripttext/NNP) as/IN if/IN it/PRP was/VBD the/DT source/NN text/NN of/IN an/DT ecmascript/JJ script/NN ,/, but/CC using/VBG the/DT alternative/JJ definition/NN of/IN doublestringcharacter/NN provided/VBN below/IN ./. the/DT extended/JJ propertydefinitionevaluation/NN semantics/NNS defined/VBD in/IN b.3.1/NN must/MD not/RB be/VB used/VBN during/IN the/DT evaluation/NN ./.)
*0*let VARunfiltered be VARcompletion.[[VALUE]]. 
*0*(S (Chunk let/VB VARunfiltered/NNP) (Chunk be/VB VARcompletion/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*assert: VARunfiltered is either a string, number, boolean, null, or an object that is defined by either an arrayliteral or an objectliteral. 
*0*(S assert/NN :/: (Chunk VARunfiltered/NNP) is/VBZ either/CC a/DT string/NN ,/, number/NN ,/, boolean/JJ ,/, null/JJ ,/, or/CC an/DT object/NN that/WDT is/VBZ defined/VBN by/IN either/DT an/DT arrayliteral/JJ or/CC an/DT objectliteral/JJ ./.)
*0*if FUNCiscallable(VARreviver) is true, then
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARreviver/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*let VARroot be FUNCobjectcreate(%objectprototype%). 
*1*(S (Chunk let/VB VARroot/NNP) (Chunk be/VB FUNCobjectcreate/NNP) (/( %/NN objectprototype/IN %/NN )/) ./.)
*1*let VARrootname be the empty string. 
*1*(S (Chunk let/VB VARrootname/NNP) be/VB the/DT empty/JJ string/NN ./.)
*1*let VARstatus be FUNCcreatedataproperty(VARroot, VARrootname, VARunfiltered). 
*1*(S (Chunk let/VB VARstatus/NNP) (Chunk be/VB FUNCcreatedataproperty/NNP) (/( (Chunk VARroot/NNP) ,/, (Chunk VARrootname/NNP) ,/, (Chunk VARunfiltered/NNP) )/) ./.)
*1*assert: VARstatus is true. 
*1*(S assert/NN :/: (Chunk VARstatus/NNP) is/VBZ true/JJ ./.)
*1*return ? FUNCinternalizejsonproperty(VARroot, VARrootname). 
*1*(S return/NN ?/. (Chunk FUNCinternalizejsonproperty/NNP) (/( (Chunk VARroot/NNP) ,/, (Chunk VARrootname/NNP) )/) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*return VARunfiltered.    
*1*(S return/NN (Chunk VARunfiltered/NNP) ./.)
ID= 24.5.1.1
Summary= Runtime Semantics: InternalizeJSONProperty ( holder, name )
*0*let VARval be ? FUNCget(VARholder, VARname). 
*0*(S (Chunk let/VB VARval/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARholder/NNP) ,/, (Chunk VARname/NNP) )/) ./.)
*0*if FUNCtype(VARval) is object, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARval/NNP) )/) is/VBZ object/JJ ,/, then/RB)
*1*let VARisarray be ? FUNCisarray(VARval). 
*1*(S (Chunk let/VB VARisarray/NNP) be/VB ?/. (Chunk FUNCisarray/NNP) (/( (Chunk VARval/NNP) )/) ./.)
*1*if VARisarray is true, then
*1*(S if/IN (Chunk VARisarray/NNP) is/VBZ true/JJ ,/, then/RB)
*2*let VARi be 0. 
*2*(S (Chunk let/VB VARi/NNP) be/VB 0/CD ./.)
*2*let VARlen be ? FUNCtolength(? FUNCget(VARval, "length")). 
*2*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARval/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*2*repeat, while VARi &lt; VARlen,
*2*(S repeat/NN ,/, while/IN (Chunk VARi/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP) ,/,)
*3*let VARnewelement be ? FUNCinternalizejsonproperty(VARval, ! FUNCtostring(VARi)). 
*3*(S (Chunk let/VB VARnewelement/NNP) be/VB ?/. (Chunk FUNCinternalizejsonproperty/NNP) (/( (Chunk VARval/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARi/NNP) )/) )/) ./.)
*3*if VARnewelement is undefined, then
*3*(S if/IN (Chunk VARnewelement/NNP) is/VBZ undefined/VBN ,/, then/RB)
*4*perform ? VARval.[[DELETE]](! FUNCtostring(VARi)). 
*4*(S perform/NN ?/. (Chunk VARval./NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk DELETE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARi/NNP) )/) )/) ./.)
*3*else,
*3*(S else/RB ,/,)
*4*perform ? FUNCcreatedataproperty(VARval, ! FUNCtostring(VARi), VARnewelement). 
*4*(S perform/NN ?/. (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARval/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARi/NNP) )/) ,/, (Chunk VARnewelement/NNP) )/) ./.)
*4*note: this algorithm intentionally does not throw an exception if createdataproperty returns false. 
*4*(S note/NN :/: this/DT algorithm/VBZ intentionally/RB does/VBZ not/RB throw/VB an/DT exception/NN if/IN createdataproperty/JJ returns/NNS false/RB ./.)
*3*add 1 to VARi. 
*3*(S add/RB 1/CD to/TO (Chunk VARi/NNP) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*let VARkeys be ? FUNCenumerableownpropertynames(VARval, "key"). 
*2*(S (Chunk let/VB VARkeys/NNP) be/VB ?/. (Chunk FUNCenumerableownpropertynames/NNP) (/( (Chunk VARval/NNP) ,/, ``/`` key/JJ ''/'' )/) ./.)
*2*for each string VARp in VARkeys, do
*2*(S for/IN each/DT string/NN (Chunk VARp/NNP) in/IN (Chunk VARkeys/NNP) ,/, do/VBP)
*3*let VARnewelement be ? FUNCinternalizejsonproperty(VARval, VARp). 
*3*(S (Chunk let/VB VARnewelement/NNP) be/VB ?/. (Chunk FUNCinternalizejsonproperty/NNP) (/( (Chunk VARval/NNP) ,/, (Chunk VARp/NNP) )/) ./.)
*3*if VARnewelement is undefined, then
*3*(S if/IN (Chunk VARnewelement/NNP) is/VBZ undefined/VBN ,/, then/RB)
*4*perform ? VARval.[[DELETE]](VARp). 
*4*(S perform/NN ?/. (Chunk VARval/NNP) ./. [/VB [/JJ (Chunk DELETE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*3*else,
*3*(S else/RB ,/,)
*4*perform ? FUNCcreatedataproperty(VARval, VARp, VARnewelement). 
*4*(S perform/NN ?/. (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARval/NNP) ,/, (Chunk VARp/NNP) ,/, (Chunk VARnewelement/NNP) )/) ./.)
*4*note: this algorithm intentionally does not throw an exception if createdataproperty returns false. 
*4*(S note/NN :/: this/DT algorithm/VBZ intentionally/RB does/VBZ not/RB throw/VB an/DT exception/NN if/IN createdataproperty/JJ returns/NNS false/RB ./.)
*0*return ? FUNCcall(VARreviver, VARholder, « VARname, VARval »).     
*0*(S return/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARreviver/NNP) ,/, (Chunk VARholder/NNP) ,/, (Chunk «/NNP) (Chunk VARname/NNP) ,/, (Chunk VARval/NNP) (Chunk »/NNP) )/) ./.)
ID= 24.5.2
Summary= JSON.stringify ( value [ , replacer [ , space ] ] )
*0*let VARstack be a new empty list. 
*0*(S (Chunk let/VB VARstack/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARindent be the empty string. 
*0*(S (Chunk let/VB VARindent/NNP) be/VB the/DT empty/JJ string/NN ./.)
*0*let VARpropertylist and VARreplacerfunction be undefined. 
*0*(S (Chunk let/VB VARpropertylist/NNP) and/CC (Chunk VARreplacerfunction/NNP) be/VB undefined/VBN ./.)
*0*if FUNCtype(VARreplacer) is object, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARreplacer/NNP) )/) is/VBZ object/JJ ,/, then/RB)
*1*if FUNCiscallable(VARreplacer) is true, then
*1*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARreplacer/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*let VARreplacerfunction be VARreplacer. 
*2*(S (Chunk let/VB VARreplacerfunction/NNP) (Chunk be/VB VARreplacer/NNP) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*let VARisarray be ? FUNCisarray(VARreplacer). 
*2*(S (Chunk let/VB VARisarray/NNP) be/VB ?/. (Chunk FUNCisarray/NNP) (/( (Chunk VARreplacer/NNP) )/) ./.)
*2*if VARisarray is true, then
*2*(S if/IN (Chunk VARisarray/NNP) is/VBZ true/JJ ,/, then/RB)
*3*let VARpropertylist be a new empty list. 
*3*(S (Chunk let/VB VARpropertylist/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*3*let VARlen be ? FUNCtolength(? FUNCget(VARreplacer, "length")). 
*3*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARreplacer/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*3*let VARk be 0. 
*3*(S (Chunk let/VB VARk/NNP) be/VB 0/CD ./.)
*3*repeat, while VARk&lt;VARlen,
*3*(S repeat/NN ,/, while/IN (Chunk VARk/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP) ,/,)
*4*let VARv be ? FUNCget(VARreplacer, ! FUNCtostring(VARk)). 
*4*(S (Chunk let/VB VARv/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARreplacer/NNP) ,/, !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARk/NNP) )/) )/) ./.)
*4*let VARitem be undefined. 
*4*(S (Chunk let/VB VARitem/NNP) be/VB undefined/VBN ./.)
*4*if FUNCtype(VARv) is string, let VARitem be VARv. 
*4*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ string/VBG ,/, (Chunk let/VB VARitem/NNP) (Chunk be/VB VARv/NNP) ./.)
*4*else if FUNCtype(VARv) is number, let VARitem be ! FUNCtostring(VARv). 
*4*(S else/RB if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ number/NN ,/, (Chunk let/VB VARitem/NNP) be/VB !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARv/NNP) )/) ./.)
*4*else if FUNCtype(VARv) is object, then
*4*(S else/RB if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARv/NNP) )/) is/VBZ object/JJ ,/, then/RB)
*5*if VARv has a [[STRINGDATA]] or [[NUMBERDATA]] internal slot, let VARitem be ? FUNCtostring(VARv). 
*5*(S if/IN (Chunk VARv/NNP) has/VBZ a/DT [/JJ [/NN (Chunk STRINGDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) or/CC (Chunk [/NNP) (Chunk [/NNP) (Chunk NUMBERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, (Chunk let/VB VARitem/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARv/NNP) )/) ./.)
*4*if VARitem is not undefined and VARitem is not currently an element of VARpropertylist, then
*4*(S if/IN (Chunk VARitem/NNP) is/VBZ not/RB undefined/JJ and/CC (Chunk VARitem/NNP) is/VBZ not/RB currently/RB an/DT element/NN of/IN (Chunk VARpropertylist/NNP) ,/, then/RB)
*5*append VARitem to the end of VARpropertylist. 
*5*(S append/NN (Chunk VARitem/NNP) to/TO the/DT end/NN of/IN (Chunk VARpropertylist/NNP) ./.)
*4*let VARk be VARk+1. 
*4*(S (Chunk let/VB VARk/NNP) (Chunk be/VB VARk+1/NNP) ./.)
*0*if FUNCtype(VARspace) is object, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARspace/NNP) )/) is/VBZ object/JJ ,/, then/RB)
*1*if VARspace has a [[NUMBERDATA]] internal slot, then
*1*(S if/IN (Chunk VARspace/NNP) has/VBZ a/DT [/JJ [/NN (Chunk NUMBERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, then/RB)
*2*let VARspace be ? FUNCtonumber(VARspace). 
*2*(S (Chunk let/VB VARspace/NNP) be/VB ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARspace/NNP) )/) ./.)
*1*else if VARspace has a [[STRINGDATA]] internal slot, then
*1*(S else/RB if/IN (Chunk VARspace/NNP) has/VBZ a/DT [/JJ [/NN (Chunk STRINGDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, then/RB)
*2*let VARspace be ? FUNCtostring(VARspace). 
*2*(S (Chunk let/VB VARspace/NNP) be/VB ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARspace/NNP) )/) ./.)
*0*if FUNCtype(VARspace) is number, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARspace/NNP) )/) is/VBZ number/NN ,/, then/RB)
*1*let VARspace be min(10, FUNCtointeger(VARspace)). 
*1*(S (Chunk let/VB VARspace/NNP) be/VB min/VBN (/( 10/CD ,/, (Chunk FUNCtointeger/NNP) (/( (Chunk VARspace/NNP) )/) )/) ./.)
*1*set VARgap to the string value containing VARspace occurrences of the code unit 0x0020 (space). this will be the empty string if VARspace is less than 1. 
*1*(S (Chunk set/VBN VARgap/NNP) to/TO the/DT string/VBG value/NN (Chunk containing/VBG VARspace/NNP) occurrences/NNS of/IN the/DT code/NN unit/NN 0x0020/CD (/( space/NN )/) ./. this/DT will/MD be/VB the/DT empty/JJ string/NN if/IN (Chunk VARspace/NNP) is/VBZ less/JJR than/IN 1/CD ./.)
*0*else if FUNCtype(VARspace) is string, then
*0*(S else/RB if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARspace/NNP) )/) is/VBZ string/VBG ,/, then/RB)
*1*if the length of VARspace is 10 or less, set VARgap to VARspace; otherwise set VARgap to the string value consisting of the first 10 elements of VARspace. 
*1*(S if/IN the/DT length/NN of/IN (Chunk VARspace/NNP) is/VBZ 10/CD or/CC less/JJR ,/, (Chunk set/VBN VARgap/NNP) to/TO (Chunk VARspace/NNP) ;/: (Chunk otherwise/RB set/VB VARgap/NNP) to/TO the/DT string/VBG value/NN consisting/NN of/IN the/DT first/JJ 10/CD elements/NNS of/IN (Chunk VARspace/NNP) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*set VARgap to the empty string. 
*1*(S (Chunk set/VBN VARgap/NNP) to/TO the/DT empty/JJ string/NN ./.)
*0*let VARwrapper be FUNCobjectcreate(%objectprototype%). 
*0*(S (Chunk let/VB VARwrapper/NNP) (Chunk be/VB FUNCobjectcreate/NNP) (/( %/NN objectprototype/IN %/NN )/) ./.)
*0*let VARstatus be FUNCcreatedataproperty(VARwrapper, the empty string, VARvalue). 
*0*(S (Chunk let/VB VARstatus/NNP) (Chunk be/VB FUNCcreatedataproperty/NNP) (/( (Chunk VARwrapper/NNP) ,/, the/DT empty/JJ string/NN ,/, (Chunk VARvalue/NNP) )/) ./.)
*0*assert: VARstatus is true. 
*0*(S assert/NN :/: (Chunk VARstatus/NNP) is/VBZ true/JJ ./.)
*0*return ? FUNCserializejsonproperty(the empty string, VARwrapper).    
*0*(S return/NN ?/. (Chunk FUNCserializejsonproperty/NNP) (/( the/DT empty/NN string/NN ,/, (Chunk VARwrapper/NNP) )/) ./.)
ID= 24.5.2.1
Summary= Runtime Semantics: SerializeJSONProperty ( key, holder )
*0*let VARvalue be ? FUNCget(VARholder, VARkey). 
*0*(S (Chunk let/VB VARvalue/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARholder/NNP) ,/, (Chunk VARkey/NNP) )/) ./.)
*0*if FUNCtype(VARvalue) is object, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARvalue/NNP) )/) is/VBZ object/JJ ,/, then/RB)
*1*let VARtojson be ? FUNCget(VARvalue, "tojson"). 
*1*(S (Chunk let/VB VARtojson/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARvalue/NNP) ,/, ``/`` tojson/NN ''/'' )/) ./.)
*1*if FUNCiscallable(VARtojson) is true, then
*1*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARtojson/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*2*set VARvalue to ? FUNCcall(VARtojson, VARvalue, « VARkey »). 
*2*(S (Chunk set/VBN VARvalue/NNP) to/TO ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARtojson/NNP) ,/, (Chunk VARvalue/NNP) ,/, (Chunk «/NNP) (Chunk VARkey/NNP) (Chunk »/NNP) )/) ./.)
*0*if VARreplacerfunction is not undefined, then
*0*(S if/IN (Chunk VARreplacerfunction/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*1*set VARvalue to ? FUNCcall(VARreplacerfunction, VARholder, « VARkey, VARvalue »). 
*1*(S (Chunk set/VBN VARvalue/NNP) to/TO ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARreplacerfunction/NNP) ,/, (Chunk VARholder/NNP) ,/, (Chunk «/NNP) (Chunk VARkey/NNP) ,/, (Chunk VARvalue/NNP) (Chunk »/NNP) )/) ./.)
*0*if FUNCtype(VARvalue) is object, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARvalue/NNP) )/) is/VBZ object/JJ ,/, then/RB)
*1*if VARvalue has a [[NUMBERDATA]] internal slot, then
*1*(S if/IN (Chunk VARvalue/NNP) has/VBZ a/DT [/JJ [/NN (Chunk NUMBERDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, then/RB)
*2*set VARvalue to ? FUNCtonumber(VARvalue). 
*2*(S (Chunk set/VBN VARvalue/NNP) to/TO ?/. (Chunk FUNCtonumber/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*1*else if VARvalue has a [[STRINGDATA]] internal slot, then
*1*(S else/RB if/IN (Chunk VARvalue/NNP) has/VBZ a/DT [/JJ [/NN (Chunk STRINGDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, then/RB)
*2*set VARvalue to ? FUNCtostring(VARvalue). 
*2*(S (Chunk set/VBN VARvalue/NNP) to/TO ?/. (Chunk FUNCtostring/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*1*else if VARvalue has a [[BOOLEANDATA]] internal slot, then
*1*(S else/RB if/IN (Chunk VARvalue/NNP) has/VBZ a/DT [/JJ [/NN (Chunk BOOLEANDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, then/RB)
*2*set VARvalue to VARvalue.[[BOOLEANDATA]]. 
*2*(S (Chunk set/VBN VARvalue/NNP) to/TO (Chunk VARvalue/NNP) ./. [/VB [/JJ (Chunk BOOLEANDATA/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARvalue is null, return "null". 
*0*(S if/IN (Chunk VARvalue/NNP) is/VBZ null/JJ ,/, return/VB ``/`` null/JJ ''/'' ./.)
*0*if VARvalue is true, return "true". 
*0*(S if/IN (Chunk VARvalue/NNP) is/VBZ true/JJ ,/, return/VB ``/`` true/JJ ''/'' ./.)
*0*if VARvalue is false, return "false". 
*0*(S if/IN (Chunk VARvalue/NNP) is/VBZ false/JJ ,/, return/VB ``/`` false/JJ ''/'' ./.)
*0*if FUNCtype(VARvalue) is string, return FUNCquotejsonstring(VARvalue). 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARvalue/NNP) )/) is/VBZ string/VBG ,/, return/NN (Chunk FUNCquotejsonstring/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*0*if FUNCtype(VARvalue) is number, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARvalue/NNP) )/) is/VBZ number/NN ,/, then/RB)
*1*if VARvalue is finite, return ! FUNCtostring(VARvalue). 
*1*(S if/IN (Chunk VARvalue/NNP) is/VBZ finite/JJ ,/, return/NN !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*1*return "null". 
*1*(S return/NN ``/`` null/JJ ''/'' ./.)
*0*if FUNCtype(VARvalue) is object and FUNCiscallable(VARvalue) is false, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARvalue/NNP) )/) is/VBZ object/JJ and/CC (Chunk FUNCiscallable/NNP) (/( (Chunk VARvalue/NNP) )/) is/VBZ false/JJ ,/, then/RB)
*1*let VARisarray be ? FUNCisarray(VARvalue). 
*1*(S (Chunk let/VB VARisarray/NNP) be/VB ?/. (Chunk FUNCisarray/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*1*if VARisarray is true, return ? FUNCserializejsonarray(VARvalue). 
*1*(S if/IN (Chunk VARisarray/NNP) is/VBZ true/JJ ,/, return/VB ?/. (Chunk FUNCserializejsonarray/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*1*return ? FUNCserializejsonobject(VARvalue). 
*1*(S return/NN ?/. (Chunk FUNCserializejsonobject/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*0*return undefined.     
*0*(S return/NN undefined/VBD ./.)
ID= 24.5.2.2
Summary= Runtime Semantics: QuoteJSONString ( value )
*0*let VARproduct be the string value consisting solely of the code unit 0x0022 (quotation mark). 
*0*(S (Chunk let/VB VARproduct/NNP) be/VB the/DT string/VBG value/NN consisting/VBG solely/RB of/IN the/DT code/NN unit/NN 0x0022/CD (/( quotation/NN mark/NN )/) ./.)
*0*for each code unit VARc in VARvalue, do
*0*(S for/IN each/DT code/NN unit/NN (Chunk VARc/NNP) in/IN (Chunk VARvalue/NNP) ,/, do/VBP)
*1*if the numeric value of VARc is listed in the code unit value column of table 59, then
*1*(S if/IN the/DT numeric/JJ value/NN of/IN (Chunk VARc/NNP) is/VBZ listed/VBN in/IN the/DT code/NN unit/NN value/NN column/NN of/IN table/JJ 59/CD ,/, then/RB)
*2*set VARproduct to the string-concatenation of VARproduct and the escape sequence for VARc as specified in table 59. 
*2*(S set/VBN VARproduct/NN to/TO the/DT string-concatenation/NN of/IN (Chunk VARproduct/NNP) and/CC the/DT escape/NN sequence/NN for/IN (Chunk VARc/NNP) as/IN specified/VBN in/IN table/JJ 59/CD ./.)
*1*else if VARc has a numeric value less than 0x0020 (space), then
*1*(S else/RB if/IN (Chunk VARc/NNP) has/VBZ a/DT numeric/JJ value/NN less/JJR than/IN 0x0020/CD (/( space/NN )/) ,/, then/RB)
*2*set VARproduct to the FUNCstring-concatenation of VARproduct and unicodeescape(VARc). 
*2*(S set/VBN VARproduct/NN to/TO the/DT (Chunk FUNCstring-concatenation/NNP) of/IN (Chunk VARproduct/NNP) and/CC unicodeescape/NN (/( (Chunk VARc/NNP) )/) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*set VARproduct to the string-concatenation of VARproduct and VARc. 
*2*(S set/VBN VARproduct/NN to/TO the/DT string-concatenation/NN of/IN (Chunk VARproduct/NNP) and/CC (Chunk VARc/NNP) ./.)
*0*set VARproduct to the string-concatenation of VARproduct and the code unit 0x0022 (quotation mark). 
*0*(S set/VBN VARproduct/NN to/TO the/DT string-concatenation/NN of/IN (Chunk VARproduct/NNP) and/CC the/DT code/NN unit/NN 0x0022/CD (/( quotation/NN mark/NN )/) ./.)
*0*return VARproduct.     
*0*(S return/NN (Chunk VARproduct/NNP) ./.)
ID= 24.5.2.3
Summary= Runtime Semantics: UnicodeEscape ( C )
*0*let VARn be the numeric value of VARc. 
*0*(S (Chunk let/VB VARn/NNP) be/VB the/DT numeric/JJ value/NN of/IN (Chunk VARc/NNP) ./.)
*0*assert: VARn ≤ 0xffff. 
*0*(S assert/NN :/: (Chunk VARn/NNP) ≤/VBZ 0xffff/CD ./.)
*0*return the string-concatenation of:the code unit 0x005c (reverse solidus) "u" the string representation of VARn, formatted as a four-digit lowercase hexadecimal number, padded to the left with zeroes if necessary     
*0*(S return/VB the/DT string-concatenation/NN of/IN :/: the/DT code/NN unit/NN 0x005c/CD (/( reverse/VB solidus/NN )/) ``/`` u/JJ ''/'' the/DT string/NN representation/NN of/IN (Chunk VARn/NNP) ,/, formatted/VBD as/IN a/DT four-digit/JJ lowercase/NN hexadecimal/JJ number/NN ,/, padded/VBD to/TO the/DT left/NN with/IN zeroes/NNS if/IN necessary/JJ)
ID= 24.5.2.4
Summary= Runtime Semantics: SerializeJSONObject ( value )
*0*if VARstack contains VARvalue, throw a typeerror exception because the structure is cyclical. 
*0*(S if/IN (Chunk VARstack/NNP) (Chunk contains/VBZ VARvalue/NNP) ,/, throw/VBP a/DT typeerror/NN exception/NN because/IN the/DT structure/NN is/VBZ cyclical/JJ ./.)
*0*append VARvalue to VARstack. 
*0*(S (Chunk append/VB VARvalue/NNP) to/TO (Chunk VARstack/NNP) ./.)
*0*let VARstepback be VARindent. 
*0*(S (Chunk let/VB VARstepback/NNP) (Chunk be/VB VARindent/NNP) ./.)
*0*set VARindent to the string-concatenation of VARindent and VARgap. 
*0*(S (Chunk set/VBN VARindent/NNP) to/TO the/DT string-concatenation/NN of/IN (Chunk VARindent/NNP) and/CC (Chunk VARgap/NNP) ./.)
*0*if VARpropertylist is not undefined, then
*0*(S if/IN (Chunk VARpropertylist/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*1*let VARk be VARpropertylist. 
*1*(S (Chunk let/VB VARk/NNP) (Chunk be/VB VARpropertylist/NNP) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARk be ? FUNCenumerableownpropertynames(VARvalue, "key"). 
*1*(S (Chunk let/VB VARk/NNP) be/VB ?/. (Chunk FUNCenumerableownpropertynames/NNP) (/( (Chunk VARvalue/NNP) ,/, ``/`` key/JJ ''/'' )/) ./.)
*0*let VARpartial be a new empty list. 
*0*(S (Chunk let/VB VARpartial/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*for each element VARp of VARk, do
*0*(S for/IN each/DT element/NN (Chunk VARp/NNP) of/IN (Chunk VARk/NNP) ,/, do/VBP)
*1*let VARstrp be ? FUNCserializejsonproperty(VARp, VARvalue). 
*1*(S (Chunk let/VB VARstrp/NNP) be/VB ?/. (Chunk FUNCserializejsonproperty/NNP) (/( (Chunk VARp/NNP) ,/, (Chunk VARvalue/NNP) )/) ./.)
*1*if VARstrp is not undefined, then
*1*(S if/IN (Chunk VARstrp/NNP) is/VBZ not/RB undefined/JJ ,/, then/RB)
*2*let VARmember be FUNCquotejsonstring(VARp). 
*2*(S (Chunk let/VB VARmember/NNP) (Chunk be/VB FUNCquotejsonstring/NNP) (/( (Chunk VARp/NNP) )/) ./.)
*2*set VARmember to the string-concatenation of VARmember and ":". 
*2*(S (Chunk set/VBN VARmember/NNP) to/TO the/DT string-concatenation/NN of/IN (Chunk VARmember/NNP) and/CC ``/`` :/: ''/'' ./.)
*2*if VARgap is not the empty string, then
*2*(S if/IN (Chunk VARgap/NNP) is/VBZ not/RB the/DT empty/JJ string/NN ,/, then/RB)
*3*set VARmember to the string-concatenation of VARmember and the code unit 0x0020 (space). 
*3*(S (Chunk set/VBN VARmember/NNP) to/TO the/DT string-concatenation/NN of/IN (Chunk VARmember/NNP) and/CC the/DT code/NN unit/NN 0x0020/CD (/( space/NN )/) ./.)
*2*set VARmember to the string-concatenation of VARmember and VARstrp. 
*2*(S (Chunk set/VBN VARmember/NNP) to/TO the/DT string-concatenation/NN of/IN (Chunk VARmember/NNP) and/CC (Chunk VARstrp/NNP) ./.)
*2*append VARmember to VARpartial. 
*2*(S append/JJ (Chunk VARmember/NNP) to/TO (Chunk VARpartial/NNP) ./.)
*0*if VARpartial is empty, then
*0*(S if/IN (Chunk VARpartial/NNP) is/VBZ empty/JJ ,/, then/RB)
*1*let VARfinal be "{}". 
*1*(S (Chunk let/VB VARfinal/NNP) be/VB ``/`` {/( }/) ''/'' ./.)
*0*else,
*0*(S else/RB ,/,)
*1*if VARgap is the empty string, then
*1*(S if/IN (Chunk VARgap/NNP) is/VBZ the/DT empty/JJ string/NN ,/, then/RB)
*2*let VARproperties be the string value formed by concatenating all the element strings of VARpartial with each adjacent pair of strings separated with the code unit 0x002c (comma). a comma is not inserted either before the first string or after the last string. 
*2*(S let/VB VARproperties/NNS be/VB the/DT string/VBG value/NN formed/VBN by/IN concatenating/VBG all/PDT the/DT element/JJ strings/NNS of/IN (Chunk VARpartial/NNP) with/IN each/DT adjacent/JJ pair/NN of/IN strings/NNS separated/VBN with/IN the/DT code/NN unit/NN 0x002c/CD (/( comma/NN )/) ./. a/DT comma/NN is/VBZ not/RB inserted/VBN either/CC before/IN the/DT first/JJ string/NN or/CC after/IN the/DT last/JJ string/NN ./.)
*2*let VARfinal be the string-concatenation of "{", VARproperties, and "}". 
*2*(S (Chunk let/VB VARfinal/NNP) be/VB the/DT string-concatenation/NN of/IN ``/`` {/( ``/`` ,/, (Chunk VARproperties/NNP) ,/, and/CC ``/`` }/) ''/'' ./.)
*1*else VARgap is not the empty string,
*1*(S (Chunk else/RB VARgap/NNP) is/VBZ not/RB the/DT empty/JJ string/NN ,/,)
*2*let VARseparator be the string-concatenation of the code unit 0x002c (comma), the code unit 0x000a (line feed), and VARindent. 
*2*(S (Chunk let/VB VARseparator/NNP) be/VB the/DT string-concatenation/NN of/IN the/DT code/NN unit/NN 0x002c/CD (/( comma/NN )/) ,/, the/DT code/NN unit/NN 0x000a/CD (/( line/NN feed/NN )/) ,/, and/CC (Chunk VARindent/NNP) ./.)
*2*let VARproperties be the string value formed by concatenating all the element strings of VARpartial with each adjacent pair of strings separated with VARseparator. the VARseparator string is not inserted either before the first string or after the last string. 
*2*(S let/VB VARproperties/NNS be/VB the/DT string/VBG value/NN formed/VBN by/IN concatenating/VBG all/PDT the/DT element/JJ strings/NNS of/IN (Chunk VARpartial/NNP) with/IN each/DT adjacent/JJ pair/NN of/IN strings/NNS separated/VBN with/IN (Chunk VARseparator/NNP) ./. the/DT (Chunk VARseparator/NNP) string/NN is/VBZ not/RB inserted/VBN either/CC before/IN the/DT first/JJ string/NN or/CC after/IN the/DT last/JJ string/NN ./.)
*2*let VARfinal be the string-concatenation of "{", the code unit 0x000a (line feed), VARindent, VARproperties, the code unit 0x000a (line feed), VARstepback, and "}". 
*2*(S (Chunk let/VB VARfinal/NNP) be/VB the/DT string-concatenation/NN of/IN ``/`` {/( ``/`` ,/, the/DT code/NN unit/NN 0x000a/CD (/( line/NN feed/NN )/) ,/, (Chunk VARindent/NNP) ,/, (Chunk VARproperties/NNP) ,/, the/DT code/NN unit/NN 0x000a/CD (/( line/NN feed/NN )/) ,/, (Chunk VARstepback/NNP) ,/, and/CC ``/`` }/) ''/'' ./.)
*0*remove the last element of VARstack. 
*0*(S remove/VB the/DT last/JJ element/NN of/IN (Chunk VARstack/NNP) ./.)
*0*set VARindent to VARstepback. 
*0*(S (Chunk set/VBN VARindent/NNP) to/TO (Chunk VARstepback/NNP) ./.)
*0*return VARfinal.     
*0*(S return/NN (Chunk VARfinal/NNP) ./.)
ID= 24.5.2.5
Summary= Runtime Semantics: SerializeJSONArray ( value )
*0*if VARstack contains VARvalue, throw a typeerror exception because the structure is cyclical. 
*0*(S if/IN (Chunk VARstack/NNP) (Chunk contains/VBZ VARvalue/NNP) ,/, throw/VBP a/DT typeerror/NN exception/NN because/IN the/DT structure/NN is/VBZ cyclical/JJ ./.)
*0*append VARvalue to VARstack. 
*0*(S (Chunk append/VB VARvalue/NNP) to/TO (Chunk VARstack/NNP) ./.)
*0*let VARstepback be VARindent. 
*0*(S (Chunk let/VB VARstepback/NNP) (Chunk be/VB VARindent/NNP) ./.)
*0*set VARindent to the string-concatenation of VARindent and VARgap. 
*0*(S (Chunk set/VBN VARindent/NNP) to/TO the/DT string-concatenation/NN of/IN (Chunk VARindent/NNP) and/CC (Chunk VARgap/NNP) ./.)
*0*let VARpartial be a new empty list. 
*0*(S (Chunk let/VB VARpartial/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARlen be ? FUNCtolength(? FUNCget(VARvalue, "length")). 
*0*(S (Chunk let/VB VARlen/NNP) be/VB ?/. (Chunk FUNCtolength/NNP) (/( ?/. (Chunk FUNCget/NNP) (/( (Chunk VARvalue/NNP) ,/, ``/`` length/NN ''/'' )/) )/) ./.)
*0*let VARindex be 0. 
*0*(S (Chunk let/VB VARindex/NNP) be/VB 0/CD ./.)
*0*repeat, while VARindex &lt; VARlen
*0*(S repeat/NN ,/, while/IN (Chunk VARindex/NNP) &/CC lt/NN ;/: (Chunk VARlen/NNP))
*1*let VARstrp be ? FUNCserializejsonproperty(! FUNCtostring(VARindex), VARvalue). 
*1*(S (Chunk let/VB VARstrp/NNP) be/VB ?/. (Chunk FUNCserializejsonproperty/NNP) (/( !/. (Chunk FUNCtostring/NNP) (/( (Chunk VARindex/NNP) )/) ,/, (Chunk VARvalue/NNP) )/) ./.)
*1*if VARstrp is undefined, then
*1*(S if/IN (Chunk VARstrp/NNP) is/VBZ undefined/VBN ,/, then/RB)
*2*append "null" to VARpartial. 
*2*(S append/VB ``/`` null/JJ ''/'' to/TO (Chunk VARpartial/NNP) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*append VARstrp to VARpartial. 
*2*(S append/NN (Chunk VARstrp/NNP) to/TO (Chunk VARpartial/NNP) ./.)
*1*increment VARindex by 1. 
*1*(S increment/NN VARindex/NN by/IN 1/CD ./.)
*0*if VARpartial is empty, then
*0*(S if/IN (Chunk VARpartial/NNP) is/VBZ empty/JJ ,/, then/RB)
*1*let VARfinal be "[]". 
*1*(S (Chunk let/VB VARfinal/NNP) be/VB ``/`` [/JJ ]/NN ''/'' ./.)
*0*else,
*0*(S else/RB ,/,)
*1*if VARgap is the empty string, then
*1*(S if/IN (Chunk VARgap/NNP) is/VBZ the/DT empty/JJ string/NN ,/, then/RB)
*2*let VARproperties be the string value formed by concatenating all the element strings of VARpartial with each adjacent pair of strings separated with the code unit 0x002c (comma). a comma is not inserted either before the first string or after the last string. 
*2*(S let/VB VARproperties/NNS be/VB the/DT string/VBG value/NN formed/VBN by/IN concatenating/VBG all/PDT the/DT element/JJ strings/NNS of/IN (Chunk VARpartial/NNP) with/IN each/DT adjacent/JJ pair/NN of/IN strings/NNS separated/VBN with/IN the/DT code/NN unit/NN 0x002c/CD (/( comma/NN )/) ./. a/DT comma/NN is/VBZ not/RB inserted/VBN either/CC before/IN the/DT first/JJ string/NN or/CC after/IN the/DT last/JJ string/NN ./.)
*2*let VARfinal be the string-concatenation of "[", VARproperties, and "]". 
*2*(S (Chunk let/VB VARfinal/NNP) be/VB the/DT string-concatenation/NN of/IN ``/`` [/JJ ``/`` ,/, (Chunk VARproperties/NNP) ,/, and/CC ``/`` ]/JJ ''/'' ./.)
*1*else,
*1*(S else/RB ,/,)
*2*let VARseparator be the string-concatenation of the code unit 0x002c (comma), the code unit 0x000a (line feed), and VARindent. 
*2*(S (Chunk let/VB VARseparator/NNP) be/VB the/DT string-concatenation/NN of/IN the/DT code/NN unit/NN 0x002c/CD (/( comma/NN )/) ,/, the/DT code/NN unit/NN 0x000a/CD (/( line/NN feed/NN )/) ,/, and/CC (Chunk VARindent/NNP) ./.)
*2*let VARproperties be the string value formed by concatenating all the element strings of VARpartial with each adjacent pair of strings separated with VARseparator. the VARseparator string is not inserted either before the first string or after the last string. 
*2*(S let/VB VARproperties/NNS be/VB the/DT string/VBG value/NN formed/VBN by/IN concatenating/VBG all/PDT the/DT element/JJ strings/NNS of/IN (Chunk VARpartial/NNP) with/IN each/DT adjacent/JJ pair/NN of/IN strings/NNS separated/VBN with/IN (Chunk VARseparator/NNP) ./. the/DT (Chunk VARseparator/NNP) string/NN is/VBZ not/RB inserted/VBN either/CC before/IN the/DT first/JJ string/NN or/CC after/IN the/DT last/JJ string/NN ./.)
*2*let VARfinal be the string-concatenation of "[", the code unit 0x000a (line feed), VARindent, VARproperties, the code unit 0x000a (line feed), VARstepback, and "]". 
*2*(S (Chunk let/VB VARfinal/NNP) be/VB the/DT string-concatenation/NN of/IN ``/`` [/JJ ``/`` ,/, the/DT code/NN unit/NN 0x000a/CD (/( line/NN feed/NN )/) ,/, (Chunk VARindent/NNP) ,/, (Chunk VARproperties/NNP) ,/, the/DT code/NN unit/NN 0x000a/CD (/( line/NN feed/NN )/) ,/, (Chunk VARstepback/NNP) ,/, and/CC ``/`` ]/JJ ''/'' ./.)
*0*remove the last element of VARstack. 
*0*(S remove/VB the/DT last/JJ element/NN of/IN (Chunk VARstack/NNP) ./.)
*0*set VARindent to VARstepback. 
*0*(S (Chunk set/VBN VARindent/NNP) to/TO (Chunk VARstepback/NNP) ./.)
*0*return VARfinal.     
*0*(S return/NN (Chunk VARfinal/NNP) ./.)
ID= 25.1.2.1
Summary= %IteratorPrototype% [ @@iterator ] ( )
*0*return the this value.     
*0*(S return/VB the/DT this/DT value/NN ./.)
ID= 25.1.3.1
Summary= %AsyncIteratorPrototype% [ @@asyncIterator ] ( )
*0*return the this value.     
*0*(S return/VB the/DT this/DT value/NN ./.)
ID= 25.1.4.1
Summary= CreateAsyncFromSyncIterator ( syncIteratorRecord )
*0*let VARasynciterator be ! FUNCobjectcreate(%asyncfromsynciteratorprototype%, « [[SYNCITERATORRECORD]] »). 
*0*(S (Chunk let/VB VARasynciterator/NNP) be/VB !/. (Chunk FUNCobjectcreate/NNP) (/( %/NN asyncfromsynciteratorprototype/NN %/NN ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk SYNCITERATORRECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARasynciterator.[[SYNCITERATORRECORD]] to VARsynciteratorrecord. 
*0*(S (Chunk set/VBN VARasynciterator/NNP) ./. [/VB [/JJ (Chunk SYNCITERATORRECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARsynciteratorrecord/NNP) ./.)
*0*return ? FUNCgetiterator(VARasynciterator, async).     
*0*(S return/NN ?/. (Chunk FUNCgetiterator/NNP) (/( (Chunk VARasynciterator/NNP) ,/, async/NN )/) ./.)
ID= 25.1.4.2.1
Summary= %AsyncFromSyncIteratorPrototype%.next ( value )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*let VARpromisecapability be ! FUNCnewpromisecapability(%promise%). 
*0*(S (Chunk let/VB VARpromisecapability/NNP) be/VB !/. (Chunk FUNCnewpromisecapability/NNP) (/( %/NN promise/NN %/NN )/) ./.)
*0*if FUNCtype(VARo) is not object, or if VARo does not have a [[SYNCITERATORRECORD]] internal slot, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, or/CC if/IN (Chunk VARo/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk SYNCITERATORRECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, then/RB)
*1*let VARinvaliditeratorerror be a newly created typeerror object. 
*1*(S (Chunk let/VB VARinvaliditeratorerror/NNP) be/VB a/DT newly/RB created/VBN typeerror/NN object/NN ./.)
*1*perform ! FUNCcall(VARpromisecapability.[[REJECT]], undefined, « VARinvaliditeratorerror »). 
*1*(S perform/NN !/. (Chunk FUNCcall/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk REJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, (Chunk «/NNP) (Chunk VARinvaliditeratorerror/NNP) (Chunk »/NNP) )/) ./.)
*1*return VARpromisecapability.[[PROMISE]]. 
*1*(S return/NN (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARsynciteratorrecord be VARo.[[SYNCITERATORRECORD]]. 
*0*(S (Chunk let/VB VARsynciteratorrecord/NNP) (Chunk be/VB VARo/NNP) ./. [/VB [/JJ (Chunk SYNCITERATORRECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARnextresult be FUNCiteratornext(VARsynciteratorrecord, VARvalue). 
*0*(S (Chunk let/VB VARnextresult/NNP) (Chunk be/VB FUNCiteratornext/NNP) (/( (Chunk VARsynciteratorrecord/NNP) ,/, (Chunk VARvalue/NNP) )/) ./.)
*0*FUNCifabruptrejectpromise(VARnextresult, VARpromisecapability). 
*0*(S (Chunk FUNCifabruptrejectpromise/NNP) (/( (Chunk VARnextresult/NNP) ,/, (Chunk VARpromisecapability/NNP) )/) ./.)
*0*let VARnextdone be FUNCiteratorcomplete(VARnextresult). 
*0*(S (Chunk let/VB VARnextdone/NNP) (Chunk be/VB FUNCiteratorcomplete/NNP) (/( (Chunk VARnextresult/NNP) )/) ./.)
*0*FUNCifabruptrejectpromise(VARnextdone, VARpromisecapability). 
*0*(S (Chunk FUNCifabruptrejectpromise/NNP) (/( (Chunk VARnextdone/NNP) ,/, (Chunk VARpromisecapability/NNP) )/) ./.)
*0*let VARnextvalue be FUNCiteratorvalue(VARnextresult). 
*0*(S (Chunk let/VB VARnextvalue/NNP) (Chunk be/VB FUNCiteratorvalue/NNP) (/( (Chunk VARnextresult/NNP) )/) ./.)
*0*FUNCifabruptrejectpromise(VARnextvalue, VARpromisecapability). 
*0*(S (Chunk FUNCifabruptrejectpromise/NNP) (/( (Chunk VARnextvalue/NNP) ,/, (Chunk VARpromisecapability/NNP) )/) ./.)
*0*let VARvaluewrappercapability be ! FUNCnewpromisecapability(%promise%). 
*0*(S (Chunk let/VB VARvaluewrappercapability/NNP) be/VB !/. (Chunk FUNCnewpromisecapability/NNP) (/( %/NN promise/NN %/NN )/) ./.)
*0*perform ! FUNCcall(VARvaluewrappercapability.[[RESOLVE]], undefined, « VARnextvalue »). 
*0*(S perform/NN !/. (Chunk FUNCcall/NNP) (/( (Chunk VARvaluewrappercapability/NNP) ./. [/VB [/JJ (Chunk RESOLVE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, (Chunk «/NNP) (Chunk VARnextvalue/NNP) (Chunk »/NNP) )/) ./.)
*0*let VARsteps be the algorithm steps defined in async-from-sync iterator value unwrap functions. 
*0*(S (Chunk let/VB VARsteps/NNP) be/VB the/DT algorithm/JJ steps/NNS defined/VBN in/IN async-from-sync/JJ iterator/NN value/NN unwrap/JJ functions/NNS ./.)
*0*let VARonfulfilled be FUNCcreatebuiltinfunction(VARsteps, « [[DONE]] »). 
*0*(S (Chunk let/VB VARonfulfilled/NNP) (Chunk be/VB FUNCcreatebuiltinfunction/NNP) (/( (Chunk VARsteps/NNP) ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk DONE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARonfulfilled.[[DONE]] to VARnextdone. 
*0*(S set/NN (Chunk VARonfulfilled/NNP) ./. [/NN [/IN (Chunk DONE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARnextdone/NNP) ./.)
*0*perform ! FUNCperformpromisethen(VARvaluewrappercapability.[[PROMISE]], VARonfulfilled, undefined, VARpromisecapability). 
*0*(S perform/NN !/. (Chunk FUNCperformpromisethen/NNP) (/( (Chunk VARvaluewrappercapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARonfulfilled/NNP) ,/, undefined/VBD ,/, (Chunk VARpromisecapability/NNP) )/) ./.)
*0*return VARpromisecapability.[[PROMISE]].      
*0*(S return/NN (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
ID= 25.1.4.2.2
Summary= %AsyncFromSyncIteratorPrototype%.return ( value )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*let VARpromisecapability be ! FUNCnewpromisecapability(%promise%). 
*0*(S (Chunk let/VB VARpromisecapability/NNP) be/VB !/. (Chunk FUNCnewpromisecapability/NNP) (/( %/NN promise/NN %/NN )/) ./.)
*0*if FUNCtype(VARo) is not object, or if VARo does not have a [[SYNCITERATORRECORD]] internal slot, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, or/CC if/IN (Chunk VARo/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk SYNCITERATORRECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, then/RB)
*1*let VARinvaliditeratorerror be a newly created typeerror object. 
*1*(S (Chunk let/VB VARinvaliditeratorerror/NNP) be/VB a/DT newly/RB created/VBN typeerror/NN object/NN ./.)
*1*perform ! FUNCcall(VARpromisecapability.[[REJECT]], undefined, « VARinvaliditeratorerror »). 
*1*(S perform/NN !/. (Chunk FUNCcall/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk REJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, (Chunk «/NNP) (Chunk VARinvaliditeratorerror/NNP) (Chunk »/NNP) )/) ./.)
*1*return VARpromisecapability.[[PROMISE]]. 
*1*(S return/NN (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARsynciterator be VARo.[[SYNCITERATORRECORD]].[[ITERATOR]]. 
*0*(S (Chunk let/VB VARsynciterator/NNP) (Chunk be/VB VARo./NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk SYNCITERATORRECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./. [/VB [/JJ (Chunk ITERATOR/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARreturn be FUNCgetmethod(VARsynciterator, "return"). 
*0*(S (Chunk let/VB VARreturn/NNP) (Chunk be/VB FUNCgetmethod/NNP) (/( (Chunk VARsynciterator/NNP) ,/, ``/`` return/NN ''/'' )/) ./.)
*0*FUNCifabruptrejectpromise(VARreturn, VARpromisecapability). 
*0*(S (Chunk FUNCifabruptrejectpromise/NNP) (/( (Chunk VARreturn/NNP) ,/, (Chunk VARpromisecapability/NNP) )/) ./.)
*0*if VARreturn is undefined, then
*0*(S if/IN (Chunk VARreturn/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*let VARiterresult be ! FUNCcreateiterresultobject(VARvalue, true). 
*1*(S (Chunk let/VB VARiterresult/NNP) be/VB !/. (Chunk FUNCcreateiterresultobject/NNP) (/( (Chunk VARvalue/NNP) ,/, true/JJ )/) ./.)
*1*perform ! FUNCcall(VARpromisecapability.[[RESOLVE]], undefined, « VARiterresult »). 
*1*(S perform/NN !/. (Chunk FUNCcall/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk RESOLVE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, (Chunk «/NNP) (Chunk VARiterresult/NNP) (Chunk »/NNP) )/) ./.)
*1*return VARpromisecapability.[[PROMISE]]. 
*1*(S return/NN (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARreturnresult be FUNCcall(VARreturn, VARsynciterator, « VARvalue »). 
*0*(S (Chunk let/VB VARreturnresult/NNP) (Chunk be/VB FUNCcall/NNP) (/( (Chunk VARreturn/NNP) ,/, (Chunk VARsynciterator/NNP) ,/, (Chunk «/NNP) (Chunk VARvalue/NNP) (Chunk »/NNP) )/) ./.)
*0*FUNCifabruptrejectpromise(VARreturnresult, VARpromisecapability). 
*0*(S (Chunk FUNCifabruptrejectpromise/NNP) (/( (Chunk VARreturnresult/NNP) ,/, (Chunk VARpromisecapability/NNP) )/) ./.)
*0*if FUNCtype(VARreturnresult) is not object, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARreturnresult/NNP) )/) is/VBZ not/RB object/JJ ,/, then/RB)
*1*perform ! FUNCcall(VARpromisecapability.[[REJECT]], undefined, « a newly created typeerror object »). 
*1*(S perform/NN !/. (Chunk FUNCcall/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk REJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, «/VB a/DT newly/RB created/VBN typeerror/NN object/JJ »/NN )/) ./.)
*1*return VARpromisecapability.[[PROMISE]]. 
*1*(S return/NN (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARreturndone be FUNCiteratorcomplete(VARreturnresult). 
*0*(S (Chunk let/VB VARreturndone/NNP) (Chunk be/VB FUNCiteratorcomplete/NNP) (/( (Chunk VARreturnresult/NNP) )/) ./.)
*0*FUNCifabruptrejectpromise(VARreturndone, VARpromisecapability). 
*0*(S (Chunk FUNCifabruptrejectpromise/NNP) (/( (Chunk VARreturndone/NNP) ,/, (Chunk VARpromisecapability/NNP) )/) ./.)
*0*let VARreturnvalue be FUNCiteratorvalue(VARreturnresult). 
*0*(S (Chunk let/VB VARreturnvalue/NNP) (Chunk be/VB FUNCiteratorvalue/NNP) (/( (Chunk VARreturnresult/NNP) )/) ./.)
*0*FUNCifabruptrejectpromise(VARreturnvalue, VARpromisecapability). 
*0*(S (Chunk FUNCifabruptrejectpromise/NNP) (/( (Chunk VARreturnvalue/NNP) ,/, (Chunk VARpromisecapability/NNP) )/) ./.)
*0*let VARvaluewrappercapability be ! FUNCnewpromisecapability(%promise%). 
*0*(S (Chunk let/VB VARvaluewrappercapability/NNP) be/VB !/. (Chunk FUNCnewpromisecapability/NNP) (/( %/NN promise/NN %/NN )/) ./.)
*0*perform ! FUNCcall(VARvaluewrappercapability.[[RESOLVE]], undefined, « VARreturnvalue »). 
*0*(S perform/NN !/. (Chunk FUNCcall/NNP) (/( (Chunk VARvaluewrappercapability/NNP) ./. [/VB [/JJ (Chunk RESOLVE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, (Chunk «/NNP) (Chunk VARreturnvalue/NNP) (Chunk »/NNP) )/) ./.)
*0*let VARsteps be the algorithm steps defined in async-from-sync iterator value unwrap functions. 
*0*(S (Chunk let/VB VARsteps/NNP) be/VB the/DT algorithm/JJ steps/NNS defined/VBN in/IN async-from-sync/JJ iterator/NN value/NN unwrap/JJ functions/NNS ./.)
*0*let VARonfulfilled be FUNCcreatebuiltinfunction(VARsteps, « [[DONE]] »). 
*0*(S (Chunk let/VB VARonfulfilled/NNP) (Chunk be/VB FUNCcreatebuiltinfunction/NNP) (/( (Chunk VARsteps/NNP) ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk DONE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARonfulfilled.[[DONE]] to VARreturndone. 
*0*(S set/NN (Chunk VARonfulfilled/NNP) ./. [/NN [/IN (Chunk DONE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARreturndone/NNP) ./.)
*0*perform ! FUNCperformpromisethen(VARvaluewrappercapability.[[PROMISE]], VARonfulfilled, undefined, VARpromisecapability). 
*0*(S perform/NN !/. (Chunk FUNCperformpromisethen/NNP) (/( (Chunk VARvaluewrappercapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARonfulfilled/NNP) ,/, undefined/VBD ,/, (Chunk VARpromisecapability/NNP) )/) ./.)
*0*return VARpromisecapability.[[PROMISE]].      
*0*(S return/NN (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
ID= 25.1.4.2.3
Summary= %AsyncFromSyncIteratorPrototype%.throw ( value )
*0*let VARo be the this value. 
*0*(S (Chunk let/VB VARo/NNP) be/VB the/DT this/DT value/NN ./.)
*0*let VARpromisecapability be ! FUNCnewpromisecapability(%promise%). 
*0*(S (Chunk let/VB VARpromisecapability/NNP) be/VB !/. (Chunk FUNCnewpromisecapability/NNP) (/( %/NN promise/NN %/NN )/) ./.)
*0*if FUNCtype(VARo) is not object, or if VARo does not have a [[SYNCITERATORRECORD]] internal slot, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARo/NNP) )/) is/VBZ not/RB object/JJ ,/, or/CC if/IN (Chunk VARo/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk SYNCITERATORRECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, then/RB)
*1*let VARinvaliditeratorerror be a newly created typeerror object. 
*1*(S (Chunk let/VB VARinvaliditeratorerror/NNP) be/VB a/DT newly/RB created/VBN typeerror/NN object/NN ./.)
*1*perform ! FUNCcall(VARpromisecapability.[[REJECT]], undefined, « VARinvaliditeratorerror »). 
*1*(S perform/NN !/. (Chunk FUNCcall/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk REJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, (Chunk «/NNP) (Chunk VARinvaliditeratorerror/NNP) (Chunk »/NNP) )/) ./.)
*1*return VARpromisecapability.[[PROMISE]]. 
*1*(S return/NN (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARsynciterator be VARo.[[SYNCITERATORRECORD]].[[ITERATOR]]. 
*0*(S (Chunk let/VB VARsynciterator/NNP) (Chunk be/VB VARo./NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk SYNCITERATORRECORD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./. [/VB [/JJ (Chunk ITERATOR/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARthrow be FUNCgetmethod(VARsynciterator, "throw"). 
*0*(S (Chunk let/VB VARthrow/NNP) (Chunk be/VB FUNCgetmethod/NNP) (/( (Chunk VARsynciterator/NNP) ,/, ``/`` throw/VB ''/'' )/) ./.)
*0*FUNCifabruptrejectpromise(VARthrow, VARpromisecapability). 
*0*(S (Chunk FUNCifabruptrejectpromise/NNP) (/( (Chunk VARthrow/NNP) ,/, (Chunk VARpromisecapability/NNP) )/) ./.)
*0*if VARthrow is undefined, then
*0*(S if/IN (Chunk VARthrow/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*perform ! FUNCcall(VARpromisecapability.[[REJECT]], undefined, « VARvalue »). 
*1*(S perform/NN !/. (Chunk FUNCcall/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk REJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, (Chunk «/NNP) (Chunk VARvalue/NNP) (Chunk »/NNP) )/) ./.)
*1*return VARpromisecapability.[[PROMISE]]. 
*1*(S return/NN (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARthrowresult be FUNCcall(VARthrow, VARsynciterator, « VARvalue »). 
*0*(S (Chunk let/VB VARthrowresult/NNP) (Chunk be/VB FUNCcall/NNP) (/( (Chunk VARthrow/NNP) ,/, (Chunk VARsynciterator/NNP) ,/, (Chunk «/NNP) (Chunk VARvalue/NNP) (Chunk »/NNP) )/) ./.)
*0*FUNCifabruptrejectpromise(VARthrowresult, VARpromisecapability). 
*0*(S (Chunk FUNCifabruptrejectpromise/NNP) (/( (Chunk VARthrowresult/NNP) ,/, (Chunk VARpromisecapability/NNP) )/) ./.)
*0*if FUNCtype(VARthrowresult) is not object, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARthrowresult/NNP) )/) is/VBZ not/RB object/JJ ,/, then/RB)
*1*perform ! FUNCcall(VARpromisecapability.[[REJECT]], undefined, « a newly created typeerror object »). 
*1*(S perform/NN !/. (Chunk FUNCcall/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk REJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, «/VB a/DT newly/RB created/VBN typeerror/NN object/JJ »/NN )/) ./.)
*1*return VARpromisecapability.[[PROMISE]]. 
*1*(S return/NN (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARthrowdone be FUNCiteratorcomplete(VARthrowresult). 
*0*(S (Chunk let/VB VARthrowdone/NNP) (Chunk be/VB FUNCiteratorcomplete/NNP) (/( (Chunk VARthrowresult/NNP) )/) ./.)
*0*FUNCifabruptrejectpromise(VARthrowdone, VARpromisecapability). 
*0*(S (Chunk FUNCifabruptrejectpromise/NNP) (/( (Chunk VARthrowdone/NNP) ,/, (Chunk VARpromisecapability/NNP) )/) ./.)
*0*let VARthrowvalue be FUNCiteratorvalue(VARthrowresult). 
*0*(S (Chunk let/VB VARthrowvalue/NNP) (Chunk be/VB FUNCiteratorvalue/NNP) (/( (Chunk VARthrowresult/NNP) )/) ./.)
*0*FUNCifabruptrejectpromise(VARthrowvalue, VARpromisecapability). 
*0*(S (Chunk FUNCifabruptrejectpromise/NNP) (/( (Chunk VARthrowvalue/NNP) ,/, (Chunk VARpromisecapability/NNP) )/) ./.)
*0*let VARvaluewrappercapability be ! FUNCnewpromisecapability(%promise%). 
*0*(S (Chunk let/VB VARvaluewrappercapability/NNP) be/VB !/. (Chunk FUNCnewpromisecapability/NNP) (/( %/NN promise/NN %/NN )/) ./.)
*0*perform ! FUNCcall(VARvaluewrappercapability.[[RESOLVE]], undefined, « VARthrowvalue »). 
*0*(S perform/NN !/. (Chunk FUNCcall/NNP) (/( (Chunk VARvaluewrappercapability/NNP) ./. [/VB [/JJ (Chunk RESOLVE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, (Chunk «/NNP) (Chunk VARthrowvalue/NNP) (Chunk »/NNP) )/) ./.)
*0*let VARsteps be the algorithm steps defined in async-from-sync iterator value unwrap functions. 
*0*(S (Chunk let/VB VARsteps/NNP) be/VB the/DT algorithm/JJ steps/NNS defined/VBN in/IN async-from-sync/JJ iterator/NN value/NN unwrap/JJ functions/NNS ./.)
*0*let VARonfulfilled be FUNCcreatebuiltinfunction(VARsteps, « [[DONE]] »). 
*0*(S (Chunk let/VB VARonfulfilled/NNP) (Chunk be/VB FUNCcreatebuiltinfunction/NNP) (/( (Chunk VARsteps/NNP) ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk DONE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARonfulfilled.[[DONE]] to VARthrowdone. 
*0*(S set/NN (Chunk VARonfulfilled/NNP) ./. [/NN [/IN (Chunk DONE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARthrowdone/NNP) ./.)
*0*perform ! FUNCperformpromisethen(VARvaluewrappercapability.[[PROMISE]], VARonfulfilled, undefined, VARpromisecapability). 
*0*(S perform/NN !/. (Chunk FUNCperformpromisethen/NNP) (/( (Chunk VARvaluewrappercapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARonfulfilled/NNP) ,/, undefined/VBD ,/, (Chunk VARpromisecapability/NNP) )/) ./.)
*0*return VARpromisecapability.[[PROMISE]].      
*0*(S return/NN (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
ID= 25.2.1.1
Summary= GeneratorFunction ( p1, p2, … , pn, body )
*0*let VARc be the active function object. 
*0*(S (Chunk let/VB VARc/NNP) be/VB the/DT active/JJ function/NN object/NN ./.)
*0*let VARargs be the VARargumentslist that was passed to this function by [[CALL]] or [[CONSTRUCT]]. 
*0*(S (Chunk let/VB VARargs/NNP) be/VB the/DT (Chunk VARargumentslist/NNP) that/WDT was/VBD passed/VBN to/TO this/DT function/NN by/IN (Chunk [/NNP) (Chunk [/NNP) (Chunk CALL/NNP) (Chunk ]/NNP) (Chunk ]/NNP) or/CC (Chunk [/NNP) (Chunk [/NNP) (Chunk CONSTRUCT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*return ? FUNCcreatedynamicfunction(VARc, newtarget, "generator", VARargs).     
*0*(S return/NN ?/. (Chunk FUNCcreatedynamicfunction/NNP) (/( (Chunk VARc/NNP) ,/, newtarget/NN ,/, ``/`` generator/NN ''/'' ,/, (Chunk VARargs/NNP) )/) ./.)
ID= 25.3.1.1
Summary= AsyncGeneratorFunction ( p1, p2, ..., pn, body )
*0*let VARc be the active function object. 
*0*(S (Chunk let/VB VARc/NNP) be/VB the/DT active/JJ function/NN object/NN ./.)
*0*let VARargs be the VARargumentslist that was passed to this function by [[CALL]] or [[CONSTRUCT]]. 
*0*(S (Chunk let/VB VARargs/NNP) be/VB the/DT (Chunk VARargumentslist/NNP) that/WDT was/VBD passed/VBN to/TO this/DT function/NN by/IN (Chunk [/NNP) (Chunk [/NNP) (Chunk CALL/NNP) (Chunk ]/NNP) (Chunk ]/NNP) or/CC (Chunk [/NNP) (Chunk [/NNP) (Chunk CONSTRUCT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*return ? FUNCcreatedynamicfunction(VARc, newtarget, "async generator", VARargs).     
*0*(S return/NN ?/. (Chunk FUNCcreatedynamicfunction/NNP) (/( (Chunk VARc/NNP) ,/, newtarget/NN ,/, ``/`` async/NN generator/NN ''/'' ,/, (Chunk VARargs/NNP) )/) ./.)
ID= 25.4.1.2
Summary= Generator.prototype.next ( value )
*0*let VARg be the this value. 
*0*(S (Chunk let/VB VARg/NNP) be/VB the/DT this/DT value/NN ./.)
*0*return ? FUNCgeneratorresume(VARg, VARvalue).     
*0*(S return/NN ?/. (Chunk FUNCgeneratorresume/NNP) (/( (Chunk VARg/NNP) ,/, (Chunk VARvalue/NNP) )/) ./.)
ID= 25.4.1.3
Summary= Generator.prototype.return ( value )
*0*let VARg be the this value. 
*0*(S (Chunk let/VB VARg/NNP) be/VB the/DT this/DT value/NN ./.)
*0*let VARc be completion { [[TYPE]]: return, [[VALUE]]: VARvalue, [[TARGET]]: empty }. 
*0*(S (Chunk let/VB VARc/NNP) be/VB completion/NN {/( [/JJ (Chunk [/NNP) (Chunk TYPE/NNP) (Chunk ]/NNP) ]/NN :/: return/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARvalue/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk TARGET/NNP) (Chunk ]/NNP) ]/NN :/: empty/JJ }/) ./.)
*0*return ? FUNCgeneratorresumeabrupt(VARg, VARc).     
*0*(S return/NN ?/. (Chunk FUNCgeneratorresumeabrupt/NNP) (/( (Chunk VARg/NNP) ,/, (Chunk VARc/NNP) )/) ./.)
ID= 25.4.1.4
Summary= Generator.prototype.throw ( exception )
*0*let VARg be the this value. 
*0*(S (Chunk let/VB VARg/NNP) be/VB the/DT this/DT value/NN ./.)
*0*let VARc be FUNCthrowcompletion(VARexception). 
*0*(S (Chunk let/VB VARc/NNP) (Chunk be/VB FUNCthrowcompletion/NNP) (/( (Chunk VARexception/NNP) )/) ./.)
*0*return ? FUNCgeneratorresumeabrupt(VARg, VARc).     
*0*(S return/NN ?/. (Chunk FUNCgeneratorresumeabrupt/NNP) (/( (Chunk VARg/NNP) ,/, (Chunk VARc/NNP) )/) ./.)
ID= 25.4.3.1
Summary= GeneratorStart ( generator, generatorBody )
*0*assert: the value of VARgenerator.[[GENERATORSTATE]] is undefined. 
*0*(S assert/NN :/: the/DT value/NN of/IN (Chunk VARgenerator/NNP) ./. [/VB [/JJ (Chunk GENERATORSTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ undefined/VBN ./.)
*0*let VARgencontext be the running execution context. 
*0*(S (Chunk let/VB VARgencontext/NNP) be/VB the/DT running/JJ execution/NN context/NN ./.)
*0*set the generator component of VARgencontext to VARgenerator. 
*0*(S set/VB the/DT generator/NN component/NN of/IN (Chunk VARgencontext/NNP) to/TO (Chunk VARgenerator/NNP) ./.)
*0*set the code evaluation state of VARgencontext such that when evaluation is resumed for that execution context the following steps will be performed:
*0*(S set/VB the/DT code/NN evaluation/NN state/NN of/IN (Chunk VARgencontext/NNP) such/JJ that/IN when/WRB evaluation/NN is/VBZ resumed/VBN for/IN that/DT execution/NN context/VBD the/DT following/JJ steps/NNS will/MD be/VB performed/VBN :/:)
*1*let VARresult be the result of evaluating VARgeneratorbody. 
*1*(S (Chunk let/VB VARresult/NNP) be/VB the/DT result/NN of/IN (Chunk evaluating/VBG VARgeneratorbody/NNP) ./.)
*1*assert: if we return here, the generator either threw an exception or performed either an implicit or explicit return. 
*1*(S assert/NN :/: if/IN we/PRP return/VBP here/RB ,/, the/DT generator/NN either/CC threw/VBD an/DT exception/NN or/CC performed/VBN either/CC an/DT implicit/NN or/CC explicit/JJ return/NN ./.)
*1*remove VARgencontext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context. 
*1*(S (Chunk remove/VB VARgencontext/NNP) from/IN the/DT execution/NN context/NN stack/NN and/CC restore/VB the/DT execution/NN context/NN that/WDT is/VBZ at/IN the/DT top/NN of/IN the/DT execution/NN context/NN stack/NN as/IN the/DT running/VBG execution/NN context/NN ./.)
*1*set VARgenerator.[[GENERATORSTATE]] to "completed". 
*1*(S (Chunk set/VBN VARgenerator/NNP) ./. [/VB [/JJ (Chunk GENERATORSTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` completed/VBN ''/'' ./.)
*1*once a generator enters the "completed" state it never leaves it and its associated execution context is never resumed. any execution state associated with VARgenerator can be discarded at this point. 
*1*(S once/RB a/DT generator/NN enters/VBZ the/DT ``/`` completed/VBN ''/'' state/NN it/PRP never/RB leaves/VBZ it/PRP and/CC its/PRP$ associated/JJ execution/NN context/NN is/VBZ never/RB resumed/VBN ./. any/DT execution/NN state/NN associated/VBN with/IN (Chunk VARgenerator/NNP) can/MD be/VB discarded/VBN at/IN this/DT point/NN ./.)
*1*if VARresult.[[TYPE]] is normal, let VARresultvalue be undefined. 
*1*(S if/IN (Chunk VARresult/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ normal/JJ ,/, (Chunk let/VB VARresultvalue/NNP) be/VB undefined/VBN ./.)
*1*else if VARresult.[[TYPE]] is return, let VARresultvalue be VARresult.[[VALUE]]. 
*1*(S else/RB if/IN (Chunk VARresult/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ return/NN ,/, (Chunk let/VB VARresultvalue/NNP) (Chunk be/VB VARresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*assert: VARresult.[[TYPE]] is throw. 
*2*(S assert/NN :/: VARresult/NN ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ throw/JJ ./.)
*2*return FUNCcompletion(VARresult). 
*2*(S return/NN (Chunk FUNCcompletion/NNP) (/( (Chunk VARresult/NNP) )/) ./.)
*1*return FUNCcreateiterresultobject(VARresultvalue, true). 
*1*(S return/NN (Chunk FUNCcreateiterresultobject/NNP) (/( (Chunk VARresultvalue/NNP) ,/, true/JJ )/) ./.)
*0*set VARgenerator.[[GENERATORCONTEXT]] to VARgencontext. 
*0*(S (Chunk set/VBN VARgenerator/NNP) ./. [/VB [/JJ (Chunk GENERATORCONTEXT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARgencontext/NNP) ./.)
*0*set VARgenerator.[[GENERATORSTATE]] to "suspendedstart". 
*0*(S (Chunk set/VBN VARgenerator/NNP) ./. [/VB [/JJ (Chunk GENERATORSTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` suspendedstart/VB ''/'' ./.)
*0*return FUNCnormalcompletion(undefined).     
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( undefined/JJ )/) ./.)
ID= 25.4.3.2
Summary= GeneratorValidate ( generator )
*0*if FUNCtype(VARgenerator) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARgenerator/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARgenerator does not have a [[GENERATORSTATE]] internal slot, throw a typeerror exception. 
*0*(S if/IN (Chunk VARgenerator/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk GENERATORSTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*assert: VARgenerator also has a [[GENERATORCONTEXT]] internal slot. 
*0*(S assert/NN :/: VARgenerator/NN also/RB has/VBZ a/DT [/JJ (Chunk [/NNP) (Chunk GENERATORCONTEXT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ./.)
*0*let VARstate be VARgenerator.[[GENERATORSTATE]]. 
*0*(S (Chunk let/VB VARstate/NNP) (Chunk be/VB VARgenerator/NNP) ./. [/VB [/JJ (Chunk GENERATORSTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARstate is "executing", throw a typeerror exception. 
*0*(S if/IN (Chunk VARstate/NNP) is/VBZ ``/`` executing/VBG ''/'' ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return VARstate.     
*0*(S return/NN (Chunk VARstate/NNP) ./.)
ID= 25.4.3.3
Summary= GeneratorResume ( generator, value )
*0*let VARstate be ? FUNCgeneratorvalidate(VARgenerator). 
*0*(S (Chunk let/VB VARstate/NNP) be/VB ?/. (Chunk FUNCgeneratorvalidate/NNP) (/( (Chunk VARgenerator/NNP) )/) ./.)
*0*if VARstate is "completed", return FUNCcreateiterresultobject(undefined, true). 
*0*(S if/IN (Chunk VARstate/NNP) is/VBZ ``/`` completed/VBN ''/'' ,/, (Chunk return/VB FUNCcreateiterresultobject/NNP) (/( undefined/JJ ,/, true/JJ )/) ./.)
*0*assert: VARstate is either "suspendedstart" or "suspendedyield". 
*0*(S assert/NN :/: (Chunk VARstate/NNP) is/VBZ either/CC ``/`` suspendedstart/NN ''/'' or/CC ``/`` suspendedyield/JJ ''/'' ./.)
*0*let VARgencontext be VARgenerator.[[GENERATORCONTEXT]]. 
*0*(S (Chunk let/VB VARgencontext/NNP) (Chunk be/VB VARgenerator/NNP) ./. [/VB [/JJ (Chunk GENERATORCONTEXT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARmethodcontext be the running execution context. 
*0*(S (Chunk let/VB VARmethodcontext/NNP) be/VB the/DT running/JJ execution/NN context/NN ./.)
*0*suspend VARmethodcontext. 
*0*(S suspend/NN (Chunk VARmethodcontext/NNP) ./.)
*0*set VARgenerator.[[GENERATORSTATE]] to "executing". 
*0*(S (Chunk set/VBN VARgenerator/NNP) ./. [/VB [/JJ (Chunk GENERATORSTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` executing/VBG ''/'' ./.)
*0*push VARgencontext onto the execution context stack; VARgencontext is now the running execution context. 
*0*(S push/NN (Chunk VARgencontext/NNP) onto/IN the/DT execution/NN context/NN stack/NN ;/: (Chunk VARgencontext/NNP) is/VBZ now/RB the/DT running/VBG execution/NN context/NN ./.)
*0*resume the suspended evaluation of VARgencontext using FUNCnormalcompletion(VARvalue) as the result of the operation that suspended it. let VARresult be the value returned by the resumed computation. 
*0*(S resume/VB the/DT suspended/JJ evaluation/NN of/IN (Chunk VARgencontext/NNP) (Chunk using/VBG FUNCnormalcompletion/NNP) (/( (Chunk VARvalue/NNP) )/) as/IN the/DT result/NN of/IN the/DT operation/NN that/WDT suspended/VBD it/PRP ./. (Chunk let/VB VARresult/NNP) be/VB the/DT value/NN returned/VBN by/IN the/DT resumed/JJ computation/NN ./.)
*0*assert: when we return here, VARgencontext has already been removed from the execution context stack and VARmethodcontext is the currently running execution context. 
*0*(S assert/NN :/: when/WRB we/PRP return/VBP here/RB ,/, (Chunk VARgencontext/NNP) has/VBZ already/RB been/VBN removed/VBN from/IN the/DT execution/NN context/NN stack/NN and/CC (Chunk VARmethodcontext/NNP) is/VBZ the/DT currently/RB running/VBG execution/NN context/NN ./.)
*0*return FUNCcompletion(VARresult).     
*0*(S return/NN (Chunk FUNCcompletion/NNP) (/( (Chunk VARresult/NNP) )/) ./.)
ID= 25.4.3.4
Summary= GeneratorResumeAbrupt ( generator, abruptCompletion )
*0*let VARstate be ? FUNCgeneratorvalidate(VARgenerator). 
*0*(S (Chunk let/VB VARstate/NNP) be/VB ?/. (Chunk FUNCgeneratorvalidate/NNP) (/( (Chunk VARgenerator/NNP) )/) ./.)
*0*if VARstate is "suspendedstart", then
*0*(S if/IN (Chunk VARstate/NNP) is/VBZ ``/`` suspendedstart/JJ ''/'' ,/, then/RB)
*1*set VARgenerator.[[GENERATORSTATE]] to "completed". 
*1*(S (Chunk set/VBN VARgenerator/NNP) ./. [/VB [/JJ (Chunk GENERATORSTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` completed/VBN ''/'' ./.)
*1*once a generator enters the "completed" state it never leaves it and its associated execution context is never resumed. any execution state associated with VARgenerator can be discarded at this point. 
*1*(S once/RB a/DT generator/NN enters/VBZ the/DT ``/`` completed/VBN ''/'' state/NN it/PRP never/RB leaves/VBZ it/PRP and/CC its/PRP$ associated/JJ execution/NN context/NN is/VBZ never/RB resumed/VBN ./. any/DT execution/NN state/NN associated/VBN with/IN (Chunk VARgenerator/NNP) can/MD be/VB discarded/VBN at/IN this/DT point/NN ./.)
*1*set VARstate to "completed". 
*1*(S (Chunk set/VBN VARstate/NNP) to/TO ``/`` completed/VBN ''/'' ./.)
*0*if VARstate is "completed", then
*0*(S if/IN (Chunk VARstate/NNP) is/VBZ ``/`` completed/VBN ''/'' ,/, then/RB)
*1*if VARabruptcompletion.[[TYPE]] is return, then
*1*(S if/IN (Chunk VARabruptcompletion/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ return/NN ,/, then/RB)
*2*return FUNCcreateiterresultobject(VARabruptcompletion.[[VALUE]], true). 
*2*(S return/NN (Chunk FUNCcreateiterresultobject/NNP) (/( (Chunk VARabruptcompletion/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, true/JJ )/) ./.)
*1*return FUNCcompletion(VARabruptcompletion). 
*1*(S return/NN (Chunk FUNCcompletion/NNP) (/( (Chunk VARabruptcompletion/NNP) )/) ./.)
*0*assert: VARstate is "suspendedyield". 
*0*(S assert/NN :/: (Chunk VARstate/NNP) is/VBZ ``/`` suspendedyield/JJ ''/'' ./.)
*0*let VARgencontext be VARgenerator.[[GENERATORCONTEXT]]. 
*0*(S (Chunk let/VB VARgencontext/NNP) (Chunk be/VB VARgenerator/NNP) ./. [/VB [/JJ (Chunk GENERATORCONTEXT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARmethodcontext be the running execution context. 
*0*(S (Chunk let/VB VARmethodcontext/NNP) be/VB the/DT running/JJ execution/NN context/NN ./.)
*0*suspend VARmethodcontext. 
*0*(S suspend/NN (Chunk VARmethodcontext/NNP) ./.)
*0*set VARgenerator.[[GENERATORSTATE]] to "executing". 
*0*(S (Chunk set/VBN VARgenerator/NNP) ./. [/VB [/JJ (Chunk GENERATORSTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` executing/VBG ''/'' ./.)
*0*push VARgencontext onto the execution context stack; VARgencontext is now the running execution context. 
*0*(S push/NN (Chunk VARgencontext/NNP) onto/IN the/DT execution/NN context/NN stack/NN ;/: (Chunk VARgencontext/NNP) is/VBZ now/RB the/DT running/VBG execution/NN context/NN ./.)
*0*resume the suspended evaluation of VARgencontext using VARabruptcompletion as the result of the operation that suspended it. let VARresult be the completion record returned by the resumed computation. 
*0*(S resume/VB the/DT suspended/JJ evaluation/NN of/IN (Chunk VARgencontext/NNP) (Chunk using/VBG VARabruptcompletion/NNP) as/IN the/DT result/NN of/IN the/DT operation/NN that/WDT suspended/VBD it/PRP ./. (Chunk let/VB VARresult/NNP) be/VB the/DT completion/NN record/NN returned/VBN by/IN the/DT resumed/JJ computation/NN ./.)
*0*assert: when we return here, VARgencontext has already been removed from the execution context stack and VARmethodcontext is the currently running execution context. 
*0*(S assert/NN :/: when/WRB we/PRP return/VBP here/RB ,/, (Chunk VARgencontext/NNP) has/VBZ already/RB been/VBN removed/VBN from/IN the/DT execution/NN context/NN stack/NN and/CC (Chunk VARmethodcontext/NNP) is/VBZ the/DT currently/RB running/VBG execution/NN context/NN ./.)
*0*return FUNCcompletion(VARresult).     
*0*(S return/NN (Chunk FUNCcompletion/NNP) (/( (Chunk VARresult/NNP) )/) ./.)
ID= 25.4.3.5
Summary= GetGeneratorKind ( )
*0*let VARgencontext be the running execution context. 
*0*(S (Chunk let/VB VARgencontext/NNP) be/VB the/DT running/JJ execution/NN context/NN ./.)
*0*if VARgencontext does not have a generator component, return non-generator. 
*0*(S if/IN (Chunk VARgencontext/NNP) does/VBZ not/RB have/VB a/DT generator/NN component/NN ,/, return/VB non-generator/NN ./.)
*0*let VARgenerator be the generator component of VARgencontext. 
*0*(S (Chunk let/VB VARgenerator/NNP) be/VB the/DT generator/NN component/NN of/IN (Chunk VARgencontext/NNP) ./.)
*0*if VARgenerator has an [[ASYNCGENERATORSTATE]] internal slot, return async. 
*0*(S if/IN (Chunk VARgenerator/NNP) has/VBZ an/DT [/JJ [/NN (Chunk ASYNCGENERATORSTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, return/NN async/NN ./.)
*0*else, return sync.     
*0*(S else/RB ,/, return/NN sync/NN ./.)
ID= 25.4.3.6
Summary= GeneratorYield ( iterNextObj )
*0*assert: VARiternextobj is an object that implements the iteratorresult interface. 
*0*(S assert/NN :/: (Chunk VARiternextobj/NNP) is/VBZ an/DT object/NN that/WDT implements/VBZ the/DT iteratorresult/NN interface/NN ./.)
*0*let VARgencontext be the running execution context. 
*0*(S (Chunk let/VB VARgencontext/NNP) be/VB the/DT running/JJ execution/NN context/NN ./.)
*0*assert: VARgencontext is the execution context of a generator. 
*0*(S assert/NN :/: (Chunk VARgencontext/NNP) is/VBZ the/DT execution/NN context/NN of/IN a/DT generator/NN ./.)
*0*let VARgenerator be the value of the generator component of VARgencontext. 
*0*(S (Chunk let/VB VARgenerator/NNP) be/VB the/DT value/NN of/IN the/DT generator/NN component/NN of/IN (Chunk VARgencontext/NNP) ./.)
*0*assert: FUNCgetgeneratorkind() is sync. 
*0*(S assert/NN :/: (Chunk FUNCgetgeneratorkind/NNP) (/( )/) is/VBZ sync/JJ ./.)
*0*set VARgenerator.[[GENERATORSTATE]] to "suspendedyield". 
*0*(S (Chunk set/VBN VARgenerator/NNP) ./. [/VB [/JJ (Chunk GENERATORSTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` suspendedyield/VB ''/'' ./.)
*0*remove VARgencontext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context. 
*0*(S (Chunk remove/VB VARgencontext/NNP) from/IN the/DT execution/NN context/NN stack/NN and/CC restore/VB the/DT execution/NN context/NN that/WDT is/VBZ at/IN the/DT top/NN of/IN the/DT execution/NN context/NN stack/NN as/IN the/DT running/VBG execution/NN context/NN ./.)
*0*set the code evaluation state of VARgencontext such that when evaluation is resumed with a completion VARresumptionvalue the following steps will be performed:
*0*(S set/VB the/DT code/NN evaluation/NN state/NN of/IN (Chunk VARgencontext/NNP) such/JJ that/IN when/WRB evaluation/NN is/VBZ resumed/VBN with/IN a/DT completion/NN (Chunk VARresumptionvalue/NNP) the/DT following/JJ steps/NNS will/MD be/VB performed/VBN :/:)
*1*return VARresumptionvalue. 
*1*(S return/NN (Chunk VARresumptionvalue/NNP) ./.)
*1*note: this returns to the evaluation of the yieldexpression that originally called this abstract operation. 
*1*(S note/NN :/: this/DT returns/VBZ to/TO the/DT evaluation/NN of/IN the/DT yieldexpression/NN that/WDT originally/RB called/VBD this/DT abstract/JJ operation/NN ./.)
*0*return FUNCnormalcompletion(VARiternextobj). 
*0*(S return/NN (Chunk FUNCnormalcompletion/NNP) (/( (Chunk VARiternextobj/NNP) )/) ./.)
*0*note: this returns to the evaluation of the operation that had most previously resumed evaluation of VARgencontext.     
*0*(S note/NN :/: this/DT returns/VBZ to/TO the/DT evaluation/NN of/IN the/DT operation/NN that/WDT had/VBD most/RBS previously/RB resumed/VBN evaluation/NN of/IN (Chunk VARgencontext/NNP) ./.)
ID= 25.5.1.2
Summary= AsyncGenerator.prototype.next ( value )
*0*let VARgenerator be the this value. 
*0*(S (Chunk let/VB VARgenerator/NNP) be/VB the/DT this/DT value/NN ./.)
*0*let VARcompletion be FUNCnormalcompletion(VARvalue). 
*0*(S (Chunk let/VB VARcompletion/NNP) (Chunk be/VB FUNCnormalcompletion/NNP) (/( (Chunk VARvalue/NNP) )/) ./.)
*0*return ! FUNCasyncgeneratorenqueue(VARgenerator, VARcompletion).     
*0*(S return/NN !/. (Chunk FUNCasyncgeneratorenqueue/NNP) (/( (Chunk VARgenerator/NNP) ,/, (Chunk VARcompletion/NNP) )/) ./.)
ID= 25.5.1.3
Summary= AsyncGenerator.prototype.return ( value )
*0*let VARgenerator be the this value. 
*0*(S (Chunk let/VB VARgenerator/NNP) be/VB the/DT this/DT value/NN ./.)
*0*let VARcompletion be completion { [[TYPE]]: return, [[VALUE]]: VARvalue, [[TARGET]]: empty }. 
*0*(S (Chunk let/VB VARcompletion/NNP) be/VB completion/NN {/( [/JJ (Chunk [/NNP) (Chunk TYPE/NNP) (Chunk ]/NNP) ]/NN :/: return/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARvalue/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk TARGET/NNP) (Chunk ]/NNP) ]/NN :/: empty/JJ }/) ./.)
*0*return ! FUNCasyncgeneratorenqueue(VARgenerator, VARcompletion).     
*0*(S return/NN !/. (Chunk FUNCasyncgeneratorenqueue/NNP) (/( (Chunk VARgenerator/NNP) ,/, (Chunk VARcompletion/NNP) )/) ./.)
ID= 25.5.1.4
Summary= AsyncGenerator.prototype.throw ( exception )
*0*let VARgenerator be the this value. 
*0*(S (Chunk let/VB VARgenerator/NNP) be/VB the/DT this/DT value/NN ./.)
*0*let VARcompletion be FUNCthrowcompletion(VARexception). 
*0*(S (Chunk let/VB VARcompletion/NNP) (Chunk be/VB FUNCthrowcompletion/NNP) (/( (Chunk VARexception/NNP) )/) ./.)
*0*return ! FUNCasyncgeneratorenqueue(VARgenerator, VARcompletion).     
*0*(S return/NN !/. (Chunk FUNCasyncgeneratorenqueue/NNP) (/( (Chunk VARgenerator/NNP) ,/, (Chunk VARcompletion/NNP) )/) ./.)
ID= 25.5.3.2
Summary= AsyncGeneratorStart ( generator, generatorBody )
*0*assert: VARgenerator is an asyncgenerator instance. 
*0*(S assert/NN :/: VARgenerator/NN is/VBZ an/DT asyncgenerator/NN instance/NN ./.)
*0*assert: VARgenerator.[[ASYNCGENERATORSTATE]] is undefined. 
*0*(S assert/NN :/: VARgenerator/NN ./. [/CC [/JJ (Chunk ASYNCGENERATORSTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ undefined/VBN ./.)
*0*let VARgencontext be the running execution context. 
*0*(S (Chunk let/VB VARgencontext/NNP) be/VB the/DT running/JJ execution/NN context/NN ./.)
*0*set the generator component of VARgencontext to VARgenerator. 
*0*(S set/VB the/DT generator/NN component/NN of/IN (Chunk VARgencontext/NNP) to/TO (Chunk VARgenerator/NNP) ./.)
*0*set the code evaluation state of VARgencontext such that when evaluation is resumed for that execution context the following steps will be performed:
*0*(S set/VB the/DT code/NN evaluation/NN state/NN of/IN (Chunk VARgencontext/NNP) such/JJ that/IN when/WRB evaluation/NN is/VBZ resumed/VBN for/IN that/DT execution/NN context/VBD the/DT following/JJ steps/NNS will/MD be/VB performed/VBN :/:)
*1*let VARresult be the result of evaluating VARgeneratorbody. 
*1*(S (Chunk let/VB VARresult/NNP) be/VB the/DT result/NN of/IN (Chunk evaluating/VBG VARgeneratorbody/NNP) ./.)
*1*assert: if we return here, the async generator either threw an exception or performed either an implicit or explicit return. 
*1*(S assert/NN :/: if/IN we/PRP return/VBP here/RB ,/, the/DT async/NN generator/NN either/CC threw/VBD an/DT exception/NN or/CC performed/VBN either/CC an/DT implicit/NN or/CC explicit/JJ return/NN ./.)
*1*remove VARgencontext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context. 
*1*(S (Chunk remove/VB VARgencontext/NNP) from/IN the/DT execution/NN context/NN stack/NN and/CC restore/VB the/DT execution/NN context/NN that/WDT is/VBZ at/IN the/DT top/NN of/IN the/DT execution/NN context/NN stack/NN as/IN the/DT running/VBG execution/NN context/NN ./.)
*1*set VARgenerator.[[ASYNCGENERATORSTATE]] to "completed". 
*1*(S (Chunk set/VBN VARgenerator/NNP) ./. [/VB [/JJ (Chunk ASYNCGENERATORSTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` completed/VBN ''/'' ./.)
*1*if VARresult is a normal completion, let VARresultvalue be undefined. 
*1*(S if/IN (Chunk VARresult/NNP) is/VBZ a/DT normal/JJ completion/NN ,/, (Chunk let/VB VARresultvalue/NNP) be/VB undefined/VBN ./.)
*1*else,
*1*(S else/RB ,/,)
*2*let VARresultvalue be VARresult.[[VALUE]]. 
*2*(S (Chunk let/VB VARresultvalue/NNP) (Chunk be/VB VARresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*2*if VARresult.[[TYPE]] is not return, then
*2*(S if/IN (Chunk VARresult/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB return/JJ ,/, then/RB)
*3*return ! FUNCasyncgeneratorreject(VARgenerator, VARresultvalue). 
*3*(S return/NN !/. (Chunk FUNCasyncgeneratorreject/NNP) (/( (Chunk VARgenerator/NNP) ,/, (Chunk VARresultvalue/NNP) )/) ./.)
*1*return ! FUNCasyncgeneratorresolve(VARgenerator, VARresultvalue, true). 
*1*(S return/NN !/. (Chunk FUNCasyncgeneratorresolve/NNP) (/( (Chunk VARgenerator/NNP) ,/, (Chunk VARresultvalue/NNP) ,/, true/JJ )/) ./.)
*0*set VARgenerator.[[ASYNCGENERATORCONTEXT]] to VARgencontext. 
*0*(S (Chunk set/VBN VARgenerator/NNP) ./. [/VB [/JJ (Chunk ASYNCGENERATORCONTEXT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARgencontext/NNP) ./.)
*0*set VARgenerator.[[ASYNCGENERATORSTATE]] to "suspendedstart". 
*0*(S (Chunk set/VBN VARgenerator/NNP) ./. [/VB [/JJ (Chunk ASYNCGENERATORSTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` suspendedstart/VB ''/'' ./.)
*0*set VARgenerator.[[ASYNCGENERATORQUEUE]] to a new empty list. 
*0*(S (Chunk set/VBN VARgenerator/NNP) ./. [/VB [/JJ (Chunk ASYNCGENERATORQUEUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO a/DT new/JJ empty/JJ list/NN ./.)
*0*return undefined.     
*0*(S return/NN undefined/VBD ./.)
ID= 25.5.3.3
Summary= AsyncGeneratorResolve ( generator, value, done )
*0*assert: VARgenerator is an asyncgenerator instance. 
*0*(S assert/NN :/: VARgenerator/NN is/VBZ an/DT asyncgenerator/NN instance/NN ./.)
*0*let VARqueue be VARgenerator.[[ASYNCGENERATORQUEUE]]. 
*0*(S (Chunk let/VB VARqueue/NNP) (Chunk be/VB VARgenerator/NNP) ./. [/VB [/JJ (Chunk ASYNCGENERATORQUEUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*assert: VARqueue is not an empty list. 
*0*(S assert/NN :/: (Chunk VARqueue/NNP) is/VBZ not/RB an/DT empty/JJ list/NN ./.)
*0*remove the first element from VARqueue and let VARnext be the value of that element. 
*0*(S remove/VB the/DT first/JJ element/NN from/IN (Chunk VARqueue/NNP) and/CC (Chunk let/VB VARnext/NNP) be/VB the/DT value/NN of/IN that/DT element/NN ./.)
*0*let VARpromisecapability be VARnext.[[CAPABILITY]]. 
*0*(S (Chunk let/VB VARpromisecapability/NNP) (Chunk be/VB VARnext/NNP) ./. [/VB [/JJ (Chunk CAPABILITY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARiteratorresult be ! FUNCcreateiterresultobject(VARvalue, VARdone). 
*0*(S (Chunk let/VB VARiteratorresult/NNP) be/VB !/. (Chunk FUNCcreateiterresultobject/NNP) (/( (Chunk VARvalue/NNP) ,/, (Chunk VARdone/NNP) )/) ./.)
*0*perform ! FUNCcall(VARpromisecapability.[[RESOLVE]], undefined, « VARiteratorresult »). 
*0*(S perform/NN !/. (Chunk FUNCcall/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk RESOLVE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, (Chunk «/NNP) (Chunk VARiteratorresult/NNP) (Chunk »/NNP) )/) ./.)
*0*perform ! FUNCasyncgeneratorresumenext(VARgenerator). 
*0*(S perform/NN !/. (Chunk FUNCasyncgeneratorresumenext/NNP) (/( (Chunk VARgenerator/NNP) )/) ./.)
*0*return undefined.     
*0*(S return/NN undefined/VBD ./.)
ID= 25.5.3.4
Summary= AsyncGeneratorReject ( generator, exception )
*0*assert: VARgenerator is an asyncgenerator instance. 
*0*(S assert/NN :/: VARgenerator/NN is/VBZ an/DT asyncgenerator/NN instance/NN ./.)
*0*let VARqueue be VARgenerator.[[ASYNCGENERATORQUEUE]]. 
*0*(S (Chunk let/VB VARqueue/NNP) (Chunk be/VB VARgenerator/NNP) ./. [/VB [/JJ (Chunk ASYNCGENERATORQUEUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*assert: VARqueue is not an empty list. 
*0*(S assert/NN :/: (Chunk VARqueue/NNP) is/VBZ not/RB an/DT empty/JJ list/NN ./.)
*0*remove the first element from VARqueue and let VARnext be the value of that element. 
*0*(S remove/VB the/DT first/JJ element/NN from/IN (Chunk VARqueue/NNP) and/CC (Chunk let/VB VARnext/NNP) be/VB the/DT value/NN of/IN that/DT element/NN ./.)
*0*let VARpromisecapability be VARnext.[[CAPABILITY]]. 
*0*(S (Chunk let/VB VARpromisecapability/NNP) (Chunk be/VB VARnext/NNP) ./. [/VB [/JJ (Chunk CAPABILITY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*perform ! FUNCcall(VARpromisecapability.[[REJECT]], undefined, « VARexception »). 
*0*(S perform/NN !/. (Chunk FUNCcall/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk REJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, «/JJ (Chunk VARexception/NNP) (Chunk »/NNP) )/) ./.)
*0*perform ! FUNCasyncgeneratorresumenext(VARgenerator). 
*0*(S perform/NN !/. (Chunk FUNCasyncgeneratorresumenext/NNP) (/( (Chunk VARgenerator/NNP) )/) ./.)
*0*return undefined.     
*0*(S return/NN undefined/VBD ./.)
ID= 25.5.3.5
Summary= AsyncGeneratorResumeNext ( generator )
*0*assert: VARgenerator is an asyncgenerator instance. 
*0*(S assert/NN :/: VARgenerator/NN is/VBZ an/DT asyncgenerator/NN instance/NN ./.)
*0*let VARstate be VARgenerator.[[ASYNCGENERATORSTATE]]. 
*0*(S (Chunk let/VB VARstate/NNP) (Chunk be/VB VARgenerator/NNP) ./. [/VB [/JJ (Chunk ASYNCGENERATORSTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*assert: VARstate is not "executing". 
*0*(S assert/NN :/: (Chunk VARstate/NNP) is/VBZ not/RB ``/`` executing/VBG ''/'' ./.)
*0*if VARstate is "awaiting-return", return undefined. 
*0*(S if/IN (Chunk VARstate/NNP) is/VBZ ``/`` awaiting-return/JJ ''/'' ,/, return/NN undefined/VBD ./.)
*0*let VARqueue be VARgenerator.[[ASYNCGENERATORQUEUE]]. 
*0*(S (Chunk let/VB VARqueue/NNP) (Chunk be/VB VARgenerator/NNP) ./. [/VB [/JJ (Chunk ASYNCGENERATORQUEUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARqueue is an empty list, return undefined. 
*0*(S if/IN (Chunk VARqueue/NNP) is/VBZ an/DT empty/JJ list/NN ,/, return/NN undefined/VBD ./.)
*0*let VARnext be the value of the first element of VARqueue. 
*0*(S (Chunk let/VB VARnext/NNP) be/VB the/DT value/NN of/IN the/DT first/JJ element/NN of/IN (Chunk VARqueue/NNP) ./.)
*0*assert: VARnext is an asyncgeneratorrequest record. 
*0*(S assert/NN :/: (Chunk VARnext/NNP) is/VBZ an/DT asyncgeneratorrequest/NN record/NN ./.)
*0*let VARcompletion be VARnext.[[COMPLETION]]. 
*0*(S (Chunk let/VB VARcompletion/NNP) (Chunk be/VB VARnext/NNP) ./. [/NN [/JJ (Chunk COMPLETION/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARcompletion is an abrupt completion, then
*0*(S if/IN (Chunk VARcompletion/NNP) is/VBZ an/DT abrupt/JJ completion/NN ,/, then/RB)
*1*if VARstate is "suspendedstart", then
*1*(S if/IN (Chunk VARstate/NNP) is/VBZ ``/`` suspendedstart/JJ ''/'' ,/, then/RB)
*2*set VARgenerator.[[ASYNCGENERATORSTATE]] to "completed". 
*2*(S (Chunk set/VBN VARgenerator/NNP) ./. [/VB [/JJ (Chunk ASYNCGENERATORSTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` completed/VBN ''/'' ./.)
*2*set VARstate to "completed". 
*2*(S (Chunk set/VBN VARstate/NNP) to/TO ``/`` completed/VBN ''/'' ./.)
*1*if VARstate is "completed", then
*1*(S if/IN (Chunk VARstate/NNP) is/VBZ ``/`` completed/VBN ''/'' ,/, then/RB)
*2*if VARcompletion.[[TYPE]] is return, then
*2*(S if/IN (Chunk VARcompletion/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ return/NN ,/, then/RB)
*3*set VARgenerator.[[ASYNCGENERATORSTATE]] to "awaiting-return". 
*3*(S (Chunk set/VBN VARgenerator/NNP) ./. [/VB [/JJ (Chunk ASYNCGENERATORSTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` awaiting-return/JJ ''/'' ./.)
*3*let VARpromisecapability be ! FUNCnewpromisecapability(%promise%). 
*3*(S (Chunk let/VB VARpromisecapability/NNP) be/VB !/. (Chunk FUNCnewpromisecapability/NNP) (/( %/NN promise/NN %/NN )/) ./.)
*3*perform ! FUNCcall(VARpromisecapability.[[RESOLVE]], undefined, « VARcompletion.[[VALUE]] »). 
*3*(S perform/NN !/. (Chunk FUNCcall/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk RESOLVE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, «/JJ (Chunk VARcompletion/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*3*let VARstepsfulfilled be the algorithm steps defined in asyncgeneratorresumenext return processor fulfilled functions. 
*3*(S (Chunk let/VB VARstepsfulfilled/NNP) be/VB the/DT algorithm/JJ steps/NNS defined/VBN in/IN asyncgeneratorresumenext/JJ return/NN processor/NN fulfilled/VBD functions/NNS ./.)
*3*let VARonfulfilled be FUNCcreatebuiltinfunction(VARstepsfulfilled, « [[GENERATOR]] »). 
*3*(S (Chunk let/VB VARonfulfilled/NNP) (Chunk be/VB FUNCcreatebuiltinfunction/NNP) (/( (Chunk VARstepsfulfilled/NNP) ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk GENERATOR/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*3*set VARonfulfilled.[[GENERATOR]] to VARgenerator. 
*3*(S set/NN (Chunk VARonfulfilled/NNP) ./. [/VB [/JJ (Chunk GENERATOR/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARgenerator/NNP) ./.)
*3*let VARstepsrejected be the algorithm steps defined in asyncgeneratorresumenext return processor rejected functions. 
*3*(S (Chunk let/VB VARstepsrejected/NNP) be/VB the/DT algorithm/JJ steps/NNS defined/VBN in/IN asyncgeneratorresumenext/JJ return/NN processor/NN rejected/VBD functions/NNS ./.)
*3*let VARonrejected be FUNCcreatebuiltinfunction(VARstepsrejected, « [[GENERATOR]] »). 
*3*(S (Chunk let/VB VARonrejected/NNP) (Chunk be/VB FUNCcreatebuiltinfunction/NNP) (/( (Chunk VARstepsrejected/NNP) ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk GENERATOR/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*3*set VARonrejected.[[GENERATOR]] to VARgenerator. 
*3*(S set/NN (Chunk VARonrejected/NNP) ./. [/VB [/JJ (Chunk GENERATOR/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARgenerator/NNP) ./.)
*3*let VARthrowawaycapability be ! FUNCnewpromisecapability(%promise%). 
*3*(S (Chunk let/VB VARthrowawaycapability/NNP) be/VB !/. (Chunk FUNCnewpromisecapability/NNP) (/( %/NN promise/NN %/NN )/) ./.)
*3*set VARthrowawaycapability.[[PROMISE]].[[PROMISEISHANDLED]] to true. 
*3*(S (Chunk set/VBN VARthrowawaycapability./NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./. (Chunk [/VB [/NNP) (Chunk PROMISEISHANDLED/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO true/JJ ./.)
*3*perform ! FUNCperformpromisethen(VARpromisecapability.[[PROMISE]], VARonfulfilled, VARonrejected, VARthrowawaycapability). 
*3*(S perform/NN !/. (Chunk FUNCperformpromisethen/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARonfulfilled/NNP) ,/, (Chunk VARonrejected/NNP) ,/, (Chunk VARthrowawaycapability/NNP) )/) ./.)
*3*return undefined. 
*3*(S return/NN undefined/VBD ./.)
*2*else,
*2*(S else/RB ,/,)
*3*assert: VARcompletion.[[TYPE]] is throw. 
*3*(S assert/NN :/: VARcompletion/NN ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ throw/JJ ./.)
*3*perform ! FUNCasyncgeneratorreject(VARgenerator, VARcompletion.[[VALUE]]). 
*3*(S perform/NN !/. (Chunk FUNCasyncgeneratorreject/NNP) (/( (Chunk VARgenerator/NNP) ,/, (Chunk VARcompletion/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*3*return undefined. 
*3*(S return/NN undefined/VBD ./.)
*0*else if VARstate is "completed", return ! FUNCasyncgeneratorresolve(VARgenerator, undefined, true). 
*0*(S else/RB if/IN (Chunk VARstate/NNP) is/VBZ ``/`` completed/VBN ''/'' ,/, return/NN !/. (Chunk FUNCasyncgeneratorresolve/NNP) (/( (Chunk VARgenerator/NNP) ,/, undefined/JJ ,/, true/JJ )/) ./.)
*0*assert: VARstate is either "suspendedstart" or "suspendedyield". 
*0*(S assert/NN :/: (Chunk VARstate/NNP) is/VBZ either/CC ``/`` suspendedstart/NN ''/'' or/CC ``/`` suspendedyield/JJ ''/'' ./.)
*0*let VARgencontext be VARgenerator.[[ASYNCGENERATORCONTEXT]]. 
*0*(S (Chunk let/VB VARgencontext/NNP) (Chunk be/VB VARgenerator/NNP) ./. [/VB [/JJ (Chunk ASYNCGENERATORCONTEXT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARcallercontext be the running execution context. 
*0*(S (Chunk let/VB VARcallercontext/NNP) be/VB the/DT running/JJ execution/NN context/NN ./.)
*0*suspend VARcallercontext. 
*0*(S suspend/NN (Chunk VARcallercontext/NNP) ./.)
*0*set VARgenerator.[[ASYNCGENERATORSTATE]] to "executing". 
*0*(S (Chunk set/VBN VARgenerator/NNP) ./. [/VB [/JJ (Chunk ASYNCGENERATORSTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` executing/VBG ''/'' ./.)
*0*push VARgencontext onto the execution context stack; VARgencontext is now the running execution context. 
*0*(S push/NN (Chunk VARgencontext/NNP) onto/IN the/DT execution/NN context/NN stack/NN ;/: (Chunk VARgencontext/NNP) is/VBZ now/RB the/DT running/VBG execution/NN context/NN ./.)
*0*resume the suspended evaluation of VARgencontext using VARcompletion as the result of the operation that suspended it. let VARresult be the completion record returned by the resumed computation. 
*0*(S resume/VB the/DT suspended/JJ evaluation/NN of/IN (Chunk VARgencontext/NNP) (Chunk using/VBG VARcompletion/NNP) as/IN the/DT result/NN of/IN the/DT operation/NN that/WDT suspended/VBD it/PRP ./. (Chunk let/VB VARresult/NNP) be/VB the/DT completion/NN record/NN returned/VBN by/IN the/DT resumed/JJ computation/NN ./.)
*0*assert: VARresult is never an abrupt completion. 
*0*(S assert/NN :/: VARresult/NN is/VBZ never/RB an/DT abrupt/JJ completion/NN ./.)
*0*assert: when we return here, VARgencontext has already been removed from the execution context stack and VARcallercontext is the currently running execution context. 
*0*(S assert/NN :/: when/WRB we/PRP return/VBP here/RB ,/, (Chunk VARgencontext/NNP) has/VBZ already/RB been/VBN removed/VBN from/IN the/DT execution/NN context/NN stack/NN and/CC (Chunk VARcallercontext/NNP) is/VBZ the/DT currently/RB running/VBG execution/NN context/NN ./.)
*0*return undefined.     
*0*(S return/NN undefined/VBD ./.)
ID= 25.5.3.6
Summary= AsyncGeneratorEnqueue ( generator, completion )
*0*assert: VARcompletion is a completion record. 
*0*(S assert/NN :/: VARcompletion/NN is/VBZ a/DT completion/NN record/NN ./.)
*0*let VARpromisecapability be ! FUNCnewpromisecapability(%promise%). 
*0*(S (Chunk let/VB VARpromisecapability/NNP) be/VB !/. (Chunk FUNCnewpromisecapability/NNP) (/( %/NN promise/NN %/NN )/) ./.)
*0*if FUNCtype(VARgenerator) is not object, or if VARgenerator does not have an [[ASYNCGENERATORSTATE]] internal slot, then
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARgenerator/NNP) )/) is/VBZ not/RB object/JJ ,/, or/CC if/IN (Chunk VARgenerator/NNP) does/VBZ not/RB have/VB an/DT [/JJ [/NN (Chunk ASYNCGENERATORSTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, then/RB)
*1*let VARbadgeneratorerror be a newly created typeerror object. 
*1*(S (Chunk let/VB VARbadgeneratorerror/NNP) be/VB a/DT newly/RB created/VBN typeerror/NN object/NN ./.)
*1*perform ! FUNCcall(VARpromisecapability.[[REJECT]], undefined, « VARbadgeneratorerror »). 
*1*(S perform/NN !/. (Chunk FUNCcall/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk REJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, (Chunk «/NNP) (Chunk VARbadgeneratorerror/NNP) (Chunk »/NNP) )/) ./.)
*1*return VARpromisecapability.[[PROMISE]]. 
*1*(S return/NN (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARqueue be VARgenerator.[[ASYNCGENERATORQUEUE]]. 
*0*(S (Chunk let/VB VARqueue/NNP) (Chunk be/VB VARgenerator/NNP) ./. [/VB [/JJ (Chunk ASYNCGENERATORQUEUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARrequest be asyncgeneratorrequest { [[COMPLETION]]: VARcompletion, [[CAPABILITY]]: VARpromisecapability }. 
*0*(S (Chunk let/VB VARrequest/NNP) be/VB asyncgeneratorrequest/RB {/( [/JJ (Chunk [/NNP) (Chunk COMPLETION/NNP) (Chunk ]/NNP) ]/NN :/: VARcompletion/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk CAPABILITY/NNP) (Chunk ]/NNP) ]/NN :/: VARpromisecapability/NN }/) ./.)
*0*append VARrequest to the end of VARqueue. 
*0*(S (Chunk append/RB VARrequest/NNP) to/TO the/DT end/NN of/IN (Chunk VARqueue/NNP) ./.)
*0*let VARstate be VARgenerator.[[ASYNCGENERATORSTATE]]. 
*0*(S (Chunk let/VB VARstate/NNP) (Chunk be/VB VARgenerator/NNP) ./. [/VB [/JJ (Chunk ASYNCGENERATORSTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARstate is not "executing", then
*0*(S if/IN (Chunk VARstate/NNP) is/VBZ not/RB ``/`` executing/VBG ''/'' ,/, then/RB)
*1*perform ! FUNCasyncgeneratorresumenext(VARgenerator). 
*1*(S perform/NN !/. (Chunk FUNCasyncgeneratorresumenext/NNP) (/( (Chunk VARgenerator/NNP) )/) ./.)
*0*return VARpromisecapability.[[PROMISE]].     
*0*(S return/NN (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
ID= 25.5.3.7
Summary= AsyncGeneratorYield ( value )
*0*let VARgencontext be the running execution context. 
*0*(S (Chunk let/VB VARgencontext/NNP) be/VB the/DT running/JJ execution/NN context/NN ./.)
*0*assert: VARgencontext is the execution context of a generator. 
*0*(S assert/NN :/: (Chunk VARgencontext/NNP) is/VBZ the/DT execution/NN context/NN of/IN a/DT generator/NN ./.)
*0*let VARgenerator be the value of the generator component of VARgencontext. 
*0*(S (Chunk let/VB VARgenerator/NNP) be/VB the/DT value/NN of/IN the/DT generator/NN component/NN of/IN (Chunk VARgencontext/NNP) ./.)
*0*assert: FUNCgetgeneratorkind() is async. 
*0*(S assert/NN :/: (Chunk FUNCgetgeneratorkind/NNP) (/( )/) is/VBZ async/JJ ./.)
*0*set VARvalue to ? await(VARvalue). 
*0*(S (Chunk set/VBN VARvalue/NNP) to/TO ?/. await/NN (/( (Chunk VARvalue/NNP) )/) ./.)
*0*set VARgenerator.[[ASYNCGENERATORSTATE]] to "suspendedyield". 
*0*(S (Chunk set/VBN VARgenerator/NNP) ./. [/VB [/JJ (Chunk ASYNCGENERATORSTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` suspendedyield/VB ''/'' ./.)
*0*remove VARgencontext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context. 
*0*(S (Chunk remove/VB VARgencontext/NNP) from/IN the/DT execution/NN context/NN stack/NN and/CC restore/VB the/DT execution/NN context/NN that/WDT is/VBZ at/IN the/DT top/NN of/IN the/DT execution/NN context/NN stack/NN as/IN the/DT running/VBG execution/NN context/NN ./.)
*0*set the code evaluation state of VARgencontext such that when evaluation is resumed with a completion VARresumptionvalue the following steps will be performed:
*0*(S set/VB the/DT code/NN evaluation/NN state/NN of/IN (Chunk VARgencontext/NNP) such/JJ that/IN when/WRB evaluation/NN is/VBZ resumed/VBN with/IN a/DT completion/NN (Chunk VARresumptionvalue/NNP) the/DT following/JJ steps/NNS will/MD be/VB performed/VBN :/:)
*1*if VARresumptionvalue.[[TYPE]] is not return, return FUNCcompletion(VARresumptionvalue). 
*1*(S if/IN (Chunk VARresumptionvalue/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ not/RB return/JJ ,/, return/JJ (Chunk FUNCcompletion/NNP) (/( (Chunk VARresumptionvalue/NNP) )/) ./.)
*1*let VARawaited be await(VARresumptionvalue.[[VALUE]]). 
*1*(S (Chunk let/VB VARawaited/NNP) be/VB await/VBN (/( (Chunk VARresumptionvalue/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*1*if VARawaited.[[TYPE]] is throw, return FUNCcompletion(VARawaited). 
*1*(S if/IN VARawaited/VBN ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ throw/JJ ,/, return/JJ (Chunk FUNCcompletion/NNP) (/( VARawaited/VBN )/) ./.)
*1*assert: VARawaited.[[TYPE]] is normal. 
*1*(S assert/NN :/: VARawaited/VBN ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ normal/JJ ./.)
*1*return completion { [[TYPE]]: return, [[VALUE]]: VARawaited.[[VALUE]], [[TARGET]]: empty }. 
*1*(S return/NN completion/NN {/( [/JJ (Chunk [/NNP) (Chunk TYPE/NNP) (Chunk ]/NNP) ]/NN :/: return/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: VARawaited/VBN ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk TARGET/NNP) (Chunk ]/NNP) ]/NN :/: empty/JJ }/) ./.)
*1*note: when one of the above steps returns, it returns to the evaluation of the yieldexpression production that originally called this abstract operation. 
*1*(S note/NN :/: when/WRB one/CD of/IN the/DT above/JJ steps/NNS returns/NNS ,/, it/PRP returns/VBZ to/TO the/DT evaluation/NN of/IN the/DT yieldexpression/NN production/NN that/WDT originally/RB called/VBD this/DT abstract/JJ operation/NN ./.)
*0*return ! FUNCasyncgeneratorresolve(VARgenerator, VARvalue, false). 
*0*(S return/NN !/. (Chunk FUNCasyncgeneratorresolve/NNP) (/( (Chunk VARgenerator/NNP) ,/, (Chunk VARvalue/NNP) ,/, false/RB )/) ./.)
*0*note: this returns to the evaluation of the operation that had most previously resumed evaluation of VARgencontext.     
*0*(S note/NN :/: this/DT returns/VBZ to/TO the/DT evaluation/NN of/IN the/DT operation/NN that/WDT had/VBD most/RBS previously/RB resumed/VBN evaluation/NN of/IN (Chunk VARgencontext/NNP) ./.)
ID= 25.6.1.1.1
Summary= IfAbruptRejectPromise ( value, capability )
*0*FUNCifabruptrejectpromise(VARvalue, VARcapability).      
*0*(S (Chunk FUNCifabruptrejectpromise/NNP) (/( (Chunk VARvalue/NNP) ,/, (Chunk VARcapability/NNP) )/) ./.)
ID= 25.6.1.3
Summary= CreateResolvingFunctions ( promise )
*0*let VARalreadyresolved be a new record { [[VALUE]]: false }. 
*0*(S (Chunk let/VB VARalreadyresolved/NNP) be/VB a/DT new/JJ record/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) ./.)
*0*let VARstepsresolve be the algorithm steps defined in promise resolve functions (25.6.1.3.2). 
*0*(S (Chunk let/VB VARstepsresolve/NNP) be/VB the/DT algorithm/JJ steps/NNS defined/VBN in/IN promise/NN resolve/NN functions/NNS (/( 25.6.1.3.2/CD )/) ./.)
*0*let VARresolve be FUNCcreatebuiltinfunction(VARstepsresolve, « [[PROMISE]], [[ALREADYRESOLVED]] »). 
*0*(S (Chunk let/VB VARresolve/NNP) (Chunk be/VB FUNCcreatebuiltinfunction/NNP) (/( (Chunk VARstepsresolve/NNP) ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ALREADYRESOLVED/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARresolve.[[PROMISE]] to VARpromise. 
*0*(S (Chunk set/VBN VARresolve/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARpromise/NNP) ./.)
*0*set VARresolve.[[ALREADYRESOLVED]] to VARalreadyresolved. 
*0*(S (Chunk set/VBN VARresolve/NNP) ./. [/VB [/JJ (Chunk ALREADYRESOLVED/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARalreadyresolved/NNP) ./.)
*0*let VARstepsreject be the algorithm steps defined in promise reject functions (25.6.1.3.1). 
*0*(S (Chunk let/VB VARstepsreject/NNP) be/VB the/DT algorithm/JJ steps/NNS defined/VBN in/IN promise/NN reject/NN functions/NNS (/( 25.6.1.3.1/CD )/) ./.)
*0*let VARreject be FUNCcreatebuiltinfunction(VARstepsreject, « [[PROMISE]], [[ALREADYRESOLVED]] »). 
*0*(S (Chunk let/VB VARreject/NNP) (Chunk be/VB FUNCcreatebuiltinfunction/NNP) (/( (Chunk VARstepsreject/NNP) ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ALREADYRESOLVED/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARreject.[[PROMISE]] to VARpromise. 
*0*(S (Chunk set/VBN VARreject/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARpromise/NNP) ./.)
*0*set VARreject.[[ALREADYRESOLVED]] to VARalreadyresolved. 
*0*(S (Chunk set/VBN VARreject/NNP) ./. [/VB [/JJ (Chunk ALREADYRESOLVED/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARalreadyresolved/NNP) ./.)
*0*return a new record { [[RESOLVE]]: VARresolve, [[REJECT]]: VARreject }.     
*0*(S return/VB a/DT new/JJ record/NN {/( [/JJ (Chunk [/NNP) (Chunk RESOLVE/NNP) (Chunk ]/NNP) ]/NN :/: (Chunk VARresolve/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk REJECT/NNP) (Chunk ]/NNP) ]/NN :/: VARreject/JJ }/) ./.)
ID= 25.6.1.4
Summary= FulfillPromise ( promise, value )
*0*assert: the value of VARpromise.[[PROMISESTATE]] is "pending". 
*0*(S assert/NN :/: the/DT value/NN of/IN (Chunk VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISESTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` pending/VBG ''/'' ./.)
*0*let VARreactions be VARpromise.[[PROMISEFULFILLREACTIONS]]. 
*0*(S (Chunk let/VB VARreactions/NNP) (Chunk be/VB VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISEFULFILLREACTIONS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*set VARpromise.[[PROMISERESULT]] to VARvalue. 
*0*(S (Chunk set/VBN VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISERESULT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARvalue/NNP) ./.)
*0*set VARpromise.[[PROMISEFULFILLREACTIONS]] to undefined. 
*0*(S (Chunk set/VBN VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISEFULFILLREACTIONS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO undefined/VB ./.)
*0*set VARpromise.[[PROMISEREJECTREACTIONS]] to undefined. 
*0*(S (Chunk set/VBN VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISEREJECTREACTIONS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO undefined/VB ./.)
*0*set VARpromise.[[PROMISESTATE]] to "fulfilled". 
*0*(S (Chunk set/VBN VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISESTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` fulfilled/VBN ''/'' ./.)
*0*return FUNCtriggerpromisereactions(VARreactions, VARvalue).     
*0*(S return/NN FUNCtriggerpromisereactions/NNS (/( (Chunk VARreactions/NNP) ,/, (Chunk VARvalue/NNP) )/) ./.)
ID= 25.6.1.5
Summary= NewPromiseCapability ( C )
*0*if FUNCisconstructor(VARc) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisconstructor/NNP) (/( (Chunk VARc/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*note: VARc is assumed to be a constructor function that supports the parameter conventions of the promise constructor (see 25.6.3.1). 
*0*(S note/NN :/: (Chunk VARc/NNP) is/VBZ assumed/VBN to/TO be/VB a/DT constructor/NN function/NN that/WDT supports/VBZ the/DT parameter/NN conventions/NNS of/IN the/DT promise/NN constructor/NN (/( see/VB 25.6.3.1/CD )/) ./.)
*0*let VARpromisecapability be a new promisecapability { [[PROMISE]]: undefined, [[RESOLVE]]: undefined, [[REJECT]]: undefined }. 
*0*(S (Chunk let/VB VARpromisecapability/NNP) be/VB a/DT new/JJ promisecapability/NN {/( [/JJ (Chunk [/NNP) (Chunk PROMISE/NNP) (Chunk ]/NNP) ]/NN :/: undefined/JJ ,/, [/JJ (Chunk [/NNP) (Chunk RESOLVE/NNP) (Chunk ]/NNP) ]/NN :/: undefined/JJ ,/, [/JJ [/NN (Chunk REJECT/NNP) (Chunk ]/NNP) ]/NN :/: undefined/JJ }/) ./.)
*0*let VARsteps be the algorithm steps defined in getcapabilitiesexecutor functions. 
*0*(S (Chunk let/VB VARsteps/NNP) be/VB the/DT algorithm/JJ steps/NNS defined/VBN in/IN getcapabilitiesexecutor/NN functions/NNS ./.)
*0*let VARexecutor be FUNCcreatebuiltinfunction(VARsteps, « [[CAPABILITY]] »). 
*0*(S (Chunk let/VB VARexecutor/NNP) (Chunk be/VB FUNCcreatebuiltinfunction/NNP) (/( (Chunk VARsteps/NNP) ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk CAPABILITY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARexecutor.[[CAPABILITY]] to VARpromisecapability. 
*0*(S (Chunk set/VBN VARexecutor/NNP) ./. [/VB [/JJ (Chunk CAPABILITY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARpromisecapability/NNP) ./.)
*0*let VARpromise be ? FUNCconstruct(VARc, « VARexecutor »). 
*0*(S (Chunk let/VB VARpromise/NNP) be/VB ?/. (Chunk FUNCconstruct/NNP) (/( (Chunk VARc/NNP) ,/, (Chunk «/NNP) (Chunk VARexecutor/NNP) (Chunk »/NNP) )/) ./.)
*0*if FUNCiscallable(VARpromisecapability.[[RESOLVE]]) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk RESOLVE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if FUNCiscallable(VARpromisecapability.[[REJECT]]) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk REJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*set VARpromisecapability.[[PROMISE]] to VARpromise. 
*0*(S (Chunk set/VBN VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARpromise/NNP) ./.)
*0*return VARpromisecapability.     
*0*(S return/NN (Chunk VARpromisecapability/NNP) ./.)
ID= 25.6.1.6
Summary= IsPromise ( x )
*0*if FUNCtype(VARx) is not object, return false. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARx/NNP) )/) is/VBZ not/RB object/JJ ,/, return/NN false/JJ ./.)
*0*if VARx does not have a [[PROMISESTATE]] internal slot, return false. 
*0*(S if/IN (Chunk VARx/NNP) does/VBZ not/RB have/VB a/DT [/JJ [/NN (Chunk PROMISESTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) internal/JJ slot/NN ,/, return/NN false/JJ ./.)
*0*return true.     
*0*(S return/NN true/JJ ./.)
ID= 25.6.1.7
Summary= RejectPromise ( promise, reason )
*0*assert: the value of VARpromise.[[PROMISESTATE]] is "pending". 
*0*(S assert/NN :/: the/DT value/NN of/IN (Chunk VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISESTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` pending/VBG ''/'' ./.)
*0*let VARreactions be VARpromise.[[PROMISEREJECTREACTIONS]]. 
*0*(S (Chunk let/VB VARreactions/NNP) (Chunk be/VB VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISEREJECTREACTIONS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*set VARpromise.[[PROMISERESULT]] to VARreason. 
*0*(S (Chunk set/VBN VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISERESULT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARreason/NNP) ./.)
*0*set VARpromise.[[PROMISEFULFILLREACTIONS]] to undefined. 
*0*(S (Chunk set/VBN VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISEFULFILLREACTIONS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO undefined/VB ./.)
*0*set VARpromise.[[PROMISEREJECTREACTIONS]] to undefined. 
*0*(S (Chunk set/VBN VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISEREJECTREACTIONS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO undefined/VB ./.)
*0*set VARpromise.[[PROMISESTATE]] to "rejected". 
*0*(S (Chunk set/VBN VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISESTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` rejected/VBN ''/'' ./.)
*0*if VARpromise.[[PROMISEISHANDLED]] is false, perform FUNChostpromiserejectiontracker(VARpromise, "reject"). 
*0*(S if/IN (Chunk VARpromise/NNP) ./. (Chunk [/VB [/NNP) (Chunk PROMISEISHANDLED/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, perform/JJ (Chunk FUNChostpromiserejectiontracker/NNP) (/( (Chunk VARpromise/NNP) ,/, ``/`` reject/VB ''/'' )/) ./.)
*0*return FUNCtriggerpromisereactions(VARreactions, VARreason).     
*0*(S return/NN FUNCtriggerpromisereactions/NNS (/( (Chunk VARreactions/NNP) ,/, (Chunk VARreason/NNP) )/) ./.)
ID= 25.6.1.8
Summary= TriggerPromiseReactions ( reactions, argument )
*0*for each VARreaction in VARreactions, in original insertion order, do
*0*(S for/IN each/DT (Chunk VARreaction/NNP) in/IN (Chunk VARreactions/NNP) ,/, in/IN original/JJ insertion/NN order/NN ,/, do/VBP)
*1*perform FUNCenqueuejob("promisejobs", promisereactionjob, « VARreaction, VARargument »). 
*1*(S perform/NN (Chunk FUNCenqueuejob/NNP) (/( ``/`` promisejobs/NN ''/'' ,/, promisereactionjob/NN ,/, (Chunk «/NNP) (Chunk VARreaction/NNP) ,/, (Chunk VARargument/NNP) (Chunk »/NNP) )/) ./.)
*0*return undefined.     
*0*(S return/NN undefined/VBD ./.)
ID= 25.6.2.1
Summary= PromiseReactionJob ( reaction, argument )
*0*assert: VARreaction is a promisereaction record. 
*0*(S assert/NN :/: VARreaction/NN is/VBZ a/DT promisereaction/NN record/NN ./.)
*0*let VARpromisecapability be VARreaction.[[CAPABILITY]]. 
*0*(S (Chunk let/VB VARpromisecapability/NNP) (Chunk be/VB VARreaction/NNP) ./. [/VB [/JJ (Chunk CAPABILITY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARtype be VARreaction.[[TYPE]]. 
*0*(S (Chunk let/VB VARtype/NNP) (Chunk be/VB VARreaction/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*let VARhandler be VARreaction.[[HANDLER]]. 
*0*(S (Chunk let/VB VARhandler/NNP) (Chunk be/VB VARreaction/NNP) ./. [/VB [/JJ (Chunk HANDLER/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*if VARhandler is undefined, then
*0*(S if/IN (Chunk VARhandler/NNP) is/VBZ undefined/VBN ,/, then/RB)
*1*if VARtype is "fulfill", let VARhandlerresult be FUNCnormalcompletion(VARargument). 
*1*(S if/IN (Chunk VARtype/NNP) is/VBZ ``/`` fulfill/JJ ''/'' ,/, (Chunk let/VB VARhandlerresult/NNP) (Chunk be/VB FUNCnormalcompletion/NNP) (/( (Chunk VARargument/NNP) )/) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*assert: VARtype is "reject". 
*2*(S assert/NN :/: VARtype/NN is/VBZ ``/`` reject/JJ ''/'' ./.)
*2*let VARhandlerresult be FUNCthrowcompletion(VARargument). 
*2*(S (Chunk let/VB VARhandlerresult/NNP) (Chunk be/VB FUNCthrowcompletion/NNP) (/( (Chunk VARargument/NNP) )/) ./.)
*0*else, let VARhandlerresult be FUNCcall(VARhandler, undefined, « VARargument »). 
*0*(S else/RB ,/, (Chunk let/VB VARhandlerresult/NNP) (Chunk be/VB FUNCcall/NNP) (/( (Chunk VARhandler/NNP) ,/, undefined/VBD ,/, «/FW (Chunk VARargument/NNP) (Chunk »/NNP) )/) ./.)
*0*if VARhandlerresult is an abrupt completion, then
*0*(S if/IN (Chunk VARhandlerresult/NNP) is/VBZ an/DT abrupt/JJ completion/NN ,/, then/RB)
*1*let VARstatus be FUNCcall(VARpromisecapability.[[REJECT]], undefined, « VARhandlerresult.[[VALUE]] »). 
*1*(S (Chunk let/VB VARstatus/NNP) (Chunk be/VB FUNCcall/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk REJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, «/JJ (Chunk VARhandlerresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARstatus be FUNCcall(VARpromisecapability.[[RESOLVE]], undefined, « VARhandlerresult.[[VALUE]] »). 
*1*(S (Chunk let/VB VARstatus/NNP) (Chunk be/VB FUNCcall/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk RESOLVE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, «/JJ (Chunk VARhandlerresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*return FUNCcompletion(VARstatus).     
*0*(S return/NN (Chunk FUNCcompletion/NNP) (/( (Chunk VARstatus/NNP) )/) ./.)
ID= 25.6.2.2
Summary= PromiseResolveThenableJob ( promiseToResolve, thenable, then )
*0*let VARresolvingfunctions be FUNCcreateresolvingfunctions(VARpromisetoresolve). 
*0*(S (Chunk let/VB VARresolvingfunctions/NNP) (Chunk be/VB FUNCcreateresolvingfunctions/NNP) (/( (Chunk VARpromisetoresolve/NNP) )/) ./.)
*0*let VARthencallresult be FUNCcall(VARthen, VARthenable, « VARresolvingfunctions.[[RESOLVE]], VARresolvingfunctions.[[REJECT]] »). 
*0*(S (Chunk let/VB VARthencallresult/NNP) (Chunk be/VB FUNCcall/NNP) (/( (Chunk VARthen/NNP) ,/, (Chunk VARthenable/NNP) ,/, (Chunk «/NNP) (Chunk VARresolvingfunctions/NNP) ./. [/VB [/JJ (Chunk RESOLVE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARresolvingfunctions/NNP) ./. [/VB [/JJ (Chunk REJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*if VARthencallresult is an abrupt completion, then
*0*(S if/IN (Chunk VARthencallresult/NNP) is/VBZ an/DT abrupt/JJ completion/NN ,/, then/RB)
*1*let VARstatus be FUNCcall(VARresolvingfunctions.[[REJECT]], undefined, « VARthencallresult.[[VALUE]] »). 
*1*(S (Chunk let/VB VARstatus/NNP) (Chunk be/VB FUNCcall/NNP) (/( (Chunk VARresolvingfunctions/NNP) ./. [/VB [/JJ (Chunk REJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, «/JJ (Chunk VARthencallresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*1*return FUNCcompletion(VARstatus). 
*1*(S return/NN (Chunk FUNCcompletion/NNP) (/( (Chunk VARstatus/NNP) )/) ./.)
*0*return FUNCcompletion(VARthencallresult).     
*0*(S return/NN (Chunk FUNCcompletion/NNP) (/( (Chunk VARthencallresult/NNP) )/) ./.)
ID= 25.6.3.1
Summary= Promise ( executor )
*0*if newtarget is undefined, throw a typeerror exception. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if FUNCiscallable(VARexecutor) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARexecutor/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARpromise be ? FUNCordinarycreatefromconstructor(newtarget, "%promiseprototype%", « [[PROMISESTATE]], [[PROMISERESULT]], [[PROMISEFULFILLREACTIONS]], [[PROMISEREJECTREACTIONS]], [[PROMISEISHANDLED]] »). 
*0*(S (Chunk let/VB VARpromise/NNP) be/VB ?/. (Chunk FUNCordinarycreatefromconstructor/NNP) (/( newtarget/NN ,/, ``/`` %/NN promiseprototype/NN %/NN ''/'' ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk PROMISESTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk PROMISERESULT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk PROMISEFULFILLREACTIONS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk PROMISEREJECTREACTIONS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk PROMISEISHANDLED/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARpromise.[[PROMISESTATE]] to "pending". 
*0*(S (Chunk set/VBN VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISESTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO ``/`` pending/VBG ''/'' ./.)
*0*set VARpromise.[[PROMISEFULFILLREACTIONS]] to a new empty list. 
*0*(S (Chunk set/VBN VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISEFULFILLREACTIONS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO a/DT new/JJ empty/JJ list/NN ./.)
*0*set VARpromise.[[PROMISEREJECTREACTIONS]] to a new empty list. 
*0*(S (Chunk set/VBN VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISEREJECTREACTIONS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO a/DT new/JJ empty/JJ list/NN ./.)
*0*set VARpromise.[[PROMISEISHANDLED]] to false. 
*0*(S (Chunk set/VBN VARpromise/NNP) ./. (Chunk [/VB [/NNP) (Chunk PROMISEISHANDLED/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO false/VB ./.)
*0*let VARresolvingfunctions be FUNCcreateresolvingfunctions(VARpromise). 
*0*(S (Chunk let/VB VARresolvingfunctions/NNP) (Chunk be/VB FUNCcreateresolvingfunctions/NNP) (/( (Chunk VARpromise/NNP) )/) ./.)
*0*let VARcompletion be FUNCcall(VARexecutor, undefined, « VARresolvingfunctions.[[RESOLVE]], VARresolvingfunctions.[[REJECT]] »). 
*0*(S (Chunk let/VB VARcompletion/NNP) (Chunk be/VB FUNCcall/NNP) (/( (Chunk VARexecutor/NNP) ,/, undefined/VBD ,/, «/JJ (Chunk VARresolvingfunctions/NNP) ./. [/VB [/JJ (Chunk RESOLVE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARresolvingfunctions/NNP) ./. [/VB [/JJ (Chunk REJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*if VARcompletion is an abrupt completion, then
*0*(S if/IN (Chunk VARcompletion/NNP) is/VBZ an/DT abrupt/JJ completion/NN ,/, then/RB)
*1*perform ? FUNCcall(VARresolvingfunctions.[[REJECT]], undefined, « VARcompletion.[[VALUE]] »). 
*1*(S perform/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARresolvingfunctions/NNP) ./. [/VB [/JJ (Chunk REJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, «/JJ (Chunk VARcompletion/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*return VARpromise.     
*0*(S return/NN (Chunk VARpromise/NNP) ./.)
ID= 25.6.4.1
Summary= Promise.all ( iterable )
*0*let VARc be the this value. 
*0*(S (Chunk let/VB VARc/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARc) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARc/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARpromisecapability be ? FUNCnewpromisecapability(VARc). 
*0*(S (Chunk let/VB VARpromisecapability/NNP) be/VB ?/. (Chunk FUNCnewpromisecapability/NNP) (/( (Chunk VARc/NNP) )/) ./.)
*0*let VARiteratorrecord be FUNCgetiterator(VARiterable). 
*0*(S (Chunk let/VB VARiteratorrecord/NNP) (Chunk be/VB FUNCgetiterator/NNP) (/( (Chunk VARiterable/NNP) )/) ./.)
*0*FUNCifabruptrejectpromise(VARiteratorrecord, VARpromisecapability). 
*0*(S (Chunk FUNCifabruptrejectpromise/NNP) (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARpromisecapability/NNP) )/) ./.)
*0*let VARresult be FUNCperformpromiseall(VARiteratorrecord, VARc, VARpromisecapability). 
*0*(S (Chunk let/VB VARresult/NNP) (Chunk be/VB FUNCperformpromiseall/NNP) (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARc/NNP) ,/, (Chunk VARpromisecapability/NNP) )/) ./.)
*0*if VARresult is an abrupt completion, then
*0*(S if/IN (Chunk VARresult/NNP) is/VBZ an/DT abrupt/JJ completion/NN ,/, then/RB)
*1*if VARiteratorrecord.[[DONE]] is false, let VARresult be FUNCiteratorclose(VARiteratorrecord, VARresult). 
*1*(S if/IN (Chunk VARiteratorrecord/NNP) ./. [/NN [/IN (Chunk DONE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, (Chunk let/VB VARresult/NNP) (Chunk be/VB FUNCiteratorclose/NNP) (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARresult/NNP) )/) ./.)
*1*FUNCifabruptrejectpromise(VARresult, VARpromisecapability). 
*1*(S (Chunk FUNCifabruptrejectpromise/NNP) (/( (Chunk VARresult/NNP) ,/, (Chunk VARpromisecapability/NNP) )/) ./.)
*0*return FUNCcompletion(VARresult).     
*0*(S return/NN (Chunk FUNCcompletion/NNP) (/( (Chunk VARresult/NNP) )/) ./.)
ID= 25.6.4.1.1
Summary= Runtime Semantics: PerformPromiseAll ( iteratorRecord, constructor, resultCapability )
*0*assert: VARconstructor is a constructor function. 
*0*(S assert/NN :/: VARconstructor/NN is/VBZ a/DT constructor/NN function/NN ./.)
*0*assert: VARresultcapability is a promisecapability record. 
*0*(S assert/NN :/: VARresultcapability/NN is/VBZ a/DT promisecapability/NN record/NN ./.)
*0*let VARvalues be a new empty list. 
*0*(S (Chunk let/VB VARvalues/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*let VARremainingelementscount be a new record { [[VALUE]]: 1 }. 
*0*(S (Chunk let/VB VARremainingelementscount/NNP) be/VB a/DT new/JJ record/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) :/: 1/CD }/) ./.)
*0*let VARindex be 0. 
*0*(S (Chunk let/VB VARindex/NNP) be/VB 0/CD ./.)
*0*repeat,
*0*(S repeat/NN ,/,)
*1*let VARnext be FUNCiteratorstep(VARiteratorrecord). 
*1*(S (Chunk let/VB VARnext/NNP) (Chunk be/VB FUNCiteratorstep/NNP) (/( (Chunk VARiteratorrecord/NNP) )/) ./.)
*1*if VARnext is an abrupt completion, set VARiteratorrecord.[[DONE]] to true. 
*1*(S if/IN (Chunk VARnext/NNP) is/VBZ an/DT abrupt/JJ completion/NN ,/, (Chunk set/VBN VARiteratorrecord/NNP) ./. [/NN [/IN (Chunk DONE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO true/JJ ./.)
*1*FUNCreturnifabrupt(VARnext). 
*1*(S (Chunk FUNCreturnifabrupt/NNP) (/( (Chunk VARnext/NNP) )/) ./.)
*1*if VARnext is false, then
*1*(S if/IN (Chunk VARnext/NNP) is/VBZ false/JJ ,/, then/RB)
*2*set VARiteratorrecord.[[DONE]] to true. 
*2*(S (Chunk set/VBN VARiteratorrecord/NNP) ./. [/NN [/IN (Chunk DONE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO true/JJ ./.)
*2*set VARremainingelementscount.[[VALUE]] to VARremainingelementscount.[[VALUE]] - 1. 
*2*(S set/NN (Chunk VARremainingelementscount/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARremainingelementscount/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) -/: 1/CD ./.)
*2*if VARremainingelementscount.[[VALUE]] is 0, then
*2*(S if/IN (Chunk VARremainingelementscount/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ 0/CD ,/, then/RB)
*3*let VARvaluesarray be FUNCcreatearrayfromlist(VARvalues). 
*3*(S (Chunk let/VB VARvaluesarray/NNP) (Chunk be/VB FUNCcreatearrayfromlist/NNP) (/( (Chunk VARvalues/NNP) )/) ./.)
*3*perform ? FUNCcall(VARresultcapability.[[RESOLVE]], undefined, « VARvaluesarray »). 
*3*(S perform/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARresultcapability/NNP) ./. [/VB [/JJ (Chunk RESOLVE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, (Chunk «/NNP) (Chunk VARvaluesarray/NNP) (Chunk »/NNP) )/) ./.)
*2*return VARresultcapability.[[PROMISE]]. 
*2*(S return/NN (Chunk VARresultcapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*let VARnextvalue be FUNCiteratorvalue(VARnext). 
*1*(S (Chunk let/VB VARnextvalue/NNP) (Chunk be/VB FUNCiteratorvalue/NNP) (/( (Chunk VARnext/NNP) )/) ./.)
*1*if VARnextvalue is an abrupt completion, set VARiteratorrecord.[[DONE]] to true. 
*1*(S if/IN (Chunk VARnextvalue/NNP) is/VBZ an/DT abrupt/JJ completion/NN ,/, (Chunk set/VBN VARiteratorrecord/NNP) ./. [/NN [/IN (Chunk DONE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO true/JJ ./.)
*1*FUNCreturnifabrupt(VARnextvalue). 
*1*(S (Chunk FUNCreturnifabrupt/NNP) (/( (Chunk VARnextvalue/NNP) )/) ./.)
*1*append undefined to VARvalues. 
*1*(S append/NN undefined/VBD to/TO (Chunk VARvalues/NNP) ./.)
*1*let VARnextpromise be ? FUNCinvoke(VARconstructor, "resolve", « VARnextvalue »). 
*1*(S (Chunk let/VB VARnextpromise/NNP) be/VB ?/. (Chunk FUNCinvoke/NNP) (/( (Chunk VARconstructor/NNP) ,/, ``/`` resolve/NN ''/'' ,/, (Chunk «/NNP) (Chunk VARnextvalue/NNP) (Chunk »/NNP) )/) ./.)
*1*let VARsteps be the algorithm steps defined in promise.all resolve element functions. 
*1*(S (Chunk let/VB VARsteps/NNP) be/VB the/DT algorithm/JJ steps/NNS defined/VBN in/IN promise.all/NN resolve/VBP element/JJ functions/NNS ./.)
*1*let VARresolveelement be FUNCcreatebuiltinfunction(VARsteps, « [[ALREADYCALLED]], [[INDEX]], [[VALUES]], [[CAPABILITY]], [[REMAININGELEMENTS]] »). 
*1*(S (Chunk let/VB VARresolveelement/NNP) (Chunk be/VB FUNCcreatebuiltinfunction/NNP) (/( (Chunk VARsteps/NNP) ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk ALREADYCALLED/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk INDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk VALUES/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk CAPABILITY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk REMAININGELEMENTS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*1*set VARresolveelement.[[ALREADYCALLED]] to a new record { [[VALUE]]: false }. 
*1*(S (Chunk set/VBN VARresolveelement/NNP) ./. (Chunk [/VB [/NNP) (Chunk ALREADYCALLED/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO a/DT new/JJ record/NN {/( [/JJ (Chunk [/NNP) (Chunk VALUE/NNP) (Chunk ]/NNP) ]/NN :/: false/JJ }/) ./.)
*1*set VARresolveelement.[[INDEX]] to VARindex. 
*1*(S (Chunk set/VBN VARresolveelement/NNP) ./. (Chunk [/NNP) (Chunk [/NNP) (Chunk INDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARindex/NNP) ./.)
*1*set VARresolveelement.[[VALUES]] to VARvalues. 
*1*(S (Chunk set/VBN VARresolveelement/NNP) ./. [/VB [/JJ (Chunk VALUES/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARvalues/NNP) ./.)
*1*set VARresolveelement.[[CAPABILITY]] to VARresultcapability. 
*1*(S (Chunk set/VBN VARresolveelement/NNP) ./. [/VB [/JJ (Chunk CAPABILITY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARresultcapability/NNP) ./.)
*1*set VARresolveelement.[[REMAININGELEMENTS]] to VARremainingelementscount. 
*1*(S (Chunk set/VBN VARresolveelement/NNP) ./. [/VB [/JJ (Chunk REMAININGELEMENTS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARremainingelementscount/NNP) ./.)
*1*set VARremainingelementscount.[[VALUE]] to VARremainingelementscount.[[VALUE]] + 1. 
*1*(S set/NN (Chunk VARremainingelementscount/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARremainingelementscount/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) +/VBD 1/CD ./.)
*1*perform ? FUNCinvoke(VARnextpromise, "then", « VARresolveelement, VARresultcapability.[[REJECT]] »). 
*1*(S perform/NN ?/. (Chunk FUNCinvoke/NNP) (/( (Chunk VARnextpromise/NNP) ,/, ``/`` then/RB ''/'' ,/, (Chunk «/NNP) (Chunk VARresolveelement/NNP) ,/, (Chunk VARresultcapability/NNP) ./. [/VB [/JJ (Chunk REJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*1*set VARindex to VARindex + 1.      
*1*(S set/VBN VARindex/NN to/TO (Chunk VARindex/NNP) (Chunk +/NNP) 1/CD ./.)
ID= 25.6.4.3
Summary= Promise.race ( iterable )
*0*let VARc be the this value. 
*0*(S (Chunk let/VB VARc/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARc) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARc/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARpromisecapability be ? FUNCnewpromisecapability(VARc). 
*0*(S (Chunk let/VB VARpromisecapability/NNP) be/VB ?/. (Chunk FUNCnewpromisecapability/NNP) (/( (Chunk VARc/NNP) )/) ./.)
*0*let VARiteratorrecord be FUNCgetiterator(VARiterable). 
*0*(S (Chunk let/VB VARiteratorrecord/NNP) (Chunk be/VB FUNCgetiterator/NNP) (/( (Chunk VARiterable/NNP) )/) ./.)
*0*FUNCifabruptrejectpromise(VARiteratorrecord, VARpromisecapability). 
*0*(S (Chunk FUNCifabruptrejectpromise/NNP) (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARpromisecapability/NNP) )/) ./.)
*0*let VARresult be FUNCperformpromiserace(VARiteratorrecord, VARc, VARpromisecapability). 
*0*(S (Chunk let/VB VARresult/NNP) (Chunk be/VB FUNCperformpromiserace/NNP) (/( (Chunk VARiteratorrecord/NNP) ,/, (Chunk VARc/NNP) ,/, (Chunk VARpromisecapability/NNP) )/) ./.)
*0*if VARresult is an abrupt completion, then
*0*(S if/IN (Chunk VARresult/NNP) is/VBZ an/DT abrupt/JJ completion/NN ,/, then/RB)
*1*if VARiteratorrecord.[[DONE]] is false, let VARresult be FUNCiteratorclose(VARiterator, VARresult). 
*1*(S if/IN (Chunk VARiteratorrecord/NNP) ./. [/NN [/IN (Chunk DONE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, (Chunk let/VB VARresult/NNP) (Chunk be/VB FUNCiteratorclose/NNP) (/( (Chunk VARiterator/NNP) ,/, (Chunk VARresult/NNP) )/) ./.)
*1*FUNCifabruptrejectpromise(VARresult, VARpromisecapability). 
*1*(S (Chunk FUNCifabruptrejectpromise/NNP) (/( (Chunk VARresult/NNP) ,/, (Chunk VARpromisecapability/NNP) )/) ./.)
*0*return FUNCcompletion(VARresult).     
*0*(S return/NN (Chunk FUNCcompletion/NNP) (/( (Chunk VARresult/NNP) )/) ./.)
ID= 25.6.4.3.1
Summary= Runtime Semantics: PerformPromiseRace ( iteratorRecord, constructor, resultCapability )
*0*assert: VARconstructor is a constructor function. 
*0*(S assert/NN :/: VARconstructor/NN is/VBZ a/DT constructor/NN function/NN ./.)
*0*assert: VARresultcapability is a promisecapability record. 
*0*(S assert/NN :/: VARresultcapability/NN is/VBZ a/DT promisecapability/NN record/NN ./.)
*0*repeat,
*0*(S repeat/NN ,/,)
*1*let VARnext be FUNCiteratorstep(VARiteratorrecord). 
*1*(S (Chunk let/VB VARnext/NNP) (Chunk be/VB FUNCiteratorstep/NNP) (/( (Chunk VARiteratorrecord/NNP) )/) ./.)
*1*if VARnext is an abrupt completion, set VARiteratorrecord.[[DONE]] to true. 
*1*(S if/IN (Chunk VARnext/NNP) is/VBZ an/DT abrupt/JJ completion/NN ,/, (Chunk set/VBN VARiteratorrecord/NNP) ./. [/NN [/IN (Chunk DONE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO true/JJ ./.)
*1*FUNCreturnifabrupt(VARnext). 
*1*(S (Chunk FUNCreturnifabrupt/NNP) (/( (Chunk VARnext/NNP) )/) ./.)
*1*if VARnext is false, then
*1*(S if/IN (Chunk VARnext/NNP) is/VBZ false/JJ ,/, then/RB)
*2*set VARiteratorrecord.[[DONE]] to true. 
*2*(S (Chunk set/VBN VARiteratorrecord/NNP) ./. [/NN [/IN (Chunk DONE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO true/JJ ./.)
*2*return VARresultcapability.[[PROMISE]]. 
*2*(S return/NN (Chunk VARresultcapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*let VARnextvalue be FUNCiteratorvalue(VARnext). 
*1*(S (Chunk let/VB VARnextvalue/NNP) (Chunk be/VB FUNCiteratorvalue/NNP) (/( (Chunk VARnext/NNP) )/) ./.)
*1*if VARnextvalue is an abrupt completion, set VARiteratorrecord.[[DONE]] to true. 
*1*(S if/IN (Chunk VARnextvalue/NNP) is/VBZ an/DT abrupt/JJ completion/NN ,/, (Chunk set/VBN VARiteratorrecord/NNP) ./. [/NN [/IN (Chunk DONE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO true/JJ ./.)
*1*FUNCreturnifabrupt(VARnextvalue). 
*1*(S (Chunk FUNCreturnifabrupt/NNP) (/( (Chunk VARnextvalue/NNP) )/) ./.)
*1*let VARnextpromise be ? FUNCinvoke(VARconstructor, "resolve", « VARnextvalue »). 
*1*(S (Chunk let/VB VARnextpromise/NNP) be/VB ?/. (Chunk FUNCinvoke/NNP) (/( (Chunk VARconstructor/NNP) ,/, ``/`` resolve/NN ''/'' ,/, (Chunk «/NNP) (Chunk VARnextvalue/NNP) (Chunk »/NNP) )/) ./.)
*1*perform ? FUNCinvoke(VARnextpromise, "then", « VARresultcapability.[[RESOLVE]], VARresultcapability.[[REJECT]] »).      
*1*(S perform/NN ?/. (Chunk FUNCinvoke/NNP) (/( (Chunk VARnextpromise/NNP) ,/, ``/`` then/RB ''/'' ,/, (Chunk «/NNP) (Chunk VARresultcapability/NNP) ./. [/VB [/JJ (Chunk RESOLVE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARresultcapability/NNP) ./. [/VB [/JJ (Chunk REJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
ID= 25.6.4.4
Summary= Promise.reject ( r )
*0*let VARc be the this value. 
*0*(S (Chunk let/VB VARc/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARc) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARc/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARpromisecapability be ? FUNCnewpromisecapability(VARc). 
*0*(S (Chunk let/VB VARpromisecapability/NNP) be/VB ?/. (Chunk FUNCnewpromisecapability/NNP) (/( (Chunk VARc/NNP) )/) ./.)
*0*perform ? FUNCcall(VARpromisecapability.[[REJECT]], undefined, « VARr »). 
*0*(S perform/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk REJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, (Chunk «/NNP) (Chunk VARr/NNP) (Chunk »/NNP) )/) ./.)
*0*return VARpromisecapability.[[PROMISE]].     
*0*(S return/NN (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
ID= 25.6.4.5
Summary= Promise.resolve ( x )
*0*let VARc be the this value. 
*0*(S (Chunk let/VB VARc/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARc) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARc/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return ? FUNCpromiseresolve(VARc, VARx).     
*0*(S return/NN ?/. (Chunk FUNCpromiseresolve/NNP) (/( (Chunk VARc/NNP) ,/, (Chunk VARx/NNP) )/) ./.)
ID= 25.6.4.5.1
Summary= PromiseResolve ( C, x )
*0*assert: FUNCtype(VARc) is object. 
*0*(S assert/NN :/: (Chunk FUNCtype/NNP) (/( (Chunk VARc/NNP) )/) is/VBZ object/JJ ./.)
*0*if FUNCispromise(VARx) is true, then
*0*(S if/IN (Chunk FUNCispromise/NNP) (/( (Chunk VARx/NNP) )/) is/VBZ true/JJ ,/, then/RB)
*1*let VARxconstructor be ? FUNCget(VARx, "constructor"). 
*1*(S (Chunk let/VB VARxconstructor/NNP) be/VB ?/. (Chunk FUNCget/NNP) (/( (Chunk VARx/NNP) ,/, ``/`` constructor/NN ''/'' )/) ./.)
*1*if FUNCsamevalue(VARxconstructor, VARc) is true, return VARx. 
*1*(S if/IN (Chunk FUNCsamevalue/NNP) (/( (Chunk VARxconstructor/NNP) ,/, (Chunk VARc/NNP) )/) is/VBZ true/JJ ,/, (Chunk return/VB VARx/NNP) ./.)
*0*let VARpromisecapability be ? FUNCnewpromisecapability(VARc). 
*0*(S (Chunk let/VB VARpromisecapability/NNP) be/VB ?/. (Chunk FUNCnewpromisecapability/NNP) (/( (Chunk VARc/NNP) )/) ./.)
*0*perform ? FUNCcall(VARpromisecapability.[[RESOLVE]], undefined, « VARx »). 
*0*(S perform/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk RESOLVE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, (Chunk «/NNP) (Chunk VARx/NNP) (Chunk »/NNP) )/) ./.)
*0*return VARpromisecapability.[[PROMISE]].      
*0*(S return/NN (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
ID= 25.6.5.1
Summary= Promise.prototype.catch ( onRejected )
*0*let VARpromise be the this value. 
*0*(S (Chunk let/VB VARpromise/NNP) be/VB the/DT this/DT value/NN ./.)
*0*return ? FUNCinvoke(VARpromise, "then", « undefined, VARonrejected »).     
*0*(S return/NN ?/. (Chunk FUNCinvoke/NNP) (/( (Chunk VARpromise/NNP) ,/, ``/`` then/RB ''/'' ,/, (Chunk «/NNP) undefined/VBD ,/, (Chunk VARonrejected/NNP) (Chunk »/NNP) )/) ./.)
ID= 25.6.5.3
Summary= Promise.prototype.finally ( onFinally )
*0*let VARpromise be the this value. 
*0*(S (Chunk let/VB VARpromise/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCtype(VARpromise) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARpromise/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARc be ? FUNCspeciesconstructor(VARpromise, %promise%). 
*0*(S (Chunk let/VB VARc/NNP) be/VB ?/. (Chunk FUNCspeciesconstructor/NNP) (/( (Chunk VARpromise/NNP) ,/, %/NN promise/NN %/NN )/) ./.)
*0*assert: FUNCisconstructor(VARc) is true. 
*0*(S assert/NN :/: (Chunk FUNCisconstructor/NNP) (/( (Chunk VARc/NNP) )/) is/VBZ true/JJ ./.)
*0*if FUNCiscallable(VARonfinally) is false, then
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARonfinally/NNP) )/) is/VBZ false/JJ ,/, then/RB)
*1*let VARthenfinally be VARonfinally. 
*1*(S (Chunk let/VB VARthenfinally/NNP) (Chunk be/VB VARonfinally/NNP) ./.)
*1*let VARcatchfinally be VARonfinally. 
*1*(S (Chunk let/VB VARcatchfinally/NNP) (Chunk be/VB VARonfinally/NNP) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*let VARstepsthenfinally be the algorithm steps defined in then finally functions. 
*1*(S (Chunk let/VB VARstepsthenfinally/NNP) be/VB the/DT algorithm/JJ steps/NNS defined/VBN in/IN then/RB finally/RB functions/NNS ./.)
*1*let VARthenfinally be FUNCcreatebuiltinfunction(VARstepsthenfinally, « [[CONSTRUCTOR]], [[ONFINALLY]] »). 
*1*(S (Chunk let/VB VARthenfinally/NNP) (Chunk be/VB FUNCcreatebuiltinfunction/NNP) (/( (Chunk VARstepsthenfinally/NNP) ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk CONSTRUCTOR/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ONFINALLY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*1*set VARthenfinally.[[CONSTRUCTOR]] to VARc. 
*1*(S (Chunk set/VBN VARthenfinally/NNP) ./. [/VB [/JJ (Chunk CONSTRUCTOR/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARc/NNP) ./.)
*1*set VARthenfinally.[[ONFINALLY]] to VARonfinally. 
*1*(S (Chunk set/VBN VARthenfinally/NNP) ./. (Chunk [/VB [/NNP) (Chunk ONFINALLY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARonfinally/NNP) ./.)
*1*let VARstepscatchfinally be the algorithm steps defined in catch finally functions. 
*1*(S (Chunk let/VB VARstepscatchfinally/NNP) be/VB the/DT algorithm/JJ steps/NNS defined/VBN in/IN catch/NN finally/RB functions/NNS ./.)
*1*let VARcatchfinally be FUNCcreatebuiltinfunction(VARstepscatchfinally, « [[CONSTRUCTOR]], [[ONFINALLY]] »). 
*1*(S (Chunk let/VB VARcatchfinally/NNP) (Chunk be/VB FUNCcreatebuiltinfunction/NNP) (/( (Chunk VARstepscatchfinally/NNP) ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk CONSTRUCTOR/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk ONFINALLY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*1*set VARcatchfinally.[[CONSTRUCTOR]] to VARc. 
*1*(S (Chunk set/VBN VARcatchfinally/NNP) ./. [/VB [/JJ (Chunk CONSTRUCTOR/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARc/NNP) ./.)
*1*set VARcatchfinally.[[ONFINALLY]] to VARonfinally. 
*1*(S (Chunk set/VBN VARcatchfinally/NNP) ./. (Chunk [/VB [/NNP) (Chunk ONFINALLY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARonfinally/NNP) ./.)
*0*return ? FUNCinvoke(VARpromise, "then", « VARthenfinally, VARcatchfinally »).     
*0*(S return/NN ?/. (Chunk FUNCinvoke/NNP) (/( (Chunk VARpromise/NNP) ,/, ``/`` then/RB ''/'' ,/, (Chunk «/NNP) (Chunk VARthenfinally/NNP) ,/, (Chunk VARcatchfinally/NNP) (Chunk »/NNP) )/) ./.)
ID= 25.6.5.4
Summary= Promise.prototype.then ( onFulfilled, onRejected )
*0*let VARpromise be the this value. 
*0*(S (Chunk let/VB VARpromise/NNP) be/VB the/DT this/DT value/NN ./.)
*0*if FUNCispromise(VARpromise) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCispromise/NNP) (/( (Chunk VARpromise/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARc be ? FUNCspeciesconstructor(VARpromise, %promise%). 
*0*(S (Chunk let/VB VARc/NNP) be/VB ?/. (Chunk FUNCspeciesconstructor/NNP) (/( (Chunk VARpromise/NNP) ,/, %/NN promise/NN %/NN )/) ./.)
*0*let VARresultcapability be ? FUNCnewpromisecapability(VARc). 
*0*(S (Chunk let/VB VARresultcapability/NNP) be/VB ?/. (Chunk FUNCnewpromisecapability/NNP) (/( (Chunk VARc/NNP) )/) ./.)
*0*return FUNCperformpromisethen(VARpromise, VARonfulfilled, VARonrejected, VARresultcapability).     
*0*(S return/NN (Chunk FUNCperformpromisethen/NNP) (/( (Chunk VARpromise/NNP) ,/, (Chunk VARonfulfilled/NNP) ,/, (Chunk VARonrejected/NNP) ,/, (Chunk VARresultcapability/NNP) )/) ./.)
ID= 25.6.5.4.1
Summary= PerformPromiseThen ( promise, onFulfilled, onRejected, resultCapability )
*0*assert: FUNCispromise(VARpromise) is true. 
*0*(S assert/NN :/: (Chunk FUNCispromise/NNP) (/( (Chunk VARpromise/NNP) )/) is/VBZ true/JJ ./.)
*0*assert: VARresultcapability is a promisecapability record. 
*0*(S assert/NN :/: VARresultcapability/NN is/VBZ a/DT promisecapability/NN record/NN ./.)
*0*if FUNCiscallable(VARonfulfilled) is false, then
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( VARonfulfilled/VBN )/) is/VBZ false/JJ ,/, then/RB)
*1*set VARonfulfilled to undefined. 
*1*(S set/NN VARonfulfilled/VBD to/TO undefined/JJ ./.)
*0*if FUNCiscallable(VARonrejected) is false, then
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARonrejected/NNP) )/) is/VBZ false/JJ ,/, then/RB)
*1*set VARonrejected to undefined. 
*1*(S set/NN VARonrejected/VBD to/TO undefined/JJ ./.)
*0*let VARfulfillreaction be the promisereaction { [[CAPABILITY]]: VARresultcapability, [[TYPE]]: "fulfill", [[HANDLER]]: VARonfulfilled }. 
*0*(S (Chunk let/VB VARfulfillreaction/NNP) be/VB the/DT promisereaction/NN {/( [/JJ (Chunk [/NNP) (Chunk CAPABILITY/NNP) (Chunk ]/NNP) ]/NN :/: VARresultcapability/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk TYPE/NNP) (Chunk ]/NNP) ]/NN :/: ``/`` fulfill/NN ''/'' ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk HANDLER/NNP) (Chunk ]/NNP) ]/NN :/: VARonfulfilled/VBN }/) ./.)
*0*let VARrejectreaction be the promisereaction { [[CAPABILITY]]: VARresultcapability, [[TYPE]]: "reject", [[HANDLER]]: VARonrejected }. 
*0*(S (Chunk let/VB VARrejectreaction/NNP) be/VB the/DT promisereaction/NN {/( [/JJ (Chunk [/NNP) (Chunk CAPABILITY/NNP) (Chunk ]/NNP) ]/NN :/: VARresultcapability/NN ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk TYPE/NNP) (Chunk ]/NNP) ]/NN :/: ``/`` reject/NN ''/'' ,/, (Chunk [/NNP) (Chunk [/NNP) (Chunk HANDLER/NNP) (Chunk ]/NNP) ]/NN :/: VARonrejected/VBN }/) ./.)
*0*if VARpromise.[[PROMISESTATE]] is "pending", then
*0*(S if/IN (Chunk VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISESTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` pending/VBG ''/'' ,/, then/RB)
*1*append VARfulfillreaction as the last element of the list that is VARpromise.[[PROMISEFULFILLREACTIONS]]. 
*1*(S append/JJ (Chunk VARfulfillreaction/NNP) as/IN the/DT last/JJ element/NN of/IN the/DT list/NN that/WDT (Chunk is/VBZ VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISEFULFILLREACTIONS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*append VARrejectreaction as the last element of the list that is VARpromise.[[PROMISEREJECTREACTIONS]]. 
*1*(S append/JJ (Chunk VARrejectreaction/NNP) as/IN the/DT last/JJ element/NN of/IN the/DT list/NN that/WDT (Chunk is/VBZ VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISEREJECTREACTIONS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*else if VARpromise.[[PROMISESTATE]] is "fulfilled", then
*0*(S else/RB if/IN (Chunk VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISESTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` fulfilled/JJ ''/'' ,/, then/RB)
*1*let VARvalue be VARpromise.[[PROMISERESULT]]. 
*1*(S (Chunk let/VB VARvalue/NNP) (Chunk be/VB VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISERESULT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*perform FUNCenqueuejob("promisejobs", promisereactionjob, « VARfulfillreaction, VARvalue »). 
*1*(S perform/NN (Chunk FUNCenqueuejob/NNP) (/( ``/`` promisejobs/NN ''/'' ,/, promisereactionjob/NN ,/, (Chunk «/NNP) (Chunk VARfulfillreaction/NNP) ,/, (Chunk VARvalue/NNP) (Chunk »/NNP) )/) ./.)
*0*else,
*0*(S else/RB ,/,)
*1*assert: the value of VARpromise.[[PROMISESTATE]] is "rejected". 
*1*(S assert/NN :/: the/DT value/NN of/IN (Chunk VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISESTATE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ ``/`` rejected/JJ ''/'' ./.)
*1*let VARreason be VARpromise.[[PROMISERESULT]]. 
*1*(S (Chunk let/VB VARreason/NNP) (Chunk be/VB VARpromise/NNP) ./. [/VB [/JJ (Chunk PROMISERESULT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*if VARpromise.[[PROMISEISHANDLED]] is false, perform FUNChostpromiserejectiontracker(VARpromise, "handle"). 
*1*(S if/IN (Chunk VARpromise/NNP) ./. (Chunk [/VB [/NNP) (Chunk PROMISEISHANDLED/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ false/JJ ,/, perform/JJ (Chunk FUNChostpromiserejectiontracker/NNP) (/( (Chunk VARpromise/NNP) ,/, ``/`` handle/VB ''/'' )/) ./.)
*1*perform FUNCenqueuejob("promisejobs", promisereactionjob, « VARrejectreaction, VARreason »). 
*1*(S perform/NN (Chunk FUNCenqueuejob/NNP) (/( ``/`` promisejobs/NN ''/'' ,/, promisereactionjob/NN ,/, (Chunk «/NNP) (Chunk VARrejectreaction/NNP) ,/, (Chunk VARreason/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARpromise.[[PROMISEISHANDLED]] to true. 
*0*(S (Chunk set/VBN VARpromise/NNP) ./. (Chunk [/VB [/NNP) (Chunk PROMISEISHANDLED/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO true/JJ ./.)
*0*return VARresultcapability.[[PROMISE]].      
*0*(S return/NN (Chunk VARresultcapability/NNP) ./. [/VB [/JJ (Chunk PROMISE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
ID= 25.7.1.1
Summary= AsyncFunction ( p1, p2, … , pn, body )
*0*let VARc be the active function object. 
*0*(S (Chunk let/VB VARc/NNP) be/VB the/DT active/JJ function/NN object/NN ./.)
*0*let VARargs be the VARargumentslist that was passed to this function by [[CALL]] or [[CONSTRUCT]]. 
*0*(S (Chunk let/VB VARargs/NNP) be/VB the/DT (Chunk VARargumentslist/NNP) that/WDT was/VBD passed/VBN to/TO this/DT function/NN by/IN (Chunk [/NNP) (Chunk [/NNP) (Chunk CALL/NNP) (Chunk ]/NNP) (Chunk ]/NNP) or/CC (Chunk [/NNP) (Chunk [/NNP) (Chunk CONSTRUCT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*return FUNCcreatedynamicfunction(VARc, newtarget, "async", VARargs).     
*0*(S return/NN (Chunk FUNCcreatedynamicfunction/NNP) (/( (Chunk VARc/NNP) ,/, newtarget/NN ,/, ``/`` async/NN ''/'' ,/, (Chunk VARargs/NNP) )/) ./.)
ID= 25.7.5.1
Summary= AsyncFunctionStart ( promiseCapability, asyncFunctionBody )
*0*let VARrunningcontext be the running execution context. 
*0*(S (Chunk let/VB VARrunningcontext/NNP) be/VB the/DT running/JJ execution/NN context/NN ./.)
*0*let VARasynccontext be a copy of VARrunningcontext. 
*0*(S (Chunk let/VB VARasynccontext/NNP) be/VB a/DT copy/NN of/IN (Chunk VARrunningcontext/NNP) ./.)
*0*set the code evaluation state of VARasynccontext such that when evaluation is resumed for that execution context the following steps will be performed:
*0*(S set/VB the/DT code/NN evaluation/NN state/NN of/IN (Chunk VARasynccontext/NNP) such/JJ that/IN when/WRB evaluation/NN is/VBZ resumed/VBN for/IN that/DT execution/NN context/VBD the/DT following/JJ steps/NNS will/MD be/VB performed/VBN :/:)
*1*let VARresult be the result of evaluating VARasyncfunctionbody. 
*1*(S (Chunk let/VB VARresult/NNP) be/VB the/DT result/NN of/IN (Chunk evaluating/VBG VARasyncfunctionbody/NNP) ./.)
*1*assert: if we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done. 
*1*(S assert/NN :/: if/IN we/PRP return/VBP here/RB ,/, the/DT async/NN function/NN either/CC threw/VBD an/DT exception/NN or/CC performed/VBD an/DT implicit/NN or/CC explicit/JJ return/NN ;/: all/DT awaiting/NN is/VBZ done/VBN ./.)
*1*remove VARasynccontext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context. 
*1*(S (Chunk remove/VB VARasynccontext/NNP) from/IN the/DT execution/NN context/NN stack/NN and/CC restore/VB the/DT execution/NN context/NN that/WDT is/VBZ at/IN the/DT top/NN of/IN the/DT execution/NN context/NN stack/NN as/IN the/DT running/VBG execution/NN context/NN ./.)
*1*if VARresult.[[TYPE]] is normal, then
*1*(S if/IN (Chunk VARresult/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ normal/JJ ,/, then/RB)
*2*perform ! FUNCcall(VARpromisecapability.[[RESOLVE]], undefined, « undefined »). 
*2*(S perform/NN !/. (Chunk FUNCcall/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk RESOLVE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, (Chunk «/NNP) (Chunk undefined/VBD »/NNP) )/) ./.)
*1*else if VARresult.[[TYPE]] is return, then
*1*(S else/RB if/IN (Chunk VARresult/NNP) ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ return/NN ,/, then/RB)
*2*perform ! FUNCcall(VARpromisecapability.[[RESOLVE]], undefined, « VARresult.[[VALUE]] »). 
*2*(S perform/NN !/. (Chunk FUNCcall/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk RESOLVE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, «/JJ (Chunk VARresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*assert: VARresult.[[TYPE]] is throw. 
*2*(S assert/NN :/: VARresult/NN ./. [/VB [/JJ (Chunk TYPE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) is/VBZ throw/JJ ./.)
*2*perform ! FUNCcall(VARpromisecapability.[[REJECT]], undefined, « VARresult.[[VALUE]] »). 
*2*(S perform/NN !/. (Chunk FUNCcall/NNP) (/( (Chunk VARpromisecapability/NNP) ./. [/VB [/JJ (Chunk REJECT/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, undefined/VBD ,/, «/JJ (Chunk VARresult/NNP) ./. [/CC [/JJ (Chunk VALUE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*1*return. 
*1*(S return/NN ./.)
*0*push VARasynccontext onto the execution context stack; VARasynccontext is now the running execution context. 
*0*(S push/NN (Chunk VARasynccontext/NNP) onto/IN the/DT execution/NN context/NN stack/NN ;/: (Chunk VARasynccontext/NNP) is/VBZ now/RB the/DT running/VBG execution/NN context/NN ./.)
*0*resume the suspended evaluation of VARasynccontext. let VARresult be the value returned by the resumed computation. 
*0*(S resume/VB the/DT suspended/JJ evaluation/NN of/IN (Chunk VARasynccontext/NNP) ./. (Chunk let/VB VARresult/NNP) be/VB the/DT value/NN returned/VBN by/IN the/DT resumed/JJ computation/NN ./.)
*0*assert: when we return here, VARasynccontext has already been removed from the execution context stack and VARrunningcontext is the currently running execution context. 
*0*(S assert/NN :/: when/WRB we/PRP return/VBP here/RB ,/, (Chunk VARasynccontext/NNP) has/VBZ already/RB been/VBN removed/VBN from/IN the/DT execution/NN context/NN stack/NN and/CC (Chunk VARrunningcontext/NNP) is/VBZ the/DT currently/RB running/VBG execution/NN context/NN ./.)
*0*assert: VARresult is a normal completion with a value of undefined. the possible sources of completion values are await or, if the async function doesn't await anything, the step 3.g above. 
*0*(S assert/NN :/: VARresult/NN is/VBZ a/DT normal/JJ completion/NN with/IN a/DT value/NN of/IN undefined/JJ ./. the/DT possible/JJ sources/NNS of/IN completion/NN values/NNS are/VBP await/JJ or/CC ,/, if/IN the/DT async/JJ function/NN does/VBZ n't/RB await/VB anything/NN ,/, the/DT step/NN 3.g/CD above/IN ./.)
*0*return.     
*0*(S return/NN ./.)
ID= 26.1.1
Summary= Reflect.apply ( target, thisArgument, argumentsList )
*0*if FUNCiscallable(VARtarget) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCiscallable/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARargs be ? FUNCcreatelistfromarraylike(VARargumentslist). 
*0*(S (Chunk let/VB VARargs/NNP) be/VB ?/. (Chunk FUNCcreatelistfromarraylike/NNP) (/( (Chunk VARargumentslist/NNP) )/) ./.)
*0*perform FUNCpreparefortailcall(). 
*0*(S (Chunk perform/VB FUNCpreparefortailcall/NNP) (/( )/) ./.)
*0*return ? FUNCcall(VARtarget, VARthisargument, VARargs).    
*0*(S return/NN ?/. (Chunk FUNCcall/NNP) (/( (Chunk VARtarget/NNP) ,/, (Chunk VARthisargument/NNP) ,/, (Chunk VARargs/NNP) )/) ./.)
ID= 26.1.2
Summary= Reflect.construct ( target, argumentsList [ , newTarget ] )
*0*if FUNCisconstructor(VARtarget) is false, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCisconstructor/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if VARnewtarget is not present, let VARnewtarget be VARtarget. 
*0*(S if/IN (Chunk VARnewtarget/NNP) is/VBZ not/RB present/JJ ,/, (Chunk let/VB VARnewtarget/NNP) (Chunk be/VB VARtarget/NNP) ./.)
*0*else if FUNCisconstructor(VARnewtarget) is false, throw a typeerror exception. 
*0*(S else/RB if/IN (Chunk FUNCisconstructor/NNP) (/( (Chunk VARnewtarget/NNP) )/) is/VBZ false/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARargs be ? FUNCcreatelistfromarraylike(VARargumentslist). 
*0*(S (Chunk let/VB VARargs/NNP) be/VB ?/. (Chunk FUNCcreatelistfromarraylike/NNP) (/( (Chunk VARargumentslist/NNP) )/) ./.)
*0*return ? FUNCconstruct(VARtarget, VARargs, VARnewtarget).    
*0*(S return/NN ?/. (Chunk FUNCconstruct/NNP) (/( (Chunk VARtarget/NNP) ,/, (Chunk VARargs/NNP) ,/, (Chunk VARnewtarget/NNP) )/) ./.)
ID= 26.1.3
Summary= Reflect.defineProperty ( target, propertyKey, attributes )
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARkey be ? FUNCtopropertykey(VARpropertykey). 
*0*(S (Chunk let/VB VARkey/NNP) be/VB ?/. (Chunk FUNCtopropertykey/NNP) (/( (Chunk VARpropertykey/NNP) )/) ./.)
*0*let VARdesc be ? FUNCtopropertydescriptor(VARattributes). 
*0*(S (Chunk let/VB VARdesc/NNP) be/VB ?/. (Chunk FUNCtopropertydescriptor/NNP) (/( (Chunk VARattributes/NNP) )/) ./.)
*0*return ? VARtarget.[[DEFINEOWNPROPERTY]](VARkey, VARdesc).    
*0*(S return/NN ?/. (Chunk VARtarget/NNP) ./. (Chunk [/VB [/NNP) (Chunk DEFINEOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARkey/NNP) ,/, (Chunk VARdesc/NNP) )/) ./.)
ID= 26.1.4
Summary= Reflect.deleteProperty ( target, propertyKey )
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARkey be ? FUNCtopropertykey(VARpropertykey). 
*0*(S (Chunk let/VB VARkey/NNP) be/VB ?/. (Chunk FUNCtopropertykey/NNP) (/( (Chunk VARpropertykey/NNP) )/) ./.)
*0*return ? VARtarget.[[DELETE]](VARkey).    
*0*(S return/NN ?/. (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk DELETE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARkey/NNP) )/) ./.)
ID= 26.1.5
Summary= Reflect.get ( target, propertyKey [ , receiver ] )
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARkey be ? FUNCtopropertykey(VARpropertykey). 
*0*(S (Chunk let/VB VARkey/NNP) be/VB ?/. (Chunk FUNCtopropertykey/NNP) (/( (Chunk VARpropertykey/NNP) )/) ./.)
*0*if VARreceiver is not present, then
*0*(S if/IN (Chunk VARreceiver/NNP) is/VBZ not/RB present/JJ ,/, then/RB)
*1*let VARreceiver be VARtarget. 
*1*(S (Chunk let/VB VARreceiver/NNP) (Chunk be/VB VARtarget/NNP) ./.)
*0*return ? VARtarget.[[GET]](VARkey, VARreceiver).    
*0*(S return/NN ?/. (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk GET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARkey/NNP) ,/, (Chunk VARreceiver/NNP) )/) ./.)
ID= 26.1.6
Summary= Reflect.getOwnPropertyDescriptor ( target, propertyKey )
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARkey be ? FUNCtopropertykey(VARpropertykey). 
*0*(S (Chunk let/VB VARkey/NNP) be/VB ?/. (Chunk FUNCtopropertykey/NNP) (/( (Chunk VARpropertykey/NNP) )/) ./.)
*0*let VARdesc be ? VARtarget.[[GETOWNPROPERTY]](VARkey). 
*0*(S (Chunk let/VB VARdesc/NNP) be/VB ?/. (Chunk VARtarget/NNP) ./. (Chunk [/VB [/NNP) (Chunk GETOWNPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARkey/NNP) )/) ./.)
*0*return FUNCfrompropertydescriptor(VARdesc).    
*0*(S return/NN (Chunk FUNCfrompropertydescriptor/NNP) (/( (Chunk VARdesc/NNP) )/) ./.)
ID= 26.1.7
Summary= Reflect.getPrototypeOf ( target )
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return ? VARtarget.[[GETPROTOTYPEOF]]().    
*0*(S return/NN ?/. (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk GETPROTOTYPEOF/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
ID= 26.1.8
Summary= Reflect.has ( target, propertyKey )
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARkey be ? FUNCtopropertykey(VARpropertykey). 
*0*(S (Chunk let/VB VARkey/NNP) be/VB ?/. (Chunk FUNCtopropertykey/NNP) (/( (Chunk VARpropertykey/NNP) )/) ./.)
*0*return ? VARtarget.[[HASPROPERTY]](VARkey).    
*0*(S return/NN ?/. (Chunk VARtarget/NNP) ./. (Chunk [/VB [/NNP) (Chunk HASPROPERTY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARkey/NNP) )/) ./.)
ID= 26.1.9
Summary= Reflect.isExtensible ( target )
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return ? VARtarget.[[ISEXTENSIBLE]]().    
*0*(S return/NN ?/. (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk ISEXTENSIBLE/NNP) ]/NN (Chunk ]/NNP) (/( )/) ./.)
ID= 26.1.10
Summary= Reflect.ownKeys ( target )
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARkeys be ? VARtarget.[[OWNPROPERTYKEYS]](). 
*0*(S (Chunk let/VB VARkeys/NNP) be/VB ?/. (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk OWNPROPERTYKEYS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
*0*return FUNCcreatearrayfromlist(VARkeys).    
*0*(S return/NN (Chunk FUNCcreatearrayfromlist/NNP) (/( (Chunk VARkeys/NNP) )/) ./.)
ID= 26.1.11
Summary= Reflect.preventExtensions ( target )
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return ? VARtarget.[[PREVENTEXTENSIONS]]().    
*0*(S return/NN ?/. (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk PREVENTEXTENSIONS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( )/) ./.)
ID= 26.1.12
Summary= Reflect.set ( target, propertyKey, V [ , receiver ] )
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*let VARkey be ? FUNCtopropertykey(VARpropertykey). 
*0*(S (Chunk let/VB VARkey/NNP) be/VB ?/. (Chunk FUNCtopropertykey/NNP) (/( (Chunk VARpropertykey/NNP) )/) ./.)
*0*if VARreceiver is not present, then
*0*(S if/IN (Chunk VARreceiver/NNP) is/VBZ not/RB present/JJ ,/, then/RB)
*1*let VARreceiver be VARtarget. 
*1*(S (Chunk let/VB VARreceiver/NNP) (Chunk be/VB VARtarget/NNP) ./.)
*0*return ? VARtarget.[[SET]](VARkey, VARv, VARreceiver).    
*0*(S return/NN ?/. (Chunk VARtarget/NNP) ./. [/NN [/NN (Chunk SET/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARkey/NNP) ,/, (Chunk VARv/NNP) ,/, (Chunk VARreceiver/NNP) )/) ./.)
ID= 26.1.13
Summary= Reflect.setPrototypeOf ( target, proto )
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARtarget/NNP) )/) is/VBZ not/RB object/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*if FUNCtype(VARproto) is not object and VARproto is not null, throw a typeerror exception. 
*0*(S if/IN (Chunk FUNCtype/NNP) (/( (Chunk VARproto/NNP) )/) is/VBZ not/RB object/JJ and/CC (Chunk VARproto/NNP) is/VBZ not/RB null/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return ? VARtarget.[[SETPROTOTYPEOF]](VARproto).    
*0*(S return/NN ?/. (Chunk VARtarget/NNP) ./. [/VB [/JJ (Chunk SETPROTOTYPEOF/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARproto/NNP) )/) ./.)
ID= 26.2.1.1
Summary= Proxy ( target, handler )
*0*if newtarget is undefined, throw a typeerror exception. 
*0*(S if/IN newtarget/DT is/VBZ undefined/JJ ,/, throw/VB a/DT typeerror/NN exception/NN ./.)
*0*return ? FUNCproxycreate(VARtarget, VARhandler).     
*0*(S return/NN ?/. (Chunk FUNCproxycreate/NNP) (/( (Chunk VARtarget/NNP) ,/, (Chunk VARhandler/NNP) )/) ./.)
ID= 26.2.2.1
Summary= Proxy.revocable ( target, handler )
*0*let VARp be ? FUNCproxycreate(VARtarget, VARhandler). 
*0*(S (Chunk let/VB VARp/NNP) be/VB ?/. (Chunk FUNCproxycreate/NNP) (/( (Chunk VARtarget/NNP) ,/, (Chunk VARhandler/NNP) )/) ./.)
*0*let VARsteps be the algorithm steps defined in proxy revocation functions. 
*0*(S (Chunk let/VB VARsteps/NNP) be/VB the/DT algorithm/JJ steps/NNS defined/VBN in/IN proxy/JJ revocation/NN functions/NNS ./.)
*0*let VARrevoker be FUNCcreatebuiltinfunction(VARsteps, « [[REVOCABLEPROXY]] »). 
*0*(S (Chunk let/VB VARrevoker/NNP) (Chunk be/VB FUNCcreatebuiltinfunction/NNP) (/( (Chunk VARsteps/NNP) ,/, (Chunk «/NNP) (Chunk [/NNP) (Chunk [/NNP) (Chunk REVOCABLEPROXY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk »/NNP) )/) ./.)
*0*set VARrevoker.[[REVOCABLEPROXY]] to VARp. 
*0*(S (Chunk set/VBN VARrevoker/NNP) ./. [/VB [/JJ (Chunk REVOCABLEPROXY/NNP) (Chunk ]/NNP) (Chunk ]/NNP) to/TO (Chunk VARp/NNP) ./.)
*0*let VARresult be FUNCobjectcreate(%objectprototype%). 
*0*(S (Chunk let/VB VARresult/NNP) (Chunk be/VB FUNCobjectcreate/NNP) (/( %/NN objectprototype/IN %/NN )/) ./.)
*0*perform FUNCcreatedataproperty(VARresult, "proxy", VARp). 
*0*(S perform/NN (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARresult/NNP) ,/, ``/`` proxy/NN ''/'' ,/, (Chunk VARp/NNP) )/) ./.)
*0*perform FUNCcreatedataproperty(VARresult, "revoke", VARrevoker). 
*0*(S perform/NN (Chunk FUNCcreatedataproperty/NNP) (/( (Chunk VARresult/NNP) ,/, ``/`` revoke/NN ''/'' ,/, (Chunk VARrevoker/NNP) )/) ./.)
*0*return VARresult.     
*0*(S return/NN (Chunk VARresult/NNP) ./.)
ID= 27.5.1
Summary= EventSet ( execution )
*0*let VARevents be an empty set. 
*0*(S (Chunk let/VB VARevents/NNP) be/VB an/DT empty/JJ set/NN ./.)
*0*for each agent events record VARaer in VARexecution.[[EVENTLISTS]], do
*0*(S for/IN each/DT agent/NN events/NNS record/NN (Chunk VARaer/NNP) in/IN (Chunk VARexecution/NNP) ./. [/VB [/JJ (Chunk EVENTLISTS/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, do/VBP)
*1*for each event VARe in VARaer.[[EVENTLIST]], do
*1*(S for/IN each/DT event/NN (Chunk VARe/NNP) in/IN (Chunk VARaer/NNP) ./. [/VB [/JJ (Chunk EVENTLIST/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, do/VBP)
*2*add VARe to VARevents. 
*2*(S add/NNS (Chunk VARe/NNP) to/TO VARevents/NNS ./.)
*0*return VARevents.    
*0*(S return/NN VARevents/NNS ./.)
ID= 27.5.2
Summary= SharedDataBlockEventSet ( execution )
*0*let VARevents be an empty set. 
*0*(S (Chunk let/VB VARevents/NNP) be/VB an/DT empty/JJ set/NN ./.)
*0*for each event VARe in FUNCeventset(VARexecution), do
*0*(S for/IN each/DT event/NN (Chunk VARe/NNP) in/IN (Chunk FUNCeventset/NNP) (/( (Chunk VARexecution/NNP) )/) ,/, do/VBP)
*1*if VARe is a readsharedmemory, writesharedmemory, or readmodifywritesharedmemory event, add VARe to VARevents. 
*1*(S if/IN (Chunk VARe/NNP) is/VBZ a/DT readsharedmemory/NN ,/, writesharedmemory/NN ,/, or/CC readmodifywritesharedmemory/JJ event/NN ,/, (Chunk add/VB VARe/NNP) to/TO VARevents/NNS ./.)
*0*return VARevents.    
*0*(S return/NN VARevents/NNS ./.)
ID= 27.5.3
Summary= HostEventSet ( execution )
*0*let VARevents be an empty set. 
*0*(S (Chunk let/VB VARevents/NNP) be/VB an/DT empty/JJ set/NN ./.)
*0*for each event VARe in FUNCeventset(VARexecution), do
*0*(S for/IN each/DT event/NN (Chunk VARe/NNP) in/IN (Chunk FUNCeventset/NNP) (/( (Chunk VARexecution/NNP) )/) ,/, do/VBP)
*1*if VARe is not in FUNCshareddatablockeventset(VARexecution), add VARe to VARevents. 
*1*(S if/IN (Chunk VARe/NNP) is/VBZ not/RB in/IN (Chunk FUNCshareddatablockeventset/NNP) (/( (Chunk VARexecution/NNP) )/) ,/, (Chunk add/VBP VARe/NNP) to/TO VARevents/NNS ./.)
*0*return VARevents.    
*0*(S return/NN VARevents/NNS ./.)
ID= 27.5.4
Summary= ComposeWriteEventBytes ( execution, byteIndex, Ws )
*0*let VARbytelocation be VARbyteindex. 
*0*(S (Chunk let/VB VARbytelocation/NNP) (Chunk be/VB VARbyteindex/NNP) ./.)
*0*let VARbytesread be a new empty list. 
*0*(S (Chunk let/VB VARbytesread/NNP) be/VB a/DT new/JJ empty/JJ list/NN ./.)
*0*for each element VARw of VARws in list order, do
*0*(S for/IN each/DT element/NN (Chunk VARw/NNP) of/IN (Chunk VARws/NNP) in/IN list/NN order/NN ,/, do/VBP)
*1*assert: VARw has VARbytelocation in its range. 
*1*(S assert/NN :/: (Chunk VARw/NNP) (Chunk has/VBZ VARbytelocation/NNP) in/IN its/PRP$ range/NN ./.)
*1*let VARpayloadindex be VARbytelocation - VARw.[[BYTEINDEX]]. 
*1*(S (Chunk let/VB VARpayloadindex/NNP) (Chunk be/VB VARbytelocation/NNP) -/: (Chunk VARw/NNP) ./. [/VB [/JJ (Chunk BYTEINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*1*if VARw is a writesharedmemory event, then
*1*(S if/IN (Chunk VARw/NNP) is/VBZ a/DT writesharedmemory/JJ event/NN ,/, then/RB)
*2*let VARbyte be VARw.[[PAYLOAD]][VARpayloadindex]. 
*2*(S (Chunk let/VB VARbyte/NNP) (Chunk be/VB VARw/NNP) ./. [/VB [/JJ (Chunk PAYLOAD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (Chunk [/NNP) (Chunk VARpayloadindex/NNP) (Chunk ]/NNP) ./.)
*1*else,
*1*(S else/RB ,/,)
*2*assert: VARw is a readmodifywritesharedmemory event. 
*2*(S assert/NN :/: (Chunk VARw/NNP) is/VBZ a/DT readmodifywritesharedmemory/JJ event/NN ./.)
*2*let VARbytes be FUNCvalueofreadevent(VARexecution, VARw). 
*2*(S (Chunk let/VB VARbytes/NNP) (Chunk be/VB FUNCvalueofreadevent/NNP) (/( (Chunk VARexecution/NNP) ,/, (Chunk VARw/NNP) )/) ./.)
*2*let VARbytesmodified be VARw.[[MODIFYOP]](VARbytes, VARw.[[PAYLOAD]]). 
*2*(S (Chunk let/VB VARbytesmodified/NNP) (Chunk be/VB VARw/NNP) ./. [/VB [/JJ (Chunk MODIFYOP/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARbytes/NNP) ,/, (Chunk VARw/NNP) ./. [/VB [/JJ (Chunk PAYLOAD/NNP) (Chunk ]/NNP) (Chunk ]/NNP) )/) ./.)
*2*let VARbyte be VARbytesmodified[VARpayloadindex]. 
*2*(S (Chunk let/VB VARbyte/NNP) (Chunk be/VB VARbytesmodified/VBN [/NNP) (Chunk VARpayloadindex/NNP) (Chunk ]/NNP) ./.)
*1*append VARbyte to VARbytesread. 
*1*(S append/NN (Chunk VARbyte/NNP) to/TO (Chunk VARbytesread/NNP) ./.)
*1*increment VARbytelocation by 1. 
*1*(S increment/JJ (Chunk VARbytelocation/NNP) by/IN 1/CD ./.)
*0*return VARbytesread.    
*0*(S return/NN (Chunk VARbytesread/NNP) ./.)
ID= 27.5.5
Summary= ValueOfReadEvent ( execution, R )
*0*assert: VARr is a readsharedmemory or readmodifywritesharedmemory event. 
*0*(S assert/NN :/: (Chunk VARr/NNP) is/VBZ a/DT readsharedmemory/NN or/CC readmodifywritesharedmemory/JJ event/NN ./.)
*0*let VARws be VARexecution.[[READSBYTESFROM]](VARr). 
*0*(S (Chunk let/VB VARws/NNP) (Chunk be/VB VARexecution/NNP) ./. [/VB [/JJ (Chunk READSBYTESFROM/NNP) (Chunk ]/NNP) (Chunk ]/NNP) (/( (Chunk VARr/NNP) )/) ./.)
*0*assert: VARws is a list of writesharedmemory or readmodifywritesharedmemory events with length equal to VARr.[[ELEMENTSIZE]]. 
*0*(S assert/NN :/: (Chunk VARws/NNP) is/VBZ a/DT list/NN of/IN writesharedmemory/NN or/CC readmodifywritesharedmemory/JJ events/NNS with/IN length/JJ equal/JJ to/TO (Chunk VARr/NNP) ./. [/VB [/JJ (Chunk ELEMENTSIZE/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ./.)
*0*return FUNCcomposewriteeventbytes(VARexecution, VARr.[[BYTEINDEX]], VARws).    
*0*(S return/NN FUNCcomposewriteeventbytes/NNS (/( (Chunk VARexecution/NNP) ,/, (Chunk VARr/NNP) ./. [/VB [/JJ (Chunk BYTEINDEX/NNP) (Chunk ]/NNP) (Chunk ]/NNP) ,/, (Chunk VARws/NNP) )/) ./.)
