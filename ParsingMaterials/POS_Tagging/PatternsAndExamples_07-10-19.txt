VB NNP VB . NNP ( NNP ) .
313
*0*let number be ? tonumber(argument).
*0*let number be ? tonumber(argument).
*0*let number be ? tonumber(argument).
*0*let number be ? tonumber(argument).
*0*let number be ? tonumber(argument).
*0*let number be ? tonumber(argument).
*0*let number be ? tonumber(argument).
*0*let number be ? tonumber(argument).
*0*let len be ? tointeger(argument).
*0*let n be ! tonumber(argument).
*1*let integerindex be ? tointeger(value).
*1*let index be ! tolength(integerindex).
*0*let o be ? toobject(v).
*0*let status be ? isextensible(o).
*1*let indexname be ! tostring(index).
*0*let from be ! toobject(source).
*0*let result be ? iteratornext(iteratorrecord).
*0*let done be ? iteratorcomplete(result).
*1*let status be ? objrec.deletebinding(n).
*0*let globalobj be ? setdefaultglobalbindings(realm).
*1*let realm be ? getfunctionrealm(constructor).
*2*let thisvalue be ! toobject(thisargument).
*1*let index be ! touint32(p).
*0*let isarray be ? isarray(originalarray).
*1*let realmc be ? getfunctionrealm(c).
*0*let index be ! canonicalnumericindexstring(p).
*1*let numericindex be ! canonicalnumericindexstring(p).
*1*let numericindex be ! canonicalnumericindexstring(p).
*1*let numericindex be ! canonicalnumericindexstring(p).
*1*let numericindex be ! canonicalnumericindexstring(p).
*1*let numericindex be ! canonicalnumericindexstring(p).
*0*let numvalue be ? tonumber(value).
*0*let symbolkeys be ! ordinaryownpropertykeys(o).
*0*let extensibletarget be ? isextensible(target).
*0*let extensibletarget be ? isextensible(target).
*1*let extensibletarget be ? isextensible(target).
*0*let extensibletarget be ? isextensible(target).
*0*let resultdesc be ? topropertydescriptor(trapresultobj).
*0*let extensibletarget be ? isextensible(target).
*2*let extensibletarget be ? isextensible(target).
*0*let extensibletarget be ? isextensible(target).
*0*let template be ! arraycreate(count).
*0*let rawobj be ! arraycreate(count).
*1*let prop be ! tostring(index).
*0*let constructor be ? getvalue(ref).
*0*let bv be ? requireobjectcoercible(basevalue).
*0*let lval be ? getvalue(lref).
*0*let rval be ? getvalue(rref).
*0*let lprim be ? toprimitive(lval).
*0*let rprim be ? toprimitive(rval).
*1*let lstr be ? tostring(lprim).
*1*let rstr be ? tostring(rprim).
*0*let lnum be ? tonumber(lprim).
*0*let rnum be ? tonumber(rprim).
*0*let lval be ? getvalue(lref).
*0*let rval be ? getvalue(rref).
*0*let lnum be ? tonumber(lval).
*0*let rnum be ? tonumber(rval).
*0*let lval be ? getvalue(lref).
*0*let rval be ? getvalue(rref).
*0*let lnum be ? toint32(lval).
*0*let rnum be ? touint32(rval).
*0*let lval be ? getvalue(lref).
*0*let rval be ? getvalue(rref).
*0*let lnum be ? toint32(lval).
*0*let rnum be ? touint32(rval).
*0*let lval be ? getvalue(lref).
*0*let rval be ? getvalue(rref).
*0*let lnum be ? touint32(lval).
*0*let rnum be ? touint32(rval).
*2*let testvalue be ? getvalue(testref).
*0*let exprvalue be ? getvalue(exprref).
*1*let obj be ! toobject(exprvalue).
*1*let nextvalue be ? iteratorvalue(nextresult).
*3*let lhsref be ! resolvebinding(lhsname).
*0*let clauseselector be ? getvalue(exprref).
*1*let hasrestrictedglobal be ? envrec.hasrestrictedglobalproperty(name).
*2*let namespace be ? getmodulenamespace(importedmodule).
*0*let num be ? tonumber(number).
*0*let num be ? tonumber(number).
*0*let r be ? toint32(radix).
*0*let to be ? toobject(target).
*2*let from be ! toobject(nextsource).
*0*let props be ? toobject(properties).
*2*let desc be ? topropertydescriptor(descobj).
*0*let key be ? topropertykey(p).
*0*let desc be ? topropertydescriptor(attributes).
*0*let obj be ? toobject(o).
*0*let obj be ? toobject(o).
*0*let key be ? topropertykey(p).
*0*let obj be ? toobject(o).
*1*let descriptor be ! frompropertydescriptor(desc).
*0*let obj be ? toobject(o).
*0*let obj be ? toobject(o).
*0*let obj be ? toobject(o).
*0*let o be ? requireobjectcoercible(o).
*0*let obj be ? toobject(o).
*0*let p be ? topropertykey(v).
*0*let p be ? topropertykey(v).
*0*let isarray be ? isarray(o).
*0*let arglist be ? createlistfromarraylike(argarray).
*0*let stringkey be ? tostring(key).
*1*let msg be ? tostring(message).
*1*let msg be ? tostring(message).
*0*let f be ? tointeger(fractiondigits).
*1*let m be ! tostring(x).
*0*let p be ? tointeger(precision).
*0*let h be ! tointeger(hour).
*0*let m be ! tointeger(min).
*0*let s be ! tointeger(sec).
*0*let milli be ! tointeger(ms).
*0*let y be ! tointeger(year).
*0*let m be ! tointeger(month).
*0*let dt be ! tointeger(date).
*0*let clippedtime be ! tointeger(time).
*1*let y be ? tonumber(year).
*1*let m be ? tonumber(month).
*2*let v be ? toprimitive(value).
*3*let tv be ? tonumber(v).
*0*let y be ? tonumber(year).
*0*let dt be ? tonumber(date).
*0*let y be ? tonumber(year).
*0*let h be ? tonumber(hour).
*0*let ms be ? tonumber(ms).
*0*let m be ? tonumber(min).
*0*let m be ? tonumber(month).
*0*let s be ? tonumber(sec).
*0*let t be ? tonumber(time).
*0*let dt be ? tonumber(date).
*0*let y be ? tonumber(year).
*0*let h be ? tonumber(hour).
*0*let milli be ? tonumber(ms).
*0*let m be ? tonumber(min).
*1*let s be ? tonumber(sec).
*1*let milli be ? tonumber(ms).
*0*let m be ? tonumber(month).
*1*let dt be ? tonumber(date).
*0*let s be ? tonumber(sec).
*1*let milli be ? tonumber(ms).
*1*let s be ? tostring(value).
*1*let nextcu be ? touint16(next).
*1*let nextcp be ? tonumber(next).
*0*let cooked be ? toobject(template).
*1*let nextkey be ! tostring(nextindex).
*1*let nextsub be ? tostring(next).
*0*let s be ? tostring(o).
*0*let position be ? tointeger(pos).
*0*let s be ? tostring(o).
*0*let position be ? tointeger(pos).
*0*let s be ? tostring(o).
*0*let position be ? tointeger(pos).
*0*let s be ? tostring(o).
*0*let s be ? tostring(o).
*0*let s be ? tostring(o).
*0*let s be ? tostring(o).
*0*let s be ? tostring(o).
*0*let s be ? tostring(o).
*0*let that be ? tostring(that).
*0*let s be ? tostring(o).
*0*let s be ? tostring(o).
*0*let f be ? tostring(form).
*0*let s be ? tostring(o).
*0*let intmaxlength be ? tolength(maxlength).
*0*let s be ? tostring(o).
*0*let intmaxlength be ? tolength(maxlength).
*0*let s be ? tostring(o).
*0*let n be ? tointeger(count).
*1*let replacevalue be ? tostring(replacevalue).
*1*let replstr be ? tostring(replvalue).
*0*let s be ? tostring(o).
*0*let intstart be ? tointeger(start).
*0*let s be ? tostring(o).
*0*let r be ? tostring(separator).
*0*let s be ? tostring(o).
*0*let s be ? tostring(o).
*0*let intstart be ? tointeger(start).
*0*let s be ? tostring(o).
*0*let s be ? tostring(o).
*0*let s be ? tostring(o).
*0*let patternisregexp be ? isregexp(pattern).
*0*let o be ? regexpalloc(newtarget).
*1*let replacevalue be ? tostring(replacevalue).
*3*let capn be ? tostring(capn).
*2*let replacement be ? tostring(replvalue).
*1*let pk be ! tostring(k).
*2*let a be ? construct(c).
*2*let pk be ! tostring(k).
*2*let next be ? iteratorstep(iteratorrecord).
*2*let nextvalue be ? iteratorvalue(next).
*0*let arraylike be ! toobject(items).
*1*let a be ? arraycreate(len).
*1*let pk be ! tostring(k).
*1*let a be ? arraycreate(len).
*1*let pk be ! tostring(k).
*3*let p be ! tostring(k).
*0*let relativetarget be ? tointeger(target).
*0*let relativestart be ? tointeger(start).
*1*let fromkey be ! tostring(from).
*1*let tokey be ! tostring(to).
*1*let pk be ! tostring(k).
*0*let relativestart be ? tointeger(start).
*1*let pk be ! tostring(k).
*1*let pk be ! tostring(k).
*1*let pk be ! tostring(k).
*1*let pk be ! tostring(k).
*1*let pk be ! tostring(k).
*1*let pk be ! tostring(k).
*1*let index be ! tostring(newlen).
*2*let pk be ! tostring(k).
*1*let pk be ! tostring(k).
*2*let pk be ! tostring(k).
*1*let pk be ! tostring(k).
*1*let upperp be ! tostring(upper).
*1*let lowerp be ! tostring(lower).
*1*let from be ! tostring(k).
*1*let to be ! tostring(k-1).
*0*let relativestart be ? tointeger(start).
*1*let pk be ! tostring(k).
*1*let pk be ! tostring(k).
*0*let relativestart be ? tointeger(start).
*1*let dc be ? tointeger(deletecount).
*1*let from be ! tostring(actualstart+k).
*2*let from be ! tostring(k+actualdeletecount).
*2*let to be ! tostring(k+itemcount).
*2*let from be ! tostring(k-1).
*2*let to be ! tostring(k+argcount-1).
*0*let elementkey be ! tostring(index).
*2*let pk be ! tostring(k).
*0*let arraylike be ! toobject(source).
*1*let pk be ! tostring(k).
*2*let nextvalue be ? iteratorvalue(next).
*1*let pk be ! tostring(k).
*0*let relativetarget be ? tointeger(target).
*0*let relativestart be ? tointeger(start).
*0*let value be ? tonumber(value).
*0*let relativestart be ? tointeger(start).
*1*let pk be ! tostring(k).
*1*let pk be ! tostring(k).
*1*let pk be ! tostring(k).
*0*let targetoffset be ? tointeger(offset).
*0*let src be ? toobject(array).
*1*let pk be ! tostring(k).
*0*let targetoffset be ? tointeger(offset).
*0*let src be ? toobject(array).
*1*let pk be ! tostring(k).
*0*let targetoffset be ? tointeger(offset).
*0*let relativestart be ? tointeger(start).
*2*let pk be ! tostring(k).
*0*let buffer be ? validatetypedarray(obj).
*0*let relativebegin be ? tointeger(begin).
*0*let elementlength be ? toindex(length).
*2*let pk be ! tostring(k).
*1*let pk be ! tostring(k).
*0*let offset be ? toindex(byteoffset).
*1*let newlength be ? toindex(length).
*0*let iteratorrecord be ? getiterator(iterable).
*1*let next be ? iteratorstep(iteratorrecord).
*1*let nextitem be ? iteratorvalue(next).
*0*let iteratorrecord be ? getiterator(iterable).
*1*let next be ? iteratorstep(iteratorrecord).
*1*let nextvalue be ? iteratorvalue(next).
*0*let iteratorrecord be ? getiterator(iterable).
*1*let next be ? iteratorstep(iterrecord).
*1*let nextitem be ? iteratorvalue(next).
*0*let iteratorrecord be ? getiterator(iterable).
*1*let next be ? iteratorstep(iteratorrecord).
*1*let nextvalue be ? iteratorvalue(next).
*0*let block be ? createbytedatablock(bytelength).
*0*let bytelength be ? toindex(length).
*0*let relativestart be ? tointeger(start).
*0*let block be ? createsharedbytedatablock(bytelength).
*0*let bytelength be ? toindex(length).
*0*let relativestart be ? tointeger(start).
*0*let getindex be ? toindex(requestindex).
*0*let getindex be ? toindex(requestindex).
*0*let numbervalue be ? tonumber(value).
*0*let offset be ? toindex(byteoffset).
*1*let viewbytelength be ? toindex(bytelength).
*0*let accessindex be ? toindex(requestindex).
*0*let buffer be ? validatesharedintegertypedarray(typedarray).
*0*let v be ? tointeger(value).
*0*let buffer be ? validatesharedintegertypedarray(typedarray).
*0*let buffer be ? validatesharedintegertypedarray(typedarray).
*0*let expected be ? tointeger(expectedvalue).
*0*let replacement be ? tointeger(replacementvalue).
*0*let n be ? tointeger(size).
*0*let buffer be ? validatesharedintegertypedarray(typedarray).
*0*let v be ? tointeger(value).
*0*let v be ? toint32(value).
*0*let q be ? tonumber(timeout).
*1*let intcount be ? tointeger(count).
*0*let jtext be ? tostring(text).
*1*let isarray be ? isarray(val).
*2*let isarray be ? isarray(replacer).
*2*let space be ? tonumber(space).
*2*let space be ? tostring(space).
*1*let isarray be ? isarray(value).
*0*let state be ? generatorvalidate(generator).
*0*let state be ? generatorvalidate(generator).
*0*let promisecapability be ? newpromisecapability(c).
*0*let promisecapability be ? newpromisecapability(c).
*0*let promisecapability be ? newpromisecapability(c).
*0*let promisecapability be ? newpromisecapability(c).
*0*let resultcapability be ? newpromisecapability(c).
*0*let args be ? createlistfromarraylike(argumentslist).
*0*let args be ? createlistfromarraylike(argumentslist).
*0*let key be ? topropertykey(propertykey).
*0*let desc be ? topropertydescriptor(attributes).
*0*let key be ? topropertykey(propertykey).
*0*let key be ? topropertykey(propertykey).
*0*let key be ? topropertykey(propertykey).
*0*let key be ? topropertykey(propertykey).
*0*let key be ? topropertykey(propertykey).

NN NNP .
213
*0*return obj.
*0*return desc.
*0*return desc.
*0*return db.
*0*return db.
*0*return input.
*0*return int32bit.
*0*return int16bit.
*0*return int8bit.
*0*return f.
*1*return key.
*0*return n.
*0*return index.
*0*return success.
*0*return success.
*0*return success.
*0*return success.
*0*return func.
*0*return array.
*0*return list.
*0*return target.
*0*return iteratorrecord.
*0*return result.
*0*return result.
*0*return obj.
*0*return v.
*1*return status.
*0*return env.
*0*return env.
*0*return env.
*0*return env.
*0*return env.
*0*return realmrec.
*0*return realmrec.
*0*return global.
*0*return d.
*0*return keys.
*0*return obj.
*0*return proto.
*0*return calleecontext.
*0*return f.
*0*return f.
*0*return result.
*0*return func.
*0*return obj.
*0*return a.
*0*return keys.
*0*return s.
*0*return desc.
*0*return result.
*0*return obj.
*0*return obj.
*0*return getter.
*0*return setter.
*0*return keys.
*0*return a.
*0*return m.
*0*return handlerproto.
*0*return booleantrapresult.
*0*return booleantrapresult.
*0*return resultdesc.
*0*return booleantrapresult.
*0*return trapresult.
*1*return trapresult.
*0*return trapresult.
*0*return newobj.
*0*return p.
*0*return template.
*0*return result.
*0*return superconstructor.
*3*return status.
*0*suspend leafcontext.
*1*return index.
*1*return index.
*0*return index.
*1*return index.
*0*return index.
*0*return namespace.
*0*return to.
*0*return obj.
*0*return o.
*0*return o.
*0*return o.
*0*return o.
*0*return o.
*0*return o.
*0*return f.
*0*return f.
*0*return o.
*0*return newsymbol.
*0*return o.
*0*return o.
*0*return o.
*0*return p.
*0*return t.
*0*return clippedtime.
*1*return o.
*1*return o.
*1*return o.
*0*return u.
*0*return u.
*0*return u.
*0*return u.
*0*return u.
*0*return u.
*0*return u.
*0*return v.
*0*return v.
*0*return v.
*0*return v.
*0*return v.
*0*return v.
*0*return v.
*0*return v.
*0*return r.
*0*return ns.
*0*return t.
*0*return newstring.
*0*return result.
*1*return a.
*1*return a.
*0*return a.
*0*return q+r.
*0*return l.
*0*return t.
*0*return iterator.
*0*return a.
*1*return ch.
*1*return cu.
*0*return obj.
*0*return obj.
*0*return s.
*1*return result.
*0*return a.
*0*return index+2.
*3*return a.
*3*increment n.
*1*return a.
*0*return a.
*0*return result.
*0*return array.
*0*return array.
*3*return a.
*0*return a.
*0*return a.
*0*return a.
*0*return o.
*0*return o.
*0*return a.
*0*return r.
*0*return a.
*1*return element.
*0*return len.
*0*return accumulator.
*0*return accumulator.
*0*return o.
*0*return first.
*0*return a.
*1*return v.
*0*return a.
*0*return r.
*0*return len+argcount.
*0*return iterator.
*1*return targetobj.
*0*return targetobj.
*0*return newobj.
*0*return o.
*0*return buffer.
*0*return o.
*0*return a.
*0*return a.
*0*return a.
*0*return obj.
*0*return o.
*0*return o.
*1*return o.
*0*return o.
*0*return o.
*0*return newtypedarray.
*2*return m.
*0*return m.
*0*return iterator.
*2*return s.
*0*return s.
*0*return iterator.
*2*return m.
*0*return m.
*2*return s.
*0*return s.
*0*return obj.
*0*return targetbuffer.
*0*return new.
*0*return obj.
*0*return new.
*0*return o.
*0*return buffer.
*0*return accessindex.
*0*return l.
*0*return v.
*0*return n.
*1*return unfiltered.
*0*return product.
*0*return final.
*0*return final.
*0*return state.
*0*suspend methodcontext.
*0*suspend methodcontext.
*1*return resumptionvalue.
*0*suspend callercontext.
*0*return promisecapability.
*0*return promise.
*0*return result.
*0*return bytesread.

VB NNP VB NNP . VB JJ NNP NNP NNP .
209
*1*let target be argument.[[PROXYTARGET]].
*1*let bc be c.[[BOUNDTARGETTION]].
*1*let target be obj.[[BOUNDTARGETTION]].
*1*let proxytarget be obj.[[PROXYTARGET]].
*0*let iterator be iteratorrecord.[[ITERATOR]].
*0*let iterator be iteratorrecord.[[ITERATOR]].
*0*let list be o.[[ITERATEDLIST]].
*0*let index be o.[[LISTITERATORNEXTINDEX]].
*0*let home be envrec.[[HOMEOBJECT]].
*0*let dclrec be envrec.[[DECLARATIVERECORD]].
*0*let objrec be envrec.[[OBJECTRECORD]].
*0*let dclrec be envrec.[[DECLARATIVERECORD]].
*0*let dclrec be envrec.[[DECLARATIVERECORD]].
*0*let dclrec be envrec.[[DECLARATIVERECORD]].
*0*let objrec be envrec.[[OBJECTRECORD]].
*0*let dclrec be envrec.[[DECLARATIVERECORD]].
*0*let objrec be envrec.[[OBJECTRECORD]].
*0*let dclrec be envrec.[[DECLARATIVERECORD]].
*0*let objrec be envrec.[[OBJECTRECORD]].
*0*let dclrec be envrec.[[DECLARATIVERECORD]].
*0*let objrec be envrec.[[OBJECTRECORD]].
*2*let varnames be envrec.[[NAMES]].
*0*let vardeclarednames be envrec.[[NAMES]].
*0*let dclrec be envrec.[[DECLARATIVERECORD]].
*0*let objrec be envrec.[[OBJECTRECORD]].
*0*let objrec be envrec.[[OBJECTRECORD]].
*0*let objrec be envrec.[[OBJECTRECORD]].
*0*let objrec be envrec.[[OBJECTRECORD]].
*0*let vardeclarednames be envrec.[[NAMES]].
*0*let objrec be envrec.[[OBJECTRECORD]].
*0*let vardeclarednames be envrec.[[NAMES]].
*1*let targetenv be m.[[ENVIRONMENT]].
*0*let home be f.[[HOMEOBJECT]].
*0*let global be realmrec.[[GLOBALOBJECT]].
*0*let getter be desc.[[GET]].
*0*let calleerealm be f.[[REALM]].
*0*let thismode be f.[[THISMODE]].
*0*let calleerealm be f.[[REALM]].
*2*let globalenv be calleerealm.[[GLOBALENV]].
*2*let thisvalue be globalenvrec.[[GLOBALTHISVALUE]].
*0*let kind be f.[[CONSTRUCTORKIND]].
*0*let strict be f.[[STRICT]].
*0*let code be func.[[ECMASCRIPTCODE]].
*0*let strict be func.[[STRICT]].
*0*let calleerealm be f.[[REALM]].
*0*let target be f.[[BOUNDTARGETTION]].
*0*let boundthis be f.[[BOUNDTHIS]].
*0*let boundargs be f.[[BOUNDARGUMENTS]].
*0*let target be f.[[BOUNDTARGETTION]].
*0*let boundargs be f.[[BOUNDARGUMENTS]].
*0*let map be args.[[PARAMETERMAP]].
*0*let map be args.[[PARAMETERMAP]].
*0*let map be args.[[PARAMETERMAP]].
*1*let map be args.[[PARAMETERMAP]].
*0*let map be args.[[PARAMETERMAP]].
*2*let buffer be o.[[VIEWEDARRAYBUFFER]].
*2*let length be o.[[ARRAYLENGTH]].
*0*let len be o.[[ARRAYLENGTH]].
*0*let buffer be o.[[VIEWEDARRAYBUFFER]].
*0*let length be o.[[ARRAYLENGTH]].
*0*let offset be o.[[BYTEOFFSET]].
*0*let buffer be o.[[VIEWEDARRAYBUFFER]].
*0*let length be o.[[ARRAYLENGTH]].
*0*let offset be o.[[BYTEOFFSET]].
*0*let exports be o.[[EXPORTS]].
*0*let exports be o.[[EXPORTS]].
*0*let exports be o.[[EXPORTS]].
*0*let m be o.[[MODULE]].
*0*let targetmodule be binding.[[MODULE]].
*0*let targetenv be targetmodule.[[ENVIRONMENT]].
*0*let exports be o.[[EXPORTS]].
*0*let handler be o.[[PROXYHANDLER]].
*0*let target be o.[[PROXYTARGET]].
*0*let handler be o.[[PROXYHANDLER]].
*0*let target be o.[[PROXYTARGET]].
*0*let handler be o.[[PROXYHANDLER]].
*0*let target be o.[[PROXYTARGET]].
*0*let handler be o.[[PROXYHANDLER]].
*0*let target be o.[[PROXYTARGET]].
*0*let handler be o.[[PROXYHANDLER]].
*0*let target be o.[[PROXYTARGET]].
*0*let handler be o.[[PROXYHANDLER]].
*0*let target be o.[[PROXYTARGET]].
*0*let handler be o.[[PROXYHANDLER]].
*0*let target be o.[[PROXYTARGET]].
*0*let handler be o.[[PROXYHANDLER]].
*0*let target be o.[[PROXYTARGET]].
*0*let handler be o.[[PROXYHANDLER]].
*0*let target be o.[[PROXYTARGET]].
*0*let handler be o.[[PROXYHANDLER]].
*0*let target be o.[[PROXYTARGET]].
*0*let handler be o.[[PROXYHANDLER]].
*0*let target be o.[[PROXYTARGET]].
*0*let handler be o.[[PROXYHANDLER]].
*0*let target be o.[[PROXYTARGET]].
*0*let handler be o.[[PROXYHANDLER]].
*0*let target be o.[[PROXYTARGET]].
*0*let templateregistry be realm.[[TEMPLATEMAP]].
*0*let activefunction be envrec.[[TIONOBJECT]].
*0*let scriptbody be scriptrecord.[[ECMASCRIPTCODE]].
*0*let realm be module.[[REALM]].
*0*let code be module.[[ECMASCRIPTCODE]].
*0*let namespace be module.[[NAMESPACE]].
*1*let f be thisenvrec.[[TIONOBJECT]].
*1*let varenv be evalrealm.[[GLOBALENV]].
*0*let realmf be f.[[REALM]].
*0*let scope be realmf.[[GLOBALENV]].
*0*let s be o.[[ITERATEDSTRING]].
*0*let position be o.[[STRINGITERATORNEXTINDEX]].
*1*let p be pattern.[[ORIGINALSOURCE]].
*0*let flags be r.[[ORIGINALFLAGS]].
*0*let matcher be r.[[REGEXPMATCHER]].
*0*let a be o.[[ITERATEDOBJECT]].
*0*let index be o.[[ARRAYITERATORNEXTINDEX]].
*0*let itemkind be o.[[ARRAYITERATIONKIND]].
*1*let len be a.[[ARRAYLENGTH]].
*0*let len be o.[[ARRAYLENGTH]].
*1*let buffer be o.[[VIEWEDARRAYBUFFER]].
*1*let byteoffset be o.[[BYTEOFFSET]].
*0*let buffer be o.[[VIEWEDARRAYBUFFER]].
*0*let len be o.[[ARRAYLENGTH]].
*0*let len be o.[[ARRAYLENGTH]].
*0*let len be o.[[ARRAYLENGTH]].
*0*let targetbuffer be target.[[VIEWEDARRAYBUFFER]].
*0*let targetlength be target.[[ARRAYLENGTH]].
*0*let targetbyteoffset be target.[[BYTEOFFSET]].
*0*let targetbuffer be target.[[VIEWEDARRAYBUFFER]].
*0*let targetlength be target.[[ARRAYLENGTH]].
*0*let targetbyteoffset be target.[[BYTEOFFSET]].
*0*let targetbuffer be target.[[VIEWEDARRAYBUFFER]].
*0*let targetlength be target.[[ARRAYLENGTH]].
*0*let srcbuffer be typedarray.[[VIEWEDARRAYBUFFER]].
*0*let targetbyteoffset be target.[[BYTEOFFSET]].
*0*let srclength be typedarray.[[ARRAYLENGTH]].
*0*let srcbyteoffset be typedarray.[[BYTEOFFSET]].
*1*let srcbytelength be typedarray.[[BYTELENGTH]].
*0*let len be o.[[ARRAYLENGTH]].
*1*let srcbuffer be o.[[VIEWEDARRAYBUFFER]].
*1*let targetbuffer be a.[[VIEWEDARRAYBUFFER]].
*1*let srcbyteoffet be o.[[BYTEOFFSET]].
*1*let targetbyteindex be a.[[BYTEOFFSET]].
*0*let len be obj.[[ARRAYLENGTH]].
*0*let buffer be o.[[VIEWEDARRAYBUFFER]].
*0*let srclength be o.[[ARRAYLENGTH]].
*0*let srcbyteoffset be o.[[BYTEOFFSET]].
*0*let srcdata be srcarray.[[VIEWEDARRAYBUFFER]].
*0*let elementlength be srcarray.[[ARRAYLENGTH]].
*0*let srcbyteoffset be srcarray.[[BYTEOFFSET]].
*0*let bufferbytelength be buffer.[[ARRAYBUFFERBYTELENGTH]].
*0*let m be o.[[MAP]].
*0*let index be o.[[MAPNEXTINDEX]].
*0*let itemkind be o.[[MAPITERATIONKIND]].
*0*let s be o.[[ITERATEDSET]].
*0*let index be o.[[SETNEXTINDEX]].
*0*let itemkind be o.[[SETITERATIONKIND]].
*0*let srcblock be srcbuffer.[[ARRAYBUFFERDATA]].
*0*let targetblock be targetbuffer.[[ARRAYBUFFERDATA]].
*0*let block be arraybuffer.[[ARRAYBUFFERDATA]].
*0*let block be arraybuffer.[[ARRAYBUFFERDATA]].
*0*let block be arraybuffer.[[ARRAYBUFFERDATA]].
*0*let len be o.[[ARRAYBUFFERBYTELENGTH]].
*0*let frombuf be o.[[ARRAYBUFFERDATA]].
*0*let tobuf be new.[[ARRAYBUFFERDATA]].
*0*let bufferdata be obj.[[ARRAYBUFFERDATA]].
*0*let len be o.[[ARRAYBUFFERBYTELENGTH]].
*0*let frombuf be o.[[ARRAYBUFFERDATA]].
*0*let tobuf be new.[[ARRAYBUFFERDATA]].
*0*let buffer be view.[[VIEWEDARRAYBUFFER]].
*0*let viewoffset be view.[[BYTEOFFSET]].
*0*let viewsize be view.[[BYTELENGTH]].
*0*let buffer be view.[[VIEWEDARRAYBUFFER]].
*0*let viewoffset be view.[[BYTEOFFSET]].
*0*let viewsize be view.[[BYTELENGTH]].
*0*let bufferbytelength be buffer.[[ARRAYBUFFERBYTELENGTH]].
*0*let typename be typedarray.[[TYPEDARRAYNAME]].
*0*let buffer be typedarray.[[VIEWEDARRAYBUFFER]].
*0*let length be typedarray.[[ARRAYLENGTH]].
*0*let arraytypename be typedarray.[[TYPEDARRAYNAME]].
*0*let offset be typedarray.[[BYTEOFFSET]].
*0*let arraytypename be typedarray.[[TYPEDARRAYNAME]].
*0*let offset be typedarray.[[BYTEOFFSET]].
*0*let arraytypename be typedarray.[[TYPEDARRAYNAME]].
*0*let offset be typedarray.[[BYTEOFFSET]].
*0*let arraytypename be typedarray.[[TYPEDARRAYNAME]].
*0*let offset be typedarray.[[BYTEOFFSET]].
*0*let block be buffer.[[ARRAYBUFFERDATA]].
*0*let offset be typedarray.[[BYTEOFFSET]].
*0*let block be buffer.[[ARRAYBUFFERDATA]].
*0*let offset be typedarray.[[BYTEOFFSET]].
*0*let synciteratorrecord be o.[[SYNCITERATORRECORD]].
*0*let state be generator.[[GENERATORSTATE]].
*0*let gencontext be generator.[[GENERATORCONTEXT]].
*0*let gencontext be generator.[[GENERATORCONTEXT]].
*0*let queue be generator.[[ASYNCGENERATORQUEUE]].
*0*let promisecapability be next.[[CAPABILITY]].
*0*let queue be generator.[[ASYNCGENERATORQUEUE]].
*0*let promisecapability be next.[[CAPABILITY]].
*0*let state be generator.[[ASYNCGENERATORSTATE]].
*0*let queue be generator.[[ASYNCGENERATORQUEUE]].
*0*let gencontext be generator.[[ASYNCGENERATORCONTEXT]].
*0*let queue be generator.[[ASYNCGENERATORQUEUE]].
*0*let state be generator.[[ASYNCGENERATORSTATE]].
*0*let reactions be promise.[[PROMISEFULFILLREACTIONS]].
*0*let reactions be promise.[[PROMISEREJECTREACTIONS]].
*0*let promisecapability be reaction.[[CAPABILITY]].
*0*let type be reaction.[[TYPE]].
*0*let handler be reaction.[[HANDLER]].
*1*let value be promise.[[PROMISERESULT]].
*1*let reason be promise.[[PROMISERESULT]].

RB ,
118
*0*else,
*2*else,
*1*else,
*0*else,
*0*else,
*3*else,
*3*else,
*4*else,
*0*else,
*0*else,
*0*else,
*0*else,
*1*else,
*1*else,
*1*else,
*0*else,
*1*else,
*1*else,
*1*else,
*0*else,
*0*else,
*0*else,
*3*else,
*2*else,
*0*else,
*1*else,
*0*else,
*1*else,
*0*else,
*0*else,
*2*else,
*0*else,
*1*else,
*2*else,
*1*else,
*2*else,
*2*else,
*2*else,
*2*else,
*2*else,
*1*else,
*1*else,
*2*else,
*0*else,
*0*else,
*2*else,
*1*else,
*2*else,
*1*else,
*2*else,
*1*else,
*0*else,
*1*else,
*0*else,
*0*else,
*0*else,
*1*else,
*2*else,
*0*else,
*0*else,
*0*else,
*0*else,
*0*else,
*0*else,
*0*else,
*0*else,
*1*else,
*0*else,
*0*else,
*0*else,
*1*else,
*0*else,
*2*else,
*1*else,
*0*else,
*0*else,
*1*else,
*0*else,
*0*else,
*0*else,
*0*else,
*0*else,
*0*else,
*1*else,
*0*else,
*0*else,
*0*else,
*0*else,
*0*else,
*2*else,
*0*else,
*0*else,
*1*else,
*0*else,
*0*else,
*0*else,
*0*else,
*0*else,
*3*else,
*1*else,
*3*else,
*1*else,
*0*else,
*1*else,
*0*else,
*0*else,
*1*else,
*0*else,
*1*else,
*1*else,
*1*else,
*2*else,
*1*else,
*0*else,
*0*else,
*0*else,
*1*else,
*1*else,

VB NNP VB . NNP ( NNP , NNP ) .
98
*1*let method be ? get(o, name).
*2*let result be ? call(method, o).
*0*let func be ? getv(v, p).
*1*let next be ? get(obj, indexname).
*0*let func be ? getv(v, p).
*4*let value be ? get(o, key).
*3*let propvalue be ? get(from, nextkey).
*0*let iterator be ? call(method, obj).
*0*let value be ? hasproperty(bindings, n).
*0*let existingprop be ? hasownproperty(globalobject, n).
*0*let hasproperty be ? hasownproperty(globalobject, n).
*0*let hasproperty be ? hasownproperty(globalobject, n).
*0*let proto be ? getprototypefromconstructor(constructor, intrinsicdefaultproto).
*0*let stringdesc be ! stringgetownproperty(s, p).
*0*let ismapped be ! hasownproperty(map, p).
*0*let ismapped be ! hasownproperty(map, p).
*1*let ismapped be ! hasownproperty(map, p).
*0*let ismapped be ! hasownproperty(map, p).
*0*let result be ? ordinarydelete(args, p).
*2*let value be ? integerindexedelementget(o, numericindex).
*1*let requiredmodule be ? hostresolveimportedmodule(module, required).
*1*let requiredmodule be ! hostresolveimportedmodule(module, required).
*3*let propvalue be ? get(from, nextkey).
*2*let descobj be ? get(props, nextkey).
*0*let proto be ? getprototypefromconstructor(newtarget, fallbackproto).
*2*let result be ? regexpexec(rx, s).
*1*let result be ? regexpexec(rx, s).
*0*let result be ? regexpexec(rx, s).
*1*let z be ? regexpexec(splitter, s).
*1*let z be ? regexpexec(splitter, s).
*0*let match be ? regexpexec(r, string).
*0*let array be ? arraycreate(numberofargs, proto).
*1*let kvalue be ? get(arraylike, pk).
*4*let subelement be ? get(e, p).
*1*let frompresent be ? hasproperty(o, fromkey).
*2*let fromval be ? get(o, fromkey).
*1*let kpresent be ? hasproperty(o, pk).
*2*let kvalue be ? get(o, pk).
*1*let kpresent be ? hasproperty(o, pk).
*2*let kvalue be ? get(o, pk).
*1*let kvalue be ? get(o, pk).
*1*let kvalue be ? get(o, pk).
*1*let kpresent be ? hasproperty(o, pk).
*2*let kvalue be ? get(o, pk).
*0*let a be ? arrayspeciescreate(o, len).
*1*let kpresent be ? hasproperty(o, pk).
*2*let kvalue be ? get(o, pk).
*1*let element be ? get(o, index).
*2*let kpresent be ? hasproperty(o, pk).
*1*let kpresent be ? hasproperty(o, pk).
*2*let kvalue be ? get(o, pk).
*2*let kpresent be ? hasproperty(o, pk).
*1*let kpresent be ? hasproperty(o, pk).
*2*let kvalue be ? get(o, pk).
*2*let lowervalue be ? get(o, lowerp).
*2*let uppervalue be ? get(o, upperp).
*1*let frompresent be ? hasproperty(o, from).
*2*let fromval be ? get(o, from).
*0*let a be ? arrayspeciescreate(o, count).
*1*let kpresent be ? hasproperty(o, pk).
*2*let kvalue be ? get(o, pk).
*1*let kpresent be ? hasproperty(o, pk).
*2*let kvalue be ? get(o, pk).
*0*let a be ? arrayspeciescreate(o, actualdeletecount).
*1*let frompresent be ? hasproperty(o, from).
*2*let fromvalue be ? get(o, from).
*2*let frompresent be ? hasproperty(o, from).
*3*let fromvalue be ? get(o, from).
*2*let frompresent be ? hasproperty(o, from).
*3*let fromvalue be ? get(o, from).
*2*let frompresent be ? hasproperty(o, from).
*3*let fromvalue be ? get(o, from).
*0*let elementvalue be ? get(a, elementkey).
*1*let values be ? iterabletolist(source, usingiterator).
*1*let kvalue be ? get(arraylike, pk).
*1*let kvalue be ? get(o, pk).
*1*let kvalue be ? get(o, pk).
*2*let kvalue be ? get(o, pk).
*0*let proto be ? getprototypefromconstructor(newtarget, defaultproto).
*1*let data be ? allocatearraybuffer(bufferconstructor, bytelength).
*1*let values be ? iterabletolist(object, usingiterator).
*1*let kvalue be ? get(arraylike, pk).
*0*let newtypedarray be ? construct(constructor, argumentlist).
*0*let constructor be ? speciesconstructor(exemplar, defaultconstructor).
*0*let targetbuffer be ? allocatearraybuffer(cloneconstructor, srclength).
*0*let i be ? validateatomicaccess(typedarray, index).
*0*let i be ? validateatomicaccess(typedarray, index).
*0*let i be ? validateatomicaccess(typedarray, index).
*0*let i be ? validateatomicaccess(typedarray, index).
*0*let i be ? validateatomicaccess(typedarray, index).
*0*let w be ! atomicload(typedarray, i).
*0*let i be ? validateatomicaccess(typedarray, index).
*0*let val be ? get(holder, name).
*3*let newelement be ? internalizejsonproperty(val, p).
*0*let value be ? get(holder, key).
*1*let strp be ? serializejsonproperty(p, value).
*0*let iteratorresult be ! createiterresultobject(value, done).
*0*let p be ? proxycreate(target, handler).

NN : NNP ( NNP ) VBZ JJ .
95
*0*assert: type(o) is object.
*0*assert: type(o) is object.
*0*assert: type(o) is object.
*0*assert: ispropertykey(p) is true.
*0*assert: ispropertykey(p) is true.
*0*assert: type(o) is object.
*0*assert: ispropertykey(p) is true.
*0*assert: type(throw) is boolean.
*0*assert: type(o) is object.
*0*assert: ispropertykey(p) is true.
*0*assert: type(o) is object.
*0*assert: ispropertykey(p) is true.
*0*assert: type(o) is object.
*0*assert: ispropertykey(p) is true.
*0*assert: type(o) is object.
*0*assert: ispropertykey(p) is true.
*0*assert: type(o) is object.
*0*assert: ispropertykey(p) is true.
*0*assert: ispropertykey(p) is true.
*0*assert: type(o) is object.
*0*assert: ispropertykey(p) is true.
*0*assert: type(o) is object.
*0*assert: ispropertykey(p) is true.
*0*assert: isconstructor(f) is true.
*0*assert: isconstructor(newtarget) is true.
*0*assert: type(o) is object.
*0*assert: type(o) is object.
*0*assert: ispropertykey(p) is true.
*0*assert: type(o) is object.
*0*assert: type(o) is object.
*0*assert: type(target) is object.
*0*assert: type(iterresult) is object.
*0*assert: type(iterresult) is object.
*0*assert: type(done) is boolean.
*0*assert: type(o) is object.
*0*assert: type(home) is object.
*0*assert: type(globalobj) is object.
*0*assert: ispropertykey(p) is true.
*0*assert: ispropertykey(p) is true.
*0*assert: ispropertykey(p) is true.
*0*assert: isaccessordescriptor(desc) is true.
*0*assert: ispropertykey(p) is true.
*0*assert: ispropertykey(p) is true.
*0*assert: isaccessordescriptor(owndesc) is true.
*0*assert: ispropertykey(p) is true.
*0*assert: type(newtarget) is object.
*0*assert: type(functionprototype) is object.
*0*assert: isconstructor(f) is true.
*0*assert: type(homeobject) is object.
*0*assert: isconstructor(target) is true.
*0*assert: type(targetfunction) is object.
*0*assert: ispropertykey(p) is true.
*0*assert: ispropertykey(p) is true.
*0*assert: ispropertykey(p) is true.
*0*assert: ispropertykey(p) is true.
*0*assert: ispropertykey(p) is true.
*0*assert: ispropertykey(p) is true.
*0*assert: ispropertykey(p) is true.
*0*assert: ispropertykey(p) is true.
*0*assert: ispropertykey(p) is true.
*0*assert: ispropertykey(p) is true.
*0*assert: ispropertykey(p) is true.
*0*assert: type(handler) is object.
*0*assert: type(handler) is object.
*0*assert: type(handler) is object.
*0*assert: type(handler) is object.
*0*assert: ispropertykey(p) is true.
*0*assert: type(handler) is object.
*1*assert: type(extensibletarget) is boolean.
*0*assert: ispropertykey(p) is true.
*0*assert: type(handler) is object.
*0*assert: ispropertykey(p) is true.
*0*assert: type(handler) is object.
*0*assert: ispropertykey(p) is true.
*0*assert: type(handler) is object.
*0*assert: ispropertykey(p) is true.
*0*assert: type(handler) is object.
*0*assert: ispropertykey(p) is true.
*0*assert: type(handler) is object.
*0*assert: type(handler) is object.
*0*assert: type(handler) is object.
*0*assert: type(handler) is object.
*1*assert: isconstructor(target) is true.
*0*assert: type(o) is object.
*0*assert: type(r) is object.
*0*assert: type(unicode) is boolean.
*0*assert: type(array) is object.
*0*assert: issharedarraybuffer(arraybuffer) is false.
*0*assert: isconstructor(cloneconstructor) is true.
*0*assert: isdetachedbuffer(arraybuffer) is false.
*0*assert: isdetachedbuffer(arraybuffer) is false.
*0*assert: issharedarraybuffer(arraybuffer) is true.
*0*assert: type(c) is object.
*0*assert: isconstructor(c) is true.
*0*assert: ispromise(promise) is true.

VB NNP VB DT DT NN .
90
*0*let o be the this value.
*0*let o be the this value.
*0*let target be the this value.
*0*let f be the this value.
*0*let o be the this value.
*0*let o be the this value.
*0*let o be the this value.
*0*let r be the this value.
*0*let rx be the this value.
*0*let rx be the this value.
*0*let rx be the this value.
*0*let rx be the this value.
*0*let r be the this value.
*0*let r be the this value.
*0*let c be the this value.
*0*let c be the this value.
*0*let o be the this value.
*0*let c be the this value.
*0*let c be the this value.
*0*let o be the this value.
*0*let o be the this value.
*0*let o be the this value.
*0*let o be the this value.
*0*let o be the this value.
*0*let target be the this value.
*0*let target be the this value.
*0*let target be the this value.
*0*let o be the this value.
*0*let obj be the this value.
*0*let o be the this value.
*0*let o be the this value.
*0*let m be the this value.
*0*let m be the this value.
*0*let m be the this value.
*0*let m be the this value.
*0*let m be the this value.
*0*let m be the this value.
*0*let m be the this value.
*0*let m be the this value.
*0*let m be the this value.
*0*let o be the this value.
*0*let s be the this value.
*0*let s be the this value.
*0*let s be the this value.
*0*let s be the this value.
*0*let s be the this value.
*0*let s be the this value.
*0*let s be the this value.
*0*let o be the this value.
*0*let m be the this value.
*0*let m be the this value.
*0*let m be the this value.
*0*let m be the this value.
*0*let s be the this value.
*0*let s be the this value.
*0*let s be the this value.
*0*let o be the this value.
*0*let o be the this value.
*0*let v be the this value.
*0*let v be the this value.
*0*let v be the this value.
*0*let v be the this value.
*0*let v be the this value.
*0*let v be the this value.
*0*let v be the this value.
*0*let v be the this value.
*0*let v be the this value.
*0*let v be the this value.
*0*let v be the this value.
*0*let v be the this value.
*0*let v be the this value.
*0*let v be the this value.
*0*let v be the this value.
*0*let v be the this value.
*0*let o be the this value.
*0*let o be the this value.
*0*let o be the this value.
*0*let g be the this value.
*0*let g be the this value.
*0*let g be the this value.
*0*let generator be the this value.
*0*let generator be the this value.
*0*let generator be the this value.
*0*let c be the this value.
*0*let c be the this value.
*0*let c be the this value.
*0*let c be the this value.
*0*let promise be the this value.
*0*let promise be the this value.
*0*let promise be the this value.

VBN NNP . VB JJ NNP NNP NNP TO NNP .
84
*1*set desc.[[GET]] to getter.
*0*set iterator.[[ITERATEDLIST]] to list.
*0*set o.[[LISTITERATORNEXTINDEX]] to index+1.
*0*set envrec.[[THISVALUE]] to v.
*0*set envrec.[[TIONOBJECT]] to f.
*0*set envrec.[[HOMEOBJECT]] to home.
*0*set envrec.[[NEWTARGET]] to newtarget.
*0*set globalrec.[[OBJECTRECORD]] to objrec.
*0*set globalrec.[[GLOBALTHISVALUE]] to thisvalue.
*0*set globalrec.[[DECLARATIVERECORD]] to dclrec.
*0*set realmrec.[[INTRINSICS]] to intrinsics.
*0*set realmrec.[[GLOBALOBJECT]] to globalobj.
*0*set realmrec.[[GLOBALENV]] to newglobalenv.
*0*set f.[[STRICT]] to strict.
*0*set f.[[TIONKIND]] to functionkind.
*0*set f.[[ENVIRONMENT]] to scope.
*0*set f.[[FORMALPARAMETERS]] to parameterlist.
*0*set f.[[ECMASCRIPTCODE]] to body.
*0*set f.[[HOMEOBJECT]] to homeobject.
*0*set func.[[REALM]] to realm.
*0*set obj.[[BOUNDTARGETTION]] to targetfunction.
*0*set obj.[[BOUNDTHIS]] to boundthis.
*0*set obj.[[BOUNDARGUMENTS]] to boundargs.
*0*set obj.[[PARAMETERMAP]] to map.
*0*set getter.[[ENV]] to env.
*0*set setter.[[ENV]] to env.
*0*set m.[[MODULE]] to module.
*0*set m.[[EXPORTS]] to sortedexports.
*0*set module.[[NAMESPACE]] to m.
*0*set p.[[PROXYTARGET]] to target.
*0*set p.[[PROXYHANDLER]] to handler.
*0*set module.[[DFSINDEX]] to index.
*0*set module.[[DFSANCESTORINDEX]] to index.
*0*set module.[[ENVIRONMENT]] to env.
*0*set module.[[DFSINDEX]] to index.
*0*set module.[[DFSANCESTORINDEX]] to index.
*0*set o.[[BOOLEANDATA]] to b.
*0*set o.[[NUMBERDATA]] to n.
*0*set iterator.[[ITERATEDSTRING]] to string.
*0*set obj.[[ORIGINALSOURCE]] to p.
*0*set obj.[[ORIGINALFLAGS]] to f.
*0*set iterator.[[ITERATEDOBJECT]] to array.
*0*set iterator.[[ARRAYITERATIONKIND]] to kind.
*0*set o.[[ARRAYITERATORNEXTINDEX]] to index+1.
*0*set obj.[[TYPEDARRAYNAME]] to constructorname.
*0*set o.[[VIEWEDARRAYBUFFER]] to data.
*0*set o.[[BYTELENGTH]] to bytelength.
*0*set o.[[ARRAYLENGTH]] to length.
*0*set o.[[VIEWEDARRAYBUFFER]] to data.
*0*set o.[[BYTELENGTH]] to bytelength.
*0*set o.[[ARRAYLENGTH]] to elementlength.
*0*set o.[[VIEWEDARRAYBUFFER]] to buffer.
*0*set o.[[BYTELENGTH]] to newbytelength.
*0*set o.[[BYTEOFFSET]] to offset.
*0*set iterator.[[MAP]] to map.
*0*set iterator.[[MAPITERATIONKIND]] to kind.
*1*set o.[[MAPNEXTINDEX]] to index.
*0*set iterator.[[ITERATEDSET]] to set.
*0*set iterator.[[SETITERATIONKIND]] to kind.
*1*set o.[[SETNEXTINDEX]] to index.
*0*set obj.[[ARRAYBUFFERDATA]] to block.
*0*set obj.[[ARRAYBUFFERBYTELENGTH]] to bytelength.
*0*set obj.[[ARRAYBUFFERDATA]] to block.
*0*set obj.[[ARRAYBUFFERBYTELENGTH]] to bytelength.
*0*set o.[[VIEWEDARRAYBUFFER]] to buffer.
*0*set o.[[BYTELENGTH]] to viewbytelength.
*0*set o.[[BYTEOFFSET]] to offset.
*0*set asynciterator.[[SYNCITERATORRECORD]] to synciteratorrecord.
*0*set generator.[[GENERATORCONTEXT]] to gencontext.
*0*set generator.[[ASYNCGENERATORCONTEXT]] to gencontext.
*0*set resolve.[[PROMISE]] to promise.
*0*set resolve.[[ALREADYRESOLVED]] to alreadyresolved.
*0*set reject.[[PROMISE]] to promise.
*0*set reject.[[ALREADYRESOLVED]] to alreadyresolved.
*0*set promise.[[PROMISERESULT]] to value.
*0*set executor.[[CAPABILITY]] to promisecapability.
*0*set promisecapability.[[PROMISE]] to promise.
*0*set promise.[[PROMISERESULT]] to reason.
*1*set resolveelement.[[VALUES]] to values.
*1*set resolveelement.[[CAPABILITY]] to resultcapability.
*1*set resolveelement.[[REMAININGELEMENTS]] to remainingelementscount.
*1*set thenfinally.[[CONSTRUCTOR]] to c.
*1*set catchfinally.[[CONSTRUCTOR]] to c.
*0*set revoker.[[REVOCABLEPROXY]] to p.

NN JJ .
83
*0*return true.
*0*return true.
*0*return false.
*0*return false.
*0*return false.
*0*return false.
*0*return true.
*0*return false.
*0*return false.
*1*return false.
*1*return false.
*0*return true.
*0*return true.
*0*return true.
*0*return false.
*0*return true.
*0*return false.
*0*return false.
*0*return true.
*0*return false.
*0*return false.
*0*return true.
*0*return true.
*0*return false.
*0*return false.
*0*return true.
*0*return false.
*0*return true.
*0*return true.
*0*return true.
*1*return true.
*2*return true.
*2*return true.
*0*return true.
*0*return false.
*0*return true.
*1*return true.
*0*return false.
*1*return true.
*2*return false.
*0*return true.
*0*return true.
*2*return true.
*2*return true.
*0*return true.
*0*return false.
*0*return true.
*0*return false.
*0*return false.
*0*return false.
*0*return true.
*0*return false.
*0*return true.
*0*return true.
*0*return true.
*0*return true.
*0*return true.
*0*return false.
*0*return false.
*0*return false.
*0*return true.
*0*return false.
*0*return true.
*0*return false.
*0*return false.
*2*return true.
*0*return false.
*0*return false.
*2*return true.
*0*return false.
*0*return false.
*2*return true.
*0*return false.
*0*return false.
*2*return true.
*0*return false.
*0*return false.
*0*return false.
*0*return false.
*0*return true.
*0*return false.
*0*return false.
*0*return true.

IN NNP VBZ JJ , RB
82
*0*if hasenumerable is true, then
*0*if hasconfigurable is true, then
*0*if hasvalue is true, then
*0*if haswritable is true, then
*0*if hasget is true, then
*0*if hasset is true, then
*0*if value is false, then
*0*if existingprop is true, then
*1*if status is true, then
*0*if needsconstruct is true, then
*0*if prefix is present, then
*2*if hasduplicates is true, then
*1*if strict is true, then
*0*if hasduplicates is true, then
*0*if hasparameterexpressions is false, then
*0*if strict is false, then
*0*if newwritable is false, then
*0*if ismapped is true, then
*0*if ismapped is true, then
*0*if ismapped is false, then
*0*if ismapped is true, then
*0*if booleantrapresult is true, then
*0*if booleantrapresult is false, then
*0*if iterationkind is enumerate, then
*2*if destructuring is false, then
*2*if destructuring is false, then
*1*if destructuring is false, then
*2*if lhskind is assignment, then
*2*if iterationkind is enumerate, then
*2*if iterationkind is enumerate, then
*0*if direct is true, then
*0*if strict is false, then
*0*if stripprefix is true, then
*0*if strict is true, then
*0*if targethaslength is true, then
*0*if functionalreplace is false, then
*0*if functionalreplace is true, then
*0*if greedy is false, then
*1*if invert is false, then
*0*if unicode is true, then
*0*if bmp is true, then
*2*if sticky is true, then
*0*if fullunicode is true, then
*0*if global is false, then
*0*if functionalreplace is false, then
*0*if global is true, then
*1*if functionalreplace is true, then
*2*if next is false, then
*2*if mapping is true, then
*1*if mapping is true, then
*1*if spreadable is true, then
*1*if frompresent is true, then
*1*if kpresent is true, then
*1*if kpresent is true, then
*1*if kpresent is true, then
*1*if kpresent is true, then
*1*if kpresent is true, then
*1*if kpresent is true, then
*0*if initialvalue is present, then
*2*if kpresent is true, then
*1*if kpresent is true, then
*0*if initialvalue is present, then
*2*if kpresent is true, then
*1*if kpresent is true, then
*1*if frompresent is true, then
*1*if kpresent is true, then
*1*if kpresent is true, then
*1*if frompresent is true, then
*2*if frompresent is true, then
*2*if frompresent is true, then
*2*if frompresent is true, then
*2*if mapping is true, then
*1*if mapping is true, then
*0*if same is true, then
*0*if onlyint32 is true, then
*0*if awoken is true, then
*1*if isarray is true, then
*2*if isarray is true, then
*0*if partial is empty, then
*0*if partial is empty, then
*1*if next is false, then
*1*if next is false, then

IN NNP ( NNP ) VBZ RB JJ , VB DT NN NN .
78
*0*if type(obj) is not object, throw a typeerror exception.
*0*if type(obj) is not object, throw a typeerror exception.
*0*if type(p) is not object, throw a typeerror exception.
*0*if type(c) is not object, throw a typeerror exception.
*0*if type(iterator) is not object, throw a typeerror exception.
*0*if type(result) is not object, throw a typeerror exception.
*0*if type(newobj) is not object, throw a typeerror exception.
*0*if type(target) is not object, throw a typeerror exception.
*0*if type(handler) is not object, throw a typeerror exception.
*0*if type(func) is not object, throw a typeerror exception.
*0*if type(target) is not object, throw a typeerror exception.
*1*if type(nextresult) is not object, throw a typeerror exception.
*0*if type(o) is not object, throw a typeerror exception.
*0*if type(o) is not object, throw a typeerror exception.
*0*if type(sym) is not symbol, throw a typeerror exception.
*0*if type(o) is not object, throw a typeerror exception.
*0*if type(o) is not object, throw a typeerror exception.
*0*if type(o) is not object, throw a typeerror exception.
*0*if type(r) is not object, throw a typeerror exception.
*0*if type(rx) is not object, throw a typeerror exception.
*0*if type(rx) is not object, throw a typeerror exception.
*0*if type(rx) is not object, throw a typeerror exception.
*0*if type(rx) is not object, throw a typeerror exception.
*0*if type(r) is not object, throw a typeerror exception.
*0*if type(r) is not object, throw a typeerror exception.
*0*if type(o) is not object, throw a typeerror exception.
*0*if type(o) is not object, throw a typeerror exception.
*0*if type(target) is not object, throw a typeerror exception.
*0*if type(target) is not object, throw a typeerror exception.
*0*if type(target) is not object, throw a typeerror exception.
*0*if type(o) is not object, throw a typeerror exception.
*0*if type(m) is not object, throw a typeerror exception.
*0*if type(m) is not object, throw a typeerror exception.
*0*if type(m) is not object, throw a typeerror exception.
*0*if type(m) is not object, throw a typeerror exception.
*0*if type(m) is not object, throw a typeerror exception.
*0*if type(m) is not object, throw a typeerror exception.
*0*if type(map) is not object, throw a typeerror exception.
*0*if type(o) is not object, throw a typeerror exception.
*0*if type(s) is not object, throw a typeerror exception.
*0*if type(s) is not object, throw a typeerror exception.
*0*if type(s) is not object, throw a typeerror exception.
*0*if type(s) is not object, throw a typeerror exception.
*0*if type(s) is not object, throw a typeerror exception.
*0*if type(set) is not object, throw a typeerror exception.
*0*if type(o) is not object, throw a typeerror exception.
*0*if type(m) is not object, throw a typeerror exception.
*0*if type(m) is not object, throw a typeerror exception.
*0*if type(m) is not object, throw a typeerror exception.
*0*if type(m) is not object, throw a typeerror exception.
*0*if type(key) is not object, throw a typeerror exception.
*0*if type(s) is not object, throw a typeerror exception.
*0*if type(value) is not object, throw a typeerror exception.
*0*if type(s) is not object, throw a typeerror exception.
*0*if type(s) is not object, throw a typeerror exception.
*0*if type(o) is not object, throw a typeerror exception.
*0*if type(o) is not object, throw a typeerror exception.
*0*if type(view) is not object, throw a typeerror exception.
*0*if type(view) is not object, throw a typeerror exception.
*0*if type(buffer) is not object, throw a typeerror exception.
*0*if type(typedarray) is not object, throw a typeerror exception.
*0*if type(generator) is not object, throw a typeerror exception.
*0*if type(c) is not object, throw a typeerror exception.
*0*if type(c) is not object, throw a typeerror exception.
*0*if type(c) is not object, throw a typeerror exception.
*0*if type(c) is not object, throw a typeerror exception.
*0*if type(promise) is not object, throw a typeerror exception.
*0*if type(target) is not object, throw a typeerror exception.
*0*if type(target) is not object, throw a typeerror exception.
*0*if type(target) is not object, throw a typeerror exception.
*0*if type(target) is not object, throw a typeerror exception.
*0*if type(target) is not object, throw a typeerror exception.
*0*if type(target) is not object, throw a typeerror exception.
*0*if type(target) is not object, throw a typeerror exception.
*0*if type(target) is not object, throw a typeerror exception.
*0*if type(target) is not object, throw a typeerror exception.
*0*if type(target) is not object, throw a typeerror exception.
*0*if type(target) is not object, throw a typeerror exception.

VB NNP VB CD .
72
*1*let index be 0.
*0*let n be 0.
*0*let index be 0.
*0*let index be 0.
*0*let index be 0.
*0*let index be 0.
*0*let sign be 1.
*1*let r be 10.
*0*let k be 0.
*0*let k be 0.
*3*let j be 1.
*1*let k be 1.
*1*let e be 0.
*1*let e be 0.
*0*let nextindex be 0.
*0*let nextindex be 0.
*0*let nextindex be 0.
*0*let lengtha be 0.
*0*let p be 0.
*1*let n be 0.
*0*let nextsourceposition be 0.
*1*let n be 1.
*0*let lengtha be 0.
*0*let p be 0.
*3*let i be 1.
*1*let intlen be 1.
*0*let k be 0.
*1*let k be 0.
*0*let k be 0.
*0*let k be 0.
*0*let n be 0.
*2*let k be 0.
*1*let direction be 1.
*0*let k be 0.
*0*let k be 0.
*0*let to be 0.
*0*let k be 0.
*0*let k be 0.
*0*let k be 0.
*0*let k be 0.
*0*let k be 0.
*0*let k be 0.
*0*let lower be 0.
*0*let k be 1.
*0*let n be 0.
*0*let k be 0.
*1*let insertcount be 0.
*1*let actualdeletecount be 0.
*1*let insertcount be 0.
*0*let k be 0.
*0*let k be 0.
*1*let j be 0.
*1*let k be 0.
*0*let k be 0.
*0*let k be 0.
*2*let direction be 1.
*0*let k be 0.
*0*let captured be 0.
*0*let n be 0.
*0*let k be 0.
*0*let k be 0.
*0*let k be 0.
*1*let srcbyteindex be 0.
*1*let n be 0.
*1*let targetbyteindex be 0.
*1*let k be 0.
*0*let k be 0.
*0*let n be 0.
*2*let i be 0.
*3*let k be 0.
*0*let index be 0.
*0*let index be 0.

IN NNP ( NNP ) VBZ JJ , VB DT NN NN .
71
*0*if isunresolvablereference(v) is true, throw a referenceerror exception.
*0*if iscallable(func) is false, throw a typeerror exception.
*0*if iscallable(f) is false, throw a typeerror exception.
*0*if dclrec.hasbinding(n) is true, throw a typeerror exception.
*0*if dclrec.hasbinding(n) is true, throw a typeerror exception.
*0*if isconstructor(c) is false, throw a typeerror exception.
*2*if isdetachedbuffer(buffer) is true, throw a typeerror exception.
*0*if isdetachedbuffer(buffer) is true, throw a typeerror exception.
*0*if isdetachedbuffer(buffer) is true, throw a typeerror exception.
*0*if isconstructor(constructor) is false, throw a typeerror exception.
*0*if iscallable(func) is false, throw a typeerror exception.
*0*if isconstructor(superconstructor) is false, throw a typeerror exception.
*0*if iscallable(target) is false, throw a typeerror exception.
*1*if envrec.hasvardeclaration(name) is true, throw a syntaxerror exception.
*1*if envrec.haslexicaldeclaration(name) is true, throw a syntaxerror exception.
*1*if envrec.haslexicaldeclaration(name) is true, throw a syntaxerror exception.
*3*if varenvrec.haslexicaldeclaration(name) is true, throw a syntaxerror exception.
*0*if iscallable(func) is false, throw a typeerror exception.
*0*if iscallable(target) is false, throw a typeerror exception.
*0*if iscallable(func) is false, throw a typeerror exception.
*1*if iscallable(mapfn) is false, throw a typeerror exception.
*0*if iscallable(callbackfn) is false, throw a typeerror exception.
*0*if iscallable(callbackfn) is false, throw a typeerror exception.
*0*if iscallable(predicate) is false, throw a typeerror exception.
*0*if iscallable(predicate) is false, throw a typeerror exception.
*0*if iscallable(callbackfn) is false, throw a typeerror exception.
*0*if iscallable(callbackfn) is false, throw a typeerror exception.
*0*if iscallable(callbackfn) is false, throw a typeerror exception.
*0*if iscallable(callbackfn) is false, throw a typeerror exception.
*0*if iscallable(callbackfn) is false, throw a typeerror exception.
*0*if isconstructor(c) is false, throw a typeerror exception.
*1*if iscallable(mapfn) is false, throw a typeerror exception.
*0*if isconstructor(c) is false, throw a typeerror exception.
*1*if isdetachedbuffer(buffer) is true, throw a typeerror exception.
*0*if isdetachedbuffer(buffer) is true, throw a typeerror exception.
*0*if iscallable(callbackfn) is false, throw a typeerror exception.
*0*if iscallable(callbackfn) is false, throw a typeerror exception.
*0*if isdetachedbuffer(targetbuffer) is true, throw a typeerror exception.
*1*if isdetachedbuffer(targetbuffer) is true, throw a typeerror exception.
*0*if isdetachedbuffer(targetbuffer) is true, throw a typeerror exception.
*1*if isdetachedbuffer(targetbuffer) is true, throw a typeerror exception.
*0*if isdetachedbuffer(targetbuffer) is true, throw a typeerror exception.
*0*if isdetachedbuffer(srcbuffer) is true, throw a typeerror exception.
*1*if isdetachedbuffer(srcbuffer) is true, throw a typeerror exception.
*0*if isdetachedbuffer(srcdata) is true, throw a typeerror exception.
*1*if isdetachedbuffer(srcdata) is true, throw a typeerror exception.
*1*if isdetachedbuffer(srcdata) is true, throw a typeerror exception.
*0*if isdetachedbuffer(buffer) is true, throw a typeerror exception.
*0*if iscallable(adder) is false, throw a typeerror exception.
*0*if iscallable(callbackfn) is false, throw a typeerror exception.
*0*if iscallable(adder) is false, throw a typeerror exception.
*0*if iscallable(callbackfn) is false, throw a typeerror exception.
*0*if iscallable(adder) is false, throw a typeerror exception.
*0*if iscallable(adder) is false, throw a typeerror exception.
*0*if isdetachedbuffer(srcbuffer) is true, throw a typeerror exception.
*0*if issharedarraybuffer(o) is true, throw a typeerror exception.
*0*if isdetachedbuffer(o) is true, throw a typeerror exception.
*0*if issharedarraybuffer(new) is true, throw a typeerror exception.
*0*if isdetachedbuffer(new) is true, throw a typeerror exception.
*0*if isdetachedbuffer(o) is true, throw a typeerror exception.
*0*if issharedarraybuffer(o) is false, throw a typeerror exception.
*0*if issharedarraybuffer(new) is false, throw a typeerror exception.
*0*if isdetachedbuffer(buffer) is true, throw a typeerror exception.
*0*if isdetachedbuffer(buffer) is true, throw a typeerror exception.
*0*if isdetachedbuffer(buffer) is true, throw a typeerror exception.
*0*if issharedarraybuffer(buffer) is false, throw a typeerror exception.
*0*if isconstructor(c) is false, throw a typeerror exception.
*0*if iscallable(executor) is false, throw a typeerror exception.
*0*if ispromise(promise) is false, throw a typeerror exception.
*0*if iscallable(target) is false, throw a typeerror exception.
*0*if isconstructor(target) is false, throw a typeerror exception.

NN . NNP ( NNP , NNP ) .
64
*1*return ? ordinarytoprimitive(input, hint).
*1*return ? instanceofoperator(o, bc).
*0*return ? get(bindings, n).
*0*return ? objrec.initializebinding(n, v).
*0*return ? objrec.getbindingvalue(n, s).
*1*perform ? objrec.createmutablebinding(n, d).
*0*return ! ordinarysetprototypeof(o, v).
*0*return ! ordinarygetownproperty(o, p).
*0*return ? ordinaryhasproperty(o, p).
*0*return ? call(getter, receiver).
*0*return ? ordinarydelete(o, p).
*0*perform ! setfunctionlength(f, len).
*1*return ? arraysetlength(a, desc).
*0*return ! stringgetownproperty(s, p).
*0*return ? ordinaryhasproperty(o, p).
*2*return ? integerindexedelementget(o, numericindex).
*0*return ? setimmutableprototype(o, v).
*1*return ? ordinarydelete(o, p).
*0*return ? setimmutableprototype(o, v).
*1*return ? putvalue(lhs, value).
*0*return ? construct(constructor, arglist).
*0*return ? ordinaryhasinstance(target, v).
*1*return ? getiterator(exprvalue, iteratorhint).
*3*return ? iteratorclose(iteratorrecord, status).
*3*return ? iteratorclose(iteratorrecord, status).
*3*perform ! varenvrec.initializebinding(fn, fo).
*0*return ? decode(uristring, reserveduriset).
*0*return ? decode(componentstring, reserveduricomponentset).
*0*return ? encode(uristring, unescapeduriset).
*0*return ? encode(componentstring, unescapeduricomponentset).
*0*return ? hasownproperty(o, p).
*1*return ? call(func, thisarg).
*0*perform ! setfunctionlength(f, l).
*0*return ? ordinaryhasinstance(f, v).
*0*return ? ordinarytoprimitive(o, tryfirst).
*0*return ? regexpbuiltinexec(r, s).
*0*return ? regexpbuiltinexec(r, s).
*1*return ? regexpexec(rx, s).
*3*return ? iteratorclose(iteratorrecord, error).
*2*perform ? deletepropertyorthrow(o, tokey).
*1*perform ? deletepropertyorthrow(o, index).
*2*perform ? deletepropertyorthrow(o, upperp).
*2*perform ? deletepropertyorthrow(o, lowerp).
*2*perform ? deletepropertyorthrow(o, to).
*3*perform ? deletepropertyorthrow(o, to).
*3*perform ? deletepropertyorthrow(o, to).
*0*return ? call(func, array).
*3*perform ? deletepropertyorthrow(o, to).
*1*perform ? allocatetypedarraybuffer(obj, length).
*1*perform ? allocatetypedarraybuffer(o, len).
*0*perform ? allocatetypedarraybuffer(o, len).
*2*return ? iteratorclose(iteratorrecord, error).
*2*return ? iteratorclose(iteratorrecord, error).
*0*return ? atomicload(typedarray, index).
*1*return ? internalizejsonproperty(root, rootname).
*0*return ? generatorresume(g, value).
*0*return ? generatorresumeabrupt(g, c).
*0*return ? generatorresumeabrupt(g, c).
*0*return ! asyncgeneratorenqueue(generator, completion).
*0*return ! asyncgeneratorenqueue(generator, completion).
*0*return ! asyncgeneratorenqueue(generator, completion).
*3*return ! asyncgeneratorreject(generator, resultvalue).
*0*return ? promiseresolve(c, x).
*0*return ? proxycreate(target, handler).

VB NNP VB NNP ( NNP ) .
61
*0*let base be getbase(v).
*0*let base be getbase(v).
*0*let base be getbase(v).
*1*let alreadydeclared be envrec.hasbinding(paramname).
*2*let ao be createunmappedargumentsobject(argumentslist).
*0*let iteratorrecord be createlistiteratorrecord(argumentslist).
*1*let varenv be newdeclarativeenvironment(env).
*1*let lexenv be newdeclarativeenvironment(varenv).
*0*let descobj be frompropertydescriptor(desc).
*0*let argarray be createarrayfromlist(argumentslist).
*0*let argarray be createarrayfromlist(argumentslist).
*1*let lhs be resolvebinding(name).
*2*let thisvalue be getthisvalue(ref).
*2*let refenv be getbase(ref).
*1*let thisiterationenv be newdeclarativeenvironment(outer).
*1*let tdz be newdeclarativeenvironment(oldenv).
*2*let iterationenv be newdeclarativeenvironment(oldenv).
*0*let importedboundnames be importedlocalnames(importentries).
*0*let obj be objectcreate(o).
*2*let targetlen be tointeger(targetlen).
*0*let b be toboolean(value).
*0*let integer be tointeger(number).
*0*let integer be tointeger(number).
*0*let n be touint32(x).
*0*let a be touint32(x).
*0*let b be touint32(y).
*0*let v be timeclip(t).
*0*let v be timeclip(newdate).
*0*let v be timeclip(newdate).
*0*let v be timeclip(newdate).
*0*let v be timeclip(date).
*0*let v be timeclip(newdate).
*0*let v be timeclip(date).
*0*let t be localtime(tv).
*0*let t be localtime(tv).
*0*let t be localtime(tv).
*0*let functionalreplace be iscallable(replacevalue).
*1*let cc be canonicalize(ch).
*0*let functionalreplace be iscallable(replacevalue).
*1*let intlen be touint32(len).
*1*let intvalue be convop(value).
*2*let member be quotejsonstring(p).
*0*let nextdone be iteratorcomplete(nextresult).
*0*let nextvalue be iteratorvalue(nextresult).
*0*let returndone be iteratorcomplete(returnresult).
*0*let returnvalue be iteratorvalue(returnresult).
*0*let throwdone be iteratorcomplete(throwresult).
*0*let throwvalue be iteratorvalue(throwresult).
*0*let c be throwcompletion(exception).
*0*let completion be normalcompletion(value).
*0*let completion be throwcompletion(exception).
*2*let handlerresult be throwcompletion(argument).
*0*let resolvingfunctions be createresolvingfunctions(promisetoresolve).
*0*let resolvingfunctions be createresolvingfunctions(promise).
*0*let iteratorrecord be getiterator(iterable).
*1*let next be iteratorstep(iteratorrecord).
*3*let valuesarray be createarrayfromlist(values).
*1*let nextvalue be iteratorvalue(next).
*0*let iteratorrecord be getiterator(iterable).
*1*let next be iteratorstep(iteratorrecord).
*1*let nextvalue be iteratorvalue(next).

NN NNP IN CD .
61
*1*decrement count by 1.
*1*increment n by 1.
*3*increase k by 1.
*1*increase k by 1.
*2*increment k by 2.
*4*increment k by 1.
*4*increment k by 2.
*4*increment j by 1.
*1*increase k by 1.
*2*increase k by 1.
*3*increment lengtha by 1.
*1*increase k by 1.
*2*increase k by 1.
*1*increase k by 1.
*1*increase k by 1.
*3*increase n by 1.
*3*increase k by 1.
*2*increase n by 1.
*1*increase k by 1.
*1*increase k by 1.
*3*increase to by 1.
*1*increase k by 1.
*1*increase k by 1.
*1*increase k by 1.
*1*increase k by 1.
*1*increase k by 1.
*1*increase k by 1.
*1*increase k by 1.
*1*decrease k by 1.
*1*increase k by 1.
*2*increase k by 1.
*1*increase k by 1.
*2*decrease k by 1.
*1*decrease k by 1.
*1*increase lower by 1.
*1*increase k by 1.
*1*increase k by 1.
*1*increase n by 1.
*1*increase k by 1.
*1*increment k by 1.
*2*increase k by 1.
*2*decrease k by 1.
*2*decrease k by 1.
*1*increase k by 1.
*1*increase k by 1.
*2*decrease k by 1.
*2*increase j by 1.
*2*increase k by 1.
*1*increase k by 1.
*1*increase k by 1.
*1*increase k by 1.
*1*increase k by 1.
*1*increment n by 1.
*1*increase k by 1.
*2*increase k by 1.
*2*increase n by 1.
*2*increase srcbyteindex by 1.
*2*increase targetbyteindex by 1.
*2*decrement count by 1.
*2*increase k by 1.
*1*increase k by 1.

VB NNP VB . JJ ( DT NN ) .
50
*0*let b be ? thisbooleanvalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let t be ? thistimevalue(this value).
*0*let tv be ? thistimevalue(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).
*0*let o be ? requireobjectcoercible(this value).

IN NNP ( NNP ) VBZ JJ , RB
44
*0*if ispropertyreference(v) is true, then
*1*if hasprimitivebase(v) is true, then
*0*if isunresolvablereference(v) is true, then
*1*if isstrictreference(v) is true, then
*1*if hasprimitivebase(v) is true, then
*0*if issuperreference(v) is true, then
*0*if type(input) is object, then
*1*if iscallable(method) is true, then
*0*if type(x) is boolean, then
*3*if isaccessordescriptor(currentdesc) is true, then
*0*if type(unscopables) is object, then
*0*if dclrec.hasbinding(n) is true, then
*0*if dclrec.hasbinding(n) is true, then
*0*if dclrec.hasbinding(n) is true, then
*0*if dclrec.hasbinding(n) is true, then
*1*if isdatadescriptor(current) is true, then
*0*if isdatadescriptor(owndesc) is true, then
*0*if isconstructor(targetfunction) is true, then
*0*if isconstructor(c) is true, then
*0*if type(c) is object, then
*1*if isaccessordescriptor(desc) is true, then
*1*if isaccessordescriptor(targetdesc) is true, then
*0*if iscallable(target) is true, then
*1*if isconstructor(target) is true, then
*1*if ispropertyreference(ref) is true, then
*4*if thisenvrec.hasbinding(name) is true, then
*0*if iscallable(exec) is true, then
*1*if isconstructor(c) is true, then
*0*if isconstructor(c) is true, then
*0*if isconstructor(c) is true, then
*0*if issharedarraybuffer(srcdata) is false, then
*0*if issharedarraybuffer(arraybuffer) is true, then
*0*if issharedarraybuffer(arraybuffer) is true, then
*0*if iscallable(reviver) is true, then
*0*if type(val) is object, then
*0*if type(replacer) is object, then
*1*if iscallable(replacer) is true, then
*0*if type(space) is object, then
*0*if type(value) is object, then
*1*if iscallable(tojson) is true, then
*0*if type(value) is object, then
*0*if ispromise(x) is true, then
*0*if iscallable(onfinally) is false, then
*0*if iscallable(onrejected) is false, then

NN NNP ( NNP ) .
43
*0*return getbase(v).
*0*return completion(completion).
*0*return completion(completion).
*1*return dclrec.deletebinding(n).
*0*return dclrec.hasbinding(n).
*0*return envrec.bindthisvalue(thisvalue).
*0*call completepropertydescriptor(resultdesc).
*0*return islabelledfunction(substmt).
*0*return completion(result).
*0*return completion(result).
*0*return completion(result).
*0*return createarrayfromlist(namelist).
*0*return frompropertydescriptor(desc).
*0*return createarrayfromlist(namelist).
*0*return createarrayfromlist(namelist).
*0*return createarrayfromlist(namelist).
*0*return symboldescriptivestring(sym).
*1*return todatestring(now).
*1*return todatestring(now).
*1*return todatestring(now).
*0*return datefromtime(t).
*0*return weekday(t).
*0*return datestring(t).
*0*return todatestring(tv).
*0*return createstringiterator(s).
*0*perform entercriticalsection(wl).
*0*perform entercriticalsection(wl).
*1*perform leavecriticalsection(wl).
*0*perform leavecriticalsection(wl).
*0*perform entercriticalsection(wl).
*0*perform leavecriticalsection(wl).
*2*return completion(result).
*0*return completion(result).
*1*return completion(abruptcompletion).
*0*return completion(result).
*0*return normalcompletion(iternextobj).
*0*return completion(status).
*1*return completion(status).
*0*return completion(thencallresult).
*0*return completion(result).
*0*return completion(result).
*0*return frompropertydescriptor(desc).
*0*return createarrayfromlist(keys).

IN NNP VBZ RB JJ , RB
43
*1*if exotictoprim is not undefined, then
*2*if currentdesc is not undefined, then
*1*if currentdesc is not undefined, then
*0*if method is not present, then
*0*if value is not present, then
*0*if o is not undefined, then
*0*if parent is not null, then
*1*if parent is not null, then
*1*if existingdescriptor is not undefined, then
*0*if prototype is not present, then
*0*if prototype is not present, then
*0*if stringdesc is not undefined, then
*1*if numericindex is not undefined, then
*1*if numericindex is not undefined, then
*1*if numericindex is not undefined, then
*1*if numericindex is not undefined, then
*1*if numericindex is not undefined, then
*1*if targetdesc is not undefined, then
*0*if environment is not undefined, then
*0*if instofhandler is not undefined, then
*0*if message is not undefined, then
*0*if message is not undefined, then
*1*if fractiondigits is not undefined, then
*1*if matcher is not undefined, then
*1*if replacer is not undefined, then
*0*if namedcaptures is not undefined, then
*1*if searcher is not undefined, then
*1*if splitter is not undefined, then
*2*if capn is not undefined, then
*2*if namedcaptures is not undefined, then
*0*if usingiterator is not undefined, then
*0*if comparefn is not undefined, then
*0*if usingiterator is not undefined, then
*1*if next is not false, then
*0*if length is not present, then
*0*if usingiterator is not undefined, then
*1*if e is not empty, then
*1*if e is not empty, then
*0*if replacerfunction is not undefined, then
*0*if propertylist is not undefined, then
*1*if strp is not undefined, then
*0*if receiver is not present, then
*0*if receiver is not present, then

NN , IN NNP CC NN : NNP
42
*0*repeat, while index &lt; len
*0*repeat, while index &lt; count
*3*repeat, while j &lt; n
*1*repeat, while k &lt; argcount-1
*0*repeat, while nextindex &lt; length
*0*repeat, while nextindex &lt; length
*0*repeat, while k &lt; numberofargs
*0*repeat, while k &lt; len
*0*repeat, while k &lt; len
*2*repeat, while k &lt; len
*0*repeat, while k &lt; len
*0*repeat, while k &lt; final
*0*repeat, while k &lt; len
*0*repeat, while k &lt; len
*0*repeat, while k &lt; len
*0*repeat, while k &lt; len
*0*repeat, while k &lt; len
*0*repeat, while k &lt; len
*0*repeat, while k &lt; len
*0*repeat, while k &lt; len
*0*repeat, while k &lt; len
*0*repeat, while k &lt; len
*0*repeat, while k &lt; final
*0*repeat, while k &lt; len
*0*repeat, while k &lt; actualdeletecount
*1*repeat, while k &gt; actualstart
*0*repeat, while k &lt; len
*1*repeat, while k &lt; len
*0*repeat, while k &lt; len
*0*repeat, while k &lt; len
*0*repeat, while k &lt; final
*0*repeat, while k &lt; len
*0*repeat, while k &lt; len
*0*repeat, while targetbyteindex &lt; limit
*0*repeat, while targetbyteindex &lt; limit
*1*repeat, while targetbyteindex &lt; limit
*1*repeat, while targetbyteindex &lt; limit
*1*repeat, while k &lt; final
*1*repeat, while targetbyteindex &lt; limit
*1*repeat, while k &lt; len
*0*repeat, while k &lt; len
*0*repeat, while index &lt; len

IN NNP VBZ JJ , VB DT NN NN .
41
*0*if success is false, throw a typeerror exception.
*0*if success is false, throw a typeerror exception.
*0*if success is false, throw a typeerror exception.
*1*if s is true, throw a referenceerror exception.
*1*if s is true, throw a typeerror exception.
*1*if targetenv is undefined, throw a referenceerror exception.
*0*if targetenv is undefined, throw a referenceerror exception.
*0*if handler is null, throw a typeerror exception.
*0*if handler is null, throw a typeerror exception.
*0*if handler is null, throw a typeerror exception.
*0*if handler is null, throw a typeerror exception.
*1*if targetisextensible is true, throw a typeerror exception.
*0*if handler is null, throw a typeerror exception.
*1*if extensibletarget is false, throw a typeerror exception.
*0*if valid is false, throw a typeerror exception.
*0*if handler is null, throw a typeerror exception.
*1*if extensibletarget is false, throw a typeerror exception.
*1*if settingconfigfalse is true, throw a typeerror exception.
*0*if handler is null, throw a typeerror exception.
*2*if extensibletarget is false, throw a typeerror exception.
*0*if handler is null, throw a typeerror exception.
*0*if handler is null, throw a typeerror exception.
*0*if handler is null, throw a typeerror exception.
*0*if handler is null, throw a typeerror exception.
*0*if handler is null, throw a typeerror exception.
*0*if handler is null, throw a typeerror exception.
*1*if hasrestrictedglobal is true, throw a syntaxerror exception.
*3*if fndefinable is false, throw a typeerror exception.
*4*if vndefinable is false, throw a typeerror exception.
*4*if fndefinable is false, throw a typeerror exception.
*5*if vndefinable is false, throw a typeerror exception.
*0*if status is false, throw a typeerror exception.
*0*if status is false, throw a typeerror exception.
*0*if status is false, throw a typeerror exception.
*0*if status is false, throw a typeerror exception.
*0*if isregexp is true, throw a typeerror exception.
*0*if isregexp is true, throw a typeerror exception.
*0*if isregexp is true, throw a typeerror exception.
*1*if kpresent is false, throw a typeerror exception.
*1*if kpresent is false, throw a typeerror exception.
*0*if b is false, throw a typeerror exception.

VB NNP VB NNP .
41
*0*let p be v.
*1*let parameterbindings be parameternames.
*1*let varenv be env.
*1*let varenvrec be envrec.
*0*let newargdesc be desc.
*1*let index be index+1.
*3*let status be lhsref.
*1*let thislex be lexenv.
*2*let start be k.
*0*let r be s.
*0*let q be p.
*3*let p be e.
*3*let q be p.
*1*let p be pattern.
*1*let f be flags.
*2*let n be n+1.
*0*let q be p.
*3*let p be e.
*3*let q be p.
*1*let k be n.
*1*let newlen be len-1.
*1*let len be len+1.
*0*let k be len-1.
*1*let k be actualstart.
*1*let k be len.
*0*let k be actualstart.
*1*let k be len.
*0*let srcarray be typedarray.
*1*let srcbyteindex be srcbyteoffset.
*1*let count be elementlength.
*0*let arraylike be object.
*2*let replacerfunction be replacer.
*4*let k be k+1.
*0*let stepback be indent.
*1*let k be propertylist.
*0*let stepback be indent.
*1*let thenfinally be onfinally.
*1*let catchfinally be onfinally.
*1*let receiver be target.
*1*let receiver be target.
*0*let bytelocation be byteindex.

VB NNP VB . NNP ( . NNP ( NNP , `` NN '' ) ) .
40
*0*let len be ? tolength(? get(obj, "length")).
*0*let lastindex be ? tolength(? get(r, "lastindex")).
*4*let thisindex be ? tolength(? get(rx, "lastindex")).
*4*let thisindex be ? tolength(? get(rx, "lastindex")).
*1*let position be ? tointeger(? get(result, "index")).
*2*let e be ? tolength(? get(splitter, "lastindex")).
*0*let len be ? tolength(? get(arraylike, "length")).
*2*let len be ? tolength(? get(e, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(obj, "length")).
*0*let len be ? tolength(? get(o, "length")).
*0*let len be ? tolength(? get(array, "length")).
*0*let len be ? tolength(? get(o, "length")).
*1*let len be ? tolength(? get(a, "length")).
*0*let len be ? tolength(? get(arraylike, "length")).
*0*let srclength be ? tolength(? get(src, "length")).
*0*let srclength be ? tolength(? get(src, "length")).
*0*let len be ? tolength(? get(arraylike, "length")).
*2*let len be ? tolength(? get(val, "length")).
*3*let len be ? tolength(? get(replacer, "length")).
*0*let len be ? tolength(? get(value, "length")).

VB NNP VB . NNP ( DT NN ) .
39
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ! toobject(this value).
*0*let sym be ? thissymbolvalue(this value).
*0*let x be ? thisnumbervalue(this value).
*0*let x be ? thisnumbervalue(this value).
*0*let x be ? thisnumbervalue(this value).
*0*let x be ? thisnumbervalue(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let obj be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let array be ? toobject(this value).
*0*let array be ? toobject(this value).
*0*let o be ? toobject(this value).
*0*let o be ? toobject(this value).

VB NNP VB DT JJ JJ NN .
38
*0*let list be a new empty list.
*0*let env be a new lexical environment.
*0*let env be a new lexical environment.
*0*let env be a new lexical environment.
*0*let env be a new lexical environment.
*0*let env be a new lexical environment.
*0*let keys be a new empty list.
*0*let functionnames be a new empty list.
*0*let functionstoinitialize be a new empty list.
*1*let instantiatedvarnames be a new empty list.
*0*let keys be a new empty list.
*0*let mappednames be a new empty list.
*0*let keys be a new empty list.
*0*let targetconfigurablekeys be a new empty list.
*0*let targetnonconfigurablekeys be a new empty list.
*0*let functionstoinitialize be a new empty list.
*0*let declaredfunctionnames be a new empty list.
*0*let declaredvarnames be a new empty list.
*0*let localnames be a new empty list.
*0*let declaredvarnames be a new empty list.
*1*let unambiguousnames be a new empty list.
*0*let functionstoinitialize be a new empty list.
*0*let declaredfunctionnames be a new empty list.
*0*let declaredvarnames be a new empty list.
*0*let namelist be a new empty list.
*0*let arglist be a new empty list.
*1*let captures be a new empty list.
*0*let results be a new empty list.
*1*let captures be a new empty list.
*0*let values be a new empty list.
*0*let kept be a new empty list.
*0*let l be a new empty list.
*0*let stack be a new empty list.
*3*let propertylist be a new empty list.
*0*let partial be a new empty list.
*0*let partial be a new empty list.
*0*let values be a new empty list.
*0*let bytesread be a new empty list.

NN . NNP ( NNP , NNP , NNP ) .
36
*3*perform ? definepropertyorthrow(o, k, desc).
*0*return ? call(func, v, argumentslist).
*3*perform ! createdataproperty(target, nextkey, propvalue).
*0*return ? objrec.setmutablebinding(n, v, s).
*0*perform ? definepropertyorthrow(globalobject, n, desc).
*1*return ? getidentifierreference(outer, name, strict).
*1*perform ? definepropertyorthrow(global, name, desc).
*0*return ? getidentifierreference(env, name, strict).
*0*return ? ordinarydefineownproperty(o, p, desc).
*0*return ? ordinaryget(o, p, receiver).
*2*return ? createdataproperty(receiver, p, v).
*0*return ? call(target, boundthis, args).
*0*return ? construct(target, args, newtarget).
*1*return ! iscompatiblepropertydescriptor(extensible, desc, stringdesc).
*0*return ! ordinarydefineownproperty(s, p, desc).
*1*return ? ordinaryget(args, p, receiver).
*3*return ? integerindexedelementset(o, numericindex, value).
*0*return ! ordinarydefineownproperty(o, p, desc).
*0*return ? ordinaryget(o, p, receiver).
*2*return ? integerindexedelementset(o, numericindex, v).
*1*return ? ordinaryget(o, p, receiver).
*1*return ? call(target, thisargument, argumentslist).
*1*return ? construct(target, argumentslist, newtarget).
*1*perform ? definepropertyorthrow(o, p, desc).
*0*perform ? definepropertyorthrow(o, key, desc).
*0*return ? call(func, thisarg, arglist).
*0*return ? call(func, thisarg, arglist).
*0*return ? regexpinitialize(o, p, f).
*0*return ? regexpinitialize(obj, p, f).
*2*perform ! createdataproperty(groups, s, capturedvalue).
*1*perform ? createdatapropertyorthrow(a, pk, mappedvalue).
*1*perform ? createdatapropertyorthrow(a, pk, kvalue).
*2*perform ? createdatapropertyorthrow(a, pk, mappedvalue).
*4*perform ? createdataproperty(val, p, newelement).
*0*return ? call(target, thisargument, args).
*0*return ? construct(target, args, newtarget).

NN . NNP ( NNP ) .
35
*0*return ? tonumber(primvalue).
*0*return ? tostring(primvalue).
*0*return ! tostring(key).
*1*return ? isarray(target).
*1*return ? getfunctionrealm(target).
*1*return ? getfunctionrealm(proxytarget).
*3*return ? createasyncfromsynciterator(synciteratorrecord).
*0*return ? objrec.hasbinding(n).
*0*return ? isextensible(globalobject).
*0*return ! ordinarygetprototypeof(o).
*0*return ! ordinaryisextensible(o).
*0*return ! ordinaryownpropertykeys(o).
*0*perform ? createperiterationenvironment(periterationbindings).
*1*perform ? createperiterationenvironment(periterationbindings).
*2*perform ? getvalue(incref).
*0*return ? scriptevaluation(s).
*0*perform ? moduledeclarationenvironmentsetup(module).
*0*perform ? moduleexecution(module).
*0*return ! toobject(value).
*0*return ? isextensible(o).
*0*return ? isarray(arg).
*0*return ? isarray(o).
*0*perform ? validatetypedarray(o).
*0*perform ? validatetypedarray(o).
*0*perform ? validatetypedarray(o).
*0*perform ? validatetypedarray(o).
*0*perform ? validatetypedarray(o).
*0*perform ? validatetypedarray(o).
*0*perform ? validatetypedarray(o).
*0*perform ? validatetypedarray(o).
*0*perform ? validatetypedarray(newtypedarray).
*1*return ? serializejsonobject(value).
*0*perform ! asyncgeneratorresumenext(generator).
*0*perform ! asyncgeneratorresumenext(generator).
*1*perform ! asyncgeneratorresumenext(generator).

IN NNP VBZ RB VB DT JJ NN NNP NNP NNP JJ NN , VB DT NN NN .
34
*0*if r does not have a [[REGEXPMATCHER]] internal slot, throw a typeerror exception.
*0*if r does not have a [[REGEXPMATCHER]] internal slot, throw a typeerror exception.
*0*if o does not have a [[TYPEDARRAYNAME]] internal slot, throw a typeerror exception.
*0*if target does not have a [[TYPEDARRAYNAME]] internal slot, throw a typeerror exception.
*0*if target does not have a [[TYPEDARRAYNAME]] internal slot, throw a typeerror exception.
*0*if target does not have a [[TYPEDARRAYNAME]] internal slot, throw a typeerror exception.
*0*if o does not have a [[TYPEDARRAYNAME]] internal slot, throw a typeerror exception.
*0*if m does not have a [[MAPDATA]] internal slot, throw a typeerror exception.
*0*if m does not have a [[MAPDATA]] internal slot, throw a typeerror exception.
*0*if m does not have a [[MAPDATA]] internal slot, throw a typeerror exception.
*0*if m does not have a [[MAPDATA]] internal slot, throw a typeerror exception.
*0*if m does not have a [[MAPDATA]] internal slot, throw a typeerror exception.
*0*if m does not have a [[MAPDATA]] internal slot, throw a typeerror exception.
*0*if map does not have a [[MAPDATA]] internal slot, throw a typeerror exception.
*0*if s does not have a [[SETDATA]] internal slot, throw a typeerror exception.
*0*if s does not have a [[SETDATA]] internal slot, throw a typeerror exception.
*0*if s does not have a [[SETDATA]] internal slot, throw a typeerror exception.
*0*if s does not have a [[SETDATA]] internal slot, throw a typeerror exception.
*0*if s does not have a [[SETDATA]] internal slot, throw a typeerror exception.
*0*if set does not have a [[SETDATA]] internal slot, throw a typeerror exception.
*0*if m does not have a [[WEAKMAPDATA]] internal slot, throw a typeerror exception.
*0*if m does not have a [[WEAKMAPDATA]] internal slot, throw a typeerror exception.
*0*if m does not have a [[WEAKMAPDATA]] internal slot, throw a typeerror exception.
*0*if m does not have a [[WEAKMAPDATA]] internal slot, throw a typeerror exception.
*0*if s does not have a [[WEAKSETDATA]] internal slot, throw a typeerror exception.
*0*if s does not have a [[WEAKSETDATA]] internal slot, throw a typeerror exception.
*0*if s does not have a [[WEAKSETDATA]] internal slot, throw a typeerror exception.
*0*if o does not have an [[ARRAYBUFFERDATA]] internal slot, throw a typeerror exception.
*0*if new does not have an [[ARRAYBUFFERDATA]] internal slot, throw a typeerror exception.
*0*if o does not have an [[ARRAYBUFFERDATA]] internal slot, throw a typeerror exception.
*0*if new does not have an [[ARRAYBUFFERDATA]] internal slot, throw a typeerror exception.
*0*if buffer does not have an [[ARRAYBUFFERDATA]] internal slot, throw a typeerror exception.
*0*if typedarray does not have a [[TYPEDARRAYNAME]] internal slot, throw a typeerror exception.
*0*if generator does not have a [[GENERATORSTATE]] internal slot, throw a typeerror exception.

VB NNP VB DT JJ NN NN .
33
*0*let realmrec be a new realm record.
*0*let ctx be the running execution context.
*0*let callercontext be the running execution context.
*0*let newcontext be a new execution context.
*1*let newcontext be a new execution context.
*0*let callercontext be the running execution context.
*0*let callercontext be the running execution context.
*0*let callercontext be the running execution context.
*0*let calleecontext be the running execution context.
*0*let callercontext be the running execution context.
*1*let thisrealm be the current realm record.
*0*let realm be the current realm record.
*0*let leafcontext be the running execution context.
*0*let realm be the current realm record.
*0*let realm be the current realm record.
*0*let calleerealm be the current realm record.
*0*let ctx be the running execution context.
*0*let c be the active function object.
*0*let calleerealm be the current realm record.
*1*let newtarget be the active function object.
*0*let accumulatedresult be the empty string value.
*0*let c be the active function object.
*0*let c be the active function object.
*0*let gencontext be the running execution context.
*0*let methodcontext be the running execution context.
*0*let methodcontext be the running execution context.
*0*let gencontext be the running execution context.
*0*let gencontext be the running execution context.
*0*let gencontext be the running execution context.
*0*let callercontext be the running execution context.
*0*let gencontext be the running execution context.
*0*let c be the active function object.
*0*let runningcontext be the running execution context.

VB NNP VB DT NN IN NNP .
32
*0*let localenv be the lexicalenvironment of calleecontext.
*0*let constructorenv be the lexicalenvironment of calleecontext.
*0*let len be the expectedargumentcount of parameterlist.
*0*let env be the lexicalenvironment of calleecontext.
*0*let newlendesc be a copy of desc.
*0*let len be the length of str.
*0*let len be the length of str.
*0*let item be the labelleditem of stmt.
*0*let substmt be the statement of item.
*0*let body be the scriptbody of script.
*2*let k be the length of m.
*0*let size be the length of s.
*0*let size be the length of s.
*0*let size be the length of s.
*0*let len be the length of s.
*0*let searchlength be the length of searchstr.
*0*let len be the length of s.
*0*let searchlen be the length of searchstr.
*0*let len be the length of s.
*0*let searchlen be the length of searchstr.
*0*let len be the length of s.
*0*let searchlen be the length of searchstr.
*0*let stringlength be the length of s.
*0*let stringlength be the length of s.
*0*let len be the length of s.
*0*let s be the length of s.
*0*let len be the length of s.
*0*let searchlength be the length of searchstr.
*0*let len be the length of s.
*0*let len be the length of s.
*0*let size be the length of s.
*0*let asynccontext be a copy of runningcontext.

IN NNP VBZ VBN , RB
30
*0*if value is undefined, then
*2*if method is undefined, then
*0*if globalobj is undefined, then
*0*if current is undefined, then
*0*if desc is undefined, then
*0*if owndesc is undefined, then
*0*if trap is undefined, then
*0*if trap is undefined, then
*0*if trap is undefined, then
*0*if trap is undefined, then
*0*if trap is undefined, then
*0*if trapresultobj is undefined, then
*0*if trap is undefined, then
*0*if targetdesc is undefined, then
*0*if trap is undefined, then
*0*if trap is undefined, then
*0*if trap is undefined, then
*0*if trap is undefined, then
*0*if trap is undefined, then
*0*if trap is undefined, then
*0*if trap is undefined, then
*0*if namespace is undefined, then
*0*if separator is undefined, then
*1*if flags is undefined, then
*3*if newelement is undefined, then
*3*if newelement is undefined, then
*1*if strp is undefined, then
*0*if return is undefined, then
*0*if throw is undefined, then
*0*if handler is undefined, then

VB NNP VB DT JJ NN NN IN WDT DT NN VBD VBN .
29
*0*let envrec be the declarative environment record for which the method was invoked.
*0*let envrec be the declarative environment record for which the method was invoked.
*0*let envrec be the declarative environment record for which the method was invoked.
*0*let envrec be the declarative environment record for which the method was invoked.
*0*let envrec be the declarative environment record for which the method was invoked.
*0*let envrec be the declarative environment record for which the method was invoked.
*0*let envrec be the declarative environment record for which the method was invoked.
*0*let envrec be the object environment record for which the method was invoked.
*0*let envrec be the object environment record for which the method was invoked.
*0*let envrec be the object environment record for which the method was invoked.
*0*let envrec be the object environment record for which the method was invoked.
*0*let envrec be the object environment record for which the method was invoked.
*0*let envrec be the object environment record for which the method was invoked.
*0*let envrec be the object environment record for which the method was invoked.
*0*let envrec be the global environment record for which the method was invoked.
*0*let envrec be the global environment record for which the method was invoked.
*0*let envrec be the global environment record for which the method was invoked.
*0*let envrec be the global environment record for which the method was invoked.
*0*let envrec be the global environment record for which the method was invoked.
*0*let envrec be the global environment record for which the method was invoked.
*0*let envrec be the global environment record for which the method was invoked.
*0*let envrec be the global environment record for which the method was invoked.
*0*let envrec be the global environment record for which the method was invoked.
*0*let envrec be the global environment record for which the method was invoked.
*0*let envrec be the global environment record for which the method was invoked.
*0*let envrec be the global environment record for which the method was invoked.
*0*let envrec be the global environment record for which the method was invoked.
*0*let envrec be the global environment record for which the method was invoked.
*0*let envrec be the global environment record for which the method was invoked.

VB NNP VB . NNP ( NNP , `` NN '' ) .
28
*0*let hasvalue be ? hasproperty(obj, "value").
*1*let value be ? get(obj, "value").
*0*let p be ? get(c, "prototype").
*0*let c be ? get(o, "constructor").
*0*let return be ? getmethod(iterator, "return").
*0*let return be ? getmethod(iterator, "return").
*0*let proto be ? get(constructor, "prototype").
*0*let c be ? get(originalarray, "constructor").
*0*let trap be ? getmethod(handler, "getprototypeof").
*0*let trap be ? getmethod(handler, "setprototypeof").
*0*let trap be ? getmethod(handler, "getownpropertydescriptor").
*0*let trap be ? getmethod(handler, "defineproperty").
*0*let trap be ? getmethod(handler, "deleteproperty").
*0*let trap be ? getmethod(handler, "construct").
*0*let namelist be ? enumerableownpropertynames(obj, "value").
*0*let targethaslength be ? hasownproperty(target, "length").
*1*let targetlen be ? get(target, "length").
*0*let targetname be ? get(target, "name").
*0*let name be ? get(o, "name").
*0*let msg be ? get(o, "message").
*2*let patternconstructor be ? get(pattern, "constructor").
*1*let p be ? get(pattern, "source").
*0*let exec be ? get(r, "exec").
*0*let previouslastindex be ? get(rx, "lastindex").
*0*let currentlastindex be ? get(rx, "lastindex").
*0*let func be ? get(array, "join").
*1*let tojson be ? get(value, "tojson").
*1*let xconstructor be ? get(x, "constructor").

VB NNP VB . NNP . VB NNP NNP NNP NNP ( NNP ) .
27
*0*let desc be ? o.[[GETOWNPROPERTY]](p).
*2*let currentdesc be ? o.[[GETOWNPROPERTY]](k).
*1*let currentdesc be ? o.[[GETOWNPROPERTY]](k).
*2*let desc be ? o.[[GETOWNPROPERTY]](key).
*2*let desc be ? from.[[GETOWNPROPERTY]](nextkey).
*0*let existingprop be ? globalobject.[[GETOWNPROPERTY]](n).
*0*let existingprop be ? globalobject.[[GETOWNPROPERTY]](n).
*0*let existingprop be ? globalobject.[[GETOWNPROPERTY]](n).
*0*let current be ? o.[[GETOWNPROPERTY]](p).
*0*let hasown be ? o.[[GETOWNPROPERTY]](p).
*0*let desc be ? o.[[GETOWNPROPERTY]](p).
*0*let owndesc be ? o.[[GETOWNPROPERTY]](p).
*1*let existingdescriptor be ? receiver.[[GETOWNPROPERTY]](p).
*0*let desc be ? o.[[GETOWNPROPERTY]](p).
*0*let targetdesc be ? target.[[GETOWNPROPERTY]](p).
*0*let targetdesc be ? target.[[GETOWNPROPERTY]](p).
*1*let targetdesc be ? target.[[GETOWNPROPERTY]](p).
*0*let targetdesc be ? target.[[GETOWNPROPERTY]](p).
*0*let targetdesc be ? target.[[GETOWNPROPERTY]](p).
*0*let targetdesc be ? target.[[GETOWNPROPERTY]](p).
*1*let desc be ? target.[[GETOWNPROPERTY]](key).
*2*let desc be ? from.[[GETOWNPROPERTY]](nextkey).
*1*let propdesc be ? props.[[GETOWNPROPERTY]](nextkey).
*0*let desc be ? obj.[[GETOWNPROPERTY]](key).
*1*let desc be ? obj.[[GETOWNPROPERTY]](key).
*0*let desc be ? o.[[GETOWNPROPERTY]](p).
*0*let desc be ? target.[[GETOWNPROPERTY]](key).

NN NNP . VB JJ NNP NNP NNP .
27
*1*return obj.[[REALM]].
*0*return envrec.[[THISVALUE]].
*0*return envrec.[[GLOBALTHISVALUE]].
*0*return envrec.[[NEWTARGET]].
*0*return currentrealm.[[GLOBALOBJECT]].
*0*return ar.[[SIGNIFIER]].
*0*return ar.[[CANBLOCK]].
*0*return o.[[EXTENSIBLE]].
*2*return e.[[ARRAY]].
*0*return desc.[[ENUMERABLE]].
*1*return promisecapability.[[PROMISE]].
*0*return promisecapability.[[PROMISE]].
*1*return promisecapability.[[PROMISE]].
*1*return promisecapability.[[PROMISE]].
*1*return promisecapability.[[PROMISE]].
*0*return promisecapability.[[PROMISE]].
*1*return promisecapability.[[PROMISE]].
*1*return promisecapability.[[PROMISE]].
*1*return promisecapability.[[PROMISE]].
*0*return promisecapability.[[PROMISE]].
*1*return promisecapability.[[PROMISE]].
*0*return promisecapability.[[PROMISE]].
*2*return resultcapability.[[PROMISE]].
*2*return resultcapability.[[PROMISE]].
*0*return promisecapability.[[PROMISE]].
*0*return promisecapability.[[PROMISE]].
*0*return resultcapability.[[PROMISE]].

NN VBD .
27
*0*return undefined.
*0*return undefined.
*0*return undefined.
*1*return undefined.
*0*return undefined.
*0*return undefined.
*0*return undefined.
*0*return undefined.
*1*return undefined.
*1*return undefined.
*0*return undefined.
*0*return undefined.
*0*return undefined.
*0*return undefined.
*0*return undefined.
*0*return undefined.
*0*return undefined.
*0*return undefined.
*0*return undefined.
*0*return undefined.
*0*return undefined.
*0*return undefined.
*0*return undefined.
*3*return undefined.
*3*return undefined.
*0*return undefined.
*0*return undefined.

VB NNP VB NNP POS NN .
25
*1*let targeter be targetenv's environmentrecord.
*0*let envrec be lex's environmentrecord.
*1*let envrec be lex's environmentrecord.
*0*let currentrealm be ctx's realm.
*0*let callerrealm be callercontext's realm.
*0*let callerscriptormodule be callercontext's scriptormodule.
*2*let globalenvrec be globalenv's environmentrecord.
*0*let envrec be localenv's environmentrecord.
*0*let envrec be constructorenv's environmentrecord.
*0*let envrec be env's environmentrecord.
*1*let varenvrec be varenv's environmentrecord.
*0*let lexenvrec be lexenv's environmentrecord.
*0*let targetenvrec be targetenv's environmentrecord.
*0*let envrec be env's environmentrecord.
*1*let lastiterationenvrec be lastiterationenv's environmentrecord.
*1*let thisiterationenvrec be thisiterationenv's environmentrecord.
*1*let tdzenvrec be tdz's environmentrecord.
*0*let envrec be env's environmentrecord.
*0*let envrec be env's environmentrecord.
*0*let callerrealm be callercontext's realm.
*1*let varenv be ctx's variableenvironment.
*0*let lexenvrec be lexenv's environmentrecord.
*0*let varenvrec be varenv's environmentrecord.
*2*let thisenvrec be thislex's environmentrecord.
*0*let callerrealm be callercontext's realm.

IN NNP VBZ JJ , NN JJ .
23
*0*if desc is undefined, return false.
*0*if desc is undefined, return false.
*0*if desc is undefined, return false.
*0*if desc is undefined, return false.
*0*if status is false, return false.
*0*if status is true, return false.
*1*if o is null, return false.
*0*if done is true, return false.
*0*if foundbinding is false, return false.
*0*if existingprop is undefined, return false.
*0*if extensible is false, return false.
*1*if extensible is false, return false.
*0*if setter is undefined, return false.
*0*if booleantrapresult is false, return false.
*0*if booleantrapresult is false, return false.
*0*if booleantrapresult is false, return false.
*0*if booleantrapresult is false, return false.
*0*if oldvalue is true, return false.
*0*if hasname is true, return false.
*1*if v is null, return false.
*0*if desc is undefined, return false.
*2*if testresult is false, return false.
*0*if bufferdata is null, return false.

NN NNP ( JJ ) .
23
*0*return normalcompletion(empty).
*0*return normalcompletion(empty).
*0*return normalcompletion(empty).
*0*return normalcompletion(empty).
*1*return normalcompletion(empty).
*0*return normalcompletion(empty).
*0*return normalcompletion(empty).
*0*return normalcompletion(empty).
*0*return normalcompletion(empty).
*0*return normalcompletion(empty).
*0*return normalcompletion(empty).
*0*return normalcompletion(undefined).
*0*return normalcompletion(undefined).
*0*return normalcompletion(undefined).
*0*return normalcompletion(undefined).
*0*return normalcompletion(empty).
*1*return normalcompletion(undefined).
*0*return normalcompletion(empty).
*1*return normalcompletion(undefined).
*1*return normalcompletion(undefined).
*0*return normalcompletion(empty).
*0*return normalcompletion(undefined).
*0*return normalcompletion(undefined).

VB NNP VB . NNP . VB JJ NNP NNP NNP ( ) .
21
*0*let status be ? o.[[PREVENTEXTENSIONS]]().
*0*let keys be ? o.[[OWNPROPERTYKEYS]]().
*0*let keys be ? o.[[OWNPROPERTYKEYS]]().
*0*let ownkeys be ? o.[[OWNPROPERTYKEYS]]().
*0*let keys be ? from.[[OWNPROPERTYKEYS]]().
*0*let parent be ? o.[[GETPROTOTYPEOF]]().
*1*let parent be ? o.[[GETPROTOTYPEOF]]().
*1*let parent be ? o.[[GETPROTOTYPEOF]]().
*0*let proto be ? targetfunction.[[GETPROTOTYPEOF]]().
*0*let current be ? o.[[GETPROTOTYPEOF]]().
*0*let targetproto be ? target.[[GETPROTOTYPEOF]]().
*0*let targetproto be ? target.[[GETPROTOTYPEOF]]().
*0*let targetkeys be ? target.[[OWNPROPERTYKEYS]]().
*0*let superconstructor be ! activefunction.[[GETPROTOTYPEOF]]().
*2*let keys be ? from.[[OWNPROPERTYKEYS]]().
*0*let keys be ? props.[[OWNPROPERTYKEYS]]().
*0*let ownkeys be ? obj.[[OWNPROPERTYKEYS]]().
*0*let keys be ? obj.[[OWNPROPERTYKEYS]]().
*0*let status be ? o.[[PREVENTEXTENSIONS]]().
*1*let v be ? v.[[GETPROTOTYPEOF]]().
*0*let keys be ? target.[[OWNPROPERTYKEYS]]().

NN NNP ( NNP , NNP ) .
20
*0*return samevaluenonnumber(x, y).
*0*return samevaluenonnumber(x, y).
*1*perform envrec.initializebinding(n, v).
*0*return dclrec.createmutablebinding(n, d).
*0*return dclrec.createimmutablebinding(n, s).
*1*return dclrec.initializebinding(n, v).
*1*return dclrec.getbindingvalue(n, s).
*0*return objectcreate(proto, internalslotslist).
*3*call varenvrec.initializebinding(n, initialvalue).
*1*return get(map, p).
*0*return ordinarygetownproperty(o, p).
*1*perform env.initializebinding(name, value).
*2*perform envrec.initializebinding(fn, fo).
*2*perform thisiterationenvrec.initializebinding(bn, lastvalue).
*3*call envrec.initializebinding(dn, fo).
*0*return samevalue(value1, value2).
*0*return utf16decode(first, second).
*0*perform addwaiter(wl, w).
*1*perform removewaiter(wl, w).
*1*perform wakewaiter(wl, w).

VB NNP VB NNP ( NNP , NNP ) .
20
*0*let newglobalenv be newglobalenvironment(globalobj, thisvalue).
*0*let result be ordinarycallevaluatebody(f, argumentslist).
*0*let localenv be newfunctionenvironment(f, newtarget).
*0*let calleecontext be prepareforordinarycall(f, newtarget).
*0*let result be ordinarycallevaluatebody(f, argumentslist).
*0*let desc be ordinarygetownproperty(s, p).
*0*let desc be ordinarygetownproperty(args, p).
*0*let ismapped be hasownproperty(map, p).
*3*let g be makearggetter(name, env).
*3*let p be makeargsetter(name, env).
*3*let status be initializereferencedbinding(lhsref, nextvalue).
*3*let status be putvalue(lhsref, nextvalue).
*0*let result be globaldeclarationinstantiation(scriptbody, globalenv).
*3*let v be utf16decode(c, kchar).
*1*let r be matcher(s, lastindex).
*0*let wl be getwaiterlist(block, indexedposition).
*0*let wl be getwaiterlist(block, indexedposition).
*0*let s be removewaiters(wl, c).
*0*let nextresult be iteratornext(synciteratorrecord, value).
*2*let bytes be valueofreadevent(execution, w).

VB NNS VB DT NN WDT VBZ NNP . VB JJ NNP NNP NNP .
20
*0*let entries be the list that is m.[[MAPDATA]].
*0*let entries be the list that is m.[[MAPDATA]].
*0*let entries be the list that is m.[[MAPDATA]].
*0*let entries be the list that is m.[[MAPDATA]].
*0*let entries be the list that is m.[[MAPDATA]].
*0*let entries be the list that is m.[[MAPDATA]].
*0*let entries be the list that is m.[[MAPDATA]].
*0*let entries be the list that is s.[[SETDATA]].
*0*let entries be the list that is s.[[SETDATA]].
*0*let entries be the list that is s.[[SETDATA]].
*0*let entries be the list that is s.[[SETDATA]].
*0*let entries be the list that is s.[[SETDATA]].
*0*let entries be the list that is s.[[SETDATA]].
*0*let entries be the list that is m.[[WEAKMAPDATA]].
*0*let entries be the list that is m.[[WEAKMAPDATA]].
*0*let entries be the list that is m.[[WEAKMAPDATA]].
*0*let entries be the list that is m.[[WEAKMAPDATA]].
*0*let entries be the list that is s.[[WEAKSETDATA]].
*0*let entries be the list that is s.[[WEAKSETDATA]].
*0*let entries be the list that is s.[[WEAKSETDATA]].

IN DT NN NNP IN NNP , VBP
19
*0*for each index i of db, do
*1*for each element k of keys, do
*1*for each element k of keys, do
*0*for each element k of keys, do
*0*for each element e of elements, do
*0*for each string paramname in parameternames, do
*0*for each element d in lexdeclarations, do
*0*for each element key of targetkeys, do
*0*for each element e of templateregistry, do
*0*for each element d in declarations, do
*1*for each element bn of periterationbindings, do
*1*for each string name in tdznames, do
*0*for each element d in lexdeclarations, do
*0*for each element d in vardeclarations, do
*0*for each element d in lexdeclarations, do
*0*for each element d in lexdeclarations, do
*0*for each element e of kept, do
*2*for each string p in keys, do
*0*for each element p of k, do

VB NNP VB JJ .
19
*1*let excluded be false.
*0*let done be false.
*0*let argumentsobjectneeded be true.
*1*let ismapped be false.
*1*let settingconfigfalse be true.
*1*let done be false.
*1*let done be false.
*1*let infunction be true.
*1*let infunction be false.
*1*let inmethod be false.
*1*let inderivedconstructor be false.
*0*let stripprefix be true.
*0*let matchsucceeded be false.
*0*let done be false.
*1*let mapping be true.
*1*let kpresent be false.
*1*let kpresent be false.
*1*let mapping be true.
*0*let next be true.

IN NNP VBZ JJ , VB NNS .
19
*0*if z is empty, return nan.
*0*if x is nan, return nan.
*0*if t is nan, return nan.
*0*if t is nan, return nan.
*0*if t is nan, return nan.
*0*if t is nan, return nan.
*0*if t is nan, return nan.
*0*if t is nan, return nan.
*0*if t is nan, return nan.
*0*if t is nan, return nan.
*0*if t is nan, return nan.
*0*if t is nan, return nan.
*0*if t is nan, return nan.
*0*if t is nan, return nan.
*0*if t is nan, return nan.
*0*if t is nan, return nan.
*0*if t is nan, return nan.
*0*if t is nan, return nan.
*0*if t is nan, return nan.

NN : NNP ( NNP ) VBZ NN .
18
*0*assert: type(v) is reference.
*0*assert: type(v) is reference.
*0*assert: type(v) is reference.
*0*assert: type(v) is reference.
*0*assert: type(v) is reference.
*0*assert: type(v) is reference.
*0*assert: type(v) is reference.
*0*assert: type(v) is reference.
*0*assert: type(length) is number.
*0*assert: type(index) is number.
*0*assert: type(index) is number.
*0*assert: type(sym) is symbol.
*0*assert: type(tv) is number.
*0*assert: type(tv) is number.
*0*assert: type(tv) is number.
*0*assert: type(tv) is number.
*0*assert: type(value) is number.
*0*assert: type(value) is number.

VB NNP VB NNP ( NNP , NNP , NNP ) .
18
*0*let f be functionallocate(prototype, strict, allockind).
*0*let valid be iscompatiblepropertydescriptor(extensibletarget, resultdesc, targetdesc).
*0*let result be call(func, thisvalue, arglist).
*0*let s be parsescript(sourcetext, realm, hostdefined).
*0*let m be parsemodule(sourcetext, realm, hostdefined).
*0*let f be functionallocate(proto, strict, kind).
*1*let e be splitmatch(s, q, r).
*4*let nextindex be advancestringindex(s, thisindex, fullunicode).
*4*let nextindex be advancestringindex(s, thisindex, fullunicode).
*1*let definestatus be createdataproperty(array, pk, itemk).
*2*let definestatus be createdatapropertyorthrow(a, pk, mappedvalue).
*0*let rawbytes be numbertorawbytes(type, value, islittleendian).
*0*let rawbytes be numbertorawbytes(type, value, islittleendian).
*0*let expectedbytes be numbertorawbytes(elementtype, expected, islittleendian).
*0*let awoken be suspend(wl, w, t).
*1*let status be createdataproperty(root, rootname, unfiltered).
*0*let result be performpromiseall(iteratorrecord, c, promisecapability).
*0*let result be performpromiserace(iteratorrecord, c, promisecapability).

NN . NNP ( NNP , NNP , NNP , JJ ) .
18
*3*perform ? set(to, nextkey, propvalue, true).
*2*perform ? set(o, tokey, fromval, true).
*1*perform ? set(o, pk, value, true).
*2*perform ? set(o, lowerp, uppervalue, true).
*2*perform ? set(o, upperp, lowervalue, true).
*2*perform ? set(o, lowerp, uppervalue, true).
*2*perform ? set(o, upperp, lowervalue, true).
*2*perform ? set(o, to, fromval, true).
*3*perform ? set(o, to, fromvalue, true).
*3*perform ? set(o, to, fromvalue, true).
*3*perform ? set(o, to, fromvalue, true).
*2*perform ? set(targetobj, pk, mappedvalue, true).
*1*perform ? set(targetobj, pk, mappedvalue, true).
*1*perform ? set(newobj, pk, kvalue, true).
*1*perform ! set(o, pk, value, true).
*1*perform ? set(a, pk, mappedvalue, true).
*2*perform ? set(o, pk, kvalue, true).
*1*perform ? set(o, pk, kvalue, true).

NN ,
17
*0*repeat,
*0*repeat,
*0*repeat,
*0*repeat,
*0*repeat,
*0*repeat,
*0*repeat,
*0*repeat,
*0*repeat,
*1*repeat,
*1*repeat,
*0*repeat,
*0*repeat,
*0*repeat,
*0*repeat,
*0*repeat,
*0*repeat,

NN : NN VBZ DT NN NN .
16
*0*assert: completion is a completion record.
*0*assert: completion is a completion record.
*0*assert: binding is a resolvedbinding record.
*0*assert: module is a module record.
*1*assert: resolution is a resolvedbinding record.
*0*assert: generator is an asyncgenerator instance.
*0*assert: generator is an asyncgenerator instance.
*0*assert: generator is an asyncgenerator instance.
*0*assert: generator is an asyncgenerator instance.
*0*assert: completion is a completion record.
*0*assert: reaction is a promisereaction record.
*0*assert: constructor is a constructor function.
*0*assert: resultcapability is a promisecapability record.
*0*assert: constructor is a constructor function.
*0*assert: resultcapability is a promisecapability record.
*0*assert: resultcapability is a promisecapability record.

VBN NNP . VB JJ NNP NNP NNP TO VB .
16
*0*set realmrec.[[GLOBALOBJECT]] to undefined.
*0*set realmrec.[[GLOBALENV]] to undefined.
*0*set func.[[SCRIPTORMODULE]] to null.
*0*set obj.[[PARAMETERMAP]] to undefined.
*1*set o.[[ITERATEDSTRING]] to undefined.
*1*set o.[[ITERATEDOBJECT]] to undefined.
*1*set p.[[KEY]] to empty.
*2*set p.[[KEY]] to empty.
*0*set o.[[MAP]] to undefined.
*0*set o.[[ITERATEDSET]] to undefined.
*2*set p.[[KEY]] to empty.
*0*set arraybuffer.[[ARRAYBUFFERDATA]] to null.
*0*set promise.[[PROMISEFULFILLREACTIONS]] to undefined.
*0*set promise.[[PROMISEREJECTREACTIONS]] to undefined.
*0*set promise.[[PROMISEFULFILLREACTIONS]] to undefined.
*0*set promise.[[PROMISEREJECTREACTIONS]] to undefined.

VB NNP VB DT JJ NN .
16
*0*let intrinsics be a new record.
*0*let r be the empty string.
*0*let r be the empty string.
*0*let reserveduricomponentset be the empty string.
*0*let p be the empty string.
*0*let s be the empty string.
*0*let s be the empty string.
*0*let s be the empty string.
*0*let u be an empty set.
*0*let r be the empty string.
*0*let r be the empty string.
*1*let rootname be the empty string.
*0*let indent be the empty string.
*0*let events be an empty set.
*0*let events be an empty set.
*0*let events be an empty set.

VB NNP VB NNP NNP NNP .
16
*0*let tailpos be position + matchlength.
*1*let f be e + direction.
*2*let nextsourceposition be position + matchlength.
*1*let from be from + direction.
*1*let to be to + direction.
*1*let k be len + n.
*1*let k be len + n.
*1*let k be len + n.
*1*let countbytes be count × elementsize.
*2*let frombyteindex be frombyteindex + direction.
*2*let tobyteindex be tobyteindex + direction.
*0*let bytelength be elementsize × length.
*0*let bytelength be elementsize × elementlength.
*1*let newbytelength be newlength × elementsize.
*0*let bufferindex be getindex + viewoffset.
*0*let bufferindex be getindex + viewoffset.

NN . NNP ( NNP , `` NN '' , NNP , JJ ) .
16
*1*perform ? set(r, "lastindex", e, true).
*4*perform ? set(rx, "lastindex", nextindex, true).
*4*perform ? set(rx, "lastindex", nextindex, true).
*1*perform ? set(rx, "lastindex", previouslastindex, true).
*1*perform ? set(splitter, "lastindex", q, true).
*0*perform ! set(array, "length", intlen, true).
*3*perform ? set(a, "length", k, true).
*0*perform ? set(a, "length", len, true).
*0*perform ? set(a, "length", len, true).
*0*perform ? set(a, "length", n, true).
*1*perform ? set(o, "length", newlen, true).
*0*perform ? set(o, "length", len, true).
*0*perform ? set(o, "length", len-1, true).
*0*perform ? set(a, "length", n, true).
*0*perform ? set(a, "length", actualdeletecount, true).
*0*perform ? set(o, "length", len+argcount, true).

NNP ( NNP , NNP ) .
16
*0*ifabruptrejectpromise(nextresult, promisecapability).
*0*ifabruptrejectpromise(nextdone, promisecapability).
*0*ifabruptrejectpromise(nextvalue, promisecapability).
*0*ifabruptrejectpromise(return, promisecapability).
*0*ifabruptrejectpromise(returnresult, promisecapability).
*0*ifabruptrejectpromise(returndone, promisecapability).
*0*ifabruptrejectpromise(returnvalue, promisecapability).
*0*ifabruptrejectpromise(throw, promisecapability).
*0*ifabruptrejectpromise(throwresult, promisecapability).
*0*ifabruptrejectpromise(throwdone, promisecapability).
*0*ifabruptrejectpromise(throwvalue, promisecapability).
*0*ifabruptrejectpromise(value, capability).
*0*ifabruptrejectpromise(iteratorrecord, promisecapability).
*1*ifabruptrejectpromise(result, promisecapability).
*0*ifabruptrejectpromise(iteratorrecord, promisecapability).
*1*ifabruptrejectpromise(result, promisecapability).

IN NNP ( NNP ) VBZ RB JJ , NN JJ .
15
*0*if type(argument) is not object, return false.
*0*if type(argument) is not object, return false.
*0*if type(argument) is not object, return false.
*0*if type(argument) is not object, return false.
*0*if type(o) is not object, return false.
*1*if type(receiver) is not object, return false.
*0*if type(o) is not object, return false.
*0*if type(v) is not object, return false.
*0*if type(o) is not object, return false.
*0*if type(key) is not object, return false.
*0*if type(key) is not object, return false.
*0*if type(value) is not object, return false.
*0*if type(value) is not object, return false.
*0*if type(arg) is not object, return false.
*0*if type(x) is not object, return false.

VB NNP VB DT NNS IN NNP .
15
*0*let varnames be the vardeclarednames of code.
*0*let vardeclarations be the varscopeddeclarations of code.
*0*let lexicalnames be the lexicallydeclarednames of code.
*0*let lexdeclarations be the lexicallyscopeddeclarations of code.
*0*let declarations be the lexicallyscopeddeclarations of code.
*0*let lexnames be the lexicallydeclarednames of script.
*0*let varnames be the vardeclarednames of script.
*0*let vardeclarations be the varscopeddeclarations of script.
*0*let lexdeclarations be the lexicallyscopeddeclarations of script.
*0*let requestedmodules be the modulerequests of body.
*0*let vardeclarations be the varscopeddeclarations of code.
*0*let lexdeclarations be the lexicallyscopeddeclarations of code.
*0*let varnames be the vardeclarednames of body.
*0*let vardeclarations be the varscopeddeclarations of body.
*0*let lexdeclarations be the lexicallyscopeddeclarations of body.

VB DT NNP NNP NNP NNP NNP JJ NN IN DT NN NN TO NNP .
15
*0*set the [[DATEVALUE]] internal slot of this date object to u.
*0*set the [[DATEVALUE]] internal slot of this date object to u.
*0*set the [[DATEVALUE]] internal slot of this date object to u.
*0*set the [[DATEVALUE]] internal slot of this date object to u.
*0*set the [[DATEVALUE]] internal slot of this date object to u.
*0*set the [[DATEVALUE]] internal slot of this date object to u.
*0*set the [[DATEVALUE]] internal slot of this date object to u.
*0*set the [[DATEVALUE]] internal slot of this date object to v.
*0*set the [[DATEVALUE]] internal slot of this date object to v.
*0*set the [[DATEVALUE]] internal slot of this date object to v.
*0*set the [[DATEVALUE]] internal slot of this date object to v.
*0*set the [[DATEVALUE]] internal slot of this date object to v.
*0*set the [[DATEVALUE]] internal slot of this date object to v.
*0*set the [[DATEVALUE]] internal slot of this date object to v.
*0*set the [[DATEVALUE]] internal slot of this date object to v.

IN NNP CC NN : CD , VB NNP VB VBN ( ( NNP NNP NNP ) , CD ) : JJ VB NNP VB VBN ( NNP , NNP ) .
15
*0*if relativetarget &lt; 0, let to be max((len + relativetarget), 0); else let to be min(relativetarget, len).
*0*if relativeend &lt; 0, let final be max((len + relativeend), 0); else let final be min(relativeend, len).
*0*if relativeend &lt; 0, let final be max((len + relativeend), 0); else let final be min(relativeend, len).
*0*if relativeend &lt; 0, let final be max((len + relativeend), 0); else let final be min(relativeend, len).
*0*if relativestart &lt; 0, let actualstart be max((len + relativestart), 0); else let actualstart be min(relativestart, len).
*0*if relativetarget &lt; 0, let to be max((len + relativetarget), 0); else let to be min(relativetarget, len).
*0*if relativeend &lt; 0, let final be max((len + relativeend), 0); else let final be min(relativeend, len).
*0*if relativeend &lt; 0, let final be max((len + relativeend), 0); else let final be min(relativeend, len).
*0*if relativeend &lt; 0, let final be max((len + relativeend), 0); else let final be min(relativeend, len).
*0*if relativebegin &lt; 0, let beginindex be max((srclength + relativebegin), 0); else let beginindex be min(relativebegin, srclength).
*0*if relativeend &lt; 0, let endindex be max((srclength + relativeend), 0); else let endindex be min(relativeend, srclength).
*0*if relativestart &lt; 0, let first be max((len + relativestart), 0); else let first be min(relativestart, len).
*0*if relativeend &lt; 0, let final be max((len + relativeend), 0); else let final be min(relativeend, len).
*0*if relativestart &lt; 0, let first be max((len + relativestart), 0); else let first be min(relativestart, len).
*0*if relativeend &lt; 0, let final be max((len + relativeend), 0); else let final be min(relativeend, len).

VB NNP VB DT NN IN NNS IN NNP .
14
*0*let fromsize be the number of bytes in fromblock.
*0*let tosize be the number of bytes in toblock.
*0*let len be the number of elements of list.
*0*let len be the number of elements in argumentslist.
*0*let len be the number of elements in argumentslist.
*0*let argcount be the number of elements in args.
*0*let length be the number of elements in codeunits.
*0*let numberofsubstitutions be the number of elements in substitutions.
*0*let m be the number of elements in captures.
*1*let len be the number of elements in s.
*0*let argcount be the number of elements in items.
*0*let itemcount be the number of elements in items.
*1*let len be the number of elements in values.
*1*let len be the number of elements in values.

VB NNP VB DT VBG NN IN NNP . VB JJ NNP NNP NNP .
14
*0*let str be the string value of o.[[STRINGDATA]].
*0*let str be the string value of s.[[STRINGDATA]].
*0*let arraytypename be the string value of o.[[TYPEDARRAYNAME]].
*0*let arraytypename be the string value of o.[[TYPEDARRAYNAME]].
*1*let typedarrayname be the string value of o.[[TYPEDARRAYNAME]].
*0*let targetname be the string value of target.[[TYPEDARRAYNAME]].
*0*let targetname be the string value of target.[[TYPEDARRAYNAME]].
*0*let targetname be the string value of target.[[TYPEDARRAYNAME]].
*0*let srcname be the string value of typedarray.[[TYPEDARRAYNAME]].
*0*let srcname be the string value of o.[[TYPEDARRAYNAME]].
*0*let targetname be the string value of a.[[TYPEDARRAYNAME]].
*0*let constructorname be the string value of o.[[TYPEDARRAYNAME]].
*0*let constructorname be the string value of o.[[TYPEDARRAYNAME]].
*0*let srcname be the string value of srcarray.[[TYPEDARRAYNAME]].

VB NNP VB DT VBG NN IN DT NN NN NN IN JJ CD IN NNP .
14
*0*let elementtype be the string value of the element type value in table 56 for arraytypename.
*0*let elementtype be the string value of the element type value in table 56 for arraytypename.
*0*let targettype be the string value of the element type value in table 56 for targetname.
*0*let targettype be the string value of the element type value in table 56 for targetname.
*0*let targettype be the string value of the element type value in table 56 for targetname.
*0*let srctype be the string value of the element type value in table 56 for srcname.
*0*let srctype be the string value of the element type value in table 56 for srcname.
*0*let targettype be the string value of the element type value in table 56 for targetname.
*0*let elementtype be the string value of the element type value in table 56 for constructorname.
*0*let srctype be the string value of the element type value in table 56 for srcname.
*0*let elementtype be the string value of the element type value in table 56 for arraytypename.
*0*let elementtype be the string value of the element type value in table 56 for arraytypename.
*0*let elementtype be the string value of the element type value in table 56 for arraytypename.
*0*let elementtype be the string value of the element type value in table 56 for arraytypename.

VB NNP VB VBN .
14
*1*let thisvalue be undefined.
*0*let v be undefined.
*0*let v be undefined.
*1*let x be -x.
*2*let e be -e.
*1*let x be -x.
*1*let x be -x.
*3*let e be -e.
*1*let groups be undefined.
*1*let direction be -1.
*0*let accumulator be undefined.
*0*let accumulator be undefined.
*2*let direction be -1.
*4*let item be undefined.

IN DT VBZ JJ , VB DT NN NN .
14
*0*if newtarget is undefined, throw a typeerror exception.
*0*if newtarget is undefined, throw a typeerror exception.
*0*if newtarget is undefined, throw a typeerror exception.
*0*if newtarget is undefined, throw a typeerror exception.
*0*if newtarget is undefined, throw a typeerror exception.
*0*if newtarget is undefined, throw a typeerror exception.
*0*if newtarget is undefined, throw a typeerror exception.
*0*if newtarget is undefined, throw a typeerror exception.
*0*if newtarget is undefined, throw a typeerror exception.
*0*if newtarget is undefined, throw a typeerror exception.
*0*if newtarget is undefined, throw a typeerror exception.
*0*if newtarget is undefined, throw a typeerror exception.
*0*if newtarget is undefined, throw a typeerror exception.
*0*if newtarget is undefined, throw a typeerror exception.

NN : NNP ( NNP ) VBZ VBG .
13
*0*assert: type(argument) is string.
*0*assert: type(p) is string.
*0*assert: type(q) is string.
*0*assert: type(value) is string.
*0*assert: type(name) is string.
*0*assert: type(desc) is string.
*0*assert: type(matched) is string.
*0*assert: type(str) is string.
*0*assert: type(replacement) is string.
*0*assert: type(r) is string.
*0*assert: type(s) is string.
*0*assert: type(s) is string.
*0*assert: type(s) is string.

NN NNP TO NNP .
13
*1*append n to vardeclarednames.
*1*append n to vardeclarednames.
*3*append n to instantiatedvarnames.
*3*append n to instantiatedvarnames.
*3*append fn to declaredfunctionnames.
*5*append vn to declaredvarnames.
*0*append module to stack.
*3*append dn to declaredvarnames.
*0*append module to stack.
*3*append fn to declaredfunctionnames.
*5*append vn to declaredvarnames.
*2*append strp to partial.
*1*append byte to bytesread.

VB DT NN IN NNP TO NNP .
13
*0*set the realm of newcontext to realm.
*0*set the function of calleecontext to f.
*0*set the realm of calleecontext to calleerealm.
*0*set the lexicalenvironment of calleecontext to localenv.
*0*set the variableenvironment of calleecontext to localenv.
*1*set the variableenvironment of calleecontext to varenv.
*0*set the lexicalenvironment of calleecontext to lexenv.
*0*set the function of calleecontext to f.
*0*set the realm of calleecontext to calleerealm.
*0*set the scriptormodule of scriptcxt to scriptrecord.
*0*set the variableenvironment of scriptcxt to globalenv.
*0*set the lexicalenvironment of scriptcxt to globalenv.
*0*set the scriptormodule of modulecxt to module.

VB NNP VB DT NN NN IN DT NN NN NN VBN IN JJ CD IN NNP .
13
*0*let elementsize be the number value of the element size value specified in table 56 for arraytypename.
*0*let elementsize be the number value of the element size value specified in table 56 for arraytypename.
*1*let elementsize be the number value of the element size value specified in table 56 for typedarrayname.
*0*let targetelementsize be the number value of the element size value specified in table 56 for targetname.
*0*let targetelementsize be the number value of the element size value specified in table 56 for targetname.
*0*let targetelementsize be the number value of the element size value specified in table 56 for targetname.
*0*let srcelementsize be the number value of the element size value specified in table 56 for srcname.
*1*let elementsize be the number value of the element size value specified in table 56 for srctype.
*0*let elementsize be the number value of the element size value specified in table 56 for constructorname.
*0*let elementsize be the number value of the element size value specified in table 56 for arraytypename.
*0*let elementsize be the number value of the element size value specified in table 56 for arraytypename.
*0*let elementsize be the number value of the element size value specified in table 56 for arraytypename.
*0*let elementsize be the number value of the element size value specified in table 56 for arraytypename.

IN NNP VBZ DT JJ NN , RB
13
*2*if lhsref is an abrupt completion, then
*1*if status is an abrupt completion, then
*3*if matchstr is the empty string, then
*3*if matchstr is the empty string, then
*1*if gap is the empty string, then
*1*if gap is the empty string, then
*0*if completion is an abrupt completion, then
*0*if handlerresult is an abrupt completion, then
*0*if thencallresult is an abrupt completion, then
*0*if completion is an abrupt completion, then
*0*if result is an abrupt completion, then
*0*if result is an abrupt completion, then
*1*if w is a writesharedmemory event, then

VB NNP VB . NNP ( VBG ) .
13
*0*let isregexp be ? isregexp(searchstring).
*0*let searchstr be ? tostring(searchstring).
*0*let isregexp be ? isregexp(searchstring).
*0*let searchstr be ? tostring(searchstring).
*0*let searchstr be ? tostring(searchstring).
*0*let searchstr be ? tostring(searchstring).
*0*let isregexp be ? isregexp(searchstring).
*0*let searchstr be ? tostring(searchstring).
*0*let s be ? tostring(string).
*0*let s be ? tostring(string).
*0*let s be ? tostring(string).
*0*let s be ? tostring(string).
*0*let s be ? tostring(string).

NN . NNP ( NNP , . NNP ( NNP ) , NNP ) .
13
*3*perform ! createdataproperty(a, ! tostring(lengtha), t).
*0*perform ! createdataproperty(a, ! tostring(lengtha), t).
*1*perform ! createdataproperty(a, ! tostring(i), capturedvalue).
*3*perform ! createdataproperty(a, ! tostring(lengtha), t).
*4*perform ! createdataproperty(a, ! tostring(lengtha), nextcapture).
*0*perform ! createdataproperty(a, ! tostring(lengtha), t).
*4*perform ? createdatapropertyorthrow(a, ! tostring(n), subelement).
*2*perform ? createdatapropertyorthrow(a, ! tostring(n), e).
*3*perform ? createdatapropertyorthrow(a, ! tostring(to), kvalue).
*2*perform ? createdatapropertyorthrow(a, ! tostring(n), kvalue).
*2*perform ? createdatapropertyorthrow(a, ! tostring(k), fromvalue).
*2*perform ! set(a, ! tostring(n), kvalue).
*4*perform ? createdataproperty(val, ! tostring(i), newelement).

IN NNP VBZ JJ , VB NNP VB NNP : JJ VB NNP VB VBN .
13
*1*if thisarg is present, let t be thisarg; else let t be undefined.
*0*if thisarg is present, let t be thisarg; else let t be undefined.
*0*if thisarg is present, let t be thisarg; else let t be undefined.
*0*if thisarg is present, let t be thisarg; else let t be undefined.
*0*if thisarg is present, let t be thisarg; else let t be undefined.
*0*if thisarg is present, let t be thisarg; else let t be undefined.
*0*if thisarg is present, let t be thisarg; else let t be undefined.
*0*if thisarg is present, let t be thisarg; else let t be undefined.
*0*if thisarg is present, let t be thisarg; else let t be undefined.
*0*if thisarg is present, let t be thisarg; else let t be undefined.
*0*if thisarg is present, let t be thisarg; else let t be undefined.
*0*if thisarg is present, let t be thisarg; else let t be undefined.
*0*if thisarg is present, let t be thisarg; else let t be undefined.

NN . NNP ( NNP . VB JJ NNP NNP NNP , VBD , NNP NNP NNP ) .
13
*1*perform ! call(promisecapability.[[REJECT]], undefined, « invaliditeratorerror »).
*0*perform ! call(valuewrappercapability.[[RESOLVE]], undefined, « nextvalue »).
*1*perform ! call(promisecapability.[[REJECT]], undefined, « invaliditeratorerror »).
*1*perform ! call(promisecapability.[[RESOLVE]], undefined, « iterresult »).
*0*perform ! call(valuewrappercapability.[[RESOLVE]], undefined, « returnvalue »).
*1*perform ! call(promisecapability.[[REJECT]], undefined, « invaliditeratorerror »).
*1*perform ! call(promisecapability.[[REJECT]], undefined, « value »).
*0*perform ! call(valuewrappercapability.[[RESOLVE]], undefined, « throwvalue »).
*0*perform ! call(promisecapability.[[RESOLVE]], undefined, « iteratorresult »).
*1*perform ! call(promisecapability.[[REJECT]], undefined, « badgeneratorerror »).
*3*perform ? call(resultcapability.[[RESOLVE]], undefined, « valuesarray »).
*0*perform ? call(promisecapability.[[REJECT]], undefined, « r »).
*0*perform ? call(promisecapability.[[RESOLVE]], undefined, « x »).

NNP ( NNP ) .
12
*0*returnifabrupt(v).
*0*returnifabrupt(v).
*0*returnifabrupt(w).
*0*returnifabrupt(v).
*0*returnifabrupt(w).
*0*returnifabrupt(result).
*1*returnifabrupt(arglist).
*0*returnifabrupt(arglist).
*1*returnifabrupt(next).
*1*returnifabrupt(nextvalue).
*1*returnifabrupt(next).
*1*returnifabrupt(nextvalue).

VB NNP VB . NNP ( NNP , `` VB '' ) .
12
*0*let hasget be ? hasproperty(obj, "get").
*1*let getter be ? get(obj, "get").
*0*let hasset be ? hasproperty(obj, "set").
*1*let setter be ? get(obj, "set").
*0*let trap be ? getmethod(handler, "get").
*0*let trap be ? getmethod(handler, "set").
*0*let trap be ? getmethod(handler, "apply").
*0*let namelist be ? enumerableownpropertynames(obj, "key+value").
*0*let adder be ? get(map, "set").
*0*let adder be ? get(set, "add").
*0*let adder be ? get(map, "set").
*0*let adder be ? get(set, "add").

IN NNP VBZ JJ , JJ NNP .
12
*0*if c is undefined, return defaultconstructor.
*0*if extensibletarget is true, return handlerproto.
*0*if extensibletarget is true, return trapresult.
*0*if ignorecase is false, return ch.
*0*if unicode is false, return index+1.
*1*if testresult is true, return k.
*2*if same is true, return k.
*2*if same is true, return k.
*1*if next is false, return map.
*1*if next is false, return set.
*1*if next is false, return map.
*1*if next is false, return set.

NN . NNP ( NNP , RB ) .
12
*2*perform ! envrec.createmutablebinding(paramname, false).
*3*perform ! envrec.createmutablebinding(n, false).
*3*perform ! varenvrec.createmutablebinding(n, false).
*3*perform ! lexenvrec.createmutablebinding(dn, false).
*3*perform ! envrec.createmutablebinding(dn, false).
*2*perform ! thisiterationenvrec.createmutablebinding(bn, false).
*2*perform ! tdzenvrec.createmutablebinding(name, false).
*3*perform ? envrec.createmutablebinding(dn, false).
*1*perform ? envrec.createglobalvarbinding(vn, false).
*3*perform ! envrec.createmutablebinding(dn, false).
*3*perform ! envrec.createmutablebinding(dn, false).
*3*perform ? lexenvrec.createmutablebinding(dn, false).

VB NNP VB NNP NNP NNP NNP .
12
*1*let val be argumentslist[index].
*1*let val be argumentslist[index].
*1*let name be parameternames[index].
*2*let nextarg be args[k].
*1*let bodytext be args[k].
*1*let next be codeunits[nextindex].
*1*let next be codepoints[nextindex].
*1*let s be cap[n].
*1*let itemk be items[k].
*1*let kvalue be items[k].
*1*let kvalue be items[k].
*1*let e be entries[index].

VB NNP VB DT NN IN VBG NN .
12
*0*let expr be the result of evaluating unaryexpression.
*0*let expr be the result of evaluating unaryexpression.
*0*let lref be the result of evaluating additiveexpression.
*0*let rref be the result of evaluating multiplicativeexpression.
*0*let lref be the result of evaluating additiveexpression.
*0*let rref be the result of evaluating multiplicativeexpression.
*0*let lref be the result of evaluating shiftexpression.
*0*let rref be the result of evaluating additiveexpression.
*0*let lref be the result of evaluating shiftexpression.
*0*let rref be the result of evaluating additiveexpression.
*0*let lref be the result of evaluating shiftexpression.
*0*let rref be the result of evaluating additiveexpression.

VB VBG VB . NNP ( NNP ) .
12
*0*let uristring be ? tostring(encodeduri).
*0*let componentstring be ? tostring(encodeduricomponent).
*0*let uristring be ? tostring(uri).
*0*let componentstring be ? tostring(uricomponent).
*2*let nextargstring be ? tostring(nextarg).
*1*let nextstring be ? tostring(next).
*0*let string be ? tostring(o).
*0*let searchstring be ? tostring(searchvalue).
*0*let string be ? tostring(o).
*0*let string be ? tostring(s).
*0*let xstring be ? tostring(x).
*0*let ystring be ? tostring(y).

IN NNP VBZ RB JJ , VB JJ VB JJ .
12
*0*if littleendian is not present, let littleendian be false.
*0*if littleendian is not present, let littleendian be false.
*0*if littleendian is not present, let littleendian be false.
*0*if littleendian is not present, let littleendian be false.
*0*if littleendian is not present, let littleendian be false.
*0*if littleendian is not present, let littleendian be false.
*0*if littleendian is not present, let littleendian be false.
*0*if littleendian is not present, let littleendian be false.
*0*if littleendian is not present, let littleendian be false.
*0*if littleendian is not present, let littleendian be false.
*0*if littleendian is not present, let littleendian be false.
*0*if littleendian is not present, let littleendian be false.

NN : NNP VBZ DT JJ NN NN .
11
*0*assert: input is an ecmascript language value.
*0*assert: f is an ecmascript function object.
*2*assert: globalenvrec is a global environment record.
*0*assert: f is an ecmascript function object.
*0*assert: f is an ecmascript function object.
*0*assert: f is an ecmascript function object.
*0*assert: f is an ecmascript function object.
*0*assert: envrec is a declarative environment record.
*0*assert: envrec is a global environment record.
*1*assert: ch is a utf-16 code unit.
*0*assert: r is an initialized regexp instance.

VB NNP VB . NNP ( NNP , NNP NNP NN ) .
11
*1*let exotictoprim be ? getmethod(input, @@toprimitive).
*0*let matcher be ? get(argument, @@match).
*3*let syncmethod be ? getmethod(obj, @@iterator).
*0*let instofhandler be ? getmethod(target, @@hasinstance).
*0*let tag be ? get(o, @@tostringtag).
*1*let matcher be ? getmethod(regexp, @@match).
*1*let searcher be ? getmethod(regexp, @@search).
*1*let splitter be ? getmethod(separator, @@split).
*0*let usingiterator be ? getmethod(items, @@iterator).
*0*let usingiterator be ? getmethod(source, @@iterator).
*0*let usingiterator be ? getmethod(object, @@iterator).

NN : NNP VBZ JJ .
11
*1*assert: status is true.
*0*assert: s is true.
*1*assert: iterationkind is iterate.
*3*assert: iterationkind is iterate.
*3*assert: iterationkind is iterate.
*2*assert: invert is true.
*3*assert: status is true.
*1*assert: definestatus is true.
*1*assert: definestatus is true.
*1*assert: status is true.
*0*assert: status is true.

VBN NNP . VB JJ NNP NNP NNP TO CD .
11
*0*set iterator.[[LISTITERATORNEXTINDEX]] to 0.
*0*set iterator.[[STRINGITERATORNEXTINDEX]] to 0.
*0*set iterator.[[ARRAYITERATORNEXTINDEX]] to 0.
*1*set obj.[[BYTELENGTH]] to 0.
*1*set obj.[[BYTEOFFSET]] to 0.
*1*set obj.[[ARRAYLENGTH]] to 0.
*0*set o.[[BYTEOFFSET]] to 0.
*0*set o.[[BYTEOFFSET]] to 0.
*0*set iterator.[[MAPNEXTINDEX]] to 0.
*0*set iterator.[[SETNEXTINDEX]] to 0.
*0*set arraybuffer.[[ARRAYBUFFERBYTELENGTH]] to 0.

IN NNP VBZ RB DT NN IN NNP , RB
11
*2*if fn is not an element of functionnames, then
*2*if n is not an element of instantiatedvarnames, then
*2*if n is not an element of instantiatedvarnames, then
*1*if name is not an element of mappednames, then
*2*if fn is not an element of declaredfunctionnames, then
*3*if vn is not an element of declaredfunctionnames, then
*4*if vn is not an element of declaredvarnames, then
*2*if dn is not an element of declaredvarnames, then
*2*if fn is not an element of declaredfunctionnames, then
*3*if vn is not an element of declaredfunctionnames, then
*4*if vn is not an element of declaredvarnames, then

IN NNP VBD CD , RB
11
*0*if r ≠ 0, then
*0*if mathint = 0, then
*0*if x = 0, then
*0*if f ≠ 0, then
*1*if f ≠ 0, then
*0*if x = 0, then
*0*if s = 0, then
*0*if n ≥ 0, then
*0*if n ≥ 0, then
*0*if n ≥ 0, then
*1*if intvalue ≥ 0, then

IN NNP VBZ RB JJ , VB NNP VB JJ ( NNP ) : RB , VB NNP VB . NNP ( NNP ) .
11
*0*if month is not present, let m be monthfromtime(t); otherwise, let m be ? tonumber(month).
*0*if min is not present, let m be minfromtime(t); otherwise, let m be ? tonumber(min).
*0*if sec is not present, let s be secfromtime(t); otherwise, let s be ? tonumber(sec).
*0*if ms is not present, let milli be msfromtime(t); otherwise, let milli be ? tonumber(ms).
*0*if sec is not present, let s be secfromtime(t); otherwise, let s be ? tonumber(sec).
*0*if ms is not present, let milli be msfromtime(t); otherwise, let milli be ? tonumber(ms).
*0*if ms is not present, let milli be msfromtime(t); otherwise, let milli be ? tonumber(ms).
*0*if month is not present, let m be monthfromtime(t); otherwise, let m be ? tonumber(month).
*0*if min is not present, let m be minfromtime(t); otherwise, let m be ? tonumber(min).
*0*if sec is not present, let s be secfromtime(t); otherwise, let s be ? tonumber(sec).
*0*if ms is not present, let milli be msfromtime(t); otherwise, let milli be ? tonumber(ms).

VB NNP VB NNP NNP NNP NNP NNP .
11
*1*let f be e + direction × len.
*1*let tobyteindex be to × elementsize + byteoffset.
*1*let frombyteindex be from × elementsize + byteoffset.
*0*let targetbyteindex be targetoffset × targetelementsize + targetbyteoffset.
*0*let limit be targetbyteindex + targetelementsize × srclength.
*0*let targetbyteindex be targetoffset × targetelementsize + targetbyteoffset.
*0*let limit be targetbyteindex + targetelementsize × srclength.
*0*let targetbyteindex be targetoffset × targetelementsize + targetbyteoffset.
*0*let limit be targetbyteindex + targetelementsize × srclength.
*1*let limit be targetbyteindex + count × elementsize.
*0*let beginbyteoffset be srcbyteoffset + beginindex × elementsize.

VB NNP VB NNP ( ) .
10
*1*let globalobj be getglobalobject().
*0*let envrec be getthisenvironment().
*0*let envrec be getthisenvironment().
*0*let realm be createrealm().
*2*let thisvalue be refenv.withbaseobject().
*0*let envrec be getthisenvironment().
*0*let env be getthisenvironment().
*1*let inmethod be thisenvrec.hassuperbinding().
*0*let b be agentcansuspend().
*0*let w be agentsignifier().

VBN NNP . VB JJ NNP NN NN TO NNP .
10
*1*set desc.[[ENUMERABLE]] to enum.
*1*set desc.[[CONFIGURABLE]] to conf.
*1*set desc.[[WRITABLE]] to writable.
*0*set o.[[PROTOTYPE]] to v.
*0*set obj.[[PROTOTYPE]] to proto.
*0*set f.[[PROTOTYPE]] to functionprototype.
*0*set func.[[PROTOTYPE]] to prototype.
*0*set obj.[[PROTOTYPE]] to proto.
*0*set a.[[PROTOTYPE]] to proto.
*0*set a.[[PROTOTYPE]] to prototype.

IN NNP ( NNP ) VBZ NN , RB
10
*0*if type(key) is symbol, then
*0*if type(x) is number, then
*0*if type(x) is number, then
*0*if type(x) is symbol, then
*0*if type(name) is symbol, then
*0*if type(p) is symbol, then
*0*if type(p) is symbol, then
*0*if type(ref) is reference, then
*0*if type(space) is number, then
*0*if type(value) is number, then

RB NNP IN DT JJ NN IN NNP .
10
*1*append next as the last element of list.
*1*add p as the last element of keys.
*1*add p as the last element of keys.
*1*add p as the last element of keys.
*1*add p as the last element of keys.
*1*add p as the last element of keys.
*1*add p as the last element of keys.
*1*add p as the last element of keys.
*1*add p as the last element of keys.
*2*append nextkey as the last element of namelist.

NN NNS .
10
*0*return properties.
*0*return intrinsics.
*0*return exports.
*0*return localnames.
*0*return descriptors.
*0*return values.
*0*return rawbytes.
*0*return events.
*0*return events.
*0*return events.

VB NNP VB DT NN IN JJ NNS IN NNP .
10
*0*let strlen be the number of code units in string.
*0*let strlen be the number of code units in string.
*0*let matchlength be the number of code units in matched.
*0*let stringlength be the number of code units in str.
*0*let r be the number of code units in r.
*0*let s be the number of code units in s.
*0*let resultsize be the number of code units in resultstring.
*0*let length be the number of code units in s.
*0*let length be the number of code units in s.
*1*let matchlength be the number of code units in matched.

IN NNP VBZ JJ , VB NNP VB NNP : JJ VB NNP VB . NNP ( NNP ) .
10
*0*if end is undefined, let intend be len; else let intend be ? tointeger(end).
*0*if end is undefined, let intend be len; else let intend be ? tointeger(end).
*0*if end is undefined, let relativeend be len; else let relativeend be ? tointeger(end).
*0*if end is undefined, let relativeend be len; else let relativeend be ? tointeger(end).
*0*if end is undefined, let relativeend be len; else let relativeend be ? tointeger(end).
*0*if end is undefined, let relativeend be len; else let relativeend be ? tointeger(end).
*0*if end is undefined, let relativeend be len; else let relativeend be ? tointeger(end).
*0*if end is undefined, let relativeend be len; else let relativeend be ? tointeger(end).
*0*if end is undefined, let relativeend be len; else let relativeend be ? tointeger(end).
*0*if end is undefined, let relativeend be len; else let relativeend be ? tointeger(end).

VB NNP VB . NNP ( NN NN NN ) .
10
*0*let obj be ? regexpalloc(%regexp%).
*0*let promisecapability be ! newpromisecapability(%promise%).
*0*let valuewrappercapability be ! newpromisecapability(%promise%).
*0*let promisecapability be ! newpromisecapability(%promise%).
*0*let valuewrappercapability be ! newpromisecapability(%promise%).
*0*let promisecapability be ! newpromisecapability(%promise%).
*0*let valuewrappercapability be ! newpromisecapability(%promise%).
*3*let promisecapability be ! newpromisecapability(%promise%).
*3*let throwawaycapability be ! newpromisecapability(%promise%).
*0*let promisecapability be ! newpromisecapability(%promise%).

VB NNP VB . NNP ( NNP , . NNP ( NNP ) ) .
10
*2*let capn be ? get(result, ! tostring(n)).
*4*let nextcapture be ? get(z, ! tostring(i)).
*1*let kpresent be ? hasproperty(o, ! tostring(k)).
*2*let elementk be ? get(o, ! tostring(k)).
*1*let element be ? get(o, ! tostring(k)).
*1*let kpresent be ? hasproperty(o, ! tostring(k)).
*2*let elementk be ? get(o, ! tostring(k)).
*1*let nextelement be ? get(array, ! tostring(k)).
*3*let newelement be ? internalizejsonproperty(val, ! tostring(i)).
*4*let v be ? get(replacer, ! tostring(k)).

IN NNP VBZ DT NNP NN , VB . JJ ( NNP , NNP ) .
10
*3*if mappedvalue is an abrupt completion, return ? iteratorclose(iteratorrecord, mappedvalue).
*2*if definestatus is an abrupt completion, return ? iteratorclose(iteratorrecord, definestatus).
*1*if k is an abrupt completion, return ? iteratorclose(iteratorrecord, k).
*1*if v is an abrupt completion, return ? iteratorclose(iteratorrecord, v).
*1*if status is an abrupt completion, return ? iteratorclose(iteratorrecord, status).
*1*if status is an abrupt completion, return ? iteratorclose(iteratorrecord, status).
*1*if k is an abrupt completion, return ? iteratorclose(iteratorrecord, k).
*1*if v is an abrupt completion, return ? iteratorclose(iteratorrecord, v).
*1*if status is an abrupt completion, return ? iteratorclose(iteratorrecord, status).
*1*if status is an abrupt completion, return ? iteratorclose(iteratorrecord, status).

VB DT NN NN .
9
*2*throw a referenceerror exception.
*2*throw a typeerror exception.
*0*throw a typeerror exception.
*0*throw a typeerror exception.
*0*throw a typeerror exception.
*2*throw a typeerror exception.
*5*throw a syntaxerror exception.
*0*throw a typeerror exception.
*0*throw a typeerror exception.

IN NNP VBZ `` JJ '' , RB
9
*0*if level is "sealed", then
*0*if p is "length", then
*0*if kind is "normal", then
*2*if itemkind is "key+value", then
*0*if type is "float32", then
*0*if type is "float64", then
*0*if type is "float32", then
*0*if state is "suspendedstart", then
*1*if state is "suspendedstart", then

IN DT NN NNP IN NNP IN NN NN , VBP
9
*0*for each element key of ownkeys in list order, do
*0*for each element nextkey of keys in list order, do
*1*for each element e of excludeditems in list order, do
*2*for each element octet of octets in list order, do
*1*for each element nextkey of keys in list order, do
*0*for each element nextkey of keys in list order, do
*0*for each element key of ownkeys in list order, do
*0*for each element nextkey of keys in list order, do
*0*for each element w of ws in list order, do

IN NNP NNP NNP , RB
9
*0*if index ≥ len, then
*1*if index ≥ oldlen, then
*0*if newlen ≥ oldlen, then
*0*if x = +∞, then
*2*if k ≤ f, then
*0*if x = +∞, then
*0*if position ≥ len, then
*1*if position ≥ nextsourceposition, then
*0*if index ≥ len, then

VBN NNP . VB JJ NNP NNP NNP TO `` VBN '' .
9
*0*set envrec.[[THISBINDINGSTATUS]] to "initialized".
*2*set requiredmodule.[[STATUS]] to "instantiated".
*2*set requiredmodule.[[STATUS]] to "evaluated".
*1*set generator.[[GENERATORSTATE]] to "completed".
*1*set generator.[[GENERATORSTATE]] to "completed".
*1*set generator.[[ASYNCGENERATORSTATE]] to "completed".
*2*set generator.[[ASYNCGENERATORSTATE]] to "completed".
*0*set promise.[[PROMISESTATE]] to "fulfilled".
*0*set promise.[[PROMISESTATE]] to "rejected".

VBN NNP . VB JJ NNP NNP NNP TO DT JJ JJ NN .
9
*0*set globalrec.[[NAMES]] to a new empty list.
*0*set realmrec.[[TEMPLATEMAP]] to a new empty list.
*0*set map.[[MAPDATA]] to a new empty list.
*0*set set.[[SETDATA]] to a new empty list.
*0*set map.[[WEAKMAPDATA]] to a new empty list.
*0*set set.[[WEAKSETDATA]] to a new empty list.
*0*set generator.[[ASYNCGENERATORQUEUE]] to a new empty list.
*0*set promise.[[PROMISEFULFILLREACTIONS]] to a new empty list.
*0*set promise.[[PROMISEREJECTREACTIONS]] to a new empty list.

IN DT NNP IN NNP , VBP
9
*1*for each n in varnames, do
*1*for each n in varnames, do
*0*for each name in lexnames, do
*0*for each name in varnames, do
*0*for each d in vardeclarations, do
*2*for each name in varnames, do
*3*for each name in varnames, do
*0*for each d in vardeclarations, do
*0*for each result in results, do

VB NNP VB NNP NNP CD .
9
*1*let index be index + 1.
*1*let index be index + 1.
*3*let k be f + 1.
*1*let nextindex be nextindex + 1.
*1*let nextindex be nextindex + 1.
*1*let nextindex be nextindex + 1.
*3*let lengtha be lengtha + 1.
*4*let i be i + 1.
*4*let lengtha be lengtha + 1.

VB NNP VB DT NN IN VBG NNP .
9
*0*let ref be the result of evaluating constructexpr.
*2*let testref be the result of evaluating test.
*1*let result be the result of evaluating stmt.
*2*let incref be the result of evaluating increment.
*0*let exprref be the result of evaluating expr.
*1*let result be the result of evaluating stmt.
*1*let result be the result of evaluating generatorbody.
*1*let result be the result of evaluating generatorbody.
*1*let result be the result of evaluating asyncfunctionbody.

NN : NNP VBZ CD .
9
*2*assert: e ≠ 0.
*0*assert: numberofargs ≥ 2.
*0*assert: numberofargs = 1.
*0*assert: numberofargs = 0.
*0*assert: numberofargs = 0.
*0*assert: numberofargs = 1.
*0*assert: numberofargs ≥ 2.
*0*assert: length ≥ 0.
*0*assert: n ≤ 0xffff.

NN : NNP VBZ DT JJ NN NNP NNP NNP JJ NN .
9
*0*assert: o has a [[VIEWEDARRAYBUFFER]] internal slot.
*0*assert: target has a [[VIEWEDARRAYBUFFER]] internal slot.
*0*assert: target has a [[VIEWEDARRAYBUFFER]] internal slot.
*0*assert: target has a [[VIEWEDARRAYBUFFER]] internal slot.
*0*assert: o has a [[VIEWEDARRAYBUFFER]] internal slot.
*0*assert: m has a [[MAPDATA]] internal slot.
*0*assert: s has a [[SETDATA]] internal slot.
*0*assert: view has a [[VIEWEDARRAYBUFFER]] internal slot.
*0*assert: view has a [[VIEWEDARRAYBUFFER]] internal slot.

IN DT NN ( JJ NNP NNP NNP NNP , NNP NNP NNP NNP NNP ) NNP WDT VBZ DT NN IN NNS , VBP
9
*0*for each record { [[KEY]], [[VALUE]] } p that is an element of entries, do
*0*for each record { [[KEY]], [[VALUE]] } p that is an element of entries, do
*0*for each record { [[KEY]], [[VALUE]] } p that is an element of entries, do
*0*for each record { [[KEY]], [[VALUE]] } p that is an element of entries, do
*0*for each record { [[KEY]], [[VALUE]] } p that is an element of entries, do
*0*for each record { [[KEY]], [[VALUE]] } p that is an element of entries, do
*0*for each record { [[KEY]], [[VALUE]] } p that is an element of entries, do
*0*for each record { [[KEY]], [[VALUE]] } p that is an element of entries, do
*0*for each record { [[KEY]], [[VALUE]] } p that is an element of entries, do

IN NNP VBZ JJ , VB NNP .
8
*0*if number is nan, return +0.
*0*if number is nan, return +0.
*0*if desc is undefined, return desc.
*0*if result is null, return -1.
*1*if testresult is true, return kvalue.
*0*if y is undefined, return -1.
*1*if v is nan, return +0.
*0*if xsmaller is true, return -1.

IN NNP ( NNP ) VBZ VBG , RB
8
*0*if type(x) is string, then
*1*if type(key) is string, then
*0*if type(p) is string, then
*0*if type(p) is string, then
*0*if type(p) is string, then
*0*if type(p) is string, then
*0*if type(p) is string, then
*2*if type(v) is string, then

VB NNS VB DT JJ JJ NN .
8
*0*let properties be a new empty list.
*0*let indirectexportentries be a new empty list.
*0*let localexportentries be a new empty list.
*0*let starexportentries be a new empty list.
*0*let descriptors be a new empty list.
*0*let elements be a new empty list.
*0*let elements be a new empty list.
*0*let stringelements be a new empty list.

VB NNP VB DT NN NN IN NNP .
8
*0*let globalobject be the binding object for objrec.
*0*let globalobject be the binding object for objrec.
*0*let globalobject be the binding object for objrec.
*0*let globalobject be the binding object for objrec.
*0*let globalobject be the binding object for objrec.
*0*let globalobject be the binding object for objrec.
*0*let number be the number value for mathint.
*0*let generator be the generator component of gencontext.

NN NNP IN DT NN NN NN : NNP VBZ RB DT VBG NN NN .
8
*0*push newcontext onto the execution context stack; newcontext is now the running execution context.
*1*push newcontext onto the execution context stack; newcontext is now the running execution context.
*0*push calleecontext onto the execution context stack; calleecontext is now the running execution context.
*0*push calleecontext onto the execution context stack; calleecontext is now the running execution context.
*0*push gencontext onto the execution context stack; gencontext is now the running execution context.
*0*push gencontext onto the execution context stack; gencontext is now the running execution context.
*0*push gencontext onto the execution context stack; gencontext is now the running execution context.
*0*push asynccontext onto the execution context stack; asynccontext is now the running execution context.

IN NNP . VB JJ NNP NNP NNP VBZ JJ , RB
8
*0*if current.[[CONFIGURABLE]] is false, then
*1*if current.[[CONFIGURABLE]] is false, then
*0*if desc.[[CONFIGURABLE]] is true, then
*0*if func.[[THISMODE]] is lexical, then
*0*if resultdesc.[[CONFIGURABLE]] is false, then
*0*if result.[[TYPE]] is normal, then
*0*if result.[[TYPE]] is normal, then
*1*if result.[[TYPE]] is normal, then

VBN NNP . VB JJ NNP NN NN TO JJ .
8
*0*set obj.[[EXTENSIBLE]] to true.
*0*set f.[[EXTENSIBLE]] to true.
*0*set func.[[EXTENSIBLE]] to true.
*0*set obj.[[EXTENSIBLE]] to true.
*0*set a.[[EXTENSIBLE]] to true.
*1*set newlendesc.[[WRITABLE]] to true.
*0*set obj.[[EXTENSIBLE]] to true.
*0*set a.[[EXTENSIBLE]] to true.

VB NNP VB DT JJ NN NN NN NN .
8
*0*let calleecontext be a new ecmascript code execution context.
*0*let functionprototype be the intrinsic object %generator%.
*0*let functionprototype be the intrinsic object %asyncgenerator%.
*0*let functionprototype be the intrinsic object %asyncfunctionprototype%.
*0*let calleecontext be a new ecmascript code execution context.
*0*let scriptcxt be a new ecmascript code execution context.
*0*let modulecxt be a new ecmascript code execution context.
*0*let evalcxt be a new ecmascript code execution context.

RB , VB NNP VB NNP .
8
*0*else, let lexenv be varenv.
*1*else, let f be flags.
*1*else, let f be flags.
*2*else, let mappedvalue be nextvalue.
*1*else, let mappedvalue be kvalue.
*2*else, let mappedvalue be kvalue.
*1*else, let mappedvalue be kvalue.
*0*else, let srcbyteindex be srcbyteoffset.

IN DT NN NNP IN DT NNS IN NNP , VBP
8
*1*for each element dn of the boundnames of d, do
*1*for each element dn of the boundnames of d, do
*2*for each string vn in the boundnames of d, do
*1*for each element dn of the boundnames of d, do
*1*for each element dn of the boundnames of d, do
*1*for each element dn of the boundnames of d, do
*2*for each string vn in the boundnames of d, do
*1*for each element dn of the boundnames of d, do

VB NNP VB DT JJ NN IN NNP .
8
*1*let env be the environmentrecord component of environment.
*2*let requiredmodule be the last element in stack.
*2*let requiredmodule be the last element in stack.
*1*let p be the first element of pair.
*1*let desc be the second element of pair.
*1*let w be the first waiter in s.
*1*let w be the first agent in s.
*0*let n be the numeric value of c.

RB , NN JJ .
8
*0*otherwise, return true.
*0*otherwise, return false.
*0*otherwise, return true.
*0*otherwise, return true.
*0*otherwise, return false.
*0*otherwise, return false.
*0*otherwise, return false.
*0*otherwise, return false.

NN NN .
8
*1*return +0.
*1*return +0.
*2*return null.
*3*return null.
*0*return -1.
*0*return -1.
*0*return -1.
*0*return +0.

RB NNP CC NN : CD ,
8
*0*else argcount &gt; 1,
*0*else x &lt; 1021,
*2*else e &lt; 0,
*0*else e &lt; 0,
*0*else n &lt; 0,
*0*else n &lt; 0,
*0*else n &lt; 0,
*0*else len &gt; 0,

RB NNP VBZ JJ ,
8
*1*else fractiondigits is undefined,
*1*else fullunicode is false,
*0*else global is true,
*1*else frompresent is false,
*1*else frompresent is false,
*2*else frompresent is false,
*2*else frompresent is false,
*2*else frompresent is false,

NN . NNP ( NNP , `` NN '' , CD , JJ ) .
8
*0*perform ? set(obj, "lastindex", 0, true).
*3*perform ? set(r, "lastindex", 0, true).
*3*perform ? set(r, "lastindex", 0, true).
*1*perform ? set(rx, "lastindex", 0, true).
*1*perform ? set(rx, "lastindex", 0, true).
*1*perform ? set(rx, "lastindex", 0, true).
*1*perform ? set(o, "length", 0, true).
*1*perform ? set(o, "length", 0, true).

IN NNP ( NNP ) VBZ RB JJ , VB NNP .
7
*0*if type(v) is not reference, return v.
*2*if type(result) is not object, return result.
*2*if type(result) is not object, return result.
*0*if type(o) is not object, return o.
*0*if type(o) is not object, return o.
*0*if type(o) is not object, return o.
*0*if type(o) is not object, return o.

VBN NNP TO . NNP ( NNP ) .
7
*2*set base to ! toobject(base).
*2*set base to ! toobject(base).
*1*set p to ? tostring(firstarg).
*0*set bodytext to ? tostring(bodytext).
*1*set next to ? iteratorstep(iteratorrecord).
*2*set value to ? tonumber(value).
*2*set value to ? tostring(value).

IN NNP . VB JJ NNP NNP NNP VBZ JJ , NN JJ .
7
*2*if currentdesc.[[CONFIGURABLE]] is true, return false.
*3*if currentdesc.[[WRITABLE]] is true, return false.
*0*if existingprop.[[CONFIGURABLE]] is true, return false.
*1*if current.[[CONFIGURABLE]] is false, return false.
*1*if owndesc.[[WRITABLE]] is false, return false.
*2*if existingdescriptor.[[WRITABLE]] is false, return false.
*0*if oldlendesc.[[WRITABLE]] is false, return false.

IN NNP VBZ RB JJ CC NNP . VB JJ NNP NNP NNP VBZ JJ , RB
7
*2*if desc is not undefined and desc.[[ENUMERABLE]] is true, then
*2*if desc is not undefined and desc.[[ENUMERABLE]] is true, then
*0*if targetdesc is not undefined and targetdesc.[[CONFIGURABLE]] is false, then
*0*if targetdesc is not undefined and targetdesc.[[CONFIGURABLE]] is false, then
*1*if desc is not undefined and desc.[[CONFIGURABLE]] is false, then
*2*if desc is not undefined and desc.[[ENUMERABLE]] is true, then
*1*if propdesc is not undefined and propdesc.[[ENUMERABLE]] is true, then

IN NNP ( NNP , NNP ) VBZ JJ , RB
7
*2*if samevalue(e, nextkey) is true, then
*0*if samevalue(args, receiver) is false, then
*1*if loopcontinues(result, labelset) is false, then
*0*if samevalue(currentlastindex, previouslastindex) is false, then
*0*if samevalue(srctype, targettype) is true, then
*0*if samevalue(srctype, targettype) is false, then
*0*if samevalue(elementtype, srctype) is true, then

VB NNP VB DT NN NN NN IN WDT DT NN VBD VBN .
7
*0*let envrec be the function environment record for which the method was invoked.
*0*let envrec be the function environment record for which the method was invoked.
*0*let envrec be the function environment record for which the method was invoked.
*0*let envrec be the function environment record for which the method was invoked.
*0*let envrec be the function environment record for which the method was invoked.
*0*let envrec be the module environment record for which the method was invoked.
*0*let envrec be the module environment record for which the method was invoked.

NN . NNP . VB JJ NNP NNP NNP ( ) .
7
*0*return ? home.[[GETPROTOTYPEOF]]().
*1*return ? target.[[GETPROTOTYPEOF]]().
*1*return ? target.[[PREVENTEXTENSIONS]]().
*1*return ? target.[[OWNPROPERTYKEYS]]().
*0*return ? obj.[[GETPROTOTYPEOF]]().
*0*return ? target.[[GETPROTOTYPEOF]]().
*0*return ? target.[[PREVENTEXTENSIONS]]().

IN NNP VBZ JJ , VB JJ .
7
*0*if hasproperty is true, return true.
*0*if desc is undefined, return true.
*0*if extensibletarget is true, return true.
*0*if targetdesc is undefined, return true.
*0*if num is nan, return true.
*0*if number is nan, return true.
*2*if testresult is true, return true.

NN . NNP ( NNP , JJ ) .
7
*1*return ? targeter.getbindingvalue(n2, true).
*3*perform ! lexenvrec.createimmutablebinding(dn, true).
*3*perform ! envrec.createimmutablebinding(dn, true).
*3*perform ? envrec.createimmutablebinding(dn, true).
*3*perform ! envrec.createimmutablebinding(dn, true).
*3*perform ? lexenvrec.createimmutablebinding(dn, true).
*2*perform ? varenvrec.createglobalvarbinding(vn, true).

NN . NNP ( ) .
7
*0*return ? envrec.getthisbinding().
*0*perform ? initializehostdefinedrealm().
*0*return ? envrec.getthisbinding().
*1*perform ? module.instantiate().
*1*perform ? module.evaluate().
*0*perform ? m.instantiate().
*0*return ? m.evaluate().

VB NNP VB DT JJ NN IN DT NNS IN NNP .
7
*2*let fn be the sole element of the boundnames of d.
*1*let fn be the sole element of the boundnames of f.
*2*let fn be the sole element of the boundnames of d.
*2*let fn be the sole element of the boundnames of d.
*1*let fn be the sole element of the boundnames of f.
*2*let fn be the sole element of the boundnames of d.
*1*let fn be the sole element of the boundnames of f.

NN : NNP VBZ DT NN WDT VBZ DT JJ NN NNP NNP NNP JJ NN .
7
*0*assert: s is an object that has a [[STRINGDATA]] internal slot.
*0*assert: o is an object that has a [[VIEWEDARRAYBUFFER]] internal slot.
*0*assert: o is an object that has a [[VIEWEDARRAYBUFFER]] internal slot.
*0*assert: o is an object that has a [[VIEWEDARRAYBUFFER]] internal slot.
*0*assert: o is an object that has a [[VIEWEDARRAYBUFFER]] internal slot.
*0*assert: exemplar is an object that has a [[TYPEDARRAYNAME]] internal slot.
*0*assert: typedarray is an object that has a [[VIEWEDARRAYBUFFER]] internal slot.

VB NNP VB NNP ( . NNP ( NNP , NNP , NNP NNP , NNP , NNP NNP ) ) .
7
*0*let booleantrapresult be toboolean(? call(trap, handler, « target, p, descobj »)).
*2*let testresult be toboolean(? call(callbackfn, t, « kvalue, k, o »)).
*2*let selected be toboolean(? call(callbackfn, t, « kvalue, k, o »)).
*1*let testresult be toboolean(? call(predicate, t, « kvalue, k, o »)).
*1*let testresult be toboolean(? call(predicate, t, « kvalue, k, o »)).
*2*let testresult be toboolean(? call(callbackfn, t, « kvalue, k, o »)).
*1*let selected be toboolean(? call(callbackfn, t, « kvalue, k, o »)).

IN NNP VBZ JJ , VB NNP VB VBN .
7
*1*if iterationkind is async-iterate, let iteratorhint be async.
*0*if description is undefined, let descstring be undefined.
*0*if t is nan, let t be +0.
*1*if capturei is undefined, let capturedvalue be undefined.
*0*if key is -0, let key be +0.
*0*if value is -0, let value be +0.
*0*if count is undefined, let c be +∞.

VB NNP VB . NNP ( NN , `` NN NN NN '' , NNP NNP NNP NNP NNP NNP NNP ) .
7
*0*let o be ? ordinarycreatefromconstructor(newtarget, "%booleanprototype%", « [[BOOLEANDATA]] »).
*1*let o be ? ordinarycreatefromconstructor(newtarget, "%dateprototype%", « [[DATEVALUE]] »).
*1*let o be ? ordinarycreatefromconstructor(newtarget, "%dateprototype%", « [[DATEVALUE]] »).
*1*let o be ? ordinarycreatefromconstructor(newtarget, "%dateprototype%", « [[DATEVALUE]] »).
*0*let map be ? ordinarycreatefromconstructor(newtarget, "%mapprototype%", « [[MAPDATA]] »).
*0*let map be ? ordinarycreatefromconstructor(newtarget, "%weakmapprototype%", « [[WEAKMAPDATA]] »).
*0*let set be ? ordinarycreatefromconstructor(newtarget, "%weaksetprototype%", « [[WEAKSETDATA]] »).

IN NNP CC NN : CD , RB
7
*0*if x &lt; 0, then
*0*if x &lt; 0, then
*0*if x &lt; 0, then
*2*if e &gt; 0, then
*1*if k &gt; 0, then
*0*if argcount &gt; 0, then
*0*if count &gt; 0, then

IN NNP VBZ JJ , VB NNP VB . NNP ( NNP ) : JJ VB NNP VB CD .
7
*1*if hours is present, let h be ? tonumber(hours); else let h be 0.
*1*if minutes is present, let min be ? tonumber(minutes); else let min be 0.
*1*if ms is present, let milli be ? tonumber(ms); else let milli be 0.
*0*if month is present, let m be ? tonumber(month); else let m be 0.
*0*if hours is present, let h be ? tonumber(hours); else let h be 0.
*0*if minutes is present, let min be ? tonumber(minutes); else let min be 0.
*0*if ms is present, let milli be ? tonumber(ms); else let milli be 0.

VB DT JJ NN IN NNP CC VB NNP VB DT NN IN DT NN .
7
*1*remove the first element from args and let next be the value of that element.
*1*remove the first element from items and let e be the value of the element.
*1*remove the first element from items and let e be the value of the element.
*1*remove the first element from items and let e be the value of that element.
*2*remove the first element from items and let e be the value of that element.
*0*remove the first element from queue and let next be the value of that element.
*0*remove the first element from queue and let next be the value of that element.

VB NNP VB VBN ( NN ( NNP , CD ) , NNP ) .
7
*0*let end be min(max(pos, 0), len).
*0*let start be min(max(pos, 0), len).
*0*let start be min(max(pos, 0), len).
*0*let start be min(max(pos, 0), len).
*0*let start be min(max(pos, 0), len).
*0*let finalstart be min(max(intstart, 0), len).
*0*let finalend be min(max(intend, 0), len).

IN DT NNP WDT VBZ DT NN IN NNS , VBP
7
*0*for each e that is an element of entries, do
*0*for each e that is an element of entries, do
*0*for each e that is an element of entries, do
*0*for each e that is an element of entries, do
*0*for each e that is an element of entries, do
*0*for each e that is an element of entries, do
*0*for each e that is an element of entries, do

VB NNP VB NNP ( NNP , NNP NNP NNP NNP NNP NNP NNP ) .
7
*0*let onfulfilled be createbuiltinfunction(steps, « [[DONE]] »).
*0*let onfulfilled be createbuiltinfunction(steps, « [[DONE]] »).
*0*let onfulfilled be createbuiltinfunction(steps, « [[DONE]] »).
*3*let onfulfilled be createbuiltinfunction(stepsfulfilled, « [[GENERATOR]] »).
*3*let onrejected be createbuiltinfunction(stepsrejected, « [[GENERATOR]] »).
*0*let executor be createbuiltinfunction(steps, « [[CAPABILITY]] »).
*0*let revoker be createbuiltinfunction(steps, « [[REVOCABLEPROXY]] »).

IN NNP VBZ JJ , NN VBD .
6
*0*if desc is undefined, return undefined.
*1*if parent is null, return undefined.
*0*if getter is undefined, return undefined.
*0*if index is undefined, return undefined.
*2*if value is undefined, return undefined.
*1*if targetdesc is undefined, return undefined.

VB NNP VB NNP ( . NNP ( NNP , `` JJ '' ) ) .
6
*1*let enum be toboolean(? get(obj, "enumerable")).
*1*let conf be toboolean(? get(obj, "configurable")).
*0*let global be toboolean(? get(rx, "global")).
*1*let fullunicode be toboolean(? get(rx, "unicode")).
*0*let global be toboolean(? get(rx, "global")).
*1*let fullunicode be toboolean(? get(rx, "unicode")).

VBN NNP . CC JJ NNP NNP NNP TO NNP .
6
*1*set desc.[[VALUE]] to value.
*0*set newlendesc.[[VALUE]] to newlen.
*0*set getter.[[NAME]] to name.
*0*set setter.[[NAME]] to name.
*2*set p.[[VALUE]] to value.
*2*set p.[[VALUE]] to value.

IN NNP VBZ JJ , NNP , NNP , NNP , CC NN , NN NN .
6
*0*if number is nan, +0, -0, +∞, or -∞, return +0.
*0*if number is nan, +0, -0, +∞, or -∞, return +0.
*0*if number is nan, +0, -0, +∞, or -∞, return +0.
*0*if number is nan, +0, -0, +∞, or -∞, return +0.
*0*if number is nan, +0, -0, +∞, or -∞, return +0.
*0*if number is nan, +0, -0, +∞, or -∞, return +0.

VB NNP VB DT JJ NN WDT VBZ DT JJ NN IN NNP CC WP$ NN VBZ NN ( JJ ( NNP ) ) .
6
*0*let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).
*0*let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).
*0*let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).
*0*let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).
*0*let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).
*0*let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).

VB NNP VB NNP $ CD .
6
*0*let int32bit be int modulo 232.
*0*let int32bit be int modulo 232.
*0*let int16bit be int modulo 216.
*0*let int16bit be int modulo 216.
*0*let int8bit be int modulo 28.
*0*let int8bit be int modulo 28.

IN NNP CC NN : CD , VBP DT NN NN .
6
*1*if integerindex &lt; 0, throw a rangeerror exception.
*0*if n &lt; 0, throw a rangeerror exception.
*0*if targetoffset &lt; 0, throw a rangeerror exception.
*0*if targetoffset &lt; 0, throw a rangeerror exception.
*0*if targetoffset &lt; 0, throw a rangeerror exception.
*1*if newbytelength &lt; 0, throw a rangeerror exception.

NN . NNP . VB JJ NNP NNP NNP ( NNP , NNP ) .
6
*0*return ? o.[[GET]](p, o).
*0*return ? o.[[GET]](p, v).
*0*return ? f.[[CALL]](v, argumentslist).
*1*return ? parent.[[GET]](p, receiver).
*1*return ? target.[[GET]](p, receiver).
*0*return ? target.[[GET]](key, receiver).

VBN NN TO NNP NNP CD .
6
*1*set index to index + 1.
*0*set index to index + 1.
*0*set index to index + 1.
*2*set srcbyteindex to srcbyteindex + 1.
*2*set targetbyteindex to targetbyteindex + 1.
*1*set index to index + 1.

IN NNP ( NNP ) VBZ JJ , NN JJ .
6
*0*if iscallable(c) is false, return false.
*2*if isaccessordescriptor(existingdescriptor) is true, return false.
*2*if isinteger(numericindex) is false, return false.
*2*if isinteger(numericindex) is false, return false.
*2*if isaccessordescriptor(desc) is true, return false.
*0*if isinteger(index) is false, return false.

NN : NNP VBZ DT JJ NN .
6
*0*assert: obj is a callable object.
*0*assert: f is an ecmascript function.
*0*assert: env is a lexical environment.
*3*assert: lhs binds a single name.
*0*assert: bytelength is a nonnegative integer.
*2*assert: w is a readmodifywritesharedmemory event.

IN VBN VBZ JJ , RB
6
*1*if excluded is false, then
*1*if alreadydeclared is false, then
*0*if argumentsobjectneeded is true, then
*1*if deletesucceeded is false, then
*2*if selected is true, then
*1*if selected is true, then

VB NNP VB . NNP ( NNP , `` JJ '' ) .
6
*0*let nextmethod be ? getv(iterator, "next").
*0*let trap be ? getmethod(handler, "isextensible").
*0*let status be ? setintegritylevel(o, "frozen").
*0*let namelist be ? enumerableownpropertynames(obj, "key").
*2*let keys be ? enumerableownpropertynames(val, "key").
*1*let k be ? enumerableownpropertynames(value, "key").

VB JJ VB . NNP ( NNP ) .
6
*0*let extensible be ? isextensible(globalobject).
*3*let fndefinable be ? envrec.candeclareglobalfunction(fn).
*4*let vndefinable be ? envrec.candeclareglobalvar(vn).
*4*let fndefinable be ? varenvrec.candeclareglobalfunction(fn).
*5*let vndefinable be ? varenvrec.candeclareglobalvar(vn).
*1*let spreadable be ? isconcatspreadable(e).

IN NNS VBZ JJ , RB
6
*0*if exists is true, then
*2*if bindingexists is false, then
*2*if bindingexists is false, then
*3*if exists is true, then
*1*if lowerexists is true, then
*1*if upperexists is true, then

VBN NNP TO NNP .
6
*1*set lex to outer.
*1*set e to eutf.
*1*set accumulator to initialvalue.
*1*set accumulator to initialvalue.
*0*set indent to stepback.
*0*set indent to stepback.

VB DT NN IN NNP TO NNP . VB JJ NNP NNP NNP .
6
*0*set the scriptormodule of calleecontext to f.[[SCRIPTORMODULE]].
*0*set the scriptormodule of calleecontext to f.[[SCRIPTORMODULE]].
*0*set the realm of scriptcxt to scriptrecord.[[REALM]].
*0*set the realm of modulecxt to module.[[REALM]].
*0*set the variableenvironment of modulecxt to module.[[ENVIRONMENT]].
*0*set the lexicalenvironment of modulecxt to module.[[ENVIRONMENT]].

IN DT NN NN NNP IN NNP , VBP
6
*0*for each parse node f in functionstoinitialize, do
*0*for each parse node f in functionstoinitialize, do
*0*for each importentry record i in importentries, do
*0*for each exportentry record ee in exportentries, do
*0*for each parse node f in functionstoinitialize, do
*0*for each code unit c in value, do

VBN NNP . VB JJ NNP NNP NNP IN VBN IN CD .
6
*0*set obj.[[CALL]] as described in 9.4.1.1.
*0*set obj.[[GET]] as specified in 9.4.4.3.
*0*set obj.[[DELETE]] as specified in 9.4.4.5.
*0*set a.[[GET]] as specified in 9.4.5.4.
*0*set a.[[OWNPROPERTYKEYS]] as specified in 9.4.5.6.
*1*set p.[[CALL]] as specified in 9.5.12.

VB NNP VB NNP . CC JJ NNP NNP NNP .
6
*1*let oldlen be oldlendesc.[[VALUE]].
*0*let oldlen be oldlendesc.[[VALUE]].
*3*let value be desc.[[VALUE]].
*3*let mappedvalue be mappedvalue.[[VALUE]].
*0*let unfiltered be completion.[[VALUE]].
*2*let resultvalue be result.[[VALUE]].

VBN NNP . VB NNP NNP NNP NNP IN VBN IN CD .
6
*0*set a.[[DEFINEOWNPROPERTY]] as specified in 9.4.2.1.
*0*set obj.[[GETOWNPROPERTY]] as specified in 9.4.4.1.
*0*set obj.[[DEFINEOWNPROPERTY]] as specified in 9.4.4.2.
*0*set a.[[GETOWNPROPERTY]] as specified in 9.4.5.1.
*0*set a.[[HASPROPERTY]] as specified in 9.4.5.2.
*0*set a.[[DEFINEOWNPROPERTY]] as specified in 9.4.5.3.

VB NNP VB NNP ( NNP , NNP NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP NNP ) .
6
*0*let getter be createbuiltinfunction(steps, « [[NAME]], [[ENV]] »).
*0*let setter be createbuiltinfunction(steps, « [[NAME]], [[ENV]] »).
*0*let resolve be createbuiltinfunction(stepsresolve, « [[PROMISE]], [[ALREADYRESOLVED]] »).
*0*let reject be createbuiltinfunction(stepsreject, « [[PROMISE]], [[ALREADYRESOLVED]] »).
*1*let thenfinally be createbuiltinfunction(stepsthenfinally, « [[CONSTRUCTOR]], [[ONFINALLY]] »).
*1*let catchfinally be createbuiltinfunction(stepscatchfinally, « [[CONSTRUCTOR]], [[ONFINALLY]] »).

VB NNP VB ( NNP NNP NNP ) NN NNP .
6
*0*let indexedposition be (index × elementsize) + offset.
*0*let indexedposition be (index × elementsize) + offset.
*0*let indexedposition be (i × elementsize) + offset.
*0*let indexedposition be (i × elementsize) + offset.
*0*let indexedposition be (i × elementsize) + offset.
*0*let indexedposition be (i × elementsize) + offset.

RB NNP VBZ RB JJ ,
6
*0*else targetdesc is not undefined,
*2*else result is not null,
*1*else result is not null,
*1*else z is not null,
*0*else initialvalue is not present,
*0*else initialvalue is not present,

VB DT NN IN NNP CC NNP .
6
*1*return the string-concatenation of lstr and rstr.
*0*return the string-concatenation of s and m.
*0*return the string-concatenation of s and m.
*0*return the string-concatenation of s and m.
*0*return the string-concatenation of s and truncatedstringfiller.
*0*return the string-concatenation of truncatedstringfiller and s.

VB NNP VB . NNP ( NNP , JJ ) .
6
*2*let lastvalue be ? lastiterationenvrec.getbindingvalue(bn, true).
*3*let status be ! varenvrec.createmutablebinding(fn, true).
*3*let status be ! varenvrec.createmutablebinding(vn, true).
*0*let buffer be ? validatesharedintegertypedarray(typedarray, true).
*0*let buffer be ? validatesharedintegertypedarray(typedarray, true).
*1*let iterresult be ! createiterresultobject(value, true).

VB DT JJ NN NN POS NN TO NNP .
6
*1*set the running execution context's lexicalenvironment to thisiterationenv.
*1*set the running execution context's lexicalenvironment to tdz.
*0*set the running execution context's lexicalenvironment to oldenv.
*2*set the running execution context's lexicalenvironment to iterationenv.
*2*set the running execution context's lexicalenvironment to oldenv.
*1*set the running execution context's lexicalenvironment to oldenv.

VBN NNP . VB JJ NNP NNP NNP TO `` VBG '' .
6
*0*set module.[[STATUS]] to "instantiating".
*0*set module.[[STATUS]] to "evaluating".
*0*set generator.[[GENERATORSTATE]] to "executing".
*0*set generator.[[GENERATORSTATE]] to "executing".
*0*set generator.[[ASYNCGENERATORSTATE]] to "executing".
*0*set promise.[[PROMISESTATE]] to "pending".

NN . NNP ( DT NN ) .
6
*0*return ? toobject(this value).
*0*return ? thissymbolvalue(this value).
*0*return ? thissymbolvalue(this value).
*0*return ? thisnumbervalue(this value).
*0*return ? thisstringvalue(this value).
*0*return ? thisstringvalue(this value).

IN NNP VBZ NN VBZ JJ , VB DT NN NN .
6
*0*if body contains supercall is true, throw a syntaxerror exception.
*0*if parameters contains supercall is true, throw a syntaxerror exception.
*0*if body contains superproperty is true, throw a syntaxerror exception.
*0*if parameters contains superproperty is true, throw a syntaxerror exception.
*1*if parameters contains yieldexpression is true, throw a syntaxerror exception.
*1*if parameters contains awaitexpression is true, throw a syntaxerror exception.

IN NNP NNP CD , RB
6
*0*if e = 0, then
*0*if x ≥ 1021, then
*2*if p ≠ 1, then
*0*if e ≥ 0, then
*0*if size = 0, then
*2*if k ≥ 253-1, then

VB NNP VB . NNP ( NNP ) . ( IN NNP VBZ JJ , DT NN VBZ DT NN NNP .
6
*0*let f be ? tointeger(fractiondigits). (if fractiondigits is undefined, this step produces the value 0.)
*0*let pos be ? tointeger(position). (if position is undefined, this step produces the value 0.)
*0*let pos be ? tointeger(position). (if position is undefined, this step produces the value 0.)
*0*let pos be ? tointeger(position). (if position is undefined, this step produces the value 0.)
*0*let n be ? tointeger(fromindex). (if fromindex is undefined, this step produces the value 0.)
*0*let n be ? tointeger(fromindex). (if fromindex is undefined, this step produces the value 0.)

VB NNP VB DT NN IN NNS VBN TO DT NN NN .
6
*0*let numberofargs be the number of arguments passed to this function call.
*0*let numberofargs be the number of arguments passed to this function call.
*0*let numberofargs be the number of arguments passed to this function call.
*0*let numberofargs be the number of arguments passed to this function call.
*0*let numberofargs be the number of arguments passed to this function call.
*0*let numberofargs be the number of arguments passed to this function call.

NN NN ( NNP ( NNP ) ) .
6
*0*return yearfromtime(localtime(t)).
*0*return hourfromtime(localtime(t)).
*0*return msfromtime(localtime(t)).
*0*return minfromtime(localtime(t)).
*0*return monthfromtime(localtime(t)).
*0*return secfromtime(localtime(t)).

NN NN ( NNP ) .
6
*0*return yearfromtime(t).
*0*return hourfromtime(t).
*0*return msfromtime(t).
*0*return minfromtime(t).
*0*return monthfromtime(t).
*0*return secfromtime(t).

VB NNP VB NNP ( . NN ( DT NN ) ) .
6
*0*let t be localtime(? thistimevalue(this value)).
*0*let t be localtime(? thistimevalue(this value)).
*0*let t be localtime(? thistimevalue(this value)).
*0*let t be localtime(? thistimevalue(this value)).
*0*let t be localtime(? thistimevalue(this value)).
*0*let t be localtime(? thistimevalue(this value)).

VB NNP VB NNP ( NNP ( NNP ) ) .
6
*0*let u be timeclip(utc(newdate)).
*0*let u be timeclip(utc(newdate)).
*0*let u be timeclip(utc(date)).
*0*let u be timeclip(utc(date)).
*0*let u be timeclip(utc(newdate)).
*0*let u be timeclip(utc(date)).

NN , IN NNP VBZ RB JJ
6
*0*repeat, while args is not empty
*0*repeat, while items is not empty
*0*repeat, while items is not empty
*0*repeat, while items is not empty
*1*repeat, while items is not empty
*0*repeat, while next is not false

VB NNP VB . NNP ( NNP , NN NN NN ) .
6
*0*let c be ? speciesconstructor(rx, %regexp%).
*1*let bufferconstructor be ? speciesconstructor(srcdata, %arraybuffer%).
*0*let ctor be ? speciesconstructor(o, %arraybuffer%).
*0*let ctor be ? speciesconstructor(o, %sharedarraybuffer%).
*0*let c be ? speciesconstructor(promise, %promise%).
*0*let c be ? speciesconstructor(promise, %promise%).

IN NNP CC NN : CD , VB NNP VB VBN ( ( NNP NNP NNP ) , CD ) : JJ NN NNP VB VBN ( NNP , NNP ) .
6
*0*if relativestart &lt; 0, let from be max((len + relativestart), 0); else let from be min(relativestart, len).
*0*if relativestart &lt; 0, let k be max((len + relativestart), 0); else let k be min(relativestart, len).
*0*if relativestart &lt; 0, let k be max((len + relativestart), 0); else let k be min(relativestart, len).
*0*if relativestart &lt; 0, let from be max((len + relativestart), 0); else let from be min(relativestart, len).
*0*if relativestart &lt; 0, let k be max((len + relativestart), 0); else let k be min(relativestart, len).
*0*if relativestart &lt; 0, let k be max((len + relativestart), 0); else let k be min(relativestart, len).

VBN NNP TO DT NN IN NNP CC NNP .
6
*1*set r to the string-concatenation of r and next.
*2*set r to the string-concatenation of r and separator.
*2*set r to the string-concatenation of r and s.
*0*set indent to the string-concatenation of indent and gap.
*2*set member to the string-concatenation of member and strp.
*0*set indent to the string-concatenation of indent and gap.

VB NNP VB . NN ( NNP , NNP NNP NNP ) .
6
*1*let targetobj be ? typedarraycreate(c, « len »).
*0*let targetobj be ? typedarraycreate(c, « len »).
*0*let newobj be ? typedarraycreate(c, « len »).
*0*let a be ? typedarrayspeciescreate(o, « captured »).
*0*let a be ? typedarrayspeciescreate(o, « len »).
*0*let a be ? typedarrayspeciescreate(o, « count »).

VBN NN TO NNP NNP NNP .
6
*1*set targetbyteindex to targetbyteindex + targetelementsize.
*1*set targetbyteindex to targetbyteindex + targetelementsize.
*2*set srcbyteindex to srcbyteindex + srcelementsize.
*2*set targetbyteindex to targetbyteindex + targetelementsize.
*2*set srcbyteindex to srcbyteindex + srcelementsize.
*2*set targetbyteindex to targetbyteindex + elementsize.

VB NNP VB DT NN NN IN DT NN NN NN VBN IN JJ CD IN NN NN NNP .
6
*0*let elementsize be the number value of the element size value specified in table 56 for element type type.
*0*let elementsize be the number value of the element size value specified in table 56 for element type type.
*0*let elementsize be the number value of the element size value specified in table 56 for element type type.
*0*let elementsize be the number value of the element size value specified in table 56 for element type type.
*0*let elementsize be the number value of the element size value specified in table 56 for element type type.
*0*let elementsize be the number value of the element size value specified in table 56 for element type type.

NN : DT VBG NN VBZ IN DT JJ NN IN NNP .
6
*0*assert: the calling agent is in the critical section for wl.
*0*assert: the calling agent is in the critical section for wl.
*0*assert: the calling agent is in the critical section for wl.
*0*assert: the calling agent is in the critical section for wl.
*0*assert: the calling agent is in the critical section for wl.
*0*assert: the calling agent is in the critical section for wl.

NN : NNP VBZ DT NN NN .
5
*0*assert: base is an environment record.
*0*assert: desc is a property descriptor.
*0*assert: m is a module record.
*0*assert: realm is a realm record.
*0*assert: next is an asyncgeneratorrequest record.

VB NNP VB NNP ( NN IN NN ) .
5
*0*let obj be objectcreate(%objectprototype%).
*0*let obj be objectcreate(%objectprototype%).
*1*let root be objectcreate(%objectprototype%).
*0*let wrapper be objectcreate(%objectprototype%).
*0*let result be objectcreate(%objectprototype%).

VB NNP VB DT NNP NNP NNP NNP NNP NN IN DT VBG NN POS NN NN .
5
*0*let execution be the [[CANDIDATEEXECUTION]] field of the surrounding agent's agent record.
*2*let execution be the [[CANDIDATEEXECUTION]] field of the surrounding agent's agent record.
*1*let execution be the [[CANDIDATEEXECUTION]] field of the surrounding agent's agent record.
*1*let execution be the [[CANDIDATEEXECUTION]] field of the surrounding agent's agent record.
*0*let execution be the [[CANDIDATEEXECUTION]] field of the surrounding agent's agent record.

VB NNP VB DT NNP NNP NNP NNP NNP NN IN DT NN IN NNP . VB JJ NNP NNP NNP WP$ NNP NNP NNP NNP NNP VBZ NNP ( ) .
5
*0*let eventlist be the [[EVENTLIST]] field of the element in execution.[[EVENTLISTS]] whose [[AGENTSIGNIFIER]] is agentsignifier().
*2*let eventlist be the [[EVENTLIST]] field of the element in execution.[[EVENTLISTS]] whose [[AGENTSIGNIFIER]] is agentsignifier().
*1*let eventlist be the [[EVENTLIST]] field of the element in execution.[[EVENTLISTS]] whose [[AGENTSIGNIFIER]] is agentsignifier().
*1*let eventlist be the [[EVENTLIST]] field of the element in execution.[[EVENTLISTS]] whose [[AGENTSIGNIFIER]] is agentsignifier().
*0*let eventlist be the [[EVENTLIST]] field of the element in execution.[[EVENTLISTS]] whose [[AGENTSIGNIFIER]] is agentsignifier().

VB NNP TO NNP .
5
*2*append readevent to eventlist.
*1*append readevent to eventlist.
*0*append rmwevent to eventlist.
*0*append value to stack.
*0*append value to stack.

IN NNP VBZ JJ , VB DT NN `` JJ '' .
5
*0*if m is nan, return the string "nan".
*0*if x is nan, return the string "nan".
*0*if x is nan, return the string "nan".
*0*if x is nan, return the string "nan".
*0*if awoken is true, return the string "ok".

IN NNP ( NNP , NNP ) VBZ JJ , VB DT NN NN .
5
*1*if samevaluezero(integerindex, index) is false, throw a rangeerror exception.
*0*if samevalue(handlerproto, targetproto) is false, throw a typeerror exception.
*0*if samevalue(v, targetproto) is false, throw a typeerror exception.
*0*if samevalue(booleantrapresult, targetresult) is false, throw a typeerror exception.
*0*if samevalue(new, o) is true, throw a typeerror exception.

IN NNP . VB JJ NNP NNP NNP VBZ JJ , VB DT NN NN .
5
*1*if argument.[[PROXYHANDLER]] is null, throw a typeerror exception.
*1*if obj.[[PROXYHANDLER]] is null, throw a typeerror exception.
*1*if targetdesc.[[CONFIGURABLE]] is false, throw a typeerror exception.
*2*if targetdesc.[[CONFIGURABLE]] is false, throw a typeerror exception.
*0*if targetdesc.[[CONFIGURABLE]] is false, throw a typeerror exception.

IN NNP ( NNP ) VBZ RB NN , NN JJ .
5
*0*if type(argument) is not number, return false.
*0*if type(number) is not number, return false.
*0*if type(number) is not number, return false.
*0*if type(number) is not number, return false.
*0*if type(number) is not number, return false.

IN NNP VBZ JJ , JJ , CC NN , NN JJ .
5
*0*if argument is nan, +∞, or -∞, return false.
*0*if num is nan, +∞, or -∞, return false.
*0*if number is nan, +∞, or -∞, return false.
*0*if number is nan, +∞, or -∞, return false.
*0*if number is nan, +∞, or -∞, return false.

NN . NNP . VB NNP NNP NNP NNP ( NNP , NNP ) .
5
*0*return ? o.[[DEFINEOWNPROPERTY]](p, newdesc).
*0*return ? o.[[DEFINEOWNPROPERTY]](p, newdesc).
*2*return ? receiver.[[DEFINEOWNPROPERTY]](p, valuedesc).
*1*return ? target.[[DEFINEOWNPROPERTY]](p, desc).
*0*return ? target.[[DEFINEOWNPROPERTY]](key, desc).

NN . NNP . VB NNP NNP NNP NNP ( NNP ) .
5
*0*return ? o.[[HASPROPERTY]](p).
*1*return ? parent.[[HASPROPERTY]](p).
*1*return ? target.[[GETOWNPROPERTY]](p).
*1*return ? target.[[HASPROPERTY]](p).
*0*return ? target.[[HASPROPERTY]](key).

VB NNP VB . NNP ( CD ) .
5
*0*let array be ! arraycreate(0).
*0*let a be ! arraycreate(0).
*1*let a be ! arraycreate(0).
*0*let a be ! arraycreate(0).
*2*let a be ! arraycreate(0).

IN NNP ( NNP , NNP ) VBZ JJ , VB JJ .
5
*1*if samevalue(p, o) is true, return true.
*0*if samevalue(v, current) is true, return true.
*0*if samevalue(v, current) is true, return true.
*1*if samevalue(o, v) is true, return true.
*1*if samevaluezero(searchelement, elementk) is true, return true.

NN : NNP VBZ `` JJ '' .
5
*5*assert: kind is "key+value".
*1*assert: kind is "async".
*1*assert: itemkind is "key+value".
*3*assert: itemkind is "key+value".
*0*assert: state is "suspendedyield".

NN NNP ( NNP , `` NN '' , NNP ) .
5
*0*perform createdataproperty(obj, "value", value).
*1*return ordinarydefineownproperty(a, "length", desc).
*1*return ordinarydefineownproperty(a, "length", newlendesc).
*0*perform createdataproperty(result, "proxy", p).
*0*perform createdataproperty(result, "revoke", revoker).

NN NNP ( JJ , JJ ) .
5
*1*return createiterresultobject(undefined, true).
*1*return createiterresultobject(undefined, true).
*1*return createiterresultobject(undefined, true).
*0*return createiterresultobject(undefined, true).
*0*return createiterresultobject(undefined, true).

VB NNS VB DT NN NN IN NNP .
5
*0*let bindings be the binding object for envrec.
*0*let bindings be the binding object for envrec.
*0*let bindings be the binding object for envrec.
*0*let bindings be the binding object for envrec.
*0*let bindings be the binding object for envrec.

NN . NNP ( NNP , NNP , RB ) .
5
*0*return ? envrec.setmutablebinding(n, v, false).
*1*perform ! varenvrec.setmutablebinding(fn, fo, false).
*1*perform ? envrec.createglobalfunctionbinding(fn, fo, false).
*3*perform ! varenvrec.setmutablebinding(fn, fo, false).
*0*return ! asyncgeneratorresolve(generator, value, false).

NN . NNP ( NNP , NNP , NNP , NNP ) .
5
*0*return ? set(bindings, n, v, s).
*0*return ? ordinaryset(o, p, v, receiver).
*0*return ? ordinaryset(args, p, v, receiver).
*0*return ? ordinaryset(o, p, v, receiver).
*0*return ? atomicreadmodifywrite(typedarray, index, value, xor).

NN NNP ( NNP , NNP , NNP ) .
5
*1*return dclrec.setmutablebinding(n, v, s).
*0*perform setrealmglobalobject(realm, global, thisvalue).
*0*return ordinarydefineownproperty(a, p, desc).
*0*return rawbytestonumber(type, rawvalue, islittleendian).
*0*return rawbytestonumber(type, rawbytesread, islittleendian).

VBN NNP POS NN TO NNP .
5
*0*set env's environmentrecord to envrec.
*0*set env's environmentrecord to envrec.
*0*set env's environmentrecord to envrec.
*0*set env's environmentrecord to globalrec.
*0*set env's environmentrecord to envrec.

NN NNP ( `` NN '' , NN , NNP NNP , NNP NNP ) .
5
*2*perform enqueuejob("scriptjobs", scriptevaluationjob, « sourcetext, hostdefined »).
*2*perform enqueuejob("scriptjobs", toplevelmoduleevaluationjob, « sourcetext, hostdefined »).
*1*perform enqueuejob("promisejobs", promisereactionjob, « reaction, argument »).
*1*perform enqueuejob("promisejobs", promisereactionjob, « fulfillreaction, value »).
*1*perform enqueuejob("promisejobs", promisereactionjob, « rejectreaction, reason »).

NN NNP ( NNP , NNP , NNP , NNP , NNP ) .
5
*0*return validateandapplypropertydescriptor(o, p, extensible, desc, current).
*0*return ordinarysetwithowndescriptor(o, p, v, receiver, owndesc).
*0*return functioninitialize(f, kind, parameterlist, body, scope).
*0*return functioninitialize(f, kind, parameterlist, body, scope).
*0*return getmodifysetvalueinbuffer(buffer, indexedposition, elementtype, v, op).

IN NNP ( NNP ) VBZ RB JJ , RB
5
*0*if type(proto) is not object, then
*1*if type(nextitem) is not object, then
*1*if type(nextitem) is not object, then
*0*if type(returnresult) is not object, then
*0*if type(throwresult) is not object, then

VBN NNP . VB JJ NNP NNP NNP TO `` VB '' .
5
*1*set f.[[CONSTRUCTORKIND]] to "base".
*0*set generator.[[GENERATORSTATE]] to "suspendedstart".
*0*set generator.[[GENERATORSTATE]] to "suspendedyield".
*0*set generator.[[ASYNCGENERATORSTATE]] to "suspendedstart".
*0*set generator.[[ASYNCGENERATORSTATE]] to "suspendedyield".

IN NN IN NNP VBZ JJ , RB
5
*2*if isconstantdeclaration of d is true, then
*2*if isconstantdeclaration of d is true, then
*2*if isconstantdeclaration of d is true, then
*2*if isconstantdeclaration of d is true, then
*2*if isconstantdeclaration of d is true, then

VB NNP VB DT NN IN VBG NN IN NNP IN NN NNP .
5
*1*let fo be the result of performing instantiatefunctionobject for f with argument lexenv.
*2*let fo be the result of performing instantiatefunctionobject for d with argument env.
*1*let fo be the result of performing instantiatefunctionobject for f with argument env.
*3*let fo be the result of performing instantiatefunctionobject for d with argument env.
*1*let fo be the result of performing instantiatefunctionobject for f with argument lexenv.

NN , IN NNP CC NN : NNP ,
5
*0*repeat, while newlen &lt; oldlen,
*0*repeat, while index &lt; len,
*0*repeat, while index &lt; len,
*2*repeat, while i &lt; len,
*3*repeat, while k&lt;len,

NN . NNP ( NNP , `` NN '' , NNP ) .
5
*2*perform ! ordinarydefineownproperty(a, "length", newlendesc).
*1*perform ! definepropertyorthrow(o, "message", msgdesc).
*1*perform ! definepropertyorthrow(o, "message", msgdesc).
*0*perform ! createdataproperty(a, "index", lastindex).
*0*perform ! createdataproperty(a, "input", s).

VB NNP VB DT NNS VBP .
5
*0*let args be the arguments object.
*0*let args be the arguments object.
*0*let args be the arguments object.
*0*let args be the arguments object.
*0*let args be the arguments object.

NN NNP ( NNP , NNP , NNP , NNP , JJ , `` JJ '' ) .
5
*0*perform setvalueinbuffer(buffer, indexedposition, elementtype, numvalue, true, "unordered").
*1*perform setvalueinbuffer(targetbuffer, targetbyteindex, targettype, knumber, true, "unordered").
*1*perform setvalueinbuffer(targetbuffer, targetbyteindex, targettype, knumber, true, "unordered").
*2*perform setvalueinbuffer(targetbuffer, targetbyteindex, targettype, value, true, "unordered").
*2*perform setvalueinbuffer(data, targetbyteindex, elementtype, value, true, "unordered").

NN . NNP . VB JJ NNP NNP NNP ( NNP ) .
5
*1*return ? target.[[SETPROTOTYPEOF]](v).
*1*return ? target.[[DELETE]](p).
*4*perform ? val.[[DELETE]](p).
*0*return ? target.[[DELETE]](key).
*0*return ? target.[[SETPROTOTYPEOF]](proto).

NN NNP ( NNP , `` JJ '' ) .
5
*0*perform setintegritylevel(rawobj, "frozen").
*0*perform setintegritylevel(template, "frozen").
*0*perform setfunctionname(f, "anonymous").
*0*return createarrayiterator(o, "key").
*0*return createarrayiterator(o, "key").

NN : NNP VBZ DT NN .
5
*1*assert: lhs is a lefthandsideexpression.
*2*assert: lhs is a fordeclaration.
*3*assert: lhs is a forbinding.
*3*assert: lhs is a fordeclaration.
*2*assert: r is a state.

VB DT JJ NN IN NNP .
5
*2*remove the last element of stack.
*2*remove the last element of stack.
*0*leave the critical section for wl.
*0*remove the last element of stack.
*0*remove the last element of stack.

IN NNP VBZ DT JJ NN NN , RB
5
*1*if varenvrec is a global environment record, then
*3*if varenvrec is a global environment record, then
*4*if varenvrec is a global environment record, then
*1*if varenvrec is a global environment record, then
*1*if varenvrec is a global environment record, then

IN DT VBZ JJ , VB NNP VB DT JJ NN NN , RB VB NNP VB VBN .
5
*0*if newtarget is undefined, let newtarget be the active function object, else let newtarget be newtarget.
*0*if newtarget is undefined, let newtarget be the active function object, else let newtarget be newtarget.
*0*if newtarget is undefined, let newtarget be the active function object, else let newtarget be newtarget.
*0*if newtarget is undefined, let newtarget be the active function object, else let newtarget be newtarget.
*0*if newtarget is undefined, let newtarget be the active function object, else let newtarget be newtarget.

RB , VB NNP VB . NNP ( NNP ) .
5
*0*else, let n be ? tonumber(value).
*0*else, let radixnumber be ? tointeger(radix).
*0*else, let p be ? tostring(pattern).
*0*else, let f be ? tostring(flags).
*0*else, let sep be ? tostring(separator).

IN NNP CC NN : CD CC NNP CC NN : CD , VBP DT NN NN .
5
*0*if f &lt; 0 or f &gt; 100, throw a rangeerror exception.
*0*if f &lt; 0 or f &gt; 100, throw a rangeerror exception.
*0*if p &lt; 1 or p &gt; 100, throw a rangeerror exception.
*0*if radixnumber &lt; 2 or radixnumber &gt; 36, throw a rangeerror exception.
*1*if nextcp &lt; 0 or nextcp &gt; 0x10ffff, throw a rangeerror exception.

VB NNP VB NNP : NN .
5
*0*let start be end - searchlength.
*0*let filllen be intmaxlength - stringlength.
*0*let filllen be intmaxlength - stringlength.
*1*let newbytelength be bufferbytelength - offset.
*1*let viewbytelength be bufferbytelength - offset.

IN NNP NNP NNP , NN NNP .
5
*3*if lengtha = lim, return a.
*0*if index+1 ≥ length, return index+1.
*0*if nextsourceposition ≥ lengths, return accumulatedresult.
*3*if lengtha = lim, return a.
*4*if lengtha = lim, return a.

VB NNP VB VBN ( NNP , NNP ) .
5
*0*let from be min(finalstart, finalend).
*0*let to be max(finalstart, finalend).
*1*let index be min(e, f).
*1*let g be min(e, f).
*2*let e be min(e, size).

RB NNP IN DT JJ NN IN NNS .
5
*2*append capn as the last element of captures.
*0*append p as the last element of entries.
*0*append value as the last element of entries.
*0*append p as the last element of entries.
*0*append value as the last element of entries.

VB NNP VB . NNP ( NNP , NNP NNP NNP ) .
5
*1*let a be ? construct(c, « len »).
*1*let a be ? construct(c, « len »).
*0*let new be ? construct(ctor, « newlen »).
*0*let new be ? construct(ctor, « newlen »).
*0*let promise be ? construct(c, « executor »).

IN NNP NNP NNP CC NN : NNP , VBP DT NN NN .
5
*0*if srclength + targetoffset &gt; targetlength, throw a rangeerror exception.
*0*if srclength + targetoffset &gt; targetlength, throw a rangeerror exception.
*0*if srclength + targetoffset &gt; targetlength, throw a rangeerror exception.
*0*if getindex + elementsize &gt; viewsize, throw a rangeerror exception.
*0*if getindex + elementsize &gt; viewsize, throw a rangeerror exception.

VB NNP VB DT VBG NN IN DT NN NN NN VBN IN JJ CD IN DT NNP NN .
5
*0*let constructorname be the string value of the constructor name value specified in table 56 for this typedarray constructor.
*0*let constructorname be the string value of the constructor name value specified in table 56 for this typedarray constructor.
*0*let constructorname be the string value of the constructor name value specified in table 56 for this typedarray constructor.
*0*let constructorname be the string value of the constructor name value specified in table 56 for this typedarray constructor.
*0*let constructorname be the string value of the constructor name value specified in table 56 for this typedarray constructor.

VB NNP IN DT NN NN NN CC VB DT NN NN WDT VBZ IN DT NN IN DT NN NN NN IN DT VBG NN NN .
5
*1*remove gencontext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
*0*remove gencontext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
*1*remove gencontext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
*0*remove gencontext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
*1*remove asynccontext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.

IN NNP VBZ DT JJ NN NNP NNP NNP NN , RB
4
*0*if desc has a [[WRITABLE]] field, then
*0*if desc has a [[SET]] field, then
*0*if desc has an [[ENUMERABLE]] field, then
*0*if desc has a [[CONFIGURABLE]] field, then

NN : NNP NNP NNP .
4
*0*assert: fromindex+count ≤ fromsize.
*0*assert: toindex+count ≤ tosize.
*0*assert: position ≤ stringlength.
*0*assert: i ≤ j.

NN , IN NNP CC NN : CD
4
*0*repeat, while count&gt;0
*0*repeat, while count &gt; 0
*1*repeat, while countbytes &gt; 0
*1*repeat, while count &gt; 0

VB NNP VB . NNP ( NNP , NNP , NNP NNP NNP ) .
4
*2*let result be ? call(exotictoprim, input, « hint »).
*0*let handlerproto be ? call(trap, handler, « target »).
*0*let trapresultarray be ? call(trap, handler, « target »).
*1*let result be ? call(exec, r, « s »).

VB NNP VB . NNP ( NNP , NN NN ) .
4
*0*let primvalue be ? toprimitive(argument, hint number).
*0*let primvalue be ? toprimitive(argument, hint string).
*0*let key be ? toprimitive(argument, hint string).
*0*let tv be ? toprimitive(o, hint number).

IN NNP ( NNP ) VBZ JJ , VB JJ .
4
*0*if type(argument) is symbol, return true.
*0*if type(x) is undefined, return true.
*0*if type(x) is null, return true.
*0*if dclrec.hasbinding(n) is true, return true.

IN NNP VBZ JJ CC NNP VBZ JJ , VB JJ .
4
*1*if x is nan and y is nan, return true.
*1*if x is nan and y is nan, return true.
*1*if x is +0 and y is -0, return true.
*1*if x is -0 and y is +0, return true.

VB NNP VB DT NN ( JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) .
4
*0*let newdesc be the propertydescriptor { [[VALUE]]: v, [[WRITABLE]]: true, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: true }.
*0*let newdesc be the propertydescriptor { [[VALUE]]: v, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }.
*1*let msgdesc be the propertydescriptor { [[VALUE]]: msg, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }.
*1*let msgdesc be the propertydescriptor { [[VALUE]]: msg, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }.

VB NNP VB . NNP ( NNP , NNP , NNP ) .
4
*0*let success be ? createdataproperty(o, p, v).
*1*let succeeded be ! ordinarydefineownproperty(a, p, desc).
*0*let allowed be ? ordinarydefineownproperty(args, p, newargdesc).
*0*let f be ? boundfunctioncreate(target, thisarg, args).

IN NNP VBZ RB JJ , VBN NNP TO DT JJ JJ NN .
4
*0*if argumentslist is not present, set argumentslist to a new empty list.
*0*if argumentslist is not present, set argumentslist to a new empty list.
*0*if argumentslist is not present, set argumentslist to a new empty list.
*0*if internalslotslist is not present, set internalslotslist to a new empty list.

NN VBD TO JJ .
4
*3*set excluded to true.
*2*set matchsucceeded to true.
*1*set onfulfilled to undefined.
*1*set onrejected to undefined.

IN NNP VBZ RB JJ , VBN NNP TO VB .
4
*0*if hint is not present, set hint to sync.
*0*if iteratorkind is not present, set iteratorkind to sync.
*0*if key is not present, set key to undefined.
*0*if onlyint32 is not present, set onlyint32 to false.

NN . NNP ( NNP , `` NN '' ) .
4
*0*return ? get(iterresult, "value").
*0*return ? get(result, "index").
*0*return ? createmapiterator(m, "value").
*0*return ? createsetiterator(s, "value").

IN NNP . VB JJ NNP NNP NNP VBZ JJ , JJ NNP ( NNP ) .
4
*0*if completion.[[TYPE]] is throw, return completion(completion).
*0*if innerresult.[[TYPE]] is throw, return completion(innerresult).
*0*if completion.[[TYPE]] is throw, return completion(completion).
*0*if innerresult.[[TYPE]] is throw, return completion(innerresult).

IN VBN VBZ JJ , NN JJ .
4
*1*if blocked is true, return false.
*1*if succeeded is false, return false.
*0*if succeeded is false, return false.
*0*if allowed is false, return false.

IN NNP VBZ JJ , VB . NNP ( NNP ) .
4
*0*if existingprop is undefined, return ? isextensible(globalobject).
*0*if isarray is false, return ? arraycreate(length).
*0*if c is undefined, return ? arraycreate(length).
*1*if isarray is true, return ? serializejsonarray(value).

IN NNP . VB JJ NNP NNP NNP VBZ JJ , VB JJ .
4
*0*if existingprop.[[CONFIGURABLE]] is true, return true.
*0*if completion.[[TYPE]] is normal, return true.
*0*if completion.[[TARGET]] is empty, return true.
*0*if arraybuffer.[[ARRAYBUFFERDATA]] is null, return true.

NN NNP . VB JJ NNP NNP NNP ( NNP ) .
4
*0*call thrower.[[SETPROTOTYPEOF]](funcproto).
*2*call map.[[DELETE]](p).
*3*call map.[[DELETE]](p).
*1*call map.[[DELETE]](p).

VB NNP VB DT JJ NN NN POS NN .
4
*0*let lex be the running execution context's lexicalenvironment.
*1*let lastiterationenv be the running execution context's lexicalenvironment.
*0*let oldenv be the running execution context's lexicalenvironment.
*0*let oldenv be the running execution context's lexicalenvironment.

VB DT NN IN NNP TO VB .
4
*0*set the function of newcontext to null.
*0*set the scriptormodule of newcontext to null.
*0*set the function of scriptcxt to null.
*0*set the function of modulecxt to null.

VBN NNP POS JJ JJ NNS TO DT NN JJ JJ NNS VBN IN CD .
4
*0*set obj's essential internal methods to the default ordinary object definitions specified in 9.1.
*0*set f's essential internal methods to the default ordinary object definitions specified in 9.1.
*0*set obj's essential internal methods to the default ordinary object definitions specified in 9.1.
*0*set a's essential internal methods to the default ordinary object definitions specified in 9.1.

VB NNP VB . NNP ( NNP , `` NN JJ NN '' ) .
4
*1*let thisargument be ? ordinarycreatefromconstructor(newtarget, "%objectprototype%").
*0*let proto be ? getprototypefromconstructor(newtarget, "%arrayprototype%").
*0*let proto be ? getprototypefromconstructor(newtarget, "%arrayprototype%").
*0*let proto be ? getprototypefromconstructor(newtarget, "%arrayprototype%").

RB , VB NNP VB JJ .
4
*0*else, let needsconstruct be false.
*0*else, let settingconfigfalse be false.
*0*else, let unicodematching be false.
*0*else, let mapping be false.

NN . NNP ( NNP , `` NN '' , NN ( JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) ) .
4
*0*return ! definepropertyorthrow(f, "length", propertydescriptor { [[VALUE]]: length, [[WRITABLE]]: false, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }).
*0*perform ! ordinarydefineownproperty(a, "length", propertydescriptor { [[VALUE]]: length, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }).
*0*perform ! definepropertyorthrow(s, "length", propertydescriptor { [[VALUE]]: length, [[WRITABLE]]: false, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }).
*0*perform ! definepropertyorthrow(obj, "callee", propertydescriptor { [[VALUE]]: func, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }).

VB NNP VB NN IN NNS .
4
*0*let simpleparameterlist be issimpleparameterlist of formals.
*0*let hasparameterexpressions be containsexpression of formals.
*1*let arglist be argumentlistevaluation of arguments.
*0*let arglist be argumentlistevaluation of arguments.

IN DT NNP IN NNP , IN JJ NN NN , VBP
4
*0*for each d in vardeclarations, in reverse list order, do
*0*for each d in vardeclarations, in reverse list order, do
*0*for each d in vardeclarations, in reverse list order, do
*0*for each reaction in reactions, in original insertion order, do

JJ NNP IN DT JJ NN IN NNP .
4
*3*insert fn as the first element of functionnames.
*3*insert d as the first element of functionstoinitialize.
*3*insert d as the first element of functionstoinitialize.
*3*insert d as the first element of functionstoinitialize.

IN NNP VBZ JJ , VBN NNP TO VB .
4
*0*if length is -0, set length to +0.
*0*if length is -0, set length to +0.
*1*if c is null, set c to undefined.
*0*if clippedtime is -0, set clippedtime to +0.

NN NNP . VB JJ NNP NNP NNP TO NNP .
4
*0*set s.[[STRINGDATA]] to value.
*1*append i.[[LOCALNAME]] to localnames.
*3*set onfulfilled.[[GENERATOR]] to generator.
*3*set onrejected.[[GENERATOR]] to generator.

IN NNP VBZ JJ CC NNP VBZ JJ , RB
4
*0*if result is true and ismapped is true, then
*0*if extensibletarget is true and targetnonconfigurablekeys is empty, then
*2*if global is true or sticky is true, then
*0*if global is true or sticky is true, then

VB NNP VB NNP : CD .
4
*0*let index be numberofparameters - 1.
*1*let index be index - 1.
*1*let count be count - 1.
*2*let countbytes be countbytes - 1.

IN NNP NNP NNP , NN JJ .
4
*2*if numericindex = -0, return false.
*2*if numericindex = -0, return false.
*2*if numericindex ≥ length, return false.
*0*if index = -0, return false.

IN NNP ( NNP ) VBZ DT JJ CC JJ , VB DT NN NN .
4
*0*if type(handlerproto) is neither object nor null, throw a typeerror exception.
*0*if type(trapresultobj) is neither object nor undefined, throw a typeerror exception.
*0*if type(o) is neither object nor null, throw a typeerror exception.
*0*if type(proto) is neither object nor null, throw a typeerror exception.

VB NNP VB . NNP ( NNP , NNP , NNP NNP , NNP NNP ) .
4
*0*let trapresultobj be ? call(trap, handler, « target, p »).
*2*let mappedvalue be ? call(mapfn, t, « kvalue, k »).
*3*let mappedvalue be ? call(mapfn, t, « kvalue, k »).
*2*let mappedvalue be ? call(mapfn, t, « kvalue, k »).

VB NNP VB . NNP ( NNP , NNP , NNP NNP , NNP , NNP NNP ) .
4
*0*let trapresult be ? call(trap, handler, « target, p, receiver »).
*0*let newobj be ? call(trap, handler, « target, argarray, newtarget »).
*2*let mappedvalue be ? call(callbackfn, t, « kvalue, k, o »).
*1*let mappedvalue be ? call(callbackfn, t, « kvalue, k, o »).

NN : NNP ( ) VBZ JJ .
4
*0*assert: env.hassuperbinding() is true.
*0*assert: agentcansuspend() is true.
*0*assert: getgeneratorkind() is sync.
*0*assert: getgeneratorkind() is async.

NN : NNP VBZ DT JJ NN NN ( VB RB CD ) .
4
*0*assert: sourcetext is an ecmascript source text (see clause 10).
*0*assert: sourcetext is an ecmascript source text (see clause 10).
*0*assert: sourcetext is an ecmascript source text (see clause 10).
*0*assert: sourcetext is an ecmascript source text (see clause 10).

RB NNP TO NNP .
4
*3*append ee to localexportentries.
*4*append ee to localexportentries.
*2*append ee to starexportentries.
*2*append ee to indirectexportentries.

NN : NNP VBZ RB JJ .
4
*0*assert: realm is not undefined.
*0*assert: tv is not nan.
*0*assert: tv is not nan.
*0*assert: tv is not nan.

NN . NNS ( NNP , NNP ) .
4
*0*perform ? hostensurecancompilestrings(callerrealm, calleerealm).
*1*return ? objectdefineproperties(obj, properties).
*0*return ? objectdefineproperties(o, properties).
*0*perform ? hostensurecancompilestrings(callerrealm, calleerealm).

RB NNP NNP CD ,
4
*0*else r = 0,
*0*else x ≠ 0,
*1*else e ≤ 0,
*0*else x ≠ 0,

VBN NNP TO DT NN IN DT JJ NN IN NNP CC NNP .
4
*2*set r to the string-concatenation of the previous value of r and s.
*3*set r to the string-concatenation of the previous value of r and s.
*1*set r to the string-concatenation of the previous value of r and s.
*1*set r to the string-concatenation of the previous value of r and nextstring.

RB IN NNP VBZ DT JJ NN NNP NNP NNP JJ NN , VB NNP VB `` NN '' .
4
*0*else if o has a [[CALL]] internal method, let builtintag be "function".
*0*else if o has an [[ERRORDATA]] internal slot, let builtintag be "error".
*0*else if o has a [[NUMBERDATA]] internal slot, let builtintag be "number".
*0*else if o has a [[DATEVALUE]] internal slot, let builtintag be "date".

VB NNP VB DT NNP WDT VBD VBN TO DT NN IN NNP NNP NNP NNP NNP CC NNP NNP NNP NNP NNP .
4
*0*let args be the argumentslist that was passed to this function by [[CALL]] or [[CONSTRUCT]].
*0*let args be the argumentslist that was passed to this function by [[CALL]] or [[CONSTRUCT]].
*0*let args be the argumentslist that was passed to this function by [[CALL]] or [[CONSTRUCT]].
*0*let args be the argumentslist that was passed to this function by [[CALL]] or [[CONSTRUCT]].

VB NNP VB DT NN NN NNS VBP NNP , NNP NNP .
4
*1*let parametergoal be the grammar symbol formalparameters[~yield, ~await].
*1*let parametergoal be the grammar symbol formalparameters[+yield, ~await].
*1*let parametergoal be the grammar symbol formalparameters[~yield, +await].
*1*let parametergoal be the grammar symbol formalparameters[+yield, +await].

VB NNP ( ) .
4
*1*perform preparefortailcall().
*0*perform preparefortailcall().
*0*perform preparefortailcall().
*0*perform preparefortailcall().

NN . NN ( DT NN ) .
4
*0*return ? thisbooleanvalue(this value).
*0*return ? thistimevalue(this value).
*0*perform ? thistimevalue(this value).
*0*return ? thistimevalue(this value).

IN NNP VBZ DT JJ NN , NN NNP .
4
*0*if name is the empty string, return msg.
*0*if msg is the empty string, return name.
*0*if filler is the empty string, return s.
*0*if filler is the empty string, return s.

VB NNP VB DT VBG NN NN IN DT NNS IN DT JJ NN IN NNP ( IN NN , IN DT VBG NNS ) .
4
*1*let m be the string value consisting of the digits of the decimal representation of n (in order, with no leading zeroes).
*1*let d be the string value consisting of the digits of the decimal representation of e (in order, with no leading zeroes).
*1*let m be the string value consisting of the digits of the decimal representation of n (in order, with no leading zeroes).
*2*let d be the string value consisting of the digits of the decimal representation of e (in order, with no leading zeroes).

IN DT VBZ JJ , RB
4
*0*if newtarget is undefined, then
*0*if newtarget is undefined, then
*0*if newtarget is undefined, then
*0*if newtarget is undefined, then

IN NNP VBZ JJ , VB NNP VB . NNP ( NNP ) : JJ NN NNP VB CD .
4
*1*if date is present, let dt be ? tonumber(date); else let dt be 1.
*1*if seconds is present, let s be ? tonumber(seconds); else let s be 0.
*0*if date is present, let dt be ? tonumber(date); else let dt be 1.
*0*if seconds is present, let s be ? tonumber(seconds); else let s be 0.

IN NNP VBZ JJ , VB `` JJ NN '' .
4
*0*if tv is nan, return "invalid date".
*0*if tv is nan, return "invalid date".
*0*if tv is nan, return "invalid date".
*0*if tv is nan, return "invalid date".

VB NNP VB DT NN IN DT NN IN JJ CD IN DT NN NN ( NNP ) .
4
*0*let weekday be the name of the entry in table 46 with the number weekday(tv).
*0*let month be the name of the entry in table 47 with the number monthfromtime(tv).
*0*let weekday be the name of the entry in table 46 with the number weekday(tv).
*0*let month be the name of the entry in table 47 with the number monthfromtime(tv).

IN NNP VBZ DT JJ CC JJ , RB
4
*0*if regexp is neither undefined nor null, then
*0*if searchvalue is neither undefined nor null, then
*0*if regexp is neither undefined nor null, then
*0*if separator is neither undefined nor null, then

VB NNP VB VBN ( NNP : NNP , CD ) .
4
*0*let span be max(to - from, 0).
*0*let count be max(final - k, 0).
*0*let count be max(final - k, 0).
*0*let newlen be max(final - first, 0).

NN . NNP ( NNP , `` CD '' , NNP ) .
4
*1*perform ! createdataproperty(a, "0", s).
*1*perform ! createdataproperty(a, "0", s).
*0*perform ! createdataproperty(a, "0", matchedsubstr).
*1*perform ! createdataproperty(a, "0", s).

IN NNP VBZ RB VB DT IN DT JJ NNS IN DT NN NN NN ( CD ) , VBP DT NN NN .
4
*0*if o does not have all of the internal slots of a string iterator instance (21.1.5.3), throw a typeerror exception.
*0*if o does not have all of the internal slots of an array iterator instance (22.1.5.3), throw a typeerror exception.
*0*if o does not have all of the internal slots of a map iterator instance (23.1.5.3), throw a typeerror exception.
*0*if o does not have all of the internal slots of a set iterator instance (23.2.5.3), throw a typeerror exception.

IN NNP VBZ JJ , VB NNP ( JJ , JJ ) .
4
*0*if s is undefined, return createiterresultobject(undefined, true).
*0*if a is undefined, return createiterresultobject(undefined, true).
*0*if m is undefined, return createiterresultobject(undefined, true).
*0*if s is undefined, return createiterresultobject(undefined, true).

NN NNP ( NNP , RB ) .
4
*0*return createiterresultobject(resultstring, false).
*0*return createiterresultobject(result, false).
*2*return createiterresultobject(result, false).
*2*return createiterresultobject(e, false).

VB NNP VB NNP NNP NNP : CD .
4
*1*let from be from + count - 1.
*1*let to be to + count - 1.
*2*let frombyteindex be frombyteindex + countbytes - 1.
*2*let tobyteindex be tobyteindex + countbytes - 1.

NN . NNP ( NNP , . NNP ( NNP ) , NNP , JJ ) .
4
*1*perform ? set(o, ! tostring(len), e, true).
*1*perform ? set(o, ! tostring(k), e, true).
*2*perform ? set(o, ! tostring(j), e, true).
*1*perform ! set(a, ! tostring(n), e, true).

IN NNP ( NNP . VB JJ NNP NNP NNP ) VBZ JJ , VB DT NN NN .
4
*1*if isdetachedbuffer(a.[[VIEWEDARRAYBUFFER]]) is true, throw a typeerror exception.
*0*if isdetachedbuffer(o.[[VIEWEDARRAYBUFFER]]) is true, throw a typeerror exception.
*0*if iscallable(promisecapability.[[RESOLVE]]) is false, throw a typeerror exception.
*0*if iscallable(promisecapability.[[REJECT]]) is false, throw a typeerror exception.

IN NNP VBZ RB JJ , VB NNP VB VBN .
4
*0*if iterable is not present, let iterable be undefined.
*0*if iterable is not present, let iterable be undefined.
*0*if iterable is not present, let iterable be undefined.
*0*if iterable is not present, let iterable be undefined.

VB NNP VB NNP ( NNP , `` CD '' ) .
4
*1*let k be get(nextitem, "0").
*1*let v be get(nextitem, "1").
*1*let k be get(nextitem, "0").
*1*let v be get(nextitem, "1").

IN NNP . VB JJ NNP NNP NNP VBZ RB JJ CC NNP ( NNP . VB JJ NNP NNP NNP , NNP ) VBZ JJ , RB
4
*1*if p.[[KEY]] is not empty and samevaluezero(p.[[KEY]], key) is true, then
*1*if p.[[KEY]] is not empty and samevaluezero(p.[[KEY]], key) is true, then
*1*if p.[[KEY]] is not empty and samevalue(p.[[KEY]], key) is true, then
*1*if p.[[KEY]] is not empty and samevalue(p.[[KEY]], key) is true, then

IN NNP VBZ RB JJ CC NNP ( NNP , NNP ) VBZ JJ , RB
4
*1*if e is not empty and samevaluezero(e, value) is true, then
*1*if e is not empty and samevaluezero(e, value) is true, then
*1*if e is not empty and samevalue(e, value) is true, then
*1*if e is not empty and samevalue(e, value) is true, then

NN . NNP ( NNP , NNP , NNP , `` NN '' ) .
4
*0*return ? getviewvalue(v, byteoffset, littleendian, "float32").
*0*return ? getviewvalue(v, byteoffset, littleendian, "float64").
*0*return ? getviewvalue(v, byteoffset, littleendian, "int16").
*0*return ? getviewvalue(v, byteoffset, littleendian, "int32").

NN . NNP ( NNP , NNP , NNP , `` NN '' , NNP ) .
4
*0*return ? setviewvalue(v, byteoffset, littleendian, "float32", value).
*0*return ? setviewvalue(v, byteoffset, littleendian, "float64", value).
*0*return ? setviewvalue(v, byteoffset, littleendian, "int16", value).
*0*return ? setviewvalue(v, byteoffset, littleendian, "int32", value).

IN NNP ( NNP ) VBZ RB JJ , CC IN NNP VBZ RB VB DT JJ NN NNP NNP NNP JJ NN , RB
4
*0*if type(o) is not object, or if o does not have a [[SYNCITERATORRECORD]] internal slot, then
*0*if type(o) is not object, or if o does not have a [[SYNCITERATORRECORD]] internal slot, then
*0*if type(o) is not object, or if o does not have a [[SYNCITERATORRECORD]] internal slot, then
*0*if type(generator) is not object, or if generator does not have an [[ASYNCGENERATORSTATE]] internal slot, then

VB NNP VB DT RB VBN NN NN .
4
*1*let invaliditeratorerror be a newly created typeerror object.
*1*let invaliditeratorerror be a newly created typeerror object.
*1*let invaliditeratorerror be a newly created typeerror object.
*1*let badgeneratorerror be a newly created typeerror object.

NN : WRB PRP VBP RB , NNP VBZ RB VBN VBN IN DT NN NN NN CC NNP VBZ DT RB VBG NN NN .
4
*0*assert: when we return here, gencontext has already been removed from the execution context stack and methodcontext is the currently running execution context.
*0*assert: when we return here, gencontext has already been removed from the execution context stack and methodcontext is the currently running execution context.
*0*assert: when we return here, gencontext has already been removed from the execution context stack and callercontext is the currently running execution context.
*0*assert: when we return here, asynccontext has already been removed from the execution context stack and runningcontext is the currently running execution context.

NN . NNP ( NNP . VB JJ NNP NNP NNP , VBD , JJ NNP . CC JJ NNP NNP NNP NNP ) .
4
*3*perform ! call(promisecapability.[[RESOLVE]], undefined, « completion.[[VALUE]] »).
*1*perform ? call(resolvingfunctions.[[REJECT]], undefined, « completion.[[VALUE]] »).
*2*perform ! call(promisecapability.[[RESOLVE]], undefined, « result.[[VALUE]] »).
*2*perform ! call(promisecapability.[[REJECT]], undefined, « result.[[VALUE]] »).

IN NNP VBZ DT JJ NN , VBN NNP . NN IN NNP NNP NNP TO JJ .
4
*1*if next is an abrupt completion, set iteratorrecord.[[DONE]] to true.
*1*if nextvalue is an abrupt completion, set iteratorrecord.[[DONE]] to true.
*1*if next is an abrupt completion, set iteratorrecord.[[DONE]] to true.
*1*if nextvalue is an abrupt completion, set iteratorrecord.[[DONE]] to true.

NN .
3
*1*return.
*1*return.
*0*return.

NN NNP ( NNP , `` JJ '' , NNP . VB JJ NNP NNP NNP ) .
3
*1*perform createdataproperty(obj, "writable", desc.[[WRITABLE]]).
*1*perform createdataproperty(obj, "enumerable", desc.[[ENUMERABLE]]).
*1*perform createdataproperty(obj, "configurable", desc.[[CONFIGURABLE]]).

VB JJ VB . NNP ( NNP , `` JJ '' ) .
3
*0*let hasenumerable be ? hasproperty(obj, "enumerable").
*0*let hasconfigurable be ? hasproperty(obj, "configurable").
*0*let haswritable be ? hasproperty(obj, "writable").

IN NNP ( NNP ) VBZ JJ CC NNP ( NNP ) VBZ JJ , RB
3
*0*if isgenericdescriptor(desc) is true or isdatadescriptor(desc) is true, then
*1*if isgenericdescriptor(desc) is true or isdatadescriptor(desc) is true, then
*0*if type(value) is object and iscallable(value) is false, then

IN NNP VBZ RB VB DT JJ NN NNP NNP NNP NN , VBN NNP . VB JJ NNP NN NN TO NNP . VB JJ NNP NNP NNP .
3
*1*if desc does not have a [[WRITABLE]] field, set desc.[[WRITABLE]] to like.[[WRITABLE]].
*0*if desc does not have an [[ENUMERABLE]] field, set desc.[[ENUMERABLE]] to like.[[ENUMERABLE]].
*0*if desc does not have a [[CONFIGURABLE]] field, set desc.[[CONFIGURABLE]] to like.[[CONFIGURABLE]].

IN NNP VBD CD , NN NNP : CD : RB VB NNP .
3
*0*if int32bit ≥ 231, return int32bit - 232; otherwise return int32bit.
*0*if int16bit ≥ 215, return int16bit - 216; otherwise return int16bit.
*0*if int8bit ≥ 27, return int8bit - 28; otherwise return int8bit.

IN NNP NNP NNP , NN NN .
3
*0*if len ≤ +0, return +0.
*1*if sign = -1, return -0.
*0*if n ≥ len, return -1.

IN NNP VBZ DT JJ NN NNP NNP NNP JJ NN , NN JJ .
3
*0*if argument has a [[CALL]] internal method, return true.
*0*if argument has a [[REGEXPMATCHER]] internal slot, return true.
*0*if arg has a [[VIEWEDARRAYBUFFER]] internal slot, return true.

NN . NNP . VB JJ NNP NN NNP ( ) .
3
*0*return ? o.[[ISEXTENSIBLE]]().
*1*return ? target.[[ISEXTENSIBLE]]().
*0*return ? target.[[ISEXTENSIBLE]]().

IN NNP VBZ RB JJ CC JJ , JJ NNP .
3
*0*if s is either undefined or null, return defaultconstructor.
*0*if iterable is either undefined or null, return set.
*0*if iterable is either undefined or null, return set.

VB NNP VB . NNP ( NNP , NN , NNP ) .
3
*3*let synciteratorrecord be ? getiterator(obj, sync, syncmethod).
*1*let iteratorrecord be ? getiterator(items, sync, usingiterator).
*0*let iteratorrecord be ? getiterator(items, sync, method).

NN : NN VBZ RB RB VB DT NN IN NNP .
3
*0*assert: envrec does not already have a binding for n.
*0*assert: envrec does not already have a binding for n.
*0*assert: envrec does not already have a binding for n.

NN IN DT NN IN NNP IN NNP VBZ VBN VBN .
3
*0*record that the binding for n in envrec has been initialized.
*0*record that the binding for n in envrec has been initialized.
*0*record that the binding for n in objrec has been initialized.

NN . NNP ( NNP , VBD ) .
3
*1*perform ? objrec.initializebinding(n, undefined).
*3*perform ! envrec.initializebinding(paramname, undefined).
*3*perform ! varenvrec.initializebinding(vn, undefined).

VB DT JJ JJ NN NN IN NNP TO NNP .
3
*0*set the outer lexical environment reference of env to e.
*0*set the outer lexical environment reference of env to e.
*0*set the outer lexical environment reference of env to e.

NN NNS ( NNP ) .
3
*0*perform createintrinsics(realmrec).
*1*perform hostreporterrors(s).
*1*perform hostreporterrors(m).

VB NNP VB NNP ( NN ) .
3
*0*let objproto be objectcreate(null).
*0*let map be objectcreate(null).
*1*let groups be objectcreate(null).

VBN NNS . VB CD NN NNP NN NNP NNP TO NNP .
3
*0*set intrinsics.[[%OBJECTPROTOTYPE%]] to objproto.
*0*set intrinsics.[[%THROWTYPEERROR%]] to thrower.
*0*set intrinsics.[[%TIONPROTOTYPE%]] to funcproto.

NN NNS ( NNP , NNP ) .
3
*0*perform addrestrictedfunctionproperties(funcproto, realmrec).
*0*return triggerpromisereactions(reactions, value).
*0*return triggerpromisereactions(reactions, reason).

NN : NN VBZ RB JJ .
3
*1*assert: outer is not null.
*0*assert: targetmodule is not undefined.
*1*assert: outer is not null.

VB NNP VB DT NN NN IN DT VBG NN .
3
*0*let ar be the agent record of the surrounding agent.
*0*let ar be the agent record of the surrounding agent.
*0*let ar be the agent record of the surrounding agent.

NN : CC NNP ( NNP ) VBZ JJ CC NNP ( NNP ) VBZ JJ .
3
*0*assert: either type(v) is object or type(v) is null.
*0*assert: either type(v) is object or type(v) is null.
*0*assert: either type(v) is object or type(v) is null.

VB JJ VB NNP . VB JJ NNP NNP NNP .
3
*0*let extensible be o.[[EXTENSIBLE]].
*0*let extensible be o.[[EXTENSIBLE]].
*1*let extensible be s.[[EXTENSIBLE]].

NN , IN NNP VBZ JJ ,
3
*0*repeat, while done is false,
*1*repeat, while done is false,
*1*repeat, while done is false,

IN NNP VBZ JJ , VB NNP TO JJ .
3
*1*if p is null, set done to true.
*1*if result is null, set done to true.
*2*if global is false, set done to true.

VBN NNP . VB JJ NNP NN NN TO DT NN IN NNP POS NNP NNP NNP NNP NNP NN .
3
*1*set d.[[WRITABLE]] to the value of x's [[WRITABLE]] attribute.
*0*set d.[[ENUMERABLE]] to the value of x's [[ENUMERABLE]] attribute.
*0*set d.[[CONFIGURABLE]] to the value of x's [[CONFIGURABLE]] attribute.

NN . NNP . NN NN NNP NNP NNP ( NNP , NNP , NNP ) .
3
*2*return ? parent.[[SET]](p, v, receiver).
*1*return ? target.[[SET]](p, v, receiver).
*0*return ? target.[[SET]](key, v, receiver).

NN . NNP ( NNP , NNP , NNP NNP NNP ) .
3
*0*perform ? call(setter, receiver, « v »).
*2*return ? call(matcher, regexp, « o »).
*2*return ? call(searcher, regexp, « o »).

VB NNP IN DT NN NN NN CC VB NNP IN DT VBG NN NN .
3
*0*remove calleecontext from the execution context stack and restore callercontext as the running execution context.
*0*remove calleecontext from the execution context stack and restore callercontext as the running execution context.
*0*remove calleecontext from the execution context stack and restore callercontext as the running execution context.

IN NNP VBZ RB RB VBN , VBP NNP .
3
*0*if callercontext is not already suspended, suspend callercontext.
*0*if callercontext is not already suspended, suspend callercontext.
*0*if ctx is not already suspended, suspend ctx.

IN NNP VBZ JJ CC JJ , RB
3
*1*if thisargument is undefined or null, then
*1*if exprvalue is undefined or null, then
*0*if argarray is undefined or null, then

IN NNP . VB JJ NNP NNP NNP VBZ NN , RB
3
*0*if result.[[TYPE]] is return, then
*1*if abruptcompletion.[[TYPE]] is return, then
*2*if completion.[[TYPE]] is return, then

NN : NNP VBZ DT JJ NN WDT VBZ RB VB DT NN JJ NN .
3
*0*assert: f is an extensible object that does not have a prototype own property.
*0*assert: f is an extensible object that does not have a name own property.
*0*assert: f is an extensible object that does not have a length own property.

IN NNP VBZ CC DT NN CC DT NN CC DT NN , RB
3
*1*if d is neither a variabledeclaration nor a forbinding nor a bindingidentifier, then
*1*if d is neither a variabledeclaration nor a forbinding nor a bindingidentifier, then
*1*if d is neither a variabledeclaration nor a forbinding nor a bindingidentifier, then

NN : NNP VBZ CC DT NN , DT NN , DT NN , CC DT NN .
3
*2*assert: d is either a functiondeclaration, a generatordeclaration, an asyncfunctiondeclaration, or an asyncgeneratordeclaration.
*2*assert: d is either a functiondeclaration, a generatordeclaration, an asyncfunctiondeclaration, or an asyncgeneratordeclaration.
*2*assert: d is either a functiondeclaration, a generatordeclaration, an asyncfunctiondeclaration, or an asyncgeneratordeclaration.

NN : IN EX VBP JJ NN NNS IN DT JJ NN , DT JJ NN VBZ VBN .
3
*3*note: if there are multiple function declarations for the same name, the last declaration is used.
*2*note: if there are multiple function declarations for the same name, the last declaration is used.
*2*note: if there are multiple function declarations for the same name, the last declaration is used.

NN VBD TO VB .
3
*1*set argumentsobjectneeded to false.
*1*set argumentsobjectneeded to false.
*2*set argumentsobjectneeded to false.

RB IN NNP VBZ JJ , RB
3
*0*else if hasparameterexpressions is false, then
*0*else if patternisregexp is true, then
*1*else if fullunicode is true, then

NN : NN NN VBZ JJ NNS IN DT NN .
3
*0*note: annex b.3.3.1 adds additional steps at this point.
*0*note: annex b.3.3.2 adds additional steps at this point.
*0*note: annex b.3.3.3 adds additional steps at this point.

VB NNP VB DT RB VBN NN .
3
*0*let obj be a newly created object.
*0*let m be a newly created object.
*0*let p be a newly created object.

VB NNP VB NNP ( NNP , `` NN '' ) .
3
*1*let oldlendesc be ordinarygetownproperty(a, "length").
*0*let oldlendesc be ordinarygetownproperty(a, "length").
*0*let return be getmethod(synciterator, "return").

IN NNP CC NN : JJ , VB DT NN NN .
3
*0*if length&gt;232-1, throw a rangeerror exception.
*0*if len+insertcount-actualdeletecount &gt; 253-1, throw a typeerror exception.
*1*if len+argcount &gt; 253-1, throw a typeerror exception.

IN NNP NNP NNP , VBP DT NN NN .
3
*0*if newlen ≠ numberlen, throw a rangeerror exception.
*1*if intlen ≠ len, throw a rangeerror exception.
*0*if accessindex ≥ length, throw a rangeerror exception.

IN NNP CC NN : CD CC NNP NNP NNP , NN VBD .
3
*0*if index &lt; 0 or len ≤ index, return undefined.
*0*if index &lt; 0 or index ≥ length, return undefined.
*0*if position &lt; 0 or position ≥ size, return undefined.

IN NNP CC NN : NNP , RB
3
*2*if index &lt; len, then
*1*if lastindex &gt; length, then
*0*if itemcount &lt; actualdeletecount, then

IN NNP VBZ DT JJ NN NNP NNP NNP NN CC IN NNP . VB JJ NNP NNP NNP VBZ JJ , NN JJ .
3
*2*if desc has a [[CONFIGURABLE]] field and if desc.[[CONFIGURABLE]] is true, return false.
*2*if desc has an [[ENUMERABLE]] field and if desc.[[ENUMERABLE]] is false, return false.
*2*if desc has a [[WRITABLE]] field and if desc.[[WRITABLE]] is false, return false.

NN : NNP VBZ DT NN WDT VBZ VBN NNP NNP NNP NNP , NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP , CC NNP NNP NNP NNP NNP JJ NNS .
3
*0*assert: o is an object that has [[VIEWEDARRAYBUFFER]], [[ARRAYLENGTH]], [[BYTEOFFSET]], and [[TYPEDARRAYNAME]] internal slots.
*0*assert: o is an object that has [[VIEWEDARRAYBUFFER]], [[ARRAYLENGTH]], [[BYTEOFFSET]], and [[TYPEDARRAYNAME]] internal slots.
*0*assert: o is an object that has [[VIEWEDARRAYBUFFER]], [[ARRAYLENGTH]], [[BYTEOFFSET]], and [[TYPEDARRAYNAME]] internal slots.

VB NNP VB NNP ( . NNP ( NNP , NNP , NNP NNP , NNP NNP ) ) .
3
*0*let booleantrapresult be toboolean(? call(trap, handler, « target, v »)).
*0*let booleantrapresult be toboolean(? call(trap, handler, « target, p »)).
*0*let booleantrapresult be toboolean(? call(trap, handler, « target, p »)).

VB NNP VB . NNP ( NNP , `` NNS '' ) .
3
*0*let trap be ? getmethod(handler, "preventextensions").
*0*let trap be ? getmethod(handler, "ownkeys").
*2*let f be ? get(pattern, "flags").

IN DT NNP WDT VBZ DT NN IN NNP , VBP
3
*0*for each key that is an element of targetnonconfigurablekeys, do
*0*for each key that is an element of targetconfigurablekeys, do
*1*for each name that is an element of exportednames, do

VB NNP IN NNP .
3
*1*remove key from uncheckedresultkeys.
*1*remove key from uncheckedresultkeys.
*1*remove w from s.

NN . NNP ( NNP , NNP , NNP NNP , NNP , NNP NNP ) .
3
*0*return ? call(trap, handler, « target, thisargument, argarray »).
*2*perform ? call(callbackfn, t, « kvalue, k, o »).
*2*perform ? call(callbackfn, t, « e, e, s »).

IN NNP VBD CD , NN NNP .
3
*0*if cp ≤ 0xffff, return cp.
*0*if lim = 0, return a.
*0*if lim = 0, return a.

VB NNP VB . NNP ( ) .
3
*0*let actualthis be ? env.getthisbinding().
*0*let basevalue be ? env.getsuperbase().
*0*let thisenvrec be ! getthisenvironment().

VB NNP VB DT NN IN VBG RP DT CC DT JJS JJ CD NNS IN NNP , WDT VBZ , JJ NNP CC NN : CD .
3
*0*let shiftcount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum &amp; 0x1f.
*0*let shiftcount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum &amp; 0x1f.
*0*let shiftcount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum &amp; 0x1f.

IN NNP VBZ DT NN IN DT NN , NN JJ .
3
*0*if body is the functionbody of a generatorbody, return false.
*0*if body is the functionbody of an asyncfunctionbody, return false.
*0*if body is the functionbody of an asyncgeneratorbody, return false.

VB NNP VB NNP NNP NNP NNP NNP NNP . VB JJ NNP NNP NNP .
3
*0*let globalenv be scriptrecord.[[REALM]].[[GLOBALENV]].
*0*let synciterator be o.[[SYNCITERATORRECORD]].[[ITERATOR]].
*0*let synciterator be o.[[SYNCITERATORRECORD]].[[ITERATOR]].

NN NNP IN TO DT NN NN NN : NNP VBZ RB DT VBG NN NN .
3
*0*push scriptcxt on to the execution context stack; scriptcxt is now the running execution context.
*0*push modulecxt on to the execution context stack; modulecxt is now the running execution context.
*0*push evalcxt on to the execution context stack; evalcxt is now the running execution context.

NN NNP CC VB PRP IN DT NN NN NN .
3
*0*suspend scriptcxt and remove it from the execution context stack.
*0*suspend modulecxt and remove it from the execution context stack.
*0*suspend evalcxt and remove it from the execution context stack.

VB DT NN WDT VBZ RB IN DT NN IN DT NN NN NN IN DT VBG NN NN .
3
*0*resume the context that is now on the top of the execution context stack as the running execution context.
*0*resume the context that is now on the top of the execution context stack as the running execution context.
*0*resume the context that is now on the top of the execution context stack as the running execution context.

IN NNP . VB JJ NNP NNP NNP VBZ `` JJ '' , RB
3
*3*if ie.[[IMPORTNAME]] is "*", then
*1*if in.[[IMPORTNAME]] is "*", then
*0*if module.[[STATUS]] is "evaluated", then

IN NNP . VB JJ NNP NNP NNP VBZ `` VBG '' , RB
3
*1*if requiredmodule.[[STATUS]] is "instantiating", then
*1*if requiredmodule.[[STATUS]] is "evaluating", then
*0*if promise.[[PROMISESTATE]] is "pending", then

VB DT NNP POS NN TO NNP .
3
*0*set the evalcxt's realm to evalrealm.
*0*set the evalcxt's variableenvironment to varenv.
*0*set the evalcxt's lexicalenvironment to lexenv.

VB NNP VB DT NN NN IN NN NNP IN NNP .
3
*1*let c be the code unit at index k within string.
*3*let kchar be the code unit at index k within string.
*1*let c be the code unit at index k within string.

VB NNP VB DT VBG NN VBG RB DT NN NN NNP .
3
*2*let s be the string value containing only the code unit c.
*2*let s be the string value containing only the code unit c.
*4*let s be the string value containing only the code unit c.

VB NNP VB DT NN NN NN .
3
*1*let goal be the grammar symbol generatorbody.
*1*let goal be the grammar symbol asyncfunctionbody.
*1*let goal be the grammar symbol asyncgeneratorbody.

IN NNP VBZ JJ , VB NNP VB DT JJ NN .
3
*0*if desc is undefined, let desc be the empty string.
*0*if pattern is undefined, let p be the empty string.
*0*if flags is undefined, let f be the empty string.

VB NNP VB `` : '' .
3
*1*let s be "-".
*2*let c be "-".
*1*let s be "-".

VB NNP VB DT VBG NN VBG IN NNP NNS IN DT NN NN CD ( JJ NN ) .
3
*1*let m be the string value consisting of f+1 occurrences of the code unit 0x0030 (digit zero).
*3*let z be the string value consisting of f+1-k occurrences of the code unit 0x0030 (digit zero).
*1*let m be the string value consisting of p occurrences of the code unit 0x0030 (digit zero).

VB NNP VB DT NN IN NNP , `` . `` , CC NNP .
3
*1*let m be the string-concatenation of a, ".", and b.
*2*let m be the string-concatenation of a, ".", and b.
*3*let m be the string-concatenation of a, ".", and b.

VB NNP VB DT NN WDT VBZ DT NN NN ( JJ ) VBG DT JJ NN .
3
*1*let now be the number that is the time value (utc) identifying the current time.
*1*let now be the number that is the time value (utc) identifying the current time.
*1*let now be the number that is the time value (utc) identifying the current time.

IN NNP VBZ RB JJ , VB NNP VB NNP ( NNP ) : RB , VB NNP VB . NNP ( NNP ) .
3
*0*if date is not present, let dt be datefromtime(t); otherwise, let dt be ? tonumber(date).
*0*if date is not present, let dt be datefromtime(t); otherwise, let dt be ? tonumber(date).
*0*if date is not present, let dt be datefromtime(t); otherwise, let dt be ? tonumber(date).

IN NNP VBZ RB JJ , VB NNP VB JJ ( NNP ) .
3
*0*if sec is not present, let s be secfromtime(t).
*0*if ms is not present, let milli be msfromtime(t).
*0*if ms is not present, let milli be msfromtime(t).

VB NNP VB DT NN NN .
3
*0*let o be this date object.
*0*let o be this date object.
*0*let o be this date object.

VB NNP VB . JJ ( NNP ) .
3
*0*let tv be ? thistimevalue(o).
*0*let tv be ? thistimevalue(o).
*0*let tv be ? thistimevalue(o).

VB NNP VB DT JJ NN IN NN ( NNP ) , VBN IN DT JJ JJ NN , VBD TO DT NN IN DT NN IN JJ .
3
*0*let hour be the string representation of hourfromtime(tv), formatted as a two-digit decimal number, padded to the left with a zero if necessary.
*0*let minute be the string representation of minfromtime(tv), formatted as a two-digit decimal number, padded to the left with a zero if necessary.
*0*let second be the string representation of secfromtime(tv), formatted as a two-digit decimal number, padded to the left with a zero if necessary.

VB NNS VB . NNP ( . NNP ( NNP , `` NN '' ) ) .
3
*0*let literalsegments be ? tolength(? get(raw, "length")).
*1*let ncaptures be ? tolength(? get(result, "length")).
*3*let numberofcaptures be ? tolength(? get(z, "length")).

VB NNP VB DT JJ NN IN DT NN NN IN NN NNP IN DT NN NNP .
3
*0*let first be the numeric value of the code unit at index position within the string s.
*0*let second be the numeric value of the code unit at index position+1 within the string s.
*1*let second be the numeric value of the code unit at index position+1 within the string s.

IN NNP CC NN : CD CC NNP CC NN : CD , NN NNP .
3
*0*if second &lt; 0xdc00 or second &gt; 0xdfff, return first.
*0*if first &lt; 0xd800 or first &gt; 0xdbff, return index+1.
*0*if second &lt; 0xdc00 or second &gt; 0xdfff, return index+1.

NN . NNP ( NNP , NNP , NNP NNP , NNP NNP ) .
3
*2*return ? call(replacer, searchvalue, « o, replacevalue »).
*2*return ? call(splitter, separator, « o, limit »).
*0*return ? call(reviver, holder, « name, val »).

NN , IN NNP NNP NNP
3
*0*repeat, while q ≠ s
*1*repeat, while n ≤ ncaptures
*0*repeat, while lower ≠ middle

VB NNP VB DT JJ NN IN DT NN NN IN NN NNP IN NNP .
3
*0*let first be the numeric value of the code unit at index position within s.
*0*let first be the numeric value of the code unit at index index within s.
*0*let second be the numeric value of the code unit at index index+1 within s.

VB NNP VB NNP POS NNP .
3
*0*let e be x's endindex.
*1*let e be x's endindex.
*1*let e be x's endindex.

VB NNP VB DT NN ( NNP , NNP ) .
3
*0*let xr be the state (e, cap).
*1*let y be the state (f, cap).
*1*let y be the state (f, cap).

NN NNP ( NNP ) CC VB PRP$ NN .
3
*0*call c(x) and return its result.
*1*call c(y) and return its result.
*1*call c(y) and return its result.

VB NNP VB NNP POS NNP NN .
3
*1*let cap be x's captures list.
*1*let cap be x's captures list.
*0*let e be r's endindex value.

VB NNP VB . VBG ( . NNP ( NNP , `` CD '' ) ) .
3
*3*let matchstr be ? tostring(? get(result, "0")).
*3*let matchstr be ? tostring(? get(result, "0")).
*1*let matched be ? tostring(? get(result, "0")).

VB NNP VB VBN ( NNP , CD ) .
3
*3*let numberofcaptures be max(numberofcaptures-1, 0).
*0*let newlen be max(final-first, 0).
*1*let c be max(intcount, 0).

VB NNP VB NNP ( DT RB VBN NN NN ) .
3
*3*let error be throwcompletion(a newly created typeerror object).
*2*let error be throwcompletion(a newly created typeerror object).
*2*let error be throwcompletion(a newly created typeerror object).

VB NNS VB . NNP ( NNP , NNP ) .
3
*3*let exists be ? hasproperty(e, p).
*1*let lowerexists be ? hasproperty(o, lowerp).
*1*let upperexists be ? hasproperty(o, upperp).

VB NNP VB NNP ( NN NN NN , NNP NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP NNP ) .
3
*0*let iterator be objectcreate(%arrayiteratorprototype%, « [[ITERATEDOBJECT]], [[ARRAYITERATORNEXTINDEX]], [[ARRAYITERATIONKIND]] »).
*0*let iterator be objectcreate(%mapiteratorprototype%, « [[MAP]], [[MAPNEXTINDEX]], [[MAPITERATIONKIND]] »).
*0*let iterator be objectcreate(%setiteratorprototype%, « [[ITERATEDSET]], [[SETNEXTINDEX]], [[SETITERATIONKIND]] »).

IN NNP VBZ DT JJ NN NNP NNP NNP JJ NN , RB
3
*0*if a has a [[TYPEDARRAYNAME]] internal slot, then
*1*if space has a [[NUMBERDATA]] internal slot, then
*1*if value has a [[NUMBERDATA]] internal slot, then

VB NNP VB NNP ( NNP , NNP , `` JJ '' , JJ , `` JJ '' ) .
3
*2*let value be getvaluefrombuffer(buffer, frombyteindex, "uint8", true, "unordered").
*2*let value be getvaluefrombuffer(srcbuffer, srcbyteindex, "uint8", true, "unordered").
*2*let value be getvaluefrombuffer(srcbuffer, srcbyteindex, "uint8", true, "unordered").

NN NNP ( NNP , NNP , `` JJ '' , NNP , JJ , `` JJ '' ) .
3
*2*perform setvalueinbuffer(buffer, tobyteindex, "uint8", value, true, "unordered").
*2*perform setvalueinbuffer(targetbuffer, targetbyteindex, "uint8", value, true, "unordered").
*2*perform setvalueinbuffer(targetbuffer, targetbyteindex, "uint8", value, true, "unordered").

VB NNP VB DT JJ NN NN IN JJ CD IN NNP .
3
*0*let elementsize be the element size value in table 56 for constructorname.
*0*let srcelementsize be the element size value in table 56 for srcname.
*0*let elementsize be the element size value in table 56 for constructorname.

VB NNP VB . NNP ( NNP , NN , `` NN JJ NN '' ) .
3
*0*let o be ? allocatetypedarray(constructorname, newtarget, "%typedarrayprototype%").
*0*let o be ? allocatetypedarray(constructorname, newtarget, "%typedarrayprototype%").
*0*let o be ? allocatetypedarray(constructorname, newtarget, "%typedarrayprototype%").

IN NNP CC NN : NNP , VBP DT NN NN .
3
*1*if offset+newbytelength &gt; bufferbytelength, throw a rangeerror exception.
*0*if offset &gt; bufferbytelength, throw a rangeerror exception.
*1*if offset+viewbytelength &gt; bufferbytelength, throw a rangeerror exception.

VBN NNP . CC JJ NNP NNP NNP TO VB .
3
*1*set p.[[VALUE]] to empty.
*2*set p.[[VALUE]] to empty.
*2*set p.[[VALUE]] to empty.

IN NNP . VB JJ NNP NNP NNP VBZ RB JJ , RB
3
*1*if e.[[KEY]] is not empty, then
*1*if e.[[KEY]] is not empty, then
*2*if result.[[TYPE]] is not return, then

VB DT NN IN NNS WP$ NN VBZ NNP IN DT NN WP$ NN VBZ JJ .
3
*1*replace the element of entries whose value is e with an element whose value is empty.
*2*replace the element of entries whose value is e with an element whose value is empty.
*2*replace the element of entries whose value is e with an element whose value is empty.

VB NNP VB NNP ( NNP , NNP , NNP NNP NNP ) .
3
*1*let status be call(adder, set, « nextvalue »).
*0*let returnresult be call(return, synciterator, « value »).
*0*let throwresult be call(throw, synciterator, « value »).

NN : NNP ( NNP ) VBZ JJ CC PRP VBZ DT JJ NN NNP NNP NNP JJ NN .
3
*0*assert: type(arraybuffer) is object and it has an [[ARRAYBUFFERDATA]] internal slot.
*0*assert: type(srcbuffer) is object and it has an [[ARRAYBUFFERDATA]] internal slot.
*0*assert: type(obj) is object and it has an [[ARRAYBUFFERDATA]] internal slot.

NN NNS ( NNP , CD , NNP , NNP , NNP ) .
3
*0*perform copydatablockbytes(targetblock, 0, srcblock, srcbyteoffset, srclength).
*0*perform copydatablockbytes(tobuf, 0, frombuf, first, newlen).
*0*perform copydatablockbytes(tobuf, 0, frombuf, first, newlen).

VB DT NN NN WDT VBZ TO NNP .
3
*1*return the number value that corresponds to value.
*1*return the number value that corresponds to value.
*0*return the number value that corresponds to intvalue.

NN : EX VBP JJ NNS IN NNP VBG IN NNP TO VB DT NN IN NNP .
3
*0*assert: there are sufficient bytes in arraybuffer starting at byteindex to represent a value of type.
*0*assert: there are sufficient bytes in arraybuffer starting at byteindex to represent a value of type.
*0*assert: there are sufficient bytes in arraybuffer starting at byteindex to represent a value of type.

NN : NN VBZ DT NN NN VBD CD .
3
*0*assert: byteindex is an integer value ≥ 0.
*0*assert: byteindex is an integer value ≥ 0.
*0*assert: byteindex is an integer value ≥ 0.

IN NNP VBZ RB JJ , VBN JJ TO DT NN IN DT NNP NNP NNP NNP NNP NN IN DT VBG NN POS NN NN .
3
*0*if islittleendian is not present, set islittleendian to the value of the [[LITTLEENDIAN]] field of the surrounding agent's agent record.
*0*if islittleendian is not present, set islittleendian to the value of the [[LITTLEENDIAN]] field of the surrounding agent's agent record.
*0*if islittleendian is not present, set islittleendian to the value of the [[LITTLEENDIAN]] field of the surrounding agent's agent record.

NN : NNP VBZ IN DT NN IN NNS IN NNP .
3
*0*assert: w is on the list of waiters in wl.
*0*assert: w is on the list of waiters in wl.
*0*assert: w is on the list of waiters in wl.

NN . NNP ( NNP , NNP , NNP , NN ) .
3
*0*return ? atomicreadmodifywrite(typedarray, index, value, add).
*0*return ? atomicreadmodifywrite(typedarray, index, value, second).
*0*return ? atomicreadmodifywrite(typedarray, index, value, subtract).

RB IN NNP VBZ DT JJ NN NNP NNP NNP JJ NN , RB
3
*1*else if space has a [[STRINGDATA]] internal slot, then
*1*else if value has a [[STRINGDATA]] internal slot, then
*1*else if value has a [[BOOLEANDATA]] internal slot, then

IN NNP VBZ JJ , VB `` JJ '' .
3
*0*if value is null, return "null".
*0*if value is true, return "true".
*0*if value is false, return "false".

VB NNP VB DT JJ NNS VBN IN JJ NN NN JJ NNS .
3
*0*let steps be the algorithm steps defined in async-from-sync iterator value unwrap functions.
*0*let steps be the algorithm steps defined in async-from-sync iterator value unwrap functions.
*0*let steps be the algorithm steps defined in async-from-sync iterator value unwrap functions.

NN NNP . NN IN NNP NNP NNP TO NNP .
3
*0*set onfulfilled.[[DONE]] to nextdone.
*0*set onfulfilled.[[DONE]] to returndone.
*0*set onfulfilled.[[DONE]] to throwdone.

NN . NNP ( NNP . VB JJ NNP NNP NNP , NNP , VBD , NNP ) .
3
*0*perform ! performpromisethen(valuewrappercapability.[[PROMISE]], onfulfilled, undefined, promisecapability).
*0*perform ! performpromisethen(valuewrappercapability.[[PROMISE]], onfulfilled, undefined, promisecapability).
*0*perform ! performpromisethen(valuewrappercapability.[[PROMISE]], onfulfilled, undefined, promisecapability).

VB DT NN NN NN IN NNP JJ IN WRB NN VBZ VBN IN DT NN VBD DT JJ NNS MD VB VBN :
3
*0*set the code evaluation state of gencontext such that when evaluation is resumed for that execution context the following steps will be performed:
*0*set the code evaluation state of gencontext such that when evaluation is resumed for that execution context the following steps will be performed:
*0*set the code evaluation state of asynccontext such that when evaluation is resumed for that execution context the following steps will be performed:

NN : NN . VB JJ NNP NNP NNP VBZ JJ .
3
*2*assert: result.[[TYPE]] is throw.
*3*assert: completion.[[TYPE]] is throw.
*2*assert: result.[[TYPE]] is throw.

VB NNP VB NNP ( NNP . VB JJ NNP NNP NNP , VBD , JJ NNP . CC JJ NNP NNP NNP NNP ) .
3
*1*let status be call(promisecapability.[[REJECT]], undefined, « handlerresult.[[VALUE]] »).
*1*let status be call(promisecapability.[[RESOLVE]], undefined, « handlerresult.[[VALUE]] »).
*1*let status be call(resolvingfunctions.[[REJECT]], undefined, « thencallresult.[[VALUE]] »).

VB DT JJ NN NN IN NNP .
2
*0*return the referenced name component of v.
*0*return the strict reference flag of v.

NN : IN DT NN , NNP MD RB VB JJ CC JJ .
2
*2*assert: in this case, base will never be undefined or null.
*2*assert: in this case, base will never be undefined or null.

JJ NNP MD VB DT NN NN ,
2
*0*else base must be an environment record,
*0*else base must be an environment record,

RB IN NNP ( NNP ) VBZ JJ , RB
2
*0*else if ispropertyreference(v) is true, then
*4*else if type(v) is object, then

NN : NN ( NNP ) VBZ JJ .
2
*0*assert: ispropertyreference(v) is true.
*0*assert: isunresolvablereference(v) is false.

IN NNP VBZ DT NNP NNP NNP NNP NNP NN , RB
2
*0*if desc has a [[VALUE]] field, then
*2*if desc has a [[VALUE]] field, then

IN NNP ( NNP ) VBZ JJ CC NNP VBZ RB JJ , VB DT NN NN .
2
*1*if iscallable(getter) is false and getter is not undefined, throw a typeerror exception.
*1*if iscallable(setter) is false and setter is not undefined, throw a typeerror exception.

NN : NNP .
2
*0*assert: size≥0.
*0*assert: size≥0.

IN NNP VBZ DT VBN NN NN , RB
2
*1*if fromblock is a shared data block, then
*2*if toblock is a shared data block, then

IN DT NNP IN NNP IN NN NN , VBP
2
*0*for each name in methodnames in list order, do
*0*for each pair from descriptors in list order, do

IN NNP VBZ DT JJ JJ NN , RB
2
*0*if argument is a proxy exotic object, then
*0*if obj is a proxy exotic object, then

IN NNP VBZ RB JJ , JJ NNP ( NNP ) .
2
*0*if matcher is not undefined, return toboolean(matcher).
*0*if spreadable is not undefined, return toboolean(spreadable).

IN NNP ( NNP ) VBZ JJ IN NNP ( NNP ) , VBP JJ .
2
*0*if type(x) is different from type(y), return false.
*0*if type(x) is different from type(y), return false.

IN NNP VBZ JJ CC NNP VBZ JJ , NN JJ .
2
*1*if x is +0 and y is -0, return false.
*1*if x is -0 and y is +0, return false.

IN NNP VBZ DT JJ NN NN IN NNP , NN JJ .
2
*1*if x is the same number value as y, return true.
*1*if x is the same number value as y, return true.

VB NNP VB . NNP . VB JJ NNP NNP NNP ( NNP ) .
2
*0*let success be ? o.[[DELETE]](p).
*0*let status be ? o.[[SETPROTOTYPEOF]](proto).

NN : NNP VBZ CC `` JJ '' CC `` JJ '' .
2
*0*assert: level is either "sealed" or "frozen".
*0*assert: level is either "sealed" or "frozen".

VB NNP VB NNP ( NNP , . NNP ( NNP ) , NNP ) .
2
*1*let status be createdataproperty(array, ! tostring(n), e).
*3*let status be createdataproperty(a, ! tostring(n), matchstr).

VB NNP VB . NNP ( NNP , NNP NNP NNS ) .
2
*0*let s be ? get(c, @@species).
*0*let unscopables be ? get(bindings, @@unscopables).

VB NNP VB NNP ( NNP NNP , NNP NNP ) .
2
*5*let entry be createarrayfromlist(« key, value »).
*1*let result be createarrayfromlist(« index, elementvalue »).

JJ NNP TO NNP .
2
*5*append entry to properties.
*2*append member to partial.

IN NNP VBZ DT NN NN JJ NN , RB
2
*0*if obj is a bound function exotic object, then
*0*if func is a bound function exotic object, then

NN : NNP VBZ DT NN IN NN NNS .
2
*0*assert: excludeditems is a list of property keys.
*2*assert: capturei is a list of code points.

IN NNP VBZ RB , RB
2
*1*if hint is async, then
*2*if result is null, then

VB NNP VB . NNP ( NNP . VB JJ NNP NNP NNP , NNP . VB JJ NNP NNP NNP , NNP NNP ) .
2
*1*let result be ? call(iteratorrecord.[[NEXTMETHOD]], iteratorrecord.[[ITERATOR]], « »).
*1*let nextresult be ? call(iteratorrecord.[[NEXTMETHOD]], iteratorrecord.[[ITERATOR]], « »).

NN : NNP ( NNP . VB JJ NNP NNP NNP ) VBZ JJ .
2
*0*assert: type(iteratorrecord.[[ITERATOR]]) is object.
*0*assert: type(iteratorrecord.[[ITERATOR]]) is object.

IN NNP VBZ JJ , JJ NNP ( NNP ) .
2
*0*if return is undefined, return completion(completion).
*0*if return is undefined, return completion(completion).

VB NNP VB NNP ( NNP , NNP , NNP NNP ) .
2
*0*let innerresult be call(return, iterator, « »).
*0*let innerresult be call(return, iterator, « »).

IN NNP ( NNP . CC JJ NNP NNP NNP ) VBZ RB JJ , VB DT NN NN .
2
*0*if type(innerresult.[[VALUE]]) is not object, throw a typeerror exception.
*0*if type(innerresult.[[VALUE]]) is not object, throw a typeerror exception.

VB NNP VB NNP ( NN NN NN , NNP NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP NNP ) .
2
*0*let iterator be objectcreate(%iteratorprototype%, « [[ITERATEDLIST]], [[LISTITERATORNEXTINDEX]] »).
*0*let iterator be objectcreate(%stringiteratorprototype%, « [[ITERATEDSTRING]], [[STRINGITERATORNEXTINDEX]] »).

NN : NNP MD VB DT JJ NN IN NNP .
2
*0*assert: envrec must have an uninitialized binding for n.
*0*assert: envrec must have an uninitialized binding for n.

NN NNP ( NNP , JJ ) .
2
*1*perform envrec.createmutablebinding(n, true).
*1*return createiterresultobject(resultvalue, true).

NN : NNP VBZ DT NN IN NNP .
2
*0*assert: envrec has a binding for n.
*0*assert: envrec has a binding for n.

IN DT NN IN NNP IN NNP VBZ DT JJ NN , VB DT NN NN .
2
*0*if the binding for n in envrec is an uninitialized binding, throw a referenceerror exception.
*0*if the binding for n in envrec is an uninitialized binding, throw a referenceerror exception.

VB DT NN RB IN TO NNP IN NNP .
2
*0*return the value currently bound to n in envrec.
*0*return the value currently bound to n in envrec.

NN : NNP . VB JJ NNP NNP NNP VBZ RB `` JJ '' .
2
*0*assert: envrec.[[THISBINDINGSTATUS]] is not "lexical".
*0*assert: envrec.[[THISBINDINGSTATUS]] is not "lexical".

IN NNP . VB JJ NNP NNP NNP VBZ `` JJ '' , VB DT NN NN .
2
*0*if envrec.[[THISBINDINGSTATUS]] is "initialized", throw a referenceerror exception.
*0*if envrec.[[THISBINDINGSTATUS]] is "uninitialized", throw a referenceerror exception.

IN NNP VBZ RB VB NNP , RB
2
*0*if vardeclarednames does not contain n, then
*0*if vardeclarednames does not contain n, then

IN NNP VBZ JJ CC NNP . VB JJ NNP NNP NNP VBZ JJ , RB
2
*0*if existingprop is undefined or existingprop.[[CONFIGURABLE]] is true, then
*1*if targetdesc is undefined or targetdesc.[[CONFIGURABLE]] is true, then

VB NNP VB DT NN ( JJ NNP NNP NNP NN : NNP ) .
2
*1*let desc be the propertydescriptor { [[VALUE]]: v }.
*2*let valuedesc be the propertydescriptor { [[VALUE]]: v }.

IN NNP VBZ DT NN NN , RB
2
*0*if lex is the value null, then
*0*if x is a data property, then

VB NNP VB DT NN IN NNP POS NN NN NN .
2
*1*let outer be the value of lex's outer environment reference.
*1*let outer be the value of lex's outer environment reference.

VB NNP VB DT JJ JJ NN NN VBG DT NNS .
2
*0*let envrec be a new declarative environment record containing no bindings.
*0*let dclrec be a new declarative environment record containing no bindings.

VB NNP VB DT JJ JJ NN NN VBG NNP IN DT NN NN .
2
*0*let envrec be a new object environment record containing o as the binding object.
*0*let objrec be a new object environment record containing g as the binding object.

NN : NNP ( NNP ) VBZ JJ CC JJ .
2
*0*assert: type(newtarget) is undefined or object.
*0*assert: type(newtarget) is undefined or object.

VB NNP VB DT JJ NN NN NN VBG DT NNS .
2
*0*let envrec be a new function environment record containing no bindings.
*0*let envrec be a new module environment record containing no bindings.

IN NNP VBZ JJ , VBN NNP TO NNP .
2
*0*if thisvalue is undefined, set thisvalue to globalobj.
*0*if stricteval is true, set varenv to lexenv.

NN : DT NN NN NN VBZ RB JJ .
2
*1*assert: the execution context stack is now empty.
*0*assert: the execution context stack is not empty.

VBN NNP POS NN TO NNP . VB JJ NNP NNP NNP .
2
*1*set newcontext's realm to nextpending.[[REALM]].
*1*set newcontext's scriptormodule to nextpending.[[SCRIPTORMODULE]].

NN . NNS ( NNP ) .
2
*0*return ! ordinarypreventextensions(o).
*1*return ? enumerateobjectproperties(obj).

IN NNP VBZ RB JJ , VB DT JJ NN NN VBN NNP IN JJ NNP WP$ NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP CC NNP NNP NNP NNP NNP NN NNS VBP VBN IN NNP . IN DT NN IN DT JJ NN IN NNP VBZ JJ , DT NN IN DT RB VBN NN VBZ VBN TO PRP$ NN NN .
2
*2*if o is not undefined, create an own data property named p of object o whose [[VALUE]], [[WRITABLE]], [[ENUMERABLE]] and [[CONFIGURABLE]] attribute values are described by desc. if the value of an attribute field of desc is absent, the attribute of the newly created property is set to its default value.
*2*if o is not undefined, create an own accessor property named p of object o whose [[GET]], [[SET]], [[ENUMERABLE]] and [[CONFIGURABLE]] attribute values are described by desc. if the value of an attribute field of desc is absent, the attribute of the newly created property is set to its default value.

IN NNP VBZ RB JJ , VBP DT NN VBD NNP IN JJ NNP IN DT NN NN TO DT NN NN . VB DT VBG NNS IN DT JJ NN POS JJ NNP NNP NNP NNP CC NNP NNP NNP NNP NNP NNS CC VBD DT NN IN DT NN POS NNS TO PRP$ NN NNS .
2
*2*if o is not undefined, convert the property named p of object o from a data property to an accessor property. preserve the existing values of the converted property's [[CONFIGURABLE]] and [[ENUMERABLE]] attributes and set the rest of the property's attributes to their default values.
*2*if o is not undefined, convert the property named p of object o from an accessor property to a data property. preserve the existing values of the converted property's [[CONFIGURABLE]] and [[ENUMERABLE]] attributes and set the rest of the property's attributes to their default values.

VB NNP VB DT RB VBN NN IN DT JJ NN IN DT NN IN NNP .
2
*0*let obj be a newly created object with an internal slot for each name in internalslotslist.
*0*let a be a newly created object with an internal slot for each name in internalslotslist.

NN : NNP VBZ DT VBG NN WDT VBZ DT NN POS NN IN DT JJ NN . DT JJ NN MD VB DT JJ WDT VBZ VBN TO VB VBN IN DT NNP NNP NNP NNP NNP NN IN DT NN .
2
*0*assert: intrinsicdefaultproto is a string value that is this specification's name of an intrinsic object. the corresponding object must be an intrinsic that is intended to be used as the [[PROTOTYPE]] value of an object.
*0*assert: intrinsicdefaultproto is a string value that is this specification's name of an intrinsic object. the corresponding object must be an intrinsic that is intended to be used as the [[PROTOTYPE]] value of an object.

NN : NNP VBZ RB DT VBG NN NN .
2
*0*assert: calleecontext is now the running execution context.
*0*assert: calleecontext is now the running execution context.

IN NNP VBZ JJ , VB NNP VB NNP .
2
*0*if thismode is strict, let thisvalue be thisargument.
*1*if e is false, let q be q+1.

NN : NNP VBZ DT NN NN NN .
2
*0*assert: envrec is a function environment record.
*0*assert: envrec is a function environment record.

IN NNP VBZ `` NN '' , RB
2
*0*if kind is "base", then
*0*if kind is "generator", then

IN NNP VBZ `` JJ '' , VB NNP VB JJ .
2
*0*if functionkind is "normal", let needsconstruct be true.
*0*if flags contains "u", let unicodematching be true.

RB , VB NNP VB `` JJ '' .
2
*0*else, let allockind be "normal".
*0*else, let builtintag be "object".

VB NNP VB . NNP ( NNP , NNP , `` NN '' ) .
2
*0*let f be ! functionallocate(functionprototype, strict, "generator").
*0*let f be ! functionallocate(functionprototype, strict, "async").

NN . NNP ( NNP , NNP , NNP , NNP , NNP ) .
2
*0*return ! functioninitialize(f, kind, parameterlist, body, scope).
*0*return ! functioninitialize(f, kind, parameters, body, scope).

VB NNP VB NNP POS NNP NNP NNP NNP NNP NN .
2
*1*let description be name's [[DESCRIPTION]] value.
*0*let desc be sym's [[DESCRIPTION]] value.

VB NNP VB DT NNS IN NNS .
2
*0*let parameternames be the boundnames of formals.
*0*let parameternames be the boundnames of formals.

IN NNP VBZ JJ CC IN NNP VBZ JJ , RB
2
*1*if strict is true or if simpleparameterlist is false, then
*0*if destructuring is true and if lhskind is assignment, then

VB NNP VB NNP ( NNP , NNP , NNP , NNP ) .
2
*2*let ao be createmappedargumentsobject(func, formals, argumentslist, envrec).
*0*let result be evaldeclarationinstantiation(body, varenv, lexenv, stricteval).

NN . NNP ( `` NNS '' , JJ ) .
2
*2*perform ! envrec.createimmutablebinding("arguments", false).
*2*perform ! envrec.createmutablebinding("arguments", false).

NN NNP ( NNP , VBD ) .
2
*3*call envrec.initializebinding(n, undefined).
*3*call envrec.initializebinding(dn, undefined).

VB NNP VB DT JJ NN VBG DT JJ NNS IN DT NN NNP IN DT JJ NN VBN IN DT JJ NNS IN DT NN NNP IN DT JJ NN .
2
*0*let args be a new list containing the same values as the list boundargs in the same order followed by the same values as the list argumentslist in the same order.
*0*let args be a new list containing the same values as the list boundargs in the same order followed by the same values as the list argumentslist in the same order.

VBN NNP . NNP NNP NNP NNP NNP IN VBN IN CD .
2
*1*set obj.[[CONSTRUCT]] as described in 9.4.1.2.
*2*set p.[[CONSTRUCT]] as specified in 9.5.13.

NN : NNP MD RB VB JJ CC DT NN NN IN NN NNS VBP VBN IN DT NN NN NN WDT MD RB VB VBN CC VBN .
2
*1*assert: oldlendesc will never be undefined or an accessor descriptor because array objects are created with a length data property that cannot be deleted or reconfigured.
*0*assert: oldlendesc will never be undefined or an accessor descriptor because array objects are created with a length data property that cannot be deleted or reconfigured.

VBN NNP . CC JJ NNP NNP NNP TO NNP NNP CD .
2
*2*set oldlendesc.[[VALUE]] to index + 1.
*2*set newlendesc.[[VALUE]] to oldlen + 1.

NN : NNP VBZ DT JJ NN $ CD .
2
*0*assert: length is an integer number ≥ 0.
*0*assert: length is an integer number ≥ 0.

VB NNP VB DT RB VBN NN JJ NN .
2
*0*let a be a newly created array exotic object.
*0*let s be a newly created string exotic object.

IN NNP . CC JJ NNP NNP NNP VBZ JJ , RB
2
*0*if desc.[[VALUE]] is absent, then
*2*if desc.[[VALUE]] is present, then

VB NNP VB . NNP ( NNP . CC JJ NNP NNP NNP ) .
2
*0*let newlen be ? touint32(desc.[[VALUE]]).
*0*let numberlen be ? tonumber(desc.[[VALUE]]).

IN NNP VBZ RB JJ , VB NNP .
2
*0*if desc is not undefined, return desc.
*1*if z is not null, return a.

IN DT NN NNP VBG IN CD JJ IN NNP CC NN : NNP , IN VBG NN , VBP
2
*0*for each integer i starting with 0 such that i &lt; len, in ascending order, do
*0*for each integer i starting with 0 such that i &lt; len, in ascending order, do

NN . NNP ( NNP ) IN DT JJ NN IN NNP .
2
*1*add ! tostring(i) as the last element of keys.
*1*add ! tostring(i) as the last element of keys.

IN DT JJ NN JJ NNP IN NNP JJ IN NNP ( NNP ) VBZ VBG CC NNP VBZ RB DT NN NN , IN VBG JJ NN IN NN NN , VBP
2
*0*for each own property key p of o such that type(p) is string and p is not an integer index, in ascending chronological order of property creation, do
*0*for each own property key p of o such that type(p) is string and p is not an integer index, in ascending chronological order of property creation, do

IN DT JJ NN JJ NNP IN NNP JJ IN NNP ( NNP ) VBZ JJ , IN VBG JJ NN IN NN NN , VBP
2
*0*for each own property key p of o such that type(p) is symbol, in ascending chronological order of property creation, do
*0*for each own property key p of o such that type(p) is symbol, in ascending chronological order of property creation, do

NN NNP . VB NNP NNP NNP NNP IN VBN IN CD .
2
*0*set s.[[GETOWNPROPERTY]] as specified in 9.4.3.1.
*0*set s.[[DEFINEOWNPROPERTY]] as specified in 9.4.3.2.

VB NNP VB DT NN IN JJ NN NNS IN NNP .
2
*0*let length be the number of code unit elements in value.
*0*let lengths be the number of code unit elements in s.

IN NNP ( NNP ) VBZ RB JJ , NN VBD .
2
*0*if type(p) is not string, return undefined.
*0*if type(key) is not object, return undefined.

IN NNP ( NNP ) VBZ JJ , NN VBD .
2
*0*if isinteger(index) is false, return undefined.
*0*if isinteger(index) is false, return undefined.

IN NNP NNP NNP , NN VBD .
2
*0*if index = -0, return undefined.
*0*if index = -0, return undefined.

VB DT NN ( JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) .
2
*0*return a propertydescriptor { [[VALUE]]: resultstr, [[WRITABLE]]: false, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: false }.
*2*return a propertydescriptor { [[VALUE]]: value, [[WRITABLE]]: true, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: false }.

VBN NNP . CC JJ NNP NNP NNP TO NNP ( NNP , NNP ) .
2
*1*set desc.[[VALUE]] to get(map, p).
*2*set newargdesc.[[VALUE]] to get(map, p).

NN : NNP VBZ JJ IN JJ NNS VBN IN NN NNS VBP RB JJ .
2
*3*assert: setstatus is true because formal parameters mapped by argument objects are always writable.
*1*assert: setstatus is true because formal parameters mapped by argument objects are always writable.

NN NNP ( NNP , `` NN '' , NN ( JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) ) .
2
*0*perform definepropertyorthrow(obj, "length", propertydescriptor { [[VALUE]]: len, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }).
*0*perform definepropertyorthrow(obj, "length", propertydescriptor { [[VALUE]]: len, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }).

NN NNP ( NNP , . NNP ( NNP ) , NNP ) .
2
*1*perform createdataproperty(obj, ! tostring(index), val).
*1*perform createdataproperty(obj, ! tostring(index), val).

NN . NNP ( NNP , NNP NNP NN , NN ( JJ NNP NNP NNP NNP : NN VBZ NN , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) ) .
2
*0*perform ! definepropertyorthrow(obj, @@iterator, propertydescriptor { [[VALUE]]: %arrayproto_values%, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }).
*0*perform ! definepropertyorthrow(obj, @@iterator, propertydescriptor { [[VALUE]]: %arrayproto_values%, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }).

VBN NNP . NN NN NNP NNP NNP IN VBN IN CD .
2
*0*set obj.[[SET]] as specified in 9.4.4.4.
*0*set a.[[SET]] as specified in 9.4.5.5.

VB NNP VB DT NNS IN DT NN NN IN VBN IN .
2
*0*let steps be the steps of an arggetter function as specified below.
*0*let steps be the steps of an argsetter function as specified below.

IN NNP CC NN : CD , NN JJ .
2
*2*if numericindex &lt; 0, return false.
*2*if numericindex &lt; 0, return false.

IN NNP ( NNP ) VBZ JJ , VB NNP ( NNP , NNP ) .
2
*0*if type(p) is symbol, return ordinarygetownproperty(o, p).
*0*if type(p) is symbol, return ordinaryhasproperty(o, p).

IN NNP VBZ RB DT NN IN NNP , NN VBD .
2
*0*if p is not an element of exports, return undefined.
*0*if p is not an element of exports, return undefined.

IN NNP VBZ DT NN IN NNP , NN JJ .
2
*0*if p is an element of exports, return true.
*0*if p is an element of exports, return false.

VB NNP VB . NNP ( NNP , NNP NNP ) .
2
*0*let binding be ! m.resolveexport(p, « »).
*2*let resolution be ? module.resolveexport(name, « »).

NN . NNP ( NNP . VB JJ NNP NNP NNP , JJ ) .
2
*0*return ? targetenvrec.getbindingvalue(binding.[[BINDINGNAME]], true).
*2*perform ! envrec.createimmutablebinding(in.[[LOCALNAME]], true).

NN : NN . CC JJ NNP NNP NNP VBZ VBN .
2
*0*assert: module.[[NAMESPACE]] is undefined.
*0*assert: generator.[[ASYNCGENERATORSTATE]] is undefined.

VB NNP VB NNP ( . NNP ( NNP , NNP , NNP NNP NNP ) ) .
2
*0*let booleantrapresult be toboolean(? call(trap, handler, « target »)).
*0*let booleantrapresult be toboolean(? call(trap, handler, « target »)).

IN NNP ( NNP ) VBZ JJ CC NNP . VB JJ NNP NNP NNP VBZ JJ , RB
2
*1*if isdatadescriptor(targetdesc) is true and targetdesc.[[WRITABLE]] is false, then
*1*if isdatadescriptor(targetdesc) is true and targetdesc.[[WRITABLE]] is false, then

IN NNP ( NNP , NNP . CC JJ NNP NNP NNP ) VBZ JJ , VB DT NN NN .
2
*2*if samevalue(trapresult, targetdesc.[[VALUE]]) is false, throw a typeerror exception.
*2*if samevalue(v, targetdesc.[[VALUE]]) is false, throw a typeerror exception.

IN NNP VBZ RB JJ , VB DT NN NN .
2
*2*if trapresult is not undefined, throw a typeerror exception.
*0*if uncheckedresultkeys is not empty, throw a typeerror exception.

NN : NNP VBZ DT NN NNS .
2
*0*assert: targetkeys contains no duplicate entries.
*1*assert: tdznames has no duplicate entries.

RB NNP IN DT NN IN NNP .
2
*2*append key as an element of targetnonconfigurablekeys.
*2*append key as an element of targetconfigurablekeys.

IN NNP VBZ RB DT NN IN NNP , VBP DT NN NN .
2
*1*if key is not an element of uncheckedresultkeys, throw a typeerror exception.
*1*if key is not an element of uncheckedresultkeys, throw a typeerror exception.

IN NNP VBZ DT JJ JJ NN CC NNP . VB JJ NNP NNP NNP VBZ JJ , VB DT NN NN .
2
*0*if target is a proxy exotic object and target.[[PROXYHANDLER]] is null, throw a typeerror exception.
*0*if handler is a proxy exotic object and handler.[[PROXYHANDLER]] is null, throw a typeerror exception.

VB NNP VB DT VBG NN NNP NNP NNP NNP .
2
*1*let cookedvalue be the string value cookedstrings[index].
*1*let rawvalue be the string value rawstrings[index].

NN NNP . VB NNP NNP NNP NNP ( NNP , NN ( JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) ) .
2
*1*call template.[[DEFINEOWNPROPERTY]](prop, propertydescriptor { [[VALUE]]: cookedvalue, [[WRITABLE]]: false, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: false }).
*1*call rawobj.[[DEFINEOWNPROPERTY]](prop, propertydescriptor { [[VALUE]]: rawvalue, [[WRITABLE]]: false, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: false }).

VB DT NN IN VBG DT NN NN TO NNP CC NNP . VB DT NN IN CD .
2
*0*return the result of applying the addition operation to lnum and rnum. see the note below 12.8.5.
*0*return the result of applying the subtraction operation to lnum and rnum. see the note below 12.8.5.

IN NNP VBZ DT NN , DT NN , DT NN , CC DT NN , RB
2
*1*if d is a functiondeclaration, a generatordeclaration, an asyncfunctiondeclaration, or an asyncgeneratordeclaration, then
*2*if d is a functiondeclaration, a generatordeclaration, an asyncfunctiondeclaration, or an asyncgeneratordeclaration, then

IN NNP VBZ RB JJ JJ NN , RB
2
*1*if test is not [empty], then
*1*if increment is not [empty], then

IN NNP . CC JJ NNP NNP NNP VBZ RB JJ , VBN NNP TO NNP . CC JJ NNP NNP NNP .
2
*1*if result.[[VALUE]] is not empty, set v to result.[[VALUE]].
*1*if result.[[VALUE]] is not empty, set v to result.[[VALUE]].

IN NNP VBZ RB DT JJ NN , RB
2
*0*if tdznames is not an empty list, then
*2*if gap is not the empty string, then

RB , VB NNP VB VBN .
2
*1*else, let iteratorhint be sync.
*0*else, let newtarget be newtarget.

NN : NNP VBZ VBG .
2
*2*assert: lhskind is lexicalbinding.
*3*assert: lhskind is lexicalbinding.

RB IN NNP VBZ VBG , RB
2
*2*else if lhskind is lexicalbinding, then
*2*else if lhskind is varbinding, then

IN NNP VBZ JJ , VB . NNP ( NNP , NNP ) .
2
*2*if iteratorkind is async, return ? asynciteratorclose(iteratorrecord, status).
*3*if iteratorkind is async, return ? asynciteratorclose(iteratorrecord, status).

VBN NNP TO NNP ( NNP , NNP ) .
2
*3*set status to updateempty(result, v).
*1*set namespace to modulenamespacecreate(module, unambiguousnames).

NN : NN VBZ DT JJ NN .
2
*0*assert: call is a parse node.
*0*assert: position is a nonnegative integer.

NN NNP VBG NN IN DT NN NN CC VB DT NN NN IN DT JJ NN NNS . IN DT NN VBD JJ CC DT JJ NNS VBD VBN , VB NNP VB DT JJ JJ NN . RB , VB NNP VB DT NN IN CD CC JJR NN CC NN NNS VBG DT JJ NNS or JJ NNS . NN CC JJ NN NN MD VB VBN IN DT JJ NN . IN JJR IN CD VBG NN CC JJ NN VBZ JJ , DT NN CC NN IN NN NNS IN DT NN VBZ JJ , CC IN JJS CD MD VB JJ .
2
*0*parse sourcetext using script as the goal symbol and analyse the parse result for any early error conditions. if the parse was successful and no early errors were found, let body be the resulting parse tree. otherwise, let body be a list of one or more syntaxerror or referenceerror objects representing the parsing errors and/or early errors. parsing and early error detection may be interweaved in an implementation-dependent manner. if more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-dependent, but at least one must be present.
*0*parse sourcetext using module as the goal symbol and analyse the parse result for any early error conditions. if the parse was successful and no early errors were found, let body be the resulting parse tree. otherwise, let body be a list of one or more syntaxerror or referenceerror objects representing the parsing errors and/or early errors. parsing and early error detection may be interweaved in an implementation-dependent manner. if more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-dependent, but at least one must be present.

IN NNP VBZ DT NN IN NNS , NN NNP .
2
*0*if body is a list of errors, return body.
*0*if body is a list of errors, return body.

VB DT RB VBG NN NN .
2
*0*suspend the currently running execution context.
*0*suspend the currently running execution context.

VBN NNP TO DT NN IN VBG NNP .
2
*1*set result to the result of evaluating scriptbody.
*1*set result to the result of evaluating body.

IN NNP . VB JJ NNP NNP NNP VBZ JJ CC NNP . CC JJ NNP NNP NNP VBZ JJ , RB
2
*0*if result.[[TYPE]] is normal and result.[[VALUE]] is empty, then
*0*if result.[[TYPE]] is normal and result.[[VALUE]] is empty, then

VBN NNP TO NNP ( JJ ) .
2
*1*set result to normalcompletion(undefined).
*1*set result to normalcompletion(undefined).

IN NNP VBZ DT NN , DT NN , CC DT NN , RB
2
*1*if d is a variabledeclaration, a forbinding, or a bindingidentifier, then
*1*if d is a variabledeclaration, a forbinding, or a bindingidentifier, then

NN : RB VBN NNS VBP RB VBN RB CC RB VBN .
2
*1*note: lexically declared names are only instantiated here but not initialized.
*1*note: lexically declared names are only instantiated here but not initialized.

IN DT NN NNP IN NNP , IN NN NN , VBP
2
*0*for each string vn in declaredvarnames, in list order, do
*0*for each string vn in declaredvarnames, in list order, do

IN NNP VBZ DT NN IN NNS , RB
2
*0*if s is a list of errors, then
*0*if m is a list of errors, then

VB NNS VB NNS IN NNP .
2
*0*let importentries be importentries of body.
*0*let exportentries be exportentries of body.

RB IN NNP . VB JJ NNP NNP NNP VBZ `` JJ '' , RB
2
*1*else if ee.[[IMPORTNAME]] is "*", then
*0*else if promise.[[PROMISESTATE]] is "fulfilled", then

IN NNP VBZ RB DT NN NN NN NN , RB
2
*0*if module is not a source text module record, then
*0*if module is not a source text module record, then

NN : NN . CC JJ NNP NNP NNP VBZ `` JJ '' .
2
*0*assert: module.[[STATUS]] is "uninstantiated".
*0*assert: module.[[STATUS]] is "instantiated".

IN DT NN VBD DT VBZ DT NN IN NNP . VB JJ NNP NNP NNP , VBP
2
*0*for each string required that is an element of module.[[REQUESTEDMODULES]], do
*0*for each string required that is an element of module.[[REQUESTEDMODULES]], do

VBN NN TO . NNP ( NNP , NNP , NNP ) .
2
*1*set index to ? innermoduleinstantiation(requiredmodule, stack, index).
*1*set index to ? innermoduleevaluation(requiredmodule, stack, index).

NN : NN . CC JJ NNP NNP NNP VBZ `` VBG '' IN CC RB IN NNP VBZ IN NNP .
2
*1*assert: requiredmodule.[[STATUS]] is "instantiating" if and only if requiredmodule is in stack.
*1*assert: requiredmodule.[[STATUS]] is "evaluating" if and only if requiredmodule is in stack.

NN : NN VBZ DT NN NN NN NN .
2
*2*assert: requiredmodule is a source text module record.
*2*assert: requiredmodule is a source text module record.

VBN NNP . VB JJ NNP NNP NNP TO VB ( NNP . VB JJ NNP NNP NNP , NNP . VB JJ NNP NNP NNP ) .
2
*2*set module.[[DFSANCESTORINDEX]] to min(module.[[DFSANCESTORINDEX]], requiredmodule.[[DFSANCESTORINDEX]]).
*2*set module.[[DFSANCESTORINDEX]] to min(module.[[DFSANCESTORINDEX]], requiredmodule.[[DFSANCESTORINDEX]]).

NN : NN VBZ RB RB IN NNP .
2
*0*assert: module occurs exactly once in stack.
*0*assert: module occurs exactly once in stack.

NN : NN . CC JJ NNP NNP NNP VBZ JJR IN CC JJ TO NNP . VB JJ NNP NNP NNP .
2
*0*assert: module.[[DFSANCESTORINDEX]] is less than or equal to module.[[DFSINDEX]].
*0*assert: module.[[DFSANCESTORINDEX]] is less than or equal to module.[[DFSINDEX]].

IN NNP . VB JJ NNP NNP NNP NNS NNP . VB JJ NNP NNP NNP , RB
2
*0*if module.[[DFSANCESTORINDEX]] equals module.[[DFSINDEX]], then
*0*if module.[[DFSANCESTORINDEX]] equals module.[[DFSINDEX]], then

IN NNP CC NNP VBP DT JJ NN NN , VB NNP TO JJ .
2
*2*if requiredmodule and module are the same module record, set done to true.
*2*if requiredmodule and module are the same module record, set done to true.

IN DT NN NN NNP IN NNP . VB JJ NNP NNP NNP , VBP
2
*0*for each exportentry record e in module.[[INDIRECTEXPORTENTRIES]], do
*0*for each importentry record in in module.[[IMPORTENTRIES]], do

VB NNP VB . NNP ( NNP . VB JJ NNP NNP NNP , NNP NNP ) .
2
*1*let resolution be ? module.resolveexport(e.[[EXPORTNAME]], « »).
*2*let resolution be ? importedmodule.resolveexport(in.[[IMPORTNAME]], « »).

IN NNP VBZ JJ CC `` JJ '' , VB DT NN NN .
2
*1*if resolution is null or "ambiguous", throw a syntaxerror exception.
*2*if resolution is null or "ambiguous", throw a syntaxerror exception.

VB NNP VB NNP ( NNP . VB JJ NNP NNP NNP ) .
2
*0*let env be newmoduleenvironment(realm.[[GLOBALENV]]).
*1*let lexenv be newdeclarativeenvironment(evalrealm.[[GLOBALENV]]).

NN : DT NN NN NN VBZ IN JJS CD NNS .
2
*0*assert: the execution context stack has at least two elements.
*0*assert: the execution context stack has at least two elements.

VB NNP VB DT JJ TO VB NN IN DT NN NN NN .
2
*0*let callercontext be the second to top element of the execution context stack.
*0*let callercontext be the second to top element of the execution context stack.

IN NNP VBZ JJ , VB NNP VB JJ .
2
*0*if strictcaller is true, let stricteval be true.
*0*if mapfn is undefined, let mapping be false.

NN . NNP ( NNP , NNP , JJ ) .
2
*2*perform ? varenvrec.createglobalfunctionbinding(fn, fo, true).
*1*return ! asyncgeneratorresolve(generator, resultvalue, true).

VB NNS VB NNP ( NNP ) .
2
*2*let bindingexists be varenvrec.hasbinding(fn).
*2*let bindingexists be varenvrec.hasbinding(vn).

NN : NNP VBZ RB DT JJ NN IN IN NN VBG NN CD .
2
*3*assert: status is not an abrupt completion because of validation preceding step 12.
*3*assert: status is not an abrupt completion because of validation preceding step 12.

VB VBG VB . NNP ( VBG ) .
2
*0*let inputstring be ? tostring(string).
*0*let inputstring be ? tostring(string).

IN NNP NNS NNP , NN NNP .
2
*1*if k equals strlen, return r.
*1*if k equals strlen, return r.

IN DT NN NNS IN NN ( NNP NNP CD ) CC ( NNP NNP CD ) IN VBG VBP RB VB JJ NNS , VBP DT JJ NN .
2
*2*if the code units at index (k + 1) and (k + 2) within string do not represent hexadecimal digits, throw a urierror exception.
*4*if the code units at index (k + 1) and (k + 2) within string do not represent hexadecimal digits, throw a urierror exception.

VB NNP VB DT JJ NN VBN IN DT CD JJ NNS IN NN ( NNP NNP CD ) CC ( NNP NNP CD ) .
2
*2*let b be the 8-bit value represented by the two hexadecimal digits at index (k + 1) and (k + 2).
*4*let b be the 8-bit value represented by the two hexadecimal digits at index (k + 1) and (k + 2).

NN . NNP ( NNP , NN ) .
2
*0*return ? getownpropertykeys(o, symbol).
*0*return ? getiterator(asynciterator, async).

IN NNP ( NNP ) VBZ RB JJ , VB JJ .
2
*0*if type(o) is not object, return true.
*0*if type(o) is not object, return true.

NN . NNP ( NNP , `` JJ '' ) .
2
*0*return ? testintegritylevel(o, "frozen").
*0*return ? createmapiterator(m, "key").

NN . NNP ( NNP , `` VBG '' ) .
2
*0*return ? invoke(o, "tostring").
*0*return ? invoke(o, "toisostring").

RB IN NNP VBZ DT JJ NN NNP NNP NNP JJ NN , VB NNP VB `` JJ '' .
2
*0*else if o has a [[BOOLEANDATA]] internal slot, let builtintag be "boolean".
*0*else if o has a [[REGEXPMATCHER]] internal slot, let builtintag be "regexp".

VB NNP VB `` NN JJ NN '' .
2
*1*let fallbackproto be "%functionprototype%".
*1*let fallbackproto be "%asyncfunctionprototype%".

VB NNP VB `` NN NN NN '' .
2
*1*let fallbackproto be "%generator%".
*1*let fallbackproto be "%asyncgenerator%".

RB IN NNP VBZ `` JJ '' , RB
2
*0*else if kind is "async", then
*0*else if type is "float64", then

NN NNP ( NNP , `` NN '' , NN ( JJ NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) ) .
2
*1*perform definepropertyorthrow(f, "prototype", propertydescriptor { [[VALUE]]: prototype, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }).
*1*perform definepropertyorthrow(f, "prototype", propertydescriptor { [[VALUE]]: prototype, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }).

IN NNP ( NNP . VB JJ NNP NNP NNP , NNP ) VBZ JJ , NN NNP . VB JJ NNP NNP NNP .
2
*1*if samevalue(e.[[KEY]], stringkey) is true, return e.[[SYMBOL]].
*1*if samevalue(e.[[SYMBOL]], sym) is true, return e.[[KEY]].

NN : NN VBZ RB RB VBP DT NN IN NNP .
2
*0*assert: globalsymbolregistry does not currently contain an entry for stringkey.
*0*assert: globalsymbolregistry does not currently contain an entry for sym.

VB NNP VB . NNP ( NNP , `` NN JJ NN '' , NNP NNP NNP NNP NNP NNP NNP ) .
2
*0*let o be ? ordinarycreatefromconstructor(newtarget, "%errorprototype%", « [[ERRORDATA]] »).
*0*let o be ? ordinarycreatefromconstructor(newtarget, "%nativeerrorprototype%", « [[ERRORDATA]] »).

VB NNP VB . NNP ( NN , `` NN JJ NN '' , NNP NNP NNP NNP NNP NNP NNP ) .
2
*0*let o be ? ordinarycreatefromconstructor(newtarget, "%numberprototype%", « [[NUMBERDATA]] »).
*0*let set be ? ordinarycreatefromconstructor(newtarget, "%setprototype%", « [[SETDATA]] »).

IN NNP VBZ RB JJ TO NNP , NN JJ .
2
*0*if integer is not equal to number, return false.
*0*if integer is not equal to number, return false.

VB DT NN IN NNP CC `` NN '' .
2
*1*return the string-concatenation of s and "infinity".
*1*return the string-concatenation of s and "infinity".

IN NNP VBZ JJ , NN . NNP ( NNP ) .
2
*0*if precision is undefined, return ! tostring(x).
*1*if value is finite, return ! tostring(value).

VB NNP VB DT NN NN CD ( NN ) .
2
*1*let s be the code unit 0x002d (hyphen-minus).
*3*let c be the code unit 0x002d (hyphen-minus).

IN NNP VBZ RB JJ CC CD NN NNP ( NNP ) VBD CD , VB NNP VB CD ( NNP ) : RB , VB NNP VB NNP .
2
*1*if y is not nan and 0 ≤ tointeger(y) ≤ 99, let yr be 1900+tointeger(y); otherwise, let yr be y.
*0*if y is not nan and 0 ≤ tointeger(y) ≤ 99, let yr be 1900+tointeger(y); otherwise, let yr be y.

IN NNP ( NNP ) VBZ JJ CC NNP VBZ DT JJ NN NNP NNP NNP JJ NN , RB
2
*1*if type(value) is object and value has a [[DATEVALUE]] internal slot, then
*0*if type(pattern) is object and pattern has a [[REGEXPMATCHER]] internal slot, then

NN NNP ( NNP ( NNP ) ) .
2
*0*return datefromtime(localtime(t)).
*0*return weekday(localtime(t)).

VB NNP VB NNP ( NNP ( NN ( NNP ) , FW ( NNP ) , NNP ) , JJ ( NNP ) ) .
2
*0*let newdate be makedate(makeday(yearfromtime(t), monthfromtime(t), dt), timewithinday(t)).
*0*let newdate be makedate(makeday(yearfromtime(t), monthfromtime(t), dt), timewithinday(t)).

IN NNP VBZ JJ , VB NNP VB VBN : RB , VB NNP VB NNP ( NNP ) .
2
*0*if t is nan, let t be +0; otherwise, let t be localtime(t).
*0*if numpos is nan, let pos be +∞; otherwise, let pos be tointeger(numpos).

VB NNP VB NNP ( NNP ( NNP , NNP , NNP ) , JJ ( NNP ) ) .
2
*0*let newdate be makedate(makeday(y, m, dt), timewithinday(t)).
*0*let newdate be makedate(makeday(y, m, dt), timewithinday(t)).

VB NNP VB NNP ( NN ( NNP ) , NNP ( NNP , NNP , NNP , NNP ) ) .
2
*0*let date be makedate(day(t), maketime(h, m, s, milli)).
*0*let newdate be makedate(day(t), maketime(h, m, s, milli)).

VB NNP VB NNP ( NN ( NNP ) , FW ( NNP ) , RB ( NNP ) , NNP ) .
2
*0*let time be maketime(hourfromtime(t), minfromtime(t), secfromtime(t), ms).
*0*let time be maketime(hourfromtime(t), minfromtime(t), secfromtime(t), milli).

VB NNP VB NNP ( NN ( NNP ) , NNP ( NN ( NNP ) , NNP , NNP , NNP ) ) .
2
*0*let date be makedate(day(t), maketime(hourfromtime(t), m, s, milli)).
*0*let date be makedate(day(t), maketime(hourfromtime(t), m, s, milli)).

VB NNP VB NNP ( NNP ( NN ( NNP ) , NNP , NNP ) , JJ ( NNP ) ) .
2
*0*let newdate be makedate(makeday(yearfromtime(t), m, dt), timewithinday(t)).
*0*let newdate be makedate(makeday(yearfromtime(t), m, dt), timewithinday(t)).

VB NNP VB NNP ( NN ( NNP ) , NNP ( NN ( NNP ) , FW ( NNP ) , NNP , NNP ) ) .
2
*0*let date be makedate(day(t), maketime(hourfromtime(t), minfromtime(t), s, milli)).
*0*let date be makedate(day(t), maketime(hourfromtime(t), minfromtime(t), s, milli)).

VB NNP VB DT JJ NN IN NNP ( NNP ) , VBN IN DT JJ JJ NN , VBD TO DT NN IN DT NN IN JJ .
2
*0*let day be the string representation of datefromtime(tv), formatted as a two-digit decimal number, padded to the left with a zero if necessary.
*0*let day be the string representation of datefromtime(tv), formatted as a two-digit decimal number, padded to the left with a zero if necessary.

VB NNP VB DT JJ NN IN NN ( NNP ) , VBN IN DT JJ NN IN IN JJS CD NNS , VBD TO DT NN IN NNS IN JJ .
2
*0*let year be the string representation of yearfromtime(tv), formatted as a decimal number of at least four digits, padded to the left with zeroes if necessary.
*0*let year be the string representation of yearfromtime(tv), formatted as a decimal number of at least four digits, padded to the left with zeroes if necessary.

VB NNP VB DT JJ NN IN NN ( JJ ( NNP ) ) , VBN IN DT JJ JJ NN , VBD TO DT NN IN DT NN IN JJ .
2
*0*let offsetmin be the string representation of minfromtime(abs(offset)), formatted as a two-digit decimal number, padded to the left with a zero if necessary.
*0*let offsethour be the string representation of hourfromtime(abs(offset)), formatted as a two-digit decimal number, padded to the left with a zero if necessary.

VB DT NN NN WP$ NNS VBP , IN NN , DT NNS IN DT NN NNP . IN NNP VBZ CD , DT JJ NN VBZ VBN .
2
*0*return the string value whose elements are, in order, the elements in the list elements. if length is 0, the empty string is returned.
*0*return the string value whose elements are, in order, the elements in the list elements. if length is 0, the empty string is returned.

NN IN NN DT NN NN NNS IN NNP TO DT NN IN NNS .
2
*1*append in order the code unit elements of nextseg to the end of stringelements.
*1*append in order the code unit elements of nextsub to the end of stringelements.

IN DT NN IN NNS IN NNP VBG IN NNP IN NN NNP VBZ DT JJ IN DT JJ NN NN IN NNP , NN JJ .
2
*0*if the sequence of elements of s starting at start of length searchlength is the same as the full element sequence of searchstr, return true.
*0*if the sequence of elements of s starting at start of length searchlength is the same as the full element sequence of searchstr, return true.

VB NNP VB . NNP ( NNP , VBD ) .
2
*0*let rx be ? regexpcreate(regexp, undefined).
*0*let rx be ? regexpcreate(regexp, undefined).

NN . NNP ( NNP , NNP NNP NN , NNP NNP NNP ) .
2
*0*return ? invoke(rx, @@match, « s »).
*0*return ? invoke(rx, @@search, « string »).

IN NNP VBZ RB JJR IN NNP , NN NNP .
2
*0*if intmaxlength is not greater than stringlength, return s.
*0*if intmaxlength is not greater than stringlength, return s.

IN NNP VBZ JJ , VB NNP VB DT VBG NN VBG RB IN DT NN NN CD ( NN ) .
2
*0*if fillstring is undefined, let filler be the string value consisting solely of the code unit 0x0020 (space).
*0*if fillstring is undefined, let filler be the string value consisting solely of the code unit 0x0020 (space).

RB , VB NNP VB . NNP ( VBG ) .
2
*0*else, let filler be ? tostring(fillstring).
*0*else, let filler be ? tostring(fillstring).

VB NNP VB DT VBG NN VBG IN JJ NNS IN NNP VBD TO VB NNP .
2
*0*let truncatedstringfiller be the string value consisting of repeated concatenations of filler truncated to length filllen.
*0*let truncatedstringfiller be the string value consisting of repeated concatenations of filler truncated to length filllen.

IN NNP CC NN : CD , VB NNP VB VBN ( NNP NNP NNP , CD ) : RB VB NNP VB VBN ( NNP , NNP ) .
2
*0*if intstart &lt; 0, let from be max(len + intstart, 0); otherwise let from be min(intstart, len).
*0*if intend &lt; 0, let to be max(len + intend, 0); otherwise let to be min(intend, len).

IN NNP VBZ JJ , VB NNP VB JJ : JJ VB NNP VB . NNP ( NNP ) .
2
*0*if limit is undefined, let lim be 232-1; else let lim be ? touint32(limit).
*0*if limit is undefined, let lim be 232-1; else let lim be ? touint32(limit).

RB NNP NNP NNP ,
2
*2*else e ≠ p,
*2*else e ≠ p,

VB NNP VB DT VBG NN JJ TO DT NN IN NNP VBG IN DT NN NNS IN NNS NNP ( JJ ) IN NNP ( JJ ) .
2
*3*let t be the string value equal to the substring of s consisting of the code units at indices p (inclusive) through q (exclusive).
*0*let t be the string value equal to the substring of s consisting of the code units at indices p (inclusive) through s (exclusive).

IN NNP VBZ RB JJ , NN NNP .
2
*1*if z is not failure, return z.
*0*if z is not failure, return z.

VB NNP VB DT NN NNP NNP NNP NNP .
2
*0*let c be the character input[e].
*1*let ch be the character input[index].

IN NNP CC NN : CD CC NNP CC NN : NNP , NN NN .
2
*1*if f &lt; 0 or f &gt; inputlength, return failure.
*1*if f &lt; 0 or f &gt; inputlength, return failure.

VB NNP VB DT JJ NN NN IN NNP IN VBN IN DT NNP JJ NN NN NNP NN IN DT JJ NN .
2
*0*let c be the canonical property name of p as given in the “canonical property name” column of the corresponding row.
*0*let value be the canonical property value of v as given in the “canonical property value” column of the corresponding row.

VB DT NN IN JJ NN NNS IN NNP .
2
*0*return the list of unicode code points of c.
*0*return the list of unicode code points of value.

VB NNP VB DT CD NN IN NN NNP .
2
*0*let a be the one character in charset a.
*0*let b be the one character in charset b.

VB NNP VB DT NN NN IN NN NNP .
2
*0*let i be the character value of character a.
*0*let j be the character value of character b.

IN NNP VBZ `` NN '' , VB NNP VB JJ , JJ NN NNP VB JJ .
2
*0*if flags contains "g", let global be true, else let global be false.
*0*if flags contains "y", let sticky be true, else let sticky be false.

RB NNP TO DT NN IN NNP .
2
*2*append result to the end of results.
*0*append request to the end of queue.

VB NNP VB . VBG ( . NNP ( NNP , `` NNS '' ) ) .
2
*0*let flags be ? tostring(? get(rx, "flags")).
*0*let flags be ? tostring(? get(r, "flags")).

IN NNP VBZ `` NN '' , VB NNP VB NNP .
2
*0*if flags contains "y", let newflags be flags.
*0*if itemkind is "value", let result be elementvalue.

VB NNP VB DT VBG NN JJ TO DT NN IN NNP VBG IN DT NNS IN NNS NNP ( JJ ) IN NNP ( JJ ) .
2
*3*let t be the string value equal to the substring of s consisting of the elements at indices p (inclusive) through q (exclusive).
*0*let t be the string value equal to the substring of s consisting of the elements at indices p (inclusive) through size (exclusive).

VB NNP VB DT JJ NN IN NNS VBN TO DT NN .
2
*0*let len be the actual number of arguments passed to this function.
*0*let len be the actual number of arguments passed to this function.

VB NNP VB DT NN IN NNS VBN TO DT NN .
2
*0*let items be the list of arguments passed to this function.
*0*let items be the list of arguments passed to this function.

VB NNP VB . NNP ( NNP , CD ) .
2
*0*let a be ? arrayspeciescreate(o, 0).
*0*let a be ? arrayspeciescreate(o, 0).

IN NNP NNP NNP CC NN : JJ , VB DT NN NN .
2
*2*if n + len &gt; 253-1, throw a typeerror exception.
*0*if len + argcount &gt; 253-1, throw a typeerror exception.

VB NNP VB VBN ( JJ , NNP ) .
2
*0*let count be min(final-from, len-to).
*0*let count be min(final-from, len-to).

IN NNP CC NN : NNP CC NNP CC NN : NNP , RB
2
*0*if from&lt;to and to&lt;from+count, then
*1*if frombyteindex&lt;tobyteindex and tobyteindex&lt;frombyteindex+countbytes, then

NN NNP ( NNP , `` VB '' ) .
2
*0*return createarrayiterator(o, "key+value").
*0*return createarrayiterator(o, "key+value").

IN NNP VBZ CD , NN JJ .
2
*0*if len is 0, return false.
*0*if n equals 4, return true.

IN NNP CC NN : CD , VB NNP VB CD .
2
*1*if k &lt; 0, let k be 0.
*1*if k &lt; 0, let k be 0.

IN NNP VBZ CD , NN NN .
2
*0*if len is 0, return -1.
*0*if len is 0, return -1.

VB NNP VB DT NN IN VBG JJ NN NN NNP NNP NNP .
2
*2*let same be the result of performing strict equality comparison searchelement === elementk.
*2*let same be the result of performing strict equality comparison searchelement === elementk.

NN , IN NNP VBD CD
2
*0*repeat, while k ≥ 0
*0*repeat, while k ≥ 0

IN NNP VBZ CD , RB
2
*0*if len is zero, then
*0*if len is zero, then

VB NNP VB DT NN WP$ NNS VBP , IN VBN TO JJ NN , DT NNS WDT VBD VBN TO DT NN NN .
2
*0*let items be a list whose elements are, in left to right order, the arguments that were passed to this function invocation.
*1*let items be a list whose elements are, in left to right order, the arguments that were passed to this function invocation.

IN NNP VBZ CD CC NNP VBZ RB JJ , VB DT NN NN .
2
*0*if len is 0 and initialvalue is not present, throw a typeerror exception.
*0*if len is 0 and initialvalue is not present, throw a typeerror exception.

VBN NN TO . NNP ( NNP , NNP ) .
2
*3*set accumulator to ? get(o, pk).
*3*set accumulator to ? get(o, pk).

VBN NN TO . NNP ( NNP , VBD , NNP NNP , NNP , NNP , NNP NNP ) .
2
*2*set accumulator to ? call(callbackfn, undefined, « accumulator, kvalue, k, o »).
*2*set accumulator to ? call(callbackfn, undefined, « accumulator, kvalue, k, o »).

RB IN NNS VBZ JJ CC NNS VBZ JJ , RB
2
*1*else if lowerexists is false and upperexists is true, then
*1*else if lowerexists is true and upperexists is false, then

NN . NNP ( NNP , . VBG ( NNP ) ) .
2
*0*perform ? deletepropertyorthrow(o, ! tostring(len-1)).
*2*perform ? deletepropertyorthrow(o, ! tostring(k-1)).

IN NNP VBZ RB JJ CC JJ ( NNP ) VBZ JJ , VB DT NN NN .
2
*0*if comparefn is not undefined and iscallable(comparefn) is false, throw a typeerror exception.
*0*if comparefn is not undefined and iscallable(comparefn) is false, throw a typeerror exception.

IN NNP VBZ JJ , VB CD .
2
*0*if x is undefined, return 1.
*0*if ysmaller is true, return 1.

VB NNP VB DT NN IN VBG JJ JJ NN NNP CC NN : NNP .
2
*0*let xsmaller be the result of performing abstract relational comparison xstring &lt; ystring.
*0*let ysmaller be the result of performing abstract relational comparison ystring &lt; xstring.

VB NNP VB . NNP ( NNP NNP NNP : CD ) .
2
*2*let from be ! tostring(k + actualdeletecount - 1).
*2*let to be ! tostring(k + itemcount - 1).

NN NNP ( NNP , `` NN '' ) .
2
*0*return createarrayiterator(o, "value").
*0*return createarrayiterator(o, "value").

IN NNP VBZ JJ CC NNP VBZ RB JJ , RB
2
*0*if mapfn is present and mapfn is not undefined, then
*0*if length is present and length is not undefined, then

VB NNP VB DT JJ NN IN NNP CC VB DT NN IN NNP .
2
*2*let kvalue be the first element of values and remove that element from values.
*2*let kvalue be the first element of values and remove that element from values.

NN : NNS VBZ RB DT JJ NN .
2
*1*assert: values is now an empty list.
*1*assert: values is now an empty list.

VB NNP TO DT NN IN NNP .
2
*2*append kvalue to the end of kept.
*1*add w to the end of l.

NN : NNP VBZ DT JJ NN NN JJ IN DT NN IN DT JJ NN NNP NNP NNP JJ NN . IN PRP VBZ JJ DT NN , DT NN IN CD NNS .
2
*0*assert: array is any ecmascript language value other than an object with a [[TYPEDARRAYNAME]] internal slot. if it is such an object, the definition in 22.2.3.23.2 applies.
*0*assert: array is any ecmascript language value other than an object with a [[TYPEDARRAYNAME]] internal slot. if it is such an object, the definition in 22.2.3.23.2 applies.

VB NNP VB . NNP ( . NNP ( NNP , NNP ) ) .
2
*1*let knumber be ? tonumber(? get(src, pk)).
*1*let knumber be ? tonumber(? get(src, pk)).

VBN NNP TO NNP NNP CD .
2
*1*set k to k + 1.
*1*set k to k + 1.

NN : IN NNP CC NNP VBP DT JJ , DT NN MD VB VBN IN DT NN WDT VBZ DT JJ NN IN DT NN NNS .
2
*1*note: if srctype and targettype are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.
*1*note: if srctype and targettype are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.

VB NNP VB NNP ( NNP , NNP , NNP , JJ , `` JJ '' ) .
2
*2*let value be getvaluefrombuffer(srcbuffer, srcbyteindex, srctype, true, "unordered").
*2*let value be getvaluefrombuffer(srcdata, srcbyteindex, srctype, true, "unordered").

NN . NN ( NNP , NNP ) .
2
*0*return ? typedarrayspeciescreate(o, argumentslist).
*0*return ? typedarraycreate(constructor, argumentlist).

VB NNP VB NNP ( NNP , NNP NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP NNP ) .
2
*0*let obj be integerindexedobjectcreate(proto, « [[VIEWEDARRAYBUFFER]], [[TYPEDARRAYNAME]], [[BYTELENGTH]], [[BYTEOFFSET]], [[ARRAYLENGTH]] »).
*1*let resolveelement be createbuiltinfunction(steps, « [[ALREADYCALLED]], [[INDEX]], [[VALUES]], [[CAPABILITY]], [[REMAININGELEMENTS]] »).

NN : NNP . VB JJ NNP NNP NNP VBZ VBN .
2
*0*assert: obj.[[VIEWEDARRAYBUFFER]] is undefined.
*0*assert: o.[[VIEWEDARRAYBUFFER]] is undefined.

NN : NNP ( NNP ) VBZ JJ CC NNP VBZ DT JJ NN NNP NNP NNP JJ NN .
2
*0*assert: type(typedarray) is object and typedarray has a [[TYPEDARRAYNAME]] internal slot.
*0*assert: type(buffer) is object and buffer has an [[ARRAYBUFFERDATA]] internal slot.

IN NNP FW NNP NNP CD , VBP DT NN NN .
2
*0*if offset modulo elementsize ≠ 0, throw a rangeerror exception.
*1*if bufferbytelength modulo elementsize ≠ 0, throw a rangeerror exception.

IN NNP VBZ RB RB JJ CC JJ , RB
2
*0*if length is either not present or undefined, then
*0*if bytelength is either not present or undefined, then

IN NNP VBZ RB JJ CC JJ , VB NNP .
2
*0*if iterable is either undefined or null, return map.
*0*if iterable is either undefined or null, return map.

VB NNP VB NNP ( NNP , NNP , NNP NNP . CC JJ NNP NNP NNP , NNP . CC JJ NNP NNP NNP NNP ) .
2
*1*let status be call(adder, map, « k.[[VALUE]], v.[[VALUE]] »).
*1*let status be call(adder, map, « k.[[VALUE]], v.[[VALUE]] »).

NN . NNP ( NNP , `` VB '' ) .
2
*0*return ? createmapiterator(m, "key+value").
*0*return ? createsetiterator(s, "key+value").

IN NNP . VB JJ NNP NNP NNP VBZ RB JJ CC NNP ( NNP . VB JJ NNP NNP NNP , NNP ) VBZ JJ , VB NNP . CC JJ NNP NNP NNP .
2
*1*if p.[[KEY]] is not empty and samevaluezero(p.[[KEY]], key) is true, return p.[[VALUE]].
*1*if p.[[KEY]] is not empty and samevalue(p.[[KEY]], key) is true, return p.[[VALUE]].

IN NNP . VB JJ NNP NNP NNP VBZ RB JJ CC NNP ( NNP . VB JJ NNP NNP NNP , NNP ) VBZ JJ , VB JJ .
2
*1*if p.[[KEY]] is not empty and samevaluezero(p.[[KEY]], key) is true, return true.
*1*if p.[[KEY]] is not empty and samevalue(p.[[KEY]], key) is true, return true.

VB NNP VB DT NN ( JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : NNP ) .
2
*0*let p be the record { [[KEY]]: key, [[VALUE]]: value }.
*0*let p be the record { [[KEY]]: key, [[VALUE]]: value }.

VB NNS VB DT NN IN NNS IN NNS .
2
*0*let numentries be the number of elements of entries.
*0*let numentries be the number of elements of entries.

NN : NNS MD VB VBN DT NN DT NN VBZ VBN .
2
*0*note: numentries must be redetermined each time this method is evaluated.
*0*note: numentries must be redetermined each time this method is evaluated.

NN , IN NNP VBZ JJR IN NNS ,
2
*0*repeat, while index is less than numentries,
*0*repeat, while index is less than numentries,

VBN NN TO NNP .
2
*1*set index to index+1.
*1*set index to index+1.

IN NNP VBZ RB JJ CC NNP ( NNP , NNP ) VBZ JJ , VB JJ .
2
*1*if e is not empty and samevaluezero(e, value) is true, return true.
*1*if e is not empty and samevalue(e, value) is true, return true.

VB NNP VB DT JJ NNS IN NNP VBD CC VBD IN DT JJ NN VBG NN IN DT JJ JJ NN NN .
2
*1*let value be the byte elements of rawbytes concatenated and interpreted as a little-endian bit string encoding of an ieee 754-2008 binary32 value.
*1*let value be the byte elements of rawbytes concatenated and interpreted as a little-endian bit string encoding of an ieee 754-2008 binary64 value.

IN NNP VBZ DT JJ JJ NN IN NN , VB DT JJ NN NN .
2
*1*if value is an ieee 754-2008 binary32 nan value, return the nan number value.
*1*if value is an ieee 754-2008 binary64 nan value, return the nan number value.

IN NNP VBZ JJ CC NNP VBZ `` JJ '' , `` JJ '' , `` NN '' , `` JJ '' , `` NN '' , CC `` JJ '' , VB NNP VB JJ : RB VB NNP VB JJ .
2
*1*if istypedarray is true and type is "int8", "uint8", "int16", "uint16", "int32", or "uint32", let notear be true; otherwise let notear be false.
*1*if istypedarray is true and type is "int8", "uint8", "int16", "uint16", "int32", or "uint32", let notear be true; otherwise let notear be false.

VB NNP VB DT NN IN JJ NNP IN RB VBN NN NNS .
2
*1*let rawvalue be a list of length elementsize of nondeterministically chosen byte values.
*0*let rawbytesread be a list of length elementsize of nondeterministically chosen byte values.

NN . NNP ( NN , NNP ) .
2
*0*return ? allocatearraybuffer(newtarget, bytelength).
*0*return ? allocatesharedarraybuffer(newtarget, bytelength).

IN NNP . VB JJ NNP NNP NNP CC NN : NNP , VBP DT NN NN .
2
*0*if new.[[ARRAYBUFFERBYTELENGTH]] &lt; newlen, throw a typeerror exception.
*0*if new.[[ARRAYBUFFERBYTELENGTH]] &lt; newlen, throw a typeerror exception.

NN : NNP VBZ DT VBN NN NN .
2
*0*assert: bufferdata is a shared data block.
*0*assert: block is a shared data block.

IN NNP VBZ RB VB DT JJ NNP NNP NNP NNP JJ NN , VB DT NN NN .
2
*0*if view does not have a [[DATAVIEW]] internal slot, throw a typeerror exception.
*0*if view does not have a [[DATAVIEW]] internal slot, throw a typeerror exception.

NN NNP TO NNP ( NNP ) .
2
*0*set islittleendian to toboolean(islittleendian).
*0*set islittleendian to toboolean(islittleendian).

NN . NNP ( NNP , NNP , NNP , `` JJ '' ) .
2
*0*return ? getviewvalue(v, byteoffset, littleendian, "uint16").
*0*return ? getviewvalue(v, byteoffset, littleendian, "uint32").

NN . NNP ( NNP , NNP , NNP , `` JJ '' , NNP ) .
2
*0*return ? setviewvalue(v, byteoffset, littleendian, "uint16", value).
*0*return ? setviewvalue(v, byteoffset, littleendian, "uint32", value).

NN . NNP ( NNP , NNP , NNP , CC ) .
2
*0*return ? atomicreadmodifywrite(typedarray, index, value, and).
*0*return ? atomicreadmodifywrite(typedarray, index, value, or).

IN NNP VBZ CD , NN NNP . VB JJ NNP NNP NNP .
2
*0*if n equals 1, return ar.[[ISLOCKFREE1]].
*0*if n equals 2, return ar.[[ISLOCKFREE2]].

VB NNP VB ( NNP NNP CD ) NN NNP .
2
*0*let indexedposition be (i × 4) + offset.
*0*let indexedposition be (i × 4) + offset.

VB DT NN `` JJ '' .
2
*1*return the string "not-equal".
*0*return the string "timed-out".

RB CD TO NNP .
2
*1*add 1 to n.
*3*add 1 to i.

NN : DT VBZ RB VBZ RB VB DT NN IN JJ NNS RB .
2
*4*note: this algorithm intentionally does not throw an exception if createdataproperty returns false.
*4*note: this algorithm intentionally does not throw an exception if createdataproperty returns false.

IN NNP VBZ NNP , VBP DT NN NN IN DT NN VBZ JJ .
2
*0*if stack contains value, throw a typeerror exception because the structure is cyclical.
*0*if stack contains value, throw a typeerror exception because the structure is cyclical.

VB NNS VB DT VBG NN VBN IN VBG PDT DT JJ NNS IN NNP IN DT JJ NN IN NNS VBN IN DT NN NN CD ( NN ) . DT NN VBZ RB VBN CC IN DT JJ NN CC IN DT JJ NN .
2
*2*let properties be the string value formed by concatenating all the element strings of partial with each adjacent pair of strings separated with the code unit 0x002c (comma). a comma is not inserted either before the first string or after the last string.
*2*let properties be the string value formed by concatenating all the element strings of partial with each adjacent pair of strings separated with the code unit 0x002c (comma). a comma is not inserted either before the first string or after the last string.

VB NNP VB DT NN IN DT NN NN CD ( NN ) , DT NN NN CD ( NN NN ) , CC NNP .
2
*2*let separator be the string-concatenation of the code unit 0x002c (comma), the code unit 0x000a (line feed), and indent.
*2*let separator be the string-concatenation of the code unit 0x002c (comma), the code unit 0x000a (line feed), and indent.

VB NNS VB DT VBG NN VBN IN VBG PDT DT JJ NNS IN NNP IN DT JJ NN IN NNS VBN IN NNP . DT NNP NN VBZ RB VBN CC IN DT JJ NN CC IN DT JJ NN .
2
*2*let properties be the string value formed by concatenating all the element strings of partial with each adjacent pair of strings separated with separator. the separator string is not inserted either before the first string or after the last string.
*2*let properties be the string value formed by concatenating all the element strings of partial with each adjacent pair of strings separated with separator. the separator string is not inserted either before the first string or after the last string.

VB DT DT NN .
2
*0*return the this value.
*0*return the this value.

NN . NNP ( NNP . VB JJ NNP NNP NNP , VBD , VB DT RB VBN NN JJ NN ) .
2
*1*perform ! call(promisecapability.[[REJECT]], undefined, « a newly created typeerror object »).
*1*perform ! call(promisecapability.[[REJECT]], undefined, « a newly created typeerror object »).

VB NNP VB NN ( JJ NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : JJ ) .
2
*0*let c be completion { [[TYPE]]: return, [[VALUE]]: value, [[TARGET]]: empty }.
*0*let completion be completion { [[TYPE]]: return, [[VALUE]]: value, [[TARGET]]: empty }.

VB DT NN NN IN NNP TO NNP .
2
*0*set the generator component of gencontext to generator.
*0*set the generator component of gencontext to generator.

RB DT NN VBZ DT `` VBN '' NN PRP RB VBZ PRP CC PRP$ JJ NN NN VBZ RB VBN . DT NN NN VBN IN NNP MD VB VBN IN DT NN .
2
*1*once a generator enters the "completed" state it never leaves it and its associated execution context is never resumed. any execution state associated with generator can be discarded at this point.
*1*once a generator enters the "completed" state it never leaves it and its associated execution context is never resumed. any execution state associated with generator can be discarded at this point.

NN : NNP VBZ CC `` NN '' CC `` JJ '' .
2
*0*assert: state is either "suspendedstart" or "suspendedyield".
*0*assert: state is either "suspendedstart" or "suspendedyield".

VBN NNP TO `` VBN '' .
2
*1*set state to "completed".
*2*set state to "completed".

IN NNP VBZ `` VBN '' , RB
2
*0*if state is "completed", then
*1*if state is "completed", then

VB DT JJ NN IN NNP VBG NNP IN DT NN IN DT NN WDT VBD PRP . VB NNP VB DT NN NN VBN IN DT JJ NN .
2
*0*resume the suspended evaluation of gencontext using abruptcompletion as the result of the operation that suspended it. let result be the completion record returned by the resumed computation.
*0*resume the suspended evaluation of gencontext using completion as the result of the operation that suspended it. let result be the completion record returned by the resumed computation.

NN : NNP VBZ DT NN NN IN DT NN .
2
*0*assert: gencontext is the execution context of a generator.
*0*assert: gencontext is the execution context of a generator.

VB NNP VB DT NN IN DT NN NN IN NNP .
2
*0*let generator be the value of the generator component of gencontext.
*0*let generator be the value of the generator component of gencontext.

VB DT NN NN NN IN NNP JJ IN WRB NN VBZ VBN IN DT NN NNP DT JJ NNS MD VB VBN :
2
*0*set the code evaluation state of gencontext such that when evaluation is resumed with a completion resumptionvalue the following steps will be performed:
*0*set the code evaluation state of gencontext such that when evaluation is resumed with a completion resumptionvalue the following steps will be performed:

NN : DT VBZ TO DT NN IN DT NN WDT VBD RBS RB VBN NN IN NNP .
2
*0*note: this returns to the evaluation of the operation that had most previously resumed evaluation of gencontext.
*0*note: this returns to the evaluation of the operation that had most previously resumed evaluation of gencontext.

NN : NNP VBZ RB DT JJ NN .
2
*0*assert: queue is not an empty list.
*0*assert: queue is not an empty list.

VB NNP VB DT JJ NNS VBN IN JJ NN NN VBD NNS .
2
*3*let stepsfulfilled be the algorithm steps defined in asyncgeneratorresumenext return processor fulfilled functions.
*3*let stepsrejected be the algorithm steps defined in asyncgeneratorresumenext return processor rejected functions.

VB NNP VB DT JJ NNS VBN IN NN NN NNS ( CD ) .
2
*0*let stepsresolve be the algorithm steps defined in promise resolve functions (25.6.1.3.2).
*0*let stepsreject be the algorithm steps defined in promise reject functions (25.6.1.3.1).

NN : DT NN IN NNP . VB JJ NNP NNP NNP VBZ `` VBG '' .
2
*0*assert: the value of promise.[[PROMISESTATE]] is "pending".
*0*assert: the value of promise.[[PROMISESTATE]] is "pending".

IN NNP . VB NNP NNP NNP NNP VBZ JJ , JJ NNP ( NNP , `` VB '' ) .
2
*0*if promise.[[PROMISEISHANDLED]] is false, perform hostpromiserejectiontracker(promise, "reject").
*1*if promise.[[PROMISEISHANDLED]] is false, perform hostpromiserejectiontracker(promise, "handle").

IN NNP . NN IN NNP NNP NNP VBZ JJ , VB NNP VB NNP ( NNP , NNP ) .
2
*1*if iteratorrecord.[[DONE]] is false, let result be iteratorclose(iteratorrecord, result).
*1*if iteratorrecord.[[DONE]] is false, let result be iteratorclose(iterator, result).

VBN NNP . NN IN NNP NNP NNP TO JJ .
2
*2*set iteratorrecord.[[DONE]] to true.
*2*set iteratorrecord.[[DONE]] to true.

VB NNP VB . NNP ( NNP , `` NN '' , NNP NNP NNP ) .
2
*1*let nextpromise be ? invoke(constructor, "resolve", « nextvalue »).
*1*let nextpromise be ? invoke(constructor, "resolve", « nextvalue »).

VBN NNP . VB NNP NNP NNP NNP TO NNP .
2
*1*set thenfinally.[[ONFINALLY]] to onfinally.
*1*set catchfinally.[[ONFINALLY]] to onfinally.

VB NNP VB DT NN ( JJ NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : `` NN '' , NNP NNP NNP NNP NN : VBN ) .
2
*0*let fulfillreaction be the promisereaction { [[CAPABILITY]]: resultcapability, [[TYPE]]: "fulfill", [[HANDLER]]: onfulfilled }.
*0*let rejectreaction be the promisereaction { [[CAPABILITY]]: resultcapability, [[TYPE]]: "reject", [[HANDLER]]: onrejected }.

JJ NNP IN DT JJ NN IN DT NN WDT VBZ NNP . VB JJ NNP NNP NNP .
2
*1*append fulfillreaction as the last element of the list that is promise.[[PROMISEFULFILLREACTIONS]].
*1*append rejectreaction as the last element of the list that is promise.[[PROMISEREJECTREACTIONS]].

IN DT NN NNP IN NNP ( NNP ) , VBP
2
*0*for each event e in eventset(execution), do
*0*for each event e in eventset(execution), do

NN : IN NNP . VB JJ NNP NNP NNP VBZ DT NN CC NN , RB NNP . CC JJ NNP NNP NNP VBZ RB JJ .
1
*0*assert: if completionrecord.[[TYPE]] is either return or throw, then completionrecord.[[VALUE]] is not empty.

IN NNP . CC JJ NNP NNP NNP VBZ RB JJ , JJ NNP ( NNP ) .
1
*0*if completionrecord.[[VALUE]] is not empty, return completion(completionrecord).

NN NN ( JJ NNP NNP NNP NN : NNP . VB JJ NNP NNP NNP , NNP NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : NNP . VB JJ NNP NNP NNP ) .
1
*0*return completion { [[TYPE]]: completionrecord.[[TYPE]], [[VALUE]]: value, [[TARGET]]: completionrecord.[[TARGET]] }.

VB DT NN NN NN IN NNP .
1
*0*return the base value component of v.

IN NNP ( NNP POS NN NN NN ) VBZ JJ , NN , NN , CC NN , VBP JJ : RB NN JJ .
1
*0*if type(v's base value component) is boolean, string, symbol, or number, return true; otherwise return false.

IN CC DT NN NN NN IN NNP VBZ DT NN CC NNP ( NNP ) VBZ JJ , VB JJ : RB NN JJ .
1
*0*if either the base value component of v is an object or hasprimitivebase(v) is true, return true; otherwise return false.

IN DT NN NN NN IN NNP VBZ JJ , VB JJ : RB NN JJ .
1
*0*if the base value component of v is undefined, return true; otherwise return false.

IN NNP VBZ DT JJ NN , NN JJ : RB NN JJ .
1
*0*if v has a thisvalue component, return true; otherwise return false.

NN . NNP . VB JJ NNP NNP NNP ( NNP ( NNP ) , NNP ( NNP ) ) .
1
*1*return ? base.[[GET]](getreferencedname(v), getthisvalue(v)).

NN . NNP ( NNP ( NNP ) , NNP ( NNP ) ) ( VB CD ) .
1
*1*return ? base.getbindingvalue(getreferencedname(v), isstrictreference(v)) (see 8.1.1).

IN NNP ( NNP ) VBZ RB NN , VB DT NN NN .
1
*0*if type(v) is not reference, throw a referenceerror exception.

NN . NNP ( NNP , NNP ( NNP ) , NNP , RB ) .
1
*1*return ? set(globalobj, getreferencedname(v), w, false).

VB NNP VB . NNP . NN NN NNP NNP NNP ( NNP ( NNP ) , NNP , NNP ( NNP ) ) .
1
*1*let succeeded be ? base.[[SET]](getreferencedname(v), w, getthisvalue(v)).

IN VBN VBZ JJ CC NNP ( NNP ) VBZ JJ , VB DT NN NN .
1
*1*if succeeded is false and isstrictreference(v) is true, throw a typeerror exception.

NN . NNP ( NNP ( NNP ) , NNP , NNP ( NNP ) ) ( VB CD ) .
1
*1*return ? base.setmutablebinding(getreferencedname(v), w, isstrictreference(v)) (see 8.1.1).

VB DT NN IN DT JJ NN IN DT NN NNP .
1
*1*return the value of the thisvalue component of the reference v.

NN NNP ( NNP ( NNP ) , NNP ) .
1
*0*return base.initializebinding(getreferencedname(v), w).

IN DT NNP . VB JJ NNP NNP NNP CC NNP . NN NN NNP NNP NNP VBP JJ , NN JJ .
1
*0*if both desc.[[GET]] and desc.[[SET]] are absent, return false.

IN DT NNP . CC JJ NNP NNP NNP CC NNP . VB JJ NNP NN NN VBP JJ , NN JJ .
1
*0*if both desc.[[VALUE]] and desc.[[WRITABLE]] are absent, return false.

IN NNP ( NNP ) CC NNP ( NNP ) VBP DT JJ , VB JJ .
1
*0*if isaccessordescriptor(desc) and isdatadescriptor(desc) are both false, return true.

NN : NNP VBZ DT JJ JJ NN IN DT JJ NNS .
1
*0*assert: obj is an extensible ordinary object with no own properties.

NN NNP ( NNP , `` NN '' , NNP . CC JJ NNP NNP NNP ) .
1
*1*perform createdataproperty(obj, "value", desc.[[VALUE]]).

IN NNP VBZ DT NN NNP NNP NNP NNP NN , RB
1
*0*if desc has a [[GET]] field, then

NN NNP ( NNP , `` NN '' , NNP . VB JJ NNP NNP NNP ) .
1
*1*perform createdataproperty(obj, "get", desc.[[GET]]).

NN NNP ( NNP , `` NN '' , NNP . NN NN NNP NNP NNP ) .
1
*1*perform createdataproperty(obj, "set", desc.[[SET]]).

NN : DT IN DT JJ NN NNS VBP JJ .
1
*0*assert: all of the above createdataproperty operations return true.

VB NNP VB DT JJ NN NN WDT RB VBZ DT NNS .
1
*0*let desc be a new property descriptor that initially has no fields.

VB JJ VB NNP ( . NNP ( NNP , `` JJ '' ) ) .
1
*1*let writable be toboolean(? get(obj, "writable")).

VBN NNP . NN NN NNP NNP NNP TO NNP .
1
*1*set desc.[[SET]] to setter.

IN NNP . VB JJ NNP NNP NNP VBZ JJ CC NNP . NN NN NNP NNP NNP VBZ JJ , RB
1
*0*if desc.[[GET]] is present or desc.[[SET]] is present, then

IN NNP . CC JJ NNP NNP NNP VBZ JJ CC NNP . VB JJ NNP NNP NNP VBZ JJ , VB DT NN NN .
1
*1*if desc.[[VALUE]] is present or desc.[[WRITABLE]] is present, throw a typeerror exception.

VB NNP VB JJ ( JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ , NNP NNP NNP NNP NN : JJ , JJ NN NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) .
1
*0*let like be record { [[VALUE]]: undefined, [[WRITABLE]]: false, [[GET]]: undefined, [[SET]]: undefined, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }.

IN NNP VBZ RB VB DT NN NNP NNP NNP NNP NN , VBN NNP . CC JJ NNP NNP NNP TO NNP . CC JJ NNP NNP NNP .
1
*1*if desc does not have a [[VALUE]] field, set desc.[[VALUE]] to like.[[VALUE]].

IN NNP VBZ RB VB DT NN NNP NNP NNP NNP NN , VBN NNP . VB JJ NNP NNP NNP TO NNP . VB JJ NNP NNP NNP .
1
*1*if desc does not have a [[GET]] field, set desc.[[GET]] to like.[[GET]].

IN NNP VBZ RB VB DT JJ NN NNP NNP NNP NN , VBN NNP . NN NN NNP NNP NNP TO NNP . NN NN NNP NNP NNP .
1
*1*if desc does not have a [[SET]] field, set desc.[[SET]] to like.[[SET]].

VB NNP VB DT JJ NN NN NN VBG IN NNP NNS . IN PRP VBZ JJ TO VB JJ DT NN NN , VBP DT NN NN .
1
*0*let db be a new data block value consisting of size bytes. if it is impossible to create such a data block, throw a rangeerror exception.

VBN DT IN DT NNS IN NNP TO CD .
1
*0*set all of the bytes of db to 0.

VB NNP VB DT JJ VBN NNS NN NN VBG IN NNP NNS . IN PRP VBZ JJ TO VB JJ DT VBN NN NN , VBP DT NN NN .
1
*0*let db be a new shared data block value consisting of size bytes. if it is impossible to create such a shared data block, throw a rangeerror exception.

VB NNP VB JJ CD NN .
1
*0*let zero be « 0 ».

RB JJ ( JJ NN NNP NNP NN : `` NN '' , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : CD , NNP NNP NNP NNP NN : NN ) TO NNP .
1
*1*append writesharedmemory { [[ORDER]]: "init", [[NOTEAR]]: true, [[BLOCK]]: db, [[BYTEINDEX]]: i, [[ELEMENTSIZE]]: 1, [[PAYLOAD]]: zero } to eventlist.

NN : NNP CC NNP VBP JJ NNS NN CC VBN NNS NN NNS .
1
*0*assert: fromblock and toblock are distinct data block or shared data block values.

NN : NN , NNP , CC NNP VBP JJ NNS VBP CD .
1
*0*assert: fromindex, toindex, and count are integer values ≥ 0.

VB NNP VB DT NN IN NN CD WDT VBZ DT RB VBN NN NN .
1
*2*let bytes be a list of length 1 that contains a nondeterministically chosen byte value.

NN : IN NNS , NNP VBZ DT NN IN DT JJ JJ NN IN DT JJ NN . DT NN VBZ DT JJ NN IN DT NN NN TO VB JJ NN IN NN IN JJ NN .
1
*2*note: in implementations, bytes is the result of a non-atomic read instruction on the underlying hardware. the nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.

VB NNP VB JJ ( JJ NN NNP NNP NN : `` JJ '' , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : CD ) .
1
*2*let readevent be readsharedmemory { [[ORDER]]: "unordered", [[NOTEAR]]: true, [[BLOCK]]: fromblock, [[BYTEINDEX]]: fromindex, [[ELEMENTSIZE]]: 1 }.

NN VBZ NN NN ( JJ FW NNP NNP NN : NN , NNP NNP NNP NNP NN : NNS ) TO NNP . VB JJ NNP NNP NNP .
1
*2*append chosen value record { [[EVENT]]: readevent, [[CHOSENVALUE]]: bytes } to execution.[[CHOSENVALUES]].

RB JJ ( JJ NN NNP NNP NN : `` JJ '' , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : CD , NNP NNP NNP NNP NN : NNS ) TO NNP .
1
*3*append writesharedmemory { [[ORDER]]: "unordered", [[NOTEAR]]: true, [[BLOCK]]: toblock, [[BYTEINDEX]]: toindex, [[ELEMENTSIZE]]: 1, [[PAYLOAD]]: bytes } to eventlist.

VBN NNP NNP NNP NNP TO NNP NNP CD NN .
1
*3*set toblock[toindex] to bytes[0].

NN : NNP VBZ RB DT VBN NN NN .
1
*2*assert: toblock is not a shared data block.

VBN NNP NNP NNP NNP TO NNP NNP NNP NNP .
1
*2*set toblock[toindex] to fromblock[fromindex].

JJ NNP CC NNP DT IN CD .
1
*1*increment toindex and fromindex each by 1.

IN NNP VBZ RB JJ , VB NNP VB `` NN '' .
1
*1*if preferredtype is not present, let hint be "default".

RB IN NNP VBZ JJ NN , VB NNP VB `` VBG '' .
1
*1*else if preferredtype is hint string, let hint be "string".

RB NNP VBZ JJ NN , VB NNP VB `` NN '' .
1
*1*else preferredtype is hint number, let hint be "number".

IN NNP VBZ `` NN '' , VBD NNP TO `` NN '' .
1
*1*if hint is "default", set hint to "number".

NN : NNP ( NNP ) VBZ VBG CC PRP$ NN VBZ CC `` NN '' CC `` NN '' .
1
*0*assert: type(hint) is string and its value is either "string" or "number".

IN NNP VBZ `` VBG '' , RB
1
*0*if hint is "string", then

VB NNP VB VBN `` VBG '' , `` NN '' NN .
1
*1*let methodnames be « "tostring", "valueof" ».

VB NNP VB VBN `` NN '' , `` VBG '' NN .
1
*1*let methodnames be « "valueof", "tostring" ».

IN NNP VBZ NNP , NNP , NNP , CC NN , NN NNP .
1
*0*if number is +0, -0, +∞, or -∞, return number.

VB DT NN NN WDT VBZ DT JJ NN IN NNP CC WP$ NN VBZ NN ( JJ ( NNP ) ) .
1
*0*return the number value that is the same sign as number and whose magnitude is floor(abs(number)).

IN NNP NNP CD , NN NN .
1
*0*if number ≤ 0, return +0.

IN NNP NNP CD , NN CD .
1
*0*if number ≥ 255, return 255.

VB NNP VB NN ( NNP ) .
1
*0*let f be floor(number).

IN NNP NNP CD CC NN : NNP , NN NNP VBD CD .
1
*0*if f + 0.5 &lt; number, return f + 1.

IN NNP CC NN : NNP VBD CD , NN NNP .
1
*0*if number &lt; f + 0.5, return f.

IN NNP VBZ JJ , VB NNP NNP CD .
1
*0*if f is odd, return f + 1.

IN NNP VBZ JJ CC JJ , VB DT NN `` CD '' .
1
*0*if m is +0 or -0, return the string "0".

IN NNP VBZ JJR IN CD , VBP DT NNP IN `` : '' CC . NN ( NNP ) .
1
*0*if m is less than zero, return the string-concatenation of "-" and ! numbertostring(-m).

IN NNP VBZ JJ , VB DT NN `` NN '' .
1
*0*if m is +∞, return the string "infinity".

RB , VB NNP , NNP , CC NNP VB NNS JJ IN NNP NNP CD , JJ NNP NNP CC NN : CD , DT NN NN IN NNP NNP CD VBZ NNP , CC NNP VBZ RB JJ IN JJ . NN IN NNP VBZ DT NN IN NNS IN DT JJ NN IN NNP , IN NNP VBZ RB JJ IN CD , CC IN DT JJS JJ NN IN NNP VBZ RB RB RB VBN IN DT NNS .
1
*0*otherwise, let n, k, and s be integers such that k ≥ 1, 10k-1 ≤ s &lt; 10k, the number value for s × 10n-k is m, and k is as small as possible. note that k is the number of digits in the decimal representation of s, that s is not divisible by 10, and that the least significant digit of s is not necessarily uniquely determined by these criteria.

IN NNP NNP NNP NNP CD , VBP DT NN IN : DT NN NNS IN DT NNP NNS IN DT JJ NN IN NNP ( IN NN , IN DT VBG NNS ) NNP NNS IN DT NN NN CD ( JJ NN
1
*0*if k ≤ n ≤ 21, return the string-concatenation of:the code units of the k digits of the decimal representation of s (in order, with no leading zeroes) n-k occurrences of the code unit 0x0030 (digit zero)

IN CD CC NN : NNP VBZ CD , VBP DT NN IN : DT NN NNS IN DT RBS JJ NNP NNS IN DT JJ NN IN NNP DT NN NN CD ( JJ NN ) DT NN NNS IN DT VBG NNP NNS IN DT JJ NN IN NNP
1
*0*if 0 &lt; n ≤ 21, return the string-concatenation of:the code units of the most significant n digits of the decimal representation of s the code unit 0x002e (full stop) the code units of the remaining k-n digits of the decimal representation of s

IN NNP CC NN : NNP VBZ CD , VBP DT NN IN : DT NN NN CD ( JJ NN ) DT NN NN CD ( JJ NN ) NN NNS IN DT NN NN CD ( JJ NN ) DT NN NNS IN DT NNP NNS IN DT JJ NN IN NNP
1
*0*if -6 &lt; n ≤ 0, return the string-concatenation of:the code unit 0x0030 (digit zero) the code unit 0x002e (full stop) -n occurrences of the code unit 0x0030 (digit zero) the code units of the k digits of the decimal representation of s

RB , IN NNP NNP CD , VBP DT NN IN : DT NN NN IN DT JJ NN IN NNP NN NN CD ( VB JJ NN NN ) DT NN NN CD ( CC NN ) CC DT NN NN CD ( NN ) VBG TO IN NNP VBZ JJ CC JJ NN NNS IN DT JJ NN IN DT NN NN ( NNP ) ( IN DT VBG NNS
1
*0*otherwise, if k = 1, return the string-concatenation of:the code unit of the single digit of sthe code unit 0x0065 (latin small letter e)the code unit 0x002b (plus sign) or the code unit 0x002d (hyphen-minus) according to whether n-1 is positive or negativethe code units of the decimal representation of the integer abs(n-1) (with no leading zeroes)

VB DT NN IN : DT NN NNS IN DT RBS JJ NN IN DT JJ NN IN NNP NN NN CD ( JJ NN ) DT NN NNS IN DT VBG NNP NNS IN DT JJ NN IN NNP NN NN CD ( VB JJ NN NN ) DT NN NN CD ( CC NN ) CC DT NN NN CD ( NN ) VBG TO IN NNP VBZ JJ CC JJ NN NNS IN DT JJ NN IN DT NN NN ( NNP ) ( IN DT VBG NNS
1
*0*return the string-concatenation of:the code units of the most significant digit of the decimal representation of sthe code unit 0x002e (full stop)the code units of the remaining k-1 digits of the decimal representation of sthe code unit 0x0065 (latin small letter e)the code unit 0x002b (plus sign) or the code unit 0x002d (hyphen-minus) according to whether n-1 is positive or negativethe code units of the decimal representation of the integer abs(n-1) (with no leading zeroes)

NN NN ( NNP , JJ ) .
1
*0*return min(len, 253-1).

IN NNP VBZ `` JJ '' , VB NNP .
1
*0*if argument is "-0", return -0.

IN NNP ( . NNP ( NNP ) , NNP ) VBZ JJ , NN VBD .
1
*0*if samevalue(! tostring(n), argument) is false, return undefined.

IN NNP VBZ DT NN JJ NN , NN JJ .
1
*0*if argument is an array exotic object, return true.

IN NNP VBZ DT JJ NNP NNP NNP NNP JJ NN , NN JJ .
1
*0*if argument has a [[CONSTRUCT]] internal method, return true.

IN NN ( JJ ( NNP ) ) FW NN ( NNP ) , VBP JJ .
1
*0*if floor(abs(argument)) ≠ abs(argument), return false.

IN NNP ( NNP ) VBZ VBG , NN JJ .
1
*0*if type(argument) is string, return true.

IN NNP MD VB DT NN IN NNP CC DT JJ NN NNP , NN JJ . RB , NN JJ .
1
*0*if q can be the string-concatenation of p and some other string r, return true. otherwise, return false.

NN : DT NN VBZ DT NN IN PRP , IN NNP MD VB DT JJ NN .
1
*0*note: any string is a prefix of itself, because r may be the empty string.

NN : NNP ( NNP ) VBZ RB NN .
1
*0*assert: type(x) is not number.

NN : NNP ( NNP ) VBZ DT JJ IN NNP ( NNP ) .
1
*0*assert: type(x) is the same as type(y).

IN NNP CC NNP VBP RB DT JJ NN IN NN NNS ( JJ NN CC JJ NN NNS IN VBG NNS ) , VBP JJ : RB , NN JJ .
1
*1*if x and y are exactly the same sequence of code units (same length and same code units at corresponding indices), return true; otherwise, return false.

IN NNP CC NNP VBP DT JJ CC DT JJ , VB JJ : RB , NN JJ .
1
*1*if x and y are both true or both false, return true; otherwise, return false.

IN NNP CC NNP VBP DT DT JJ NN NN , VB JJ : RB , NN JJ .
1
*1*if x and y are both the same symbol value, return true; otherwise, return false.

IN NNP CC NNP VBP DT JJ JJ NN , VB JJ . RB , NN JJ .
1
*0*if x and y are the same object value, return true. otherwise, return false.

VB NNP VB . NNP . NN NN NNP NNP NNP ( NNP , NNP , NNP ) .
1
*0*let success be ? o.[[SET]](p, v, o).

IN NNP VBZ JJ CC NNP VBZ JJ , VB DT NN NN .
1
*0*if success is false and throw is true, throw a typeerror exception.

VB NNP VB . NNP . VB NNP NNP NNP NNP ( NNP , NNP ) .
1
*0*let success be ? o.[[DEFINEOWNPROPERTY]](p, desc).

IN NNP VBZ RB JJ CC JJ , NN VBD .
1
*0*if func is either undefined or null, return undefined.

IN NNP VBZ RB JJ , VB NNP TO NNP .
1
*0*if newtarget is not present, set newtarget to f.

NN . NNP . NNP NNP NNP NNP NNP ( NNP , NNP ) .
1
*0*return ? f.[[CONSTRUCT]](argumentslist, newtarget).

NN . NNP ( NNP , NNP , NN ( JJ NNP NNP NNP NN : JJ ) ) .
1
*2*perform ? definepropertyorthrow(o, k, propertydescriptor { [[CONFIGURABLE]]: false }).

RB NNP VBZ `` JJ '' ,
1
*0*else level is "frozen",

VB NNP VB DT NN ( JJ NNP NNP NNP NN : JJ ) .
1
*4*let desc be the propertydescriptor { [[CONFIGURABLE]]: false }.

VB NNP VB DT NN ( JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) .
1
*4*let desc be the propertydescriptor { [[CONFIGURABLE]]: false, [[WRITABLE]]: false }.

NN : IN DT NN VBZ JJ , NN IN PRP$ NNS VBP VBN .
1
*0*note: if the object is extensible, none of its properties are examined.

IN NNP VBZ `` JJ '' CC NNP ( NNP ) VBZ JJ , RB
1
*2*if level is "frozen" and isdatadescriptor(currentdesc) is true, then

NN : NNS VBZ DT NN WP$ NNS VBP DT JJ NN NNS .
1
*0*assert: elements is a list whose elements are all ecmascript language values.

IN NNP VBZ RB JJ , VBN NNS TO VB JJ , JJ , JJ , NN , NN , NN , JJ NN .
1
*0*if elementtypes is not present, set elementtypes to « undefined, null, boolean, string, symbol, number, object ».

IN NNP ( NNP ) VBZ RB DT NN IN NNP , VBP DT NN NN .
1
*1*if type(next) is not an element of elementtypes, throw a typeerror exception.

IN NNP VBZ DT JJ JJ NNP NNP NNP JJ NN , RB
1
*0*if c has a [[BOUNDTARGETTION]] internal slot, then

VBN NNP TO . NNP . VB JJ NNP NNP NNP ( ) .
1
*1*set o to ? o.[[GETPROTOTYPEOF]]().

IN NNP ( NNP ) VBZ JJ , JJ NNP .
1
*0*if isconstructor(s) is true, return s.

IN NNP VBZ `` JJ '' , VBP NNP TO NNP .
1
*3*if kind is "key", append key to properties.

IN NNP VBZ `` NN '' , VBP NNP TO NNP .
1
*4*if kind is "value", append value to properties.

NN DT NNS IN NNS IN PRP VBP IN DT JJ JJ NN IN MD VB VBN IN DT NN WDT MD VB VBN IN DT NNS JJ NN VBD VBN IN NNP .
1
*0*order the elements of properties so they are in the same relative order as would be produced by the iterator that would be returned if the enumerateobjectproperties internal method were invoked with o.

IN NNP VBZ DT JJ NNP NNP NNP NNP JJ NN , RB
1
*0*if obj has a [[REALM]] internal slot, then

VB DT JJ NN NN .
1
*0*return the current realm record.

IN NNP VBZ JJ CC JJ , VB NNP .
1
*0*if source is undefined or null, return target.

NN : NN VBZ DT NN CC NN .
1
*0*assert: hint is either sync or async.

VBN NNP TO . NNP ( NNP , NNP NNP NN ) .
1
*2*set method to ? getmethod(obj, @@asynciterator).

RB , VBD NNP TO . NNP ( NNP , NNP NNP NN ) .
1
*1*otherwise, set method to ? getmethod(obj, @@iterator).

VB NNP VB JJ ( JJ NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : JJ ) .
1
*0*let iteratorrecord be record { [[ITERATOR]]: iterator, [[NEXTMETHOD]]: nextmethod, [[DONE]]: false }.

VB NNP VB . NNP ( NNP . VB JJ NNP NNP NNP , NNP . VB JJ NNP NNP NNP , NNP NNP NNP ) .
1
*1*let result be ? call(iteratorrecord.[[NEXTMETHOD]], iteratorrecord.[[ITERATOR]], « value »).

NN NNP ( . NNP ( NNP , `` VBN '' ) ) .
1
*0*return toboolean(? get(iterresult, "done")).

IN NNP . VB JJ NNP NNP NNP VBZ JJ , VBN NNP TO VB ( NNP . CC JJ NNP NNP NNP ) .
1
*0*if innerresult.[[TYPE]] is normal, set innerresult to await(innerresult.[[VALUE]]).

NN NNP ( NNP , `` VBN '' , NNP ) .
1
*0*perform createdataproperty(obj, "done", done).

VB NNP VB DT JJ NNS VBN IN NN JJ ( CD ) .
1
*0*let steps be the algorithm steps defined in listiterator next (7.4.9.1).

VB NNP VB NNP ( NNP , NNP NNP ) .
1
*0*let next be createbuiltinfunction(steps, « »).

NN NN ( JJ NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : JJ ) .
1
*0*return record { [[ITERATOR]]: iterator, [[NEXTMETHOD]]: next, [[DONE]]: false }.

NN : NNP VBZ DT JJ JJ NNP NNP NNP JJ NN .
1
*0*assert: o has an [[ITERATEDLIST]] internal slot.

NN NNP ( NNP NNP NNP NNP , RB ) .
1
*0*return createiterresultobject(list[index], false).

IN NNP VBZ DT NN IN DT NN WDT VBZ DT NN IN NNP , NN JJ .
1
*0*if envrec has a binding for the name that is the value of n, return true.

VB DT JJ NN IN NNP IN NNP CC NN IN PRP VBZ JJ . IN NNP VBZ JJ , NN IN DT RB VBN NN MD VB VBN IN DT JJ NN NN .
1
*0*create a mutable binding in envrec for n and record that it is uninitialized. if d is true, record that the newly created binding may be deleted by a subsequent deletebinding call.

VB DT JJ NN IN NNP IN NNP CC NN IN PRP VBZ JJ . IN NNP VBZ JJ , NN IN DT RB VBN NN VBZ DT JJ NN .
1
*0*create an immutable binding in envrec for n and record that it is uninitialized. if s is true, record that the newly created binding is a strict binding.

VB DT NN NN IN NNP IN NNP TO NNP .
1
*0*set the bound value for n in envrec to v.

IN NNP VBZ RB VB DT NN IN NNP , RB
1
*0*if envrec does not have a binding for n, then

IN DT NN IN NNP IN NNP VBZ DT JJ NN , VBN NNP TO JJ .
1
*0*if the binding for n in envrec is a strict binding, set s to true.

IN DT NN IN NNP IN NNP VBZ RB RB VBN VBN , VB DT NN NN .
1
*0*if the binding for n in envrec has not yet been initialized, throw a referenceerror exception.

RB IN DT NN IN NNP IN NNP VBZ DT JJ NN , VB PRP$ NN NN TO NNP .
1
*0*else if the binding for n in envrec is a mutable binding, change its bound value to v.

NN : DT VBZ DT NN TO VB DT NN IN DT JJ NN .
1
*1*assert: this is an attempt to change the value of an immutable binding.

NN : NNP VBZ DT NN IN DT NN WDT VBZ DT NN IN NNP .
1
*0*assert: envrec has a binding for the name that is the value of n.

IN DT NN IN NNP IN NNP MD RB VB VBN , VB JJ .
1
*0*if the binding for n in envrec cannot be deleted, return false.

VB DT NN IN NNP IN NNP .
1
*0*remove the binding for n from envrec.

VB VBG VB . NNP ( NNP , NNP ) .
1
*0*let foundbinding be ? hasproperty(bindings, n).

IN DT NNP NN IN NNP VBZ JJ , VB JJ .
1
*0*if the withenvironment flag of envrec is false, return true.

VB NNP VB NNP ( . NNP ( NNP , NNP ) ) .
1
*1*let blocked be toboolean(? get(unscopables, n)).

NN . NNP ( NNP , NNP , NN ( JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : NNP ) ) .
1
*0*return ? definepropertyorthrow(bindings, n, propertydescriptor { [[VALUE]]: undefined, [[WRITABLE]]: true, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: d }).

IN NNP VBZ JJ , VB DT NN VBD : RB VB DT NN NN .
1
*1*if s is false, return the value undefined; otherwise throw a referenceerror exception.

NN . NNS . VB JJ NNP NNP NNP ( NNP ) .
1
*0*return ? bindings.[[DELETE]](n).

IN DT NNP NN IN NNP VBZ JJ , VB DT NN NN IN NNP .
1
*0*if the withenvironment flag of envrec is true, return the binding object for envrec.

RB , NN VBD .
1
*0*otherwise, return undefined.

IN NNP . VB JJ NNP NNP NNP VBZ `` JJ '' , VB JJ : RB , NN JJ .
1
*0*if envrec.[[THISBINDINGSTATUS]] is "lexical", return false; otherwise, return true.

IN NNP . VB JJ NNP NNP NNP VBZ `` JJ '' , NN JJ .
1
*0*if envrec.[[THISBINDINGSTATUS]] is "lexical", return false.

IN NNP . VB JJ NNP NNP NNP VBZ DT NN VBD , NN RB : RB , NN JJ .
1
*0*if envrec.[[HOMEOBJECT]] has the value undefined, return false; otherwise, return true.

IN NNP VBZ DT NN VBD , NN VBD .
1
*0*if home has the value undefined, return undefined.

NN : IN DT NN VBZ , PRP MD VB IN DT JJ NN NN .
1
*0*assert: if the binding exists, it must be in the object environment record.

IN NNP VBZ DT NN IN NNP , VB DT NN IN DT NNP .
1
*2*if n is an element of varnames, remove that element from the varnames.

IN NNP VBZ NNP , NN JJ .
1
*0*if vardeclarednames contains n, return true.

IN NNP ( NNP ) VBZ JJ CC NNP VBZ NN NNS ( JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) , VBP JJ .
1
*0*if isdatadescriptor(existingprop) is true and existingprop has attribute values { [[WRITABLE]]: true, [[ENUMERABLE]]: true }, return true.

IN NNP VBZ JJ CC JJ VBZ JJ , RB
1
*0*if hasproperty is false and extensible is true, then

VB NNP VB DT NN ( JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : NNP ) .
1
*1*let desc be the propertydescriptor { [[VALUE]]: v, [[WRITABLE]]: true, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: d }.

NN . NNP ( NNP , NNP , NNP , RB ) .
1
*0*perform ? set(globalobject, n, v, false).

IN DT NN IN NNP VBZ DT JJ NN , RB
1
*0*if the binding for n is an indirect binding, then

VB NNP CC NNP VB DT NN NNS VBD WRB DT NN IN NNP VBD VBN .
1
*1*let m and n2 be the indirection values provided when this binding for n was created.

NN : DT NN VBZ RB VBN . VB CD .
1
*0*assert: this method is never invoked. see 12.5.3.1.

NN : WRB NNP . VB JJ NNP NNP NNP VBZ VBN PRP MD VB DT JJ NN IN NNP .
1
*0*assert: when m.[[ENVIRONMENT]] is instantiated it will have a direct binding for n2.

VB DT JJ JJ NN IN NNP IN NNP WDT VBZ NNP CC NNP IN PRP$ NN NN CC NN IN DT NN VBZ VBN .
1
*0*create an immutable indirect binding in envrec for n that references m and n2 as its target binding and record that the binding is initialized.

VB DT NN IN JJ NN WP$ NN NN NN VBZ JJ , WP$ JJ NN NN VBZ NNP , CC WP$ JJ NN NN VBZ NNP .
1
*1*return a value of type reference whose base value component is undefined, whose referenced name component is name, and whose strict reference flag is strict.

VB NNS VB . NNP ( NNP ) .
1
*0*let exists be ? envrec.hasbinding(name).

VB DT NN IN JJ NN WP$ NN NN NN VBZ NNP , WP$ JJ NN NN VBZ NNP , CC WP$ JJ NN NN VBZ NNP .
1
*1*return a value of type reference whose base value component is envrec, whose referenced name component is name, and whose strict reference flag is strict.

IN NNP . VB JJ NNP NNP NNP VBZ JJ , VBN NNP . VB JJ NNP NNP NNP TO `` JJ '' .
1
*0*if f.[[THISMODE]] is lexical, set envrec.[[THISBINDINGSTATUS]] to "lexical".

RB , VBN NNP . VB JJ NNP NNP NNP TO `` JJ '' .
1
*0*else, set envrec.[[THISBINDINGSTATUS]] to "uninitialized".

VB DT JJ JJ NN NN IN NNP TO NNP . VB JJ NNP NNP NNP .
1
*0*set the outer lexical environment reference of env to f.[[ENVIRONMENT]].

VB NNP VB DT JJ JJ NN NN .
1
*0*let globalrec be a new global environment record.

VB DT JJ JJ NN NN IN NNP TO VB .
1
*0*set the outer lexical environment reference of env to null.

VB NNP VB DT JJ NNS VBN IN CD IN DT NN NN NN NN .
1
*0*let throwersteps be the algorithm steps specified in 9.2.9.1 for the %throwtypeerror% function.

VB NNP VB NNP ( NNP , NNP NNP , NNP , NN ) .
1
*0*let thrower be createbuiltinfunction(throwersteps, « », realmrec, null).

VB NNP VB DT JJ NN IN JJ NNS .
1
*0*let nosteps be an empty sequence of algorithm steps.

VB NNP VB NNP ( NNP , NNP NNP , NNP , NNP ) .
1
*0*let funcproto be createbuiltinfunction(nosteps, « », realmrec, objproto).

VBN NNS IN NNS IN DT NNS VBN IN JJ CD WDT VBP RB RB VBN VBN RB . DT NN NNS VBP DT NNS VBN IN NN CD IN DT NN . DT NN IN DT NN VBZ DT JJ JJ NN RB CC RB VBN IN NN NNS IN VBN IN DT NN IN DT NN IN NNS CD DT JJ NN NNS VBP RB VBN NN NNS . DT NNS WDT VBP JJ NN NNS VBP VBN IN VBG NNP ( CC NN : NNS CC NN : , CC NN : CC CC NN : , NNP , CC NN : NN CC NN : ) WRB CC NN : NNS CC NN : VBZ DT NN IN DT NN VBN IN DT NN , CC NN : CC CC NN : VBZ DT NN IN DT NNS , IN DT , IN DT NN POS VBN JJ NNS , CC CC NN : NN CC NN : VBZ DT JJ NN IN DT NN POS JJ NN NNP NNP NNP JJ NN . DT NN IN DT NNS CC PRP$ NNS MD VB VBN TO VB DT NNS IN NNS WDT VBP RB RB VBN VBN .
1
*0*set fields of intrinsics with the values listed in table 7 that have not already been handled above. the field names are the names listed in column one of the table. the value of each field is a new object value fully and recursively populated with property values as defined by the specification of each object in clauses 18-26. all object property values are newly created object values. all values that are built-in function objects are created by performing createbuiltinfunction(&lt;steps&gt;, &lt;slots&gt;, realmrec, &lt;prototype&gt;) where &lt;steps&gt; is the definition of that function provided by this specification, &lt;slots&gt; is a list of the names, if any, of the function's specified internal slots, and &lt;prototype&gt; is the specified value of the function's [[PROTOTYPE]] internal slot. the creation of the intrinsics and their properties must be ordered to avoid any dependencies upon objects that have not yet been created.

VB NNS VB NNP . VB JJ NNP NNP NNP .
1
*1*let intrinsics be realmrec.[[INTRINSICS]].

VBN NNP TO NNP ( NNP . VB CD NN NNP NN NNP NNP ) .
1
*1*set globalobj to objectcreate(intrinsics.[[%OBJECTPROTOTYPE%]]).

IN DT NN IN DT JJ NN VBN IN NN CD , VBP
1
*0*for each property of the global object specified in clause 18, do

VB NNP VB DT VBG NN IN DT NN NN .
1
*1*let name be the string value of the property name.

VB NNP VB DT RB VBN NNS NN NN IN DT NN VBG DT VBN NNS IN DT NN . IN NNS VBN IN CD , CD , CC CD DT NN IN DT NNP NNP NNP NNP NNP NN VBZ DT JJ JJ NN IN NNP .
1
*1*let desc be the fully populated data property descriptor for the property containing the specified attributes for the property. for properties listed in 18.2, 18.3, or 18.4 the value of the [[VALUE]] attribute is the corresponding intrinsic object from realmrec.

IN DT NN NN NN VBZ JJ , JJ NN .
1
*0*if the execution context stack is empty, return null.

VB NNP VB DT JJ NN NN IN DT NN NN NN WP$ JJ NN VBZ RB JJ .
1
*0*let ec be the topmost execution context on the execution context stack whose scriptormodule component is not null.

IN DT JJ NN NN VBZ , VB RB . RB , VBP NNP POS NN NN .
1
*0*if no such execution context exists, return null. otherwise, return ec's scriptormodule component.

IN NNP VBZ RB JJ CC IN NNP VBZ VBN , RB
1
*0*if env is not present or if env is undefined, then

VBN NNP TO DT VBG NN NN POS NN .
1
*1*set env to the running execution context's lexicalenvironment.

IN DT NN VBG DT JJ NN WDT VBZ VBG VBN VBZ VBN IN JJ NN NN , VB NNP VB JJ , JJ NN NNP VB JJ .
1
*0*if the code matching the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let strict be false.

VB NNS VB NNP ( ) .
1
*1*let exists be envrec.hasthisbinding().

IN NNS VBZ JJ , VB NNP .
1
*1*if exists is true, return envrec.

NN : NNP VBZ DT JJ NNP NNP NNP NNP NN .
1
*0*assert: envrec has a [[NEWTARGET]] field.

NN : NNP ( NNP ) VBZ VBG CC PRP$ NN VBZ DT NN IN DT NN NN VBN IN DT NN .
1
*0*assert: type(queuename) is string and its value is the name of a job queue recognized by this implementation.

NN : NNP VBZ DT NN IN DT NN .
1
*0*assert: job is the name of a job.

NN : NNS VBZ DT NN WDT VBZ DT JJ NN IN NNS IN DT NN IN NNS VBN IN NNP .
1
*0*assert: arguments is a list that has the same number of elements as the number of parameters required by job.

VB NNP VB VBN ( JJ JJ NNP NNP NN : NNP , NNP NNP NNP NNP NN : NNS , NNP NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : JJ ) .
1
*0*let pending be pendingjob { [[JOB]]: job, [[ARGUMENTS]]: arguments, [[REALM]]: callerrealm, [[SCRIPTORMODULE]]: callerscriptormodule, [[HOSTDEFINED]]: undefined }.

VB DT NN CC NN NN VBD NN IN NNP . DT MD VB VBG DT NN NN NNP NNP NNP NN CC DT JJ NN IN NNP .
1
*0*perform any implementation or host environment defined processing of pending. this may include modifying the [[HOSTDEFINED]] field or any other field of pending.

VB VBG IN DT NN IN DT NN NN VBN IN NNP .
1
*0*add pending at the back of the job queue named by queuename.

IN DT NN VBZ NN IN DT JJ NN TO VB IN NNP POS JJ NN , VB NNP VB JJ DT NN VBD IN DT JJ NN . RB , VB NNP VB VBN , VBG IN DT JJ NN MD VB VBN IN DT JJ NN .
1
*0*if the host requires use of an exotic object to serve as realm's global object, let global be such an object created in an implementation-defined manner. otherwise, let global be undefined, indicating that an ordinary object should be created as the global object.

IN DT NN VBZ IN DT DT NN IN NNP POS JJ NN VB DT NN JJ IN DT JJ NN , VB NNP VB JJ DT NN VBD IN DT JJ NN . RB , VB NNP VB VBN , VBG IN NNP POS JJ DT NN MD VB DT JJ NN .
1
*0*if the host requires that the this binding in realm's global scope return an object other than the global object, let thisvalue be such an object created in an implementation-defined manner. otherwise, let thisvalue be undefined, indicating that realm's global this binding should be the global object.

VB DT JJ JJ NN NNS IN NNP .
1
*0*create any implementation-defined global object properties on globalobj.

IN DT JJ NN , VB DT NN NN NN ( VB RB CD ) CC DT JJ JJ NNS IN CD CC JJR JJ NNS or JJ NNS . IN DT JJ NNP CC NNP , VBP
1
*0*in an implementation-dependent manner, obtain the ecmascript source texts (see clause 10) and any associated host-defined values for zero or more ecmascript scripts and/or ecmascript modules. for each such sourcetext and hostdefined, do

IN NNP VBZ DT NN NN IN DT NN , RB
1
*1*if sourcetext is the source code of a script, then

RB NNP VBZ DT NN NN IN DT NN ,
1
*1*else sourcetext is the source code of a module,

VB DT JJ NN NN CC VB PRP IN DT NN NN NN .
1
*1*suspend the running execution context and remove it from the execution context stack.

VB NNP VB DT JJ NN JJ VBN IN DT JJ NN . IN DT NN NNS VBP JJ , DT NN VBZ JJ .
1
*1*let nextqueue be a non-empty job queue chosen in an implementation-defined manner. if all job queues are empty, the result is implementation-defined.

VB NNP VB DT NN NN IN DT NN IN NNP . VB IN NN IN NNP .
1
*1*let nextpending be the pendingjob record at the front of nextqueue. remove that record from nextqueue.

VBN NNP POS NN TO VB .
1
*1*set newcontext's function to null.

VB DT NN CC NN NN VBD NN NN VBG NNP .
1
*1*perform any implementation or host environment defined job initialization using nextpending.

VB NNP VB DT NN IN VBG DT JJ NN VBN IN VBG . JJ JJ NNP NNP NNP VBG DT NNS IN NNP . VB JJ NNP NNP NNP IN PRP$ NNS .
1
*1*let result be the result of performing the abstract operation named by nextpending.[[JOB]] using the elements of nextpending.[[ARGUMENTS]] as its arguments.

IN NNP VBZ DT NNP NN , NN NNS ( JJ NNP . CC JJ NNP NNP NNP NNP ) .
1
*1*if result is an abrupt completion, perform hostreporterrors(« result.[[VALUE]] »).

NN NNP . VB JJ NNP NN NN .
1
*0*return o.[[PROTOTYPE]].

VB NNP VB NNP . VB JJ NNP NN NN .
1
*0*let current be o.[[PROTOTYPE]].

RB IN NNP ( NNP , NNP ) VBZ JJ , NN JJ .
1
*1*else if samevalue(p, o) is true, return false.

IN NNP . VB JJ NNP NNP NNP VBZ RB DT JJ NN JJ NN VBN IN CD , VBN NNP TO JJ .
1
*2*if p.[[GETPROTOTYPEOF]] is not the ordinary object internal method defined in 9.1.1, set done to true.

RB , VBD NNP TO NNP . VB JJ NNP NN NN .
1
*2*else, set p to p.[[PROTOTYPE]].

VBN NNP . VB JJ NNP NN NN TO VB .
1
*0*set o.[[EXTENSIBLE]] to false.

IN NNP VBZ RB VB DT JJ NN IN JJ NNP , NN VBD .
1
*0*if o does not have an own property with key p, return undefined.

VB NNP VB DT RB VBN NN NN IN DT NNS .
1
*0*let d be a newly created property descriptor with no fields.

VB NNP VB NNP POS JJ NN WP$ NN VBZ NNP .
1
*0*let x be o's own property whose key is p.

VBN NNP . CC JJ NNP NNP NNP TO DT NN IN NNP POS NNP NNP NNP NNP NNP NN .
1
*1*set d.[[VALUE]] to the value of x's [[VALUE]] attribute.

RB NNP VBZ DT JJ NN ,
1
*0*else x is an accessor property,

VBN NNP . VB JJ NNP NNP NNP TO DT NN IN NNP POS NNP NNP NNP NNP NNP NN .
1
*1*set d.[[GET]] to the value of x's [[GET]] attribute.

VBN NNP . NN NN NNP NNP NNP TO DT NN IN NNP POS JJ NN NNP NNP NNP NN .
1
*1*set d.[[SET]] to the value of x's [[SET]] attribute.

NN NNP ( JJ , JJ , JJ , NNP , NNP ) .
1
*0*return validateandapplypropertydescriptor(undefined, undefined, extensible, desc, current).

NN : IN NNP VBZ RB JJ , RB NNP ( NNP ) VBZ JJ .
1
*0*assert: if o is not undefined, then ispropertykey(p) is true.

NN : JJ VBZ JJ .
1
*1*assert: extensible is true.

RB NNP MD VB DT JJ NN NN ,
1
*1*else desc must be an accessor property descriptor,

IN DT NN IN NNP VBZ JJ , VB JJ .
1
*0*if every field in desc is absent, return true.

IN NNP . VB JJ NNP NNP NNP VBZ JJ CC PRP$ NN VBZ JJ , NN JJ .
1
*1*if desc.[[CONFIGURABLE]] is present and its value is true, return false.

IN NNP . VB JJ NNP NNP NNP VBZ JJ CC DT NNP NNP NNP NNP NNP NNS IN NNP CC NNP VBP DT JJ NN IN DT JJ , JJ JJ .
1
*1*if desc.[[ENUMERABLE]] is present and the [[ENUMERABLE]] fields of current and desc are the boolean negation of each other, return false.

IN NNP ( NNP ) VBZ JJ , DT JJ NN VBZ VBN .
1
*0*if isgenericdescriptor(desc) is true, no further validation is required.

RB IN NNP ( NNP ) CC NNP ( NNP ) VBP JJ NNS , RB
1
*0*else if isdatadescriptor(current) and isdatadescriptor(desc) have different results, then

RB IN NNP ( NNP ) CC NNP ( NNP ) VBP DT JJ , RB
1
*0*else if isdatadescriptor(current) and isdatadescriptor(desc) are both true, then

IN NNP . VB JJ NNP NNP NNP VBZ JJ CC NNP . VB JJ NNP NNP NNP VBZ JJ , RB
1
*1*if current.[[CONFIGURABLE]] is false and current.[[WRITABLE]] is false, then

IN NNP . VB JJ NNP NNP NNP VBZ JJ CC NNP . VB JJ NNP NNP NNP VBZ JJ , NN JJ .
1
*2*if desc.[[WRITABLE]] is present and desc.[[WRITABLE]] is true, return false.

IN NNP . CC JJ NNP NNP NNP VBZ JJ CC NNP ( NNP . CC JJ NNP NNP NNP , NNP . CC JJ NNP NNP NNP ) VBZ JJ , NN JJ .
1
*2*if desc.[[VALUE]] is present and samevalue(desc.[[VALUE]], current.[[VALUE]]) is false, return false.

RB NNP ( NNP ) CC NNP ( NNP ) VBP DT JJ ,
1
*0*else isaccessordescriptor(current) and isaccessordescriptor(desc) are both true,

IN NNP . NN NN NNP NNP NNP VBZ JJ CC NNP ( NNP . NN NN NNP NNP NNP , NNP . NN NN NNP NNP NNP ) VBZ JJ , NN JJ .
1
*2*if desc.[[SET]] is present and samevalue(desc.[[SET]], current.[[SET]]) is false, return false.

IN NNP . VB JJ NNP NNP NNP VBZ JJ CC NNP ( NNP . VB JJ NNP NNP NNP , NNP . VB JJ NNP NNP NNP ) VBZ JJ , NN JJ .
1
*2*if desc.[[GET]] is present and samevalue(desc.[[GET]], current.[[GET]]) is false, return false.

IN DT NN IN NNP WDT VBZ JJ , VBD DT JJ NN IN DT NN VBD NNP IN JJ NNP TO DT NN IN DT NN .
1
*1*for each field of desc that is present, set the corresponding attribute of the property named p of object o to the value of the field.

IN NNP VBZ RB JJ , VB JJ .
1
*0*if hasown is not undefined, return true.

IN NNP ( NNP ) VBZ JJ , VB NNP . CC JJ NNP NNP NNP .
1
*0*if isdatadescriptor(desc) is true, return desc.[[VALUE]].

VBN NNP TO DT NN ( JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) .
1
*2*set owndesc to the propertydescriptor { [[VALUE]]: undefined, [[WRITABLE]]: true, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: true }.

RB NNP VBZ RB RB VBP DT NN NNP ,
1
*1*else receiver does not currently have a property p,

VB NNP VB NNP . NN NN NNP NNP NNP .
1
*0*let setter be owndesc.[[SET]].

VB DT JJ NN IN NN NNP IN NNP .
1
*1*remove the own property with name p from o.

IN DT JJ NN JJ NNP IN NNP WDT VBZ DT NN NN , IN VBG JJ NN NN , VBP
1
*0*for each own property key p of o that is an integer index, in ascending numeric index order, do

IN DT JJ NN JJ NNP IN NNP WDT VBZ DT NN CC VBZ RB DT NN NN , IN VBG JJ NN IN NN NN , VBP
1
*0*for each own property key p of o that is a string but is not an integer index, in ascending chronological order of property creation, do

IN DT JJ NN JJ NNP IN NNP WDT VBZ DT NN , IN VBG JJ NN IN NN NN , VBP
1
*0*for each own property key p of o that is a symbol, in ascending chronological order of property creation, do

NN : JJ ( NNP ) VBZ JJ .
1
*0*assert: iscallable(constructor) is true.

VBN NNP TO NNP POS JJ NN VBN NNP .
1
*1*set proto to realm's intrinsic object named intrinsicdefaultproto.

IN NNP . VB JJ NNP NNP NNP VBZ `` NN '' , VB DT NN NN .
1
*0*if f.[[TIONKIND]] is "classconstructor", throw a typeerror exception.

VB NNP VB NNP ( NNP , VBD ) .
1
*0*let calleecontext be prepareforordinarycall(f, undefined).

VB NNP ( NNP , NNP , NNP ) .
1
*0*perform ordinarycallbindthis(f, calleecontext, thisargument).

IN NNP . VB JJ NNP NNP NNP VBZ JJ , JJ NNP ( NNP . CC JJ NNP NNP NNP ) .
1
*0*if result.[[TYPE]] is return, return normalcompletion(result.[[VALUE]]).

NN : DT NN NNS VBN IN DT NN VBP VBN IN NNP .
1
*0*note: any exception objects produced after this point are associated with calleerealm.

IN NNP VBZ JJ , JJ NNP ( JJ ) .
1
*0*if thismode is lexical, return normalcompletion(undefined).

NN : NN VBZ JJR NNS VBG NNP .
1
*2*note: toobject produces wrapper objects using calleerealm.

NN : DT JJ NN RB VBZ DT JJ NN IN NNP . VB JJ NNP NNP NNP VBZ RB `` JJ '' .
1
*0*assert: the next step never returns an abrupt completion because envrec.[[THISBINDINGSTATUS]] is not "initialized".

VB DT NN IN NN IN DT JJ NN WDT VBZ NNP . VB JJ NNP NNP NNP VBG NNP CC NNP IN DT NNS .
1
*0*return the result of evaluatebody of the parsed code that is f.[[ECMASCRIPTCODE]] passing f and argumentslist as the arguments.

IN NNP VBZ `` NN '' , VB NNP ( NNP , NNP , NNP ) .
1
*0*if kind is "base", perform ordinarycallbindthis(f, calleecontext, thisargument).

IN NNP ( NNP . CC JJ NNP NNP NNP ) VBZ JJ , VB NNP ( NNP . CC JJ NNP NNP NNP ) .
1
*1*if type(result.[[VALUE]]) is object, return normalcompletion(result.[[VALUE]]).

IN NNP VBZ `` NN '' , VB NNP ( NNP ) .
1
*1*if kind is "base", return normalcompletion(thisargument).

IN NNP . CC JJ NNP NNP NNP VBZ RB JJ , VB DT NN NN .
1
*1*if result.[[VALUE]] is not undefined, throw a typeerror exception.

RB , NNP ( NNP ) .
1
*0*else, returnifabrupt(result).

NN : NNP VBZ RB `` JJ '' , `` NN '' , `` NN '' , `` NN '' , CC `` JJ NN '' .
1
*0*assert: functionkind is either "normal", "non-constructor", "generator", "async", or "async generator".

IN NNP VBZ `` JJ '' , VBD NNP TO `` JJ '' .
1
*0*if functionkind is "non-constructor", set functionkind to "normal".

VB NNP VB DT RB VBN NN NN NN IN DT JJ NNS VBN IN JJ CD DT IN DT JJ NNS VBP VBN TO JJ .
1
*0*let f be a newly created ecmascript function object with the internal slots listed in table 27. all of those internal slots are initialized to undefined.

VBN NNP . VB JJ NNP NNP NN TO DT NN VBN IN CD .
1
*0*set f.[[CALL]] to the definition specified in 9.2.1.

VBN NNP . NNP NNP NNP NNP NNP TO DT NN VBN IN CD .
1
*1*set f.[[CONSTRUCT]] to the definition specified in 9.2.2.

VBN NNP . VB JJ NNP NNP NNP TO DT JJ NN NN .
1
*0*set f.[[REALM]] to the current realm record.

VBN NNP . VB JJ NNP NNP NNP TO NNP ( ) .
1
*0*set f.[[SCRIPTORMODULE]] to getactivescriptormodule().

IN NNP VBZ JJ , VBN NNP . VB JJ NNP NNP NNP TO VB .
1
*0*if kind is arrow, set f.[[THISMODE]] to lexical.

RB IN NNP VBZ JJ , VBN NNP . VB JJ NNP NNP NNP TO VB .
1
*0*else if strict is true, set f.[[THISMODE]] to strict.

RB , VBN NNP . VB JJ NNP NNP NNP TO JJ .
1
*0*else, set f.[[THISMODE]] to global.

VBN NNP TO DT JJ NN NN NN NN .
1
*1*set prototype to the intrinsic object %functionprototype%.

IN NNP VBZ RB JJ , VB NNP VB `` JJ '' .
1
*0*if kind is not normal, let allockind be "non-constructor".

VB NNP VB NNP ( NNP , NNP , `` NN '' ) .
1
*0*let f be functionallocate(functionprototype, strict, "generator").

NN : NNP NNP NNP NNP NNP NNP . VB CD NN NNP NN NNP NNP NNS CC VBZ VBN VBN .
1
*0*assert: realm.[[INTRINSICS]].[[%THROWTYPEERROR%]] exists and has been initialized.

VB NNP VB NNP NNP NNP NNP NNP NNP . VB CD NN NNP NN NNP NNP .
1
*0*let thrower be realm.[[INTRINSICS]].[[%THROWTYPEERROR%]].

NN . NNP ( NNP , `` NN '' , NN ( JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) ) .
1
*0*perform ! definepropertyorthrow(f, "caller", propertydescriptor { [[GET]]: thrower, [[SET]]: thrower, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }).

NN . NNP ( NNP , `` NNS '' , NN ( JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) ) .
1
*0*return ! definepropertyorthrow(f, "arguments", propertydescriptor { [[GET]]: thrower, [[SET]]: thrower, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }).

IN NNP VBZ RB JJ , VBN NNP TO JJ .
1
*0*if writableprototype is not present, set writableprototype to true.

VBN NNP TO NNP ( NN IN NN ) .
1
*1*set prototype to objectcreate(%objectprototype%).

NN . NNP ( NNP , `` NN '' , NN ( JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) ) .
1
*1*perform ! definepropertyorthrow(prototype, "constructor", propertydescriptor { [[VALUE]]: f, [[WRITABLE]]: writableprototype, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }).

NN . NNP ( NNP , `` NN '' , NN ( JJ NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) ) .
1
*0*perform ! definepropertyorthrow(f, "prototype", propertydescriptor { [[VALUE]]: prototype, [[WRITABLE]]: writableprototype, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }).

NN : NNP . VB JJ NNP NNP NNP VBZ `` JJ '' .
1
*0*assert: f.[[TIONKIND]] is "normal".

VBN NNP . VB JJ NNP NNP NNP TO `` NN '' .
1
*0*set f.[[TIONKIND]] to "classconstructor".

NN : NNP ( NNP ) VBZ JJ NN CC NN .
1
*0*assert: type(name) is either symbol or string.

NN : IN NNP VBZ JJ , RB NNP ( NNP ) VBZ VBG .
1
*0*assert: if prefix is present, then type(prefix) is string.

IN NNP VBZ JJ , VBN NNP TO DT JJ NN .
1
*1*if description is undefined, set name to the empty string.

RB , VBN NNP TO DT NN IN `` JJ `` , NNP , CC `` JJ '' .
1
*1*else, set name to the string-concatenation of "[", description, and "]".

VBN NNP TO DT NN IN NNP , DT NN NN CD ( NN ) , CC NNP .
1
*1*set name to the string-concatenation of prefix, the code unit 0x0020 (space), and name.

NN . NNP ( NNP , `` NN '' , NN ( JJ NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) ) .
1
*0*return ! definepropertyorthrow(f, "name", propertydescriptor { [[VALUE]]: name, [[WRITABLE]]: false, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }).

NN : NNP VBZ CD CC . NNP ( NNP ) VBZ JJ TO NNP .
1
*0*assert: length ≥ 0 and ! tointeger(length) is equal to length.

NN NNS VB NNP . VB JJ NNP NNP NNP .
1
*0*let formals be func.[[FORMALPARAMETERS]].

IN NNP VBZ DT JJ NNS , VB NNP VB JJ . RB , VB NNP VB JJ .
1
*0*if parameternames has any duplicate entries, let hasduplicates be true. otherwise, let hasduplicates be false.

NN : NN NNS RB VBP DT NNS NNS .
1
*1*note: arrow functions never have an arguments objects.

RB IN `` NNS '' VBZ DT NN IN NNP , RB
1
*0*else if "arguments" is an element of parameternames, then

IN `` NNS '' VBZ DT NN IN NNP CC IN `` NNS '' VBZ DT NN IN NNP , RB
1
*1*if "arguments" is an element of functionnames or if "arguments" is an element of lexicalnames, then

NN : JJ NNS VB IN NN NN NNS MD RB VB IN JJ NNS WDT VBP RB VB NN NN NNS CC NN NNS .
1
*1*note: early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.

NN : VBN NN NN VBZ RB VBN IN JJ NNS WDT VBP RB VB DT NN NN , DT NN NN NN NNS , CC DT JJ NNS .
1
*2*note: mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.

NN NNP ( `` NNS '' , NNP ) .
1
*1*call envrec.initializebinding("arguments", ao).

VB NNP VB DT JJ NN IN NNP IN `` NNS '' VBN .
1
*1*let parameterbindings be a new list of parameternames with "arguments" appended.

NN . NN IN NNS IN NNP CC VBD IN NNS .
1
*1*perform ? iteratorbindinginitialization for formals with iteratorrecord and undefined as arguments.

NN . NN IN NNS IN NNP CC NNP IN NNS .
1
*1*perform ? iteratorbindinginitialization for formals with iteratorrecord and env as arguments.

NN : RB DT JJ JJ NN VBZ VBN IN DT NNS CC JJ NNS .
1
*1*note: only a single lexical environment is needed for the parameters and top-level vars.

VB NNP VB DT NN IN DT NN NNP .
1
*1*let instantiatedvarnames be a copy of the list parameterbindings.

NN : DT JJ NN NN VBZ VBN TO VB DT NNS VBN IN NNS IN DT JJ NN NN VBP RB VB NN IN NNS IN DT NN NN .
1
*1*note: a separate environment record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.

IN NNP VBZ RB DT NN IN NNS CC IN NNP VBZ DT NN IN NNP , VB NNP VB VBN .
1
*3*if n is not an element of parameterbindings or if n is an element of functionnames, let initialvalue be undefined.

VB NNP VB . NNP ( NNP , RB ) .
1
*4*let initialvalue be ! envrec.getbindingvalue(n, false).

NN : NNS WP$ NNS VBP DT JJ IN DT JJ NN , RB VBP DT JJ NN IN DT VBG JJ NN .
1
*3*note: vars whose names are the same as a formal parameter, initially have the same value as the corresponding initialized parameter.

NN : JJ NNS VBP DT JJ JJ NN NN IN JJ JJ NNS IN IN DT JJ NN MD VB IN DT NN VBD NNS VBN IN DT JJ NN NN IN JJ JJ RB JJ NNS . DT VBZ RB VBN IN JJ NNS IN DT JJ JJ NN RB VBZ DT NNS IN DT JJ NN NN .
1
*1*note: non-strict functions use a separate lexical environment record for top-level lexical declarations so that a direct eval can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. this is not needed for strict functions because a strict direct eval always places all declarations into a new environment record.

NN : DT RB VBN NN MD RB VB DT JJ IN DT generator NN , JJ NN , CC DT JJ NN . RB VBN NNS VBP RB VBN RB CC RB VBN .
1
*1*note: a lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. lexically declared names are only instantiated here but not initialized.

VB DT JJ JJ NN IN NNP .
1
*0*perform any necessary implementation-defined initialization of calleecontext.

VB NNP VB DT NN NN WDT VBZ DT NN IN VBG NNP IN DT JJ NN WDT VBZ TO DT NN IN NNP . NNP VBZ DT DT NN , NNP VBZ DT JJ NNS , CC DT NN NN VBZ JJ .
1
*0*let result be the completion record that is the result of evaluating f in an implementation-defined manner that conforms to the specification of f. thisargument is the this value, argumentslist provides the named parameters, and the newtarget value is undefined.

VB NNP VB DT NN NN WDT VBZ DT NN IN VBG NNP IN DT JJ NN WDT VBZ TO DT NN IN NNP . DT DT NN VBZ JJ , NNP VBZ DT JJ NNS , CC NNP VBZ DT NN NN .
1
*0*let result be the completion record that is the result of evaluating f in an implementation-defined manner that conforms to the specification of f. the this value is uninitialized, argumentslist provides the named parameters, and newtarget provides the newtarget value.

NN : NNP VBZ CC DT NN IN JJ NNS CC JJ NN IN DT NN POS NN VBD IN DT NN .
1
*0*assert: steps is either a set of algorithm steps or other definition of a function's behaviour provided in this specification.

IN NNP VBZ RB JJ , VBN NNP TO DT JJ NN NN .
1
*0*if realm is not present, set realm to the current realm record.

IN NNP VBZ RB JJ , VBN NNP TO NNP NNP NNP NNP NNP NNP . VB CD NN NNP NN NNP NNP .
1
*0*if prototype is not present, set prototype to realm.[[INTRINSICS]].[[%TIONPROTOTYPE%]].

VB NNP VB DT JJ JJ NN NN IN WRB VBN VBZ DT NN VBN IN NNP . DT JJ NN NN VBZ JJ NNS WP$ NNS VBP DT NNS IN NNP . DT JJ NN IN DT IN DT JJ NNS VBZ JJ .
1
*0*let func be a new built-in function object that when called performs the action described by steps. the new function object has internal slots whose names are the elements of internalslotslist. the initial value of each of those internal slots is undefined.

IN NNP ( NNP , NNP ) VBZ JJ , VB NNP TO NNP .
1
*0*if samevalue(f, newtarget) is true, set newtarget to target.

RB IN NNP VBZ DT NN NN , RB
1
*0*else if p is an array index, then

IN NNP NNP NNP CC NNP . VB JJ NNP NNP NNP VBZ JJ , NN JJ .
1
*1*if index ≥ oldlen and oldlendesc.[[WRITABLE]] is false, return false.

VB NNP VB NNP ( NNP , `` NN '' , NNP ) .
1
*2*let succeeded be ordinarydefineownproperty(a, "length", oldlendesc).

NN : VBN VBZ JJ .
1
*2*assert: succeeded is true.

IN NNP VBZ RB JJ , VBN NNP TO DT JJ NN NN NN NN .
1
*0*if proto is not present, set proto to the intrinsic object %arrayprototype%.

VBN NNP POS JJ JJ NNS IN IN NNP NNP NNP NNP NNP TO DT NN JJ JJ NNS VBN IN CD .
1
*0*set a's essential internal methods except for [[DEFINEOWNPROPERTY]] to the default ordinary object definitions specified in 9.1.

IN NNP CC NNP VBP RB DT JJ NN NN , RB
1
*1*if thisrealm and realmc are not the same realm record, then

IN NNP ( NNP , NNP NNP NNP NNP NNP NNP . VB CD NN NNP NN NNP NNP ) VBZ JJ , VBN NNP TO VB .
1
*2*if samevalue(c, realmc.[[INTRINSICS]].[[%ARRAY%]]) is true, set c to undefined.

VBN NNP TO . NNP ( NNP , NNP NNP NNS ) .
1
*1*set c to ? get(c, @@species).

NN . NNP ( NNP , NNP NNP NNP ) .
1
*0*return ? construct(c, « length »).

IN NNP . VB JJ NNP NNP NNP VBZ JJ CC VBZ DT NN JJ , VB JJ VB JJ .
1
*0*if newlendesc.[[WRITABLE]] is absent or has the value true, let newwritable be true.

NN TO VB VBG DT NNP NNP NNP NNP NNP NN TO VB IN NN DT NNS MD RB VB VBN .
1
*1*need to defer setting the [[WRITABLE]] attribute to false in case any elements cannot be deleted.

VB JJ VB JJ .
1
*1*let newwritable be false.

VB NNP VB . NNP ( NNP , `` NN '' , NNP ) .
1
*0*let succeeded be ! ordinarydefineownproperty(a, "length", newlendesc).

VBN NNP TO NNP : CD .
1
*1*set oldlen to oldlen - 1.

VB NNP VB . NNP NNP NNP NNP NNP NNP ( . NNP ( NNP ) ) .
1
*1*let deletesucceeded be ! a.[[DELETE]](! tostring(oldlen)).

IN NNP VBZ JJ , VBN NNP . VB JJ NNP NN NN TO VB .
1
*2*if newwritable is false, set newlendesc.[[WRITABLE]] to false.

NN NNP ( NNP , `` NN '' , NN ( JJ NNP NNP NNP NN : JJ ) ) . DT NN MD RB VB JJ .
1
*1*return ordinarydefineownproperty(a, "length", propertydescriptor { [[WRITABLE]]: false }). this call will always return true.

IN DT JJ NN JJ NNP IN NNP JJ IN NNP VBZ DT NN NN CC NNP ( NNP ) NNP NNP , IN VBG JJ NN NN , VBP
1
*0*for each own property key p of o such that p is an integer index and tointeger(p) ≥ len, in ascending numeric index order, do

NN NNP POS JJ JJ NNS TO DT NN JJ JJ NNS VBN IN CD .
1
*0*set s's essential internal methods to the default ordinary object definitions specified in 9.1.

NN NNP . VB JJ NNP NNP NNP IN VBN IN CD .
1
*0*set s.[[OWNPROPERTYKEYS]] as specified in 9.4.3.3.

NN NNP . VB JJ NNP NN NN TO NNP .
1
*0*set s.[[PROTOTYPE]] to prototype.

NN NNP . VB JJ NNP NN NN TO JJ .
1
*0*set s.[[EXTENSIBLE]] to true.

VB NNP VB DT VBG NN IN NN CD , VBG CD NN NN IN NNP , RB DT NN NN IN NN NNP .
1
*0*let resultstr be the string value of length 1, containing one code unit from str, specifically the code unit at index index.

IN NNP VBZ JJ CC NNP ( NNP ) VBZ JJ , RB
1
*0*if ismapped is true and isdatadescriptor(desc) is true, then

IN NNP . CC JJ NNP NNP NNP VBZ RB JJ CC NNP . VB JJ NNP NNP NNP VBZ JJ CC PRP$ NN VBZ JJ , RB
1
*1*if desc.[[VALUE]] is not present and desc.[[WRITABLE]] is present and its value is false, then

VBN NNP TO DT NN IN NNP .
1
*2*set newargdesc to a copy of desc.

VB NNP VB NNP ( NNP , NNP , NNP . CC JJ NNP NNP NNP , RB ) .
1
*3*let setstatus be set(map, p, desc.[[VALUE]], false).

IN NNP . VB JJ NNP NNP NNP VBZ JJ CC PRP$ NN VBZ JJ , RB
1
*2*if desc.[[WRITABLE]] is present and its value is false, then

RB NNP VBZ DT JJ NN VBG IN NNP ,
1
*0*else map contains a formal parameter mapping for p,

VB NNP VB NNP ( NNP , NNP , NNP , RB ) .
1
*1*let setstatus be set(map, p, v, false).

VB NNP VB NNP ( NN NN NN , NNP NNP NNP NNP NNP NNP NNP ) .
1
*0*let obj be objectcreate(%objectprototype%, « [[PARAMETERMAP]] »).

NN . NNP ( NNP , `` NN '' , NN ( JJ NNP NNP NNP NNP : NN NN NN , JJ NN NNP NNP NN : NN NN NN , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) ) .
1
*0*perform ! definepropertyorthrow(obj, "callee", propertydescriptor { [[GET]]: %throwtypeerror%, [[SET]]: %throwtypeerror%, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }).

NN : NNS VBZ RB VB DT NN NN , DT NN NNS , CC DT NNS . PRP MD VB JJ NNS .
1
*0*assert: formals does not contain a rest parameter, any binding patterns, or any initializers. it may contain duplicate identifiers.

VB NNP VB DT RB VBN NNS JJ NN IN DT JJ NN NNP NNP NNP JJ NN .
1
*0*let obj be a newly created arguments exotic object with a [[PARAMETERMAP]] internal slot.

VB DT NN IN NNP POS JJ JJ NNS TO DT NN JJ JJ NNS VBN IN CD .
1
*0*set the remainder of obj's essential internal methods to the default ordinary object definitions specified in 9.1.

VBN NNP . VB JJ NNP NN NNP TO NN JJ NN .
1
*0*set obj.[[PROTOTYPE]] to %objectprototype%.

VB NNS VB DT NN IN NNS IN NNP .
1
*0*let numberofparameters be the number of elements in parameternames.

NN , IN NNP VBD CD ,
1
*0*repeat, while index ≥ 0,

RB NNP IN DT NN IN DT NN NNP .
1
*2*add name as an element of the list mappednames.

NN NNP NNP NNP NNP NNP NNP ( . NNP ( NNP ) , NN ( JJ NN NNP NNP NN : NNP , NNP NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) ) .
1
*3*perform map.[[DEFINEOWNPROPERTY]](! tostring(index), propertydescriptor { [[SET]]: p, [[GET]]: g, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }).

IN NNP NNP NNP . VB JJ NNP NNP NNP , NN JJ .
1
*2*if numericindex ≥ o.[[ARRAYLENGTH]], return false.

NN : NN VBZ DT NNS VBP NNP NNP NNP NNP , NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP , CC NNP NNP NNP NNP NNP .
1
*0*assert: internalslotslist contains the names [[VIEWEDARRAYBUFFER]], [[ARRAYLENGTH]], [[BYTEOFFSET]], and [[TYPEDARRAYNAME]].

NN NNP ( NNP , NNP , NNP , JJ , `` JJ '' ) .
1
*0*return getvaluefrombuffer(buffer, indexedposition, elementtype, true, "unordered").

IN NNP CC NN : CD CC NNP NNP NNP , NN JJ .
1
*0*if index &lt; 0 or index ≥ length, return false.

VB NNP VB . NNP . VB JJ NNP NNP NNP ( NNP , NNP ) .
1
*0*let value be ? o.[[GET]](p, o).

NN NN ( JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) .
1
*0*return propertydescriptor { [[VALUE]]: value, [[WRITABLE]]: true, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: false }.

VB NNP VB DT NN IN NNP . VB JJ NNP NNP NNP .
1
*0*let exports be a copy of o.[[EXPORTS]].

VB PDT DT NNS IN NNP TO DT NN IN NNS .
1
*0*append all the entries of symbolkeys to the end of exports.

NN : NNS VBZ DT NN IN VBG NNS .
1
*0*assert: exports is a list of string values.

VBN NNP POS JJ JJ NNS TO DT NNS VBN IN CD .
1
*0*set m's essential internal methods to the definitions specified in 9.4.6.

VB NNP VB DT JJ NN VBG DT JJ NNS IN DT NN NNP WRB DT NNS VBP VBN IN IN DT NN IN DT JJ NNS VBD VBN VBN VBG NN VBG JJ IN NNP .
1
*0*let sortedexports be a new list containing the same values as the list exports where the values are ordered as if an array of the same values had been sorted using array.prototype.sort using undefined as comparefn.

NN JJ NNS IN NNP VBG TO DT NNS IN CD .
1
*0*create own properties of m corresponding to the definitions in 26.3.

VB NNP VB . NNP . VB JJ NNP NN NNP ( ) .
1
*0*let targetresult be ? target.[[ISEXTENSIBLE]]().

VB JJ VB . NNP . VB JJ NNP NN NNP ( ) .
1
*1*let targetisextensible be ? target.[[ISEXTENSIBLE]]().

IN NNP VBZ DT JJ NN NNP NNP NNP NN CC IN NNP . VB JJ NNP NNP NNP VBZ JJ , RB
1
*0*if desc has a [[CONFIGURABLE]] field and if desc.[[CONFIGURABLE]] is false, then

IN NNP ( NNP , NNP , NNP ) VBZ JJ , VB DT NN NN .
1
*1*if iscompatiblepropertydescriptor(extensibletarget, desc, targetdesc) is false, throw a typeerror exception.

IN NNP VBZ JJ CC NNP . VB JJ NNP NNP NNP VBZ JJ , VB DT NN NN .
1
*1*if settingconfigfalse is true and targetdesc.[[CONFIGURABLE]] is true, throw a typeerror exception.

VB NNP VB . NNP ( NNP , `` VBZ '' ) .
1
*0*let trap be ? getmethod(handler, "has").

IN NNP ( NNP ) VBZ JJ CC NNP . VB JJ NNP NNP NNP VBZ VBN , RB
1
*1*if isaccessordescriptor(targetdesc) is true and targetdesc.[[GET]] is undefined, then

VB NNP VB NNP ( . NNP ( NNP , NNP , NNP NNP , NNP , NNP , NNP NNP ) ) .
1
*0*let booleantrapresult be toboolean(? call(trap, handler, « target, p, v, receiver »)).

IN NNP . NN NN NNP NNP NNP VBZ JJ , VB DT NN NN .
1
*2*if targetdesc.[[SET]] is undefined, throw a typeerror exception.

VB NNP VB . NNP ( NNP , NNP NN , NN NN ) .
1
*0*let trapresult be ? createlistfromarraylike(trapresultarray, « string, symbol »).

IN NNP VBZ DT JJ NNS , VBP DT NN NN .
1
*0*if trapresult contains any duplicate entries, throw a typeerror exception.

NN : NNP VBZ DT NN VBG RB VBG CC NN NNS .
1
*0*assert: targetkeys is a list containing only string and symbol values.

VB NNP VB DT JJ NN WDT VBZ DT NN IN NNP .
1
*0*let uncheckedresultkeys be a new list which is a copy of trapresult.

VBN NNP POS JJ JJ NNS ( IN IN NNP NNP NNP NNP NNP CC NNP NNP NNP NNP NNP ) TO DT NNS VBN IN CD .
1
*0*set p's essential internal methods (except for [[CALL]] and [[CONSTRUCT]]) to the definitions specified in 9.5.

NN : CD NN NNP VBZ CD .
1
*0*assert: 0 ≤ cp ≤ 0x10ffff.

VB NNP VB NN ( ( NNP : CD )  CD ) NN CD .
1
*0*let cu1 be floor((cp - 0x10000) / 0x400) + 0xd800.

VB NNP VB ( ( NNP : CD ) FW CD ) NN CD .
1
*0*let cu2 be ((cp - 0x10000) modulo 0x400) + 0xdc00.

VB DT NN NN NN NN IN NNP VBN IN NNP .
1
*0*return the code unit sequence consisting of cu1 followed by cu2.

NN : NN VBZ DT VBG NN CC NNP VBZ DT VBG NN .
1
*0*assert: lead is a leading surrogate and trail is a trailing surrogate.

VB NNP VB ( NNP : CD ) VBD CD NNP ( NNP : CD ) NN CD .
1
*0*let cp be (lead - 0xd800) × 0x400 + (trail - 0xdc00) + 0x10000.

VB DT NN NN NNP .
1
*0*return the code point cp.

VB NNP VB NNS IN NNP IN NN JJ .
1
*0*let rawstrings be templatestrings of templateliteral with argument true.

IN NNP . VB JJ NNP NNP NNP VBZ DT JJ NN NN IN NNP , RB
1
*1*if e.[[SITE]] is the same parse node as templateliteral, then

VB NNP VB NNS IN NNP IN NN NN .
1
*0*let cookedstrings be templatestrings of templateliteral with argument false.

VB NNP VB DT NN IN NNS IN DT NN NNP .
1
*0*let count be the number of elements in the list cookedstrings.

NN : NNP NNP JJ .
1
*0*assert: count ≤ 232-1.

NN NNP . VB NNP NNP NNP NNP ( `` VB '' , NN ( JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) ) .
1
*0*call template.[[DEFINEOWNPROPERTY]]("raw", propertydescriptor { [[VALUE]]: rawobj, [[WRITABLE]]: false, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }).

VB DT NN ( JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : NN ) TO NNP .
1
*0*append the record { [[SITE]]: templateliteral, [[ARRAY]]: template } to templateregistry.

NN : NNP VBZ CC DT NN CC DT NN .
1
*0*assert: constructexpr is either a newexpression or a memberexpression.

NN : NNS VBZ DT JJ CC DT NNS .
1
*0*assert: arguments is either empty or an arguments.

IN NNS VBZ JJ , VB NNP VB DT JJ JJ NN .
1
*0*if arguments is empty, let arglist be a new empty list.

RB DT NN IN NNP VBZ DT NN NN ,
1
*1*else the base of ref is an environment record,

RB NNP ( NNP ) VBZ RB NN ,
1
*0*else type(ref) is not reference,

IN NNP VBZ JJ , VB NNP ( ) .
1
*0*if tailposition is true, perform preparefortailcall().

NN : IN NNP VBZ JJ , DT NN NN MD RB VB RB , CC RB NN MD VB IN IN DT VBG NN VBZ RB VBN .
1
*0*assert: if tailposition is true, the above call will not return here, but instead evaluation will continue as if the following return has already occurred.

NN : IN NNP VBZ RB DT NNP NN , RB NN ( NNP ) VBZ DT JJ NN NN .
1
*0*assert: if result is not an abrupt completion, then type(result) is an ecmascript language type.

NN : NN VBZ DT JJ NN NN .
1
*0*assert: activefunction is an ecmascript function object.

VB DT NN IN JJ NN WDT VBZ DT JJ NN WP$ NN NN NN VBZ NNP , WP$ JJ NN NN VBZ NNP , WP$ JJ NN VBZ NNP , CC WP$ JJ NN NN VBZ NNP .
1
*0*return a value of type reference that is a super reference whose base value component is bv, whose referenced name component is propertykey, whose thisvalue component is actualthis, and whose strict reference flag is strict.

VB NNP VB . NNP ( . NNP ( NNP ) ) .
1
*0*let oldvalue be ? toint32(? getvalue(expr)).

VB DT NN IN VBG NN NN TO NNP . DT NN VBZ DT JJ JJ NN .
1
*0*return the result of applying bitwise complement to oldvalue. the result is a signed 32-bit integer.

VB NNP VB NNP ( . NNP ( NNP ) ) .
1
*0*let oldvalue be toboolean(? getvalue(expr)).

IN NNP ( NNP ) VBZ VBG CC NNP ( NNP ) VBZ VBG , RB
1
*0*if type(lprim) is string or type(rprim) is string, then

VB DT NN IN NN VBG NNP IN NNP NNS . DT NN VBZ DT JJ JJ NN .
1
*0*return the result of left shifting lnum by shiftcount bits. the result is a signed 32-bit integer.

VB DT NN IN VBG DT JJ JJ NN IN NNP IN NNP NNS . DT RBS JJ NN VBZ VBN . DT NN VBZ DT JJ JJ NN .
1
*0*return the result of performing a sign-extending right shift of lnum by shiftcount bits. the most significant bit is propagated. the result is a signed 32-bit integer.

VB DT NN IN VBG DT JJ JJ NN IN NNP IN NNP NNS . VBN NNS VBP VBN IN NN . DT NN VBZ DT JJ JJ NN .
1
*0*return the result of performing a zero-filling right shift of lnum by shiftcount bits. vacated bits are filled with zero. the result is an unsigned 32-bit integer.

NN NNP ( . NNP ( NNP , NNP , NNP NNP NNP ) ) .
1
*1*return toboolean(? call(instofhandler, target, « v »)).

IN NNP . VB JJ NNP NNP NNP VBZ RB JJ , VB JJ .
1
*0*if completion.[[TYPE]] is not continue, return false.

IN NNP . VB JJ NNP NNP NNP VBZ DT NN IN NNP , NN JJ .
1
*0*if completion.[[TARGET]] is an element of labelset, return true.

IN NNP ( NNP ) VBZ JJ , JJ NNP ( NNP ) .
1
*2*if toboolean(testvalue) is false, return normalcompletion(v).

IN NNP ( NNP , NNP ) VBZ JJ , JJ NNP ( NNP ( NNP , NNP ) ) .
1
*1*if loopcontinues(result, labelset) is false, return completion(updateempty(result, v)).

IN NNP VBZ DT NNS , RB
1
*0*if periterationbindings has any elements, then

VB NNP VB NNP POS NN NN NN .
1
*1*let outer be lastiterationenv's outer environment reference.

NN NN ( JJ NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) .
1
*2*return completion { [[TYPE]]: break, [[VALUE]]: empty, [[TARGET]]: empty }.

VB NNP VB VBG IN NNP .
1
*0*let destructuring be isdestructuring of lhs.

VB NNP VB DT JJ WDT VBZ VBN IN NNP .
1
*1*let assignmentpattern be the assignmentpattern that is covered by lhs.

IN NNP VBZ RB , RB VB NNP TO . NN ( NNP ) .
1
*1*if iteratorkind is async, then set nextresult to ? await(nextresult).

IN NNP VBZ DT NN CC NN , RB
1
*1*if lhskind is either assignment or varbinding, then

VB NNP VB DT NN IN VBG NNP . ( PRP MD VB VBN RB .
1
*3*let lhsref be the result of evaluating lhs. (it may be evaluated repeatedly.)

NN NN IN NNP VBG NNP IN DT NN .
1
*2*perform bindinginstantiation for lhs passing iterationenv as the argument.

VB NNP VB DT JJ NN IN NNS IN NNP .
1
*3*let lhsname be the sole element of boundnames of lhs.

VB NNP VB DT NN IN VBG NN IN NNP VBG NNP IN DT NN .
1
*3*let status be the result of performing destructuringassignmentevaluation of assignmentpattern using nextvalue as the argument.

VB NNP VB DT NN IN VBG NN IN NNP VBG NNP CC VBD IN DT NNS .
1
*3*let status be the result of performing bindinginitialization for lhs passing nextvalue and undefined as the arguments.

VB NNP VB DT NN IN VBG NN IN NNP VBG NNP CC NNP IN NNS .
1
*3*let status be the result of performing bindinginitialization for lhs passing nextvalue and iterationenv as arguments.

NN NNP ( NNP ( NNP , NNP ) ) .
1
*3*return completion(updateempty(result, v)).

VB DT NN NN ( CD ) WP$ JJ NN VBZ IN PDT DT JJ NNS IN JJ NNS IN NNP . DT NN NN VBZ RB RB JJ TO VB NN . DT NNS CC NN IN VBG DT NNS VBZ RB VBN CC MD VB TO DT NNS VBN IN .
1
*0*return an iterator object (25.1.1.2) whose next method iterates over all the string-valued keys of enumerable properties of o. the iterator object is never directly accessible to ecmascript code. the mechanics and order of enumerating the properties is not specified but must conform to the rules specified below.

NN : NNP VBZ DT NN IN DT NN NN : NN : NN .
1
*0*assert: c is an instance of the production caseclause:caseexpression:statementlistopt.

VB NNP VB DT NN IN VBG DT NN IN NNP .
1
*0*let exprref be the result of evaluating the expression of c.

VB DT NN IN VBG JJ NN NN NNP NNP NNP .
1
*0*return the result of performing strict equality comparison input === clauseselector.

IN NNP VBZ RB DT NN , NN JJ .
1
*0*if stmt is not a labelledstatement, return false.

IN NNP VBZ JJ : NN , NN JJ .
1
*0*if item is labelleditem:functiondeclaration , return true.

IN NN IN NNP VBZ JJ , NN JJ .
1
*0*if isfunctiondefinition of expr is false, return false.

VB NNP VB DT NN IN NN IN NNP .
1
*0*let hasname be the result of hasname of expr.

IN DT NN NN VBG NNP VBZ JJ NN , NN JJ .
1
*0*if the source code matching call is non-strict code, return false.

IN NNP VBZ RB VBN IN DT NN , NN , CC NN , NN JJ .
1
*0*if call is not contained within a functionbody, concisebody, or asyncconcisebody, return false.

VB NNP VB DT NN , NN , CC NN IN JJS RB VBZ NNP .
1
*0*let body be the functionbody, concisebody, or asyncconcisebody that most closely contains call.

IN NNP VBZ DT NN , NN JJ .
1
*0*if body is an asyncconcisebody, return false.

VB DT NN IN NN IN NN IN NN NNP .
1
*0*return the result of hascallintailposition of body with argument call.

NN NNP IN DT NN NN NN . DT NN NN RB IN DT NN IN DT NN VBZ DT JJ NN NN .
1
*0*pop leafcontext from the execution context stack. the execution context now on the top of the stack becomes the running execution context.

NN : NNP VBZ DT JJ NN . PRP MD RB VB VBN IN DT VBG NN NN .
1
*0*assert: leafcontext has no further use. it will never be activated as the running execution context.

NN NN NN ( JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : VBN ) .
1
*0*return script record { [[REALM]]: realm, [[ENVIRONMENT]]: undefined, [[ECMASCRIPTCODE]]: body, [[HOSTDEFINED]]: hostdefined }.

NN : DT JJ NNS VBP IN DT JJ NN IN DT JJ NN VBZ DT JJ NN . RB , IN DT JJ NN VBZ DT JJ JJ NN PRP MD VB NNS WDT VBP JJ NNS IN DT IN DT JJ NNS .
1
*0*note: no abnormal terminations occur after this algorithm step if the global object is an ordinary object. however, if the global object is a proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps.

IN NNP . VB JJ NNP NN NN VBZ RB , RB
1
*1*if ee.[[MODULEREQUEST]] is null, then

IN NNP . VB JJ NNP NNP NNP VBZ RB DT NN IN NNP , RB
1
*2*if ee.[[LOCALNAME]] is not an element of importedboundnames, then

VB NNP VB DT NN IN NNS WP$ JJ NN NNP NNP NNP VBZ DT JJ IN NNP . VB JJ NNP NNP NNP .
1
*3*let ie be the element of importentries whose [[LOCALNAME]] is the same as ee.[[LOCALNAME]].

NN : DT VBZ DT NN IN DT VBN NN NN NN .
1
*4*assert: this is a re-export of an imported module namespace object.

RB DT VBZ DT NN IN DT JJ NN ,
1
*3*else this is a re-export of a single name,

VB DT NN NN ( JJ NN NNP NN NN : NNP . VB JJ NNP NN NNP , NNP NNP NNP NNP NN : NNP . VB JJ NNP NNP NNP , NNP NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : NNP . VB JJ NNP NNP NNP ) TO NNS .
1
*4*append the exportentry record { [[MODULEREQUEST]]: ie.[[MODULEREQUEST]], [[IMPORTNAME]]: ie.[[IMPORTNAME]], [[LOCALNAME]]: null, [[EXPORTNAME]]: ee.[[EXPORTNAME]] } to indirectexportentries.

NN NN NN NN NN ( JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : JJ , JJ FW NNP NNP NN : JJ , JJ NN NNP NNP NN : `` JJ '' , NNP NNP NNP NNP NN : JJ , JJ NN NNP NNP NN : VBN , JJ NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : NNS , NNP NNP NNP NNP NN : NNS , NNP NNP NNP NNP NN : NNS , NNP NNP NNP NNP NN : NNS , NNP NNP NNP NNP NN : NNS , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) .
1
*0*return source text module record { [[REALM]]: realm, [[ENVIRONMENT]]: undefined, [[NAMESPACE]]: undefined, [[STATUS]]: "uninstantiated", [[EVALUATIONERROR]]: undefined, [[HOSTDEFINED]]: hostdefined, [[ECMASCRIPTCODE]]: body, [[REQUESTEDMODULES]]: requestedmodules, [[IMPORTENTRIES]]: importentries, [[LOCALEXPORTENTRIES]]: localexportentries, [[INDIRECTEXPORTENTRIES]]: indirectexportentries, [[STAREXPORTENTRIES]]: starexportentries, [[DFSINDEX]]: undefined, [[DFSANCESTORINDEX]]: undefined }.

IN NNP . VB JJ NNP NNP NNP VBZ `` VBG '' , `` VBN '' , CC `` VBN '' , RB
1
*0*if module.[[STATUS]] is "instantiating", "instantiated", or "evaluated", then

NN : NN . CC JJ NNP NNP NNP VBZ CC `` NN '' , `` VBN '' , CC `` VBN '' .
1
*1*assert: requiredmodule.[[STATUS]] is either "instantiating", "instantiated", or "evaluated".

NN : DT VBN NNS IN NNP VBP JJ .
1
*0*assert: all named exports from module are resolvable.

VB NNP VB . NNP ( NNP , NNP . VB JJ NNP NNP NNP ) .
1
*1*let importedmodule be ! hostresolveimportedmodule(module, in.[[MODULEREQUEST]]).

NN : DT IN NN MD RB VB IN VBN NN NNS VBP DT NN IN NNP . VB JJ NNP NNP NNP , CC DT VBP VBN VBN RBR IN DT NN .
1
*1*note: the above call cannot fail because imported module requests are a subset of module.[[REQUESTEDMODULES]], and these have been resolved earlier in this algorithm.

NN NNP ( NNP . VB JJ NNP NNP NNP , NNP ) .
1
*2*call envrec.initializebinding(in.[[LOCALNAME]], namespace).

NN NNP ( NNP . VB JJ NNP NNP NNP , NNP . VB JJ NNP NNP NNP , NNP . VB JJ NNP NNP NNP ) .
1
*2*call envrec.createimportbinding(in.[[LOCALNAME]], resolution.[[MODULE]], resolution.[[BINDINGNAME]]).

IN NNP . VB JJ NNP NNP NNP VBZ JJ , JJ NNP .
1
*1*if module.[[EVALUATIONERROR]] is undefined, return index.

RB NN NNP . VB JJ NNP NNP NNP .
1
*1*otherwise return module.[[EVALUATIONERROR]].

IN NNP . VB JJ NNP NNP NNP VBZ `` VBG '' , VB NNP .
1
*0*if module.[[STATUS]] is "evaluating", return index.

NN : NN MD VB VBN RB JJ TO VBG DT NN , RB DT JJ NN VBZ VBN TO VB RB .
1
*1*note: instantiate must be completed successfully prior to invoking this method, so every requested module is guaranteed to resolve successfully.

NN : NN . CC JJ NNP NNP NNP VBZ CC `` NN '' CC `` VBN '' .
1
*1*assert: requiredmodule.[[STATUS]] is either "evaluating" or "evaluated".

NN : NN . CC JJ NNP NNP NNP VBZ RB JJ .
1
*0*assert: module.[[REALM]] is not undefined.

NN : NN VBZ VBN VBN CC NNS IN PRP$ NN NN VBP VBN VBN .
1
*0*assert: module has been linked and declarations in its module environment have been instantiated.

VB NNP VB DT NN IN VBG NNP . VB JJ NNP NNP NNP .
1
*0*let result be the result of evaluating module.[[ECMASCRIPTCODE]].

NN : NN VBZ DT NN IN DT JJ NN IN NN NN .
1
*0*assert: module is an instance of a concrete subclass of module record.

NN : NN . CC JJ NNP NNP NNP VBZ RB `` JJ '' .
1
*0*assert: module.[[STATUS]] is not "uninstantiated".

NN : IN NNP . VB JJ NNP NNP NNP VBZ `` JJ '' , NNP . VB JJ NNP NNP NNP VBZ VBN .
1
*0*assert: if module.[[STATUS]] is "evaluated", module.[[EVALUATIONERROR]] is undefined.

VB NNP VB . NNP ( NNP NNP ) .
1
*1*let exportednames be ? module.getexportednames(« »).

IN NNP VBZ DT NN NN , VBP NNP TO NNP .
1
*2*if resolution is a resolvedbinding record, append name to unambiguousnames.

NN : DT NNS IN NNP VBP VBN RB VBN CC NNP VBZ JJ IN NN .
1
*0*assert: all dependencies of m have been transitively resolved and m is ready for evaluation.

NN . NNP ( NNP , NNP , JJ , JJ ) .
1
*0*return ? performeval(x, calleerealm, false, false).

NN : IN NNP VBZ JJ , RB NNP VBZ RB JJ .
1
*0*assert: if direct is false, then strictcaller is also false.

IN NNP ( NNP ) VBZ RB JJ , JJ NNP .
1
*0*if type(x) is not string, return x.

IN NNP VBZ DT NN NN NN , RB
1
*0*if thisenvrec is a function environment record, then

IN NNP . VB JJ NNP NNP NNP VBZ `` JJ '' , VB NNP VB JJ : RB , VB NNP VB JJ .
1
*1*if f.[[CONSTRUCTORKIND]] is "derived", let inderivedconstructor be true; otherwise, let inderivedconstructor be false.

VB NNP VB DT JJ NN WDT VBZ DT NN IN VBG NNP , VBD IN JJ VBD JJ NN IN VBN IN CD , IN DT NN NN NN . IN NNP VBZ JJ , JJ JJ NN NNS IN CD VBP VBN . IN NNP VBZ JJ , JJ JJ NN NNS IN CD VBP VBN . IN NNP VBZ JJ , JJ JJ NN NNS IN CD VBP VBN . IN DT NN VBZ , VB DT NN NN . IN DT JJ NNS VBP VBN , VB DT NN CC DT NN NN , VBG IN DT NN IN DT NN ( CC VBP RB VBP CD ) . VBG CC JJ NN NN MD VB VBN IN DT JJ NN .
1
*0*let script be the ecmascript code that is the result of parsing x, interpreted as utf-16 encoded unicode text as described in 6.1.4, for the goal symbol script. if infunction is false, additional early error rules from 18.2.1.1.1 are applied. if inmethod is false, additional early error rules from 18.2.1.1.2 are applied. if inderivedconstructor is false, additional early error rules from 18.2.1.1.3 are applied. if the parse fails, throw a syntaxerror exception. if any early errors are detected, throw a syntaxerror or a referenceerror exception, depending on the type of the error (but see also clause 16). parsing and early error detection may be interweaved in an implementation-dependent manner.

IN NNP VBZ NN VBZ JJ , NN VBD .
1
*0*if script contains scriptbody is false, return undefined.

RB , VB NNP VB NN IN NNP .
1
*0*else, let stricteval be isstrict of script.

NN : IN NNP VBZ JJ , NNP MD VB DT NN NN WDT VBD DT JJ NN . IN NNP VBZ JJ , NNP MD VB DT NN NN IN DT NN IN DT JJ NN .
1
*0*note: if direct is true, ctx will be the execution context that performed the direct eval. if direct is false, ctx will be the execution context for the invocation of the eval function.

VB NNP VB NNP ( NNP POS NN ) .
1
*1*let lexenv be newdeclarativeenvironment(ctx's lexicalenvironment).

VB DT NNP POS NN TO VB .
1
*0*set the evalcxt's function to null.

VB DT NNP POS NN TO NNP POS NN .
1
*0*set the evalcxt's scriptormodule to ctx's scriptormodule.

NN : NN MD RB VB DT JJ NN NN WDT MD VB VBN IN DT JJ JJ NN .
1
*3*note: eval will not create a global var declaration that would be shadowed by a global lexical declaration.

NN : DT VBG NN MD VB .
1
*1*assert: the following loop will terminate.

NN , IN NNP VBZ RB DT JJ IN NNP ,
1
*1*repeat, while thislex is not the same as varenv,

IN NNP VBZ RB DT JJ NN NN , RB
1
*2*if thisenvrec is not an object environment record, then

NN : DT NN IN IN NNS MD RB VB DT JJ NN IN PRP VBZ RB VB TO VB VBN IN let NN NNS .
1
*3*note: the environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.

NN : NN NN NNS VBP NNS IN DT JJ NN .
1
*5*note: annex b.3.5 defines alternate semantics for the above step.

NN : DT JJ NN MD RB VB NN NN IN DT JJ JJ NN .
1
*4*note: a direct eval will not hoist var declaration over a like-named lexical declaration.

VBN NNP TO NNP POS NN NN NN .
1
*2*set thislex to thislex's outer environment reference.

NN : DT JJ NNS VBP IN DT JJ NN IN NNP VBZ DT JJ NN NN CC DT JJ NN VBZ DT JJ JJ NN .
1
*0*note: no abnormal terminations occur after this algorithm step unless varenvrec is a global environment record and the global object is a proxy exotic object.

VB NNP VB DT NN IN VBG VBG IN DT JJS NN NN WDT VBZ RB DT NN CC DT VBP NNS TO DT NN IN DT NN NN . ( IN JJ NNS , VB VBG JJ NN . ) IN NNP VBZ RB VB DT JJ NN NNS , VB NNP VB DT JJ NN .
1
*0*let trimmedstring be a substring of inputstring consisting of the leftmost code unit that is not a strwhitespacechar and all code units to the right of that code unit. (in other words, remove leading white space.) if inputstring does not contain any such code units, let trimmedstring be the empty string.

IN DT NNP CC DT NN IN VBG NNS DT NN IN DT JJ ( VB CD ) , VBP RB .
1
*0*if neither trimmedstring nor any prefix of trimmedstring satisfies the syntax of a strdecimalliteral (see 7.1.3.1), return nan.

VB NNP VB DT JJS NN IN NNP , WDT MD VB VBG PRP , IN VBZ DT NN IN DT JJ .
1
*0*let numberstring be the longest prefix of trimmedstring, which might be trimmedstring itself, that satisfies the syntax of a strdecimalliteral.

VB NNP VB VBN IN NNP .
1
*0*let mathfloat be mv of numberstring.

IN NNP , RB
1
*0*if mathfloat=0, then

IN DT JJ NN NN IN NNP VBZ DT NN NN CD ( NN ) , VBP UH .
1
*1*if the first code unit of trimmedstring is the code unit 0x002d (hyphen-minus), return -0.

VB DT NN NN IN NNP .
1
*0*return the number value for mathfloat.

VB NNP VB DT RB VBN NN IN VBG VBG IN DT JJ NN NN WDT VBZ RB DT NN CC DT VBP NNS VBG IN JJ NN . ( IN JJ NNS , VB VBG JJ NN . ) IN NNP VBZ RB VB DT JJ NN NN , VB NNP VB DT JJ NN .
1
*0*let s be a newly created substring of inputstring consisting of the first code unit that is not a strwhitespacechar and all code units following that code unit. (in other words, remove leading white space.) if inputstring does not contain any such code unit, let s be the empty string.

IN NNP VBZ RB JJ CC DT JJ NN NN IN NNP VBZ DT NN NN CD ( NN ) , VB NNP VB VBN .
1
*0*if s is not empty and the first code unit of s is the code unit 0x002d (hyphen-minus), let sign be -1.

IN NNP VBZ RB JJ CC DT JJ NN NN IN NNP VBZ DT NN NN CD ( CC NN ) CC DT NN NN CD ( NN ) , VB DT JJ NN NN IN NNP .
1
*0*if s is not empty and the first code unit of s is the code unit 0x002b (plus sign) or the code unit 0x002d (hyphen-minus), remove the first code unit from s.

IN NNP CC NN : CD CC NNP CC NN : CD , NN NN .
1
*1*if r &lt; 2 or r &gt; 36, return nan.

IN NNP VBD CD , VB NNP VB JJ .
1
*1*if r ≠ 16, let stripprefix be false.

IN DT NN IN NNP VBZ IN JJS CD CC DT JJ CD VBP NNS IN NNP VBP DT `` CD '' CC `` CD '' , VB DT JJ CD VBP NNS IN NNP CC VB NNP VB CD .
1
*1*if the length of s is at least 2 and the first two code units of s are either "0x" or "0x", remove the first two code units from s and let r be 16.

IN NNP VBZ DT NN NN WDT VBZ RB DT JJ NN , VB NNP VB DT NN IN NNP VBG IN DT NNS NNS IN DT JJ JJ NN NN : RB , VB NNP VB NNP .
1
*0*if s contains a code unit that is not a radix-r digit, let z be the substring of s consisting of all code units before the first such code unit; otherwise, let z be s.

VB NNP VB DT JJ NN NN WDT VBZ VBN IN NNP IN JJ NN , VBG DT NNS JJ CC JJ IN NNS IN NNS CD IN CD . ( RB , IN NNP VBZ CD CC NNP VBZ JJR IN CD JJ NNS , DT JJ NN IN DT JJ MD VB VBN IN DT CD NN , IN DT NN IN DT NN : CC IN NNP VBZ RB CD , CD , CD , CD , CD , CC CD , RB NNP MD VB DT JJ NN TO DT JJ NN NN WDT VBZ VBN IN NNP IN JJ NN .
1
*0*let mathint be the mathematical integer value that is represented by z in radix-r notation, using the letters a-z and a-z for digits with values 10 through 35. (however, if r is 10 and z contains more than 20 significant digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the implementation; and if r is not 2, 4, 8, 10, 16, or 32, then mathint may be an implementation-dependent approximation to the mathematical integer value that is represented by z in radix-r notation.)

NN NNP NNP NNP .
1
*0*return sign × number.

IN NNP VBZ IN NNP , RB
1
*1*if c is in unescapedset, then

RB NNP VBZ RB IN NNP ,
1
*1*else c is not in unescapedset,

IN NNP VBZ DT VBG NN , VB DT JJ NN .
1
*2*if c is a trailing surrogate, throw a urierror exception.

IN NNP VBZ RB DT VBG NN , RB
1
*2*if c is not a leading surrogate, then

VB NNP VB DT NN NN IN DT JJ JJ NN IN NN NN NNP .
1
*3*let v be the code point with the same numeric value as code unit c.

IN NNP NNS NNP , VBP DT JJ NN .
1
*3*if k equals strlen, throw a urierror exception.

IN NNP VBZ RB DT NN NN , VB DT JJ NN .
1
*3*if kchar is not a trailing surrogate, throw a urierror exception.

VB NNS VB DT NN IN NNS VBG IN VBG DT JJ NN TO NNP .
1
*2*let octets be the list of octets resulting by applying the utf-8 transformation to v.

VB NNP VB DT NN IN : '' NN '' DT NN NN IN NNP , VBD IN DT JJ NN JJ NN , VBD TO DT NN IN DT NN IN JJ
1
*3*let s be the string-concatenation of:"%" the string representation of octet, formatted as a two-digit uppercase hexadecimal number, padded to the left with a zero if necessary

IN NNP VBZ RB DT NN NN CD ( JJ NN ) , RB
1
*1*if c is not the code unit 0x0025 (percent sign), then

RB NNP VBZ DT NN NN CD ( JJ NN ) ,
1
*1*else c is the code unit 0x0025 (percent sign),

IN NNP NNP CD VBZ JJR IN CC JJ TO NNP , VBP DT JJ NN .
1
*2*if k + 2 is greater than or equal to strlen, throw a urierror exception.

IN DT RBS JJ NN IN NNP VBZ CD , RB
1
*2*if the most significant bit in b is 0, then

VB NNP VB DT NN NN WP$ NN VBZ NNP .
1
*3*let c be the code unit whose value is b.

IN NNP VBZ RB IN NNP , RB
1
*3*if c is not in reservedset, then

RB NNP VBZ IN NNP ,
1
*3*else c is in reservedset,

VB NNP VB DT NN IN VBG IN NN NNP TO NN NNP NN .
1
*4*let s be the substring of string from index start to index k inclusive.

RB DT RBS JJ NN IN NNP VBZ CD ,
1
*2*else the most significant bit in b is 1,

VB NNP VB DT JJS JJ NN JJ IN ( NNP CC NN : CC NN : NNP ) CC NN : CD VBZ JJ TO CD .
1
*3*let n be the smallest nonnegative integer such that (b &lt;&lt; n) &amp; 0x80 is equal to 0.

IN NNP VBZ CD CC NNP VBZ JJR IN CD , VBP DT JJ NN .
1
*3*if n equals 1 or n is greater than 4, throw a urierror exception.

VB NNS VB DT NN IN JJ NNS IN NN NNP .
1
*3*let octets be a list of 8-bit integers of size n.

VBN NNS VBP CD NN TO NNP .
1
*3*set octets[0] to b.

IN NNP NNP ( CD NN ( NNP : CD ) ) VBZ JJR IN CC JJ TO NNP , VBP DT JJ NN .
1
*3*if k + (3 × (n - 1)) is greater than or equal to strlen, throw a urierror exception.

IN DT NN NN IN NN NNP IN NNP VBZ RB DT NN NN CD ( JJ NN ) , VBP DT JJ NN .
1
*4*if the code unit at index k within string is not the code unit 0x0025 (percent sign), throw a urierror exception.

IN DT CD RBS JJ NNS IN NNP VBP RB CD , VBP DT JJ NN .
1
*4*if the two most significant bits in b are not 10, throw a urierror exception.

VBN NNS VBP NNP NNP TO NNP .
1
*4*set octets[j] to b.

IN NNS VBZ RB VB DT JJ JJ NN IN DT JJ NN NN , VB DT JJ NN .
1
*3*if octets does not contain a valid utf-8 encoding of a unicode code point, throw a urierror exception.

VB NNP VB DT NN VBN IN VBG DT JJ NN TO NNS , DT VBZ , IN DT NN IN NNS IN DT JJ NN .
1
*3*let v be the value obtained by applying the utf-8 transformation to octets, that is, from a list of octets into a 21-bit value.

VB NNP VB DT NN NN WP$ NNS VBP , IN NN , DT NNS IN NNP ( NNP ) .
1
*3*let s be the string value whose elements are, in order, the elements in utf16encoding(v).

VB NNP VB DT NN VBG CD NN IN DT NN NN JJ IN JJ CC `` # '' .
1
*0*let reserveduriset be a string containing one instance of each code unit valid in urireserved plus "#".

VB NNP VB DT NN VBG CD NN IN DT NN NN JJ IN JJ CC JJ CC `` # '' .
1
*0*let unescapeduriset be a string containing one instance of each code unit valid in urireserved and uriunescaped plus "#".

VB NNP VB DT NN VBG CD NN IN DT NN NN JJ IN JJ .
1
*0*let unescapeduricomponentset be a string containing one instance of each code unit valid in uriunescaped.

IN DT VBZ DT JJ CC DT JJ NN , RB
1
*0*if newtarget is neither undefined nor the active function, then

NN . NNP ( NN , `` NN JJ NN '' ) .
1
*1*return ? ordinarycreatefromconstructor(newtarget, "%objectprototype%").

IN NNP VBZ JJ , VBD CC RB VBN , VB NNP ( NN IN NN ) .
1
*0*if value is null, undefined or not supplied, return objectcreate(%objectprototype%).

IN RB CD NN VBD VBN , VB NNP .
1
*0*if only one argument was passed, return to.

VB NNS VB DT NN IN NN NNS VBG IN DT JJ NN .
1
*0*let sources be the list of argument values starting with the second argument.

IN DT NN NNP IN NNP , IN VBG NN NN , VBP
1
*0*for each element nextsource of sources, in ascending index order, do

IN NNP VBZ JJ CC JJ , VB NNP VB DT JJ JJ NN .
1
*1*if nextsource is undefined or null, let keys be a new empty list.

IN NNS VBZ RB JJ , RB
1
*0*if properties is not undefined, then

VB DT NN ( DT CD JJ NN ) NN IN NNP CC NNP TO DT NN IN NNS .
1
*2*append the pair (a two element list) consisting of nextkey and desc to the end of descriptors.

VB NNS VB . NNP ( NN IN NN ) .
1
*0*let descriptors be ! objectcreate(%objectprototype%).

IN NNP VBZ RB JJ , NN . NNP ( NNP , NNP , NNP ) .
1
*1*if descriptor is not undefined, perform ! createdataproperty(descriptors, key, descriptor).

NN . NNP ( NNP , VBG ) .
1
*0*return ? getownpropertykeys(o, string).

IN NNP ( NNP ) VBZ NNP , RB
1
*1*if type(nextkey) is type, then

NN . NNP ( NNP , `` VBD '' ) .
1
*0*return ? testintegritylevel(o, "sealed").

VB NNP VB . NNP ( NNP , `` VBD '' ) .
1
*0*let status be ? setintegritylevel(o, "sealed").

IN DT DT NN VBZ JJ , VB `` JJ NN VBD NNP '' .
1
*0*if the this value is undefined, return "[object undefined]".

IN DT DT NN VBZ JJ , VB `` JJ JJ NN NN '' .
1
*0*if the this value is null, return "[object null]".

IN NNP VBZ JJ , VB NNP VB `` JJ '' .
1
*0*if isarray is true, let builtintag be "array".

RB IN NNP VBZ DT NN JJ NN , VB NNP VB `` VBG '' .
1
*0*else if o is a string exotic object, let builtintag be "string".

RB IN NNP VBZ DT JJ NN NNP NNP NNP JJ NN , VB NNP VB `` NNS '' .
1
*0*else if o has a [[PARAMETERMAP]] internal slot, let builtintag be "arguments".

IN NNP ( NNP ) VBZ RB VBG , VB NNP VB NNP .
1
*0*if type(tag) is not string, let tag be builtintag.

VB DT NN IN `` JJ NN `` , NNP , CC `` JJ '' .
1
*0*return the string-concatenation of "[object ", tag, and "]".

NN . NNP ( NNP , NN , `` JJ '' , NNP ) .
1
*0*return ? createdynamicfunction(c, newtarget, "normal", args).

IN NNP VBZ JJ , VB NNP TO NNP .
1
*0*if newtarget is undefined, set newtarget to constructor.

VB NNP VB DT NN NN NN NNP NNP , NNP NNP .
1
*1*let goal be the grammar symbol functionbody[~yield, ~await].

RB IN NNP VBZ `` NN '' , RB
1
*0*else if kind is "generator", then

NN : NNP VBZ `` JJ NN '' .
1
*1*assert: kind is "async generator".

IN NNP VBD CD , VB NNP VB DT JJ NN .
1
*0*if argcount = 0, let bodytext be the empty string.

RB IN NNP VBD CD , VB NNP VB NNP NNP CD NN .
1
*0*else if argcount = 1, let bodytext be args[0].

VB NNP VB NNP NNP CD NN .
1
*1*let firstarg be args[0].

VBN NNP TO DT NN IN DT JJ NN IN NNP , `` , '' ( DT NN ) , CC NNP .
1
*2*set p to the string-concatenation of the previous value of p, "," (a comma), and nextargstring.

VB NNS VB DT NN IN VBG NNP , VBD IN JJ VBD JJ NN IN VBN IN CD , VBG NNP IN DT NN NN . VB DT NN NN IN DT NN VBZ .
1
*0*let parameters be the result of parsing p, interpreted as utf-16 encoded unicode text as described in 6.1.4, using parametergoal as the goal symbol. throw a syntaxerror exception if the parse fails.

VB NNP VB DT NN IN VBG NNP , VBD IN JJ VBD JJ NN IN VBN IN CD , VBG NNP IN DT NN NN . VB DT NN NN IN DT NN VBZ .
1
*0*let body be the result of parsing bodytext, interpreted as utf-16 encoded unicode text as described in 6.1.4, using goal as the goal symbol. throw a syntaxerror exception if the parse fails.

VB NNP VB NN IN NNP .
1
*0*let strict be containsusestrict of body.

IN DT JJ NNS NNS VBP VBN IN NNS CC NNP , VBP DT NN CC DT NN NN , VBG IN DT NN IN DT NN . IN NNP VBZ JJ , DT JJ NN NNS IN NNS : NNS VBP VBN . NN CC JJ NN NN MD VB VBN IN DT JJ NN .
1
*0*if any static semantics errors are detected for parameters or body, throw a syntaxerror or a referenceerror exception, depending on the type of the error. if strict is true, the early error rules for uniqueformalparameters:formalparameters are applied. parsing and early error detection may be interweaved in an implementation-dependent manner.

IN NNP VBZ JJ CC NN IN NNP VBZ JJ , VB DT NN NN .
1
*0*if strict is true and issimpleparameterlist of parameters is false, throw a syntaxerror exception.

IN DT NN IN DT NNS IN NNP RB VBZ IN DT NNS IN NNP , VBP DT NN NN .
1
*0*if any element of the boundnames of parameters also occurs in the lexicallydeclarednames of body, throw a syntaxerror exception.

IN NNP VBZ `` NN '' CC `` JJ NN '' , RB
1
*0*if kind is "generator" or "async generator", then

IN NNP VBZ `` JJ '' CC `` JJ NN '' , RB
1
*0*if kind is "async" or "async generator", then

IN NNS IN NNP VBZ DT JJ NNS , VBP DT NN NN .
1
*1*if boundnames of parameters contains any duplicate elements, throw a syntaxerror exception.

NN NNP ( NNP , JJ , NNP , NNP , NNP ) .
1
*0*perform functioninitialize(f, normal, parameters, body, scope).

VB NNP VB NNP ( NN NN NN ) .
1
*1*let prototype be objectcreate(%generatorprototype%).

RB IN NNP VBZ `` JJ NN '' , RB
1
*0*else if kind is "async generator", then

VB NNP VB NNP ( NN RB NN ) .
1
*1*let prototype be objectcreate(%asyncgeneratorprototype%).

RB IN NNP VBZ `` JJ '' , VB NNP ( NNP ) .
1
*0*else if kind is "normal", perform makeconstructor(f).

NN : JJ NNS VBP RB JJ CC VBP RB VB DT JJ NNP NNP NNP NNP JJ NN CC DT `` NN '' NN .
1
*0*note: async functions are not constructable and do not have a [[CONSTRUCT]] internal method or a "prototype" property.

VB NNP VB DT JJ ( RB RB ) NN VBG IN DT IN DT NN NNS VBN IN NNP IN NN .
1
*0*let args be a new (possibly empty) list consisting of all of the argument values provided after thisarg in order.

IN NNP ( NNP ) VBZ RB NN , VB NNP VB CD .
1
*1*if type(targetlen) is not number, let l be 0.

VB NNP VB DT JJR IN CD CC DT NN IN NNP CC DT NN IN NNS IN NNP .
1
*2*let l be the larger of 0 and the result of targetlen minus the number of elements of args.

RB , VB NNP VB CD .
1
*0*else, let l be 0.

IN NNP ( NNP ) VBZ RB VBG , VB NNP VB DT JJ NN .
1
*0*if type(targetname) is not string, let targetname be the empty string.

NN NNP ( NNP , NNP , `` NN '' ) .
1
*0*perform setfunctionname(f, targetname, "bound").

IN DT NN VBD VBN IN JJR IN CD NN , RB IN VBN TO JJ NN , VBG IN DT JJ NN , VBP DT NN IN DT JJ NN IN NNP .
1
*0*if this method was called with more than one argument, then in left to right order, starting with the second argument, append each argument as the last element of arglist.

VB DT JJ NN NN NN NN IN NNP . DT NN MD VB TO DT NNS IN . PRP VBZ JJ IN DT NN VBZ IN NN NN CC NN IN DT NN NN .
1
*1*return an implementation-dependent string source code representation of func. the representation must conform to the rules below. it is implementation-dependent whether the representation includes bound function information or information about the target function.

IN NNP ( NNP ) VBZ JJ CC VBZ DT DT JJ NN NN CC VBZ DT JJ NN NNP NNP NNP JJ NN , RB
1
*0*if type(func) is object and is either a built-in function object or has an [[ECMASCRIPTCODE]] internal slot, then

VB DT JJ NN NN NN NN IN NNP . DT NN MD VB TO DT NNS IN .
1
*1*return an implementation-dependent string source code representation of func. the representation must conform to the rules below.

IN DT VBZ JJ , VB NNP .
1
*0*if newtarget is undefined, return b.

IN NNP VBZ JJ , VB `` JJ '' : RB VBP `` JJ '' .
1
*0*if b is true, return "true"; else return "false".

IN DT VBZ RB JJ , VB DT NN NN .
1
*0*if newtarget is not undefined, throw a typeerror exception.

RB , VB VBG VB . NNP ( NNP ) .
1
*0*else, let descstring be ? tostring(description).

VB DT JJ JJ NN NN WP$ JJ NNP NNP NNP NNP NN VBZ VBG .
1
*0*return a new unique symbol value whose [[DESCRIPTION]] value is descstring.

IN DT NN NNP IN DT NN NN , VBP
1
*0*for each element e of the globalsymbolregistry list, do

VB NNP VB DT JJ JJ NN NN WP$ JJ NNP NNP NNP NNP NN VBZ NNP .
1
*0*let newsymbol be a new unique symbol value whose [[DESCRIPTION]] value is stringkey.

VB DT NN ( JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NNP : NN ) TO DT NN NN .
1
*0*append the record { [[KEY]]: stringkey, [[SYMBOL]]: newsymbol } to the globalsymbolregistry list.

IN DT NN NNP IN DT NN NN ( VB CD ) , VBP
1
*0*for each element e of the globalsymbolregistry list (see 19.4.2.2), do

VB DT NN IN `` NN ( `` , NNP , CC `` ) '' .
1
*0*return the string-concatenation of "symbol(", desc, and ")".

IN NNP VBZ JJ , VB NNP VB `` JJ '' : RB VB NNP VB . NNP ( NNP ) .
1
*0*if name is undefined, let name be "error"; otherwise let name be ? tostring(name).

IN NNP VBZ JJ , VB NNP VB DT JJ NN : RB VB NNP VB . NNP ( NNP ) .
1
*0*if msg is undefined, let msg be the empty string; otherwise let msg be ? tostring(msg).

VB DT NN IN NNP , DT NN NN CD ( NN ) , DT NN NN CD ( NN ) , CC NNP .
1
*0*return the string-concatenation of name, the code unit 0x003a (colon), the code unit 0x0020 (space), and msg.

IN DT NNS VBD VBN TO DT NN NN , VB NNP VB VBN .
1
*0*if no arguments were passed to this function invocation, let n be +0.

IN DT VBZ JJ , NN NNP .
1
*0*if newtarget is undefined, return n.

IN NNS ( NNP ) VBD JJ , VB JJ .
1
*0*if abs(integer) ≤ 253-1, return true.

NN : NNP VBZ CD , WRB NNS VBZ JJ .
1
*0*assert: f is 0, when fractiondigits is undefined.

NN NNP CC NNP VB NNS JJ IN CD NNP NNP CC NN : CD CC IN WDT DT JJ JJ NN IN NNP NNP JJ : NN VBZ RB JJ TO CD IN JJ . IN EX VBP CD JJ NNS IN NNP CC NNP , VB DT NNP CC NNP IN WDT NNP NNP CD VBZ JJR .
1
*2*let e and n be integers such that 10f ≤ n &lt; 10f+1 and for which the exact mathematical value of n × 10e-f - x is as close to zero as possible. if there are two such sets of e and n, pick the e and n for which n × 10e-f is larger.

NN NNP , NNP , CC NNP VB NNS JJ IN NNP VBD CD , CD NNP NNP CC NN : CD , DT NN NN IN NNP NNP CD VBZ NNP , CC NNP VBZ RB JJ IN JJ . NN IN DT JJ NN IN NNP VBZ NNP NNS , NNP VBZ RB JJ IN CD , CC DT JJS JJ NN IN NNP VBZ RB RB RB VBN IN DT NNS .
1
*2*let e, n, and f be integers such that f ≥ 0, 10f ≤ n &lt; 10f+1, the number value for n × 10e-f is x, and f is as small as possible. note that the decimal representation of n has f+1 digits, n is not divisible by 10, and the least significant digit of n is not necessarily uniquely determined by these criteria.

VB NNP VB DT JJ NN IN NNP , CC VB NNP VB DT VBG NNP NNS IN NNP .
1
*1*let a be the first element of m, and let b be the remaining f elements of m.

VB NNP VB `` JJ '' .
1
*1*let c be "+".

VB NNP VB `` CD '' .
1
*1*let d be "0".

IN NNP CC NN : CD , VB NNP VB `` JJ '' .
1
*1*if e &gt; 0, let c be "+".

VB NNP VB DT NN IN NNP , `` NN '' , NNP , CC NNP .
1
*0*let m be the string-concatenation of m, "e", c, and d.

VB NNP VB DT NN IN WDT DT JJ JJ NN IN NNP NNP CD : NN VBZ RB JJ TO CD IN JJ . IN EX VBP CD JJ NNP , VB DT JJR NNP .
1
*1*let n be an integer for which the exact mathematical value of n ÷ 10f - x is as close to zero as possible. if there are two such n, pick the larger n.

IN NNP VBD CD , VB NNP VB DT NN `` CD '' . RB , VB NNP VB DT VBG NN NN IN DT NNS IN DT JJ NN IN NNP ( IN NN , IN DT VBG NNS ) .
1
*1*if n = 0, let m be the string "0". otherwise, let m be the string value consisting of the digits of the decimal representation of n (in order, with no leading zeroes).

VB NNP VB DT NN IN NNP CC NNP .
1
*3*let m be the string-concatenation of z and m.

VB NNP VB DT JJ JJ NNS IN NNP , CC VB NNP VB DT VBG NNP NNS IN NNP .
1
*2*let a be the first k-f elements of m, and let b be the remaining f elements of m.

NN NNP CC NNP VB NNS JJ IN JJ NNP NNP CC NN : CD CC IN WDT DT JJ JJ NN IN NNP NNP JJ : NN VBZ RB JJ TO CD IN JJ . IN EX VBP CD JJ NNS IN NNP CC NNP , VB DT NNP CC NNP IN WDT NNP NNP CD VBZ JJR .
1
*1*let e and n be integers such that 10p-1 ≤ n &lt; 10p and for which the exact mathematical value of n × 10e-p+1 - x is as close to zero as possible. if there are two such sets of e and n, pick the e and n for which n × 10e-p+1 is larger.

IN NNP CC NN : CC CC NNP NNP NNP , RB
1
*1*if e &lt; -6 or e ≥ p, then

VB NNP VB DT JJ NN IN NNP , CC VB NNP VB DT VBG JJ NNS IN NNP .
1
*3*let a be the first element of m, and let b be the remaining p-1 elements of m.

VB NNP VB DT NN NN CD ( CC NN ) .
1
*3*let c be the code unit 0x002b (plus sign).

VB DT NN IN NNP , NNP , DT NN NN CD ( VB JJ NN NN ) , NNP , CC NNP .
1
*2*return the string-concatenation of s, m, the code unit 0x0065 (latin small letter e), c, and d.

IN NNP NNP NNP , VB DT NN IN NNP CC NNP .
1
*0*if e = p-1, return the string-concatenation of s and m.

VB NNP VB DT NN IN DT JJ NNP NNS IN NNP , DT NN NN CD ( JJ NN ) , CC DT VBG NNP ( NNP ) NNS IN NNP .
1
*1*let m be the string-concatenation of the first e+1 elements of m, the code unit 0x002e (full stop), and the remaining p- (e+1) elements of m.

VB NNP VB DT NN IN DT NN NN CD ( JJ NN ) , DT NN NN CD ( JJ NN ) , : ( NNP ) NNS IN DT NN NN CD ( JJ NN ) , CC DT NN NNP .
1
*1*let m be the string-concatenation of the code unit 0x0030 (digit zero), the code unit 0x002e (full stop), -(e+1) occurrences of the code unit 0x0030 (digit zero), and the string m.

IN NNP VBZ RB JJ , VB NNP VB CD .
1
*0*if radix is not present, let radixnumber be 10.

RB IN NNP VBZ JJ , VB NNP VB CD .
1
*0*else if radix is undefined, let radixnumber be 10.

IN NNP NNP CD , NN . NNP ( NNP ) .
1
*0*if radixnumber = 10, return ! tostring(x).

VB DT NN NN IN DT NN NN VBG DT NN VBN IN NNP . NNS JJ VBP VBN IN NNS IN NNS CD IN CD DT NN NN VBZ JJ , RB DT NN MD VB DT NN IN DT VBN IN CD .
1
*0*return the string representation of this number value using the radix specified by radixnumber. letters a-z are used for digits with values 10 through 35. the precise algorithm is implementation-dependent, however the algorithm should be a generalization of that specified in 7.1.12.1.

VB NNP VB DT NN IN VBG CD NNS IN DT JJ JJ NN IN NNP .
1
*0*let p be the number of leading zero bits in the 32-bit binary representation of n.

IN NNP VBZ CD IN NN , NNP , NNP , NNP , NN NNP .
1
*0*if x is one of +0, -0, +∞, -∞, return x.

VB NNP VB DT NN IN VBG NNP TO DT NN IN JJ JJ NN NN VBG NN .
1
*0*let x32 be the result of converting x to a value in ieee 754-2008 binary32 format using roundtiestoeven.

VB NNP VB DT NN IN VBG NNP TO DT NN IN JJ JJ NN NN .
1
*0*let x64 be the result of converting x32 to a value in ieee 754-2008 binary64 format.

VB DT NN NN NN VBG TO NNP .
1
*0*return the ecmascript number value corresponding to x64.

VB NNP VB ( NNP NNP NNP ) VBD CD .
1
*0*let product be (a × b) modulo 232.

IN NNP NNP CD , NN NNP : CD : RB VB NNP .
1
*0*if product ≥ 231, return product - 232; otherwise return product.

VB NNP NNP NNP ( NNP , JJ ) .
1
*0*return t + localtza(t, true).

VB NNP : NNP ( NNP , RB ) .
1
*0*return t - localtza(t, false).

IN NNP VBZ RB JJ CC NNP VBZ RB JJ CC NNP VBZ RB JJ CC NNP VBZ RB JJ , VB NNS .
1
*0*if hour is not finite or min is not finite or sec is not finite or ms is not finite, return nan.

VB NNP VB NNP JJ NNP NNP CC NNP ) .
1
*0*let t be h * msperhour + m * msperminute + s * mspersecond + milli, performing the arithmetic according to ieee 754-2008 rules (that is, as if using the ecmascript operators * and +).

IN NNP VBZ RB JJ CC NNP VBZ RB JJ CC NNP VBZ RB JJ , VB NNS .
1
*0*if year is not finite or month is not finite or date is not finite, return nan.

VB NNP VB NNP NNP NN ( NNP  CD ) .
1
*0*let ym be y + floor(m / 12).

VB NNP VB NNP NN CD .
1
*0*let mn be m modulo 12.

VB DT NN NNP PDT IN NN ( NNP ) VBZ NNP CC NN ( NNP ) VBZ NNP CC NNP ( NNP ) VBZ CD : CC IN DT VBZ RB JJ ( IN DT NN VBZ IN IN NN ) , VBP RB .
1
*0*find a value t such that yearfromtime(t) is ym and monthfromtime(t) is mn and datefromtime(t) is 1; but if this is not possible (because some argument is out of range), return nan.

NN NN ( NNP ) NN NNP : CD .
1
*0*return day(t) + dt - 1.

IN NNP VBZ RB JJ CC NNP VBZ RB JJ , VB NNS .
1
*0*if day is not finite or time is not finite, return nan.

NN NNP NNP NN NNP NNP .
1
*0*return day × msperday + time.

IN NNP VBZ RB JJ , VB NNS .
1
*0*if time is not finite, return nan.

IN NNS ( NNP ) CC NN : CD NN CD , NN NN .
1
*0*if abs(time) &gt; 8.64 × 1015, return nan.

VB NNP VB NNP ( NNP ( NNP , NNP , NNP ) , NNP ( NNP , NNP , NNP , NNP ) ) .
1
*1*let finaldate be makedate(makeday(yr, m, dt), maketime(h, min, s, milli)).

VBN NNP . VB JJ NNP NNP NNP TO NNP ( NNP ( NNP ) ) .
1
*1*set o.[[DATEVALUE]] to timeclip(utc(finaldate)).

VB NNP VB JJ ( NNP ) .
1
*2*let tv be thistimevalue(value).

NN : DT JJ NN RB VBZ DT JJ NN IN NNP VBZ DT VBG NN .
1
*3*assert: the next step never returns an abrupt completion because v is a string value.

VB NNP VB DT NN IN VBG NNP IN DT NN , IN RB DT JJ NN IN IN DT NN NN ( CD ) .
1
*3*let tv be the result of parsing v as a date, in exactly the same manner as for the parse method (20.3.3.2).

VBN NNP . VB JJ NNP NNP NNP TO NNP ( NNP ) .
1
*1*set o.[[DATEVALUE]] to timeclip(tv).

VBN NNP . VB JJ NNP NNP NNP TO DT NN NN ( JJ ) VBG DT JJ NN .
1
*1*set o.[[DATEVALUE]] to the time value (utc) identifying the current time.

NN NNP ( NNP ( NNP ( NNP , NNP , NNP ) , NNP ( NNP , NNP , NNP , NNP ) ) ) .
1
*0*return timeclip(makedate(makeday(yr, m, dt), maketime(h, min, s, milli))).

NN ( NNP : NNP ( NNP ) )  NN .
1
*0*return (t - localtime(t)) / msperminute.

VB NNP VB NNP ( NNP ( NNP ( NN ( NNP ) , NNP ) ) ) .
1
*0*let u be timeclip(utc(makedate(day(t), time))).

VB NNP VB NNP ( NNP ( NN ( NNP ) , NNP ) ) .
1
*0*let v be timeclip(makedate(day(t), time)).

IN NNP VBZ RB JJ , VB NNP VB NNP ( NNP ) .
1
*0*if date is not present, let dt be datefromtime(t).

IN NNP ( NNP ) VBZ NN CC NNP VBZ RB JJ , JJ NN .
1
*0*if type(tv) is number and tv is not finite, return null.

VB DT NN IN NNP , `` : '' , NNP , `` : '' , NNP , DT NN NN CD ( NN ) , CC `` NN '' .
1
*0*return the string-concatenation of hour, ":", minute, ":", second, the code unit 0x0020 (space), and "gmt".

VB DT NN IN NNP , DT NN NN CD ( NN ) , NNP , DT NN NN CD ( NN ) , NNP , DT NN NN CD ( NN ) , CC NNP .
1
*0*return the string-concatenation of weekday, the code unit 0x0020 (space), month, the code unit 0x0020 (space), day, the code unit 0x0020 (space), and year.

VB NNP VB NNP ( NNP , JJ ) .
1
*0*let offset be localtza(tv, true).

IN NNP VBD CD , VB NNP VB `` JJ '' : RB , VB NNP VB `` : '' .
1
*0*if offset ≥ 0, let offsetsign be "+"; otherwise, let offsetsign be "-".

VB NNP VB DT JJ NN WDT VBZ CC DT JJ NN CC DT NN IN DT NN NN CD ( NN ) , DT NN NN CD ( JJ NN ) , DT JJ NN NN , CC DT NN NN CD ( JJ NN ) .
1
*0*let tzname be an implementation-defined string that is either the empty string or the string-concatenation of the code unit 0x0020 (space), the code unit 0x0028 (left parenthesis), an implementation-dependent timezone name, and the code unit 0x0029 (right parenthesis).

VB DT NN IN NNP , NNP , NNP , CC NNP .
1
*0*return the string-concatenation of offsetsign, offsethour, offsetmin, and tzname.

VB DT NNP IN VBG ( NNP ) , DT NN NN CD ( NN ) , NNP ( NNP ) , CC NNP ( NNP ) .
1
*0*return the string-concatenation of datestring(t), the code unit 0x0020 (space), timestring(t), and timezonestring(tv).

VB DT NNP IN VBG ( NNP ) CC NNP ( NNP ) .
1
*0*return the string-concatenation of timestring(t) and timezonestring(tv).

VB DT NNP IN NNP , `` , '' , DT NN NN CD ( NN ) , NNP , DT NN NN CD ( NN ) , NNP , DT NN NN CD ( NN ) , NNP , DT NN NN CD ( NN ) , CC VBG ( NNP ) .
1
*0*return the string-concatenation of weekday, ",", the code unit 0x0020 (space), day, the code unit 0x0020 (space), month, the code unit 0x0020 (space), year, the code unit 0x0020 (space), and timestring(tv).

IN NNP VBZ DT VBG NN `` NN '' CC DT NN NN `` NN '' , RB
1
*0*if hint is the string value "string" or the string value "default", then

VB NNP VB `` VBG '' .
1
*1*let tryfirst be "string".

RB IN NNP VBZ DT VBG NN `` NN '' , RB
1
*0*else if hint is the string value "number", then

VB NNP VB `` NN '' .
1
*1*let tryfirst be "number".

RB , VB DT NN NN .
1
*0*else, throw a typeerror exception.

IN DT NNS VBD VBN TO DT NN NN , VB NNP VB `` '' .
1
*0*if no arguments were passed to this function invocation, let s be "".

IN DT VBZ JJ CC NNP ( NNP ) VBZ JJ , VB NNP ( NNP ) .
1
*1*if newtarget is undefined and type(value) is symbol, return symboldescriptivestring(value).

IN DT VBZ JJ , JJ NNP .
1
*0*if newtarget is undefined, return s.

NN . NNP ( NNP , . NNP ( NN , `` NN JJ NN '' ) ) .
1
*0*return ? stringcreate(s, ? getprototypefromconstructor(newtarget, "%stringprototype%")).

VB NNP VB DT NN VBG DT NNS VBN TO DT NN .
1
*0*let codeunits be a list containing the arguments passed to this function.

NN NNP TO DT NN IN NNS .
1
*1*append nextcu to the end of elements.

VB NNS VB DT NN VBG DT NNS VBN TO DT NN .
1
*0*let codepoints be a list containing the arguments passed to this function.

VB NNP VB DT NN IN NNS IN NNS .
1
*0*let length be the number of elements in codepoints.

IN NNP ( NNP , NNP ( NNP ) ) VBZ JJ , VB DT NN NN .
1
*1*if samevalue(nextcp, tointeger(nextcp)) is false, throw a rangeerror exception.

VB DT NNS IN DT NN IN NNP TO DT NN IN NNS .
1
*1*append the elements of the utf16encoding of nextcp to the end of elements.

VB NNP VB DT NN NN IN DT IN DT NNS VBN TO DT NN , VBG IN DT JJ NN . IN JJR IN CD NNS VBD VBN , DT NN VBZ JJ .
1
*0*let substitutions be a list consisting of all of the arguments passed to this function, starting with the second argument. if fewer than two arguments were passed, the list is empty.

VB NNP VB . NNP ( . NNP ( NNP , `` JJ '' ) ) .
1
*0*let raw be ? toobject(? get(cooked, "raw")).

IN NNS VBP CD , VBP DT JJ NN .
1
*0*if literalsegments ≤ 0, return the empty string.

VB NNP VB . VBG ( . NNP ( NNP , NNP ) ) .
1
*1*let nextseg be ? tostring(? get(raw, nextkey)).

IN NNP VBD CD JJ NNS , RB
1
*1*if nextindex + 1 = literalsegments, then

VB DT NN NN WP$ NN NNS VBP , IN NN , DT NNS IN DT NN NNP . IN NNP VBZ DT NNS , DT JJ NN VBZ VBN .
1
*2*return the string value whose code units are, in order, the elements in the list stringelements. if stringelements has no elements, the empty string is returned.

IN NNP CC NN : NNP , VB NNP VB NNP NNP NNP NNP .
1
*1*if nextindex &lt; numberofsubstitutions, let next be substitutions[nextindex].

RB , VB NNP VB DT JJ NN .
1
*1*else, let next be the empty string.

IN NNP CC NN : CD CC NNP NNP NNP , VBP DT JJ NN .
1
*0*if position &lt; 0 or position ≥ size, return the empty string.

VB DT VBG NN IN NN CD , VBG CD NN NN IN NNP , RB DT NN NN IN NN NNP .
1
*0*return the string value of length 1, containing one code unit from s, namely the code unit at index position.

IN NNP CC NN : CD CC NNP NNP NNP , NN NN .
1
*0*if position &lt; 0 or position ≥ size, return nan.

VB DT NN IN NN NN , WP$ NN VBZ DT JJ NN IN DT NN NN IN NN NNP IN DT NN NNP .
1
*0*return a value of number type, whose value is the numeric value of the code unit at index position within the string s.

IN NNP CC NN : CD CC NNP CC NN : CD CC NNP NNP NNP , NN NNP .
1
*0*if first &lt; 0xd800 or first &gt; 0xdbff or position+1 = size, return first.

VB NNP VB DT NN WP$ NNS VBP DT NNS VBN TO DT NN .
1
*0*let args be a list whose elements are the arguments passed to this function.

IN NNP VBZ JJ , VB NNP VB NNP , RB VB NNP VB . NNP ( NNP ) .
1
*0*if endposition is undefined, let pos be len, else let pos be ? tointeger(endposition).

IN NNP VBZ JJR IN CD , NN JJ .
1
*0*if start is less than 0, return false.

IN EX VBZ DT NN NNP RB JJR IN NNP JJ IN NNP NNP NNP VBZ RB JJR IN NNP , CC IN DT JJ NNS NNP JJR IN NNP , DT NN NN IN NN NNP IN NNP VBZ DT JJ IN DT NN NN IN NN NNP IN NNP , NN JJ : CC IN EX VBZ DT JJ NN NNP , NN JJ .
1
*0*if there exists any integer k not smaller than start such that k + searchlen is not greater than len, and for all nonnegative integers j less than searchlen, the code unit at index k+j within s is the same as the code unit at index j within searchstr, return true; but if there is no such integer k, return false.

VB DT JJS JJ NN NNP RB JJR IN NNP JJ IN NNP VBZ RB JJR IN NNP , CC IN DT JJ NNS NNP JJR IN NNP , DT NN NN IN NN NNP IN NNP VBZ DT JJ IN DT NN NN IN NN NNP IN NNP : CC IN EX VBZ DT JJ NN NNP , VBP DT NN NNP .
1
*0*return the smallest possible integer k not smaller than start such that k+searchlen is not greater than len, and for all nonnegative integers j less than searchlen, the code unit at index k+j within s is the same as the code unit at index j within searchstr; but if there is no such integer k, return the value -1.

VB NNP VB . NNP ( NNP ) . ( IN NNP VBZ JJ , DT NN VBZ DT NN RB .
1
*0*let numpos be ? tonumber(position). (if position is undefined, this step produces the value nan.)

VB DT JJS JJ JJ NN NNP RB JJR IN NNP JJ IN NNP VBZ RB JJR IN NNP , CC IN DT JJ NNS NNP JJR IN NNP , DT NN NN IN NN NNP IN NNP VBZ DT JJ IN DT NN NN IN NN NNP IN NNP : CC IN EX VBZ DT JJ NN NNP , VBP DT NN NNP .
1
*0*return the largest possible nonnegative integer k not larger than start such that k+searchlen is not greater than len, and for all nonnegative integers j less than searchlen, the code unit at index k+j within s is the same as the code unit at index j within searchstr; but if there is no such integer k, return the value -1.

IN NNP VBZ RB JJ CC NNP VBZ JJ , VB NNP VB `` JJ '' .
1
*0*if form is not present or form is undefined, let form be "nfc".

IN NNP VBZ RB CD IN `` JJ '' , `` NN '' , `` NN '' , CC `` JJ '' , VB DT NN NN .
1
*0*if f is not one of "nfc", "nfd", "nfkc", or "nfkd", throw a rangeerror exception.

VB NNP VB DT VBG NN WDT VBZ DT NN IN VBG NNP IN DT NN NN VBN IN NNP IN VBN IN NN :  .
1
*0*let ns be the string value that is the result of normalizing s into the normalization form named by f as specified in https://unicode.org/reports/tr15/.

IN NNP VBZ NNP , VBP DT NN NN .
1
*0*if n is +∞, throw a rangeerror exception.

VB NNP VB DT VBG NN WDT VBZ VBN IN NNP NNS IN NNP VBD RB . IN NNP VBZ CD , NNP VBZ DT JJ NN .
1
*0*let t be the string value that is made from n copies of s appended together. if n is 0, t is the empty string.

VB NNP VB . NNP ( NNP , NNP NNP VB ) .
1
*1*let replacer be ? getmethod(searchvalue, @@replace).

NN VBG IN DT JJ NN IN NNP CC VB NNP VB DT NN IN NNP IN DT JJ NN NN IN DT JJ NN CC VB NNP VB NNP . IN DT NNS IN NNP VBD VBN , VB NNP .
1
*0*search string for the first occurrence of searchstring and let pos be the index within string of the first code unit of the matched substring and let matched be searchstring. if no occurrences of searchstring were found, return string.

VB NNP VB . NNP ( NNP , VBD , NNP NNP , NNP , NNP NNP ) .
1
*1*let replvalue be ? call(replacevalue, undefined, « matched, pos, string »).

VB NNP VB NNP ( NNP , NNP , NNP , NNP , VBD , NNP ) .
1
*1*let replstr be getsubstitution(matched, string, pos, captures, undefined, replacevalue).

VB NNP VB NNP NNP DT NN IN JJ NNS IN NNP .
1
*0*let tailpos be pos + the number of code units in matched.

VB NNP VB DT NN IN DT JJ NNP NN NNS IN NNP , NNP , CC DT VBG NN IN VBG VBG IN NN NNP . IN NNP VBZ CD , DT JJ NN IN DT NN MD VB DT JJ NN .
1
*0*let newstring be the string-concatenation of the first pos code units of string, replstr, and the trailing substring of string starting at index tailpos. if pos is 0, the first element of the concatenation will be the empty string.

NN : NNS VBZ DT RB JJ NN IN NNS .
1
*0*assert: captures is a possibly empty list of strings.

NN NNS TO . NNP ( NNP ) .
1
*1*set namedcaptures to ? toobject(namedcaptures).

VB NNP VB DT VBG NN VBN IN NNP IN VBG NN NN NNS IN NNP TO NNP IN VBG NNS IN VBN IN JJ CD DT $ NNS VBP VBN JJ , CC , RB JJ DT NN VBZ VBN , DT JJ NN NN VBZ RB JJ TO JJ NNS .
1
*0*let result be the string value derived from replacement by copying code unit elements from replacement to result while performing replacements as specified in table 48. these $ replacements are done left-to-right, and, once such a replacement is performed, the new replacement text is not subject to further replacements.

VB DT NN NN VBG NNP JJ NNS IN NNP VBG IN DT NN IN NN NNP .
1
*0*return the string value containing span consecutive elements from s beginning with the element at index from.

VB NNP VB NNP ( NNP , CD , NNP ) .
1
*1*let z be splitmatch(s, 0, r).

IN NNP VBZ RB JJ , JJ NNP .
1
*1*if z is not false, return a.

RB NNP VBZ DT NN NN NNP NNP ,
1
*1*else e is an integer index ≤ s,

IN NNP NNP NNP , VB NNP VB NNP .
1
*2*if e = p, let q be q+1.

IN NNP CC NN : NNP , NN JJ .
1
*0*if q+r &gt; s, return false.

IN EX VBZ DT NN NNP IN CD ( JJ ) CC NNP ( JJ ) JJ IN DT NN NN IN NN NNP IN NNP VBZ JJ IN DT NN NN IN NN NNP IN NNP , NN JJ .
1
*0*if there exists an integer i between 0 (inclusive) and r (exclusive) such that the code unit at index q+i within s is different from the code unit at index i within r, return false.

IN NNP VBZ JJR IN NNP , NN JJ .
1
*0*if searchlength+start is greater than len, return false.

VB DT NN NN WP$ NN VBZ NNP : NN , VBG NN NNS IN NNP , RB DT NN NNS IN NNS NNP IN NNP : CD , IN VBG NN .
1
*0*return the string value whose length is to - from, containing code units from s, namely the code units with indices from through to - 1, in ascending order.

VB NNP VB DT NN VBG IN NN DT NN NNS IN VBN IN CD IN NNP , VBG IN DT JJ NN IN NNP .
1
*0*let cplist be a list containing in order the code points as defined in 6.1.4 of s, starting at the first element of s.

VB NNP VB DT NN WRB DT NNS VBP DT NN IN NN ( NNP ) , VBG TO DT NN NN NN NN NN .
1
*0*let culist be a list where the elements are the result of tolowercase(cplist), according to the unicode default case conversion algorithm.

VB NNP VB DT NN NN WP$ NNS VBP DT NN IN DT NN NNS IN NNP .
1
*0*let l be the string value whose elements are the utf16encoding of the code points of culist.

VB NNP VB DT VBG NN WDT VBZ DT NN IN NNP IN DT VBG CC VBG JJ NN VBN . DT NN IN JJ NN VBZ DT NN IN NN CC NN . WRB VBG IN DT JJ NN NN VBZ IN JJ JJ NN NNP NN NNP ( NNP NNP NNP ) , JJ NN NNS VBP VBN IN JJ VBD NN NN NNS IN VBN IN CD .
1
*0*let t be the string value that is a copy of s with both leading and trailing white space removed. the definition of white space is the union of whitespace and lineterminator. when determining whether a unicode code point is in unicode general category “space_separator” (“zs”), code unit sequences are interpreted as utf-16 encoded code point sequences as specified in 6.1.4.

NN : NNP ( VBG ) VBZ VBG .
1
*0*assert: type(string) is string.

IN NNP CC NN : CD CC NNP CC NN : CD CC NNP NNP NNP , VB NNP VB DT VBG NN NN IN DT JJ NN NN NNP .
1
*0*if first &lt; 0xd800 or first &gt; 0xdbff or position+1 = len, let resultstring be the string value consisting of the single code unit first.

IN NNP CC NN : CD CC NNP CC NN : CD , VB NNP VB DT VBG NN NN IN DT JJ NN NN NNP .
1
*1*if second &lt; 0xdc00 or second &gt; 0xdfff, let resultstring be the string value consisting of the single code unit first.

RB , VB NNP VB DT NN IN DT NN NN NNP CC DT NN NN NNP .
1
*1*else, let resultstring be the string-concatenation of the code unit first and the code unit second.

VBN NNP . VB JJ NNP NNP NNP TO NNP NNP NNP .
1
*0*set o.[[STRINGITERATORNEXTINDEX]] to position + resultsize.

IN NNP VBZ CD , NN NNP ( NNP ) .
1
*0*if max is zero, return c(x).

VB NNP VB DT JJ NN NN WDT VBZ CD NN NN NNP CC VBZ DT JJ NNS WRB VBN :
1
*0*let d be an internal continuation closure that takes one state argument y and performs the following steps when evaluated:

IN NNP VBZ CD CC NNP POS NNP VBZ JJ TO NNP POS NNP , NN NN .
1
*1*if min is zero and y's endindex is equal to x's endindex, return failure.

IN NNP VBZ CD , VB NNP VB CD : RB VB NNP VB NNP .
1
*1*if min is zero, let min2 be zero; otherwise let min2 be min-1.

IN NNP VBZ JJ , VB NNP VB VBN : RB VB NNP VB NNP .
1
*1*if max is ∞, let max2 be ∞; otherwise let max2 be max-1.

NN NNP ( NNP , NNP , NNP , NNP , NNP , NNP , NNP , NNP ) CC VB PRP$ NN .
1
*1*call repeatmatcher(m, min2, max2, greedy, y, c, parenindex, parencount) and return its result.

VB NNP VB DT NN IN NNP POS NNP NN .
1
*0*let cap be a copy of x's captures list.

IN DT NN NNP IN VBZ NNP CC NN : NNP CC NNP NNP NNP , VBD NNP NNP NNP NNP TO VB .
1
*0*for each integer k that satisfies parenindex &lt; k and k ≤ parenindex+parencount, set cap[k] to undefined.

IN NNP VBZ RB CD , NN NNP ( NNP , NNP ) .
1
*0*if min is not zero, return m(xr, d).

NN NNP ( NNP ) CC VB NNP VB PRP$ NN .
1
*1*call c(x) and let z be its result.

NN NNP ( NNP , NNP ) CC VB PRP$ NN .
1
*1*call m(xr, d) and return its result.

NN NNP ( NNP , NNP ) CC VB NNP VB PRP$ NN .
1
*0*call m(xr, d) and let z be its result.

VB NNP VB DT NN IN NNS VBG DT JJ NNS : NN
1
*0*let a be a set of characters containing the sixty-three characters:      abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789_

IN DT NN NNP RB IN NN NNP WRB NNP ( NNP ) VBZ IN NNP , VB NNP TO NNP .
1
*0*for each character c not in set a where canonicalize(c) is in a, add c to u.

NN : IN NNP CC NNP VBP DT JJ , NNP VBZ JJ .
1
*0*assert: unless unicode and ignorecase are both true, u is empty.

VB DT NNS IN NN NNP TO VB NNP .
1
*0*add the characters in set u to set a.

IN NNP VBZ JJ CC NNP VBZ NNP , NN JJ .
1
*0*if e is -1 or e is inputlength, return false.

VB NNP VB DT NN IN . NNP ( ) .
1
*0*let wordchars be the result of ! wordcharacters().

IN NNP VBZ IN NNP , NN JJ .
1
*0*if c is in wordchars, return true.

VB DT JJ NN NN WDT VBZ CD NNS , DT NN NNP CC DT NN NNP , CC VBZ DT JJ NNS WRB VBN :
1
*0*return an internal matcher closure that takes two arguments, a state x and a continuation c, and performs the following steps when evaluated:

IN EX VBZ RB VB DT NN NNP IN VBN NNP JJ IN NNP ( NNP ) VBZ NNP , NN NN .
1
*2*if there does not exist a member a of set a such that canonicalize(a) is cc, return failure.

IN EX VBZ DT NN NNP IN VBN NNP JJ IN NNP ( NNP ) VBZ NNP , NN NN .
1
*2*if there exists a member a of set a such that canonicalize(a) is cc, return failure.

IN DT NN NN IN DT JJ NN NN VBZ DT JJ CC JJ NN VBG NN IN NNP , VBP DT NN IN VBG IN VBG TO NNP .
1
*1*if the file casefolding.txt of the unicode character database provides a simple or common case folding mapping for ch, return the result of applying that mapping to ch.

VB NNP VB DT VBG NN NN IN DT JJ NN NN NNP .
1
*1*let s be the string value consisting of the single code unit ch.

VB NNP VB DT JJ NN VBN IN IN IN VBG DT NN IN NN VBG NNP IN DT DT NN .
1
*1*let u be the same result produced as if by performing the algorithm for string.prototype.touppercase using s as the this value.

NN : NNP VBZ DT VBG NN .
1
*1*assert: u is a string value.

IN NNP VBZ RB VB IN DT JJ NN NN , NN NNP .
1
*1*if u does not consist of a single code unit, return ch.

VB NNP VB NNP POS JJ NN NN NN .
1
*1*let cu be u's single code unit element.

IN DT JJ NN IN NNP NNP CD CC DT JJ NN IN NNP CC NN : CD , NN NNP .
1
*1*if the numeric value of ch ≥ 128 and the numeric value of cu &lt; 128, return ch.

NN : NNP VBZ DT NN IN JJ NN NNS WDT VBZ JJ TO DT NN IN JJ NN NNS WDT VBZ DT JJ NN NN CC NN NNS VBN IN DT NNP NN NN CC VBZ JJ NN IN JJ CD CC JJ CD .
1
*0*assert: p is a list of unicode code points that is identical to a list of unicode code points that is a unicode property name or property alias listed in the “property name and aliases” column of table 51 or table 52.

NN : NNP VBZ DT NN IN JJ NN NNS WDT VBZ JJ TO DT NN IN JJ NN NNS WDT VBZ DT JJ , JJ JJ NN NN VBN IN DT NNP JJ NN NN NNP NN IN JJ CD .
1
*0*assert: p is a list of unicode code points that is identical to a list of unicode code points that is a canonical, unaliased unicode property name listed in the “canonical property name” column of table 51.

NN : NNP VBZ DT NN IN JJ NN NNS WDT VBZ JJ TO DT NN IN JJ NN NNS WDT VBZ DT NN NN CC NN NN NN IN JJ NN NNP VBN IN DT NNP NN NN CC VBZ JJ NN IN JJ CD CC JJ CD .
1
*0*assert: v is a list of unicode code points that is identical to a list of unicode code points that is a property value or property value alias for unicode property p listed in the “property value and aliases” column of table 53 or table 54.

VB DT JJ NN NN WDT VBZ CD NNS , DT NN NNP CC DT NN NNP , CC VBZ DT JJ NNS :
1
*0*return an internal matcher closure that takes two arguments, a state x and a continuation c, and performs the following steps:

IN NNP VBZ JJ , VB NNP ( NNP ) .
1
*1*if s is undefined, return c(x).

IN EX VBZ DT NN NNP IN CD ( JJ ) CC NNP ( JJ ) JJ IN NNP ( NNP NNP NNP NNP ) VBZ RB DT JJ NN NN IN NNP ( NNP NNP NNP NNP NNP NNP ) , JJ NN .
1
*1*if there exists an integer i between 0 (inclusive) and len (exclusive) such that canonicalize(s[i]) is not the same character value as canonicalize(input[g + i]), return failure.

NN : NNP CC NNP DT NN RB CD NN .
1
*0*assert: a and b each contain exactly one character.

VB DT NN VBG DT NNS VBD NNP IN NNP , NN .
1
*0*return the set containing all characters numbered i through j, inclusive.

IN NNP VBZ JJ CC NNP VBZ VBN , RB
1
*1*if patternisregexp is true and flags is undefined, then

IN NNP ( NNP , NNP ) VBZ JJ , JJ NNP .
1
*2*if samevalue(newtarget, patternconstructor) is true, return pattern.

IN NNP VBZ JJ , VB NNP VB NNP . VB JJ NNP NNP NNP .
1
*1*if flags is undefined, let f be pattern.[[ORIGINALFLAGS]].

VB NNP VB . NNP ( NNP , `` NN NN NN '' , NNP NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP NNP ) .
1
*0*let obj be ? ordinarycreatefromconstructor(newtarget, "%regexpprototype%", « [[REGEXPMATCHER]], [[ORIGINALSOURCE]], [[ORIGINALFLAGS]] »).

NN . NNP ( NNP , `` NN '' , NN ( JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ ) ) .
1
*0*perform ! definepropertyorthrow(obj, "lastindex", propertydescriptor { [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }).

IN NNP VBZ DT NN NN JJ IN `` JJ '' , `` NN '' , `` NN '' , `` NN '' , `` JJ '' , CC `` JJ '' CC IN PRP VBZ DT JJ NN NN RBR IN RB , VB DT NN NN .
1
*0*if f contains any code unit other than "g", "i", "m", "s", "u", or "y" or if it contains the same code unit more than once, throw a syntaxerror exception.

IN NNP VBZ `` JJ '' , VB NNP VB JJ : JJ VB NNP VB JJ .
1
*0*if f contains "u", let bmp be false; else let bmp be true.

NN NNP VBG DT NNS IN CD CC VBG DT IN PRP$ JJ NNS IN DT JJ NN NN NN . JJ NN VBZ RB VBN TO DT NNS . DT NN NN IN DT NN VBZ JJ NNP NNP , NNP NNP . IN DT NN IN VBG NNS DT NN , NN IN DT NN NN NN NNP NNP , NNP NNP CC VB DT NN RB . VB DT NN NN IN NNP VBD RB VB TO DT NN , IN DT NNS IN NNP VBD RB VBN IN DT NN , CC IN DT JJ NN NNS VBP .
1
*1*parse p using the grammars in 21.2.1 and interpreting each of its 16-bit elements as a unicode bmp code point. utf-16 decoding is not applied to the elements. the goal symbol for the parse is pattern[~u, ~n]. if the result of parsing contains a groupname, reparse with the goal symbol pattern[~u, +n] and use this result instead. throw a syntaxerror exception if p did not conform to the grammar, if any elements of p were not matched by the parse, or if any early error conditions exist.

VB NNP VB DT NN WP$ NNS VBP DT NN NN NNS IN NNP .
1
*1*let patterncharacters be a list whose elements are the code unit elements of p.

NN NNP VBG DT NNS IN CD CC VBG NNP IN JJ VBD JJ NN NNS ( CD ) . DT NN NN IN DT NN VBZ JJ NNP NNP , NNP NNP . VB DT NN NN IN NNP VBD RB VB TO DT NN , IN DT NNS IN NNP VBD RB VBN IN DT NN , CC IN DT JJ NN NNS VBP .
1
*1*parse p using the grammars in 21.2.1 and interpreting p as utf-16 encoded unicode code points (6.1.4). the goal symbol for the parse is pattern[+u, +n]. throw a syntaxerror exception if p did not conform to the grammar, if any elements of p were not matched by the parse, or if any early error conditions exist.

VB NNP VB DT NN WP$ NNS VBP DT NN NNS VBG IN VBG JJ NN TO NNP POS NN IN NNS .
1
*1*let patterncharacters be a list whose elements are the code points resulting from applying utf-16 decoding to p's sequence of elements.

VBN NNP . VB JJ NNP NNP NNP TO DT JJ NN WDT VBZ DT JJ NN IN NNP IN VBG DT NNS VBD IN CD VBG NNS IN DT NN POS NN IN NN NNS CC NNP IN DT NN NNS .
1
*0*set obj.[[REGEXPMATCHER]] to the internal procedure that evaluates the above parse of p by applying the semantics provided in 21.2.2 using patterncharacters as the pattern's list of sourcecharacter values and f as the flag parameters.

VB NNP VB DT NN IN DT NN IN DT NN NNP NNP NNP ( JJ NNP NNP NNP IN NNP VBZ `` JJ '' ) NN TO NNP VBN IN JJ VBD JJ NN NNS ( CD ) , IN WDT JJ NN NNS VBP VBN IN VBN IN . NNP MD CC MD RB VB JJ TO NNP : RB , DT JJ NN WDT MD VB IN VBG NNP IN DT NN NNP NNP NNP ( JJ NNP NNP NNP IN NNP VBZ `` JJ '' ) MD VB RB TO DT JJ NN VBN IN DT JJ NN POS NNP NNP NNP NNP NNP JJ NN . JJ VBZ TO DT JJ NN VBG DT JJ NNS IN NNP CC NNP MD VB JJ NNS .
1
*0*let s be a string in the form of a pattern[~u] (pattern[+u] if f contains "u") equivalent to p interpreted as utf-16 encoded unicode code points (6.1.4), in which certain code points are escaped as described below. s may or may not be identical to p; however, the internal procedure that would result from evaluating s as a pattern[~u] (pattern[+u] if f contains "u") must behave identically to the internal procedure given by the constructed object's [[REGEXPMATCHER]] internal slot. multiple calls to this abstract operation using the same values for p and f must produce identical results.

DT NN NNS  CC DT NN VBG IN DT NN MD VB VBN IN NNP IN JJ TO VB IN DT NN IN ``  '' , NNP , ``  '' , CC NNP MD VB VBN ( IN DT JJ JJ NN ) IN DT JJ WDT VBZ RB TO DT VBN JJ NN . IN NN , IN NNP VBZ ``  '' , RB NNP MD VB ``  '' CC `` JJ '' , IN JJ NNS , CC RB ``  '' , IN  VBN IN NNP MD VB VBN IN DT NN RB IN DT JJ . IN NNP VBZ DT JJ NN , DT NN MD VB VBN IN VBG NNP VB `` ( . : ) '' .
1
*0*the code points / or any lineterminator occurring in the pattern shall be escaped in s as necessary to ensure that the string-concatenation of "/", s, "/", and f can be parsed (in an appropriate lexical context) as a regularexpressionliteral that behaves identically to the constructed regular expression. for example, if p is "/", then s could be "\/" or "\u002f", among other possibilities, but not "/", because /// followed by f would be parsed as a singlelinecomment rather than a regularexpressionliteral. if p is the empty string, this specification can be met by letting s be "(?:)".

IN NNP ( NNP ) VBZ JJ NN CC NN , VB DT NN NN .
1
*1*if type(result) is neither object or null, throw a typeerror exception.

IN NNP VBZ JJ CC NNP VBZ JJ , VBN NNP TO CD .
1
*0*if global is false and sticky is false, set lastindex to 0.

IN NNP VBZ `` JJ '' , VB NNP VB JJ , JJ NN NNP VB JJ .
1
*0*if flags contains "u", let fullunicode be true, else let fullunicode be false.

NN , IN VBN VBZ JJ
1
*0*repeat, while matchsucceeded is false

IN NNP VBZ NN , RB
1
*1*if r is failure, then

VBN NN TO NNP ( NNP , NNP , NNP ) .
1
*2*set lastindex to advancestringindex(s, lastindex, fullunicode).

NNP VBZ DT NN IN DT NNP NN NN , VBN IN NNP , VBN IN NNP . VB NNP VB DT JJS NN IN NNP WDT VBZ TO DT NN IN JJ NNP IN NNP . IN NNP VBZ JJR IN CC JJ TO DT NN IN NNS IN NNP , RB NNP VBZ DT NN IN JJ NNS IN NNP .
1
*1*e is an index into the input character list, derived from s, matched by matcher. let eutf be the smallest index into s that corresponds to the character at element e of input. if e is greater than or equal to the number of elements in input, then eutf is the number of code units in s.

VB NNP VB DT NN IN NNS IN NNP POS NNP NN . ( DT VBZ DT JJ NN IN CD POS NNP .
1
*0*let n be the number of elements in r's captures list. (this is the same value as 21.2.2.1's ncapturingparens.)

NN : NNP CC NN : JJ .
1
*0*assert: n &lt; 232-1.

VB NNP VB . NNP ( NNP NNP CD ) .
1
*0*let a be ! arraycreate(n + 1).

NN : DT NN IN NNP POS `` NN '' NN VBZ NNP NNP CD .
1
*0*assert: the value of a's "length" property is n + 1.

VB NNP VB DT JJ NN ( NN . DT NN IN NNP IN VBN NNP JJ CC VBN NNP JJ ) .
1
*0*let matchedsubstr be the matched substring (i.e. the portion of s between offset lastindex inclusive and offset e exclusive).

IN NNP VBZ DT NN , RB
1
*0*if r contains any groupname, then

NN . NNP ( NNP , `` NNS '' , NNP ) .
1
*0*perform ! createdataproperty(a, "groups", groups).

IN DT NN NNP JJ IN NNP CC NN : CD CC NNP NNP NNP , VBP
1
*0*for each integer i such that i &gt; 0 and i ≤ n, do

VB NNP VB NNP NN IN NNP POS NNP NN .
1
*1*let capturei be ith element of r's captures list.

VB NNP VB DT NN NN WP$ NN NNS VBP DT NN IN DT NN NNS IN NNP .
1
*2*let capturedvalue be the string value whose code units are the utf16encoding of the code points of capturei.

NN : NNP VBZ DT NN IN JJ NNS .
1
*2*assert: capturei is a list of code units.

VB NNP VB DT VBG NN NN IN DT NN NNS IN NNP .
1
*2*let capturedvalue be the string value consisting of the code units of capturei.

IN DT NNP NN IN NNP VBD VBN IN DT NN , RB
1
*1*if the ith capture of r was defined with a groupname, then

VB NNP VB DT NN IN DT JJ NN .
1
*2*let s be the stringvalue of the corresponding regexpidentifiername.

NN : NN VBZ DT NN JJ IN NN .
1
*0*assert: index is an integer such that 0≤index≤253-1.

IN NNP , NN NN .
1
*3*if n=0, return null.

NN , IN NNP VBZ JJ
1
*0*repeat, while done is false

VB NNP VB VBN ( NNP : CD , CD ) .
1
*1*let ncaptures be max(ncaptures - 1, 0).

VB NNP VB VBN ( NN ( NNP , NNP ) , CD ) .
1
*1*let position be max(min(position, lengths), 0).

VB NNS VB . NNP ( NNP , `` NNS '' ) .
1
*1*let namedcaptures be ? get(result, "groups").

VB NNP VB VBN NNP NNP .
1
*2*let replacerargs be « matched ».

NN IN NN NN DT NNS IN NNS TO DT NN IN DT NN NNP .
1
*2*append in list order the elements of captures to the end of the list replacerargs.

JJ NNP CC NNP TO NNP .
1
*2*append position and s to replacerargs.

NN VBZ IN DT JJ NN IN NNP .
1
*3*append namedcaptures as the last element of replacerargs.

VB NNP VB . NNP ( NNP , VBD , NNP ) .
1
*2*let replvalue be ? call(replacevalue, undefined, replacerargs).

VB NNP VB NNP ( NNP , NNP , NNP , NNP , NNP , NNP ) .
1
*2*let replacement be getsubstitution(matched, s, position, captures, namedcaptures, replacevalue).

NN : NN MD RB RB VB NNS . IN PRP VBZ , PRP VBZ DT NN IN DT JJ NN NN CC NN IN DT NN VBD JJ TO VB DT JJ NN CC JJ NNS IN NNP . IN JJ NNS , DT JJ NN VBZ VBN .
1
*2*note: position should not normally move backwards. if it does, it is an indication of an ill-behaving regexp subclass or use of an access triggered side-effect to change the global flag or other characteristics of rx. in such cases, the corresponding substitution is ignored.

VB NNP VB DT NN IN DT JJ NN IN NNP , DT NN IN NNP VBG IN DT NN NNS IN NNP ( NN ) IN TO NNP ( JJ ) , CC NNP .
1
*2*let accumulatedresult be the string-concatenation of the current value of accumulatedresult, the substring of s consisting of the code units from nextsourceposition (inclusive) up to position (exclusive), and replacement.

VB DT NN IN NNP CC DT NN IN NNP VBG IN DT NN NNS IN NNP ( NN ) RP IN DT JJ NN NN IN NNP ( JJ ) .
1
*0*return the string-concatenation of accumulatedresult and the substring of s consisting of the code units from nextsourceposition (inclusive) up through the final code unit of s (inclusive).

IN NNP ( NNP , CD ) VBZ JJ , RB
1
*0*if samevalue(previouslastindex, 0) is false, then

RB , VB NNP VB DT NN IN NNP CC `` NN '' .
1
*0*else, let newflags be the string-concatenation of flags and "y".

VB NNP VB . NNP ( NNP , NNP NNP , NNP NNP ) .
1
*0*let splitter be ? construct(c, « rx, newflags »).

NN , IN NNP CC NN : VB
1
*0*repeat, while q &lt; size

IN NNP VBZ JJ , VB NNP VB NNP ( NNP , NNP , NNP ) .
1
*1*if z is null, let q be advancestringindex(s, q, unicodematching).

IN NNP NNP NNP , VB NNP VB NNP ( NNP , NNP , NNP ) .
1
*2*if e = p, let q be advancestringindex(s, q, unicodematching).

NN , IN NNP NNP NNP ,
1
*3*repeat, while i ≤ numberofcaptures,

IN NNP VBZ RB JJ , VB JJ : RB NN JJ .
1
*0*if match is not null, return true; else return false.

VB NNP VB . VBG ( . NNP ( NNP , `` NN '' ) ) .
1
*0*let pattern be ? tostring(? get(r, "source")).

VB NNP VB DT NN IN ``  '' , NNP , ``  '' , CC NNP .
1
*0*let result be the string-concatenation of "/", pattern, "/", and flags.

NN . NNP ( CD , NNP ) .
1
*0*return ! arraycreate(0, proto).

VB NNP VB . NNP ( CD , NNP ) .
1
*0*let array be ! arraycreate(0, proto).

IN NNP ( NNP ) VBZ RB NN , RB
1
*0*if type(len) is not number, then

VB NNP VB NNP ( NNP , `` CD '' , NNP ) .
1
*1*let definestatus be createdataproperty(array, "0", len).

VB NNP VB DT JJ NN VBG DT NN NNS IN NN .
1
*0*let items be a zero-origined list containing the argument items in order.

NN : DT NN IN NNP POS NN NN VBZ NNP .
1
*0*assert: the value of array's length property is numberofargs.

VB NNP VB NNP ( NNP , NNP , NNP NNP , NNP NNP ) .
1
*3*let mappedvalue be call(mapfn, t, « nextvalue, k »).

NN : NNP VBZ RB DT JJ RB IN PRP VBZ DT JJ NN .
1
*0*note: items is not an iterable so assume it is an array-like object.

VB NNP VB DT NN WP$ JJ NN VBZ NNP CC WP$ JJ NNS VBP , IN VBN TO JJ NN , DT NNS WDT VBD VBN TO DT NN NN .
1
*0*let items be a list whose first element is o and whose subsequent elements are, in left to right order, the arguments that were passed to this function invocation.

RB NNP VBZ VBN IN DT JJ NN RB IN NN ,
1
*1*else e is added as a single item rather than spread,

IN NNP , VB DT NN NN .
1
*2*if n≥253-1, throw a typeerror exception.

VB JJ VB . NNP ( NNP , NNP NNP JJ ) .
1
*0*let spreadable be ? get(o, @@isconcatspreadable).

VB NNP VB DT NN IN . NNP ( NNP , . NNP ( NNP ) ) .
1
*1*let elementk be the result of ? get(o, ! tostring(k)).

IN NNP VBZ JJ , VB NNP VB VBN : JJ NN NNP VB NNP .
1
*1*if n is -0, let k be +0; else let k be n.

IN NNP VBZ JJ , VB NNP VB DT JJ NN `` , '' .
1
*0*if separator is undefined, let sep be the single-element string ",".

IN NNP CC NN : CD , VB NNP VB DT NN IN NNP CC NNP .
1
*1*if k &gt; 0, let r be the string-concatenation of r and sep.

IN NNP VBZ JJ CC JJ , VB NNP VB DT JJ NN : RB , VB NNP VB . NNP ( NNP ) .
1
*1*if element is undefined or null, let next be the empty string; otherwise, let next be ? tostring(element).

IN NNP VBZ JJ , VB NNP VB . NNP ( NNP ) : JJ NN NNP VB NNP .
1
*0*if fromindex is present, let n be ? tointeger(fromindex); else let n be len-1.

IN NNP VBZ JJ , VB NNP VB VBN : JJ NN NNP VB VBN ( NNP , NNP : CD ) .
1
*1*if n is -0, let k be +0; else let k be min(n, len - 1).

NN , IN NNP VBZ JJ CC NNP CC NN : NNP
1
*1*repeat, while kpresent is false and k &lt; len

NN , IN NNP VBZ JJ CC NNP NNP CD
1
*1*repeat, while kpresent is false and k ≥ 0

VB NNP VB NN ( 2 ) .
1
*0*let middle be floor(len/2).

VB NNP VB NNP : NNP : CD .
1
*1*let upper be len - lower - 1.

IN NNS VBZ JJ CC NNS VBZ JJ , RB
1
*1*if lowerexists is true and upperexists is true, then

RB DT NNS CC NNS VBP JJ ,
1
*1*else both lowerexists and upperexists are false,

DT NN VBZ VBN .
1
*2*no action is required.

VB NNP VB . NNP ( NNP , `` CD '' ) .
1
*0*let first be ? get(o, "0").

IN NNP CC NNP VBP DT JJ , VB NNP .
1
*0*if x and y are both undefined, return +0.

VB NNP VB . NNP ( . NNP ( NNP , VBD , NNP NNP , NNP NNP ) ) .
1
*1*let v be ? tonumber(? call(comparefn, undefined, « x, y »)).

IN DT NN IN JJ NNS VBZ CD , RB
1
*0*if the number of actual arguments is 0, then

RB IN DT NN IN JJ NNS VBZ CD , RB
1
*0*else if the number of actual arguments is 1, then

VB NNP VB NNP : NNP .
1
*1*let actualdeletecount be len - actualstart.

VB NNP VB DT NN IN JJ NNS CC CD .
1
*1*let insertcount be the number of actual arguments minus 2.

VB NNP VB VBN ( NN ( NNP , CD ) , NNP : NNP ) .
1
*1*let actualdeletecount be min(max(dc, 0), len - actualstart).

VB NNP VB DT NN WP$ NNS VBP , IN VBN TO JJ NN , DT NN IN DT JJ NN NN VBG IN DT JJ NN . DT NN VBZ JJ IN JJR IN CD NNS VBD VBN .
1
*0*let items be a list whose elements are, in left to right order, the portion of the actual argument list starting with the third argument. the list is empty if fewer than three arguments were passed.

NN , IN NNP CC NN : ( NNP : NN
1
*1*repeat, while k &lt; (len - actualdeletecount)

NN , IN NNP CC NN : ( NNP : NNP NNP NNP
1
*1*repeat, while k &gt; (len - actualdeletecount + itemcount)

RB IN NNP CC NN : NNP , RB
1
*0*else if itemcount &gt; actualdeletecount, then

VB NNP VB ( NNP : NN ) .
1
*1*let k be (len - actualdeletecount).

NN . NNP ( NNP , `` NN '' , NNP : NNP NNP NNP , JJ ) .
1
*0*perform ? set(o, "length", len - actualdeletecount + itemcount, true).

VB NNP VB DT NN NN IN DT JJ NN NN IN DT NN NN POS JJ NN ( DT VBZ VBN IN DT JJ NN ) .
1
*0*let separator be the string value for the list-separator string appropriate for the host environment's current locale (this is derived in an implementation-defined way).

IN NNP VBZ RB JJ CC JJ , RB
1
*1*if nextelement is not undefined or null, then

VB NNP VB . VBG ( . NNP ( NNP , `` VBG '' ) ) .
1
*2*let s be ? tostring(? invoke(nextelement, "tolocalestring")).

IN NNP ( NNP ) VBZ JJ , VB NNP VB DT JJ NN NN VBG NN .
1
*0*if iscallable(func) is false, let func be the intrinsic function %objproto_tostring%.

VB NNP VB DT NN IN JJ NNS .
1
*0*let argcount be the number of actual arguments.

NN , IN NNP CC NN : CD ,
1
*1*repeat, while k &gt; 0,

IN NNP VBZ `` JJ '' , VB NNP ( NNP , RB ) .
1
*0*if itemkind is "key", return createiterresultobject(index, false).

NN : NN VBZ RB DT JJ RB IN PRP VBZ RB DT JJ NN .
1
*0*note: source is not an iterable so assume it is already an array-like object.

VB NNP TO DT NN IN DT NN NNP .
1
*2*append nextvalue to the end of the list values.

VB NNP VB DT NN .
1
*0*let o be this value.

NN : DT NN MD VB VBN IN DT NN WDT VBZ DT JJ NN IN DT NN NNS .
1
*1*note: the copying must be performed in a manner that preserves the bit-level encoding of the source data.

NN VBN IN CD .
1
*2*increase captured by 1.

NN : NN VBZ DT JJ NN NNP NNP NNP JJ NN . IN PRP VBZ RB , DT NN IN CD NNS .
1
*0*assert: typedarray has a [[TYPEDARRAYNAME]] internal slot. if it does not, the definition in 22.2.3.23.1 applies.

IN DT NNP ( NNP ) CC NNP ( NNP ) VBP JJ , RB
1
*0*if both issharedarraybuffer(srcbuffer) and issharedarraybuffer(targetbuffer) are true, then

IN NNP . VB JJ NNP NNP NNP CC NNP . VB JJ NNP NNP NNP VBP DT JJ VBN NNS NN NNS , VB NNP VB JJ : JJ NN NNP VB JJ .
1
*1*if srcbuffer.[[ARRAYBUFFERDATA]] and targetbuffer.[[ARRAYBUFFERDATA]] are the same shared data block values, let same be true; else let same be false.

RB , VB NNP VB NNP ( NNP , NNP ) .
1
*0*else, let same be samevalue(srcbuffer, targetbuffer).

VB NNP VB . NNP ( NNP , NNP , NNP , NN NN NN ) .
1
*1*let srcbuffer be ? clonearraybuffer(srcbuffer, srcbyteoffset, srcbytelength, %arraybuffer%).

NN : NN NN NN VBZ VBN TO VB NNP IN VBZ PRP VBN TO RB VB DT JJ NNS .
1
*1*note: %arraybuffer% is used to clone srcbuffer because is it known to not have any observable side-effects.

RB IN NNP CC NN : CD , RB
1
*0*else if count &gt; 0, then

VB NNP VB ( NNP NNP NNP ) VBP NNP .
1
*1*let srcbyteindex be (k × elementsize) + srcbyteoffet.

IN NNP VBZ JJ , VB NNP VB NNP : RB , VB NNP VB . NNP ( NNP ) .
1
*0*if end is undefined, let relativeend be srclength; else, let relativeend be ? tointeger(end).

VB NNP VB VBN ( NNP : NN , CD ) .
1
*0*let newlength be max(endindex - beginindex, 0).

VB NNP VB JJ NNP , NNP , NNP NNP .
1
*0*let argumentslist be « buffer, beginbyteoffset, newlength ».

NN . NNP ( NNP , NN , `` NN JJ NN '' , CD ) .
1
*0*return ? allocatetypedarray(constructorname, newtarget, "%typedarrayprototype%", 0).

NN : NNP ( NNP ) VBZ RB JJ .
1
*0*assert: type(length) is not object.

NN . NNP ( NNP , NN , `` NN JJ NN '' , NNP ) .
1
*0*return ? allocatetypedarray(constructorname, newtarget, "%typedarrayprototype%", elementlength).

VB NNP VB . NNP ( NN NN NN , NNP ) .
1
*0*let data be ? allocatearraybuffer(%arraybuffer%, bytelength).

VB NNP VB NN NN NN .
1
*1*let bufferconstructor be %arraybuffer%.

VB NNP VB . NNP ( NNP , NNP , NNP , NNP ) .
1
*1*let data be ? clonearraybuffer(srcdata, srcbyteoffset, bytelength, bufferconstructor).

NN : NNP ( NNP ) VBZ JJ CC NNP VBZ RB VB CC DT JJ NN NNP NNP NNP CC DT JJ NN NNP NNP NNP JJ NN .
1
*0*assert: type(object) is object and object does not have either a [[TYPEDARRAYNAME]] or an [[ARRAYBUFFERDATA]] internal slot.

NN : NNP VBZ RB DT JJ RB IN PRP VBZ RB DT JJ NN .
1
*0*note: object is not an iterable so assume it is already an array-like object.

VB NNP VB DT NN NN IN DT NN NN NN IN JJ CD IN NNP .
1
*0*let elementsize be the number value of the element size value in table 56 for constructorname.

VBN NNP . VB JJ NNP NNP NNP TO NNP  NNP .
1
*0*set o.[[ARRAYLENGTH]] to newbytelength / elementsize.

IN NNP VBZ DT NN IN DT JJ NN , RB
1
*0*if argumentlist is a list of a single number, then

IN NNP . VB JJ NNP NNP NNP CC NN : NNP VBD CD NN , VB DT NN NN .
1
*1*if newtypedarray.[[ARRAYLENGTH]] &lt; argumentlist[0], throw a typeerror exception.

VB NNP VB DT JJ NN VBN IN NN CD IN JJ CD IN NNP . VB JJ NNP NNP NNP .
1
*0*let defaultconstructor be the intrinsic object listed in column one of table 56 for exemplar.[[TYPEDARRAYNAME]].

IN DT NN ( JJ NNP NNP NNP NNP , NNP NNP NNP NNP NNP ) NNP WDT VBZ DT NN IN NNS , IN JJ JJ NN NN , VBP
1
*0*for each record { [[KEY]], [[VALUE]] } e that is an element of entries, in original key insertion order, do

NN . NNP ( NNP , NNP , NNP NNP . CC JJ NNP NNP NNP , NNP . VB JJ NNP NNP NNP , NNP NNP ) .
1
*2*perform ? call(callbackfn, t, « e.[[VALUE]], e.[[KEY]], m »).

VB NNP VB DT NN ( JJ NNP NNP NNP NNP , NNP NNP NNP NNP NNP ) WDT VBZ DT NN IN NNP NNP NNP NNP .
1
*1*let e be the record { [[KEY]], [[VALUE]] } that is the value of entries[index].

IN NNP VBZ `` JJ '' , VB NNP VB NNP . VB JJ NNP NNP NNP .
1
*2*if itemkind is "key", let result be e.[[KEY]].

RB IN NNP VBZ `` NN '' , VB NNP VB NNP . CC JJ NNP NNP NNP .
1
*2*else if itemkind is "value", let result be e.[[VALUE]].

VB NNP VB NNP ( NNP NNP . VB JJ NNP NNP NNP , NNP . CC JJ NNP NNP NNP NNP ) .
1
*3*let result be createarrayfromlist(« e.[[KEY]], e.[[VALUE]] »).

VB NNP VB NNP ( NNP , NNP , NNP NNP . CC JJ NNP NNP NNP NNP ) .
1
*1*let status be call(adder, set, « nextvalue.[[VALUE]] »).

IN DT NNP WDT VBZ DT NN IN NNS , IN JJ NN NN , VBP
1
*0*for each e that is an element of entries, in original insertion order, do

NN NNP ( NNP ( NNP NNP , NNP NNP ) , JJ ) .
1
*3*return createiterresultobject(createarrayfromlist(« e, e »), false).

VB NNP VB . NNP ( NNP , `` NN JJ NN '' , NNP NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP NNP ) .
1
*0*let obj be ? ordinarycreatefromconstructor(constructor, "%arraybufferprototype%", « [[ARRAYBUFFERDATA]], [[ARRAYBUFFERBYTELENGTH]], [[ARRAYBUFFERDETACHKEY]] »).

NN : NNP VBZ DT NN NN VBD CD .
1
*0*assert: bytelength is an integer value ≥ 0.

NN : NNP ( NNP ) VBZ JJ CC PRP VBZ VBN NNP NNP NNP NNP , NNP NNP NNP NNP NNP , CC NNP NNP NNP NNP NNP JJ NNS .
1
*0*assert: type(arraybuffer) is object and it has [[ARRAYBUFFERDATA]], [[ARRAYBUFFERBYTELENGTH]], and [[ARRAYBUFFERDETACHKEY]] internal slots.

IN NNP ( NNP . VB JJ NNP NNP NNP , NNP ) VBZ JJ , VB DT NN NN .
1
*0*if samevalue(arraybuffer.[[ARRAYBUFFERDETACHKEY]], key) is false, throw a typeerror exception.

NN NNP ( NN ) .
1
*0*return normalcompletion(null).

IN JJ VBZ JJ , VB DT NN IN DT NNS IN NNS .
1
*0*if islittleendian is false, reverse the order of the elements of rawbytes.

IN DT JJ NN NN IN NNP VBZ DT NN NN CD ( JJ NN NN NN ) , RB
1
*0*if the first code unit of type is the code unit 0x0055 (latin capital letter u), then

VB NNP VB DT JJ NNS IN NNP VBD CC VBD IN DT NN VBG NN IN DT JJ JJ JJ NN .
1
*1*let intvalue be the byte elements of rawbytes concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.

VB NNP VB DT JJ NNS IN NNP VBD CC VBD IN DT NN VBG NN IN DT JJ JJ CD POS JJ NN IN NN JJ NNP NN CD .
1
*1*let intvalue be the byte elements of rawbytes concatenated and interpreted as a bit string encoding of a binary little-endian 2's complement number of bit length elementsize × 8.

NN : IN NNS , NNP VBZ DT NN IN DT JJ CC JJ JJ NN IN DT JJ NN . DT NN VBZ DT JJ NN IN DT NN NN TO VB JJ NN IN NN IN JJ NN .
1
*1*note: in implementations, rawvalue is the result of a non-atomic or atomic read instruction on the underlying hardware. the nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.

VB NNP VB JJ ( JJ NN NNP NNP NN : NN , NNP NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : VB ) .
1
*1*let readevent be readsharedmemory { [[ORDER]]: order, [[NOTEAR]]: notear, [[BLOCK]]: block, [[BYTEINDEX]]: byteindex, [[ELEMENTSIZE]]: elementsize }.

NN VBZ NN NN ( JJ FW NNP NNP NN : NN , NNP NNP NNP NNP NN : NNP ) TO NNP . VB JJ NNP NNP NNP .
1
*1*append chosen value record { [[EVENT]]: readevent, [[CHOSENVALUE]]: rawvalue } to execution.[[CHOSENVALUES]].

RB , VB NNP VB DT NN IN NNP NN , IN NN , DT NNP NN IN NNS VBG IN NNP NNP NNP NNP .
1
*0*else, let rawvalue be a list of elementsize containing, in order, the elementsize sequence of bytes starting with block[byteindex].

VB NNP VB DT NN VBG DT CD NNS WDT VBP DT NN IN VBG NNP TO VB JJ NN NN VBG JJ NN TO JJS , NNS TO RB VB VBG NN . IN JJ VBZ JJ , DT NNS VBP VBN IN JJ JJ NN . RB , DT NNS VBP VBN IN JJ JJ NN . IN NNP VBZ JJ , NNS MD VB VBN TO DT NN VBN JJ JJ NN JJ JJ NN . DT NN MD RB VB DT JJ NN IN DT NN JJ JJ NN .
1
*1*let rawbytes be a list containing the 4 bytes that are the result of converting value to ieee 754-2008 binary32 format using “round to nearest, ties to even” rounding mode. if islittleendian is false, the bytes are arranged in big endian order. otherwise, the bytes are arranged in little endian order. if value is nan, rawbytes may be set to any implementation chosen ieee 754-2008 binary32 format not-a-number encoding. an implementation must always choose the same encoding for each implementation distinguishable nan value.

VB NNP VB DT NN VBG DT CD NNS WDT VBP DT JJ JJ NN NN NN IN NNP . IN JJ VBZ JJ , DT NNS VBP VBN IN JJ JJ NN . RB , DT NNS VBP VBN IN JJ JJ NN . IN NNP VBZ JJ , NNS MD VB VBN TO DT NN VBN JJ JJ NN JJ JJ NN . DT NN MD RB VB DT JJ NN IN DT NN JJ JJ NN .
1
*1*let rawbytes be a list containing the 8 bytes that are the ieee 754-2008 binary64 format encoding of value. if islittleendian is false, the bytes are arranged in big endian order. otherwise, the bytes are arranged in little endian order. if value is nan, rawbytes may be set to any implementation chosen ieee 754-2008 binary64 format not-a-number encoding. an implementation must always choose the same encoding for each implementation distinguishable nan value.

VB NNP VB DT NN NN IN DT NN NN VBN IN JJ CD IN NN NN NNP .
1
*1*let n be the number value of the element size specified in table 56 for element type type.

VB NNP VB DT JJ NN VBN IN DT NN NN NN IN JJ CD IN NN NN NNP .
1
*1*let convop be the abstract operation named in the conversion operation column in table 56 for element type type.

VB NNP VB DT NN VBG DT NNP JJ NN IN NNP . IN JJ VBZ JJ , DT NNS VBP VBN IN JJ JJ NN . RB , DT NNS VBP VBN IN JJ JJ NN .
1
*2*let rawbytes be a list containing the n-byte binary encoding of intvalue. if islittleendian is false, the bytes are ordered in big endian order. otherwise, the bytes are ordered in little endian order.

VB NNP VB DT NN VBG DT NNP JJ CD POS JJ NN IN NNP . IN JJ VBZ JJ , DT NNS VBP VBN IN JJ JJ NN . RB , DT NNS VBP VBN IN JJ JJ NN .
1
*2*let rawbytes be a list containing the n-byte binary 2's complement encoding of intvalue. if islittleendian is false, the bytes are ordered in big endian order. otherwise, the bytes are ordered in little endian order.

RB JJ ( JJ NN NNP NNP NN : NN , NNP NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : NNS ) TO NNP .
1
*1*append writesharedmemory { [[ORDER]]: order, [[NOTEAR]]: notear, [[BLOCK]]: block, [[BYTEINDEX]]: byteindex, [[ELEMENTSIZE]]: elementsize, [[PAYLOAD]]: rawbytes } to eventlist.

RB , VBD DT JJ NNS IN NNP IN NNP , IN NN , VBG IN NNP NNP NNP NNP .
1
*0*else, store the individual bytes of rawbytes into block, in order, starting at block[byteindex].

NN : IN NNS , NNP VBZ DT NN IN DT JJ , IN DT JJ , CC IN DT NN IN DT JJ NN IN DT JJ NN . DT NN VBZ DT JJ NN IN DT NN NN TO VB JJ NN IN NN IN JJ NN .
1
*0*note: in implementations, rawbytesread is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. the nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.

VB NNP VB JJ ( JJ NN NNP NNP NN : `` NN '' , NNP NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : NNS , NNP NNP NNP NNP NN : NNP ) .
1
*0*let rmwevent be readmodifywritesharedmemory { [[ORDER]]: "seqcst", [[NOTEAR]]: true, [[BLOCK]]: block, [[BYTEINDEX]]: byteindex, [[ELEMENTSIZE]]: elementsize, [[PAYLOAD]]: rawbytes, [[MODIFYOP]]: op }.

NN VBZ NN NN ( JJ FW NNP NNP NN : NN , NNP NNP NNP NNP NN : NN ) TO NNP . VB JJ NNP NNP NNP .
1
*0*append chosen value record { [[EVENT]]: rmwevent, [[CHOSENVALUE]]: rawbytesread } to execution.[[CHOSENVALUES]].

NN : NNS IN DT JJ NNS MD VB VBN NNP .
1
*0*note: side-effects of the above steps may have detached o.

VB NNP VB . NNP ( NNP , `` NN JJ NN '' , NNP NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP NNP ) .
1
*0*let obj be ? ordinarycreatefromconstructor(constructor, "%sharedarraybufferprototype%", « [[ARRAYBUFFERDATA]], [[ARRAYBUFFERBYTELENGTH]] »).

IN NNP VBZ DT NN NN , NN JJ .
1
*0*if bufferdata is a data block, return false.

IN NNP . VB JJ NNP NNP NNP CC NNP . VB JJ NNP NNP NNP VBP DT JJ VBN NNS NN NNS , VBP DT NN NN .
1
*0*if new.[[ARRAYBUFFERDATA]] and o.[[ARRAYBUFFERDATA]] are the same shared data block values, throw a typeerror exception.

NN NNP ( NNP , NNP , NNP , RB , `` JJ '' , NNP ) .
1
*0*return getvaluefrombuffer(buffer, bufferindex, type, false, "unordered", islittleendian).

NN NNP ( NNP , NNP , NNP , NNP , RB , `` JJ '' , NNP ) .
1
*0*return setvalueinbuffer(buffer, bufferindex, type, numbervalue, false, "unordered", islittleendian).

VB NNP VB . NNP ( NN , `` NN NN NN '' , NNP NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP NNP ) .
1
*0*let o be ? ordinarycreatefromconstructor(newtarget, "%dataviewprototype%", « [[DATAVIEW]], [[VIEWEDARRAYBUFFER]], [[BYTELENGTH]], [[BYTEOFFSET]] »).

NN . NNP ( NNP , NNP , JJ , `` NN '' ) .
1
*0*return ? getviewvalue(v, byteoffset, true, "int8").

NN . NNP ( NNP , NNP , JJ , `` JJ '' ) .
1
*0*return ? getviewvalue(v, byteoffset, true, "uint8").

NN . NNP ( NNP , NNP , JJ , `` NN '' , NNP ) .
1
*0*return ? setviewvalue(v, byteoffset, true, "int8", value).

NN . NNP ( NNP , NNP , JJ , `` JJ '' , NNP ) .
1
*0*return ? setviewvalue(v, byteoffset, true, "uint8", value).

IN NNP VBZ RB `` NN '' , VB DT NN NN .
1
*1*if typename is not "int32array", throw a typeerror exception.

IN NNP VBZ RB `` NN '' , `` NN '' , `` NN '' , `` NN '' , `` NN '' , CC `` JJ '' , VB DT NN NN .
1
*1*if typename is not "int8array", "uint8array", "int16array", "uint16array", "int32array", or "uint32array", throw a typeerror exception.

NN : NN VBZ DT JJ NN NNP NNP NNP JJ NN .
1
*0*assert: typedarray has a [[VIEWEDARRAYBUFFER]] internal slot.

NN : NNP VBD CD .
1
*0*assert: accessindex ≥ 0.

NN : NNP CC NNP VBP JJ JJ NNS IN DT NN IN NNP .
1
*0*assert: i and i+3 are valid byte offsets within the memory of block.

NN : NNP VBZ JJ IN CD .
1
*0*assert: i is divisible by 4.

VB DT NN WDT VBZ VBN IN DT NN ( NNP , NNP ) .
1
*0*return the waiterlist that is referenced by the pair (block, i).

NN : DT VBG NN VBZ RB IN DT JJ NN IN DT NN .
1
*0*assert: the calling agent is not in the critical section for any waiterlist.

NN IN DT NN VBZ IN DT JJ NN IN NNP , RB VB DT JJ NN IN NNP ( IN VBG DT JJ NN TO NN ) .
1
*0*wait until no agent is in the critical section for wl, then enter the critical section for wl (without allowing any other agent to enter).

NN : NNP VBZ RB IN DT NN IN NNS IN DT NN .
1
*0*assert: w is not on the list of waiters in any waiterlist.

VB NNP TO DT NN IN DT NN IN NNS IN NNP .
1
*0*add w to the end of the list of waiters in wl.

VB NNP IN DT NN IN NNS IN NNP .
1
*0*remove w from the list of waiters in wl.

VB NNP VB DT NN TO DT NN IN NNS IN NNP .
1
*0*let s be a reference to the list of waiters in wl.

NN , IN NNP CC NN : CD CC NNP VBZ RB DT JJ NN ,
1
*0*repeat, while c &gt; 0 and s is not an empty list,

JJ CD IN NNP .
1
*1*subtract 1 from c.

NN : NNP VBZ JJ TO NNP ( ) .
1
*0*assert: w is equal to agentsignifier().

NN NNP ( NNP ) CC VBP NNP IN RB TO NNP NNS , VBG DT JJ NN IN JJ DT NN IN DT NN WDT VBZ IN DT JJ NN VBZ VBN CC IN DT NN VBZ NN VBZ RB VBN . NNP MD VB RP RB IN DT NN VBD CC IN PRP VBD VBN RB IN DT NN VBG NNP ( NNP , NNP ) , CC RB IN DT JJ NNS IN DT .
1
*0*perform leavecriticalsection(wl) and suspend w for up to timeout milliseconds, performing the combined operation in such a way that a wakeup that arrives after the critical section is exited but before the suspension takes effect is not lost. w can wake up either because the timeout expired or because it was woken explicitly by another agent calling wakewaiter(wl, w), and not for any other reasons at all.

IN NNP VBD VBN RB IN DT NN VBG NNP ( NNP , NNP ) , VBP JJ .
1
*0*if w was woken explicitly by another agent calling wakewaiter(wl, w), return true.

VB DT NN NNP .
1
*0*wake the agent w.

NN NNP ( NNP , NNP , NNP , JJ , `` NN '' ) .
1
*0*return getvaluefrombuffer(buffer, indexedposition, elementtype, true, "seqcst").

VB JJ VB DT NN IN DT NNP NNP NNP NNP NNP NN IN DT VBG NN POS NN NN .
1
*0*let islittleendian be the value of the [[LITTLEENDIAN]] field of the surrounding agent's agent record.

VB NN VB DT JJ NN IN CD NN IN NN NNS NNS WDT VBZ DT JJ NN IN DT JJ NN VBZ JJ JJ TO NNS .
1
*0*let compareexchange denote a semantic function of two list of byte values arguments that returns the second argument if the first argument is element-wise equal to expectedbytes.

NN NNP ( NNP , NNP , NNP , NNP , NN ) .
1
*0*return getmodifysetvalueinbuffer(buffer, indexedposition, elementtype, replacement, compareexchange).

NN NNP ( NNP , NNP , NNP , NNP , JJ , `` NN '' ) .
1
*0*perform setvalueinbuffer(buffer, indexedposition, elementtype, v, true, "seqcst").

IN NNP VBZ JJ , VB NNP VB VBN , RB VB NNP VB VBN ( NNP , CD ) .
1
*0*if q is nan, let t be +∞, else let t be max(q, 0).

IN NNP VBZ RB JJ TO NNP , RB
1
*0*if v is not equal to w, then

NN : NNP VBZ RB IN DT NN IN NNS IN NNP .
1
*1*assert: w is not on the list of waiters in wl.

NN , IN NNP VBZ RB DT JJ NN ,
1
*0*repeat, while s is not an empty list,

VB NNP IN DT NN IN NNP .
1
*1*remove w from the front of s.

NN NNP VBD IN JJ VBD JJ NNS ( CD ) IN DT NN NN IN VBN IN NN . VB DT NN NN IN NNP VBZ RB DT JJ NN NN IN VBN IN DT NN .
1
*0*parse jtext interpreted as utf-16 encoded unicode points (6.1.4) as a json text as specified in ecma-404. throw a syntaxerror exception if jtext is not a valid json text as defined in that specification.

VB NNP VB DT NN IN `` ( `` , NNP , CC `` ) : '' .
1
*0*let scripttext be the string-concatenation of "(", jtext, and ");".

VB NNP VB DT NN IN NN CC VBG NNP IN IN PRP VBD DT NN NN IN DT JJ NN , CC VBG DT JJ NN IN NN VBN IN . DT JJ NN NNS VBD IN NN MD RB VB VBN IN DT NN .
1
*0*let completion be the result of parsing and evaluating scripttext as if it was the source text of an ecmascript script, but using the alternative definition of doublestringcharacter provided below. the extended propertydefinitionevaluation semantics defined in b.3.1 must not be used during the evaluation.

NN : NNP VBZ CC DT NN , NN , JJ , JJ , CC DT NN WDT VBZ VBN IN DT DT JJ CC DT JJ .
1
*0*assert: unfiltered is either a string, number, boolean, null, or an object that is defined by either an arrayliteral or an objectliteral.

NN . NNP NNP NNP NNP NNP NNP ( . NNP ( NNP ) ) .
1
*4*perform ? val.[[DELETE]](! tostring(i)).

VB NNP CC NNP VB VBN .
1
*0*let propertylist and replacerfunction be undefined.

IN NNP ( NNP ) VBZ VBG , VB NNP VB NNP .
1
*4*if type(v) is string, let item be v.

RB IN NNP ( NNP ) VBZ NN , VB NNP VB . NNP ( NNP ) .
1
*4*else if type(v) is number, let item be ! tostring(v).

IN NNP VBZ DT JJ NN NNP NNP NNP CC NNP NNP NNP NNP NNP JJ NN , VB NNP VB . NNP ( NNP ) .
1
*5*if v has a [[STRINGDATA]] or [[NUMBERDATA]] internal slot, let item be ? tostring(v).

IN NNP VBZ RB JJ CC NNP VBZ RB RB DT NN IN NNP , RB
1
*4*if item is not undefined and item is not currently an element of propertylist, then

NN NNP TO DT NN IN NNP .
1
*5*append item to the end of propertylist.

VB NNP VB VBN ( CD , NNP ( NNP ) ) .
1
*1*let space be min(10, tointeger(space)).

VBN NNP TO DT VBG NN VBG NNP NNS IN DT NN NN CD ( NN ) . DT MD VB DT JJ NN IN NNP VBZ JJR IN CD .
1
*1*set gap to the string value containing space occurrences of the code unit 0x0020 (space). this will be the empty string if space is less than 1.

RB IN NNP ( NNP ) VBZ VBG , RB
1
*0*else if type(space) is string, then

IN DT NN IN NNP VBZ CD CC JJR , VBN NNP TO NNP : RB VB NNP TO DT VBG NN NN IN DT JJ CD NNS IN NNP .
1
*1*if the length of space is 10 or less, set gap to space; otherwise set gap to the string value consisting of the first 10 elements of space.

VBN NNP TO DT JJ NN .
1
*1*set gap to the empty string.

VB NNP VB NNP ( NNP , DT JJ NN , NNP ) .
1
*0*let status be createdataproperty(wrapper, the empty string, value).

NN . NNP ( DT NN NN , NNP ) .
1
*0*return ? serializejsonproperty(the empty string, wrapper).

VBN NNP TO . NNP ( NNP , NNP , NNP NNP NNP ) .
1
*2*set value to ? call(tojson, value, « key »).

VBN NNP TO . NNP ( NNP , NNP , NNP NNP , NNP NNP ) .
1
*1*set value to ? call(replacerfunction, holder, « key, value »).

VBN NNP TO NNP . VB JJ NNP NNP NNP .
1
*2*set value to value.[[BOOLEANDATA]].

IN NNP ( NNP ) VBZ VBG , NN NNP ( NNP ) .
1
*0*if type(value) is string, return quotejsonstring(value).

NN `` JJ '' .
1
*1*return "null".

VB NNP VB DT VBG NN VBG RB IN DT NN NN CD ( NN NN ) .
1
*0*let product be the string value consisting solely of the code unit 0x0022 (quotation mark).

IN DT JJ NN IN NNP VBZ VBN IN DT NN NN NN NN IN JJ CD , RB
1
*1*if the numeric value of c is listed in the code unit value column of table 59, then

VBN NN TO DT NN IN NNP CC DT NN NN IN NNP IN VBN IN JJ CD .
1
*2*set product to the string-concatenation of product and the escape sequence for c as specified in table 59.

RB IN NNP VBZ DT JJ NN JJR IN CD ( NN ) , RB
1
*1*else if c has a numeric value less than 0x0020 (space), then

VBN NN TO DT NNP IN NNP CC NN ( NNP ) .
1
*2*set product to the string-concatenation of product and unicodeescape(c).

VBN NN TO DT NN IN NNP CC NNP .
1
*2*set product to the string-concatenation of product and c.

VBN NN TO DT NN IN NNP CC DT NN NN CD ( NN NN ) .
1
*0*set product to the string-concatenation of product and the code unit 0x0022 (quotation mark).

VB DT NN IN : DT NN NN CD ( VB NN ) `` JJ '' DT NN NN IN NNP , VBD IN DT JJ NN JJ NN , VBD TO DT NN IN NNS IN JJ
1
*0*return the string-concatenation of:the code unit 0x005c (reverse solidus) "u" the string representation of n, formatted as a four-digit lowercase hexadecimal number, padded to the left with zeroes if necessary

VBN NNP TO DT NN IN NNP CC `` : '' .
1
*2*set member to the string-concatenation of member and ":".

VBN NNP TO DT NN IN NNP CC DT NN NN CD ( NN ) .
1
*3*set member to the string-concatenation of member and the code unit 0x0020 (space).

VB NNP VB `` ( ) '' .
1
*1*let final be "{}".

VB NNP VB DT NN IN `` ( `` , NNP , CC `` ) '' .
1
*2*let final be the string-concatenation of "{", properties, and "}".

RB NNP VBZ RB DT JJ NN ,
1
*1*else gap is not the empty string,

VB NNP VB DT NN IN `` ( `` , DT NN NN CD ( NN NN ) , NNP , NNP , DT NN NN CD ( NN NN ) , NNP , CC `` ) '' .
1
*2*let final be the string-concatenation of "{", the code unit 0x000a (line feed), indent, properties, the code unit 0x000a (line feed), stepback, and "}".

VB NNP VB . NNP ( . NNP ( NNP ) , NNP ) .
1
*1*let strp be ? serializejsonproperty(! tostring(index), value).

VB `` JJ '' TO NNP .
1
*2*append "null" to partial.

NN NN IN CD .
1
*1*increment index by 1.

VB NNP VB `` JJ NN '' .
1
*1*let final be "[]".

VB NNP VB DT NN IN `` JJ `` , NNP , CC `` JJ '' .
1
*2*let final be the string-concatenation of "[", properties, and "]".

VB NNP VB DT NN IN `` JJ `` , DT NN NN CD ( NN NN ) , NNP , NNP , DT NN NN CD ( NN NN ) , NNP , CC `` JJ '' .
1
*2*let final be the string-concatenation of "[", the code unit 0x000a (line feed), indent, properties, the code unit 0x000a (line feed), stepback, and "]".

VB NNP VB . NNP ( NN NN NN , NNP NNP NNP NNP NNP NNP NNP ) .
1
*0*let asynciterator be ! objectcreate(%asyncfromsynciteratorprototype%, « [[SYNCITERATORRECORD]] »).

VB NNP VB NNP ( NNP , `` VB '' ) .
1
*0*let throw be getmethod(synciterator, "throw").

NN . NNP ( NNP , NN , `` NN '' , NNP ) .
1
*0*return ? createdynamicfunction(c, newtarget, "generator", args).

NN . NNP ( NNP , NN , `` NN NN '' , NNP ) .
1
*0*return ? createdynamicfunction(c, newtarget, "async generator", args).

NN : DT NN IN NNP . VB JJ NNP NNP NNP VBZ VBN .
1
*0*assert: the value of generator.[[GENERATORSTATE]] is undefined.

NN : IN PRP VBP RB , DT NN CC VBD DT NN CC VBN CC DT NN CC JJ NN .
1
*1*assert: if we return here, the generator either threw an exception or performed either an implicit or explicit return.

IN NNP . VB JJ NNP NNP NNP VBZ JJ , VB NNP VB VBN .
1
*1*if result.[[TYPE]] is normal, let resultvalue be undefined.

RB IN NNP . VB JJ NNP NNP NNP VBZ NN , VB NNP VB NNP . CC JJ NNP NNP NNP .
1
*1*else if result.[[TYPE]] is return, let resultvalue be result.[[VALUE]].

NN : NN RB VBZ DT JJ NNP NNP NNP NNP JJ NN .
1
*0*assert: generator also has a [[GENERATORCONTEXT]] internal slot.

IN NNP VBZ `` VBG '' , VB DT NN NN .
1
*0*if state is "executing", throw a typeerror exception.

IN NNP VBZ `` VBN '' , VB NNP ( JJ , JJ ) .
1
*0*if state is "completed", return createiterresultobject(undefined, true).

VB DT JJ NN IN NNP VBG NNP ( NNP ) IN DT NN IN DT NN WDT VBD PRP . VB NNP VB DT NN VBN IN DT JJ NN .
1
*0*resume the suspended evaluation of gencontext using normalcompletion(value) as the result of the operation that suspended it. let result be the value returned by the resumed computation.

NN NNP ( NNP . CC JJ NNP NNP NNP , JJ ) .
1
*2*return createiterresultobject(abruptcompletion.[[VALUE]], true).

IN NNP VBZ RB VB DT NN NN , VB NN .
1
*0*if gencontext does not have a generator component, return non-generator.

IN NNP VBZ DT JJ NN NNP NNP NNP JJ NN , NN NN .
1
*0*if generator has an [[ASYNCGENERATORSTATE]] internal slot, return async.

RB , NN NN .
1
*0*else, return sync.

NN : NNP VBZ DT NN WDT VBZ DT NN NN .
1
*0*assert: iternextobj is an object that implements the iteratorresult interface.

NN : DT VBZ TO DT NN IN DT NN WDT RB VBD DT JJ NN .
1
*1*note: this returns to the evaluation of the yieldexpression that originally called this abstract operation.

NN : IN PRP VBP RB , DT NN NN CC VBD DT NN CC VBN CC DT NN CC JJ NN .
1
*1*assert: if we return here, the async generator either threw an exception or performed either an implicit or explicit return.

IN NNP VBZ DT JJ NN , VB NNP VB VBN .
1
*1*if result is a normal completion, let resultvalue be undefined.

NN . NNP ( NNP . VB JJ NNP NNP NNP , VBD , JJ NNP NNP ) .
1
*0*perform ! call(promisecapability.[[REJECT]], undefined, « exception »).

NN : NNP VBZ RB `` VBG '' .
1
*0*assert: state is not "executing".

IN NNP VBZ `` JJ '' , NN VBD .
1
*0*if state is "awaiting-return", return undefined.

IN NNP VBZ DT JJ NN , NN VBD .
1
*0*if queue is an empty list, return undefined.

VB NNP VB DT NN IN DT JJ NN IN NNP .
1
*0*let next be the value of the first element of queue.

VB NNP VB NNP . NN JJ NNP NNP NNP .
1
*0*let completion be next.[[COMPLETION]].

VBN NNP . VB JJ NNP NNP NNP TO `` JJ '' .
1
*3*set generator.[[ASYNCGENERATORSTATE]] to "awaiting-return".

VBN NNP NNP NNP NNP NNP NNP . VB NNP NNP NNP NNP TO JJ .
1
*3*set throwawaycapability.[[PROMISE]].[[PROMISEISHANDLED]] to true.

NN . NNP ( NNP . VB JJ NNP NNP NNP , NNP , NNP , NNP ) .
1
*3*perform ! performpromisethen(promisecapability.[[PROMISE]], onfulfilled, onrejected, throwawaycapability).

NN . NNP ( NNP , NNP . CC JJ NNP NNP NNP ) .
1
*3*perform ! asyncgeneratorreject(generator, completion.[[VALUE]]).

RB IN NNP VBZ `` VBN '' , NN . NNP ( NNP , JJ , JJ ) .
1
*0*else if state is "completed", return ! asyncgeneratorresolve(generator, undefined, true).

NN : NN VBZ RB DT JJ NN .
1
*0*assert: result is never an abrupt completion.

VB NNP VB RB ( JJ NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : NN ) .
1
*0*let request be asyncgeneratorrequest { [[COMPLETION]]: completion, [[CAPABILITY]]: promisecapability }.

IN NNP VBZ RB `` VBG '' , RB
1
*0*if state is not "executing", then

VBN NNP TO . NN ( NNP ) .
1
*0*set value to ? await(value).

IN NNP . VB JJ NNP NNP NNP VBZ RB JJ , JJ NNP ( NNP ) .
1
*1*if resumptionvalue.[[TYPE]] is not return, return completion(resumptionvalue).

VB NNP VB VBN ( NNP . CC JJ NNP NNP NNP ) .
1
*1*let awaited be await(resumptionvalue.[[VALUE]]).

IN VBN . VB JJ NNP NNP NNP VBZ JJ , JJ NNP ( VBN ) .
1
*1*if awaited.[[TYPE]] is throw, return completion(awaited).

NN : VBN . VB JJ NNP NNP NNP VBZ JJ .
1
*1*assert: awaited.[[TYPE]] is normal.

NN NN ( JJ NNP NNP NNP NN : NN , NNP NNP NNP NNP NN : VBN . CC JJ NNP NNP NNP , NNP NNP NNP NNP NN : JJ ) .
1
*1*return completion { [[TYPE]]: return, [[VALUE]]: awaited.[[VALUE]], [[TARGET]]: empty }.

NN : WRB CD IN DT JJ NNS NNS , PRP VBZ TO DT NN IN DT NN NN WDT RB VBD DT JJ NN .
1
*1*note: when one of the above steps returns, it returns to the evaluation of the yieldexpression production that originally called this abstract operation.

VB NNP VB DT JJ NN ( JJ NNP NNP NNP NN : JJ ) .
1
*0*let alreadyresolved be a new record { [[VALUE]]: false }.

VB DT JJ NN ( JJ NNP NNP NNP NN : NNP , NNP NNP NNP NNP NN : JJ ) .
1
*0*return a new record { [[RESOLVE]]: resolve, [[REJECT]]: reject }.

NN : NNP VBZ VBN TO VB DT NN NN WDT VBZ DT NN NNS IN DT NN NN ( VB CD ) .
1
*0*note: c is assumed to be a constructor function that supports the parameter conventions of the promise constructor (see 25.6.3.1).

VB NNP VB DT JJ NN ( JJ NNP NNP NNP NN : JJ , JJ NNP NNP NNP NN : JJ , JJ NN NNP NNP NN : JJ ) .
1
*0*let promisecapability be a new promisecapability { [[PROMISE]]: undefined, [[RESOLVE]]: undefined, [[REJECT]]: undefined }.

VB NNP VB DT JJ NNS VBN IN NN NNS .
1
*0*let steps be the algorithm steps defined in getcapabilitiesexecutor functions.

IN NNP VBZ RB VB DT JJ NN NNP NNP NNP JJ NN , NN JJ .
1
*0*if x does not have a [[PROMISESTATE]] internal slot, return false.

IN NNP VBZ `` JJ '' , VB NNP VB NNP ( NNP ) .
1
*1*if type is "fulfill", let handlerresult be normalcompletion(argument).

NN : NN VBZ `` JJ '' .
1
*2*assert: type is "reject".

RB , VB NNP VB NNP ( NNP , VBD , FW NNP NNP ) .
1
*0*else, let handlerresult be call(handler, undefined, « argument »).

VB NNP VB NNP ( NNP , NNP , NNP NNP . VB JJ NNP NNP NNP , NNP . VB JJ NNP NNP NNP NNP ) .
1
*0*let thencallresult be call(then, thenable, « resolvingfunctions.[[RESOLVE]], resolvingfunctions.[[REJECT]] »).

VB NNP VB . NNP ( NN , `` NN NN NN '' , NNP NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP , NNP NNP NNP NNP NNP NNP ) .
1
*0*let promise be ? ordinarycreatefromconstructor(newtarget, "%promiseprototype%", « [[PROMISESTATE]], [[PROMISERESULT]], [[PROMISEFULFILLREACTIONS]], [[PROMISEREJECTREACTIONS]], [[PROMISEISHANDLED]] »).

VBN NNP . VB NNP NNP NNP NNP TO VB .
1
*0*set promise.[[PROMISEISHANDLED]] to false.

VB NNP VB NNP ( NNP , VBD , JJ NNP . VB JJ NNP NNP NNP , NNP . VB JJ NNP NNP NNP NNP ) .
1
*0*let completion be call(executor, undefined, « resolvingfunctions.[[RESOLVE]], resolvingfunctions.[[REJECT]] »).

VB NNP VB DT JJ NN ( JJ NNP NNP NNP NNP : CD ) .
1
*0*let remainingelementscount be a new record { [[VALUE]]: 1 }.

NN NNP . CC JJ NNP NNP NNP TO NNP . CC JJ NNP NNP NNP : CD .
1
*2*set remainingelementscount.[[VALUE]] to remainingelementscount.[[VALUE]] - 1.

IN NNP . CC JJ NNP NNP NNP VBZ CD , RB
1
*2*if remainingelementscount.[[VALUE]] is 0, then

NN VBD TO NNP .
1
*1*append undefined to values.

VB NNP VB DT JJ NNS VBN IN NN VBP JJ NNS .
1
*1*let steps be the algorithm steps defined in promise.all resolve element functions.

VBN NNP . VB NNP NNP NNP NNP TO DT JJ NN ( JJ NNP NNP NNP NN : JJ ) .
1
*1*set resolveelement.[[ALREADYCALLED]] to a new record { [[VALUE]]: false }.

VBN NNP . NNP NNP NNP NNP NNP TO NNP .
1
*1*set resolveelement.[[INDEX]] to index.

NN NNP . CC JJ NNP NNP NNP TO NNP . CC JJ NNP NNP NNP VBD CD .
1
*1*set remainingelementscount.[[VALUE]] to remainingelementscount.[[VALUE]] + 1.

NN . NNP ( NNP , `` RB '' , NNP NNP , NNP . VB JJ NNP NNP NNP NNP ) .
1
*1*perform ? invoke(nextpromise, "then", « resolveelement, resultcapability.[[REJECT]] »).

NN . NNP ( NNP , `` RB '' , NNP NNP . VB JJ NNP NNP NNP , NNP . VB JJ NNP NNP NNP NNP ) .
1
*1*perform ? invoke(nextpromise, "then", « resultcapability.[[RESOLVE]], resultcapability.[[REJECT]] »).

IN NNP ( NNP , NNP ) VBZ JJ , VB NNP .
1
*1*if samevalue(xconstructor, c) is true, return x.

NN . NNP ( NNP , `` RB '' , NNP VBD , NNP NNP ) .
1
*0*return ? invoke(promise, "then", « undefined, onrejected »).

VB NNP VB DT JJ NNS VBN IN RB RB NNS .
1
*1*let stepsthenfinally be the algorithm steps defined in then finally functions.

VB NNP VB DT JJ NNS VBN IN NN RB NNS .
1
*1*let stepscatchfinally be the algorithm steps defined in catch finally functions.

NN . NNP ( NNP , `` RB '' , NNP NNP , NNP NNP ) .
1
*0*return ? invoke(promise, "then", « thenfinally, catchfinally »).

NN NNP ( NNP , NNP , NNP , NNP ) .
1
*0*return performpromisethen(promise, onfulfilled, onrejected, resultcapability).

IN NNP ( VBN ) VBZ JJ , RB
1
*0*if iscallable(onfulfilled) is false, then

NN : DT NN IN NNP . VB JJ NNP NNP NNP VBZ `` JJ '' .
1
*1*assert: the value of promise.[[PROMISESTATE]] is "rejected".

VBN NNP . VB NNP NNP NNP NNP TO JJ .
1
*0*set promise.[[PROMISEISHANDLED]] to true.

NN NNP ( NNP , NN , `` NN '' , NNP ) .
1
*0*return createdynamicfunction(c, newtarget, "async", args).

NN : IN PRP VBP RB , DT NN NN CC VBD DT NN CC VBD DT NN CC JJ NN : DT NN VBZ VBN .
1
*1*assert: if we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.

NN . NNP ( NNP . VB JJ NNP NNP NNP , VBD , NNP VBD NNP ) .
1
*2*perform ! call(promisecapability.[[RESOLVE]], undefined, « undefined »).

RB IN NNP . VB JJ NNP NNP NNP VBZ NN , RB
1
*1*else if result.[[TYPE]] is return, then

VB DT JJ NN IN NNP . VB NNP VB DT NN VBN IN DT JJ NN .
1
*0*resume the suspended evaluation of asynccontext. let result be the value returned by the resumed computation.

NN : NN VBZ DT JJ NN IN DT NN IN JJ . DT JJ NNS IN NN NNS VBP JJ CC , IN DT JJ NN VBZ RB VB NN , DT NN CD IN .
1
*0*assert: result is a normal completion with a value of undefined. the possible sources of completion values are await or, if the async function doesn't await anything, the step 3.g above.

IN NNP VBZ RB JJ , VB NNP VB NNP .
1
*0*if newtarget is not present, let newtarget be target.

RB IN NNP ( NNP ) VBZ JJ , VB DT NN NN .
1
*0*else if isconstructor(newtarget) is false, throw a typeerror exception.

IN NNP ( NNP ) VBZ RB JJ CC NNP VBZ RB JJ , VB DT NN NN .
1
*0*if type(proto) is not object and proto is not null, throw a typeerror exception.

VB NNP VB DT JJ NNS VBN IN JJ NN NNS .
1
*0*let steps be the algorithm steps defined in proxy revocation functions.

IN DT NN NNS NN NNP IN NNP . VB JJ NNP NNP NNP , VBP
1
*0*for each agent events record aer in execution.[[EVENTLISTS]], do

IN DT NN NNP IN NNP . VB JJ NNP NNP NNP , VBP
1
*1*for each event e in aer.[[EVENTLIST]], do

NNS NNP TO NNS .
1
*2*add e to events.

IN NNP VBZ DT NN , NN , CC JJ NN , VB NNP TO NNS .
1
*1*if e is a readsharedmemory, writesharedmemory, or readmodifywritesharedmemory event, add e to events.

IN NNP VBZ RB IN NNP ( NNP ) , VBP NNP TO NNS .
1
*1*if e is not in shareddatablockeventset(execution), add e to events.

NN : NNP VBZ NNP IN PRP$ NN .
1
*1*assert: w has bytelocation in its range.

VB NNP VB NNP : NNP . VB JJ NNP NNP NNP .
1
*1*let payloadindex be bytelocation - w.[[BYTEINDEX]].

VB NNP VB NNP . VB JJ NNP NNP NNP NNP NNP NNP .
1
*2*let byte be w.[[PAYLOAD]][payloadindex].

VB NNP VB NNP . VB JJ NNP NNP NNP ( NNP , NNP . VB JJ NNP NNP NNP ) .
1
*2*let bytesmodified be w.[[MODIFYOP]](bytes, w.[[PAYLOAD]]).

VB NNP VB VBN NNP NNP NNP .
1
*2*let byte be bytesmodified[payloadindex].

JJ NNP IN CD .
1
*1*increment bytelocation by 1.

NN : NNP VBZ DT NN CC JJ NN .
1
*0*assert: r is a readsharedmemory or readmodifywritesharedmemory event.

VB NNP VB NNP . VB JJ NNP NNP NNP ( NNP ) .
1
*0*let ws be execution.[[READSBYTESFROM]](r).

NN : NNP VBZ DT NN IN NN CC JJ NNS IN JJ JJ TO NNP . VB JJ NNP NNP NNP .
1
*0*assert: ws is a list of writesharedmemory or readmodifywritesharedmemory events with length equal to r.[[ELEMENTSIZE]].

NN NNS ( NNP , NNP . VB JJ NNP NNP NNP , NNP ) .
1
*0*return composewriteeventbytes(execution, r.[[BYTEINDEX]], ws).

