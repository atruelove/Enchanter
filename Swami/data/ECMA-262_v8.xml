<?xml version="1.0" encoding="ISO-8859-1"?>
<bugrepository name="ECMA 262 v8">
<bug id="1">
	<buginformation>
		<summary>Scope</summary>
		<description>This Standard defines the ECMAScript 2017 general-purpose programming language.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="2">
	<buginformation>
		<summary>Conformance</summary>
		<description>A conforming implementation of ECMAScript must provide and support  all the types, values, objects, properties, functions, and program  syntax and semantics described in this specification. A conforming implementation of ECMAScript must interpret source  text input in conformance with the latest version of the Unicode  Standard and ISO/IEC 10646. A conforming implementation of ECMAScript that provides an  application programming interface that supports programs that need to  adapt to the linguistic and cultural conventions used by different human  languages and countries must implement the interface defined by the  most recent edition of ECMA-402 that is compatible with this  specification. A conforming implementation of ECMAScript may provide additional  types, values, objects, properties, and functions beyond those described  in this specification. In particular, a conforming implementation of  ECMAScript may provide properties not described in this specification,  and values for those properties, for objects that are described in this  specification. A conforming implementation of ECMAScript may support program and  regular expression syntax not described in this specification. In  particular, a conforming implementation of ECMAScript may support  program syntax that makes use of the “future reserved words” listed in  subclause  11.6.2.2 of this specification. A conforming implementation of ECMAScript must not implement any  extension that is listed as a Forbidden Extension in subclause  16.2.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="3">
	<buginformation>
		<summary>Normative References</summary>
		<description>The following referenced documents are indispensable for the  application of this document. For dated references, only the edition  cited applies. For undated references, the latest edition of the  referenced document (including any amendments) applies. ISO/IEC 10646:2003:  Information Technology – Universal  Multiple-Octet Coded Character Set (UCS) plus Amendment 1:2005,  Amendment 2:2006, Amendment 3:2008, and Amendment 4:2008, plus additional amendments and corrigenda, or successor ECMA-402,  ECMAScript 2015 Internationalization API Specification.           http://www.ecma-international.org/publications/standards/Ecma-402.htm ECMA-404,  The JSON Data Interchange Format.           http://www.ecma-international.org/publications/standards/Ecma-404.htm</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.1">
	<buginformation>
		<summary>Web Scripting</summary>
		<description>A web browser provides an ECMAScript host environment for  client-side computation including, for instance, objects that represent  windows, menus, pop-ups, dialog boxes, text areas, anchors, frames,  history, cookies, and input/output. Further, the host environment  provides a means to attach scripting code to events such as change of  focus, page and image loading, unloading, error and abort, selection,  form submission, and mouse actions. Scripting code appears within the  HTML and the displayed page is a combination of user interface elements  and fixed and computed text and images. The scripting code is reactive  to user interaction, and there is no need for a main program. A web server provides a different host environment for  server-side computation including objects representing requests,  clients, and files; and mechanisms to lock and share data. By using  browser-side and server-side scripting together, it is possible to  distribute computation between the client and server while providing a  customized user interface for a Web-based application. Each Web browser and server that supports ECMAScript supplies its  own host environment, completing the ECMAScript execution environment.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.2.1">
	<buginformation>
		<summary>Objects</summary>
		<description>Even though ECMAScript includes syntax for class definitions,  ECMAScript objects are not fundamentally class-based such as those in  C++, Smalltalk, or Java. Instead objects may be created in various ways  including via a literal notation or via  constructors which  create objects and then execute code that initializes all or part of  them by assigning initial values to their properties. Each constructor  is a function that has a property named &amp;quot;prototype&amp;quot; that is used to implement  prototype-based inheritance and  shared properties. Objects are created by using constructors in  new expressions; for example, new Date(2009,11) creates a new Date object. Invoking a constructor without using  new has consequences that depend on the constructor. For example, Date() produces a string representation of the current date and time rather than an object. Every object created by a constructor has an implicit reference (called the object&apos;s  prototype) to the value of its constructor&apos;s &amp;quot;prototype&amp;quot; property. Furthermore, a prototype may have a non-null implicit reference to its prototype, and so on; this is called the  prototype chain.  When a reference is made to a property in an object, that reference is  to the property of that name in the first object in the prototype chain  that contains a property of that name. In other words, first the object  mentioned directly is examined for such a property; if that object  contains the named property, that is the property to which the reference  refers; if that object does not contain the named property, the  prototype for that object is examined next; and so on. Figure 1: Object/Prototype Relationships     In a class-based object-oriented language, in general, state is  carried by instances, methods are carried by classes, and inheritance  is only of structure and behaviour. In ECMAScript, the state and methods  are carried by objects, while structure, behaviour, and state are all  inherited. All objects that do not directly contain a particular property  that their prototype contains share that property and its value. Figure 1  illustrates this: CF is a constructor (and also an object). Five objects have been created by using new expressions:  cf1,  cf2,  cf3,  cf4, and  cf5. Each of these objects contains properties named q1 and q2. The dashed lines represent the implicit prototype relationship; so, for example,  cf3&apos;s prototype is  CFp. The constructor,  CF, has two properties itself, named P1 and P2, which are not visible to  CFp,  cf1,  cf2,  cf3,  cf4, or  cf5. The property named CFP1 in  CFp is shared by  cf1,  cf2,  cf3,  cf4, and  cf5 (but not by  CF), as are any properties found in  CFp&apos;s implicit prototype chain that are not named q1, q2, or CFP1. Notice that there is no implicit prototype link between  CF and  CFp. Unlike most class-based object languages, properties can be  added to objects dynamically by assigning values to them. That is,  constructors are not required to name or assign values to all or any of  the constructed object&apos;s properties. In the above diagram, one could add  a new shared property for  cf1,  cf2,  cf3,  cf4, and  cf5 by assigning a new value to the property in  CFp. Although ECMAScript objects are not inherently class-based, it  is often convenient to define class-like abstractions based upon a  common pattern of constructor functions, prototype objects, and methods.  The ECMAScript built-in objects themselves follow such a class-like  pattern. Beginning with ECMAScript 2015, the ECMAScript language  includes syntactic class definitions that permit programmers to  concisely define objects that conform to the same class-like abstraction  pattern used by the built-in objects.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.2.2">
	<buginformation>
		<summary>The Strict Variant of ECMAScript</summary>
		<description>The ECMAScript Language recognizes the possibility that some  users of the language may wish to restrict their usage of some features  available in the language. They might do so in the interests of  security, to avoid what they consider to be error-prone features, to get  enhanced error checking, or for other reasons of their choosing. In  support of this possibility, ECMAScript defines a strict variant of the  language. The strict variant of the language excludes some specific  syntactic and semantic features of the regular ECMAScript language and  modifies the detailed semantics of some features. The strict variant  also specifies additional error conditions that must be reported by  throwing error exceptions in situations that are not specified as errors  by the non-strict form of the language. The strict variant of ECMAScript is commonly referred to as the  strict mode  of the language. Strict mode selection and use of the strict mode  syntax and semantics of ECMAScript is explicitly made at the level of  individual ECMAScript source text units. Because strict mode is selected  at the level of a syntactic source text unit, strict mode only imposes  restrictions that have local effect within such a source text unit.  Strict mode does not restrict or modify any aspect of the ECMAScript  semantics that must operate consistently across multiple source text  units. A complete ECMAScript program may be composed of both strict mode  and non-strict mode ECMAScript source text units. In this case, strict  mode only applies when actually executing code that is defined within a  strict mode source text unit. In order to conform to this specification, an ECMAScript  implementation must implement both the full unrestricted ECMAScript  language and the strict variant of the ECMAScript language as defined by  this specification. In addition, an implementation must support the  combination of unrestricted and strict mode source text units into a  single composite program.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.1">
	<buginformation>
		<summary>type</summary>
		<description>set of data values as defined in clause  6 of this specification</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.2">
	<buginformation>
		<summary>primitive value</summary>
		<description>member of one of the types Undefined, Null, Boolean, Number, Symbol, or String as defined in clause  6 Note A primitive value is a datum that is represented directly at the lowest level of the language implementation.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.3">
	<buginformation>
		<summary>object</summary>
		<description>member of the type Object Note An object is a collection of properties and has a single prototype object. The prototype may be the null value.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.4">
	<buginformation>
		<summary>constructor</summary>
		<description>function object that creates and initializes objects Note The value of a constructor&apos;s prototype property is a prototype object that is used to implement inheritance and shared properties.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.5">
	<buginformation>
		<summary>prototype</summary>
		<description>object that provides shared properties for other objects Note When a constructor creates an object, that object implicitly references the constructor&apos;s prototype property for the purpose of resolving property references. The constructor&apos;s prototype property can be referenced by the program expression  constructor.prototype,  and properties added to an object&apos;s prototype are shared, through  inheritance, by all objects sharing the prototype. Alternatively, a new  object may be created with an explicitly specified prototype by using  the Object.create built-in function.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.6">
	<buginformation>
		<summary>ordinary object</summary>
		<description>object that has the default behaviour for the essential internal methods that must be supported by all objects</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.7">
	<buginformation>
		<summary>exotic object</summary>
		<description>object that does not have the default behaviour for one or more of the essential internal methods Note Any object that is not an ordinary object is an exotic object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.8">
	<buginformation>
		<summary>standard object</summary>
		<description>object whose semantics are defined by this specification</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.9">
	<buginformation>
		<summary>built-in object</summary>
		<description>object specified and supplied by an ECMAScript implementation Note Standard built-in objects are defined in this specification.  An ECMAScript implementation may specify and supply additional kinds of  built-in objects. A  built-in constructor is a built-in object that is also a constructor.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.10">
	<buginformation>
		<summary>undefined value</summary>
		<description>primitive value used when a variable has not been assigned a value</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.11">
	<buginformation>
		<summary>Undefined type</summary>
		<description>type whose sole value is the undefined value</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.12">
	<buginformation>
		<summary>null value</summary>
		<description>primitive value that represents the intentional absence of any object value</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.13">
	<buginformation>
		<summary>Null type</summary>
		<description>type whose sole value is the null value</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.14">
	<buginformation>
		<summary>Boolean value</summary>
		<description>member of the Boolean type Note There are only two Boolean values, true and false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.15">
	<buginformation>
		<summary>Boolean type</summary>
		<description>type consisting of the primitive values true and false</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.16">
	<buginformation>
		<summary>Boolean object</summary>
		<description>member of the Object type that is an instance of the standard built-in Boolean constructor Note A Boolean object is created by using the Boolean constructor in a new  expression, supplying a Boolean value as an argument. The resulting  object has an internal slot whose value is the Boolean value. A Boolean  object can be coerced to a Boolean value.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.17">
	<buginformation>
		<summary>String value</summary>
		<description>primitive value that is a finite ordered sequence of zero or more 16-bit unsigned integer values Note A String value is a member of the String type. Each integer  value in the sequence usually represents a single 16-bit unit of UTF-16  text. However, ECMAScript does not place any restrictions or  requirements on the values except that they must be 16-bit unsigned  integers.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.18">
	<buginformation>
		<summary>String type</summary>
		<description>set of all possible String values</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.19">
	<buginformation>
		<summary>String object</summary>
		<description>member of the Object type that is an instance of the standard built-in String constructor Note A String object is created by using the String constructor in a new  expression, supplying a String value as an argument. The resulting  object has an internal slot whose value is the String value. A String  object can be coerced to a String value by calling the String constructor as a function (21.1.1.1).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.20">
	<buginformation>
		<summary>Number value</summary>
		<description>primitive value corresponding to a double-precision 64-bit binary format IEEE 754-2008 value Note A Number value is a member of the Number type and is a direct representation of a number.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.21">
	<buginformation>
		<summary>Number type</summary>
		<description>set of all possible Number values including the special “Not-a-Number” (NaN) value, positive infinity, and negative infinity</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.22">
	<buginformation>
		<summary>Number object</summary>
		<description>member of the Object type that is an instance of the standard built-in Number constructor Note A Number object is created by using the Number constructor in a new  expression, supplying a number value as an argument. The resulting  object has an internal slot whose value is the number value. A Number  object can be coerced to a number value by calling the Number constructor as a function (20.1.1.1).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.23">
	<buginformation>
		<summary>Infinity</summary>
		<description>number value that is the positive infinite number value</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.24">
	<buginformation>
		<summary>NaN</summary>
		<description>number value that is an IEEE 754-2008 “Not-a-Number” value</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.25">
	<buginformation>
		<summary>Symbol value</summary>
		<description>primitive value that represents a unique, non-String Object property key</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.26">
	<buginformation>
		<summary>Symbol type</summary>
		<description>set of all possible Symbol values</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.27">
	<buginformation>
		<summary>Symbol object</summary>
		<description>member of the Object type that is an instance of the standard built-in Symbol constructor</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.28">
	<buginformation>
		<summary>function</summary>
		<description>member of the Object type that may be invoked as a subroutine Note In addition to its properties, a function contains executable  code and state that determine how it behaves when invoked. A function&apos;s  code may or may not be written in ECMAScript.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.29">
	<buginformation>
		<summary>built-in function</summary>
		<description>built-in object that is a function Note Examples of built-in functions include parseInt and Math.exp. An implementation may provide implementation-dependent built-in functions that are not described in this specification.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.30">
	<buginformation>
		<summary>property</summary>
		<description>part of an object that associates a key (either a String value or a Symbol value) and a value Note Depending upon the form of the property the value may be  represented either directly as a data value (a primitive value, an  object, or a function object) or indirectly by a pair of accessor  functions.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.31">
	<buginformation>
		<summary>method</summary>
		<description>function that is the value of a property Note When a function is called as a method of an object, the object is passed to the function as its this value.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.32">
	<buginformation>
		<summary>built-in method</summary>
		<description>method that is a built-in function Note Standard built-in methods are defined in this specification,  and an ECMAScript implementation may specify and provide other  additional built-in methods.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.33">
	<buginformation>
		<summary>attribute</summary>
		<description>internal value that defines some characteristic of a property</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.34">
	<buginformation>
		<summary>own property</summary>
		<description>property that is directly contained by its object</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.3.35">
	<buginformation>
		<summary>inherited property</summary>
		<description>property of an object that is not an own property but is a property (either own or inherited) of the object&apos;s prototype</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="4.4">
	<buginformation>
		<summary>Organization of This Specification</summary>
		<description>The remainder of this specification is organized as follows: Clause 5 defines the notational conventions used throughout the specification. Clauses 6-9 define the execution environment within which ECMAScript programs operate. Clauses 10-16 define the actual ECMAScript programming language  including its syntactic encoding and the execution semantics of all  language features. Clauses 17-26 define the ECMAScript standard library. They  include the definitions of all of the standard objects that are  available for use by ECMAScript programs as they execute.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="5.1.1">
	<buginformation>
		<summary>Context-Free Grammars</summary>
		<description>A  context-free grammar consists of a number of  productions. Each production has an abstract symbol called a  nonterminal as its  left-hand side, and a sequence of zero or more nonterminal and  terminal symbols as its  right-hand side. For each grammar, the terminal symbols are drawn from a specified alphabet. A  chain production is a production that has exactly one nonterminal symbol on its right-hand side along with zero or more terminal symbols. Starting from a sentence consisting of a single distinguished nonterminal, called the  goal symbol, a given context-free grammar specifies a  language,  namely, the (perhaps infinite) set of possible sequences of terminal  symbols that can result from repeatedly replacing any nonterminal in the  sequence with a right-hand side of a production for which the  nonterminal is the left-hand side.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="5.1.2">
	<buginformation>
		<summary>The Lexical and RegExp Grammars</summary>
		<description>A  lexical grammar for ECMAScript is given in clause  11. This grammar has as its terminal symbols Unicode code points that conform to the rules for SourceCharacter defined in  10.1. It defines a set of productions, starting from the goal symbol InputElementDiv, InputElementTemplateTail, or InputElementRegExp, or InputElementRegExpOrTemplateTail, that describe how sequences of such code points are translated into a sequence of input elements. Input elements other than white space and comments form the  terminal symbols for the syntactic grammar for ECMAScript and are called  ECMAScript  tokens. These tokens are the reserved words,  identifiers, literals, and punctuators of the ECMAScript language.  Moreover, line terminators, although not considered to be tokens, also  become part of the stream of input elements and guide the process of  automatic semicolon insertion (11.9).  Simple white space and single-line comments are discarded and do not  appear in the stream of input elements for the syntactic grammar. A MultiLineComment (that is, a comment of the form /*…*/ regardless of whether it spans more than one line) is likewise simply discarded if it contains no line terminator; but if a MultiLineComment  contains one or more line terminators, then it is replaced by a single  line terminator, which becomes part of the stream of input elements for  the syntactic grammar. A  RegExp grammar for ECMAScript is given in  21.2.1. This grammar also has as its terminal symbols the code points as defined by SourceCharacter. It defines a set of productions, starting from the goal symbol Pattern, that describe how sequences of code points are translated into regular expression patterns. Productions of the lexical and RegExp grammars are distinguished by having two colons “::” as separating punctuation. The lexical and RegExp grammars share some productions.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="5.1.3">
	<buginformation>
		<summary>The Numeric String Grammar</summary>
		<description>Another grammar is used for translating Strings into numeric  values. This grammar is similar to the part of the lexical grammar  having to do with numeric literals and has as its terminal symbols SourceCharacter. This grammar appears in  7.1.3.1. Productions of the numeric string grammar are distinguished by having three colons “:::” as punctuation.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="5.1.4">
	<buginformation>
		<summary>The Syntactic Grammar</summary>
		<description>The  syntactic grammar for ECMAScript is given in  clauses 11, 12, 13, 14, and 15. This grammar has ECMAScript tokens  defined by the lexical grammar as its terminal symbols (5.1.2). It defines a set of productions, starting from two alternative goal symbols Script and Module, that describe how sequences of tokens form syntactically correct independent components of ECMAScript programs. When a stream of code points is to be parsed as an ECMAScript Script or Module,  it is first converted to a stream of input elements by repeated  application of the lexical grammar; this stream of input elements is  then parsed by a single application of the syntactic grammar. The input  stream is syntactically in error if the tokens in the stream of input  elements cannot be parsed as a single instance of the goal nonterminal (Script or Module), with no tokens left over. When a parse is successful, it constructs a  parse tree, a rooted tree structure in which each node is a  Parse Node. Each Parse Node is an  instance  of a symbol in the grammar; it represents a span of the source text  that can be derived from that symbol. The root node of the parse tree,  representing the whole of the source text, is an instance of the parse&apos;s  goal symbol.  When a Parse Node is an instance of a nonterminal, it is also an  instance of some production that has that nonterminal as its left-hand  side. Moreover, it has zero or more  children, one for each  symbol on the production&apos;s right-hand side: each child is a Parse Node  that is an instance of the corresponding symbol. Productions of the syntactic grammar are distinguished by having just one colon “:” as punctuation. The syntactic grammar as presented in clauses 12, 13, 14 and 15  is not a complete account of which token sequences are accepted as a  correct ECMAScript Script or Module.  Certain additional token sequences are also accepted, namely, those  that would be described by the grammar if only semicolons were added to  the sequence in certain places (such as before line terminator  characters). Furthermore, certain token sequences that are described by  the grammar are not considered acceptable if a line terminator character  appears in certain “awkward” places. In certain cases, in order to avoid ambiguities, the syntactic  grammar uses generalized productions that permit token sequences that do  not form a valid ECMAScript Script or Module. For example, this technique is used for object literals and object destructuring patterns. In such cases a more restrictive  supplemental grammar  is provided that further restricts the acceptable token sequences. In  certain contexts, when explicitly specified, the input elements  corresponding to such a production are parsed again using a goal symbol  of a supplemental grammar. The input stream is syntactically in error  if the tokens in the stream of input elements parsed by a cover grammar  cannot be parsed as a single instance of the corresponding supplemental goal symbol, with no tokens left over.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="5.1.5">
	<buginformation>
		<summary>Grammar Notation</summary>
		<description>Terminal symbols of the lexical, RegExp, and numeric string grammars are shown in fixed width  font, both in the productions of the grammars and throughout this  specification whenever the text directly refers to such a terminal  symbol. These are to appear in a script exactly as written. All terminal  symbol code points specified in this way are to be understood as the  appropriate Unicode code points from the Basic Latin range, as opposed  to any similar-looking code points from other Unicode ranges. Nonterminal symbols are shown in  italic type. The  definition of a nonterminal (also called a “production”) is introduced  by the name of the nonterminal being defined followed by one or more  colons. (The number of colons indicates to which grammar the production  belongs.) One or more alternative right-hand sides for the nonterminal  then follow on succeeding lines. For example, the syntactic definition:  WhileStatement:while(Expression)Statement  states that the nonterminal WhileStatement represents the token while, followed by a left parenthesis token, followed by an Expression, followed by a right parenthesis token, followed by a Statement. The occurrences of Expression and Statement are themselves nonterminals. As another example, the syntactic definition:  ArgumentList:AssignmentExpression ArgumentList,AssignmentExpression  states that an ArgumentList may represent either a single AssignmentExpression or an ArgumentList, followed by a comma, followed by an AssignmentExpression. This definition of ArgumentList is recursive, that is, it is defined in terms of itself. The result is that an ArgumentList may contain any positive number of arguments, separated by commas, where each argument expression is an AssignmentExpression. Such recursive definitions of nonterminals are common. The subscripted suffix “opt”, which may appear after  a terminal or nonterminal, indicates an optional symbol. The  alternative containing the optional symbol actually specifies two  right-hand sides, one that omits the optional element and one that  includes it. This means that:  VariableDeclaration:BindingIdentifierInitializeropt  is a convenient abbreviation for:  VariableDeclaration:BindingIdentifier BindingIdentifierInitializer  and that:  IterationStatement:for(LexicalDeclarationExpressionopt;Expressionopt)Statement  is a convenient abbreviation for:  IterationStatement:for(LexicalDeclaration;Expressionopt)Statement for(LexicalDeclarationExpression;Expressionopt)Statement  which in turn is an abbreviation for:  IterationStatement:for(LexicalDeclaration;)Statement for(LexicalDeclaration;Expression)Statement for(LexicalDeclarationExpression;)Statement for(LexicalDeclarationExpression;Expression)Statement  so, in this example, the nonterminal IterationStatement actually has four alternative right-hand sides. A production may be parameterized by a subscripted annotation of the form “[parameters]”, which may appear as a suffix to the nonterminal symbol defined by the production. “parameters”  may be either a single name or a comma separated list of names. A  parameterized production is shorthand for a set of productions defining  all combinations of the parameter names, preceded by an underscore,  appended to the parameterized nonterminal symbol. This means that:  StatementList[Return]:ReturnStatement ExpressionStatement  is a convenient abbreviation for:  StatementList:ReturnStatement ExpressionStatement   StatementList_Return:ReturnStatement ExpressionStatement  and that:  StatementList[Return, In]:ReturnStatement ExpressionStatement  is an abbreviation for:  StatementList:ReturnStatement ExpressionStatement   StatementList_Return:ReturnStatement ExpressionStatement   StatementList_In:ReturnStatement ExpressionStatement   StatementList_Return_In:ReturnStatement ExpressionStatement  Multiple parameters produce a combinatory number of  productions, not all of which are necessarily referenced in a complete  grammar. References to nonterminals on the right-hand side of a production can also be parameterized. For example:  StatementList:ReturnStatement ExpressionStatement[+In]  is equivalent to saying:  StatementList:ReturnStatement ExpressionStatement_In  and:  StatementList:ReturnStatement ExpressionStatement[~In]  is equivalent to:  StatementList:ReturnStatement ExpressionStatement  A nonterminal reference may have both a parameter list and an “opt” suffix. For example:  VariableDeclaration:BindingIdentifierInitializer[+In]opt  is an abbreviation for:  VariableDeclaration:BindingIdentifier BindingIdentifierInitializer_In  Prefixing a parameter name with “?” on a right-hand  side nonterminal reference makes that parameter value dependent upon the  occurrence of the parameter name on the reference to the current  production&apos;s left-hand side symbol. For example:  VariableDeclaration[In]:BindingIdentifierInitializer[?In]  is an abbreviation for:  VariableDeclaration:BindingIdentifierInitializer   VariableDeclaration_In:BindingIdentifierInitializer_In  If a right-hand side alternative is prefixed with  “[+parameter]” that alternative is only available if the named parameter  was used in referencing the production&apos;s nonterminal symbol. If a  right-hand side alternative is prefixed with “[~parameter]” that  alternative is only available if the named parameter was  not used in referencing the production&apos;s nonterminal symbol. This means that:  StatementList[Return]:[+Return]ReturnStatement ExpressionStatement  is an abbreviation for:  StatementList:ExpressionStatement   StatementList_Return:ReturnStatement ExpressionStatement  and that:  StatementList[Return]:[~Return]ReturnStatement ExpressionStatement  is an abbreviation for:  StatementList:ReturnStatement ExpressionStatement   StatementList_Return:ExpressionStatement  When the words “one of” follow the colon(s) in a grammar  definition, they signify that each of the terminal symbols on the  following line or lines is an alternative definition. For example, the  lexical grammar for ECMAScript contains the production:  NonZeroDigit::one of123456789  which is merely a convenient abbreviation for:  NonZeroDigit::1 2 3 4 5 6 7 8 9  If the phrase “[empty]” appears as the right-hand side of a  production, it indicates that the production&apos;s right-hand side contains  no terminals or nonterminals. If the phrase “[lookahead ∉ set]” appears in the  right-hand side of a production, it indicates that the production may  not be used if the immediately following input token sequence is a  member of the given set. The set can be written as  a comma separated list of one or two element terminal sequences  enclosed in curly brackets. For convenience, the set can also be written  as a nonterminal, in which case it represents the set of all terminals  to which that nonterminal could expand. If the set consists of a single terminal the phrase “[lookahead ≠ terminal]” may be used. For example, given the definitions:  DecimalDigit::one of0123456789   DecimalDigits::DecimalDigit DecimalDigitsDecimalDigit  the definition:  LookaheadExample::n[lookahead ∉ { 1, 3, 5, 7, 9 }]DecimalDigits DecimalDigit[lookahead ∉ DecimalDigit]  matches either the letter n followed by one or more decimal digits the first of which is even, or a decimal digit not followed by another decimal digit. If the phrase “[no LineTerminator here]” appears in the right-hand side of a production of the syntactic grammar, it indicates that the production is  a restricted production: it may not be used if a LineTerminator occurs in the input stream at the indicated position. For example, the production:  ThrowStatement:throw[no LineTerminator here]Expression;  indicates that the production may not be used if a LineTerminator occurs in the script between the throw token and the Expression. Unless the presence of a LineTerminator is forbidden by a restricted production, any number of occurrences of LineTerminator  may appear between any two consecutive tokens in the stream of input  elements without affecting the syntactic acceptability of the script. When an alternative in a production of the lexical grammar or  the numeric string grammar appears to be a multi-code point token, it  represents the sequence of code points that would make up such a token. The right-hand side of a production may specify that certain expansions are not permitted by using the phrase “but not” and then indicating the expansions to be excluded. For example, the production:  Identifier::IdentifierNamebut not ReservedWord  means that the nonterminal Identifier may be replaced by any sequence of code points that could replace IdentifierName provided that the same sequence of code points could not replace ReservedWord. Finally, a few nonterminal symbols are described by a  descriptive phrase in sans-serif type in cases where it would be  impractical to list all the alternatives:  SourceCharacter::any Unicode code point</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="5.2">
	<buginformation>
		<summary>Algorithm Conventions</summary>
		<description>The specification often uses a numbered list to specify steps in  an algorithm. These algorithms are used to precisely specify the  required semantics of ECMAScript language constructs. The algorithms are  not intended to imply the use of any specific implementation technique.  In practice, there may be more efficient algorithms available to  implement a given feature. Algorithms may be explicitly parameterized, in which case the  names and usage of the parameters must be provided as part of the  algorithm&apos;s definition. In order to facilitate their use in multiple  parts of this specification, some algorithms, called  abstract operations,  are named and written in parameterized functional form so that they may  be referenced by name from within other algorithms. Abstract operations  are typically referenced using a functional application style such as  operationName(arg1, arg2). Some abstract  operations are treated as polymorphically dispatched methods of  class-like specification abstractions. Such method-like abstract  operations are typically referenced using a method application style  such as someValue.operationName(arg1, arg2). Calls to abstract operations return Completion  Records. Abstract operations referenced using the functional  application style and the method application style that are prefixed by ? indicate that ReturnIfAbrupt should be applied to the resulting Completion Record. For example, ? operationName() is equivalent to ReturnIfAbrupt(operationName()). Similarly, ? someValue.operationName() is equivalent to ReturnIfAbrupt(someValue.operationName()). The prefix ! is used to indicate that an abstract operation will never return an abrupt completion and that the resulting Completion Record&apos;s value field should be used in place of the return value of the operation. For example, “Let val be ! operationName()” is equivalent to the following algorithm steps: Let val be operationName().Assert: val is never an abrupt completion.If val is a Completion Record, let val be val.[[Value]].      Algorithms may be associated with productions of one of the  ECMAScript grammars. A production that has multiple alternative  definitions will typically have a distinct algorithm for each  alternative. When an algorithm is associated with a grammar production,  it may reference the terminal and nonterminal symbols of the production  alternative as if they were parameters of the algorithm. When used in  this manner, nonterminal symbols refer to the actual alternative  definition that is matched when parsing the source text. When an algorithm is associated with a production alternative,  the alternative is typically shown without any “[ ]” grammar  annotations. Such annotations should only affect the syntactic  recognition of the alternative and have no effect on the associated  semantics for the alternative. Unless explicitly specified otherwise, all chain productions have  an implicit definition for every algorithm that might be applied to  that production&apos;s left-hand side nonterminal. The implicit definition  simply reapplies the same algorithm name with the same parameters, if  any, to the chain production&apos;s sole right-hand side nonterminal and then returns the result. For example, assume there is a production:  Block:{StatementList}  but there is no corresponding Evaluation algorithm that is  explicitly specified for that production. If in some algorithm there is a  statement of the form: “Return the result of evaluating Block” it is implicit that an Evaluation algorithm exists of the form: Runtime Semantics: Evaluation  Block:{StatementList}  Return the result of evaluating StatementList.      For clarity of expression, algorithm steps may be subdivided into  sequential substeps. Substeps are indented and may themselves be  further divided into indented substeps. Outline numbering conventions  are used to identify substeps with the first level of substeps labelled  with lower case alphabetic characters and the second level of substeps  labelled with lower case roman numerals. If more than three levels are  required these rules repeat with the fourth level using numeric labels.  For example: Top-level stepSubstep.Substep.Subsubstep.SubsubsubstepSubsubsubsubstepSubsubsubsubsubstep      A step or substep may be written as an “if” predicate that  conditions its substeps. In this case, the substeps are only applied if  the predicate is true. If a step or substep begins with the word “else”,  it is a predicate that is the negation of the preceding “if” predicate  step at the same level. A step may specify the iterative application of its substeps. A step that begins with “Assert:” asserts  an invariant condition of its algorithm. Such assertions are used to  make explicit algorithmic invariants that would otherwise be implicit.  Such assertions add no additional semantic requirements and hence need  not be checked by an implementation. They are used simply to clarify  algorithms. Algorithm steps may declare named aliases for any value using the form “Let x be someValue”. These aliases are reference-like in that both x and someValue  refer to the same underlying data and modifications to either are  visible to both. Algorithm steps that want to avoid this reference-like  behaviour should explicitly make a copy of the right-hand side: “Let x be a copy of someValue” creates a shallow copy of someValue. Mathematical operations such as addition, subtraction, negation,  multiplication, division, and the mathematical functions defined later  in this clause should always be understood as computing exact  mathematical results on mathematical real numbers, which unless  otherwise noted do not include infinities and do not include a negative  zero that is distinguished from positive zero. Algorithms in this  standard that model floating-point arithmetic include explicit steps,  where necessary, to handle infinities and signed zero and to perform  rounding. If a mathematical operation or function is applied to a  floating-point number, it should be understood as being applied to the  exact mathematical value represented by that floating-point number; such  a floating-point number must be finite, and if it is +0 or -0 then the corresponding mathematical value is simply 0. The mathematical function  abs(x) produces the absolute value of x, which is  -x if x is negative (less than zero) and otherwise is x itself. The mathematical function  min(x1, x2, ..., xN) produces the mathematically smallest of  x1 through  xN. The mathematical function  max(x1, x2, ..., xN) produces the mathematically largest of  x1 through  xN. The domain and range of these mathematical functions include +∞ and -∞. The notation “x modulo y” (y must be finite and nonzero) computes a value k of the same sign as y (or zero) such that  abs(k) &lt; abs(y) and x-k</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="5.3">
	<buginformation>
		<summary>Static Semantic Rules</summary>
		<description>Context-free grammars are not sufficiently powerful to express  all the rules that define whether a stream of input elements form a  valid ECMAScript Script or Module  that may be evaluated. In some situations additional rules are needed  that may be expressed using either ECMAScript algorithm conventions or  prose requirements. Such rules are always associated with a production  of a grammar and are called the  static semantics of the production. Static Semantic Rules have names and typically are defined using  an algorithm. Named Static Semantic Rules are associated with grammar  productions and a production that has multiple alternative definitions  will typically have for each alternative a distinct algorithm for each  applicable named static semantic rule. Unless otherwise specified every grammar production alternative  in this specification implicitly has a definition for a static semantic  rule named Contains which takes an argument named symbol  whose value is a terminal or nonterminal of the grammar that includes  the associated production. The default definition of Contains is: For each child node child of this Parse Node, doIf child is an instance of symbol, return true.If child is an instance of a nonterminal, thenLet contained be the result of child Contains symbol.If contained is true, return true.Return false.      The above definition is explicitly over-ridden for specific productions. A special kind of static semantic rule is an  Early Error Rule. Early error rules define early error conditions (see clause  16) that are associated with specific grammar productions. Evaluation of most early error  rules are not explicitly invoked within the algorithms of this  specification. A conforming implementation must, prior to the first  evaluation of a Script or Module, validate all of the early error rules of the productions used to parse that Script or Module. If any of the early error rules are violated the Script or Module is invalid and cannot be evaluated.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.1.1">
	<buginformation>
		<summary>The Undefined Type</summary>
		<description>The Undefined type has exactly one value, called undefined. Any variable that has not been assigned a value has the value undefined.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.1.2">
	<buginformation>
		<summary>The Null Type</summary>
		<description>The Null type has exactly one value, called null.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.1.3">
	<buginformation>
		<summary>The Boolean Type</summary>
		<description>The Boolean type represents a logical entity having two values, called true and false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.1.4">
	<buginformation>
		<summary>The String Type</summary>
		<description>The String type is the set of all ordered sequences of zero or  more 16-bit unsigned integer values (“elements”) up to a maximum length  of 253-1 elements. The String type is generally used to  represent textual data in a running ECMAScript program, in which case  each element in the String is treated as a UTF-16 code unit value. Each  element is regarded as occupying a position within the sequence. These  positions are indexed with nonnegative integers. The first element (if  any) is at index 0, the next element (if any) at index 1, and so on. The  length of a String is the number of elements (i.e., 16-bit values)  within it. The empty String has length zero and therefore contains no  elements. Where ECMAScript operations interpret String values, each  element is interpreted as a single UTF-16 code unit. However, ECMAScript  does not place any restrictions or requirements on the sequence of code  units in a String value, so they may be ill-formed when interpreted as  UTF-16 code unit sequences. Operations that do not interpret String  contents treat them as sequences of undifferentiated 16-bit unsigned  integers. The function String.prototype.normalize (see  21.1.3.12) can be used to explicitly normalize a String value. String.prototype.localeCompare (see  21.1.3.10)  internally normalizes String values, but no other operations implicitly  normalize the strings upon which they operate. Only operations that are  explicitly specified to be language or locale sensitive produce  language-sensitive results. Note The rationale behind this design was to keep the  implementation of Strings as simple and high-performing as possible. If  ECMAScript source text is in Normalized Form C, string literals are  guaranteed to also be normalized, as long as they do not contain any  Unicode escape sequences.  Some operations interpret String contents as UTF-16 encoded Unicode code points. In that case the interpretation is:             A code unit in the range 0 to 0xD7FF or in the range 0xE000 to  0xFFFF is interpreted as a code point with the same value.                              A sequence of two code units, where the first code unit c1 is in the range 0xD800 to 0xDBFF and the second code unit c2 is in the range 0xDC00 to 0xDFFF, is a surrogate pair and is interpreted as a code point with the value (c1 - 0xD800) × 0x400 + (c2 - 0xDC00) + 0x10000. (See  10.1.2)                              A code unit that is in the range 0xD800 to 0xDFFF, but is not  part of a surrogate pair, is interpreted as a code point with the same  value.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.1.5.1">
	<buginformation>
		<summary>Well-Known Symbols</summary>
		<description>Well-known symbols are built-in Symbol values that are  explicitly referenced by algorithms of this specification. They are  typically used as the keys of properties whose values serve as extension  points of a specification algorithm. Unless otherwise specified,  well-known symbols values are shared by all realms (8.2). Within this specification a well-known symbol is referred to  by using a notation of the form @@name, where “name” is one of the  values listed in  Table 1. Table 1: Well-known Symbols                     Specification Name                                                [[Description]]                                                Value and Purpose                                                  @@hasInstance                                &amp;quot;Symbol.hasInstance&amp;quot;                   A method that determines if a constructor object  recognizes an object as one of the constructor&apos;s instances. Called by  the semantics of the instanceof operator.                                                  @@isConcatSpreadable                                &amp;quot;Symbol.isConcatSpreadable&amp;quot;                   A Boolean valued property that if true indicates that an object should be flattened to its array elements by  Array.prototype.concat.                                                  @@iterator                                &amp;quot;Symbol.iterator&amp;quot;                   A method that returns the default Iterator for an object. Called by the semantics of the for-of statement.                                                  @@match                                &amp;quot;Symbol.match&amp;quot;                   A regular expression method that matches the regular expression against a string. Called by the  String.prototype.match method.                                                  @@replace                                &amp;quot;Symbol.replace&amp;quot;                   A regular expression method that replaces matched substrings of a string. Called by the  String.prototype.replace method.                                                  @@search                                &amp;quot;Symbol.search&amp;quot;                   A regular expression method that returns the index  within a string that matches the regular expression. Called by the  String.prototype.search method.                                                  @@species                                &amp;quot;Symbol.species&amp;quot;                   A function valued property that is the constructor function that is used to create derived objects.                                                  @@split                                &amp;quot;Symbol.split&amp;quot;                   A regular expression method that splits a string at the  indices that match the regular expression. Called by the  String.prototype.split method.                                                  @@toPrimitive                                &amp;quot;Symbol.toPrimitive&amp;quot;                   A method that converts an object to a corresponding primitive value. Called by the ToPrimitive abstract operation.                                                  @@toStringTag                                &amp;quot;Symbol.toStringTag&amp;quot;                   A String valued property that is used in the creation of  the default string description of an object. Accessed by the built-in  method  Object.prototype.toString.                                                  @@unscopables                                &amp;quot;Symbol.unscopables&amp;quot;                   An object valued property whose own and inherited property names are property names that are excluded from the with environment bindings of the associated object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.1.6">
	<buginformation>
		<summary>The Number Type</summary>
		<description>The Number type has exactly 18437736874454810627 (that is,  264-253+3)  values, representing the double-precision 64-bit format IEEE 754-2008  values as specified in the IEEE Standard for Binary Floating-Point  Arithmetic, except that the 9007199254740990 (that is,  253-2) distinct “Not-a-Number” values of the IEEE Standard are represented in ECMAScript as a single special NaN value. (Note that the NaN value is produced by the program expression NaN.)  In some implementations, external code might be able to detect a  difference between various Not-a-Number values, but such behaviour is  implementation-dependent; to ECMAScript code, all NaN values are indistinguishable from each other. Note The bit pattern that might be observed in an ArrayBuffer (see  24.1) or a SharedArrayBuffer (see  24.2)  after a Number value has been stored into it is not necessarily the  same as the internal representation of that Number value used by the  ECMAScript implementation.  There are two other special values, called positive Infinity and negative Infinity. For brevity, these values are also referred to for expository purposes by the symbols +∞ and -∞, respectively. (Note that these two infinite Number values are produced by the program expressions +Infinity (or simply Infinity) and -Infinity.) The other 18437736874454810624 (that is,  264-253)  values are called the finite numbers. Half of these are positive  numbers and half are negative numbers; for every finite positive Number  value there is a corresponding negative value having the same magnitude. Note that there is both a positive zero and a negative zero. For brevity, these values are also referred to for expository purposes by the symbols +0 and -0, respectively. (Note that these two different zero Number values are produced by the program expressions +0 (or simply 0) and -0.) The 18437736874454810622 (that is,  264-253-2) finite nonzero values are of two kinds: 18428729675200069632 (that is,  264-254) of them are normalized, having the form  s × m × 2e  where s is +1 or -1, m is a positive integer less than 253 but not less than 252, and e is an integer ranging from -1074 to 971, inclusive. The remaining 9007199254740990 (that is,  253-2) values are denormalized, having the form  s × m × 2e  where s is +1 or -1, m is a positive integer less than 252, and e is -1074. Note that all the positive and negative integers whose magnitude is no greater than 253 are representable in the Number type (indeed, the integer 0 has two representations, +0 and -0). A finite number has an  odd significand if it is nonzero and the integer m used to express it (in one of the two forms shown above) is odd. Otherwise, it has an  even significand. In this specification, the phrase “the Number value for x” where x  represents an exact nonzero real mathematical quantity (which might  even be an irrational number such as π) means a Number value chosen in  the following manner. Consider the set of all finite values of the  Number type, with -0 removed and with two additional values added to it that are not representable in the Number type, namely 21024 (which is  +1 × 253 × 2971) and  -21024 (which is  -1 × 253 × 2971). Choose the member of this set that is closest in value to x.  If two values of the set are equally close, then the one with an even  significand is chosen; for this purpose, the two extra values 21024 and  -21024 are considered to have even significands. Finally, if 21024 was chosen, replace it with +∞; if  -21024 was chosen, replace it with -∞; if +0 was chosen, replace it with -0 if and only if x is less than zero; any other chosen value is used unchanged. The result is the Number value for x. (This procedure corresponds exactly to the behaviour of the IEEE 754-2008 “round to nearest, ties to even” mode.) Some ECMAScript operators deal only with integers in specific ranges such as  -231 through  231-1, inclusive, or in the range 0 through  216-1,  inclusive. These operators accept any value of the Number type but  first convert each such value to an integer value in the expected range.  See the descriptions of the numeric conversion operations in  7.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.1.7.1">
	<buginformation>
		<summary>Property Attributes</summary>
		<description>Attributes are used in this specification to define and  explain the state of Object properties. A data property associates a key  value with the attributes listed in  Table 2. Table 2: Attributes of a Data Property                     Attribute Name                                                Value Domain                                                Description                                                  [[Value]]                                                Any ECMAScript language type                   The value retrieved by a get access of the property.                                                  [[Writable]]                                                Boolean                                                If false, attempts by ECMAScript code to change the property&apos;s [[Value]] attribute using [[Set]] will not succeed.                                                  [[Enumerable]]                                                Boolean                                                If true, the property will be enumerated by a for-in enumeration (see  13.7.5). Otherwise, the property is said to be non-enumerable.                                                  [[Configurable]]                                                Boolean                                                If false, attempts to delete the  property, change the property to be an accessor property, or change its  attributes (other than [[Value]], or changing [[Writable]] to false) will fail.                                   An accessor property associates a key value with the attributes listed in  Table 3. Table 3: Attributes of an Accessor Property                     Attribute Name                                                Value Domain                                                Description                                                  [[Get]]                                                Object | Undefined                                                If the value is an Object it must be a function object. The function&apos;s [[Call]] internal method (Table 6) is called with an empty arguments list to retrieve the property value each time a get access of the property is performed.                                                  [[Set]]                                                Object | Undefined                                                If the value is an Object it must be a function object. The function&apos;s [[Call]] internal method (Table 6)  is called with an arguments list containing the assigned value as its  sole argument each time a set access of the property is performed. The  effect of a property&apos;s [[Set]] internal method may, but is not required  to, have an effect on the value returned by subsequent calls to the  property&apos;s [[Get]] internal method.                                                  [[Enumerable]]                                                Boolean                                                If true, the property is to be enumerated by a for-in enumeration (see  13.7.5). Otherwise, the property is said to be non-enumerable.                                                  [[Configurable]]                                                Boolean                                                If false, attempts to delete the property, change the property to be a data property, or change its attributes will fail.                                   If the initial values of a property&apos;s attributes are not  explicitly specified by this specification, the default value defined in   Table 4 is used. Table 4: Default Attribute Values                     Attribute Name                                                Default Value                                                  [[Value]]                                undefined                     [[Get]]                                undefined                     [[Set]]                                undefined                     [[Writable]]                                false                     [[Enumerable]]                                false                     [[Configurable]]                                false</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.1.7.2">
	<buginformation>
		<summary>Object Internal Methods and Internal Slots</summary>
		<description>The actual semantics of objects, in ECMAScript, are specified via algorithms called  internal methods.  Each object in an ECMAScript engine is associated with a set of  internal methods that defines its runtime behaviour. These internal  methods are not part of the ECMAScript language. They are defined by  this specification purely for expository purposes. However, each object  within an implementation of ECMAScript must behave as specified by the  internal methods associated with it. The exact manner in which this is  accomplished is determined by the implementation. Internal method names are polymorphic. This means that  different object values may perform different algorithms when a common  internal method name is invoked upon them. That actual object upon which  an internal method is invoked is the “target” of the invocation. If, at  runtime, the implementation of an algorithm attempts to use an internal  method of an object that the object does not support, a TypeError exception is thrown. Internal slots correspond to internal state that is  associated with objects and used by various ECMAScript specification  algorithms. Internal slots are not object properties and they are not  inherited. Depending upon the specific internal slot specification, such  state may consist of values of any ECMAScript language type  or of specific ECMAScript specification type values. Unless explicitly  specified otherwise, internal slots are allocated as part of the process  of creating an object and may not be dynamically added to an object.  Unless specified otherwise, the initial value of an internal slot is the  value undefined. Various algorithms within this  specification create objects that have internal slots. However, the  ECMAScript language provides no direct way to associate internal slots  with an object. Internal methods and internal slots are identified within  this specification using names enclosed in double square brackets [[ ]]. Table 5 summarizes the  essential internal methods  used by this specification that are applicable to all objects created  or manipulated by ECMAScript code. Every object must have algorithms for  all of the essential internal methods. However, all objects do not  necessarily use the same algorithms for those methods. The “Signature” column of  Table 5  and other similar tables describes the invocation pattern for each  internal method. The invocation pattern always includes a parenthesized  list of descriptive parameter names. If a parameter name is the same as  an ECMAScript type name then the name describes the required type of the  parameter value. If an internal method explicitly returns a value, its  parameter list is followed by the symbol “→” and the type name of the  returned value. The type names used in signatures refer to the types  defined in clause  6 augmented by the following additional names. “any” means the value may be any ECMAScript language type. An internal method implicitly returns a Completion Record. In addition to its parameters, an internal method always has access to the object that is the target of the method invocation. Table 5: Essential Internal Methods                     Internal Method                                                Signature                                                Description                                                  [[GetPrototypeOf]]                                                ()  → Object | Null                                                Determine the object that provides inherited properties for this object. A null value indicates that there are no inherited properties.                                                  [[SetPrototypeOf]]                                                (Object | Null)  → Boolean                                                Associate this object with another object that provides inherited properties. Passing null indicates that there are no inherited properties. Returns true indicating that the operation was completed successfully or false indicating that the operation was not successful.                                                  [[IsExtensible]]                                                ( )  → Boolean                                                Determine whether it is permitted to add additional properties to this object.                                                  [[PreventExtensions]]                                                ( )  → Boolean                                                Control whether new properties may be added to this object. Returns true if the operation was successful or false if the operation was unsuccessful.                                                  [[GetOwnProperty]]                                                (propertyKey)  → Undefined | Property Descriptor                   Return a Property Descriptor for the own property of this object whose key is propertyKey, or undefined if no such property exists.                                                  [[DefineOwnProperty]]                                                (propertyKey, PropertyDescriptor)  → Boolean                                                Create or alter the own property, whose key is propertyKey, to have the state described by PropertyDescriptor. Return true if that property was successfully created/updated or false if the property could not be created or updated.                                                  [[HasProperty]]                                                (propertyKey)  → Boolean                                                Return a Boolean value indicating whether this object  already has either an own or inherited property whose key is propertyKey.                                                  [[Get]]                                                (propertyKey, Receiver)  → any                   Return the value of the property whose key is propertyKey from this object. If any ECMAScript code must be executed to retrieve the property value, Receiver is used as the this value when evaluating the code.                                                  [[Set]]                                                (propertyKey, value, Receiver)  → Boolean                                                Set the value of the property whose key is propertyKey to value. If any ECMAScript code must be executed to set the property value, Receiver is used as the this value when evaluating the code. Returns true if the property value was set or false if it could not be set.                                                  [[Delete]]                                                (propertyKey)  → Boolean                                                Remove the own property whose key is propertyKey from this object. Return false if the property was not deleted and is still present. Return true if the property was deleted or is not present.                                                  [[OwnPropertyKeys]]                                                ()→List of propertyKey                                                Return a List whose elements are all of the own property keys for the object.                                   Table 6 summarizes additional essential internal methods that are supported by objects that may be called as functions. A  function object is an object that supports the [[Call]] internal method. A  constructor (also referred to as a  constructor function) is a function object that supports the [[Construct]] internal method. Table 6: Additional Essential Internal Methods of Function Objects                     Internal Method                                                Signature                                                Description                                                  [[Call]]                                                (any, a List of  any)  → any                   Executes code associated with this object. Invoked via a  function call expression. The arguments to the internal method are a this  value and a list containing the arguments passed to the function by a  call expression. Objects that implement this internal method are  callable.                                                  [[Construct]]                                                (a List of  any, Object)  → Object                                                Creates an object. Invoked via the new or super  operators. The first argument to the internal method is a list  containing the arguments of the operator. The second argument is the  object to which the new operator was initially applied. Objects that implement this internal method are called  constructors.  A function object is not necessarily a constructor and such  non-constructor function objects do not have a [[Construct]] internal  method.                                   The semantics of the essential internal methods for ordinary objects and standard exotic objects are specified in clause  9. If any specified use of an internal method of an exotic object is not supported by an implementation, that usage must throw a TypeError exception when attempted.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.1.7.3">
	<buginformation>
		<summary>Invariants of the Essential Internal Methods</summary>
		<description>The Internal Methods of Objects of an ECMAScript engine must  conform to the list of invariants specified below. Ordinary ECMAScript  Objects as well as all standard exotic objects in this specification  maintain these invariants. ECMAScript Proxy objects maintain these  invariants by means of runtime checks on the result of traps invoked on  the [[ProxyHandler]] object. Any implementation provided exotic objects must also maintain  these invariants for those objects. Violation of these invariants may  cause ECMAScript code to have unpredictable behaviour and create  security issues. However, violation of these invariants must never  compromise the memory safety of an implementation. An implementation must not allow these invariants to be  circumvented in any manner such as by providing alternative interfaces  that implement the functionality of the essential internal methods  without enforcing their invariants. Definitions:               The  target of an internal method is the object upon which the internal method is called.                                    A target is  non-extensible if it has been observed  to return false from its [[IsExtensible]] internal method, or true from  its [[PreventExtensions]] internal method.                                    A  non-existent property is a property that does not exist as an own property on a non-extensible target.                                    All references to  SameValue are according to the definition of the SameValue algorithm.                        [[GetPrototypeOf]] ( )               The Type of the return value must be either Object or Null.                                    If target is non-extensible, and [[GetPrototypeOf]] returns a  value v, then any future calls to [[GetPrototypeOf]] should return the SameValue as v.                        Note 1 An object&apos;s prototype chain should have finite length (that  is, starting from any object, recursively applying the  [[GetPrototypeOf]] internal method to its result should eventually lead  to the value null). However, this requirement is not enforceable as an  object level invariant if the prototype chain includes any exotic  objects that do not use the ordinary object definition of  [[GetPrototypeOf]]. Such a circular prototype chain may result in  infinite loops when accessing object properties.  [[SetPrototypeOf]] (V)               The Type of the return value must be Boolean.                                    If target is non-extensible, [[SetPrototypeOf]] must return false, unless V is the SameValue as the target&apos;s observed [[GetPrototypeOf]] value.                        [[IsExtensible]] ( )               The Type of the return value must be Boolean.                                    If [[IsExtensible]] returns false, all future calls to [[IsExtensible]] on the target must return false.                        [[PreventExtensions]] ( )               The Type of the return value must be Boolean.                                    If [[PreventExtensions]] returns true, all future calls to  [[IsExtensible]] on the target must return false and the target is now  considered non-extensible.                        [[GetOwnProperty]] (P)               The Type of the return value must be either Property Descriptor or Undefined.                                    If the Type of the return value is Property Descriptor, the return value must be a complete property descriptor (see  6.2.5.6).                                    If a property P is described as a data property with  Desc.[[Value]] equal to v and Desc.[[Writable]] and  Desc.[[Configurable]] are both false, then the SameValue must be returned for the Desc.[[Value]] attribute of the property on all future calls to [[GetOwnProperty]] ( P ).                                    If P&apos;s attributes other than [[Writable]] may change over  time or if the property might disappear, then P&apos;s [[Configurable]]  attribute must be true.                                    If the [[Writable]] attribute may change from false to true, then the [[Configurable]] attribute must be true.                                    If the target is non-extensible and P is non-existent, then  all future calls to [[GetOwnProperty]] (P) on the target must describe P  as non-existent (i.e. [[GetOwnProperty]] (P) must return undefined).                        Note 2 As a consequence of the third invariant, if a property is  described as a data property and it may return different values over  time, then either or both of the Desc.[[Writable]] and  Desc.[[Configurable]] attributes must be true even if no mechanism to  change the value is exposed via the other internal methods.  [[DefineOwnProperty]] (P, Desc)               The Type of the return value must be Boolean.                        [[DefineOwnProperty]] must return false if P has  previously been observed as a non-configurable own property of the  target, unless either:                   P is a non-configurable writable own data property. A  non-configurable writable data property can be changed into a  non-configurable non-writable data property.                                                All attributes in Desc are the SameValue as P&apos;s attributes.                                              [[DefineOwnProperty]] (P, Desc) must return false if target  is non-extensible and P is a non-existent own property. That is, a  non-extensible target object cannot be extended with new properties.                        [[HasProperty]] ( P )               The Type of the return value must be Boolean.                                    If P was previously observed as a non-configurable data or  accessor own property of the target, [[HasProperty]] must return true.                        [[Get]] (P, Receiver)               If P was previously observed as a non-configurable,  non-writable own data property of the target with value v, then [[Get]]  must return the SameValue.                                    If P was previously observed as a non-configurable own  accessor property of the target whose [[Get]] attribute is undefined,  the [[Get]] operation must return undefined.                        [[Set]] ( P, V, Receiver)               The Type of the return value must be Boolean.                                    If P was previously observed as a non-configurable,  non-writable own data property of the target, then [[Set]] must return  false unless V is the SameValue as P&apos;s [[Value]] attribute.                                    If P was previously observed as a non-configurable own  accessor property of the target whose [[Set]] attribute is undefined,  the [[Set]] operation must return false.                        [[Delete]] ( P )               The Type of the return value must be Boolean.                                    If P was previously observed to be a non-configurable own  data or accessor property of the target, [[Delete]] must return false.                        [[OwnPropertyKeys]] ( )               The return value must be a List.                                    The Type of each element of the returned List is either String or Symbol.                                    The returned List must contain at least the keys of all non-configurable own properties that have previously been observed.                                    If the object is non-extensible, the returned List must contain only the keys of all own properties of the object that are observable using [[GetOwnProperty]].                        [[Construct]] ( )               The Type of the return value must be Object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.1.7.4">
	<buginformation>
		<summary>Well-Known Intrinsic Objects</summary>
		<description>Well-known intrinsics are built-in objects that are  explicitly referenced by the algorithms of this specification and which  usually have realm-specific  identities. Unless otherwise specified each intrinsic object actually  corresponds to a set of similar objects, one per realm. Within this specification a reference such as %name% means the intrinsic object, associated with the current realm, corresponding to the name. Determination of the current realm and its intrinsics is described in  8.3. The well-known intrinsics are listed in  Table 7. Table 7: Well-known Intrinsic Objects                     Intrinsic Name                                                Global Name                                                ECMAScript Language Association                                  %Array%   Array                   The Array constructor (22.1.1)                                  %ArrayBuffer%   ArrayBuffer                   The ArrayBuffer constructor (24.1.2)                                  %ArrayBufferPrototype%   ArrayBuffer.prototype                   The initial value of the prototype data property of %ArrayBuffer%.                                  %ArrayIteratorPrototype%                     The prototype of Array iterator objects (22.1.5)                                  %ArrayPrototype%   Array.prototype                   The initial value of the prototype data property of %Array% (22.1.3)                                  %ArrayProto_values%   Array.prototype.values                   The initial value of the values data property of %ArrayPrototype% (22.1.3.30)                                  %AsyncFunction%                     The constructor of async function objects (25.5.1)                                  %AsyncFunctionPrototype%                     The initial value of the prototype data property of %AsyncFunction%     %Atomics%   Atomics                   The Atomics object (24.4)                                  %Boolean%   Boolean                   The Boolean constructor (19.3.1)                                  %BooleanPrototype%   Boolean.prototype                   The initial value of the prototype data property of %Boolean% (19.3.3)                                  %DataView%   DataView                   The DataView constructor (24.3.2)                                  %DataViewPrototype%   DataView.prototype                   The initial value of the prototype data property of %DataView%     %Date%   Date                   The Date constructor (20.3.2)                                  %DatePrototype%   Date.prototype                   The initial value of the prototype data property of %Date%.                                  %decodeURI%   decodeURI                   The decodeURI function (18.2.6.2)                                  %decodeURIComponent%   decodeURIComponent                   The decodeURIComponent function (18.2.6.3)                                  %encodeURI%   encodeURI                   The encodeURI function (18.2.6.4)                                  %encodeURIComponent%   encodeURIComponent                   The encodeURIComponent function (18.2.6.5)                                  %Error%   Error                   The Error constructor (19.5.1)                                  %ErrorPrototype%   Error.prototype                   The initial value of the prototype data property of %Error%     %eval%   eval                   The eval function (18.2.1)                                                  %EvalError%                                EvalError                   The EvalError constructor (19.5.5.1)                                                  %EvalErrorPrototype%                                EvalError.prototype                   The initial value of the prototype property of %EvalError%                                                  %Float32Array%                                Float32Array                   The Float32Array constructor (22.2)                                                  %Float32ArrayPrototype%                                Float32Array.prototype                   The initial value of the prototype data property of %Float32Array%.                                                  %Float64Array%                                Float64Array                   The Float64Array constructor (22.2)                                                  %Float64ArrayPrototype%                                Float64Array.prototype                   The initial value of the prototype data property of %Float64Array%                                  %Function%   Function                   The Function constructor (19.2.1)                                  %FunctionPrototype%   Function.prototype                   The initial value of the prototype data property of %Function%     %Generator%                     The initial value of the prototype property of %GeneratorFunction%     %GeneratorFunction%                     The constructor of generator objects (25.2.1)                                  %GeneratorPrototype%                     The initial value of the prototype property of %Generator%                     %Int8Array%                                Int8Array                   The Int8Array constructor (22.2)                                                  %Int8ArrayPrototype%                                Int8Array.prototype                   The initial value of the prototype data property of %Int8Array%                                                  %Int16Array%                                Int16Array                   The Int16Array constructor (22.2)                                                  %Int16ArrayPrototype%                                Int16Array.prototype                   The initial value of the prototype data property of %Int16Array%                                                  %Int32Array%                                Int32Array                   The Int32Array constructor (22.2)                                                  %Int32ArrayPrototype%                                Int32Array.prototype                   The initial value of the prototype data property of %Int32Array%                                  %isFinite%   isFinite                   The isFinite function (18.2.2)                                  %isNaN%   isNaN                   The isNaN function (18.2.3)                                  %IteratorPrototype%                     An object that all standard built-in iterator objects indirectly inherit from                                  %JSON%   JSON                   The JSON object (24.5)                                  %Map%   Map                   The Map constructor (23.1.1)                                  %MapIteratorPrototype%                     The prototype of Map iterator objects (23.1.5)                                  %MapPrototype%   Map.prototype                   The initial value of the prototype data property of %Map%     %Math%   Math                   The Math object (20.2)                                  %Number%   Number                   The Number constructor (20.1.1)                                  %NumberPrototype%   Number.prototype                   The initial value of the prototype property of %Number%     %Object%   Object                   The Object constructor (19.1.1)                                  %ObjectPrototype%   Object.prototype                   The initial value of the prototype data property of %Object%. (19.1.3)                                  %ObjProto_toString%   Object.prototype.toString                   The initial value of the toString data property of %ObjectPrototype% (19.1.3.6)                                  %ObjProto_valueOf%   Object.prototype.valueOf                   The initial value of the valueOf data property of %ObjectPrototype% (19.1.3.7)                                  %parseFloat%   parseFloat                   The parseFloat function (18.2.4)                                  %parseInt%   parseInt                   The parseInt function (18.2.5)                                  %Promise%   Promise                   The Promise constructor (25.4.3)                                  %PromisePrototype%   Promise.prototype                   The initial value of the prototype data property of %Promise%     %Proxy%   Proxy                   The Proxy constructor (26.2.1)                                                  %RangeError%                                RangeError                   The RangeError constructor (19.5.5.2)                                                  %RangeErrorPrototype%                                RangeError.prototype                   The initial value of the prototype property of %RangeError%                                                  %ReferenceError%                                ReferenceError                   The ReferenceError constructor (19.5.5.3)                                                  %ReferenceErrorPrototype%                                ReferenceError.prototype                   The initial value of the prototype property of %ReferenceError%                                  %Reflect%   Reflect                   The Reflect object (26.1)                                  %RegExp%   RegExp                   The RegExp constructor (21.2.3)                                  %RegExpPrototype%   RegExp.prototype                   The initial value of the prototype data property of %RegExp%     %Set%   Set                   The Set constructor (23.2.1)                                  %SetIteratorPrototype%                     The prototype of Set iterator objects (23.2.5)                                  %SetPrototype%   Set.prototype                   The initial value of the prototype data property of %Set%     %SharedArrayBuffer%   SharedArrayBuffer                   The SharedArrayBuffer constructor (24.2.2)                                  %SharedArrayBufferPrototype%   SharedArrayBuffer.prototype                   The initial value of the prototype data property of %SharedArrayBuffer%.                                  %String%   String                   The String constructor (21.1.1)                                  %StringIteratorPrototype%                     The prototype of String iterator objects (21.1.5)                                  %StringPrototype%   String.prototype                   The initial value of the prototype data property of %String%     %Symbol%   Symbol                   The Symbol constructor (19.4.1)                                  %SymbolPrototype%   Symbol.prototype                   The initial value of the prototype data property of %Symbol%. (19.4.3)                                                  %SyntaxError%                                SyntaxError                   The SyntaxError constructor (19.5.5.4)                                                  %SyntaxErrorPrototype%                                SyntaxError.prototype                   The initial value of the prototype property of %SyntaxError%                                  %ThrowTypeError%                     A function object that unconditionally throws a new instance of %TypeError%                                  %TypedArray%                     The super class of all typed Array constructors (22.2.1)                                  %TypedArrayPrototype%                     The initial value of the prototype property of %TypedArray%                     %TypeError%                                TypeError                   The TypeError constructor (19.5.5.5)                                                  %TypeErrorPrototype%                                TypeError.prototype                   The initial value of the prototype property of %TypeError%                                                  %Uint8Array%                                Uint8Array                   The Uint8Array constructor (22.2)                                                  %Uint8ArrayPrototype%                                Uint8Array.prototype                   The initial value of the prototype data property of %Uint8Array%                                                  %Uint8ClampedArray%                                Uint8ClampedArray                   The Uint8ClampedArray constructor (22.2)                                                  %Uint8ClampedArrayPrototype%                                Uint8ClampedArray.prototype                   The initial value of the prototype data property of %Uint8ClampedArray%                                                  %Uint16Array%                                Uint16Array                   The Uint16Array constructor (22.2)                                                  %Uint16ArrayPrototype%                                Uint16Array.prototype                   The initial value of the prototype data property of %Uint16Array%                                                  %Uint32Array%                                Uint32Array                   The Uint32Array constructor (22.2)                                                  %Uint32ArrayPrototype%                                Uint32Array.prototype                   The initial value of the prototype data property of %Uint32Array%                                                  %URIError%                                URIError                   The URIError constructor (19.5.5.6)                                                  %URIErrorPrototype%                                URIError.prototype                   The initial value of the prototype property of %URIError%                                  %WeakMap%   WeakMap                   The WeakMap constructor (23.3.1)                                  %WeakMapPrototype%   WeakMap.prototype                   The initial value of the prototype data property of %WeakMap%     %WeakSet%   WeakSet                   The WeakSet constructor (23.4.1)                                  %WeakSetPrototype%   WeakSet.prototype                   The initial value of the prototype data property of %WeakSet%</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.1">
	<buginformation>
		<summary>The List and Record Specification Types</summary>
		<description>The  List type is used to explain the evaluation of argument lists (see  12.3.6) in new  expressions, in function calls, and in other algorithms where a simple  ordered list of values is needed. Values of the List type are simply  ordered sequences of list elements containing the individual values.  These sequences may be of any length. The elements of a list may be  randomly accessed using 0-origin indices. For notational convenience an  array-like syntax can be used to access List elements. For example, arguments[2] is shorthand for saying the 3rd element of the List arguments. For notational convenience within this specification, a literal  syntax can be used to express a new List value. For example, « 1, 2 »  defines a List value that has two elements each of which is initialized  to a specific value. A new empty List can be expressed as « ». The  Record type is used to describe data  aggregations within the algorithms of this specification. A Record type  value consists of one or more named fields. The value of each field is  either an ECMAScript value or an abstract value represented by a name  associated with the Record type. Field names are always enclosed in  double brackets, for example [[Value]]. For notational convenience within this specification, an object  literal-like syntax can be used to express a Record value. For example,  {[[Field1]]: 42, [[Field2]]: false, [[Field3]]: empty}  defines a Record value that has three fields, each of which is  initialized to a specific value. Field name order is not significant.  Any fields that are not explicitly listed are considered to be absent. In specification text and algorithms, dot notation may be used  to refer to a specific field of a Record value. For example, if R is the  record shown in the previous paragraph then R.[[Field2]] is shorthand  for “the field of R named [[Field2]]”. Schema for commonly used Record field combinations may be  named, and that name may be used as a prefix to a literal Record value  to identify the specific kind of aggregations that is being described.  For example: PropertyDescriptor{[[Value]]: 42, [[Writable]]: false, [[Configurable]]: true}.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.2">
	<buginformation>
		<summary>The Set and Relation Specification Types</summary>
		<description>The  Set type is used to explain a collection of unordered elements for use in the memory model.  Values of the Set type are simple collections of elements, where no  element appears more than once. Elements may be added to and removed  from Sets. Sets may be unioned, intersected, or subtracted from each  other. The  Relation type is used to explain constraints on  Sets. Values of the Relation type are Sets of ordered pairs of values  from its value domain. For example, a Relation on events is a set of  ordered pairs of events. For a Relation R and two values a and b in the value domain of R, a R b is shorthand for saying the ordered pair (a, b) is a member of R. A Relation is least with respect to some conditions when it is the smallest Relation that satisfies those conditions. A  strict partial order is a Relation value R that satisfies the following conditions. For all a, b, and c in R&apos;s domain:It is not the case that a R a, andIf a R b and b R c, then a R c.        Note 1 The two properties above are called, in order, irreflexivity and transitivity.  A  strict total order is a Relation value R that satisfies the following conditions. For all a, b, and c in R&apos;s domain:a R b or b R a, andIt is not the case that a R a, andIf a R b and b R c, then a R c.        Note 2 The three properties above are called, in order, totality, irreflexivity, and transitivity.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.3.1">
	<buginformation>
		<summary>NormalCompletion</summary>
		<description>The abstract operation NormalCompletion with a single argument, such as: Return NormalCompletion(argument).          Is a shorthand that is defined as follows: Return Completion{[[Type]]: normal, [[Value]]: argument, [[Target]]: empty}.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.3.2">
	<buginformation>
		<summary>Implicit Completion Values</summary>
		<description>The algorithms of this specification often implicitly return Completion Records whose [[Type]] is normal. Unless it is otherwise obvious from the context, an algorithm statement that returns a value that is not a Completion Record, such as: Return &amp;quot;Infinity&amp;quot;.          means the same thing as: Return NormalCompletion(&amp;quot;Infinity&amp;quot;).          However, if the value expression of a “return” statement is a Completion Record construction literal, the resulting Completion Record is returned. If the value expression is a call to an abstract operation, the “return” statement simply returns the Completion Record produced by the abstract operation. The abstract operation Completion(completionRecord) is used to emphasize that a previously computed Completion Record is being returned. The Completion abstract operation takes a single argument, completionRecord, and performs the following steps: Assert: completionRecord is a Completion Record.Return completionRecord as the Completion Record of this abstract operation.          A “return” statement without a value in an algorithm step means the same thing as: Return NormalCompletion(undefined).          Any reference to a Completion Record value that is in a context that does not explicitly require a complete Completion Record value is equivalent to an explicit reference to the [[Value]] field of the Completion Record value unless the Completion Record is an abrupt completion.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.3.3">
	<buginformation>
		<summary>Throw an Exception</summary>
		<description>Algorithms steps that say to throw an exception, such as Throw a TypeError exception.          mean the same things as: Return Completion{[[Type]]: throw, [[Value]]: a newly created TypeError object, [[Target]]: empty}.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.3.4">
	<buginformation>
		<summary>ReturnIfAbrupt</summary>
		<description>Algorithms steps that say or are otherwise equivalent to: ReturnIfAbrupt(argument).          mean the same thing as: If argument is an abrupt completion, return argument.Else if argument is a Completion Record, let argument be argument.[[Value]].          Algorithms steps that say or are otherwise equivalent to: ReturnIfAbrupt(AbstractOperation()).          mean the same thing as: Let hygienicTemp be AbstractOperation().If hygienicTemp is an abrupt completion, return hygienicTemp.Else if hygienicTemp is a Completion Record, let hygienicTemp be hygienicTemp.[[Value]].          Where hygienicTemp is ephemeral and visible only in the steps pertaining to ReturnIfAbrupt. Algorithms steps that say or are otherwise equivalent to: Let result be AbstractOperation(ReturnIfAbrupt(argument)).          mean the same thing as: If argument is an abrupt completion, return argument.If argument is a Completion Record, let argument be argument.[[Value]].Let result be AbstractOperation(argument).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.3.5">
	<buginformation>
		<summary>UpdateEmpty ( completionRecord, value )</summary>
		<description>The abstract operation UpdateEmpty with arguments completionRecord and value performs the following steps: Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.If completionRecord.[[Value]] is not empty, return Completion(completionRecord).Return Completion{[[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.4.1">
	<buginformation>
		<summary>GetValue ( V )</summary>
		<description>ReturnIfAbrupt(V).If Type(V) is not Reference, return V.Let base be GetBase(V).If IsUnresolvableReference(V) is true, throw a ReferenceError exception.If IsPropertyReference(V) is true, thenIf HasPrimitiveBase(V) is true, thenAssert: In this case, base will never be undefined or null.Set base to ! ToObject(base).Return ? base.[[Get]](GetReferencedName(V), GetThisValue(V)).Else base must be an Environment Record,Return ? base.GetBindingValue(GetReferencedName(V), IsStrictReference(V)) (see 8.1.1).          Note The object that may be created in step 5.a.ii is not  accessible outside of the above abstract operation and the ordinary  object [[Get]] internal method. An implementation might choose to avoid  the actual creation of the object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.4.2">
	<buginformation>
		<summary>PutValue ( V, W )</summary>
		<description>ReturnIfAbrupt(V).ReturnIfAbrupt(W).If Type(V) is not Reference, throw a ReferenceError exception.Let base be GetBase(V).If IsUnresolvableReference(V) is true, thenIf IsStrictReference(V) is true, thenThrow a ReferenceError exception.Let globalObj be GetGlobalObject().Return ? Set(globalObj, GetReferencedName(V), W, false).Else if IsPropertyReference(V) is true, thenIf HasPrimitiveBase(V) is true, thenAssert: In this case, base will never be undefined or null.Set base to ! ToObject(base).Let succeeded be ? base.[[Set]](GetReferencedName(V), W, GetThisValue(V)).If succeeded is false and IsStrictReference(V) is true, throw a TypeError exception.Return.Else base must be an Environment Record,Return ? base.SetMutableBinding(GetReferencedName(V), W, IsStrictReference(V)) (see 8.1.1).          Note The object that may be created in step 6.a.ii is not  accessible outside of the above algorithm and the ordinary object  [[Set]] internal method. An implementation might choose to avoid the  actual creation of that object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.4.3">
	<buginformation>
		<summary>GetThisValue ( V )</summary>
		<description>Assert: IsPropertyReference(V) is true.If IsSuperReference(V) is true, thenReturn the value of the thisValue component of the reference V.Return GetBase(V).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.4.4">
	<buginformation>
		<summary>InitializeReferencedBinding ( V, W )</summary>
		<description>ReturnIfAbrupt(V).ReturnIfAbrupt(W).Assert: Type(V) is Reference.Assert: IsUnresolvableReference(V) is false.Let base be GetBase(V).Assert: base is an Environment Record.Return base.InitializeBinding(GetReferencedName(V), W).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.5.1">
	<buginformation>
		<summary>IsAccessorDescriptor ( Desc )</summary>
		<description>When the abstract operation IsAccessorDescriptor is called with Property Descriptor Desc, the following steps are taken: If Desc is undefined, return false.If both Desc.[[Get]] and Desc.[[Set]] are absent, return false.Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.5.2">
	<buginformation>
		<summary>IsDataDescriptor ( Desc )</summary>
		<description>When the abstract operation IsDataDescriptor is called with Property Descriptor Desc, the following steps are taken: If Desc is undefined, return false.If both Desc.[[Value]] and Desc.[[Writable]] are absent, return false.Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.5.3">
	<buginformation>
		<summary>IsGenericDescriptor ( Desc )</summary>
		<description>When the abstract operation IsGenericDescriptor is called with Property Descriptor Desc, the following steps are taken: If Desc is undefined, return false.If IsAccessorDescriptor(Desc) and IsDataDescriptor(Desc) are both false, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.5.4">
	<buginformation>
		<summary>FromPropertyDescriptor ( Desc )</summary>
		<description>When the abstract operation FromPropertyDescriptor is called with Property Descriptor Desc, the following steps are taken: If Desc is undefined, return undefined.Let obj be ObjectCreate(%ObjectPrototype%).Assert: obj is an extensible ordinary object with no own properties.If Desc has a [[Value]] field, thenPerform CreateDataProperty(obj, &amp;quot;value&amp;quot;, Desc.[[Value]]).If Desc has a [[Writable]] field, thenPerform CreateDataProperty(obj, &amp;quot;writable&amp;quot;, Desc.[[Writable]]).If Desc has a [[Get]] field, thenPerform CreateDataProperty(obj, &amp;quot;get&amp;quot;, Desc.[[Get]]).If Desc has a [[Set]] field, thenPerform CreateDataProperty(obj, &amp;quot;set&amp;quot;, Desc.[[Set]]).If Desc has an [[Enumerable]] field, thenPerform CreateDataProperty(obj, &amp;quot;enumerable&amp;quot;, Desc.[[Enumerable]]).If Desc has a [[Configurable]] field, thenPerform CreateDataProperty(obj, &amp;quot;configurable&amp;quot;, Desc.[[Configurable]]).Assert: All of the above CreateDataProperty operations return true.Return obj.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.5.5">
	<buginformation>
		<summary>ToPropertyDescriptor ( Obj )</summary>
		<description>When the abstract operation ToPropertyDescriptor is called with object Obj, the following steps are taken: If Type(Obj) is not Object, throw a TypeError exception.Let desc be a new Property Descriptor that initially has no fields.Let hasEnumerable be ? HasProperty(Obj, &amp;quot;enumerable&amp;quot;).If hasEnumerable is true, thenLet enum be ToBoolean(? Get(Obj, &amp;quot;enumerable&amp;quot;)).Set desc.[[Enumerable]] to enum.Let hasConfigurable be ? HasProperty(Obj, &amp;quot;configurable&amp;quot;).If hasConfigurable is true, thenLet conf be ToBoolean(? Get(Obj, &amp;quot;configurable&amp;quot;)).Set desc.[[Configurable]] to conf.Let hasValue be ? HasProperty(Obj, &amp;quot;value&amp;quot;).If hasValue is true, thenLet value be ? Get(Obj, &amp;quot;value&amp;quot;).Set desc.[[Value]] to value.Let hasWritable be ? HasProperty(Obj, &amp;quot;writable&amp;quot;).If hasWritable is true, thenLet writable be ToBoolean(? Get(Obj, &amp;quot;writable&amp;quot;)).Set desc.[[Writable]] to writable.Let hasGet be ? HasProperty(Obj, &amp;quot;get&amp;quot;).If hasGet is true, thenLet getter be ? Get(Obj, &amp;quot;get&amp;quot;).If IsCallable(getter) is false and getter is not undefined, throw a TypeError exception.Set desc.[[Get]] to getter.Let hasSet be ? HasProperty(Obj, &amp;quot;set&amp;quot;).If hasSet is true, thenLet setter be ? Get(Obj, &amp;quot;set&amp;quot;).If IsCallable(setter) is false and setter is not undefined, throw a TypeError exception.Set desc.[[Set]] to setter.If desc.[[Get]] is present or desc.[[Set]] is present, thenIf desc.[[Value]] is present or desc.[[Writable]] is present, throw a TypeError exception.Return desc.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.5.6">
	<buginformation>
		<summary>CompletePropertyDescriptor ( Desc )</summary>
		<description>When the abstract operation CompletePropertyDescriptor is called with Property Descriptor Desc, the following steps are taken: Assert: Desc is a Property Descriptor.Let like be Record{[[Value]]: undefined, [[Writable]]: false, [[Get]]: undefined, [[Set]]: undefined, [[Enumerable]]: false, [[Configurable]]: false}.If IsGenericDescriptor(Desc) is true or IsDataDescriptor(Desc) is true, thenIf Desc does not have a [[Value]] field, set Desc.[[Value]] to like.[[Value]].If Desc does not have a [[Writable]] field, set Desc.[[Writable]] to like.[[Writable]].Else,If Desc does not have a [[Get]] field, set Desc.[[Get]] to like.[[Get]].If Desc does not have a [[Set]] field, set Desc.[[Set]] to like.[[Set]].If Desc does not have an [[Enumerable]] field, set Desc.[[Enumerable]] to like.[[Enumerable]].If Desc does not have a [[Configurable]] field, set Desc.[[Configurable]] to like.[[Configurable]].Return Desc.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.6">
	<buginformation>
		<summary>The Lexical Environment and Environment Record Specification Types</summary>
		<description>The Lexical Environment and Environment Record  types are used to explain the behaviour of name resolution in nested  functions and blocks. These types and the operations upon them are  defined in  8.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.7.1">
	<buginformation>
		<summary>CreateByteDataBlock ( size )</summary>
		<description>When the abstract operation CreateByteDataBlock is called with integer argument size, the following steps are taken: Assert: size≥0.Let db be a new Data Block value consisting of size bytes. If it is impossible to create such a Data Block, throw a RangeError exception.Set all of the bytes of db to 0.Return db.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.7.2">
	<buginformation>
		<summary>CreateSharedByteDataBlock( size )</summary>
		<description>When the abstract operation CreateSharedByteDataBlock is called with integer argument size, the following steps are taken: Assert: size≥0.Let db be a new Shared Data Block value consisting of size bytes. If it is impossible to create such a Shared Data Block, throw a RangeError exception.Let execution be the [[CandidateExecution]] field of the surrounding agent&apos;s Agent Record.Let eventList be the [[EventList]] field of the element in execution.[[EventLists]] whose [[AgentSignifier]] is AgentSignifier().Let zero be « 0 ».For each index i of db, doAppend WriteSharedMemory{ [[Order]]: &amp;quot;Init&amp;quot;, [[NoTear]]: true, [[Block]]: db, [[ByteIndex]]: i, [[ElementSize]]: 1, [[Payload]]: zero } to eventList.Return db.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="6.2.7.3">
	<buginformation>
		<summary>CopyDataBlockBytes ( toBlock, toIndex, fromBlock, fromIndex, count )</summary>
		<description>When the abstract operation CopyDataBlockBytes is called, the following steps are taken: Assert: fromBlock and toBlock are distinct Data Block or Shared Data Block values.Assert: fromIndex, toIndex, and count are integer values ≥ 0.Let fromSize be the number of bytes in fromBlock.Assert: fromIndex+count ≤ fromSize.Let toSize be the number of bytes in toBlock.Assert: toIndex+count ≤ toSize.Repeat, while count&gt;0If fromBlock is a Shared Data Block, thenLet execution be the [[CandidateExecution]] field of the surrounding agent&apos;s Agent Record.Let eventList be the [[EventList]] field of the element in execution.[[EventLists]] whose [[AgentSignifier]] is AgentSignifier().Let bytes be a List of length 1 that contains a nondeterministically chosen byte value.NOTE: In implementations, bytes  is the result of a non-atomic read instruction on the underlying  hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.Let readEvent be ReadSharedMemory{ [[Order]]: &amp;quot;Unordered&amp;quot;, [[NoTear]]: true, [[Block]]: fromBlock, [[ByteIndex]]: fromIndex, [[ElementSize]]: 1 }.Append readEvent to eventList.Append WriteSharedMemory{ [[Order]]: &amp;quot;Unordered&amp;quot;, [[NoTear]]: true, [[Block]]: toBlock, [[ByteIndex]]: toIndex, [[ElementSize]]: 1, [[Payload]]: bytes } to eventList.Append Chosen Value Record { [[Event]]: readEvent, [[ChosenValue]]: bytes } to execution.[[ChosenValues]].Otherwise, set toBlock[toIndex] to fromBlock[fromIndex].Increment toIndex and fromIndex each by 1.Decrement count by 1.Return NormalCompletion(empty).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.1.1.1">
	<buginformation>
		<summary>OrdinaryToPrimitive ( O, hint )</summary>
		<description>When the abstract operation OrdinaryToPrimitive is called with arguments O and hint, the following steps are taken: Assert: Type(O) is Object.Assert: Type(hint) is String and its value is either &amp;quot;string&amp;quot; or &amp;quot;number&amp;quot;.If hint is &amp;quot;string&amp;quot;, thenLet methodNames be « &amp;quot;toString&amp;quot;, &amp;quot;valueOf&amp;quot; ».Else,Let methodNames be « &amp;quot;valueOf&amp;quot;, &amp;quot;toString&amp;quot; ».For each name in methodNames in List order, doLet method be ? Get(O, name).If IsCallable(method) is true, thenLet result be ? Call(method, O).If Type(result) is not Object, return result.Throw a TypeError exception.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.1.2">
	<buginformation>
		<summary>ToBoolean ( argument )</summary>
		<description>The abstract operation ToBoolean converts argument to a value of type Boolean according to  Table 9: Table 9: ToBoolean Conversions                   Argument Type                                          Result                                            Undefined                                          Return false.                                            Null                                          Return false.                                            Boolean                                          Return argument.                                            Number                                          If argument is +0, -0, or NaN, return false; otherwise return true.                                            String                                          If argument is the empty String (its length is zero), return false; otherwise return true.                                            Symbol                                          Return true.                                            Object                                          Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.1.3.1.1">
	<buginformation>
		<summary>Runtime Semantics: MV</summary>
		<description>The conversion of a String to a Number value is similar  overall to the determination of the Number value for a numeric literal  (see  11.8.3),  but some of the details are different, so the process for converting a  String numeric literal to a value of Number type is given here. This  value is determined in two steps: first, a mathematical value (MV) is  derived from the String numeric literal; second, this mathematical value  is rounded as described below. The MV on any grammar symbol, not  provided below, is the MV for that symbol defined in  11.8.3.1.                 The MV of   StringNumericLiteral:::[empty]  is 0.                                          The MV of   StringNumericLiteral:::StrWhiteSpace  is 0.                                          The MV of   StringNumericLiteral:::StrWhiteSpaceoptStrNumericLiteralStrWhiteSpaceopt  is the MV of StrNumericLiteral, no matter whether white space is present or not.                                          The MV of   StrNumericLiteral:::StrDecimalLiteral  is the MV of StrDecimalLiteral.                                          The MV of   StrNumericLiteral:::BinaryIntegerLiteral  is the MV of BinaryIntegerLiteral.                                          The MV of   StrNumericLiteral:::OctalIntegerLiteral  is the MV of OctalIntegerLiteral.                                          The MV of   StrNumericLiteral:::HexIntegerLiteral  is the MV of HexIntegerLiteral.                                          The MV of   StrDecimalLiteral:::StrUnsignedDecimalLiteral  is the MV of StrUnsignedDecimalLiteral.                                          The MV of   StrDecimalLiteral:::+StrUnsignedDecimalLiteral  is the MV of StrUnsignedDecimalLiteral.                                          The MV of   StrDecimalLiteral:::-StrUnsignedDecimalLiteral  is the negative of the MV of StrUnsignedDecimalLiteral. (Note that if the MV of StrUnsignedDecimalLiteral  is 0, the negative of this MV is also 0. The rounding rule described  below handles the conversion of this signless mathematical zero to a  floating-point +0 or -0 as appropriate.)                                          The MV of   StrUnsignedDecimalLiteral:::Infinity  is 1010000 (a value so large that it will round to +∞).                                          The MV of   StrUnsignedDecimalLiteral:::DecimalDigits.  is the MV of DecimalDigits.                                          The MV of   StrUnsignedDecimalLiteral:::DecimalDigits.DecimalDigits  is the MV of the first DecimalDigits plus (the MV of the second DecimalDigits times 10-n), where n is the number of code points in the second DecimalDigits.                                          The MV of   StrUnsignedDecimalLiteral:::DecimalDigits.ExponentPart  is the MV of DecimalDigits times 10e, where e is the MV of ExponentPart.                                          The MV of   StrUnsignedDecimalLiteral:::DecimalDigits.DecimalDigitsExponentPart  is (the MV of the first DecimalDigits plus (the MV of the second DecimalDigits times 10-n)) times 10e, where n is the number of code points in the second DecimalDigits and e is the MV of ExponentPart.                                          The MV of   StrUnsignedDecimalLiteral:::.DecimalDigits  is the MV of DecimalDigits times 10-n, where n is the number of code points in DecimalDigits.                                          The MV of   StrUnsignedDecimalLiteral:::.DecimalDigitsExponentPart  is the MV of DecimalDigits times 10e-n, where n is the number of code points in DecimalDigits and e is the MV of ExponentPart.                                          The MV of   StrUnsignedDecimalLiteral:::DecimalDigits  is the MV of DecimalDigits.                                          The MV of   StrUnsignedDecimalLiteral:::DecimalDigitsExponentPart  is the MV of DecimalDigits times 10e, where e is the MV of ExponentPart.                            Once the exact MV for a String numeric literal has been  determined, it is then rounded to a value of the Number type. If the MV  is 0, then the rounded value is +0 unless the first non white space code point in the String numeric literal is &amp;quot;-&amp;quot;, in which case the rounded value is -0. Otherwise, the rounded value must be the Number value for the MV (in the sense defined in  6.1.6), unless the literal includes a StrUnsignedDecimalLiteral  and the literal has more than 20 significant digits, in which case the  Number value may be either the Number value for the MV of a literal  produced by replacing each significant digit after the 20th with a 0  digit or the Number value for the MV of a literal produced by replacing  each significant digit after the 20th with a 0 digit and then  incrementing the literal at the 20th digit position. A digit is  significant if it is not part of an ExponentPart and                 it is not 0; or                                          there is a nonzero digit to its left and there is a nonzero digit, not in the ExponentPart, to its right.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.1.4">
	<buginformation>
		<summary>ToInteger ( argument )</summary>
		<description>The abstract operation ToInteger converts argument to an integral numeric value. This abstract operation functions as follows: Let number be ? ToNumber(argument).If number is NaN, return +0.If number is +0, -0, +∞, or -∞, return number.Return the number value that is the same sign as number and whose magnitude is floor(abs(number)).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.1.5">
	<buginformation>
		<summary>ToInt32 ( argument )</summary>
		<description>The abstract operation ToInt32 converts argument to one of 232 integer values in the range  -231 through  231-1, inclusive. This abstract operation functions as follows: Let number be ? ToNumber(argument).If number is NaN, +0, -0, +∞, or -∞, return +0.Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).Let int32bit be int modulo 232.If int32bit ≥ 231, return int32bit - 232; otherwise return int32bit.        Note Given the above definition of ToInt32:               The ToInt32 abstract operation is idempotent: if applied to a  result that it produced, the second application leaves that value  unchanged.                                    ToInt32(ToUint32(x)) is equal to ToInt32(x) for all values of x. (It is to preserve this latter property that +∞ and -∞ are mapped to +0.)                                    ToInt32 maps -0 to +0.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.1.6">
	<buginformation>
		<summary>ToUint32 ( argument )</summary>
		<description>The abstract operation ToUint32 converts argument to one of 232 integer values in the range 0 through  232-1, inclusive. This abstract operation functions as follows: Let number be ? ToNumber(argument).If number is NaN, +0, -0, +∞, or -∞, return +0.Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).Let int32bit be int modulo 232.Return int32bit.        Note Given the above definition of ToUint32:               Step 5 is the only difference between ToUint32 and ToInt32.                                    The ToUint32 abstract operation is idempotent: if applied to  a result that it produced, the second application leaves that value  unchanged.                                    ToUint32(ToInt32(x)) is equal to ToUint32(x) for all values of x. (It is to preserve this latter property that +∞ and -∞ are mapped to +0.)                                    ToUint32 maps -0 to +0.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.1.7">
	<buginformation>
		<summary>ToInt16 ( argument )</summary>
		<description>The abstract operation ToInt16 converts argument to one of 216 integer values in the range -32768 through 32767, inclusive. This abstract operation functions as follows: Let number be ? ToNumber(argument).If number is NaN, +0, -0, +∞, or -∞, return +0.Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).Let int16bit be int modulo 216.If int16bit ≥ 215, return int16bit - 216; otherwise return int16bit.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.1.8">
	<buginformation>
		<summary>ToUint16 ( argument )</summary>
		<description>The abstract operation ToUint16 converts argument to one of 216 integer values in the range 0 through  216-1, inclusive. This abstract operation functions as follows: Let number be ? ToNumber(argument).If number is NaN, +0, -0, +∞, or -∞, return +0.Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).Let int16bit be int modulo 216.Return int16bit.        Note Given the above definition of ToUint16:               The substitution of 216 for 232 in step 4 is the only difference between ToUint32 and ToUint16.                                    ToUint16 maps -0 to +0.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.1.9">
	<buginformation>
		<summary>ToInt8 ( argument )</summary>
		<description>The abstract operation ToInt8 converts argument to one of 28 integer values in the range -128 through 127, inclusive. This abstract operation functions as follows: Let number be ? ToNumber(argument).If number is NaN, +0, -0, +∞, or -∞, return +0.Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).Let int8bit be int modulo 28.If int8bit ≥ 27, return int8bit - 28; otherwise return int8bit.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.1.10">
	<buginformation>
		<summary>ToUint8 ( argument )</summary>
		<description>The abstract operation ToUint8 converts argument to one of 28 integer values in the range 0 through 255, inclusive. This abstract operation functions as follows: Let number be ? ToNumber(argument).If number is NaN, +0, -0, +∞, or -∞, return +0.Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).Let int8bit be int modulo 28.Return int8bit.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.1.11">
	<buginformation>
		<summary>ToUint8Clamp ( argument )</summary>
		<description>The abstract operation ToUint8Clamp converts argument to one of 28 integer values in the range 0 through 255, inclusive. This abstract operation functions as follows: Let number be ? ToNumber(argument).If number is NaN, return +0.If number ≤ 0, return +0.If number ≥ 255, return 255.Let f be floor(number).If f + 0.5 &lt; number, return f + 1.If number &lt; f + 0.5, return f.If f is odd, return f + 1.Return f.        Note Unlike the other ECMAScript integer conversion abstract  operation, ToUint8Clamp rounds rather than truncates non-integer values  and does not convert +∞ to 0. ToUint8Clamp does “round half to even” tie-breaking. This differs from Math.round which does “round half up” tie-breaking.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.1.12.1">
	<buginformation>
		<summary>ToString Applied to the Number Type</summary>
		<description>The abstract operation ToString converts a Number m to String format as follows: If m is NaN, return the String &amp;quot;NaN&amp;quot;.If m is +0 or -0, return the String &amp;quot;0&amp;quot;.If m is less than zero, return the String concatenation of the String &amp;quot;-&amp;quot; and ! ToString(-m).If m is +∞, return the String &amp;quot;Infinity&amp;quot;.Otherwise, let n, k, and s be integers such that k ≥ 1, 10k-1 ≤ s &lt; 10k, the Number value for s × 10n-k is m, and k is as small as possible. Note that k is the number of digits in the decimal representation of s, that s is not divisible by 10, and that the least significant digit of s is not necessarily uniquely determined by these criteria.If k ≤ n ≤ 21, return the String consisting of the code units of the k digits of the decimal representation of s (in order, with no leading zeroes), followed by n-k occurrences of the code unit 0x0030 (DIGIT ZERO).If 0 &lt; n ≤ 21, return the String consisting of the code units of the most significant n digits of the decimal representation of s, followed by the code unit 0x002E (FULL STOP), followed by the code units of the remaining k-n digits of the decimal representation of s.If -6 &lt; n  ≤ 0, return the String consisting of the code unit 0x0030 (DIGIT ZERO),  followed by the code unit 0x002E (FULL STOP), followed by -n occurrences of the code unit 0x0030 (DIGIT ZERO), followed by the code units of the k digits of the decimal representation of s.Otherwise, if k</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.1.13">
	<buginformation>
		<summary>ToObject ( argument )</summary>
		<description>The abstract operation ToObject converts argument to a value of type Object according to  Table 12: Table 12: ToObject Conversions                   Argument Type                                          Result                                            Undefined                                          Throw a TypeError exception.                                            Null                                          Throw a TypeError exception.                                            Boolean                                          Return a new Boolean object whose [[BooleanData]] internal slot is set to argument. See  19.3 for a description of Boolean objects.                                            Number                                          Return a new Number object whose [[NumberData]] internal slot is set to argument. See  20.1 for a description of Number objects.                                            String                                          Return a new String object whose [[StringData]] internal slot is set to argument. See  21.1 for a description of String objects.                                            Symbol                                          Return a new Symbol object whose [[SymbolData]] internal slot is set to argument. See  19.4 for a description of Symbol objects.                                            Object                                          Return argument.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.1.14">
	<buginformation>
		<summary>ToPropertyKey ( argument )</summary>
		<description>The abstract operation ToPropertyKey converts argument to a value that can be used as a property key by performing the following steps: Let key be ? ToPrimitive(argument, hint String).If Type(key) is Symbol, thenReturn key.Return ! ToString(key).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.1.15">
	<buginformation>
		<summary>ToLength ( argument )</summary>
		<description>The abstract operation ToLength converts argument to an integer suitable for use as the length of an array-like object. It performs the following steps: Let len be ? ToInteger(argument).If len ≤ +0, return +0.Return min(len, 253-1).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.1.16">
	<buginformation>
		<summary>CanonicalNumericIndexString ( argument )</summary>
		<description>The abstract operation CanonicalNumericIndexString returns argument converted to a numeric value if it is a String representation of a Number that would be produced by ToString, or the string &amp;quot;-0&amp;quot;. Otherwise, it returns undefined. This abstract operation functions as follows: Assert: Type(argument) is String.If argument is &amp;quot;-0&amp;quot;, return -0.Let n be ! ToNumber(argument).If SameValue(! ToString(n), argument) is false, return undefined.Return n.        A  canonical numeric string is any String value for which the CanonicalNumericIndexString abstract operation does not return undefined.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.1.17">
	<buginformation>
		<summary>ToIndex ( value )</summary>
		<description>The abstract operation ToIndex returns value argument converted to a numeric value if it is a valid integer index value. This abstract operation functions as follows: If value is undefined, thenLet index be 0.Else,Let integerIndex be ? ToInteger(value).If integerIndex &lt; 0, throw a RangeError exception.Let index be ! ToLength(integerIndex).If SameValueZero(integerIndex, index) is false, throw a RangeError exception.Return index.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.2.1">
	<buginformation>
		<summary>RequireObjectCoercible ( argument )</summary>
		<description>The abstract operation RequireObjectCoercible throws an error if argument is a value that cannot be converted to an Object using ToObject. It is defined by  Table 13: Table 13: RequireObjectCoercible Results                   Argument Type                                          Result                                            Undefined                                          Throw a TypeError exception.                                            Null                                          Throw a TypeError exception.                                            Boolean                                          Return argument.                                            Number                                          Return argument.                                            String                                          Return argument.                                            Symbol                                          Return argument.                                            Object                                          Return argument.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.2.2">
	<buginformation>
		<summary>IsArray ( argument )</summary>
		<description>The abstract operation IsArray takes one argument argument, and performs the following steps: If Type(argument) is not Object, return false.If argument is an Array exotic object, return true.If argument is a Proxy exotic object, thenIf argument.[[ProxyHandler]] is null, throw a TypeError exception.Let target be argument.[[ProxyTarget]].Return ? IsArray(target).Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.2.3">
	<buginformation>
		<summary>IsCallable ( argument )</summary>
		<description>The abstract operation IsCallable determines if argument, which must be an ECMAScript language value, is a callable function with a [[Call]] internal method. If Type(argument) is not Object, return false.If argument has a [[Call]] internal method, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.2.4">
	<buginformation>
		<summary>IsConstructor ( argument )</summary>
		<description>The abstract operation IsConstructor determines if argument, which must be an ECMAScript language value, is a function object with a [[Construct]] internal method. If Type(argument) is not Object, return false.If argument has a [[Construct]] internal method, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.2.5">
	<buginformation>
		<summary>IsExtensible ( O )</summary>
		<description>The abstract operation IsExtensible is used to determine whether additional properties can be added to the object that is O. A Boolean value is returned. This abstract operation performs the following steps: Assert: Type(O) is Object.Return ? O.[[IsExtensible]]().</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.2.6">
	<buginformation>
		<summary>IsInteger ( argument )</summary>
		<description>The abstract operation IsInteger determines if argument is a finite integer numeric value. If Type(argument) is not Number, return false.If argument is NaN, +∞, or -∞, return false.If floor(abs(argument)) ≠ abs(argument), return false.Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.2.7">
	<buginformation>
		<summary>IsPropertyKey ( argument )</summary>
		<description>The abstract operation IsPropertyKey determines if argument, which must be an ECMAScript language value, is a value that may be used as a property key. If Type(argument) is String, return true.If Type(argument) is Symbol, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.2.8">
	<buginformation>
		<summary>IsRegExp ( argument )</summary>
		<description>The abstract operation IsRegExp with argument argument performs the following steps: If Type(argument) is not Object, return false.Let isRegExp be ? Get(argument, @@match).If isRegExp is not undefined, return ToBoolean(isRegExp).If argument has a [[RegExpMatcher]] internal slot, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.2.9">
	<buginformation>
		<summary>SameValue ( x, y )</summary>
		<description>The internal comparison abstract operation SameValue(x, y), where x and y are ECMAScript language values, produces true or false. Such a comparison is performed as follows: If Type(x) is different from Type(y), return false.If Type(x) is Number, thenIf x is NaN and y is NaN, return true.If x is +0 and y is -0, return false.If x is -0 and y is +0, return false.If x is the same Number value as y, return true.Return false.Return SameValueNonNumber(x, y).        Note This algorithm differs from the Strict Equality Comparison Algorithm in its treatment of signed zeroes and NaNs.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.2.10">
	<buginformation>
		<summary>SameValueZero ( x, y )</summary>
		<description>The internal comparison abstract operation SameValueZero(x, y), where x and y are ECMAScript language values, produces true or false. Such a comparison is performed as follows: If Type(x) is different from Type(y), return false.If Type(x) is Number, thenIf x is NaN and y is NaN, return true.If x is +0 and y is -0, return true.If x is -0 and y is +0, return true.If x is the same Number value as y, return true.Return false.Return SameValueNonNumber(x, y).        Note SameValueZero differs from SameValue only in its treatment of +0 and -0.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.2.11">
	<buginformation>
		<summary>SameValueNonNumber ( x, y )</summary>
		<description>The internal comparison abstract operation SameValueNonNumber(x, y), where neither x nor y are Number values, produces true or false. Such a comparison is performed as follows: Assert: Type(x) is not Number.Assert: Type(x) is the same as Type(y).If Type(x) is Undefined, return true.If Type(x) is Null, return true.If Type(x) is String, thenIf x and y are exactly the same sequence of code units (same length and same code units at corresponding indices), return true; otherwise, return false.If Type(x) is Boolean, thenIf x and y are both true or both false, return true; otherwise, return false.If Type(x) is Symbol, thenIf x and y are both the same Symbol value, return true; otherwise, return false.If x and y are the same Object value, return true. Otherwise, return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.2.12">
	<buginformation>
		<summary>Abstract Relational Comparison</summary>
		<description>The comparison x &lt; y, where x and y are values, produces true, false, or undefined (which indicates that at least one operand is NaN). In addition to x and y the algorithm takes a Boolean flag named LeftFirst  as a parameter. The flag is used to control the order in which  operations with potentially visible side-effects are performed upon x and y. It is necessary because ECMAScript specifies left to right evaluation of expressions. The default value of LeftFirst is true and indicates that the x parameter corresponds to an expression that occurs to the left of the y parameter&apos;s corresponding expression. If LeftFirst is false, the reverse is the case and operations must be performed upon y before x. Such a comparison is performed as follows: If the LeftFirst flag is true, thenLet px be ? ToPrimitive(x, hint Number).Let py be ? ToPrimitive(y, hint Number).Else the order of evaluation needs to be reversed to preserve left to right evaluation,Let py be ? ToPrimitive(y, hint Number).Let px be ? ToPrimitive(x, hint Number).If both px and py are Strings, thenIf py is a prefix of px, return false. (A String value p is a prefix of String value q if q can be the result of concatenating p and some other String r. Note that any String is a prefix of itself, because r may be the empty String.)If px is a prefix of py, return true.Let k be the smallest nonnegative integer such that the code unit at index k within px is different from the code unit at index k within py. (There must be such a k, for neither String is a prefix of the other.)Let m be the integer that is the code unit value at index k within px.Let n be the integer that is the code unit value at index k within py.If m &lt; n, return true. Otherwise, return false.Else,Let nx be ? ToNumber(px). Because px and py are primitive values evaluation order is not important.Let ny be ? ToNumber(py).If nx is NaN, return undefined.If ny is NaN, return undefined.If nx and ny are the same Number value, return false.If nx is +0 and ny is -0, return false.If nx is -0 and ny is +0, return false.If nx is +∞, return false.If ny is +∞, return true.If ny is -∞, return false.If nx is -∞, return true.If the mathematical value of nx is less than the mathematical value of ny —note that these mathematical values are both finite and not both zero—return true. Otherwise, return false.        Note 1 Step 3 differs from step 7 in the algorithm for the addition operator + (12.8.3) in using “and” instead of “or”.  Note 2 The comparison of Strings uses a simple lexicographic  ordering on sequences of code unit values. There is no attempt to use  the more complex, semantically oriented definitions of character or  string equality and collating order defined in the Unicode  specification. Therefore String values that are canonically equal  according to the Unicode standard could test as unequal. In effect this  algorithm assumes that both Strings are already in normalized form.  Also, note that for strings containing supplementary characters,  lexicographic ordering on sequences of UTF-16 code unit values differs  from that on sequences of code point values.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.2.13">
	<buginformation>
		<summary>Abstract Equality Comparison</summary>
		<description>The comparison x</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.2.14">
	<buginformation>
		<summary>Strict Equality Comparison</summary>
		<description>The comparison x</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.1">
	<buginformation>
		<summary>Get ( O, P )</summary>
		<description>The abstract operation Get is used to retrieve the value of a  specific property of an object. The operation is called with arguments O and P where O is the object and P is the property key. This abstract operation performs the following steps: Assert: Type(O) is Object.Assert: IsPropertyKey(P) is true.Return ? O.[[Get]](P, O).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.2">
	<buginformation>
		<summary>GetV ( V, P )</summary>
		<description>The abstract operation GetV is used to retrieve the value of a specific property of an ECMAScript language value.  If the value is not an object, the property lookup is performed using a  wrapper object appropriate for the type of the value. The operation is  called with arguments V and P where V is the value and P is the property key. This abstract operation performs the following steps: Assert: IsPropertyKey(P) is true.Let O be ? ToObject(V).Return ? O.[[Get]](P, V).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.3">
	<buginformation>
		<summary>Set ( O, P, V, Throw )</summary>
		<description>The abstract operation Set is used to set the value of a specific property of an object. The operation is called with arguments O, P, V, and Throw where O is the object, P is the property key, V is the new value for the property and Throw is a Boolean flag. This abstract operation performs the following steps: Assert: Type(O) is Object.Assert: IsPropertyKey(P) is true.Assert: Type(Throw) is Boolean.Let success be ? O.[[Set]](P, V, O).If success is false and Throw is true, throw a TypeError exception.Return success.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.4">
	<buginformation>
		<summary>CreateDataProperty ( O, P, V )</summary>
		<description>The abstract operation CreateDataProperty is used to create a  new own property of an object. The operation is called with arguments O, P, and V where O is the object, P is the property key, and V is the value for the property. This abstract operation performs the following steps: Assert: Type(O) is Object.Assert: IsPropertyKey(P) is true.Let newDesc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}.Return ? O.[[DefineOwnProperty]](P, newDesc).        Note This abstract operation creates a property whose attributes  are set to the same defaults used for properties created by the  ECMAScript language assignment operator. Normally, the property will not  already exist. If it does exist and is not configurable or if O is not extensible, [[DefineOwnProperty]] will return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.5">
	<buginformation>
		<summary>CreateMethodProperty ( O, P, V )</summary>
		<description>The abstract operation CreateMethodProperty is used to create a  new own property of an object. The operation is called with arguments O, P, and V where O is the object, P is the property key, and V is the value for the property. This abstract operation performs the following steps: Assert: Type(O) is Object.Assert: IsPropertyKey(P) is true.Let newDesc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}.Return ? O.[[DefineOwnProperty]](P, newDesc).        Note This abstract operation creates a property whose attributes  are set to the same defaults used for built-in methods and methods  defined using class declaration syntax. Normally, the property will not  already exist. If it does exist and is not configurable or if O is not extensible, [[DefineOwnProperty]] will return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.6">
	<buginformation>
		<summary>CreateDataPropertyOrThrow ( O, P, V )</summary>
		<description>The abstract operation CreateDataPropertyOrThrow is used to create a new own property of an object. It throws a TypeError exception if the requested property update cannot be performed. The operation is called with arguments O, P, and V where O is the object, P is the property key, and V is the value for the property. This abstract operation performs the following steps: Assert: Type(O) is Object.Assert: IsPropertyKey(P) is true.Let success be ? CreateDataProperty(O, P, V).If success is false, throw a TypeError exception.Return success.        Note This abstract operation creates a property whose attributes  are set to the same defaults used for properties created by the  ECMAScript language assignment operator. Normally, the property will not  already exist. If it does exist and is not configurable or if O is not extensible, [[DefineOwnProperty]] will return false causing this operation to throw a TypeError exception.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.7">
	<buginformation>
		<summary>DefinePropertyOrThrow ( O, P, desc )</summary>
		<description>The abstract operation DefinePropertyOrThrow is used to call  the [[DefineOwnProperty]] internal method of an object in a manner that  will throw a TypeError exception if the requested property update cannot be performed. The operation is called with arguments O, P, and desc where O is the object, P is the property key, and desc is the Property Descriptor for the property. This abstract operation performs the following steps: Assert: Type(O) is Object.Assert: IsPropertyKey(P) is true.Let success be ? O.[[DefineOwnProperty]](P, desc).If success is false, throw a TypeError exception.Return success.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.8">
	<buginformation>
		<summary>DeletePropertyOrThrow ( O, P )</summary>
		<description>The abstract operation DeletePropertyOrThrow is used to remove a  specific own property of an object. It throws an exception if the  property is not configurable. The operation is called with arguments O and P where O is the object and P is the property key. This abstract operation performs the following steps: Assert: Type(O) is Object.Assert: IsPropertyKey(P) is true.Let success be ? O.[[Delete]](P).If success is false, throw a TypeError exception.Return success.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.9">
	<buginformation>
		<summary>GetMethod ( V, P )</summary>
		<description>The abstract operation GetMethod is used to get the value of a specific property of an ECMAScript language value when the value of the property is expected to be a function. The operation is called with arguments V and P where V is the ECMAScript language value, P is the property key. This abstract operation performs the following steps: Assert: IsPropertyKey(P) is true.Let func be ? GetV(V, P).If func is either undefined or null, return undefined.If IsCallable(func) is false, throw a TypeError exception.Return func.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.10">
	<buginformation>
		<summary>HasProperty ( O, P )</summary>
		<description>The abstract operation HasProperty is used to determine whether  an object has a property with the specified property key. The property  may be either an own or inherited. A Boolean value is returned. The  operation is called with arguments O and P where O is the object and P is the property key. This abstract operation performs the following steps: Assert: Type(O) is Object.Assert: IsPropertyKey(P) is true.Return ? O.[[HasProperty]](P).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.11">
	<buginformation>
		<summary>HasOwnProperty ( O, P )</summary>
		<description>The abstract operation HasOwnProperty is used to determine  whether an object has an own property with the specified property key. A  Boolean value is returned. The operation is called with arguments O and P where O is the object and P is the property key. This abstract operation performs the following steps: Assert: Type(O) is Object.Assert: IsPropertyKey(P) is true.Let desc be ? O.[[GetOwnProperty]](P).If desc is undefined, return false.Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.12">
	<buginformation>
		<summary>Call ( F, V [ , argumentsList ] )</summary>
		<description>The abstract operation Call is used to call the [[Call]]  internal method of a function object. The operation is called with  arguments F, V, and optionally argumentsList where F is the function object, V is an ECMAScript language value that is the this value of the [[Call]], and argumentsList is the value passed to the corresponding argument of the internal method. If argumentsList is not present, a new empty List is used as its value. This abstract operation performs the following steps: If argumentsList was not passed, set argumentsList to a new empty List.If IsCallable(F) is false, throw a TypeError exception.Return ? F.[[Call]](V, argumentsList).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.13">
	<buginformation>
		<summary>Construct ( F [ , argumentsList [ , newTarget ]] )</summary>
		<description>The abstract operation Construct is used to call the  [[Construct]] internal method of a function object. The operation is  called with arguments F, and optionally argumentsList, and newTarget where F is the function object. argumentsList and newTarget are the values to be passed as the corresponding arguments of the internal method. If argumentsList is not present, a new empty List is used as its value. If newTarget is not present, F is used as its value. This abstract operation performs the following steps: If newTarget was not passed, set newTarget to F.If argumentsList was not passed, set argumentsList to a new empty List.Assert: IsConstructor(F) is true.Assert: IsConstructor(newTarget) is true.Return ? F.[[Construct]](argumentsList, newTarget).        Note If newTarget is not passed, this operation is equivalent to: new F(...argumentsList)</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.14">
	<buginformation>
		<summary>SetIntegrityLevel ( O, level )</summary>
		<description>The abstract operation SetIntegrityLevel is used to fix the set  of own properties of an object. This abstract operation performs the  following steps: Assert: Type(O) is Object.Assert: level is either &amp;quot;sealed&amp;quot; or &amp;quot;frozen&amp;quot;.Let status be ? O.[[PreventExtensions]]().If status is false, return false.Let keys be ? O.[[OwnPropertyKeys]]().If level is &amp;quot;sealed&amp;quot;, thenFor each element k of keys, doPerform ? DefinePropertyOrThrow(O, k, PropertyDescriptor{[[Configurable]]: false}).Else level is &amp;quot;frozen&amp;quot;,For each element k of keys, doLet currentDesc be ? O.[[GetOwnProperty]](k).If currentDesc is not undefined, thenIf IsAccessorDescriptor(currentDesc) is true, thenLet desc be the PropertyDescriptor{[[Configurable]]: false}.Else,Let desc be the PropertyDescriptor { [[Configurable]]: false, [[Writable]]: false }.Perform ? DefinePropertyOrThrow(O, k, desc).Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.15">
	<buginformation>
		<summary>TestIntegrityLevel ( O, level )</summary>
		<description>The abstract operation TestIntegrityLevel is used to determine  if the set of own properties of an object are fixed. This abstract  operation performs the following steps: Assert: Type(O) is Object.Assert: level is either &amp;quot;sealed&amp;quot; or &amp;quot;frozen&amp;quot;.Let status be ? IsExtensible(O).If status is true, return false.NOTE: If the object is extensible, none of its properties are examined.Let keys be ? O.[[OwnPropertyKeys]]().For each element k of keys, doLet currentDesc be ? O.[[GetOwnProperty]](k).If currentDesc is not undefined, thenIf currentDesc.[[Configurable]] is true, return false.If level is &amp;quot;frozen&amp;quot; and IsDataDescriptor(currentDesc) is true, thenIf currentDesc.[[Writable]] is true, return false.Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.16">
	<buginformation>
		<summary>CreateArrayFromList ( elements )</summary>
		<description>The abstract operation CreateArrayFromList is used to create an Array object whose elements are provided by a List. This abstract operation performs the following steps: Assert: elements is a List whose elements are all ECMAScript language values.Let array be ! ArrayCreate(0).Let n be 0.For each element e of elements, doLet status be CreateDataProperty(array, ! ToString(n), e).Assert: status is true.Increment n by 1.Return array.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.17">
	<buginformation>
		<summary>CreateListFromArrayLike ( obj [ , elementTypes ] )</summary>
		<description>The abstract operation CreateListFromArrayLike is used to create a List value whose elements are provided by the indexed properties of an array-like object, obj. The optional argument elementTypes is a List containing the names of ECMAScript Language Types that are allowed for element values of the List that is created. This abstract operation performs the following steps: If elementTypes was not passed, set elementTypes to « Undefined, Null, Boolean, String, Symbol, Number, Object ».If Type(obj) is not Object, throw a TypeError exception.Let len be ? ToLength(? Get(obj, &amp;quot;length&amp;quot;)).Let list be a new empty List.Let index be 0.Repeat, while index &lt; lenLet indexName be ! ToString(index).Let next be ? Get(obj, indexName).If Type(next) is not an element of elementTypes, throw a TypeError exception.Append next as the last element of list.Set index to index + 1.Return list.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.18">
	<buginformation>
		<summary>Invoke ( V, P [ , argumentsList ] )</summary>
		<description>The abstract operation Invoke is used to call a method property of an ECMAScript language value. The operation is called with arguments V, P, and optionally argumentsList where V serves as both the lookup point for the property and the this value of the call, P is the property key, and argumentsList is the list of arguments values passed to the method. If argumentsList is not present, a new empty List is used as its value. This abstract operation performs the following steps: Assert: IsPropertyKey(P) is true.If argumentsList was not passed, set argumentsList to a new empty List.Let func be ? GetV(V, P).Return ? Call(func, V, argumentsList).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.19">
	<buginformation>
		<summary>OrdinaryHasInstance ( C, O )</summary>
		<description>The abstract operation OrdinaryHasInstance implements the default algorithm for determining if an object O inherits from the instance object inheritance path provided by constructor C. This abstract operation performs the following steps: If IsCallable(C) is false, return false.If C has a [[BoundTargetFunction]] internal slot, thenLet BC be C.[[BoundTargetFunction]].Return ? InstanceofOperator(O, BC).If Type(O) is not Object, return false.Let P be ? Get(C, &amp;quot;prototype&amp;quot;).If Type(P) is not Object, throw a TypeError exception.Repeat,Set O to ? O.[[GetPrototypeOf]]().If O is null, return false.If SameValue(P, O) is true, return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.20">
	<buginformation>
		<summary>SpeciesConstructor ( O, defaultConstructor )</summary>
		<description>The abstract operation SpeciesConstructor is used to retrieve  the constructor that should be used to create new objects that are  derived from the argument object O. The defaultConstructor argument is the constructor to use if a constructor @@species property cannot be found starting from O. This abstract operation performs the following steps: Assert: Type(O) is Object.Let C be ? Get(O, &amp;quot;constructor&amp;quot;).If C is undefined, return defaultConstructor.If Type(C) is not Object, throw a TypeError exception.Let S be ? Get(C, @@species).If S is either undefined or null, return defaultConstructor.If IsConstructor(S) is true, return S.Throw a TypeError exception.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.21">
	<buginformation>
		<summary>EnumerableOwnProperties ( O, kind )</summary>
		<description>When the abstract operation EnumerableOwnProperties is called with Object O and String kind the following steps are taken: Assert: Type(O) is Object.Let ownKeys be ? O.[[OwnPropertyKeys]]().Let properties be a new empty List.For each element key of ownKeys in List order, doIf Type(key) is String, thenLet desc be ? O.[[GetOwnProperty]](key).If desc is not undefined and desc.[[Enumerable]] is true, thenIf kind is &amp;quot;key&amp;quot;, append key to properties.Else,Let value be ? Get(O, key).If kind is &amp;quot;value&amp;quot;, append value to properties.Else,Assert: kind is &amp;quot;key+value&amp;quot;.Let entry be CreateArrayFromList(« key, value »).Append entry to properties.Order the elements of properties so they are in the same relative order as would be produced by the Iterator that would be returned if the EnumerateObjectProperties internal method were invoked with O.Return properties.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.3.22">
	<buginformation>
		<summary>GetFunctionRealm ( obj )</summary>
		<description>The abstract operation GetFunctionRealm with argument obj performs the following steps: Assert: obj is a callable object.If obj has a [[Realm]] internal slot, thenReturn obj.[[Realm]].If obj is a Bound Function exotic object, thenLet target be obj.[[BoundTargetFunction]].Return ? GetFunctionRealm(target).If obj is a Proxy exotic object, thenIf obj.[[ProxyHandler]] is null, throw a TypeError exception.Let proxyTarget be obj.[[ProxyTarget]].Return ? GetFunctionRealm(proxyTarget).Return the current Realm Record.        Note Step 5 will only be reached if target is a non-standard function exotic object that does not have a [[Realm]] internal slot.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.4.1">
	<buginformation>
		<summary>GetIterator ( obj [ , method ] )</summary>
		<description>The abstract operation GetIterator with argument obj and optional argument method performs the following steps: If method was not passed, thenSet method to ? GetMethod(obj, @@iterator).Let iterator be ? Call(method, obj).If Type(iterator) is not Object, throw a TypeError exception.Return iterator.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.4.2">
	<buginformation>
		<summary>IteratorNext ( iterator [ , value ] )</summary>
		<description>The abstract operation IteratorNext with argument iterator and optional argument value performs the following steps: If value was not passed, thenLet result be ? Invoke(iterator, &amp;quot;next&amp;quot;, « »).Else,Let result be ? Invoke(iterator, &amp;quot;next&amp;quot;, « value »).If Type(result) is not Object, throw a TypeError exception.Return result.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.4.3">
	<buginformation>
		<summary>IteratorComplete ( iterResult )</summary>
		<description>The abstract operation IteratorComplete with argument iterResult performs the following steps: Assert: Type(iterResult) is Object.Return ToBoolean(? Get(iterResult, &amp;quot;done&amp;quot;)).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.4.4">
	<buginformation>
		<summary>IteratorValue ( iterResult )</summary>
		<description>The abstract operation IteratorValue with argument iterResult performs the following steps: Assert: Type(iterResult) is Object.Return ? Get(iterResult, &amp;quot;value&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.4.5">
	<buginformation>
		<summary>IteratorStep ( iterator )</summary>
		<description>The abstract operation IteratorStep with argument iterator requests the next value from iterator and returns either false  indicating that the iterator has reached its end or the IteratorResult  object if a next value is available. IteratorStep performs the following  steps: Let result be ? IteratorNext(iterator).Let done be ? IteratorComplete(result).If done is true, return false.Return result.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.4.6">
	<buginformation>
		<summary>IteratorClose ( iterator, completion )</summary>
		<description>The abstract operation IteratorClose with arguments iterator and completion  is used to notify an iterator that it should perform any actions it  would normally perform when it has reached its completed state: Assert: Type(iterator) is Object.Assert: completion is a Completion Record.Let return be ? GetMethod(iterator, &amp;quot;return&amp;quot;).If return is undefined, return Completion(completion).Let innerResult be Call(return, iterator, « »).If completion.[[Type]] is throw, return Completion(completion).If innerResult.[[Type]] is throw, return Completion(innerResult).If Type(innerResult.[[Value]]) is not Object, throw a TypeError exception.Return Completion(completion).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.4.7">
	<buginformation>
		<summary>CreateIterResultObject ( value, done )</summary>
		<description>The abstract operation CreateIterResultObject with arguments value and done creates an object that supports the IteratorResult interface by performing the following steps: Assert: Type(done) is Boolean.Let obj be ObjectCreate(%ObjectPrototype%).Perform CreateDataProperty(obj, &amp;quot;value&amp;quot;, value).Perform CreateDataProperty(obj, &amp;quot;done&amp;quot;, done).Return obj.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="7.4.8.1">
	<buginformation>
		<summary>ListIterator next( )</summary>
		<description>The ListIterator next method is a standard built-in function object (clause  17) that performs the following steps: Let O be the this value.Assert: Type(O) is Object.Assert: O has an [[IteratedList]] internal slot.Let list be O.[[IteratedList]].Let index be O.[[ListIteratorNextIndex]].Let len be the number of elements of list.If index ≥ len, thenReturn CreateIterResultObject(undefined, true).Set O.[[ListIteratorNextIndex]] to index+1.Return CreateIterResultObject(list[index], false).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.1.1">
	<buginformation>
		<summary>HasBinding ( N )</summary>
		<description>The concrete Environment Record  method HasBinding for declarative Environment Records simply determines  if the argument identifier is one of the identifiers bound by the  record: Let envRec be the declarative Environment Record for which the method was invoked.If envRec has a binding for the name that is the value of N, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.1.2">
	<buginformation>
		<summary>CreateMutableBinding ( N, D )</summary>
		<description>The concrete Environment Record method CreateMutableBinding for declarative Environment Records creates a new mutable binding for the name N that is uninitialized. A binding must not already exist in this Environment Record for N. If Boolean argument D has the value true the new binding is marked as being subject to deletion. Let envRec be the declarative Environment Record for which the method was invoked.Assert: envRec does not already have a binding for N.Create a mutable binding in envRec for N and record that it is uninitialized. If D is true, record that the newly created binding may be deleted by a subsequent DeleteBinding call.Return NormalCompletion(empty).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.1.3">
	<buginformation>
		<summary>CreateImmutableBinding ( N, S )</summary>
		<description>The concrete Environment Record method CreateImmutableBinding for declarative Environment Records creates a new immutable binding for the name N that is uninitialized. A binding must not already exist in this Environment Record for N. If the Boolean argument S has the value true the new binding is marked as a strict binding. Let envRec be the declarative Environment Record for which the method was invoked.Assert: envRec does not already have a binding for N.Create an immutable binding in envRec for N and record that it is uninitialized. If S is true, record that the newly created binding is a strict binding.Return NormalCompletion(empty).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.1.4">
	<buginformation>
		<summary>InitializeBinding ( N, V )</summary>
		<description>The concrete Environment Record  method InitializeBinding for declarative Environment Records is used to  set the bound value of the current binding of the identifier whose name  is the value of the argument N to the value of argument V. An uninitialized binding for N must already exist. Let envRec be the declarative Environment Record for which the method was invoked.Assert: envRec must have an uninitialized binding for N.Set the bound value for N in envRec to V.Record that the binding for N in envRec has been initialized.Return NormalCompletion(empty).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.1.5">
	<buginformation>
		<summary>SetMutableBinding ( N, V, S )</summary>
		<description>The concrete Environment Record  method SetMutableBinding for declarative Environment Records attempts  to change the bound value of the current binding of the identifier whose  name is the value of the argument N to the value of argument V. A binding for N normally already exists, but in rare cases it may not. If the binding is an immutable binding, a TypeError is thrown if S is true. Let envRec be the declarative Environment Record for which the method was invoked.If envRec does not have a binding for N, thenIf S is true, throw a ReferenceError exception.Perform envRec.CreateMutableBinding(N, true).Perform envRec.InitializeBinding(N, V).Return NormalCompletion(empty).If the binding for N in envRec is a strict binding, set S to true.If the binding for N in envRec has not yet been initialized, throw a ReferenceError exception.Else if the binding for N in envRec is a mutable binding, change its bound value to V.Else,Assert: This is an attempt to change the value of an immutable binding.If S is true, throw a TypeError exception.Return NormalCompletion(empty).            Note An example of ECMAScript code that results in a missing binding at step 2 is: function f(){eval(&amp;quot;var x; x</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.1.6">
	<buginformation>
		<summary>GetBindingValue ( N, S )</summary>
		<description>The concrete Environment Record  method GetBindingValue for declarative Environment Records simply  returns the value of its bound identifier whose name is the value of the  argument N. If the binding exists but is uninitialized a ReferenceError is thrown, regardless of the value of S. Let envRec be the declarative Environment Record for which the method was invoked.Assert: envRec has a binding for N.If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception.Return the value currently bound to N in envRec.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.1.7">
	<buginformation>
		<summary>DeleteBinding ( N )</summary>
		<description>The concrete Environment Record  method DeleteBinding for declarative Environment Records can only  delete bindings that have been explicitly designated as being subject to  deletion. Let envRec be the declarative Environment Record for which the method was invoked.Assert: envRec has a binding for the name that is the value of N.If the binding for N in envRec cannot be deleted, return false.Remove the binding for N from envRec.Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.1.8">
	<buginformation>
		<summary>HasThisBinding ( )</summary>
		<description>Regular declarative Environment Records do not provide a this binding. Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.1.9">
	<buginformation>
		<summary>HasSuperBinding ( )</summary>
		<description>Regular declarative Environment Records do not provide a super binding. Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.1.10">
	<buginformation>
		<summary>WithBaseObject ( )</summary>
		<description>Declarative Environment Records always return undefined as their WithBaseObject. Return undefined.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.2.1">
	<buginformation>
		<summary>HasBinding ( N )</summary>
		<description>The concrete Environment Record  method HasBinding for object Environment Records determines if its  associated binding object has a property whose name is the value of the  argument N: Let envRec be the object Environment Record for which the method was invoked.Let bindings be the binding object for envRec.Let foundBinding be ? HasProperty(bindings, N).If foundBinding is false, return false.If the withEnvironment flag of envRec is false, return true.Let unscopables be ? Get(bindings, @@unscopables).If Type(unscopables) is Object, thenLet blocked be ToBoolean(? Get(unscopables, N)).If blocked is true, return false.Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.2.2">
	<buginformation>
		<summary>CreateMutableBinding ( N, D )</summary>
		<description>The concrete Environment Record method CreateMutableBinding for object Environment Records creates in an Environment Record&apos;s associated binding object a property whose name is the String value and initializes it to the value undefined. If Boolean argument D has the value true the new property&apos;s [[Configurable]] attribute is set to true; otherwise it is set to false. Let envRec be the object Environment Record for which the method was invoked.Let bindings be the binding object for envRec.Return ? DefinePropertyOrThrow(bindings, N, PropertyDescriptor{[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D}).            Note Normally envRec will not have a binding for N but if it does, the semantics of DefinePropertyOrThrow may result in an existing binding being replaced or shadowed or cause an abrupt completion to be returned.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.2.3">
	<buginformation>
		<summary>CreateImmutableBinding ( N, S )</summary>
		<description>The concrete Environment Record method CreateImmutableBinding is never used within this specification in association with object Environment Records.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.2.4">
	<buginformation>
		<summary>InitializeBinding ( N, V )</summary>
		<description>The concrete Environment Record  method InitializeBinding for object Environment Records is used to set  the bound value of the current binding of the identifier whose name is  the value of the argument N to the value of argument V. An uninitialized binding for N must already exist. Let envRec be the object Environment Record for which the method was invoked.Assert: envRec must have an uninitialized binding for N.Record that the binding for N in envRec has been initialized.Return ? envRec.SetMutableBinding(N, V, false).            Note In this specification, all uses of CreateMutableBinding  for object Environment Records are immediately followed by a call to  InitializeBinding for the same name. Hence, implementations do not need  to explicitly track the initialization state of individual object Environment Record bindings.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.2.5">
	<buginformation>
		<summary>SetMutableBinding ( N, V, S )</summary>
		<description>The concrete Environment Record method SetMutableBinding for object Environment Records attempts to set the value of the Environment Record&apos;s associated binding object&apos;s property whose name is the value of the argument N to the value of argument V. A property named N  normally already exists but if it does not or is not currently  writable, error handling is determined by the value of the Boolean  argument S. Let envRec be the object Environment Record for which the method was invoked.Let bindings be the binding object for envRec.Return ? Set(bindings, N, V, S).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.2.6">
	<buginformation>
		<summary>GetBindingValue ( N, S )</summary>
		<description>The concrete Environment Record  method GetBindingValue for object Environment Records returns the value  of its associated binding object&apos;s property whose name is the String  value of the argument identifier N. The property should already exist but if it does not the result depends upon the value of the S argument: Let envRec be the object Environment Record for which the method was invoked.Let bindings be the binding object for envRec.Let value be ? HasProperty(bindings, N).If value is false, thenIf S is false, return the value undefined; otherwise throw a ReferenceError exception.Return ? Get(bindings, N).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.2.7">
	<buginformation>
		<summary>DeleteBinding ( N )</summary>
		<description>The concrete Environment Record  method DeleteBinding for object Environment Records can only delete  bindings that correspond to properties of the environment object whose  [[Configurable]] attribute have the value true. Let envRec be the object Environment Record for which the method was invoked.Let bindings be the binding object for envRec.Return ? bindings.[[Delete]](N).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.2.8">
	<buginformation>
		<summary>HasThisBinding ( )</summary>
		<description>Regular object Environment Records do not provide a this binding. Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.2.9">
	<buginformation>
		<summary>HasSuperBinding ( )</summary>
		<description>Regular object Environment Records do not provide a super binding. Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.2.10">
	<buginformation>
		<summary>WithBaseObject ( )</summary>
		<description>Object Environment Records return undefined as their WithBaseObject unless their withEnvironment flag is true. Let envRec be the object Environment Record for which the method was invoked.If the withEnvironment flag of envRec is true, return the binding object for envRec.Otherwise, return undefined.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.3.1">
	<buginformation>
		<summary>BindThisValue ( V )</summary>
		<description>Let envRec be the function Environment Record for which the method was invoked.Assert: envRec.[[ThisBindingStatus]] is not &amp;quot;lexical&amp;quot;.If envRec.[[ThisBindingStatus]] is &amp;quot;initialized&amp;quot;, throw a ReferenceError exception.Set envRec.[[ThisValue]] to V.Set envRec.[[ThisBindingStatus]] to &amp;quot;initialized&amp;quot;.Return V.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.3.2">
	<buginformation>
		<summary>HasThisBinding ( )</summary>
		<description>Let envRec be the function Environment Record for which the method was invoked.If envRec.[[ThisBindingStatus]] is &amp;quot;lexical&amp;quot;, return false; otherwise, return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.3.3">
	<buginformation>
		<summary>HasSuperBinding ( )</summary>
		<description>Let envRec be the function Environment Record for which the method was invoked.If envRec.[[ThisBindingStatus]] is &amp;quot;lexical&amp;quot;, return false.If envRec.[[HomeObject]] has the value undefined, return false; otherwise, return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.3.4">
	<buginformation>
		<summary>GetThisBinding ( )</summary>
		<description>Let envRec be the function Environment Record for which the method was invoked.Assert: envRec.[[ThisBindingStatus]] is not &amp;quot;lexical&amp;quot;.If envRec.[[ThisBindingStatus]] is &amp;quot;uninitialized&amp;quot;, throw a ReferenceError exception.Return envRec.[[ThisValue]].</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.3.5">
	<buginformation>
		<summary>GetSuperBase ( )</summary>
		<description>Let envRec be the function Environment Record for which the method was invoked.Let home be envRec.[[HomeObject]].If home has the value undefined, return undefined.Assert: Type(home) is Object.Return ? home.[[GetPrototypeOf]]().</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.4.1">
	<buginformation>
		<summary>HasBinding ( N )</summary>
		<description>The concrete Environment Record  method HasBinding for global Environment Records simply determines if  the argument identifier is one of the identifiers bound by the record: Let envRec be the global Environment Record for which the method was invoked.Let DclRec be envRec.[[DeclarativeRecord]].If DclRec.HasBinding(N) is true, return true.Let ObjRec be envRec.[[ObjectRecord]].Return ? ObjRec.HasBinding(N).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.4.2">
	<buginformation>
		<summary>CreateMutableBinding ( N, D )</summary>
		<description>The concrete Environment Record method CreateMutableBinding for global Environment Records creates a new mutable binding for the name N that is uninitialized. The binding is created in the associated DeclarativeRecord. A binding for N must not already exist in the DeclarativeRecord. If Boolean argument D has the value true the new binding is marked as being subject to deletion. Let envRec be the global Environment Record for which the method was invoked.Let DclRec be envRec.[[DeclarativeRecord]].If DclRec.HasBinding(N) is true, throw a TypeError exception.Return DclRec.CreateMutableBinding(N, D).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.4.3">
	<buginformation>
		<summary>CreateImmutableBinding ( N, S )</summary>
		<description>The concrete Environment Record method CreateImmutableBinding for global Environment Records creates a new immutable binding for the name N that is uninitialized. A binding must not already exist in this Environment Record for N. If the Boolean argument S has the value true the new binding is marked as a strict binding. Let envRec be the global Environment Record for which the method was invoked.Let DclRec be envRec.[[DeclarativeRecord]].If DclRec.HasBinding(N) is true, throw a TypeError exception.Return DclRec.CreateImmutableBinding(N, S).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.4.4">
	<buginformation>
		<summary>InitializeBinding ( N, V )</summary>
		<description>The concrete Environment Record  method InitializeBinding for global Environment Records is used to set  the bound value of the current binding of the identifier whose name is  the value of the argument N to the value of argument V. An uninitialized binding for N must already exist. Let envRec be the global Environment Record for which the method was invoked.Let DclRec be envRec.[[DeclarativeRecord]].If DclRec.HasBinding(N) is true, thenReturn DclRec.InitializeBinding(N, V).Assert: If the binding exists, it must be in the object Environment Record.Let ObjRec be envRec.[[ObjectRecord]].Return ? ObjRec.InitializeBinding(N, V).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.4.5">
	<buginformation>
		<summary>SetMutableBinding ( N, V, S )</summary>
		<description>The concrete Environment Record  method SetMutableBinding for global Environment Records attempts to  change the bound value of the current binding of the identifier whose  name is the value of the argument N to the value of argument V. If the binding is an immutable binding, a TypeError is thrown if S is true. A property named N  normally already exists but if it does not or is not currently  writable, error handling is determined by the value of the Boolean  argument S. Let envRec be the global Environment Record for which the method was invoked.Let DclRec be envRec.[[DeclarativeRecord]].If DclRec.HasBinding(N) is true, thenReturn DclRec.SetMutableBinding(N, V, S).Let ObjRec be envRec.[[ObjectRecord]].Return ? ObjRec.SetMutableBinding(N, V, S).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.4.6">
	<buginformation>
		<summary>GetBindingValue ( N, S )</summary>
		<description>The concrete Environment Record  method GetBindingValue for global Environment Records returns the value  of its bound identifier whose name is the value of the argument N. If the binding is an uninitialized binding throw a ReferenceError exception. A property named N  normally already exists but if it does not or is not currently  writable, error handling is determined by the value of the Boolean  argument S. Let envRec be the global Environment Record for which the method was invoked.Let DclRec be envRec.[[DeclarativeRecord]].If DclRec.HasBinding(N) is true, thenReturn DclRec.GetBindingValue(N, S).Let ObjRec be envRec.[[ObjectRecord]].Return ? ObjRec.GetBindingValue(N, S).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.4.7">
	<buginformation>
		<summary>DeleteBinding ( N )</summary>
		<description>The concrete Environment Record  method DeleteBinding for global Environment Records can only delete  bindings that have been explicitly designated as being subject to  deletion. Let envRec be the global Environment Record for which the method was invoked.Let DclRec be envRec.[[DeclarativeRecord]].If DclRec.HasBinding(N) is true, thenReturn DclRec.DeleteBinding(N).Let ObjRec be envRec.[[ObjectRecord]].Let globalObject be the binding object for ObjRec.Let existingProp be ? HasOwnProperty(globalObject, N).If existingProp is true, thenLet status be ? ObjRec.DeleteBinding(N).If status is true, thenLet varNames be envRec.[[VarNames]].If N is an element of varNames, remove that element from the varNames.Return status.Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.4.8">
	<buginformation>
		<summary>HasThisBinding ( )</summary>
		<description>Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.4.9">
	<buginformation>
		<summary>HasSuperBinding ( )</summary>
		<description>Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.4.10">
	<buginformation>
		<summary>WithBaseObject ( )</summary>
		<description>Global Environment Records always return undefined as their WithBaseObject. Return undefined.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.4.11">
	<buginformation>
		<summary>GetThisBinding ( )</summary>
		<description>Let envRec be the global Environment Record for which the method was invoked.Return envRec.[[GlobalThisValue]].</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.4.12">
	<buginformation>
		<summary>HasVarDeclaration ( N )</summary>
		<description>The concrete Environment Record  method HasVarDeclaration for global Environment Records determines if  the argument identifier has a binding in this record that was created  using a VariableStatement or a FunctionDeclaration: Let envRec be the global Environment Record for which the method was invoked.Let varDeclaredNames be envRec.[[VarNames]].If varDeclaredNames contains N, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.4.13">
	<buginformation>
		<summary>HasLexicalDeclaration ( N )</summary>
		<description>The concrete Environment Record  method HasLexicalDeclaration for global Environment Records determines  if the argument identifier has a binding in this record that was created  using a lexical declaration such as a LexicalDeclaration or a ClassDeclaration: Let envRec be the global Environment Record for which the method was invoked.Let DclRec be envRec.[[DeclarativeRecord]].Return DclRec.HasBinding(N).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.4.14">
	<buginformation>
		<summary>HasRestrictedGlobalProperty ( N )</summary>
		<description>The concrete Environment Record  method HasRestrictedGlobalProperty for global Environment Records  determines if the argument identifier is the name of a property of the global object that must not be shadowed by a global lexically binding: Let envRec be the global Environment Record for which the method was invoked.Let ObjRec be envRec.[[ObjectRecord]].Let globalObject be the binding object for ObjRec.Let existingProp be ? globalObject.[[GetOwnProperty]](N).If existingProp is undefined, return false.If existingProp.[[Configurable]] is true, return false.Return true.            Note Properties may exist upon a global object  that were directly created rather than being declared using a var or  function declaration. A global lexical binding may not be created that  has the same name as a non-configurable property of the global object. The global property undefined is an example of such a property.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.4.15">
	<buginformation>
		<summary>CanDeclareGlobalVar ( N )</summary>
		<description>The concrete Environment Record  method CanDeclareGlobalVar for global Environment Records determines if  a corresponding CreateGlobalVarBinding call would succeed if called for  the same argument N. Redundant var declarations and var declarations for pre-existing global object properties are allowed. Let envRec be the global Environment Record for which the method was invoked.Let ObjRec be envRec.[[ObjectRecord]].Let globalObject be the binding object for ObjRec.Let hasProperty be ? HasOwnProperty(globalObject, N).If hasProperty is true, return true.Return ? IsExtensible(globalObject).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.4.16">
	<buginformation>
		<summary>CanDeclareGlobalFunction ( N )</summary>
		<description>The concrete Environment Record  method CanDeclareGlobalFunction for global Environment Records  determines if a corresponding CreateGlobalFunctionBinding call would  succeed if called for the same argument N. Let envRec be the global Environment Record for which the method was invoked.Let ObjRec be envRec.[[ObjectRecord]].Let globalObject be the binding object for ObjRec.Let existingProp be ? globalObject.[[GetOwnProperty]](N).If existingProp is undefined, return ? IsExtensible(globalObject).If existingProp.[[Configurable]] is true, return true.If IsDataDescriptor(existingProp) is true and existingProp has attribute values {[[Writable]]: true, [[Enumerable]]: true}, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.4.17">
	<buginformation>
		<summary>CreateGlobalVarBinding ( N, D )</summary>
		<description>The concrete Environment Record  method CreateGlobalVarBinding for global Environment Records creates  and initializes a mutable binding in the associated object Environment Record and records the bound name in the associated [[VarNames]] List. If a binding already exists, it is reused and assumed to be initialized. Let envRec be the global Environment Record for which the method was invoked.Let ObjRec be envRec.[[ObjectRecord]].Let globalObject be the binding object for ObjRec.Let hasProperty be ? HasOwnProperty(globalObject, N).Let extensible be ? IsExtensible(globalObject).If hasProperty is false and extensible is true, thenPerform ? ObjRec.CreateMutableBinding(N, D).Perform ? ObjRec.InitializeBinding(N, undefined).Let varDeclaredNames be envRec.[[VarNames]].If varDeclaredNames does not contain N, thenAppend N to varDeclaredNames.Return NormalCompletion(empty).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.4.18">
	<buginformation>
		<summary>CreateGlobalFunctionBinding ( N, V, D )</summary>
		<description>The concrete Environment Record  method CreateGlobalFunctionBinding for global Environment Records  creates and initializes a mutable binding in the associated object Environment Record and records the bound name in the associated [[VarNames]] List. If a binding already exists, it is replaced. Let envRec be the global Environment Record for which the method was invoked.Let ObjRec be envRec.[[ObjectRecord]].Let globalObject be the binding object for ObjRec.Let existingProp be ? globalObject.[[GetOwnProperty]](N).If existingProp is undefined or existingProp.[[Configurable]] is true, thenLet desc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D}.Else,Let desc be the PropertyDescriptor{[[Value]]: V }.Perform ? DefinePropertyOrThrow(globalObject, N, desc).Record that the binding for N in ObjRec has been initialized.Perform ? Set(globalObject, N, V, false).Let varDeclaredNames be envRec.[[VarNames]].If varDeclaredNames does not contain N, thenAppend N to varDeclaredNames.Return NormalCompletion(empty).            Note Global function declarations are always represented as own properties of the global object.  If possible, an existing own property is reconfigured to have a  standard set of attribute values. Steps 8-9 are equivalent to what  calling the InitializeBinding concrete method would do and if globalObject is a Proxy will produce the same sequence of Proxy trap calls.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.5.1">
	<buginformation>
		<summary>GetBindingValue ( N, S )</summary>
		<description>The concrete Environment Record  method GetBindingValue for module Environment Records returns the value  of its bound identifier whose name is the value of the argument N.  However, if the binding is an indirect binding the value of the target  binding is returned. If the binding exists but is uninitialized a ReferenceError is thrown. Assert: S is true.Let envRec be the module Environment Record for which the method was invoked.Assert: envRec has a binding for N.If the binding for N is an indirect binding, thenLet M and N2 be the indirection values provided when this binding for N was created.Let targetEnv be M.[[Environment]].If targetEnv is undefined, throw a ReferenceError exception.Let targetER be targetEnv&apos;s EnvironmentRecord.Return ? targetER.GetBindingValue(N2, true).If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception.Return the value currently bound to N in envRec.            Note S will always be true because a Module is always strict mode code.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.5.2">
	<buginformation>
		<summary>DeleteBinding ( N )</summary>
		<description>The concrete Environment Record method DeleteBinding for module Environment Records refuses to delete bindings. Assert: This method is never invoked. See 12.5.3.1.            Note Module Environment Records are only used within strict code and an early error rule prevents the delete operator, in strict code, from being applied to a Reference that would resolve to a module Environment Record binding. See  12.5.3.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.5.3">
	<buginformation>
		<summary>HasThisBinding ( )</summary>
		<description>Module Environment Records provide a this binding. Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.5.4">
	<buginformation>
		<summary>GetThisBinding ( )</summary>
		<description>Return undefined.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.1.5.5">
	<buginformation>
		<summary>CreateImportBinding ( N, M, N2 )</summary>
		<description>The concrete Environment Record method CreateImportBinding for module Environment Records creates a new initialized immutable indirect binding for the name N. A binding must not already exist in this Environment Record for N. M is a Module Record, and N2 is the name of a binding that exists in M&apos;s module Environment Record. Accesses to the value of the new binding will indirectly access the bound value of the target binding. Let envRec be the module Environment Record for which the method was invoked.Assert: envRec does not already have a binding for N.Assert: M is a Module Record.Assert: When M.[[Environment]] is instantiated it will have a direct binding for N2.Create an immutable indirect binding in envRec for N that references M and N2 as its target binding and record that the binding is initialized.Return NormalCompletion(empty).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.2.1">
	<buginformation>
		<summary>GetIdentifierReference ( lex, name, strict )</summary>
		<description>The abstract operation GetIdentifierReference is called with a Lexical Environment lex, a String name, and a Boolean flag strict. The value of lex may be null. When called, the following steps are performed: If lex is the value null, thenReturn a value of type Reference whose base value component is undefined, whose referenced name component is name, and whose strict reference flag is strict.Let envRec be lex&apos;s EnvironmentRecord.Let exists be ? envRec.HasBinding(name).If exists is true, thenReturn a value of type Reference whose base value component is envRec, whose referenced name component is name, and whose strict reference flag is strict.Else,Let outer be the value of lex&apos;s outer environment reference.Return ? GetIdentifierReference(outer, name, strict).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.2.2">
	<buginformation>
		<summary>NewDeclarativeEnvironment ( E )</summary>
		<description>When the abstract operation NewDeclarativeEnvironment is called with a Lexical Environment as argument E the following steps are performed: Let env be a new Lexical Environment.Let envRec be a new declarative Environment Record containing no bindings.Set env&apos;s EnvironmentRecord to envRec.Set the outer lexical environment reference of env to E.Return env.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.2.3">
	<buginformation>
		<summary>NewObjectEnvironment ( O, E )</summary>
		<description>When the abstract operation NewObjectEnvironment is called with an Object O and a Lexical Environment E as arguments, the following steps are performed: Let env be a new Lexical Environment.Let envRec be a new object Environment Record containing O as the binding object.Set env&apos;s EnvironmentRecord to envRec.Set the outer lexical environment reference of env to E.Return env.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.2.4">
	<buginformation>
		<summary>NewFunctionEnvironment ( F, newTarget )</summary>
		<description>When the abstract operation NewFunctionEnvironment is called with arguments F and newTarget the following steps are performed: Assert: F is an ECMAScript function.Assert: Type(newTarget) is Undefined or Object.Let env be a new Lexical Environment.Let envRec be a new function Environment Record containing no bindings.Set envRec.[[FunctionObject]] to F.If F.[[ThisMode]] is lexical, set envRec.[[ThisBindingStatus]] to &amp;quot;lexical&amp;quot;.Else, set envRec.[[ThisBindingStatus]] to &amp;quot;uninitialized&amp;quot;.Let home be F.[[HomeObject]].Set envRec.[[HomeObject]] to home.Set envRec.[[NewTarget]] to newTarget.Set env&apos;s EnvironmentRecord to envRec.Set the outer lexical environment reference of env to F.[[Environment]].Return env.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.2.5">
	<buginformation>
		<summary>NewGlobalEnvironment ( G, thisValue )</summary>
		<description>When the abstract operation NewGlobalEnvironment is called with arguments G and thisValue, the following steps are performed: Let env be a new Lexical Environment.Let objRec be a new object Environment Record containing G as the binding object.Let dclRec be a new declarative Environment Record containing no bindings.Let globalRec be a new global Environment Record.Set globalRec.[[ObjectRecord]] to objRec.Set globalRec.[[GlobalThisValue]] to thisValue.Set globalRec.[[DeclarativeRecord]] to dclRec.Set globalRec.[[VarNames]] to a new empty List.Set env&apos;s EnvironmentRecord to globalRec.Set the outer lexical environment reference of env to null.Return env.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.1.2.6">
	<buginformation>
		<summary>NewModuleEnvironment ( E )</summary>
		<description>When the abstract operation NewModuleEnvironment is called with a Lexical Environment argument E the following steps are performed: Let env be a new Lexical Environment.Let envRec be a new module Environment Record containing no bindings.Set env&apos;s EnvironmentRecord to envRec.Set the outer lexical environment reference of env to E.Return env.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.2.1">
	<buginformation>
		<summary>CreateRealm ( )</summary>
		<description>The abstract operation CreateRealm with no arguments performs the following steps: Let realmRec be a new Realm Record.Perform CreateIntrinsics(realmRec).Set realmRec.[[GlobalObject]] to undefined.Set realmRec.[[GlobalEnv]] to undefined.Set realmRec.[[TemplateMap]] to a new empty List.Return realmRec.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.2.2">
	<buginformation>
		<summary>CreateIntrinsics ( realmRec )</summary>
		<description>The abstract operation CreateIntrinsics with argument realmRec performs the following steps: Let intrinsics be a new Record.Set realmRec.[[Intrinsics]] to intrinsics.Let objProto be ObjectCreate(null).Set intrinsics.[[%ObjectPrototype%]] to objProto.Let throwerSteps be the algorithm steps specified in 9.2.7.1 for the %ThrowTypeError% function.Let thrower be CreateBuiltinFunction(realmRec, throwerSteps, null).Set intrinsics.[[%ThrowTypeError%]] to thrower.Let noSteps be an empty sequence of algorithm steps.Let funcProto be CreateBuiltinFunction(realmRec, noSteps, objProto).Set intrinsics.[[%FunctionPrototype%]] to funcProto.Call thrower.[[SetPrototypeOf]](funcProto).Perform AddRestrictedFunctionProperties(funcProto, realmRec).Set fields of intrinsics with the values listed in Table 7  that have not already been handled above. The field names are the names  listed in column one of the table. The value of each field is a new  object value fully and recursively populated with property values as  defined by the specification of each object in clauses 18-26. All object  property values are newly created object values. All values that are  built-in function objects are created by performing CreateBuiltinFunction(realmRec,  &lt;steps&gt;, &lt;prototype&gt;, &lt;slots&gt;) where &lt;steps&gt; is  the definition of that function provided by this specification,  &lt;prototype&gt; is the specified value of the function&apos;s [[Prototype]]  internal slot and &lt;slots&gt; is a list of the names, if any, of the  function&apos;s specified internal slots. The creation of the intrinsics and  their properties must be ordered to avoid any dependencies upon objects  that have not yet been created.Return intrinsics.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.2.3">
	<buginformation>
		<summary>SetRealmGlobalObject ( realmRec, globalObj, thisValue )</summary>
		<description>The abstract operation SetRealmGlobalObject with arguments realmRec, globalObj, and thisValue performs the following steps: If globalObj is undefined, thenLet intrinsics be realmRec.[[Intrinsics]].Set globalObj to ObjectCreate(intrinsics.[[%ObjectPrototype%]]).Assert: Type(globalObj) is Object.If thisValue is undefined, set thisValue to globalObj.Set realmRec.[[GlobalObject]] to globalObj.Let newGlobalEnv be NewGlobalEnvironment(globalObj, thisValue).Set realmRec.[[GlobalEnv]] to newGlobalEnv.Return realmRec.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.2.4">
	<buginformation>
		<summary>SetDefaultGlobalBindings ( realmRec )</summary>
		<description>The abstract operation SetDefaultGlobalBindings with argument realmRec performs the following steps: Let global be realmRec.[[GlobalObject]].For each property of the Global Object specified in clause 18, doLet name be the String value of the property name.Let desc  be the fully populated data property descriptor for the property  containing the specified attributes for the property. For properties  listed in 18.2, 18.3, or 18.4 the value of the [[Value]] attribute is the corresponding intrinsic object from realmRec.Perform ? DefinePropertyOrThrow(global, name, desc).Return global.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.3.1">
	<buginformation>
		<summary>GetActiveScriptOrModule ( )</summary>
		<description>The GetActiveScriptOrModule abstract operation is used to determine the running script or module, based on the running execution context. GetActiveScriptOrModule performs the following steps: If the execution context stack is empty, return null.Let ec be the topmost execution context on the execution context stack whose ScriptOrModule component is not null.If no such execution context exists, return null. Otherwise, return ec&apos;s ScriptOrModule component.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.3.2">
	<buginformation>
		<summary>ResolveBinding ( name [ , env ] )</summary>
		<description>The ResolveBinding abstract operation is used to determine the binding of name passed as a String value. The optional argument env can be used to explicitly provide the Lexical Environment  that is to be searched for the binding. During execution of ECMAScript  code, ResolveBinding is performed using the following algorithm: If env was not passed or if env is undefined, thenSet env to the running execution context&apos;s LexicalEnvironment.Assert: env is a Lexical Environment.If the code matching the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let strict be false.Return ? GetIdentifierReference(env, name, strict).        Note The result of ResolveBinding is always a Reference value with its referenced name component equal to the name argument.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.3.3">
	<buginformation>
		<summary>GetThisEnvironment ( )</summary>
		<description>The abstract operation GetThisEnvironment finds the Environment Record that currently supplies the binding of the keyword this. GetThisEnvironment performs the following steps: Let lex be the running execution context&apos;s LexicalEnvironment.Repeat,Let envRec be lex&apos;s EnvironmentRecord.Let exists be envRec.HasThisBinding().If exists is true, return envRec.Let outer be the value of lex&apos;s outer environment reference.Assert: outer is not null.Set lex to outer.        Note The loop in step 2 will always terminate because the list of environments always ends with the global environment which has a this binding.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.3.4">
	<buginformation>
		<summary>ResolveThisBinding ( )</summary>
		<description>The abstract operation ResolveThisBinding determines the binding of the keyword this using the LexicalEnvironment of the running execution context. ResolveThisBinding performs the following steps: Let envRec be GetThisEnvironment( ).Return ? envRec.GetThisBinding().</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.3.5">
	<buginformation>
		<summary>GetNewTarget ( )</summary>
		<description>The abstract operation GetNewTarget determines the NewTarget value using the LexicalEnvironment of the running execution context. GetNewTarget performs the following steps: Let envRec be GetThisEnvironment( ).Assert: envRec has a [[NewTarget]] field.Return envRec.[[NewTarget]].</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.3.6">
	<buginformation>
		<summary>GetGlobalObject ( )</summary>
		<description>The abstract operation GetGlobalObject returns the global object used by the currently running execution context. GetGlobalObject performs the following steps: Let ctx be the running execution context.Let currentRealm be ctx&apos;s Realm.Return currentRealm.[[GlobalObject]].</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.4.1">
	<buginformation>
		<summary>EnqueueJob ( queueName, job, arguments )</summary>
		<description>The EnqueueJob abstract operation requires three arguments: queueName, job, and arguments. It performs the following steps: Assert: Type(queueName) is String and its value is the name of a Job Queue recognized by this implementation.Assert: job is the name of a Job.Assert: arguments is a List that has the same number of elements as the number of parameters required by job.Let callerContext be the running execution context.Let callerRealm be callerContext&apos;s Realm.Let callerScriptOrModule be callerContext&apos;s ScriptOrModule.Let pending be PendingJob{ [[Job]]: job, [[Arguments]]: arguments, [[Realm]]: callerRealm, [[ScriptOrModule]]: callerScriptOrModule, [[HostDefined]]: undefined }.Perform any implementation or host environment defined processing of pending. This may include modifying the [[HostDefined]] field or any other field of pending.Add pending at the back of the Job Queue named by queueName.Return NormalCompletion(empty).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.5">
	<buginformation>
		<summary>InitializeHostDefinedRealm ( )</summary>
		<description>The abstract operation InitializeHostDefinedRealm performs the following steps: Let realm be CreateRealm().Let newContext be a new execution context.Set the Function of newContext to null.Set the Realm of newContext to realm.Set the ScriptOrModule of newContext to null.Push newContext onto the execution context stack; newContext is now the running execution context.If the host requires use of an exotic object to serve as realm&apos;s global object, let global be such an object created in an implementation-defined manner. Otherwise, let global be undefined, indicating that an ordinary object should be created as the global object.If the host requires that the this binding in realm&apos;s global scope return an object other than the global object, let thisValue be such an object created in an implementation-defined manner. Otherwise, let thisValue be undefined, indicating that realm&apos;s global this binding should be the global object.Perform SetRealmGlobalObject(realm, global, thisValue).Let globalObj be ? SetDefaultGlobalBindings(realm).Create any implementation-defined global object properties on globalObj.Return NormalCompletion(empty).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.6">
	<buginformation>
		<summary>RunJobs ( )</summary>
		<description>The abstract operation RunJobs performs the following steps: Perform ? InitializeHostDefinedRealm().In an implementation-dependent manner, obtain the ECMAScript source texts (see clause 10) and any associated host-defined values for zero or more ECMAScript scripts and/or ECMAScript modules. For each such sourceText and hostDefined, doIf sourceText is the source code of a script, thenPerform EnqueueJob(&amp;quot;ScriptJobs&amp;quot;, ScriptEvaluationJob, « sourceText, hostDefined »).Else sourceText is the source code of a module,Perform EnqueueJob(&amp;quot;ScriptJobs&amp;quot;, TopLevelModuleEvaluationJob, « sourceText, hostDefined »).Repeat,Suspend the running execution context and remove it from the execution context stack.Assert: The execution context stack is now empty.Let nextQueue  be a non-empty Job Queue chosen in an implementation-defined manner. If  all Job Queues are empty, the result is implementation-defined.Let nextPending be the PendingJob record at the front of nextQueue. Remove that record from nextQueue.Let newContext be a new execution context.Set newContext&apos;s Function to null.Set newContext&apos;s Realm to nextPending.[[Realm]].Set newContext&apos;s ScriptOrModule to nextPending.[[ScriptOrModule]].Push newContext onto the execution context stack; newContext is now the running execution context.Perform any implementation or host environment defined job initialization using nextPending.Let result be the result of performing the abstract operation named by nextPending.[[Job]] using the elements of nextPending.[[Arguments]] as its arguments.If result is an abrupt completion, perform HostReportErrors(« result.[[Value]] »).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.7.1">
	<buginformation>
		<summary>AgentSignifier( )</summary>
		<description>The abstract operation AgentSignifier takes no arguments. It performs the following steps: Let AR be the Agent Record of the surrounding agent.Return AR.[[Signifier]].</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.7.2">
	<buginformation>
		<summary>AgentCanSuspend( )</summary>
		<description>The abstract operation AgentCanSuspend takes no arguments. It performs the following steps: Let AR be the Agent Record of the surrounding agent.Return AR.[[CanBlock]].        Note In some environments it may not be reasonable for a given agent  to suspend. For example, in a web browser environment, it may be  reasonable to disallow suspending a document&apos;s main event handling  thread, while still allowing workers&apos; event handling threads to suspend.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.8">
	<buginformation>
		<summary>Agent Clusters</summary>
		<description>An  agent cluster is a maximal set of agents that can communicate by operating on shared memory. Note 1 Programs within different agents may share memory by  unspecified means.  At a minimum, the backing memory for  SharedArrayBuffer objects can be shared among the agents in the cluster. There may be agents that can communicate by message passing that cannot share memory; they are never in the same agent cluster.  Every agent belongs to exactly one agent cluster. Note 2 The agents in a cluster need not all be alive at some particular point in time.  If agent A creates another agent B, after which  A terminates and  B creates agent C, the three agents are in the same cluster if  A could share some memory with  B and  B could share some memory with  C.  All agents within a cluster must have the same value for the [[LittleEndian]] property in their respective Agent Records. Note 3 If different agents within an agent cluster have different  values of [[LittleEndian]] it becomes hard to use shared memory for  multi-byte data.  All agents within a cluster must have the same values for the [[IsLockFree1]] property in their respective Agent Records; similarly for the [[IsLockFree2]] property. All agents within a cluster must have different values for the [[Signifier]] property in their respective Agent Records. An embedding may deactivate (stop forward progress) or activate (resume forward progress) an agent without the agent&apos;s  knowledge or cooperation.  If the embedding does so, it must not leave  some agents in the cluster active while other agents in the cluster are  deactivated indefinitely. Note 4 The purpose of the preceding restriction is to avoid a situation where an agent deadlocks or starves because another agent  has been deactivated.  For example, if an HTML shared worker that has a  lifetime independent of documents in any windows were allowed to share  memory with the dedicated worker of such an independent document, and  the document and its dedicated worker were to be deactivated while the  dedicated worker holds a lock (say, the document is pushed into its  window&apos;s history), and the shared worker then tries to acquire the lock,  then the shared worker will be blocked until the dedicated worker is  activated again, if ever.  Meanwhile other workers trying to access the  shared worker from other windows will starve. The implication of the restriction is that it will not be  possible to share memory between agents that don&apos;t belong to the same  suspend/wake collective within the embedding.  An embedding may terminate an agent without any of the agent&apos;s cluster&apos;s other agents&apos; prior knowledge or cooperation.  If an agent is terminated not by programmatic action of its own or of another agent  in the cluster but by forces external to the cluster, then the  embedding must choose one of two strategies: Either terminate all the  agents in the cluster, or provide reliable APIs that allow the agents in  the cluster to coordinate so that at least one remaining member of the  cluster will be able to detect the termination, with the termination  data containing enough information to identify the agent that was terminated. Note 5 Examples of that type of termination are: operating systems or  users terminating agents that are running in separate processes; the  embedding itself terminating an agent that is running in-process with the other agents when per-agent resource accounting indicates that the agent is runaway.  Prior to any evaluation of any ECMAScript code by any agent in a cluster, the [[CandidateExecution]] field of the Agent Record for all agents in the cluster is set to the initial candidate execution. The initial candidate execution is an empty candidate execution whose [[EventLists]] field is a List containing, for each agent, an Agent Events Record whose [[AgentSignifier]] field is that agent&apos;s signifier and whose [[EventList]] field is an empty List. Note 6 All agents in an agent cluster share the same candidate execution in its Agent Record&apos;s [[CandidateExecution]] field. The candidate execution is a specification mechanism used by the memory model.  Note 7 An agent cluster is a specification mechanism and need not  correspond to any particular artefact of an ECMAScript implementation.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="8.9">
	<buginformation>
		<summary>Forward Progress</summary>
		<description>For an agent to  make forward progress is for it to perform an evaluation step according to this specification. An agent becomes  blocked when its running execution context waits synchronously and indefinitely for an external event. Only agents whose Agent Record&apos;s [[CanBlock]] property is true can become blocked in this sense.  An  unblocked agent is one that is not blocked. Implementations must ensure that:  every unblocked agent with a dedicated executing thread eventually makes forward progress in a set of agents that share an executing thread, one agent eventually makes forward progress an agent does not cause another agent to become blocked except via explicit APIs that provide blocking.  Note This, along with the liveness guarantee in the memory model, ensures that all &amp;quot;SeqCst&amp;quot; writes eventually become observable to all agents.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.1.1.1">
	<buginformation>
		<summary>OrdinaryGetPrototypeOf ( O )</summary>
		<description>When the abstract operation OrdinaryGetPrototypeOf is called with Object O, the following steps are taken: Return O.[[Prototype]].</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.1.2.1">
	<buginformation>
		<summary>OrdinarySetPrototypeOf ( O, V )</summary>
		<description>When the abstract operation OrdinarySetPrototypeOf is called with Object O and value V, the following steps are taken: Assert: Either Type(V) is Object or Type(V) is Null.Let extensible be O.[[Extensible]].Let current be O.[[Prototype]].If SameValue(V, current) is true, return true.If extensible is false, return false.Let p be V.Let done be false.Repeat, while done is false,If p is null, set done to true.Else if SameValue(p, O) is true, return false.Else,If p.[[GetPrototypeOf]] is not the ordinary object internal method defined in 9.1.1, set done to true.Else, set p to p.[[Prototype]].Set O.[[Prototype]] to V.Return true.          Note The loop in step 8 guarantees that there will be no  circularities in any prototype chain that only includes objects that use  the ordinary object definitions for [[GetPrototypeOf]] and  [[SetPrototypeOf]].</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.1.3.1">
	<buginformation>
		<summary>OrdinaryIsExtensible ( O )</summary>
		<description>When the abstract operation OrdinaryIsExtensible is called with Object O, the following steps are taken: Return O.[[Extensible]].</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.1.4.1">
	<buginformation>
		<summary>OrdinaryPreventExtensions ( O )</summary>
		<description>When the abstract operation OrdinaryPreventExtensions is called with Object O, the following steps are taken: Set O.[[Extensible]] to false.Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.1.5.1">
	<buginformation>
		<summary>OrdinaryGetOwnProperty ( O, P )</summary>
		<description>When the abstract operation OrdinaryGetOwnProperty is called with Object O and with property key P, the following steps are taken: Assert: IsPropertyKey(P) is true.If O does not have an own property with key P, return undefined.Let D be a newly created Property Descriptor with no fields.Let X be O&apos;s own property whose key is P.If X is a data property, thenSet D.[[Value]] to the value of X&apos;s [[Value]] attribute.Set D.[[Writable]] to the value of X&apos;s [[Writable]] attribute.Else X is an accessor property,Set D.[[Get]] to the value of X&apos;s [[Get]] attribute.Set D.[[Set]] to the value of X&apos;s [[Set]] attribute.Set D.[[Enumerable]] to the value of X&apos;s [[Enumerable]] attribute.Set D.[[Configurable]] to the value of X&apos;s [[Configurable]] attribute.Return D.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.1.6.1">
	<buginformation>
		<summary>OrdinaryDefineOwnProperty ( O, P, Desc )</summary>
		<description>When the abstract operation OrdinaryDefineOwnProperty is called with Object O, property key P, and Property Descriptor Desc, the following steps are taken: Let current be ? O.[[GetOwnProperty]](P).Let extensible be O.[[Extensible]].Return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.1.6.2">
	<buginformation>
		<summary>IsCompatiblePropertyDescriptor ( Extensible, Desc, Current )</summary>
		<description>When the abstract operation IsCompatiblePropertyDescriptor is called with Boolean value Extensible, and Property Descriptors Desc, and Current, the following steps are taken: Return ValidateAndApplyPropertyDescriptor(undefined, undefined, Extensible, Desc, Current).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.1.6.3">
	<buginformation>
		<summary>ValidateAndApplyPropertyDescriptor ( O, P, extensible, Desc, current )</summary>
		<description>When the abstract operation ValidateAndApplyPropertyDescriptor is called with Object O, property key P, Boolean value extensible, and Property Descriptors Desc, and current, the following steps are taken: Note If undefined is passed as the O argument only validation is performed and no object updates are performed.  Assert: If O is not undefined, then IsPropertyKey(P) is true.If current is undefined, thenIf extensible is false, return false.Assert: extensible is true.If IsGenericDescriptor(Desc) is true or IsDataDescriptor(Desc) is true, thenIf O is not undefined, create an own data property named P of object O whose [[Value]], [[Writable]], [[Enumerable]] and [[Configurable]] attribute values are described by Desc. If the value of an attribute field of Desc is absent, the attribute of the newly created property is set to its default value.Else Desc must be an accessor Property Descriptor,If O is not undefined, create an own accessor property named P of object O whose [[Get]], [[Set]], [[Enumerable]] and [[Configurable]] attribute values are described by Desc. If the value of an attribute field of Desc is absent, the attribute of the newly created property is set to its default value.Return true.If every field in Desc is absent, return true.If current.[[Configurable]] is false, thenIf Desc.[[Configurable]] is present and its value is true, return false.If Desc.[[Enumerable]] is present and the [[Enumerable]] fields of current and Desc are the Boolean negation of each other, return false.If IsGenericDescriptor(Desc) is true, no further validation is required.Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) have different results, thenIf current.[[Configurable]] is false, return false.If IsDataDescriptor(current) is true, thenIf O is not undefined, convert the property named P of object O  from a data property to an accessor property. Preserve the existing  values of the converted property&apos;s [[Configurable]] and [[Enumerable]]  attributes and set the rest of the property&apos;s attributes to their  default values.Else,If O is not undefined, convert the property named P of object O  from an accessor property to a data property. Preserve the existing  values of the converted property&apos;s [[Configurable]] and [[Enumerable]]  attributes and set the rest of the property&apos;s attributes to their  default values.Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) are both true, thenIf current.[[Configurable]] is false and current.[[Writable]] is false, thenIf Desc.[[Writable]] is present and Desc.[[Writable]] is true, return false.If Desc.[[Value]] is present and SameValue(Desc.[[Value]], current.[[Value]]) is false, return false.Return true.Else IsAccessorDescriptor(current) and IsAccessorDescriptor(Desc) are both true,If current.[[Configurable]] is false, thenIf Desc.[[Set]] is present and SameValue(Desc.[[Set]], current.[[Set]]) is false, return false.If Desc.[[Get]] is present and SameValue(Desc.[[Get]], current.[[Get]]) is false, return false.Return true.If O is not undefined, thenFor each field of Desc that is present, set the corresponding attribute of the property named P of object O to the value of the field.Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.1.7.1">
	<buginformation>
		<summary>OrdinaryHasProperty ( O, P )</summary>
		<description>When the abstract operation OrdinaryHasProperty is called with Object O and with property key P, the following steps are taken: Assert: IsPropertyKey(P) is true.Let hasOwn be ? O.[[GetOwnProperty]](P).If hasOwn is not undefined, return true.Let parent be ? O.[[GetPrototypeOf]]().If parent is not null, thenReturn ? parent.[[HasProperty]](P).Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.1.8.1">
	<buginformation>
		<summary>OrdinaryGet ( O, P, Receiver )</summary>
		<description>When the abstract operation OrdinaryGet is called with Object O, property key P, and ECMAScript language value Receiver, the following steps are taken: Assert: IsPropertyKey(P) is true.Let desc be ? O.[[GetOwnProperty]](P).If desc is undefined, thenLet parent be ? O.[[GetPrototypeOf]]().If parent is null, return undefined.Return ? parent.[[Get]](P, Receiver).If IsDataDescriptor(desc) is true, return desc.[[Value]].Assert: IsAccessorDescriptor(desc) is true.Let getter be desc.[[Get]].If getter is undefined, return undefined.Return ? Call(getter, Receiver).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.1.9.1">
	<buginformation>
		<summary>OrdinarySet ( O, P, V, Receiver )</summary>
		<description>When the abstract operation OrdinarySet is called with Object O, property key P, value V, and ECMAScript language value Receiver, the following steps are taken: Assert: IsPropertyKey(P) is true.Let ownDesc be ? O.[[GetOwnProperty]](P).If ownDesc is undefined, thenLet parent be ? O.[[GetPrototypeOf]]().If parent is not null, thenReturn ? parent.[[Set]](P, V, Receiver).Else,Set ownDesc to the PropertyDescriptor{[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}.If IsDataDescriptor(ownDesc) is true, thenIf ownDesc.[[Writable]] is false, return false.If Type(Receiver) is not Object, return false.Let existingDescriptor be ? Receiver.[[GetOwnProperty]](P).If existingDescriptor is not undefined, thenIf IsAccessorDescriptor(existingDescriptor) is true, return false.If existingDescriptor.[[Writable]] is false, return false.Let valueDesc be the PropertyDescriptor{[[Value]]: V}.Return ? Receiver.[[DefineOwnProperty]](P, valueDesc).Else Receiver does not currently have a property P,Return ? CreateDataProperty(Receiver, P, V).Assert: IsAccessorDescriptor(ownDesc) is true.Let setter be ownDesc.[[Set]].If setter is undefined, return false.Perform ? Call(setter, Receiver, « V »).Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.1.10.1">
	<buginformation>
		<summary>OrdinaryDelete ( O, P )</summary>
		<description>When the abstract operation OrdinaryDelete is called with Object O and property key P, the following steps are taken: Assert: IsPropertyKey(P) is true.Let desc be ? O.[[GetOwnProperty]](P).If desc is undefined, return true.If desc.[[Configurable]] is true, thenRemove the own property with name P from O.Return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.1.11.1">
	<buginformation>
		<summary>OrdinaryOwnPropertyKeys ( O )</summary>
		<description>When the abstract operation OrdinaryOwnPropertyKeys is called with Object O, the following steps are taken: Let keys be a new empty List.For each own property key P of O that is an integer index, in ascending numeric index order, doAdd P as the last element of keys.For each own property key P of O that is a String but is not an integer index, in ascending chronological order of property creation, doAdd P as the last element of keys.For each own property key P of O that is a Symbol, in ascending chronological order of property creation, doAdd P as the last element of keys.Return keys.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.1.12">
	<buginformation>
		<summary>ObjectCreate ( proto [ , internalSlotsList ] )</summary>
		<description>The abstract operation ObjectCreate with argument proto (an object or null) is used to specify the runtime creation of new ordinary objects. The optional argument internalSlotsList is a List of the names of additional internal slots that must be defined as part of the object. If the list is not provided, a new empty List is used. This abstract operation performs the following steps: If internalSlotsList was not provided, set internalSlotsList to a new empty List.Let obj be a newly created object with an internal slot for each name in internalSlotsList.Set obj&apos;s essential internal methods to the default ordinary object definitions specified in 9.1.Set obj.[[Prototype]] to proto.Set obj.[[Extensible]] to true.Return obj.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.1.13">
	<buginformation>
		<summary>OrdinaryCreateFromConstructor ( constructor, intrinsicDefaultProto [ , internalSlotsList ] )</summary>
		<description>The abstract operation OrdinaryCreateFromConstructor creates an  ordinary object whose [[Prototype]] value is retrieved from a  constructor&apos;s prototype property, if it exists. Otherwise the intrinsic named by intrinsicDefaultProto is used for [[Prototype]]. The optional internalSlotsList is a List of the names of additional internal slots that must be defined as part of the object. If the list is not provided, a new empty List is used. This abstract operation performs the following steps: Assert: intrinsicDefaultProto is a  String value that is this specification&apos;s name of an intrinsic object.  The corresponding object must be an intrinsic that is intended to be  used as the [[Prototype]] value of an object.Let proto be ? GetPrototypeFromConstructor(constructor, intrinsicDefaultProto).Return ObjectCreate(proto, internalSlotsList).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.1.14">
	<buginformation>
		<summary>GetPrototypeFromConstructor ( constructor, intrinsicDefaultProto )</summary>
		<description>The abstract operation GetPrototypeFromConstructor determines  the [[Prototype]] value that should be used to create an object  corresponding to a specific constructor. The value is retrieved from the  constructor&apos;s prototype property, if it exists. Otherwise the intrinsic named by intrinsicDefaultProto is used for [[Prototype]]. This abstract operation performs the following steps: Assert: intrinsicDefaultProto is a  String value that is this specification&apos;s name of an intrinsic object.  The corresponding object must be an intrinsic that is intended to be  used as the [[Prototype]] value of an object.Assert: IsCallable(constructor) is true.Let proto be ? Get(constructor, &amp;quot;prototype&amp;quot;).If Type(proto) is not Object, thenLet realm be ? GetFunctionRealm(constructor).Set proto to realm&apos;s intrinsic object named intrinsicDefaultProto.Return proto.        Note If constructor does not supply a [[Prototype]] value, the default value that is used is obtained from the realm of the constructor function rather than from the running execution context.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.2.1.1">
	<buginformation>
		<summary>PrepareForOrdinaryCall ( F, newTarget )</summary>
		<description>When the abstract operation PrepareForOrdinaryCall is called with function object F and ECMAScript language value newTarget, the following steps are taken: Assert: Type(newTarget) is Undefined or Object.Let callerContext be the running execution context.Let calleeContext be a new ECMAScript code execution context.Set the Function of calleeContext to F.Let calleeRealm be F.[[Realm]].Set the Realm of calleeContext to calleeRealm.Set the ScriptOrModule of calleeContext to F.[[ScriptOrModule]].Let localEnv be NewFunctionEnvironment(F, newTarget).Set the LexicalEnvironment of calleeContext to localEnv.Set the VariableEnvironment of calleeContext to localEnv.If callerContext is not already suspended, suspend callerContext.Push calleeContext onto the execution context stack; calleeContext is now the running execution context.NOTE: Any exception objects produced after this point are associated with calleeRealm.Return calleeContext.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.2.1.2">
	<buginformation>
		<summary>OrdinaryCallBindThis ( F, calleeContext, thisArgument )</summary>
		<description>When the abstract operation OrdinaryCallBindThis is called with function object F, execution context calleeContext, and ECMAScript value thisArgument, the following steps are taken: Let thisMode be F.[[ThisMode]].If thisMode is lexical, return NormalCompletion(undefined).Let calleeRealm be F.[[Realm]].Let localEnv be the LexicalEnvironment of calleeContext.If thisMode is strict, let thisValue be thisArgument.Else,If thisArgument is undefined or null, thenLet globalEnv be calleeRealm.[[GlobalEnv]].Let globalEnvRec be globalEnv&apos;s EnvironmentRecord.Assert: globalEnvRec is a global Environment Record.Let thisValue be globalEnvRec.[[GlobalThisValue]].Else,Let thisValue be ! ToObject(thisArgument).NOTE: ToObject produces wrapper objects using calleeRealm.Let envRec be localEnv&apos;s EnvironmentRecord.Assert: envRec is a function Environment Record.Assert: The next step never returns an abrupt completion because envRec.[[ThisBindingStatus]] is not &amp;quot;initialized&amp;quot;.Return envRec.BindThisValue(thisValue).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.2.1.3">
	<buginformation>
		<summary>OrdinaryCallEvaluateBody ( F, argumentsList )</summary>
		<description>When the abstract operation OrdinaryCallEvaluateBody is called with function object F and List argumentsList, the following steps are taken: Return the result of EvaluateBody of the parsed code that is F.[[ECMAScriptCode]] passing F and argumentsList as the arguments.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.2.2">
	<buginformation>
		<summary>[[Construct]] ( argumentsList, newTarget )</summary>
		<description>The [[Construct]] internal method for an ECMAScript function object F is called with parameters argumentsList and newTarget. argumentsList is a possibly empty List of ECMAScript language values. The following steps are taken: Assert: F is an ECMAScript function object.Assert: Type(newTarget) is Object.Let callerContext be the running execution context.Let kind be F.[[ConstructorKind]].If kind is &amp;quot;base&amp;quot;, thenLet thisArgument be ? OrdinaryCreateFromConstructor(newTarget, &amp;quot;%ObjectPrototype%&amp;quot;).Let calleeContext be PrepareForOrdinaryCall(F, newTarget).Assert: calleeContext is now the running execution context.If kind is &amp;quot;base&amp;quot;, perform OrdinaryCallBindThis(F, calleeContext, thisArgument).Let constructorEnv be the LexicalEnvironment of calleeContext.Let envRec be constructorEnv&apos;s EnvironmentRecord.Let result be OrdinaryCallEvaluateBody(F, argumentsList).Remove calleeContext from the execution context stack and restore callerContext as the running execution context.If result.[[Type]] is return, thenIf Type(result.[[Value]]) is Object, return NormalCompletion(result.[[Value]]).If kind is &amp;quot;base&amp;quot;, return NormalCompletion(thisArgument).If result.[[Value]] is not undefined, throw a TypeError exception.Else, ReturnIfAbrupt(result).Return ? envRec.GetThisBinding().</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.2.3">
	<buginformation>
		<summary>FunctionAllocate ( functionPrototype, strict, functionKind )</summary>
		<description>The abstract operation FunctionAllocate requires the three arguments functionPrototype, strict and functionKind. FunctionAllocate performs the following steps: Assert: Type(functionPrototype) is Object.Assert: functionKind is either &amp;quot;normal&amp;quot;, &amp;quot;non-constructor&amp;quot;, &amp;quot;generator&amp;quot;, or &amp;quot;async&amp;quot;.If functionKind is &amp;quot;normal&amp;quot;, let needsConstruct be true.Else, let needsConstruct be false.If functionKind is &amp;quot;non-constructor&amp;quot;, set functionKind to &amp;quot;normal&amp;quot;.Let F be a newly created ECMAScript function object with the internal slots listed in Table 27. All of those internal slots are initialized to undefined.Set F&apos;s essential internal methods to the default ordinary object definitions specified in 9.1.Set F.[[Call]] to the definition specified in 9.2.1.If needsConstruct is true, thenSet F.[[Construct]] to the definition specified in 9.2.2.Set F.[[ConstructorKind]] to &amp;quot;base&amp;quot;.Set F.[[Strict]] to strict.Set F.[[FunctionKind]] to functionKind.Set F.[[Prototype]] to functionPrototype.Set F.[[Extensible]] to true.Set F.[[Realm]] to the current Realm Record.Return F.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.2.4">
	<buginformation>
		<summary>FunctionInitialize ( F, kind, ParameterList, Body, Scope )</summary>
		<description>The abstract operation FunctionInitialize requires the arguments: a function object F, kind which is one of (Normal, Method, Arrow), a parameter list Parse Node specified by ParameterList, a body Parse Node specified by Body, a Lexical Environment specified by Scope. FunctionInitialize performs the following steps: Assert: F is an extensible object that does not have a length own property.Let len be the ExpectedArgumentCount of ParameterList.Perform ! DefinePropertyOrThrow(F, &amp;quot;length&amp;quot;, PropertyDescriptor{[[Value]]: len, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).Let Strict be F.[[Strict]].Set F.[[Environment]] to Scope.Set F.[[FormalParameters]] to ParameterList.Set F.[[ECMAScriptCode]] to Body.Set F.[[ScriptOrModule]] to GetActiveScriptOrModule().If kind is Arrow, set F.[[ThisMode]] to lexical.Else if Strict is true, set F.[[ThisMode]] to strict.Else, set F.[[ThisMode]] to global.Return F.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.2.5">
	<buginformation>
		<summary>FunctionCreate ( kind, ParameterList, Body, Scope, Strict [ , prototype ] )</summary>
		<description>The abstract operation FunctionCreate requires the arguments: kind which is one of (Normal, Method, Arrow), a parameter list Parse Node specified by ParameterList, a body Parse Node specified by Body, a Lexical Environment specified by Scope, a Boolean flag Strict, and optionally, an object prototype. FunctionCreate performs the following steps: If the prototype argument was not passed, thenSet prototype to the intrinsic object %FunctionPrototype%.If kind is not Normal, let allocKind be &amp;quot;non-constructor&amp;quot;.Else, let allocKind be &amp;quot;normal&amp;quot;.Let F be FunctionAllocate(prototype, Strict, allocKind).Return FunctionInitialize(F, kind, ParameterList, Body, Scope).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.2.6">
	<buginformation>
		<summary>GeneratorFunctionCreate ( kind, ParameterList, Body, Scope, Strict )</summary>
		<description>The abstract operation GeneratorFunctionCreate requires the arguments: kind which is one of (Normal, Method), a parameter list Parse Node specified by ParameterList, a body Parse Node specified by Body, a Lexical Environment specified by Scope, and a Boolean flag Strict. GeneratorFunctionCreate performs the following steps: Let functionPrototype be the intrinsic object %Generator%.Let F be FunctionAllocate(functionPrototype, Strict, &amp;quot;generator&amp;quot;).Return FunctionInitialize(F, kind, ParameterList, Body, Scope).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.2.7.1">
	<buginformation>
		<summary>%ThrowTypeError% ( )</summary>
		<description>The  %ThrowTypeError% intrinsic is an anonymous built-in function object that is defined once for each realm. When %ThrowTypeError% is called it performs the following steps: Throw a TypeError exception.          The value of the [[Extensible]] internal slot of a %ThrowTypeError% function is false. The length property of a %ThrowTypeError% function has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.2.8">
	<buginformation>
		<summary>MakeConstructor ( F [ , writablePrototype [ , prototype ] ] )</summary>
		<description>The abstract operation MakeConstructor requires a Function argument F and optionally, a Boolean writablePrototype and an object prototype. If prototype is provided it is assumed to already contain, if needed, a &amp;quot;constructor&amp;quot; property whose value is F. This operation converts F into a constructor by performing the following steps: Assert: F is an ECMAScript function object.Assert: F has a [[Construct]] internal method.Assert: F is an extensible object that does not have a prototype own property.If the writablePrototype argument was not provided, set writablePrototype to true.If the prototype argument was not provided, thenSet prototype to ObjectCreate(%ObjectPrototype%).Perform ! DefinePropertyOrThrow(prototype, &amp;quot;constructor&amp;quot;, PropertyDescriptor{[[Value]]: F, [[Writable]]: writablePrototype, [[Enumerable]]: false, [[Configurable]]: true }).Perform ! DefinePropertyOrThrow(F, &amp;quot;prototype&amp;quot;, PropertyDescriptor{[[Value]]: prototype, [[Writable]]: writablePrototype, [[Enumerable]]: false, [[Configurable]]: false}).Return NormalCompletion(undefined).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.2.9">
	<buginformation>
		<summary>MakeClassConstructor ( F )</summary>
		<description>The abstract operation MakeClassConstructor with argument F performs the following steps: Assert: F is an ECMAScript function object.Assert: F.[[FunctionKind]] is &amp;quot;normal&amp;quot;.Set F.[[FunctionKind]] to &amp;quot;classConstructor&amp;quot;.Return NormalCompletion(undefined).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.2.10">
	<buginformation>
		<summary>MakeMethod ( F, homeObject )</summary>
		<description>The abstract operation MakeMethod with arguments F and homeObject configures F as a method by performing the following steps: Assert: F is an ECMAScript function object.Assert: Type(homeObject) is Object.Set F.[[HomeObject]] to homeObject.Return NormalCompletion(undefined).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.2.11">
	<buginformation>
		<summary>SetFunctionName ( F, name [ , prefix ] )</summary>
		<description>The abstract operation SetFunctionName requires a Function argument F, a String or Symbol argument name and optionally a String argument prefix. This operation adds a name property to F by performing the following steps: Assert: F is an extensible object that does not have a name own property.Assert: Type(name) is either Symbol or String.Assert: If prefix was passed, then Type(prefix) is String.If Type(name) is Symbol, thenLet description be name&apos;s [[Description]] value.If description is undefined, set name to the empty String.Else, set name to the concatenation of &amp;quot;[&amp;quot;, description, and &amp;quot;]&amp;quot;.If prefix was passed, thenSet name to the concatenation of prefix, code unit 0x0020 (SPACE), and name.Return ! DefinePropertyOrThrow(F, &amp;quot;name&amp;quot;, PropertyDescriptor{[[Value]]: name, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.2.12">
	<buginformation>
		<summary>FunctionDeclarationInstantiation ( func, argumentsList )</summary>
		<description>Note 1 When an execution context is established for evaluating an ECMAScript function a new function Environment Record is created and bindings for each formal parameter are instantiated in that Environment Record.  Each declaration in the function body is also instantiated. If the  function&apos;s formal parameters do not include any default value  initializers then the body declarations are instantiated in the same Environment Record as the parameters. If default value parameter initializers exist, a second Environment Record  is created for the body declarations. Formal parameters and functions  are initialized as part of FunctionDeclarationInstantiation. All other  bindings are initialized during evaluation of the function body.  FunctionDeclarationInstantiation is performed as follows using arguments func and argumentsList. func is the function object for which the execution context is being established.  Let calleeContext be the running execution context.Let env be the LexicalEnvironment of calleeContext.Let envRec be env&apos;s EnvironmentRecord.Let code be func.[[ECMAScriptCode]].Let strict be func.[[Strict]].Let formals be func.[[FormalParameters]].Let parameterNames be the BoundNames of formals.If parameterNames has any duplicate entries, let hasDuplicates be true. Otherwise, let hasDuplicates be false.Let simpleParameterList be IsSimpleParameterList of formals.Let hasParameterExpressions be ContainsExpression of formals.Let varNames be the VarDeclaredNames of code.Let varDeclarations be the VarScopedDeclarations of code.Let lexicalNames be the LexicallyDeclaredNames of code.Let functionNames be a new empty List.Let functionsToInitialize be a new empty List.For each d in varDeclarations, in reverse list order, doIf d is neither a VariableDeclaration nor a ForBinding nor a BindingIdentifier, thenAssert: d is either a FunctionDeclaration, a GeneratorDeclaration, or an AsyncFunctionDeclaration.Let fn be the sole element of the BoundNames of d.If fn is not an element of functionNames, thenInsert fn as the first element of functionNames.NOTE: If there are multiple function declarations for the same name, the last declaration is used.Insert d as the first element of functionsToInitialize.Let argumentsObjectNeeded be true.If func.[[ThisMode]] is lexical, thenNOTE: Arrow functions never have an arguments objects.Set argumentsObjectNeeded to false.Else if &amp;quot;arguments&amp;quot; is an element of parameterNames, thenSet argumentsObjectNeeded to false.Else if hasParameterExpressions is false, thenIf &amp;quot;arguments&amp;quot; is an element of functionNames or if &amp;quot;arguments&amp;quot; is an element of lexicalNames, thenSet argumentsObjectNeeded to false.For each String paramName in parameterNames, doLet alreadyDeclared be envRec.HasBinding(paramName).NOTE:  Early errors ensure that duplicate parameter names can only occur in  non-strict functions that do not have parameter default values or rest  parameters.If alreadyDeclared is false, thenPerform ! envRec.CreateMutableBinding(paramName, false).If hasDuplicates is true, thenPerform ! envRec.InitializeBinding(paramName, undefined).If argumentsObjectNeeded is true, thenIf strict is true or if simpleParameterList is false, thenLet ao be CreateUnmappedArgumentsObject(argumentsList).Else,NOTE:  mapped argument object is only provided for non-strict functions that  don&apos;t have a rest parameter, any parameter default value initializers,  or any destructured parameters.Let ao be CreateMappedArgumentsObject(func, formals, argumentsList, envRec).If strict is true, thenPerform ! envRec.CreateImmutableBinding(&amp;quot;arguments&amp;quot;, false).Else,Perform ! envRec.CreateMutableBinding(&amp;quot;arguments&amp;quot;, false).Call envRec.InitializeBinding(&amp;quot;arguments&amp;quot;, ao).Append &amp;quot;arguments&amp;quot; to parameterNames.Let iteratorRecord be Record {[[Iterator]]: CreateListIterator(argumentsList), [[Done]]: false}.If hasDuplicates is true, thenPerform ? IteratorBindingInitialization for formals with iteratorRecord and undefined as arguments.Else,Perform ? IteratorBindingInitialization for formals with iteratorRecord and env as arguments.If hasParameterExpressions is false, thenNOTE: Only a single lexical environment is needed for the parameters and top-level vars.Let instantiatedVarNames be a copy of the List parameterNames.For each n in varNames, doIf n is not an element of instantiatedVarNames, thenAppend n to instantiatedVarNames.Perform ! envRec.CreateMutableBinding(n, false).Call envRec.InitializeBinding(n, undefined).Let varEnv be env.Let varEnvRec be envRec.Else,NOTE: A separate Environment Record  is needed to ensure that closures created by expressions in the formal  parameter list do not have visibility of declarations in the function  body.Let varEnv be NewDeclarativeEnvironment(env).Let varEnvRec be varEnv&apos;s EnvironmentRecord.Set the VariableEnvironment of calleeContext to varEnv.Let instantiatedVarNames be a new empty List.For each n in varNames, doIf n is not an element of instantiatedVarNames, thenAppend n to instantiatedVarNames.Perform ! varEnvRec.CreateMutableBinding(n, false).If n is not an element of parameterNames or if n is an element of functionNames, let initialValue be undefined.Else,Let initialValue be ! envRec.GetBindingValue(n, false).Call varEnvRec.InitializeBinding(n, initialValue).NOTE:  vars whose names are the same as a formal parameter, initially have the  same value as the corresponding initialized parameter.NOTE: Annex B.3.3.1 adds additional steps at this point.If strict is false, thenLet lexEnv be NewDeclarativeEnvironment(varEnv).NOTE: Non-strict functions use a separate lexical Environment Record for top-level lexical declarations so that a direct eval  can determine whether any var scoped declarations introduced by the  eval code conflict with pre-existing top-level lexically scoped  declarations. This is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record.Else, let lexEnv be varEnv.Let lexEnvRec be lexEnv&apos;s EnvironmentRecord.Set the LexicalEnvironment of calleeContext to lexEnv.Let lexDeclarations be the LexicallyScopedDeclarations of code.For each element d in lexDeclarations, doNOTE:  A lexically declared name cannot be the same as a function/generator  declaration, formal parameter, or a var name. Lexically declared names  are only instantiated here but not initialized.For each element dn of the BoundNames of d, doIf IsConstantDeclaration of d is true, thenPerform ! lexEnvRec.CreateImmutableBinding(dn, true).Else,Perform ! lexEnvRec.CreateMutableBinding(dn, false).For each Parse Node f in functionsToInitialize, doLet fn be the sole element of the BoundNames of f.Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.Perform ! varEnvRec.SetMutableBinding(fn, fo, false).Return NormalCompletion(empty).        Note 2 B.3.3  provides an extension to the above algorithm that is necessary for  backwards compatibility with web browser implementations of ECMAScript  that predate ECMAScript 2015.  Note 3 Parameter Initializers may contain direct eval expressions. Any top level declarations of such evals are only visible to the eval code (10.2). The creation of the environment for such declarations is described in  14.1.19.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.3.1">
	<buginformation>
		<summary>[[Call]] ( thisArgument, argumentsList )</summary>
		<description>The [[Call]] internal method for a built-in function object F is called with parameters thisArgument and argumentsList, a List of ECMAScript language values. The following steps are taken: Let callerContext be the running execution context.If callerContext is not already suspended, suspend callerContext.Let calleeContext be a new ECMAScript code execution context.Set the Function of calleeContext to F.Let calleeRealm be F.[[Realm]].Set the Realm of calleeContext to calleeRealm.Set the ScriptOrModule of calleeContext to F.[[ScriptOrModule]].Perform any necessary implementation-defined initialization of calleeContext.Push calleeContext onto the execution context stack; calleeContext is now the running execution context.Let result be the Completion Record that is the result of evaluating F in an implementation-defined manner that conforms to the specification of F. thisArgument is the this value, argumentsList provides the named parameters, and the NewTarget value is undefined.Remove calleeContext from the execution context stack and restore callerContext as the running execution context.Return result.        Note When calleeContext is removed from the execution context stack it must not be destroyed if it has been suspended and retained by an accessible generator object for later resumption.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.3.2">
	<buginformation>
		<summary>[[Construct]] ( argumentsList, newTarget )</summary>
		<description>The [[Construct]] internal method for built-in function object F is called with parameters argumentsList and newTarget. The steps performed are the same as [[Call]] (see  9.3.1) except that step 10 is replaced by: Let result be the Completion Record that is the result of evaluating F in an implementation-defined manner that conforms to the specification of F. The this value is uninitialized, argumentsList provides the named parameters, and newTarget provides the NewTarget value.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.3.3">
	<buginformation>
		<summary>CreateBuiltinFunction ( realm, steps, prototype [ , internalSlotsList ] )</summary>
		<description>The abstract operation CreateBuiltinFunction takes arguments realm, steps, and prototype. The optional argument internalSlotsList is a List of the names of additional internal slots that must be defined as part of the object. If the list is not provided, a new empty List is used. CreateBuiltinFunction returns a built-in function object created by the following steps: Assert: realm is a Realm Record.Assert: steps is either a set of algorithm steps or other definition of a function&apos;s behaviour provided in this specification.Let func be a new built-in function object that when called performs the action described by steps. The new function object has internal slots whose names are the elements of internalSlotsList. The initial value of each of those internal slots is undefined.Set func.[[Realm]] to realm.Set func.[[Prototype]] to prototype.Set func.[[Extensible]] to true.Set func.[[ScriptOrModule]] to null.Return func.        Each built-in function defined in this specification is created  as if by calling the CreateBuiltinFunction abstract operation, unless  otherwise specified.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.1.1">
	<buginformation>
		<summary>[[Call]] ( thisArgument, argumentsList )</summary>
		<description>When the [[Call]] internal method of a bound function exotic object, F, which was created using the bind function is called with parameters thisArgument and argumentsList, a List of ECMAScript language values, the following steps are taken: Let target be F.[[BoundTargetFunction]].Let boundThis be F.[[BoundThis]].Let boundArgs be F.[[BoundArguments]].Let args be a new list containing the same values as the list boundArgs in the same order followed by the same values as the list argumentsList in the same order.Return ? Call(target, boundThis, args).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.1.2">
	<buginformation>
		<summary>[[Construct]] ( argumentsList, newTarget )</summary>
		<description>When the [[Construct]] internal method of a bound function exotic object, F that was created using the bind function is called with a list of arguments argumentsList and newTarget, the following steps are taken: Let target be F.[[BoundTargetFunction]].Assert: target has a [[Construct]] internal method.Let boundArgs be F.[[BoundArguments]].Let args be a new list containing the same values as the list boundArgs in the same order followed by the same values as the list argumentsList in the same order.If SameValue(F, newTarget) is true, set newTarget to target.Return ? Construct(target, args, newTarget).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.1.3">
	<buginformation>
		<summary>BoundFunctionCreate ( targetFunction, boundThis, boundArgs )</summary>
		<description>The abstract operation BoundFunctionCreate with arguments targetFunction, boundThis and boundArgs is used to specify the creation of new Bound Function exotic objects. It performs the following steps: Assert: Type(targetFunction) is Object.Let proto be ? targetFunction.[[GetPrototypeOf]]().Let obj be a newly created object.Set obj&apos;s essential internal methods to the default ordinary object definitions specified in 9.1.Set obj.[[Call]] as described in 9.4.1.1.If targetFunction has a [[Construct]] internal method, thenSet obj.[[Construct]] as described in 9.4.1.2.Set obj.[[Prototype]] to proto.Set obj.[[Extensible]] to true.Set obj.[[BoundTargetFunction]] to targetFunction.Set obj.[[BoundThis]] to boundThis.Set obj.[[BoundArguments]] to boundArgs.Return obj.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.2.1">
	<buginformation>
		<summary>[[DefineOwnProperty]] ( P, Desc )</summary>
		<description>When the [[DefineOwnProperty]] internal method of an Array exotic object A is called with property key P, and Property Descriptor Desc, the following steps are taken: Assert: IsPropertyKey(P) is true.If P is &amp;quot;length&amp;quot;, thenReturn ? ArraySetLength(A, Desc).Else if P is an array index, thenLet oldLenDesc be OrdinaryGetOwnProperty(A, &amp;quot;length&amp;quot;).Assert: oldLenDesc will never be undefined or an accessor descriptor because Array objects are created with a length data property that cannot be deleted or reconfigured.Let oldLen be oldLenDesc.[[Value]].Let index be ! ToUint32(P).If index ≥ oldLen and oldLenDesc.[[Writable]] is false, return false.Let succeeded be ! OrdinaryDefineOwnProperty(A, P, Desc).If succeeded is false, return false.If index ≥ oldLen, thenSet oldLenDesc.[[Value]] to index + 1.Let succeeded be OrdinaryDefineOwnProperty(A, &amp;quot;length&amp;quot;, oldLenDesc).Assert: succeeded is true.Return true.Return OrdinaryDefineOwnProperty(A, P, Desc).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.2.2">
	<buginformation>
		<summary>ArrayCreate ( length [ , proto ] )</summary>
		<description>The abstract operation ArrayCreate with argument length (either 0 or a positive integer) and optional argument proto is used to specify the creation of new Array exotic objects. It performs the following steps: Assert: length is an integer Number ≥ 0.If length is -0, set length to +0.If length&gt;232-1, throw a RangeError exception.If the proto argument was not passed, set proto to the intrinsic object %ArrayPrototype%.Let A be a newly created Array exotic object.Set A&apos;s essential internal methods except for [[DefineOwnProperty]] to the default ordinary object definitions specified in 9.1.Set A.[[DefineOwnProperty]] as specified in 9.4.2.1.Set A.[[Prototype]] to proto.Set A.[[Extensible]] to true.Perform ! OrdinaryDefineOwnProperty(A, &amp;quot;length&amp;quot;, PropertyDescriptor{[[Value]]: length, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).Return A.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.2.3">
	<buginformation>
		<summary>ArraySpeciesCreate ( originalArray, length )</summary>
		<description>The abstract operation ArraySpeciesCreate with arguments originalArray and length is used to specify the creation of a new Array object using a constructor function that is derived from originalArray. It performs the following steps: Assert: length is an integer Number ≥ 0.If length is -0, set length to +0.Let isArray be ? IsArray(originalArray).If isArray is false, return ? ArrayCreate(length).Let C be ? Get(originalArray, &amp;quot;constructor&amp;quot;).If IsConstructor(C) is true, thenLet thisRealm be the current Realm Record.Let realmC be ? GetFunctionRealm(C).If thisRealm and realmC are not the same Realm Record, thenIf SameValue(C, realmC.[[Intrinsics]].[[%Array%]]) is true, set C to undefined.If Type(C) is Object, thenSet C to ? Get(C, @@species).If C is null, set C to undefined.If C is undefined, return ? ArrayCreate(length).If IsConstructor(C) is false, throw a TypeError exception.Return ? Construct(C, « length »).          Note If originalArray was created using the standard built-in Array constructor for a realm that is not the realm of the running execution context, then a new Array is created using the realm of the running execution context.  This maintains compatibility with Web browsers that have historically  had that behaviour for the Array.prototype methods that now are defined  using ArraySpeciesCreate.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.2.4">
	<buginformation>
		<summary>ArraySetLength ( A, Desc )</summary>
		<description>When the abstract operation ArraySetLength is called with an Array exotic object A, and Property Descriptor Desc, the following steps are taken: If Desc.[[Value]] is absent, thenReturn OrdinaryDefineOwnProperty(A, &amp;quot;length&amp;quot;, Desc).Let newLenDesc be a copy of Desc.Let newLen be ? ToUint32(Desc.[[Value]]).Let numberLen be ? ToNumber(Desc.[[Value]]).If newLen ≠ numberLen, throw a RangeError exception.Set newLenDesc.[[Value]] to newLen.Let oldLenDesc be OrdinaryGetOwnProperty(A, &amp;quot;length&amp;quot;).Assert: oldLenDesc will never be undefined or an accessor descriptor because Array objects are created with a length data property that cannot be deleted or reconfigured.Let oldLen be oldLenDesc.[[Value]].If newLen ≥ oldLen, thenReturn OrdinaryDefineOwnProperty(A, &amp;quot;length&amp;quot;, newLenDesc).If oldLenDesc.[[Writable]] is false, return false.If newLenDesc.[[Writable]] is absent or has the value true, let newWritable be true.Else,Need to defer setting the [[Writable]] attribute to false in case any elements cannot be deleted.Let newWritable be false.Set newLenDesc.[[Writable]] to true.Let succeeded be ! OrdinaryDefineOwnProperty(A, &amp;quot;length&amp;quot;, newLenDesc).If succeeded is false, return false.Repeat, while newLen &lt; oldLen,Set oldLen to oldLen - 1.Let deleteSucceeded be ! A.[[Delete]](! ToString(oldLen)).If deleteSucceeded is false, thenSet newLenDesc.[[Value]] to oldLen + 1.If newWritable is false, set newLenDesc.[[Writable]] to false.Let succeeded be ! OrdinaryDefineOwnProperty(A, &amp;quot;length&amp;quot;, newLenDesc).Return false.If newWritable is false, thenReturn OrdinaryDefineOwnProperty(A, &amp;quot;length&amp;quot;, PropertyDescriptor{[[Writable]]: false}). This call will always return true.Return true.          Note In steps 3 and 4, if Desc.[[Value]] is an object then its valueOf method is called twice. This is legacy behaviour that was specified with this effect starting with the 2nd Edition of this specification.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.3.1">
	<buginformation>
		<summary>[[GetOwnProperty]] ( P )</summary>
		<description>When the [[GetOwnProperty]] internal method of a String exotic object S is called with property key P, the following steps are taken: Assert: IsPropertyKey(P) is true.Let desc be OrdinaryGetOwnProperty(S, P).If desc is not undefined, return desc.Return ! StringGetOwnProperty(S, P).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.3.2">
	<buginformation>
		<summary>[[DefineOwnProperty]] ( P, Desc )</summary>
		<description>When the [[DefineOwnProperty]] internal method of a String exotic object S is called with property key P, and Property Descriptor Desc, the following steps are taken: Assert: IsPropertyKey(P) is true.Let stringDesc be ! StringGetOwnProperty(S, P).If stringDesc is not undefined, thenLet extensible be S.[[Extensible]].Return ! IsCompatiblePropertyDescriptor(extensible, Desc, stringDesc).Return ! OrdinaryDefineOwnProperty(S, P, Desc).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.3.3">
	<buginformation>
		<summary>[[OwnPropertyKeys]] ( )</summary>
		<description>When the [[OwnPropertyKeys]] internal method of a String exotic object O is called, the following steps are taken: Let keys be a new empty List.Let str be the String value of O.[[StringData]].Let len be the number of elements in str.For each integer i starting with 0 such that i &lt; len, in ascending order, doAdd ! ToString(i) as the last element of keys.For each own property key P of O such that P is an integer index and ToInteger(P) ≥ len, in ascending numeric index order, doAdd P as the last element of keys.For each own property key P of O such that Type(P) is String and P is not an integer index, in ascending chronological order of property creation, doAdd P as the last element of keys.For each own property key P of O such that Type(P) is Symbol, in ascending chronological order of property creation, doAdd P as the last element of keys.Return keys.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.3.4">
	<buginformation>
		<summary>StringCreate ( value, prototype )</summary>
		<description>The abstract operation StringCreate with arguments value and prototype is used to specify the creation of new String exotic objects. It performs the following steps: Assert: Type(value) is String.Let S be a newly created String exotic object.Set S.[[StringData]] to value.Set S&apos;s essential internal methods to the default ordinary object definitions specified in 9.1.Set S.[[GetOwnProperty]] as specified in 9.4.3.1.Set S.[[DefineOwnProperty]] as specified in 9.4.3.2.Set S.[[OwnPropertyKeys]] as specified in 9.4.3.3.Set S.[[Prototype]] to prototype.Set S.[[Extensible]] to true.Let length be the number of code unit elements in value.Perform ! DefinePropertyOrThrow(S, &amp;quot;length&amp;quot;, PropertyDescriptor{[[Value]]: length, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }).Return S.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.3.5">
	<buginformation>
		<summary>StringGetOwnProperty ( S, P )</summary>
		<description>The abstract operation StringGetOwnProperty called with arguments S and P performs the following steps: Assert: S is an Object that has a [[StringData]] internal slot.Assert: IsPropertyKey(P) is true.If Type(P) is not String, return undefined.Let index be ! CanonicalNumericIndexString(P).If index is undefined, return undefined.If IsInteger(index) is false, return undefined.If index</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.4.1">
	<buginformation>
		<summary>[[GetOwnProperty]] ( P )</summary>
		<description>The [[GetOwnProperty]] internal method of an arguments exotic object when called with a property key P performs the following steps: Let args be the arguments object.Let desc be OrdinaryGetOwnProperty(args, P).If desc is undefined, return desc.Let map be args.[[ParameterMap]].Let isMapped be ! HasOwnProperty(map, P).If isMapped is true, thenSet desc.[[Value]] to Get(map, P).Return desc.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.4.2">
	<buginformation>
		<summary>[[DefineOwnProperty]] ( P, Desc )</summary>
		<description>The [[DefineOwnProperty]] internal method of an arguments exotic object when called with a property key P and Property Descriptor Desc performs the following steps: Let args be the arguments object.Let map be args.[[ParameterMap]].Let isMapped be HasOwnProperty(map, P).Let newArgDesc be Desc.If isMapped is true and IsDataDescriptor(Desc) is true, thenIf Desc.[[Value]] is not present and Desc.[[Writable]] is present and its value is false, thenSet newArgDesc to a copy of Desc.Set newArgDesc.[[Value]] to Get(map, P).Let allowed be ? OrdinaryDefineOwnProperty(args, P, newArgDesc).If allowed is false, return false.If isMapped is true, thenIf IsAccessorDescriptor(Desc) is true, thenCall map.[[Delete]](P).Else,If Desc.[[Value]] is present, thenLet setStatus be Set(map, P, Desc.[[Value]], false).Assert: setStatus is true because formal parameters mapped by argument objects are always writable.If Desc.[[Writable]] is present and its value is false, thenCall map.[[Delete]](P).Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.4.3">
	<buginformation>
		<summary>[[Get]] ( P, Receiver )</summary>
		<description>The [[Get]] internal method of an arguments exotic object when called with a property key P and ECMAScript language value Receiver performs the following steps: Let args be the arguments object.Let map be args.[[ParameterMap]].Let isMapped be ! HasOwnProperty(map, P).If isMapped is false, thenReturn ? OrdinaryGet(args, P, Receiver).Else map contains a formal parameter mapping for P,Return Get(map, P).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.4.4">
	<buginformation>
		<summary>[[Set]] ( P, V, Receiver )</summary>
		<description>The [[Set]] internal method of an arguments exotic object when called with property key P, value V, and ECMAScript language value Receiver performs the following steps: Let args be the arguments object.If SameValue(args, Receiver) is false, thenLet isMapped be false.Else,Let map be args.[[ParameterMap]].Let isMapped be ! HasOwnProperty(map, P).If isMapped is true, thenLet setStatus be Set(map, P, V, false).Assert: setStatus is true because formal parameters mapped by argument objects are always writable.Return ? OrdinarySet(args, P, V, Receiver).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.4.5">
	<buginformation>
		<summary>[[Delete]] ( P )</summary>
		<description>The [[Delete]] internal method of an arguments exotic object when called with a property key P performs the following steps: Let args be the arguments object.Let map be args.[[ParameterMap]].Let isMapped be ! HasOwnProperty(map, P).Let result be ? OrdinaryDelete(args, P).If result is true and isMapped is true, thenCall map.[[Delete]](P).Return result.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.4.6">
	<buginformation>
		<summary>CreateUnmappedArgumentsObject ( argumentsList )</summary>
		<description>The abstract operation CreateUnmappedArgumentsObject called with an argument argumentsList performs the following steps: Let len be the number of elements in argumentsList.Let obj be ObjectCreate(%ObjectPrototype%, « [[ParameterMap]] »).Set obj.[[ParameterMap]] to undefined.Perform DefinePropertyOrThrow(obj, &amp;quot;length&amp;quot;, PropertyDescriptor{[[Value]]: len, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).Let index be 0.Repeat, while index &lt; len,Let val be argumentsList[index].Perform CreateDataProperty(obj, ! ToString(index), val).Let index be index + 1.Perform ! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor {[[Value]]: %ArrayProto_values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).Perform ! DefinePropertyOrThrow(obj, &amp;quot;callee&amp;quot;, PropertyDescriptor {[[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: false, [[Configurable]]: false}).Return obj.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.4.7.1">
	<buginformation>
		<summary>MakeArgGetter ( name, env )</summary>
		<description>The abstract operation MakeArgGetter called with String name and Environment Record env creates a built-in function object that when executed returns the value bound for name in env. It performs the following steps: Let realm be the current Realm Record.Let steps be the steps of an ArgGetter function as specified below.Let getter be CreateBuiltinFunction(realm, steps, %FunctionPrototype%, « [[Name]], [[Env]] »).Set getter.[[Name]] to name.Set getter.[[Env]] to env.Return getter.            An ArgGetter function is an anonymous built-in function with [[Name]] and [[Env]] internal slots. When an ArgGetter function f that expects no arguments is called it performs the following steps: Let name be f.[[Name]].Let env be f.[[Env]].Return env.GetBindingValue(name, false).            Note ArgGetter functions are never directly accessible to ECMAScript code.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.4.7.2">
	<buginformation>
		<summary>MakeArgSetter ( name, env )</summary>
		<description>The abstract operation MakeArgSetter called with String name and Environment Record env creates a built-in function object that when executed sets the value bound for name in env. It performs the following steps: Let realm be the current Realm Record.Let steps be the steps of an ArgSetter function as specified below.Let setter be CreateBuiltinFunction(realm, steps, %FunctionPrototype%, « [[Name]], [[Env]] »).Set setter.[[Name]] to name.Set setter.[[Env]] to env.Return setter.            An ArgSetter function is an anonymous built-in function with [[Name]] and [[Env]] internal slots. When an ArgSetter function f is called with argument value it performs the following steps: Let name be f.[[Name]].Let env be f.[[Env]].Return env.SetMutableBinding(name, value, false).            Note ArgSetter functions are never directly accessible to ECMAScript code.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.5.1">
	<buginformation>
		<summary>[[GetOwnProperty]] ( P )</summary>
		<description>When the [[GetOwnProperty]] internal method of an Integer Indexed exotic object O is called with property key P, the following steps are taken: Assert: IsPropertyKey(P) is true.Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.If Type(P) is String, thenLet numericIndex be ! CanonicalNumericIndexString(P).If numericIndex is not undefined, thenLet value be ? IntegerIndexedElementGet(O, numericIndex).If value is undefined, return undefined.Return a PropertyDescriptor{[[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: false}.Return OrdinaryGetOwnProperty(O, P).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.5.2">
	<buginformation>
		<summary>[[HasProperty]]( P )</summary>
		<description>When the [[HasProperty]] internal method of an Integer Indexed exotic object O is called with property key P, the following steps are taken: Assert: IsPropertyKey(P) is true.Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.If Type(P) is String, thenLet numericIndex be ! CanonicalNumericIndexString(P).If numericIndex is not undefined, thenLet buffer be O.[[ViewedArrayBuffer]].If IsDetachedBuffer(buffer) is true, throw a TypeError exception.If IsInteger(numericIndex) is false, return false.If numericIndex</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.5.3">
	<buginformation>
		<summary>[[DefineOwnProperty]] ( P, Desc )</summary>
		<description>When the [[DefineOwnProperty]] internal method of an Integer Indexed exotic object O is called with property key P, and Property Descriptor Desc, the following steps are taken: Assert: IsPropertyKey(P) is true.Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.If Type(P) is String, thenLet numericIndex be ! CanonicalNumericIndexString(P).If numericIndex is not undefined, thenIf IsInteger(numericIndex) is false, return false.If numericIndex</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.5.4">
	<buginformation>
		<summary>[[Get]] ( P, Receiver )</summary>
		<description>When the [[Get]] internal method of an Integer Indexed exotic object O is called with property key P and ECMAScript language value Receiver, the following steps are taken: Assert: IsPropertyKey(P) is true.If Type(P) is String, thenLet numericIndex be ! CanonicalNumericIndexString(P).If numericIndex is not undefined, thenReturn ? IntegerIndexedElementGet(O, numericIndex).Return ? OrdinaryGet(O, P, Receiver).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.5.5">
	<buginformation>
		<summary>[[Set]] ( P, V, Receiver )</summary>
		<description>When the [[Set]] internal method of an Integer Indexed exotic object O is called with property key P, value V, and ECMAScript language value Receiver, the following steps are taken: Assert: IsPropertyKey(P) is true.If Type(P) is String, thenLet numericIndex be ! CanonicalNumericIndexString(P).If numericIndex is not undefined, thenReturn ? IntegerIndexedElementSet(O, numericIndex, V).Return ? OrdinarySet(O, P, V, Receiver).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.5.6">
	<buginformation>
		<summary>[[OwnPropertyKeys]] ( )</summary>
		<description>When the [[OwnPropertyKeys]] internal method of an Integer Indexed exotic object O is called, the following steps are taken: Let keys be a new empty List.Assert: O is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.Let len be O.[[ArrayLength]].For each integer i starting with 0 such that i &lt; len, in ascending order, doAdd ! ToString(i) as the last element of keys.For each own property key P of O such that Type(P) is String and P is not an integer index, in ascending chronological order of property creation, doAdd P as the last element of keys.For each own property key P of O such that Type(P) is Symbol, in ascending chronological order of property creation, doAdd P as the last element of keys.Return keys.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.5.7">
	<buginformation>
		<summary>IntegerIndexedObjectCreate ( prototype, internalSlotsList )</summary>
		<description>The abstract operation IntegerIndexedObjectCreate with arguments prototype and internalSlotsList is used to specify the creation of new Integer Indexed exotic objects. The argument internalSlotsList is a List  of the names of additional internal slots that must be defined as part  of the object. IntegerIndexedObjectCreate performs the following steps: Assert: internalSlotsList contains the names [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]].Let A be a newly created object with an internal slot for each name in internalSlotsList.Set A&apos;s essential internal methods to the default ordinary object definitions specified in 9.1.Set A.[[GetOwnProperty]] as specified in 9.4.5.1.Set A.[[HasProperty]] as specified in 9.4.5.2.Set A.[[DefineOwnProperty]] as specified in 9.4.5.3.Set A.[[Get]] as specified in 9.4.5.4.Set A.[[Set]] as specified in 9.4.5.5.Set A.[[OwnPropertyKeys]] as specified in 9.4.5.6.Set A.[[Prototype]] to prototype.Set A.[[Extensible]] to true.Return A.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.5.8">
	<buginformation>
		<summary>IntegerIndexedElementGet ( O, index )</summary>
		<description>The abstract operation IntegerIndexedElementGet with arguments O and index performs the following steps: Assert: Type(index) is Number.Assert: O is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.Let buffer be O.[[ViewedArrayBuffer]].If IsDetachedBuffer(buffer) is true, throw a TypeError exception.If IsInteger(index) is false, return undefined.If index</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.5.9">
	<buginformation>
		<summary>IntegerIndexedElementSet ( O, index, value )</summary>
		<description>The abstract operation IntegerIndexedElementSet with arguments O, index, and value performs the following steps: Assert: Type(index) is Number.Assert: O is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.Let numValue be ? ToNumber(value).Let buffer be O.[[ViewedArrayBuffer]].If IsDetachedBuffer(buffer) is true, throw a TypeError exception.If IsInteger(index) is false, return false.If index</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.6.1">
	<buginformation>
		<summary>[[SetPrototypeOf]] ( V )</summary>
		<description>When the [[SetPrototypeOf]] internal method of a module namespace exotic object O is called with argument V, the following steps are taken: Return ? SetImmutablePrototype(O, V).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.6.2">
	<buginformation>
		<summary>[[IsExtensible]] ( )</summary>
		<description>When the [[IsExtensible]] internal method of a module namespace exotic object O is called, the following steps are taken: Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.6.3">
	<buginformation>
		<summary>[[PreventExtensions]] ( )</summary>
		<description>When the [[PreventExtensions]] internal method of a module namespace exotic object O is called, the following steps are taken: Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.6.4">
	<buginformation>
		<summary>[[GetOwnProperty]] ( P )</summary>
		<description>When the [[GetOwnProperty]] internal method of a module namespace exotic object O is called with property key P, the following steps are taken: If Type(P) is Symbol, return OrdinaryGetOwnProperty(O, P).Let exports be O.[[Exports]].If P is not an element of exports, return undefined.Let value be ? O.[[Get]](P, O).Return PropertyDescriptor{[[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.6.5">
	<buginformation>
		<summary>[[DefineOwnProperty]] ( P, Desc )</summary>
		<description>When the [[DefineOwnProperty]] internal method of a module namespace exotic object O is called with property key P and Property Descriptor Desc, the following steps are taken: Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.6.6">
	<buginformation>
		<summary>[[HasProperty]] ( P )</summary>
		<description>When the [[HasProperty]] internal method of a module namespace exotic object O is called with property key P, the following steps are taken: If Type(P) is Symbol, return OrdinaryHasProperty(O, P).Let exports be O.[[Exports]].If P is an element of exports, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.6.7">
	<buginformation>
		<summary>[[Get]] ( P, Receiver )</summary>
		<description>When the [[Get]] internal method of a module namespace exotic object O is called with property key P and ECMAScript language value Receiver, the following steps are taken: Assert: IsPropertyKey(P) is true.If Type(P) is Symbol, thenReturn ? OrdinaryGet(O, P, Receiver).Let exports be O.[[Exports]].If P is not an element of exports, return undefined.Let m be O.[[Module]].Let binding be ? m.ResolveExport(P, « »).Assert: binding is neither null nor &amp;quot;ambiguous&amp;quot;.Let targetModule be binding.[[Module]].Assert: targetModule is not undefined.Let targetEnv be targetModule.[[Environment]].If targetEnv is undefined, throw a ReferenceError exception.Let targetEnvRec be targetEnv&apos;s EnvironmentRecord.Return ? targetEnvRec.GetBindingValue(binding.[[BindingName]], true).          Note ResolveExport is idempotent and side-effect free. An  implementation might choose to pre-compute or cache the ResolveExport  results for the [[Exports]] of each module namespace exotic object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.6.8">
	<buginformation>
		<summary>[[Set]] ( P, V, Receiver )</summary>
		<description>When the [[Set]] internal method of a module namespace exotic object O is called with property key P, value V, and ECMAScript language value Receiver, the following steps are taken: Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.6.9">
	<buginformation>
		<summary>[[Delete]] ( P )</summary>
		<description>When the [[Delete]] internal method of a module namespace exotic object O is called with property key P, the following steps are taken: Assert: IsPropertyKey(P) is true.Let exports be O.[[Exports]].If P is an element of exports, return false.Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.6.10">
	<buginformation>
		<summary>[[OwnPropertyKeys]] ( )</summary>
		<description>When the [[OwnPropertyKeys]] internal method of a module namespace exotic object O is called, the following steps are taken: Let exports be a copy of O.[[Exports]].Let symbolKeys be ! OrdinaryOwnPropertyKeys(O).Append all the entries of symbolKeys to the end of exports.Return exports.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.6.11">
	<buginformation>
		<summary>ModuleNamespaceCreate ( module, exports )</summary>
		<description>The abstract operation ModuleNamespaceCreate with arguments module, and exports is used to specify the creation of new module namespace exotic objects. It performs the following steps: Assert: module is a Module Record.Assert: module.[[Namespace]] is undefined.Assert: exports is a List of String values.Let M be a newly created object.Set M&apos;s essential internal methods to the definitions specified in 9.4.6.Set M.[[Module]] to module.Let sortedExports be a new List containing the same values as the list exports where the values are ordered as if an Array of the same values had been sorted using Array.prototype.sort using undefined as comparefn.Set M.[[Exports]] to sortedExports.Create own properties of M corresponding to the definitions in 26.3.Set module.[[Namespace]] to M.Return M.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.7.1">
	<buginformation>
		<summary>[[SetPrototypeOf]] ( V )</summary>
		<description>When the [[SetPrototypeOf]] internal method of an immutable prototype exotic object O is called with argument V, the following steps are taken: Return ? SetImmutablePrototype(O, V).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.4.7.2">
	<buginformation>
		<summary>SetImmutablePrototype ( O, V )</summary>
		<description>When the SetImmutablePrototype abstract operation is called with arguments O and V, the following steps are taken: Assert: Either Type(V) is Object or Type(V) is Null.Let current be ? O.[[GetPrototypeOf]]().If SameValue(V, current) is true, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.5.1">
	<buginformation>
		<summary>[[GetPrototypeOf]] ( )</summary>
		<description>When the [[GetPrototypeOf]] internal method of a Proxy exotic object O is called, the following steps are taken: Let handler be O.[[ProxyHandler]].If handler is null, throw a TypeError exception.Assert: Type(handler) is Object.Let target be O.[[ProxyTarget]].Let trap be ? GetMethod(handler, &amp;quot;getPrototypeOf&amp;quot;).If trap is undefined, thenReturn ? target.[[GetPrototypeOf]]().Let handlerProto be ? Call(trap, handler, « target »).If Type(handlerProto) is neither Object nor Null, throw a TypeError exception.Let extensibleTarget be ? IsExtensible(target).If extensibleTarget is true, return handlerProto.Let targetProto be ? target.[[GetPrototypeOf]]().If SameValue(handlerProto, targetProto) is false, throw a TypeError exception.Return handlerProto.        Note [[GetPrototypeOf]] for proxy objects enforces the following invariants:               The result of [[GetPrototypeOf]] must be either an Object or null.                                    If the target object is not extensible, [[GetPrototypeOf]]  applied to the proxy object must return the same value as  [[GetPrototypeOf]] applied to the proxy object&apos;s target object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.5.2">
	<buginformation>
		<summary>[[SetPrototypeOf]] ( V )</summary>
		<description>When the [[SetPrototypeOf]] internal method of a Proxy exotic object O is called with argument V, the following steps are taken: Assert: Either Type(V) is Object or Type(V) is Null.Let handler be O.[[ProxyHandler]].If handler is null, throw a TypeError exception.Assert: Type(handler) is Object.Let target be O.[[ProxyTarget]].Let trap be ? GetMethod(handler, &amp;quot;setPrototypeOf&amp;quot;).If trap is undefined, thenReturn ? target.[[SetPrototypeOf]](V).Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, V »)).If booleanTrapResult is false, return false.Let extensibleTarget be ? IsExtensible(target).If extensibleTarget is true, return true.Let targetProto be ? target.[[GetPrototypeOf]]().If SameValue(V, targetProto) is false, throw a TypeError exception.Return true.        Note [[SetPrototypeOf]] for proxy objects enforces the following invariants:               The result of [[SetPrototypeOf]] is a Boolean value.                                    If the target object is not extensible, the argument value  must be the same as the result of [[GetPrototypeOf]] applied to target  object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.5.3">
	<buginformation>
		<summary>[[IsExtensible]] ( )</summary>
		<description>When the [[IsExtensible]] internal method of a Proxy exotic object O is called, the following steps are taken: Let handler be O.[[ProxyHandler]].If handler is null, throw a TypeError exception.Assert: Type(handler) is Object.Let target be O.[[ProxyTarget]].Let trap be ? GetMethod(handler, &amp;quot;isExtensible&amp;quot;).If trap is undefined, thenReturn ? target.[[IsExtensible]]().Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target »)).Let targetResult be ? target.[[IsExtensible]]().If SameValue(booleanTrapResult, targetResult) is false, throw a TypeError exception.Return booleanTrapResult.        Note [[IsExtensible]] for proxy objects enforces the following invariants:               The result of [[IsExtensible]] is a Boolean value.                                    [[IsExtensible]] applied to the proxy object must return the  same value as [[IsExtensible]] applied to the proxy object&apos;s target  object with the same argument.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.5.4">
	<buginformation>
		<summary>[[PreventExtensions]] ( )</summary>
		<description>When the [[PreventExtensions]] internal method of a Proxy exotic object O is called, the following steps are taken: Let handler be O.[[ProxyHandler]].If handler is null, throw a TypeError exception.Assert: Type(handler) is Object.Let target be O.[[ProxyTarget]].Let trap be ? GetMethod(handler, &amp;quot;preventExtensions&amp;quot;).If trap is undefined, thenReturn ? target.[[PreventExtensions]]().Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target »)).If booleanTrapResult is true, thenLet targetIsExtensible be ? target.[[IsExtensible]]().If targetIsExtensible is true, throw a TypeError exception.Return booleanTrapResult.        Note [[PreventExtensions]] for proxy objects enforces the following invariants:               The result of [[PreventExtensions]] is a Boolean value.                                    [[PreventExtensions]] applied to the proxy object only returns true if [[IsExtensible]] applied to the proxy object&apos;s target object is false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.5.5">
	<buginformation>
		<summary>[[GetOwnProperty]] ( P )</summary>
		<description>When the [[GetOwnProperty]] internal method of a Proxy exotic object O is called with property key P, the following steps are taken: Assert: IsPropertyKey(P) is true.Let handler be O.[[ProxyHandler]].If handler is null, throw a TypeError exception.Assert: Type(handler) is Object.Let target be O.[[ProxyTarget]].Let trap be ? GetMethod(handler, &amp;quot;getOwnPropertyDescriptor&amp;quot;).If trap is undefined, thenReturn ? target.[[GetOwnProperty]](P).Let trapResultObj be ? Call(trap, handler, « target, P »).If Type(trapResultObj) is neither Object nor Undefined, throw a TypeError exception.Let targetDesc be ? target.[[GetOwnProperty]](P).If trapResultObj is undefined, thenIf targetDesc is undefined, return undefined.If targetDesc.[[Configurable]] is false, throw a TypeError exception.Let extensibleTarget be ? IsExtensible(target).Assert: Type(extensibleTarget) is Boolean.If extensibleTarget is false, throw a TypeError exception.Return undefined.Let extensibleTarget be ? IsExtensible(target).Let resultDesc be ? ToPropertyDescriptor(trapResultObj).Call CompletePropertyDescriptor(resultDesc).Let valid be IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc, targetDesc).If valid is false, throw a TypeError exception.If resultDesc.[[Configurable]] is false, thenIf targetDesc is undefined or targetDesc.[[Configurable]] is true, thenThrow a TypeError exception.Return resultDesc.        Note [[GetOwnProperty]] for proxy objects enforces the following invariants:               The result of [[GetOwnProperty]] must be either an Object or undefined.                                    A property cannot be reported as non-existent, if it exists as a non-configurable own property of the target object.                                    A property cannot be reported as non-existent, if it exists  as an own property of the target object and the target object is not  extensible.                                    A property cannot be reported as existent, if it does not  exist as an own property of the target object and the target object is  not extensible.                                    A property cannot be reported as non-configurable, if it  does not exist as an own property of the target object or if it exists  as a configurable own property of the target object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.5.6">
	<buginformation>
		<summary>[[DefineOwnProperty]] ( P, Desc )</summary>
		<description>When the [[DefineOwnProperty]] internal method of a Proxy exotic object O is called with property key P and Property Descriptor Desc, the following steps are taken: Assert: IsPropertyKey(P) is true.Let handler be O.[[ProxyHandler]].If handler is null, throw a TypeError exception.Assert: Type(handler) is Object.Let target be O.[[ProxyTarget]].Let trap be ? GetMethod(handler, &amp;quot;defineProperty&amp;quot;).If trap is undefined, thenReturn ? target.[[DefineOwnProperty]](P, Desc).Let descObj be FromPropertyDescriptor(Desc).Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P, descObj »)).If booleanTrapResult is false, return false.Let targetDesc be ? target.[[GetOwnProperty]](P).Let extensibleTarget be ? IsExtensible(target).If Desc has a [[Configurable]] field and if Desc.[[Configurable]] is false, thenLet settingConfigFalse be true.Else, let settingConfigFalse be false.If targetDesc is undefined, thenIf extensibleTarget is false, throw a TypeError exception.If settingConfigFalse is true, throw a TypeError exception.Else targetDesc is not undefined,If IsCompatiblePropertyDescriptor(extensibleTarget, Desc, targetDesc) is false, throw a TypeError exception.If settingConfigFalse is true and targetDesc.[[Configurable]] is true, throw a TypeError exception.Return true.        Note [[DefineOwnProperty]] for proxy objects enforces the following invariants:               The result of [[DefineOwnProperty]] is a Boolean value.                                    A property cannot be added, if the target object is not extensible.                                    A property cannot be non-configurable, unless there exists a  corresponding non-configurable own property of the target object.                                    If a property has a corresponding target object property then applying the Property Descriptor of the property to the target object using [[DefineOwnProperty]] will not throw an exception.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.5.7">
	<buginformation>
		<summary>[[HasProperty]] ( P )</summary>
		<description>When the [[HasProperty]] internal method of a Proxy exotic object O is called with property key P, the following steps are taken: Assert: IsPropertyKey(P) is true.Let handler be O.[[ProxyHandler]].If handler is null, throw a TypeError exception.Assert: Type(handler) is Object.Let target be O.[[ProxyTarget]].Let trap be ? GetMethod(handler, &amp;quot;has&amp;quot;).If trap is undefined, thenReturn ? target.[[HasProperty]](P).Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P »)).If booleanTrapResult is false, thenLet targetDesc be ? target.[[GetOwnProperty]](P).If targetDesc is not undefined, thenIf targetDesc.[[Configurable]] is false, throw a TypeError exception.Let extensibleTarget be ? IsExtensible(target).If extensibleTarget is false, throw a TypeError exception.Return booleanTrapResult.        Note [[HasProperty]] for proxy objects enforces the following invariants:               The result of [[HasProperty]] is a Boolean value.                                    A property cannot be reported as non-existent, if it exists as a non-configurable own property of the target object.                                    A property cannot be reported as non-existent, if it exists  as an own property of the target object and the target object is not  extensible.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.5.8">
	<buginformation>
		<summary>[[Get]] ( P, Receiver )</summary>
		<description>When the [[Get]] internal method of a Proxy exotic object O is called with property key P and ECMAScript language value Receiver, the following steps are taken: Assert: IsPropertyKey(P) is true.Let handler be O.[[ProxyHandler]].If handler is null, throw a TypeError exception.Assert: Type(handler) is Object.Let target be O.[[ProxyTarget]].Let trap be ? GetMethod(handler, &amp;quot;get&amp;quot;).If trap is undefined, thenReturn ? target.[[Get]](P, Receiver).Let trapResult be ? Call(trap, handler, « target, P, Receiver »).Let targetDesc be ? target.[[GetOwnProperty]](P).If targetDesc is not undefined, thenIf IsDataDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Writable]] is false, thenIf SameValue(trapResult, targetDesc.[[Value]]) is false, throw a TypeError exception.If IsAccessorDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Get]] is undefined, thenIf trapResult is not undefined, throw a TypeError exception.Return trapResult.        Note [[Get]] for proxy objects enforces the following invariants:               The value reported for a property must be the same as the  value of the corresponding target object property if the target object  property is a non-writable, non-configurable own data property.                                    The value reported for a property must be undefined if the corresponding target object property is a non-configurable own accessor property that has undefined as its [[Get]] attribute.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.5.9">
	<buginformation>
		<summary>[[Set]] ( P, V, Receiver )</summary>
		<description>When the [[Set]] internal method of a Proxy exotic object O is called with property key P, value V, and ECMAScript language value Receiver, the following steps are taken: Assert: IsPropertyKey(P) is true.Let handler be O.[[ProxyHandler]].If handler is null, throw a TypeError exception.Assert: Type(handler) is Object.Let target be O.[[ProxyTarget]].Let trap be ? GetMethod(handler, &amp;quot;set&amp;quot;).If trap is undefined, thenReturn ? target.[[Set]](P, V, Receiver).Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P, V, Receiver »)).If booleanTrapResult is false, return false.Let targetDesc be ? target.[[GetOwnProperty]](P).If targetDesc is not undefined, thenIf IsDataDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Writable]] is false, thenIf SameValue(V, targetDesc.[[Value]]) is false, throw a TypeError exception.If IsAccessorDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false, thenIf targetDesc.[[Set]] is undefined, throw a TypeError exception.Return true.        Note [[Set]] for proxy objects enforces the following invariants:               The result of [[Set]] is a Boolean value.                                    Cannot change the value of a property to be different from  the value of the corresponding target object property if the  corresponding target object property is a non-writable, non-configurable  own data property.                                    Cannot set the value of a property if the corresponding  target object property is a non-configurable own accessor property that  has undefined as its [[Set]] attribute.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.5.10">
	<buginformation>
		<summary>[[Delete]] ( P )</summary>
		<description>When the [[Delete]] internal method of a Proxy exotic object O is called with property key P, the following steps are taken: Assert: IsPropertyKey(P) is true.Let handler be O.[[ProxyHandler]].If handler is null, throw a TypeError exception.Assert: Type(handler) is Object.Let target be O.[[ProxyTarget]].Let trap be ? GetMethod(handler, &amp;quot;deleteProperty&amp;quot;).If trap is undefined, thenReturn ? target.[[Delete]](P).Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P »)).If booleanTrapResult is false, return false.Let targetDesc be ? target.[[GetOwnProperty]](P).If targetDesc is undefined, return true.If targetDesc.[[Configurable]] is false, throw a TypeError exception.Return true.        Note [[Delete]] for proxy objects enforces the following invariants:               The result of [[Delete]] is a Boolean value.                                    A property cannot be reported as deleted, if it exists as a non-configurable own property of the target object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.5.11">
	<buginformation>
		<summary>[[OwnPropertyKeys]] ( )</summary>
		<description>When the [[OwnPropertyKeys]] internal method of a Proxy exotic object O is called, the following steps are taken: Let handler be O.[[ProxyHandler]].If handler is null, throw a TypeError exception.Assert: Type(handler) is Object.Let target be O.[[ProxyTarget]].Let trap be ? GetMethod(handler, &amp;quot;ownKeys&amp;quot;).If trap is undefined, thenReturn ? target.[[OwnPropertyKeys]]().Let trapResultArray be ? Call(trap, handler, « target »).Let trapResult be ? CreateListFromArrayLike(trapResultArray, « String, Symbol »).Let extensibleTarget be ? IsExtensible(target).Let targetKeys be ? target.[[OwnPropertyKeys]]().Assert: targetKeys is a List containing only String and Symbol values.Let targetConfigurableKeys be a new empty List.Let targetNonconfigurableKeys be a new empty List.For each element key of targetKeys, doLet desc be ? target.[[GetOwnProperty]](key).If desc is not undefined and desc.[[Configurable]] is false, thenAppend key as an element of targetNonconfigurableKeys.Else,Append key as an element of targetConfigurableKeys.If extensibleTarget is true and targetNonconfigurableKeys is empty, thenReturn trapResult.Let uncheckedResultKeys be a new List which is a copy of trapResult.For each key that is an element of targetNonconfigurableKeys, doIf key is not an element of uncheckedResultKeys, throw a TypeError exception.Remove all occurrences of key from uncheckedResultKeys.If extensibleTarget is true, return trapResult.For each key that is an element of targetConfigurableKeys, doIf key is not an element of uncheckedResultKeys, throw a TypeError exception.Remove all occurrences of key from uncheckedResultKeys.If uncheckedResultKeys is not empty, throw a TypeError exception.Return trapResult.        Note [[OwnPropertyKeys]] for proxy objects enforces the following invariants:               The result of [[OwnPropertyKeys]] is a List.                                    The Type of each result List element is either String or Symbol.                                    The result List must contain the keys of all non-configurable own properties of the target object.                                    If the target object is not extensible, then the result List must contain all the keys of the own properties of the target object and no other values.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.5.12">
	<buginformation>
		<summary>[[Call]] ( thisArgument, argumentsList )</summary>
		<description>The [[Call]] internal method of a Proxy exotic object O is called with parameters thisArgument and argumentsList, a List of ECMAScript language values. The following steps are taken: Let handler be O.[[ProxyHandler]].If handler is null, throw a TypeError exception.Assert: Type(handler) is Object.Let target be O.[[ProxyTarget]].Let trap be ? GetMethod(handler, &amp;quot;apply&amp;quot;).If trap is undefined, thenReturn ? Call(target, thisArgument, argumentsList).Let argArray be CreateArrayFromList(argumentsList).Return ? Call(trap, handler, « target, thisArgument, argArray »).        Note A Proxy exotic object only has a [[Call]] internal method if  the initial value of its [[ProxyTarget]] internal slot is an object that  has a [[Call]] internal method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.5.13">
	<buginformation>
		<summary>[[Construct]] ( argumentsList, newTarget )</summary>
		<description>The [[Construct]] internal method of a Proxy exotic object O is called with parameters argumentsList which is a possibly empty List of ECMAScript language values and newTarget. The following steps are taken: Let handler be O.[[ProxyHandler]].If handler is null, throw a TypeError exception.Assert: Type(handler) is Object.Let target be O.[[ProxyTarget]].Let trap be ? GetMethod(handler, &amp;quot;construct&amp;quot;).If trap is undefined, thenAssert: target has a [[Construct]] internal method.Return ? Construct(target, argumentsList, newTarget).Let argArray be CreateArrayFromList(argumentsList).Let newObj be ? Call(trap, handler, « target, argArray, newTarget »).If Type(newObj) is not Object, throw a TypeError exception.Return newObj.        Note 1 A Proxy exotic object only has a [[Construct]] internal  method if the initial value of its [[ProxyTarget]] internal slot is an  object that has a [[Construct]] internal method.  Note 2 [[Construct]] for proxy objects enforces the following invariants:               The result of [[Construct]] must be an Object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="9.5.14">
	<buginformation>
		<summary>ProxyCreate ( target, handler )</summary>
		<description>The abstract operation ProxyCreate with arguments target and handler is used to specify the creation of new Proxy exotic objects. It performs the following steps: If Type(target) is not Object, throw a TypeError exception.If target is a Proxy exotic object and target.[[ProxyHandler]] is null, throw a TypeError exception.If Type(handler) is not Object, throw a TypeError exception.If handler is a Proxy exotic object and handler.[[ProxyHandler]] is null, throw a TypeError exception.Let P be a newly created object.Set P&apos;s essential internal methods (except for [[Call]] and [[Construct]]) to the definitions specified in 9.5.If IsCallable(target) is true, thenSet P.[[Call]] as specified in 9.5.12.If target has a [[Construct]] internal method, thenSet P.[[Construct]] as specified in 9.5.13.Set P.[[ProxyTarget]] to target.Set P.[[ProxyHandler]] to handler.Return P.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="10.1.1">
	<buginformation>
		<summary>Static Semantics: UTF16Encoding ( cp )</summary>
		<description>The UTF16Encoding of a numeric code point value, cp, is determined as follows: Assert: 0 ≤ cp ≤ 0x10FFFF.If cp ≤ 0xFFFF, return cp.Let cu1 be floor((cp - 0x10000) / 0x400) + 0xD800.Let cu2 be ((cp - 0x10000) modulo 0x400) + 0xDC00.Return the code unit sequence consisting of cu1 followed by cu2.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="10.1.2">
	<buginformation>
		<summary>Static Semantics: UTF16Decode( lead, trail )</summary>
		<description>Two code units, lead and trail, that form a UTF-16 surrogate pair are converted to a code point by performing the following steps: Assert: 0xD800 ≤ lead ≤ 0xDBFF and 0xDC00 ≤ trail ≤ 0xDFFF.Let cp be (lead - 0xD800) × 0x400 + (trail - 0xDC00) + 0x10000.Return the code point cp.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="10.2.1">
	<buginformation>
		<summary>Strict Mode Code</summary>
		<description>An ECMAScript Script syntactic unit may be processed using either unrestricted or strict mode syntax and semantics. Code is interpreted as  strict mode code in the following situations:             Global code is strict mode code if it begins with a Directive Prologue that contains a Use Strict Directive.                              Module code is always strict mode code.                              All parts of a ClassDeclaration or a ClassExpression are strict mode code.                              Eval code is strict mode code if it begins with a Directive Prologue that contains a Use Strict Directive or if the call to eval is a direct eval that is contained in strict mode code.                              Function code is strict mode code if the associated FunctionDeclaration, FunctionExpression, GeneratorDeclaration, GeneratorExpression, AsyncFunctionDeclaration, AsyncFunctionExpression, MethodDefinition, ArrowFunction, or AsyncArrowFunction  is contained in strict mode code or if the code that produces the value  of the function&apos;s [[ECMAScriptCode]] internal slot begins with a Directive Prologue that contains a Use Strict Directive.                              Function code that is supplied as the arguments to the built-in Function, Generator, and AsyncFunction constructors is strict mode code if the last argument is a String that when processed is a FunctionBody that begins with a Directive Prologue that contains a Use Strict Directive.                    ECMAScript code that is not strict mode code is called  non-strict code.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="10.2.2">
	<buginformation>
		<summary>Non-ECMAScript Functions</summary>
		<description>An ECMAScript implementation may support the evaluation of  function exotic objects whose evaluative behaviour is expressed in some  implementation-defined form of executable code other than via ECMAScript  code. Whether a function object is an ECMAScript code function or a  non-ECMAScript function is not semantically observable from the  perspective of an ECMAScript code function that calls or is called by  such a non-ECMAScript function.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.1">
	<buginformation>
		<summary>Unicode Format-Control Characters</summary>
		<description>The Unicode format-control characters (i.e., the characters in  category “Cf” in the Unicode Character Database such as LEFT-TO-RIGHT  MARK or RIGHT-TO-LEFT MARK) are control codes used to control the  formatting of a range of text in the absence of higher-level protocols  for this (such as mark-up languages). It is useful to allow format-control characters in source text to  facilitate editing and display. All format control characters may be  used within comments, and within string literals, template literals, and  regular expression literals. U+200C (ZERO WIDTH NON-JOINER) and U+200D (ZERO WIDTH JOINER) are  format-control characters that are used to make necessary distinctions  when forming words or phrases in certain languages. In ECMAScript source  text these code points may also be used in an IdentifierName after the first character. U+FEFF (ZERO WIDTH NO-BREAK SPACE) is a format-control character  used primarily at the start of a text to mark it as Unicode and to allow  detection of the text&apos;s encoding and byte order. &lt;ZWNBSP&gt;  characters intended for this purpose can sometimes also appear after the  start of a text, for example as a result of concatenating files. In  ECMAScript source text &lt;ZWNBSP&gt; code points are treated as white  space characters (see  11.2). The special treatment of certain format-control characters  outside of comments, string literals, and regular expression literals is  summarized in  Table 31. Table 31: Format-Control Code Point Usage                 Code Point                                    Name                                    Abbreviation                                    Usage                          U+200C               ZERO WIDTH NON-JOINER                                    &lt;ZWNJ&gt;                        IdentifierPart     U+200D               ZERO WIDTH JOINER                                    &lt;ZWJ&gt;                        IdentifierPart     U+FEFF               ZERO WIDTH NO-BREAK SPACE                                    &lt;ZWNBSP&gt;                        WhiteSpace</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.2">
	<buginformation>
		<summary>White Space</summary>
		<description>White space code points are used to improve source text  readability and to separate tokens (indivisible lexical units) from each  other, but are otherwise insignificant. White space code points may  occur between any two tokens and at the start or end of input. White  space code points may occur within a StringLiteral, a RegularExpressionLiteral, a Template, or a TemplateSubstitutionTail where they are considered significant code points forming part of a literal value. They may also occur within a Comment, but cannot appear within any other kind of token. The ECMAScript white space code points are listed in  Table 32. Table 32: White Space Code Points                 Code Point                                    Name                                    Abbreviation                          U+0009               CHARACTER TABULATION                                    &lt;TAB&gt;                          U+000B               LINE TABULATION                                    &lt;VT&gt;                          U+000C               FORM FEED (FF)                                    &lt;FF&gt;                          U+0020               SPACE                                    &lt;SP&gt;                          U+00A0               NO-BREAK SPACE                                    &lt;NBSP&gt;                          U+FEFF               ZERO WIDTH NO-BREAK SPACE                                    &lt;ZWNBSP&gt;                                      Other category “Zs”                                    Any other Unicode “Space_Separator” code point                                    &lt;USP&gt;                           ECMAScript implementations must recognize as WhiteSpace code points listed in the “Space_Separator” (“Zs”) category. Note Other than for the code points listed in  Table 32, ECMAScript WhiteSpace  intentionally excludes all code points that have the Unicode  “White_Space” property but which are not classified in category  “Space_Separator” (“Zs”).  Syntax  WhiteSpace::&lt;TAB&gt; &lt;VT&gt; &lt;FF&gt; &lt;SP&gt; &lt;NBSP&gt; &lt;ZWNBSP&gt; &lt;USP&gt;</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.3">
	<buginformation>
		<summary>Line Terminators</summary>
		<description>Like white space code points, line terminator code points are  used to improve source text readability and to separate tokens  (indivisible lexical units) from each other. However, unlike white space  code points, line terminators have some influence over the behaviour of  the syntactic grammar. In general, line terminators may occur between  any two tokens, but there are a few places where they are forbidden by  the syntactic grammar. Line terminators also affect the process of  automatic semicolon insertion (11.9). A line terminator cannot occur within any token except a StringLiteral, Template, or TemplateSubstitutionTail. Line terminators may only occur within a StringLiteral token as part of a LineContinuation. A line terminator can occur within a MultiLineComment but cannot occur within a SingleLineComment. Line terminators are included in the set of white space code points that are matched by the \s class in regular expressions. The ECMAScript line terminator code points are listed in  Table 33. Table 33: Line Terminator Code Points                 Code Point                                    Unicode Name                                    Abbreviation                          U+000A               LINE FEED (LF)                                    &lt;LF&gt;                          U+000D               CARRIAGE RETURN (CR)                                    &lt;CR&gt;                          U+2028               LINE SEPARATOR                                    &lt;LS&gt;                          U+2029               PARAGRAPH SEPARATOR                                    &lt;PS&gt;                           Only the Unicode code points in  Table 33  are treated as line terminators. Other new line or line breaking  Unicode code points are not treated as line terminators but are treated  as white space if they meet the requirements listed in  Table 32. The sequence &lt;CR&gt;&lt;LF&gt; is commonly used as a line terminator. It should be considered a single SourceCharacter for the purpose of reporting line numbers. Syntax  LineTerminator::&lt;LF&gt; &lt;CR&gt; &lt;LS&gt; &lt;PS&gt;   LineTerminatorSequence::&lt;LF&gt; &lt;CR&gt;[lookahead ≠ &lt;LF&gt;] &lt;LS&gt; &lt;PS&gt; &lt;CR&gt;&lt;LF&gt;</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.4">
	<buginformation>
		<summary>Comments</summary>
		<description>Comments can be either single or multi-line. Multi-line comments cannot nest. Because a single-line comment can contain any Unicode code point except a LineTerminator  code point, and because of the general rule that a token is always as  long as possible, a single-line comment always consists of all code  points from the // marker to the end of the line. However, the LineTerminator  at the end of the line is not considered to be part of the single-line  comment; it is recognized separately by the lexical grammar and becomes  part of the stream of input elements for the syntactic grammar. This  point is very important, because it implies that the presence or absence  of single-line comments does not affect the process of automatic  semicolon insertion (see  11.9). Comments behave like white space and are discarded except that, if a MultiLineComment contains a line terminator code point, then the entire comment is considered to be a LineTerminator for purposes of parsing by the syntactic grammar. Syntax  Comment::MultiLineComment SingleLineComment   MultiLineComment::/*MultiLineCommentCharsopt*/   MultiLineCommentChars::MultiLineNotAsteriskCharMultiLineCommentCharsopt *PostAsteriskCommentCharsopt   PostAsteriskCommentChars::MultiLineNotForwardSlashOrAsteriskCharMultiLineCommentCharsopt *PostAsteriskCommentCharsopt   MultiLineNotAsteriskChar::SourceCharacterbut not *   MultiLineNotForwardSlashOrAsteriskChar::SourceCharacterbut not one of / or *   SingleLineComment:://SingleLineCommentCharsopt   SingleLineCommentChars::SingleLineCommentCharSingleLineCommentCharsopt   SingleLineCommentChar::SourceCharacterbut not LineTerminator</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.5">
	<buginformation>
		<summary>Tokens</summary>
		<description>Syntax  CommonToken::IdentifierName Punctuator NumericLiteral StringLiteral Template  Note The DivPunctuator, RegularExpressionLiteral, RightBracePunctuator, and TemplateSubstitutionTail productions derive additional tokens that are not included in the CommonToken production.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.6.1.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>IdentifierStart::\UnicodeEscapeSequence                It is a Syntax Error if SV(UnicodeEscapeSequence) is none of &amp;quot;$&amp;quot;, or &amp;quot;_&amp;quot;, or the UTF16Encoding of a code point matched by the UnicodeIDStart lexical grammar production.                         IdentifierPart::\UnicodeEscapeSequence                It is a Syntax Error if SV(UnicodeEscapeSequence) is none of &amp;quot;$&amp;quot;, or &amp;quot;_&amp;quot;, or the UTF16Encoding of either &lt;ZWNJ&gt; or &lt;ZWJ&gt;, or the UTF16Encoding of a Unicode code point that would be matched by the UnicodeIDContinue lexical grammar production.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.6.1.2">
	<buginformation>
		<summary>Static Semantics: StringValue</summary>
		<description>IdentifierName::IdentifierStart IdentifierNameIdentifierPart  Return the String value consisting of the sequence of code units corresponding to IdentifierName. In determining the sequence any occurrences of \ UnicodeEscapeSequence are first replaced with the code point represented by the UnicodeEscapeSequence and then the code points of the entire IdentifierName are converted to code units by UTF16Encoding each code point.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.6.2.1">
	<buginformation>
		<summary>Keywords</summary>
		<description>The following tokens are ECMAScript keywords and may not be used as Identifiers in ECMAScript programs. Syntax  Keyword::await break casecatchclassconstcontinue debuggerdefaultdeletedo elseexportextends finallyforfunction ifimportininstanceof new return superswitch thisthrowtrytypeof varvoid whilewith yield  Note In some contexts yield and await are given the semantics of an Identifier. See  12.1.1. In strict mode code, let and static are treated as reserved words through static semantic restrictions (see  12.1.1,  13.3.1.1,  13.7.5.1, and  14.5.1) rather than the lexical grammar.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.6.2.2">
	<buginformation>
		<summary>Future Reserved Words</summary>
		<description>The following tokens are reserved for use as keywords in future language extensions. Syntax  FutureReservedWord::enum  Note Use of the following tokens within strict mode code is also reserved. That usage is restricted using static semantic restrictions (see  12.1.1) rather than the lexical grammar:      implements   package   protected       interface   private   public</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.7">
	<buginformation>
		<summary>Punctuators</summary>
		<description>Syntax  Punctuator::{()[] ....;, &lt;&gt;&lt;</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.8.1">
	<buginformation>
		<summary>Null Literals</summary>
		<description>Syntax  NullLiteral::null</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.8.2">
	<buginformation>
		<summary>Boolean Literals</summary>
		<description>Syntax  BooleanLiteral::true false</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.8.3.1">
	<buginformation>
		<summary>Static Semantics: MV</summary>
		<description>A numeric literal stands for a value of the Number type. This  value is determined in two steps: first, a mathematical value (MV) is  derived from the literal; second, this mathematical value is rounded as  described below.               The MV of   NumericLiteral::DecimalLiteral  is the MV of DecimalLiteral.                                    The MV of   NumericLiteral::BinaryIntegerLiteral  is the MV of BinaryIntegerLiteral.                                    The MV of   NumericLiteral::OctalIntegerLiteral  is the MV of OctalIntegerLiteral.                                    The MV of   NumericLiteral::HexIntegerLiteral  is the MV of HexIntegerLiteral.                                    The MV of   DecimalLiteral::DecimalIntegerLiteral.  is the MV of DecimalIntegerLiteral.                                    The MV of   DecimalLiteral::DecimalIntegerLiteral.DecimalDigits  is the MV of DecimalIntegerLiteral plus (the MV of DecimalDigits × 10-n), where n is the number of code points in DecimalDigits.                                    The MV of   DecimalLiteral::DecimalIntegerLiteral.ExponentPart  is the MV of DecimalIntegerLiteral × 10e, where e is the MV of ExponentPart.                                    The MV of   DecimalLiteral::DecimalIntegerLiteral.DecimalDigitsExponentPart  is (the MV of DecimalIntegerLiteral plus (the MV of DecimalDigits × 10-n)) × 10e, where n is the number of code points in DecimalDigits and e is the MV of ExponentPart.                                    The MV of   DecimalLiteral::.DecimalDigits  is the MV of DecimalDigits × 10-n, where n is the number of code points in DecimalDigits.                                    The MV of   DecimalLiteral::.DecimalDigitsExponentPart  is the MV of DecimalDigits × 10e-n, where n is the number of code points in DecimalDigits and e is the MV of ExponentPart.                                    The MV of   DecimalLiteral::DecimalIntegerLiteral  is the MV of DecimalIntegerLiteral.                                    The MV of   DecimalLiteral::DecimalIntegerLiteralExponentPart  is the MV of DecimalIntegerLiteral × 10e, where e is the MV of ExponentPart.                                    The MV of   DecimalIntegerLiteral::0  is 0.                                    The MV of   DecimalIntegerLiteral::NonZeroDigit  is the MV of NonZeroDigit.                                    The MV of   DecimalIntegerLiteral::NonZeroDigitDecimalDigits  is (the MV of NonZeroDigit × 10n) plus the MV of DecimalDigits, where n is the number of code points in DecimalDigits.                                    The MV of   DecimalDigits::DecimalDigit  is the MV of DecimalDigit.                                    The MV of   DecimalDigits::DecimalDigitsDecimalDigit  is (the MV of DecimalDigits × 10) plus the MV of DecimalDigit.                                    The MV of   ExponentPart::ExponentIndicatorSignedInteger  is the MV of SignedInteger.                                    The MV of   SignedInteger::DecimalDigits  is the MV of DecimalDigits.                                    The MV of   SignedInteger::+DecimalDigits  is the MV of DecimalDigits.                                    The MV of   SignedInteger::-DecimalDigits  is the negative of the MV of DecimalDigits.                                    The MV of   DecimalDigit::0  or of   HexDigit::0  or of   OctalDigit::0  or of   BinaryDigit::0  is 0.                                    The MV of   DecimalDigit::1  or of   NonZeroDigit::1  or of   HexDigit::1  or of   OctalDigit::1  or of   BinaryDigit::1  is 1.                                    The MV of   DecimalDigit::2  or of   NonZeroDigit::2  or of   HexDigit::2  or of   OctalDigit::2  is 2.                                    The MV of   DecimalDigit::3  or of   NonZeroDigit::3  or of   HexDigit::3  or of   OctalDigit::3  is 3.                                    The MV of   DecimalDigit::4  or of   NonZeroDigit::4  or of   HexDigit::4  or of   OctalDigit::4  is 4.                                    The MV of   DecimalDigit::5  or of   NonZeroDigit::5  or of   HexDigit::5  or of   OctalDigit::5  is 5.                                    The MV of   DecimalDigit::6  or of   NonZeroDigit::6  or of   HexDigit::6  or of   OctalDigit::6  is 6.                                    The MV of   DecimalDigit::7  or of   NonZeroDigit::7  or of   HexDigit::7  or of   OctalDigit::7  is 7.                                    The MV of   DecimalDigit::8  or of   NonZeroDigit::8  or of   HexDigit::8  is 8.                                    The MV of   DecimalDigit::9  or of   NonZeroDigit::9  or of   HexDigit::9  is 9.                                    The MV of   HexDigit::a  or of   HexDigit::A  is 10.                                    The MV of   HexDigit::b  or of   HexDigit::B  is 11.                                    The MV of   HexDigit::c  or of   HexDigit::C  is 12.                                    The MV of   HexDigit::d  or of   HexDigit::D  is 13.                                    The MV of   HexDigit::e  or of   HexDigit::E  is 14.                                    The MV of   HexDigit::f  or of   HexDigit::F  is 15.                                    The MV of   BinaryIntegerLiteral::0bBinaryDigits  is the MV of BinaryDigits.                                    The MV of   BinaryIntegerLiteral::0BBinaryDigits  is the MV of BinaryDigits.                                    The MV of   BinaryDigits::BinaryDigit  is the MV of BinaryDigit.                                    The MV of   BinaryDigits::BinaryDigitsBinaryDigit  is (the MV of BinaryDigits × 2) plus the MV of BinaryDigit.                                    The MV of   OctalIntegerLiteral::0oOctalDigits  is the MV of OctalDigits.                                    The MV of   OctalIntegerLiteral::0OOctalDigits  is the MV of OctalDigits.                                    The MV of   OctalDigits::OctalDigit  is the MV of OctalDigit.                                    The MV of   OctalDigits::OctalDigitsOctalDigit  is (the MV of OctalDigits × 8) plus the MV of OctalDigit.                                    The MV of   HexIntegerLiteral::0xHexDigits  is the MV of HexDigits.                                    The MV of   HexIntegerLiteral::0XHexDigits  is the MV of HexDigits.                                    The MV of   HexDigits::HexDigit  is the MV of HexDigit.                                    The MV of   HexDigits::HexDigitsHexDigit  is (the MV of HexDigits × 16) plus the MV of HexDigit.                        Once the exact MV for a numeric literal has been determined,  it is then rounded to a value of the Number type. If the MV is 0, then  the rounded value is +0; otherwise, the rounded value must be the Number value for the MV (as specified in  6.1.6), unless the literal is a DecimalLiteral  and the literal has more than 20 significant digits, in which case the  Number value may be either the Number value for the MV of a literal  produced by replacing each significant digit after the 20th with a 0 digit or the Number value for the MV of a literal produced by replacing each significant digit after the 20th with a 0 digit and then incrementing the literal at the 20th significant digit position. A digit is  significant if it is not part of an ExponentPart and               it is not 0; or                                    there is a nonzero digit to its left and there is a nonzero digit, not in the ExponentPart, to its right.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.8.4.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>UnicodeEscapeSequence::u{HexDigits}                It is a Syntax Error if the MV of HexDigits &gt; 0x10FFFF.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.8.4.2">
	<buginformation>
		<summary>Static Semantics: StringValue</summary>
		<description>StringLiteral::&amp;quot;DoubleStringCharactersopt&amp;quot; &apos;SingleStringCharactersopt&apos;  Return the String value whose elements are the SV of this StringLiteral.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.8.4.3">
	<buginformation>
		<summary>Static Semantics: SV</summary>
		<description>A string literal stands for a value of the String type. The  String value (SV) of the literal is described in terms of code unit  values contributed by the various parts of the string literal. As part  of this process, some Unicode code points within the string literal are  interpreted as having a mathematical value (MV), as described below or  in  11.8.3.               The SV of   StringLiteral::&amp;quot;&amp;quot;  is the empty code unit sequence.                                    The SV of   StringLiteral::&apos;&apos;  is the empty code unit sequence.                                    The SV of   StringLiteral::&amp;quot;DoubleStringCharacters&amp;quot;  is the SV of DoubleStringCharacters.                                    The SV of   StringLiteral::&apos;SingleStringCharacters&apos;  is the SV of SingleStringCharacters.                                    The SV of   DoubleStringCharacters::DoubleStringCharacter  is a sequence of one or two code units that is the SV of DoubleStringCharacter.                                    The SV of   DoubleStringCharacters::DoubleStringCharacterDoubleStringCharacters  is a sequence of one or two code units that is the SV of DoubleStringCharacter followed by all the code units in the SV of DoubleStringCharacters in order.                                    The SV of   SingleStringCharacters::SingleStringCharacter  is a sequence of one or two code units that is the SV of SingleStringCharacter.                                    The SV of   SingleStringCharacters::SingleStringCharacterSingleStringCharacters  is a sequence of one or two code units that is the SV of SingleStringCharacter followed by all the code units in the SV of SingleStringCharacters in order.                                    The SV of   DoubleStringCharacter::SourceCharacterbut not one of &amp;quot; or \ or LineTerminator  is the UTF16Encoding of the code point value of SourceCharacter.                                    The SV of   DoubleStringCharacter::\EscapeSequence  is the SV of the EscapeSequence.                                    The SV of   DoubleStringCharacter::LineContinuation  is the empty code unit sequence.                                    The SV of   SingleStringCharacter::SourceCharacterbut not one of &apos; or \ or LineTerminator  is the UTF16Encoding of the code point value of SourceCharacter.                                    The SV of   SingleStringCharacter::\EscapeSequence  is the SV of the EscapeSequence.                                    The SV of   SingleStringCharacter::LineContinuation  is the empty code unit sequence.                                    The SV of   EscapeSequence::CharacterEscapeSequence  is the SV of the CharacterEscapeSequence.                                    The SV of   EscapeSequence::0  is the code unit value 0.                                    The SV of   EscapeSequence::HexEscapeSequence  is the SV of the HexEscapeSequence.                                    The SV of   EscapeSequence::UnicodeEscapeSequence  is the SV of the UnicodeEscapeSequence.                                    The SV of   CharacterEscapeSequence::SingleEscapeCharacter  is the code unit whose value is determined by the SingleEscapeCharacter according to  Table 34.                        Table 34: String Single Character Escape Sequences                     Escape Sequence                                                Code Unit Value                                                Unicode Character Name                                                Symbol                                  \b   0x0008                   BACKSPACE                                                &lt;BS&gt;                                  \t   0x0009                   CHARACTER TABULATION                                                &lt;HT&gt;                                  \n   0x000A                   LINE FEED (LF)                                                &lt;LF&gt;                                  \v   0x000B                   LINE TABULATION                                                &lt;VT&gt;                                  \f   0x000C                   FORM FEED (FF)                                                &lt;FF&gt;                                  \r   0x000D                   CARRIAGE RETURN (CR)                                                &lt;CR&gt;                                  \&amp;quot;   0x0022                   QUOTATION MARK                                &amp;quot;     \&apos;   0x0027                   APOSTROPHE                                &apos;     \\   0x005C                   REVERSE SOLIDUS                                \                    The SV of   CharacterEscapeSequence::NonEscapeCharacter  is the SV of the NonEscapeCharacter.                                    The SV of   NonEscapeCharacter::SourceCharacterbut not one of EscapeCharacter or LineTerminator  is the UTF16Encoding of the code point value of SourceCharacter.                                    The SV of   HexEscapeSequence::xHexDigitHexDigit  is the code unit value that is (16 times the MV of the first HexDigit) plus the MV of the second HexDigit.                                    The SV of   UnicodeEscapeSequence::uHex4Digits  is the SV of Hex4Digits.                                    The SV of   Hex4Digits::HexDigitHexDigitHexDigitHexDigit  is the code unit value that is (0x1000 times the MV of the first HexDigit) plus (0x100 times the MV of the second HexDigit) plus (0x10 times the MV of the third HexDigit) plus the MV of the fourth HexDigit.                                    The SV of   UnicodeEscapeSequence::u{HexDigits}  is the UTF16Encoding of the MV of HexDigits.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.8.5.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>RegularExpressionFlags::RegularExpressionFlagsIdentifierPart                It is a Syntax Error if IdentifierPart contains a Unicode escape sequence.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.8.5.2">
	<buginformation>
		<summary>Static Semantics: BodyText</summary>
		<description>RegularExpressionLiteral::/RegularExpressionBody/RegularExpressionFlags  Return the source text that was recognized as RegularExpressionBody.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.8.5.3">
	<buginformation>
		<summary>Static Semantics: FlagText</summary>
		<description>RegularExpressionLiteral::/RegularExpressionBody/RegularExpressionFlags  Return the source text that was recognized as RegularExpressionFlags.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.8.6.1">
	<buginformation>
		<summary>Static Semantics: TV and TRV</summary>
		<description>A template literal component is interpreted as a sequence of  Unicode code points. The Template Value (TV) of a literal component is  described in terms of code unit values (SV,  11.8.4)  contributed by the various parts of the template literal component. As  part of this process, some Unicode code points within the template  component are interpreted as having a mathematical value (MV,  11.8.3).  In determining a TV, escape sequences are replaced by the UTF-16 code  unit(s) of the Unicode code point represented by the escape sequence.  The Template Raw Value (TRV) is similar to a Template Value with the  difference that in TRVs escape sequences are interpreted literally.               The TV and TRV of   NoSubstitutionTemplate::``  is the empty code unit sequence.                                    The TV and TRV of   TemplateHead::`${  is the empty code unit sequence.                                    The TV and TRV of   TemplateMiddle::}${  is the empty code unit sequence.                                    The TV and TRV of   TemplateTail::}`  is the empty code unit sequence.                                    The TV of   NoSubstitutionTemplate::`TemplateCharacters`  is the TV of TemplateCharacters.                                    The TV of   TemplateHead::`TemplateCharacters${  is the TV of TemplateCharacters.                                    The TV of   TemplateMiddle::}TemplateCharacters${  is the TV of TemplateCharacters.                                    The TV of   TemplateTail::}TemplateCharacters`  is the TV of TemplateCharacters.                                    The TV of   TemplateCharacters::TemplateCharacter  is the TV of TemplateCharacter.                                    The TV of   TemplateCharacters::TemplateCharacterTemplateCharacters  is a sequence consisting of the code units in the TV of TemplateCharacter followed by all the code units in the TV of TemplateCharacters in order.                                    The TV of   TemplateCharacter::SourceCharacterbut not one of ` or \ or $ or LineTerminator  is the UTF16Encoding of the code point value of SourceCharacter.                                    The TV of   TemplateCharacter::$  is the code unit value 0x0024.                                    The TV of   TemplateCharacter::\EscapeSequence  is the SV of EscapeSequence.                                    The TV of   TemplateCharacter::LineContinuation  is the TV of LineContinuation.                                    The TV of   TemplateCharacter::LineTerminatorSequence  is the TRV of LineTerminatorSequence.                                    The TV of   LineContinuation::\LineTerminatorSequence  is the empty code unit sequence.                                    The TRV of   NoSubstitutionTemplate::`TemplateCharacters`  is the TRV of TemplateCharacters.                                    The TRV of   TemplateHead::`TemplateCharacters${  is the TRV of TemplateCharacters.                                    The TRV of   TemplateMiddle::}TemplateCharacters${  is the TRV of TemplateCharacters.                                    The TRV of   TemplateTail::}TemplateCharacters`  is the TRV of TemplateCharacters.                                    The TRV of   TemplateCharacters::TemplateCharacter  is the TRV of TemplateCharacter.                                    The TRV of   TemplateCharacters::TemplateCharacterTemplateCharacters  is a sequence consisting of the code units in the TRV of TemplateCharacter followed by all the code units in the TRV of TemplateCharacters, in order.                                    The TRV of   TemplateCharacter::SourceCharacterbut not one of ` or \ or $ or LineTerminator  is the UTF16Encoding of the code point value of SourceCharacter.                                    The TRV of   TemplateCharacter::$  is the code unit value 0x0024.                                    The TRV of   TemplateCharacter::\EscapeSequence  is the sequence consisting of the code unit value 0x005C followed by the code units of TRV of EscapeSequence.                                    The TRV of   TemplateCharacter::LineContinuation  is the TRV of LineContinuation.                                    The TRV of   TemplateCharacter::LineTerminatorSequence  is the TRV of LineTerminatorSequence.                                    The TRV of   EscapeSequence::CharacterEscapeSequence  is the TRV of the CharacterEscapeSequence.                                    The TRV of   EscapeSequence::0  is the code unit value 0x0030 (DIGIT ZERO).                                    The TRV of   EscapeSequence::HexEscapeSequence  is the TRV of the HexEscapeSequence.                                    The TRV of   EscapeSequence::UnicodeEscapeSequence  is the TRV of the UnicodeEscapeSequence.                                    The TRV of   CharacterEscapeSequence::SingleEscapeCharacter  is the TRV of the SingleEscapeCharacter.                                    The TRV of   CharacterEscapeSequence::NonEscapeCharacter  is the SV of the NonEscapeCharacter.                                    The TRV of   SingleEscapeCharacter::one of&apos;&amp;quot;\bfnrtv  is the SV of the SourceCharacter that is that single code point.                                    The TRV of   HexEscapeSequence::xHexDigitHexDigit  is the sequence consisting of code unit value 0x0078 followed by TRV of the first HexDigit followed by the TRV of the second HexDigit.                                    The TRV of   UnicodeEscapeSequence::uHex4Digits  is the sequence consisting of code unit value 0x0075 followed by TRV of Hex4Digits.                                    The TRV of   UnicodeEscapeSequence::u{HexDigits}  is the sequence consisting of code unit value 0x0075 followed by code unit value 0x007B followed by TRV of HexDigits followed by code unit value 0x007D.                                    The TRV of   Hex4Digits::HexDigitHexDigitHexDigitHexDigit  is the sequence consisting of the TRV of the first HexDigit followed by the TRV of the second HexDigit followed by the TRV of the third HexDigit followed by the TRV of the fourth HexDigit.                                    The TRV of   HexDigits::HexDigit  is the TRV of HexDigit.                                    The TRV of   HexDigits::HexDigitsHexDigit  is the sequence consisting of TRV of HexDigits followed by TRV of HexDigit.                                    The TRV of a HexDigit is the SV of the SourceCharacter that is that HexDigit.                                    The TRV of   LineContinuation::\LineTerminatorSequence  is the sequence consisting of the code unit value 0x005C followed by the code units of TRV of LineTerminatorSequence.                                    The TRV of   LineTerminatorSequence::&lt;LF&gt;  is the code unit value 0x000A.                                    The TRV of   LineTerminatorSequence::&lt;CR&gt;  is the code unit value 0x000A.                                    The TRV of   LineTerminatorSequence::&lt;LS&gt;  is the code unit value 0x2028.                                    The TRV of   LineTerminatorSequence::&lt;PS&gt;  is the code unit value 0x2029.                                    The TRV of   LineTerminatorSequence::&lt;CR&gt;&lt;LF&gt;  is the sequence consisting of the code unit value 0x000A.                        Note TV excludes the code units of LineContinuation while TRV includes them. &lt;CR&gt;&lt;LF&gt; and &lt;CR&gt; LineTerminatorSequences are normalized to &lt;LF&gt; for both TV and TRV. An explicit EscapeSequence is needed to include a &lt;CR&gt; or &lt;CR&gt;&lt;LF&gt; sequence.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.9.1">
	<buginformation>
		<summary>Rules of Automatic Semicolon Insertion</summary>
		<description>In the following rules, “token” means the actual recognized lexical token determined using the current lexical goal symbol as described in clause  11. There are three basic rules of semicolon insertion:   When, as the source text is parsed from left to right, a token (called the  offending token)  is encountered that is not allowed by any production of the grammar,  then a semicolon is automatically inserted before the offending token if  one or more of the following conditions is true:                 The offending token is separated from the previous token by at least one LineTerminator.                                          The offending token is }.                                          The previous token is ) and the inserted semicolon would then be parsed as the terminating semicolon of a do-while statement (13.7.2).                                        When, as the source text is parsed from left to right, the end  of the input stream of tokens is encountered and the parser is unable  to parse the input token stream as a single instance of the goal  nonterminal, then a semicolon is automatically inserted at the end of  the input stream.                              When, as the source text is parsed from left to right, a token  is encountered that is allowed by some production of the grammar, but  the production is a  restricted production and the token would be the first token for a terminal or nonterminal immediately following the annotation “[no LineTerminator  here]” within the restricted production (and therefore such a token is  called a restricted token), and the restricted token is separated from  the previous token by at least one LineTerminator, then a semicolon is automatically inserted before the restricted token.                    However, there is an additional overriding condition on the  preceding rules: a semicolon is never inserted automatically if the  semicolon would then be parsed as an empty statement or if that  semicolon would become one of the two semicolons in the header of a for statement (see  13.7.4). Note The following are the only restricted productions in the grammar:  UpdateExpression[Yield, Await]:LeftHandSideExpression[?Yield, ?Await][no LineTerminator here]++ LeftHandSideExpression[?Yield, ?Await][no LineTerminator here]--   ContinueStatement[Yield, Await]:continue; continue[no LineTerminator here]LabelIdentifier[?Yield, ?Await];   BreakStatement[Yield, Await]:break; break[no LineTerminator here]LabelIdentifier[?Yield, ?Await];   ReturnStatement[Yield, Await]:return; return[no LineTerminator here]Expression[+In, ?Yield, ?Await];   ThrowStatement[Yield, Await]:throw[no LineTerminator here]Expression[+In, ?Yield, ?Await];   ArrowFunction[In, Yield, Await]:ArrowParameters[?Yield, ?Await][no LineTerminator here]</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="11.9.2">
	<buginformation>
		<summary>Examples of Automatic Semicolon Insertion</summary>
		<description>The source { 1 2 } 3 is not a valid sentence in the ECMAScript grammar, even with the automatic semicolon insertion rules. In contrast, the source { 1 2 } 3 is also not a valid ECMAScript sentence, but is transformed by automatic semicolon insertion into the following: { 1 ;2 ;} 3; which is a valid ECMAScript sentence. The source for (a; b ) is not a valid ECMAScript sentence and is not altered by  automatic semicolon insertion because the semicolon is needed for the  header of a for statement. Automatic semicolon insertion never inserts one of the two semicolons in the header of a for statement. The source return a + b is transformed by automatic semicolon insertion into the following: return; a + b; Note 1 The expression a + b is not treated as a value to be returned by the return statement, because a LineTerminator separates it from the token return.  The source a</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.1.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>BindingIdentifier:Identifier              It is a Syntax Error if the code matched by this production is contained in strict mode code and the StringValue of Identifier is &amp;quot;arguments&amp;quot; or &amp;quot;eval&amp;quot;.                     IdentifierReference:yield   BindingIdentifier:yield   LabelIdentifier:yield              It is a Syntax Error if the code matched by this production is contained in strict mode code.                     IdentifierReference:await   BindingIdentifier:await   LabelIdentifier:await              It is a Syntax Error if the goal symbol of the syntactic grammar is Module.                     IdentifierReference[Yield, Await]:Identifier   BindingIdentifier[Yield, Await]:Identifier   LabelIdentifier[Yield, Await]:Identifier              It is a Syntax Error if this production has a  [Yield] parameter and StringValue of Identifier is &amp;quot;yield&amp;quot;.                              It is a Syntax Error if this production has an  [Await] parameter and StringValue of Identifier is &amp;quot;await&amp;quot;.                     Identifier:IdentifierNamebut not ReservedWord              It is a Syntax Error if this phrase is contained in strict mode code and the StringValue of IdentifierName is: &amp;quot;implements&amp;quot;, &amp;quot;interface&amp;quot;, &amp;quot;let&amp;quot;, &amp;quot;package&amp;quot;, &amp;quot;private&amp;quot;, &amp;quot;protected&amp;quot;, &amp;quot;public&amp;quot;, &amp;quot;static&amp;quot;, or &amp;quot;yield&amp;quot;.                              It is a Syntax Error if StringValue of IdentifierName is the same String value as the StringValue of any ReservedWord except for yield.                    Note StringValue of IdentifierName normalizes any Unicode escape sequences in IdentifierName hence such escapes cannot be used to write an Identifier whose code point sequence is the same as a ReservedWord.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.1.2">
	<buginformation>
		<summary>Static Semantics: BoundNames</summary>
		<description>BindingIdentifier:Identifier  Return a new List containing the StringValue of Identifier.         BindingIdentifier:yield  Return a new List containing &amp;quot;yield&amp;quot;.         BindingIdentifier:await  Return a new List containing &amp;quot;await&amp;quot;.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.1.3">
	<buginformation>
		<summary>Static Semantics: IsValidSimpleAssignmentTarget</summary>
		<description>IdentifierReference:Identifier  If this IdentifierReference is contained in strict mode code and StringValue of Identifier is &amp;quot;eval&amp;quot; or &amp;quot;arguments&amp;quot;, return false.Return true.         IdentifierReference:yield  Return true.         IdentifierReference:await  Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.1.4">
	<buginformation>
		<summary>Static Semantics: StringValue</summary>
		<description>IdentifierReference:yield   BindingIdentifier:yield   LabelIdentifier:yield  Return &amp;quot;yield&amp;quot;.         IdentifierReference:await   BindingIdentifier:await   LabelIdentifier:await  Return &amp;quot;await&amp;quot;.         Identifier:IdentifierNamebut not ReservedWord  Return the StringValue of IdentifierName.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.1.5.1">
	<buginformation>
		<summary>Runtime Semantics: InitializeBoundName ( name, value, environment )</summary>
		<description>Assert: Type(name) is String.If environment is not undefined, thenLet env be the EnvironmentRecord component of environment.Perform env.InitializeBinding(name, value).Return NormalCompletion(undefined).Else,Let lhs be ResolveBinding(name).Return ? PutValue(lhs, value).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.1.6">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>IdentifierReference:Identifier  Return ? ResolveBinding(StringValue of Identifier).         IdentifierReference:yield  Return ? ResolveBinding(&amp;quot;yield&amp;quot;).         IdentifierReference:await  Return ? ResolveBinding(&amp;quot;await&amp;quot;).        Note 1 The result of evaluating an IdentifierReference is always a value of type Reference.  Note 2 In non-strict code, the keyword yield may be used as an identifier. Evaluating the IdentifierReference resolves the binding of yield as if it was an Identifier. Early Error restriction ensures that such an evaluation only can occur for non-strict code.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.1.1">
	<buginformation>
		<summary>Static Semantics: CoveredParenthesizedExpression</summary>
		<description>CoverParenthesizedExpressionAndArrowParameterList[Yield, Await]:(Expression[+In, ?Yield, ?Await])  Return the result of parsing the lexical token stream matched by CoverParenthesizedExpressionAndArrowParameterList using ParenthesizedExpression as the goal symbol with its [Yield] and [Await] parameters set to the values used when parsing this CoverParenthesizedExpressionAndArrowParameterList.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.1.2">
	<buginformation>
		<summary>Static Semantics: HasName</summary>
		<description>PrimaryExpression:CoverParenthesizedExpressionAndArrowParameterList  Let expr be CoveredParenthesizedExpression of CoverParenthesizedExpressionAndArrowParameterList.If IsFunctionDefinition of expr is false, return false.Return HasName of expr.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.1.3">
	<buginformation>
		<summary>Static Semantics: IsFunctionDefinition</summary>
		<description>PrimaryExpression:this IdentifierReference Literal ArrayLiteral ObjectLiteral RegularExpressionLiteral TemplateLiteral  Return false.           PrimaryExpression:CoverParenthesizedExpressionAndArrowParameterList  Let expr be CoveredParenthesizedExpression of CoverParenthesizedExpressionAndArrowParameterList.Return IsFunctionDefinition of expr.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.1.4">
	<buginformation>
		<summary>Static Semantics: IsIdentifierRef</summary>
		<description>PrimaryExpression:IdentifierReference  Return true.           PrimaryExpression:this Literal ArrayLiteral ObjectLiteral FunctionExpression ClassExpression GeneratorExpression AsyncFunctionExpression RegularExpressionLiteral TemplateLiteral CoverParenthesizedExpressionAndArrowParameterList  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.1.5">
	<buginformation>
		<summary>Static Semantics: IsValidSimpleAssignmentTarget</summary>
		<description>PrimaryExpression:this Literal ArrayLiteral ObjectLiteral FunctionExpression ClassExpression GeneratorExpression AsyncFunctionExpression RegularExpressionLiteral TemplateLiteral  Return false.           PrimaryExpression:CoverParenthesizedExpressionAndArrowParameterList  Let expr be CoveredParenthesizedExpression of CoverParenthesizedExpressionAndArrowParameterList.Return IsValidSimpleAssignmentTarget of expr.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.2.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>PrimaryExpression:this  Return ? ResolveThisBinding( ).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.3">
	<buginformation>
		<summary>Identifier Reference</summary>
		<description>See  12.1 for IdentifierReference.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.4.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>Literal:NullLiteral  Return null.           Literal:BooleanLiteral  If BooleanLiteral is the token false, return false.If BooleanLiteral is the token true, return true.           Literal:NumericLiteral  Return the number whose value is MV of NumericLiteral as defined in 11.8.3.           Literal:StringLiteral  Return the StringValue of StringLiteral as defined in 11.8.4.2.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.5.1">
	<buginformation>
		<summary>Static Semantics: ElisionWidth</summary>
		<description>Elision:,  Return the numeric value 1.           Elision:Elision,  Let preceding be the ElisionWidth of Elision.Return preceding+1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.5.2">
	<buginformation>
		<summary>Runtime Semantics: ArrayAccumulation</summary>
		<description>With parameters array and nextIndex.  ElementList:ElisionoptAssignmentExpression  Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.Let initResult be the result of evaluating AssignmentExpression.Let initValue be ? GetValue(initResult).Let created be CreateDataProperty(array, ToString(ToUint32(nextIndex+padding)), initValue).Assert: created is true.Return nextIndex+padding+1.           ElementList:ElisionoptSpreadElement  Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.Return the result of performing ArrayAccumulation for SpreadElement with arguments array and nextIndex+padding.           ElementList:ElementList,ElisionoptAssignmentExpression  Let postIndex be the result of performing ArrayAccumulation for ElementList with arguments array and nextIndex.ReturnIfAbrupt(postIndex).Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.Let initResult be the result of evaluating AssignmentExpression.Let initValue be ? GetValue(initResult).Let created be CreateDataProperty(array, ToString(ToUint32(postIndex+padding)), initValue).Assert: created is true.Return postIndex+padding+1.           ElementList:ElementList,ElisionoptSpreadElement  Let postIndex be the result of performing ArrayAccumulation for ElementList with arguments array and nextIndex.ReturnIfAbrupt(postIndex).Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.Return the result of performing ArrayAccumulation for SpreadElement with arguments array and postIndex+padding.           SpreadElement:...AssignmentExpression  Let spreadRef be the result of evaluating AssignmentExpression.Let spreadObj be ? GetValue(spreadRef).Let iterator be ? GetIterator(spreadObj).Repeat,Let next be ? IteratorStep(iterator).If next is false, return nextIndex.Let nextValue be ? IteratorValue(next).Let status be CreateDataProperty(array, ToString(ToUint32(nextIndex)), nextValue).Assert: status is true.Let nextIndex be nextIndex + 1.          Note CreateDataProperty  is used to ensure that own properties are defined for the array even if  the standard built-in Array prototype object has been modified in a  manner that would preclude the creation of new own properties using  [[Set]].</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.5.3">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>ArrayLiteral:[Elisionopt]  Let array be ! ArrayCreate(0).Let pad be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.Perform Set(array, &amp;quot;length&amp;quot;, ToUint32(pad), false).NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.Return array.           ArrayLiteral:[ElementList]  Let array be ! ArrayCreate(0).Let len be the result of performing ArrayAccumulation for ElementList with arguments array and 0.ReturnIfAbrupt(len).Perform Set(array, &amp;quot;length&amp;quot;, ToUint32(len), false).NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.Return array.           ArrayLiteral:[ElementList,Elisionopt]  Let array be ! ArrayCreate(0).Let len be the result of performing ArrayAccumulation for ElementList with arguments array and 0.ReturnIfAbrupt(len).Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.Perform Set(array, &amp;quot;length&amp;quot;, ToUint32(padding+len), false).NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.Return array.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.6.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>PropertyDefinition:MethodDefinition                It is a Syntax Error if HasDirectSuper of MethodDefinition is true.                        In addition to describing an actual object initializer the ObjectLiteral productions are also used as a cover grammar for ObjectAssignmentPattern and may be recognized as part of a CoverParenthesizedExpressionAndArrowParameterList. When ObjectLiteral appears in a context where ObjectAssignmentPattern is required the following Early Error rules are  not applied. In addition, they are not applied when initially parsing a CoverParenthesizedExpressionAndArrowParameterList or CoverCallExpressionAndAsyncArrowHead.  PropertyDefinition:CoverInitializedName                Always throw a Syntax Error if code matches this production.                        Note This production exists so that ObjectLiteral can serve as a cover grammar for ObjectAssignmentPattern. It cannot occur in an actual object initializer.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.6.2">
	<buginformation>
		<summary>Static Semantics: ComputedPropertyContains</summary>
		<description>With parameter symbol.   PropertyName:LiteralPropertyName  Return false.           PropertyName:ComputedPropertyName  Return the result of ComputedPropertyName Contains symbol.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.6.3">
	<buginformation>
		<summary>Static Semantics: Contains</summary>
		<description>With parameter symbol.   PropertyDefinition:MethodDefinition  If symbol is MethodDefinition, return true.Return the result of ComputedPropertyContains for MethodDefinition with argument symbol.          Note Static semantic rules that depend upon substructure generally do not look into function definitions.   LiteralPropertyName:IdentifierName  If symbol is a ReservedWord, return false.If symbol is an Identifier and StringValue of symbol is the same value as the StringValue of IdentifierName, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.6.4">
	<buginformation>
		<summary>Static Semantics: IsComputedPropertyKey</summary>
		<description>PropertyName:LiteralPropertyName  Return false.           PropertyName:ComputedPropertyName  Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.6.5">
	<buginformation>
		<summary>Static Semantics: PropName</summary>
		<description>PropertyDefinition:IdentifierReference  Return StringValue of IdentifierReference.           PropertyDefinition:PropertyName:AssignmentExpression  Return PropName of PropertyName.           LiteralPropertyName:IdentifierName  Return StringValue of IdentifierName.           LiteralPropertyName:StringLiteral  Return a String value whose code units are the SV of the StringLiteral.           LiteralPropertyName:NumericLiteral  Let nbr be the result of forming the value of the NumericLiteral.Return ! ToString(nbr).           ComputedPropertyName:[AssignmentExpression]  Return empty.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.6.6">
	<buginformation>
		<summary>Static Semantics: PropertyNameList</summary>
		<description>PropertyDefinitionList:PropertyDefinition  If PropName of PropertyDefinition is empty, return a new empty List.Return a new List containing PropName of PropertyDefinition.           PropertyDefinitionList:PropertyDefinitionList,PropertyDefinition  Let list be PropertyNameList of PropertyDefinitionList.If PropName of PropertyDefinition is empty, return list.Append PropName of PropertyDefinition to the end of list.Return list.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.6.7">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>ObjectLiteral:{}  Return ObjectCreate(%ObjectPrototype%).           ObjectLiteral:{PropertyDefinitionList} {PropertyDefinitionList,}  Let obj be ObjectCreate(%ObjectPrototype%).Let status be the result of performing PropertyDefinitionEvaluation of PropertyDefinitionList with arguments obj and true.ReturnIfAbrupt(status).Return obj.           LiteralPropertyName:IdentifierName  Return StringValue of IdentifierName.           LiteralPropertyName:StringLiteral  Return a String value whose code units are the SV of the StringLiteral.           LiteralPropertyName:NumericLiteral  Let nbr be the result of forming the value of the NumericLiteral.Return ! ToString(nbr).           ComputedPropertyName:[AssignmentExpression]  Let exprValue be the result of evaluating AssignmentExpression.Let propName be ? GetValue(exprValue).Return ? ToPropertyKey(propName).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.6.8">
	<buginformation>
		<summary>Runtime Semantics: PropertyDefinitionEvaluation</summary>
		<description>With parameters object and enumerable.   PropertyDefinitionList:PropertyDefinitionList,PropertyDefinition  Let status be the result of performing PropertyDefinitionEvaluation of PropertyDefinitionList with arguments object and enumerable.ReturnIfAbrupt(status).Return the result of performing PropertyDefinitionEvaluation of PropertyDefinition with arguments object and enumerable.           PropertyDefinition:IdentifierReference  Let propName be StringValue of IdentifierReference.Let exprValue be the result of evaluating IdentifierReference.Let propValue be ? GetValue(exprValue).Assert: enumerable is true.Return CreateDataPropertyOrThrow(object, propName, propValue).           PropertyDefinition:PropertyName:AssignmentExpression  Let propKey be the result of evaluating PropertyName.ReturnIfAbrupt(propKey).Let exprValueRef be the result of evaluating AssignmentExpression.Let propValue be ? GetValue(exprValueRef).If IsAnonymousFunctionDefinition(AssignmentExpression) is true, thenLet hasNameProperty be ? HasOwnProperty(propValue, &amp;quot;name&amp;quot;).If hasNameProperty is false, perform SetFunctionName(propValue, propKey).Assert: enumerable is true.Return CreateDataPropertyOrThrow(object, propKey, propValue).          Note An alternative semantics for this production is given in  B.3.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.7">
	<buginformation>
		<summary>Function Defining Expressions</summary>
		<description>See  14.1 for   PrimaryExpression:FunctionExpression . See  14.4 for   PrimaryExpression:GeneratorExpression . See  14.5 for   PrimaryExpression:ClassExpression . See  14.6 for   PrimaryExpression:AsyncFunctionExpression .</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.8.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>PrimaryExpression:RegularExpressionLiteral                It is a Syntax Error if BodyText of RegularExpressionLiteral cannot be recognized using the goal symbol Pattern of the ECMAScript RegExp grammar specified in  21.2.1.                                    It is a Syntax Error if FlagText of RegularExpressionLiteral contains any code points other than &amp;quot;g&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;u&amp;quot;, or &amp;quot;y&amp;quot;, or if it contains the same code point more than once.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.8.2">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>PrimaryExpression:RegularExpressionLiteral  Let pattern be the String value consisting of the UTF16Encoding of each code point of BodyText of RegularExpressionLiteral.Let flags be the String value consisting of the UTF16Encoding of each code point of FlagText of RegularExpressionLiteral.Return RegExpCreate(pattern, flags).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.9.1">
	<buginformation>
		<summary>Static Semantics: TemplateStrings</summary>
		<description>With parameter raw.  TemplateLiteral:NoSubstitutionTemplate  If raw is false, thenLet string be the TV of NoSubstitutionTemplate.Else,Let string be the TRV of NoSubstitutionTemplate.Return a List containing the single element, string.           TemplateLiteral:TemplateHeadExpressionTemplateSpans  If raw is false, thenLet head be the TV of TemplateHead.Else,Let head be the TRV of TemplateHead.Let tail be TemplateStrings of TemplateSpans with argument raw.Return a List containing head followed by the elements, in order, of tail.           TemplateSpans:TemplateTail  If raw is false, thenLet tail be the TV of TemplateTail.Else,Let tail be the TRV of TemplateTail.Return a List containing the single element, tail.           TemplateSpans:TemplateMiddleListTemplateTail  Let middle be TemplateStrings of TemplateMiddleList with argument raw.If raw is false, thenLet tail be the TV of TemplateTail.Else,Let tail be the TRV of TemplateTail.Return a List containing the elements, in order, of middle followed by tail.           TemplateMiddleList:TemplateMiddleExpression  If raw is false, thenLet string be the TV of TemplateMiddle.Else,Let string be the TRV of TemplateMiddle.Return a List containing the single element, string.           TemplateMiddleList:TemplateMiddleListTemplateMiddleExpression  Let front be TemplateStrings of TemplateMiddleList with argument raw.If raw is false, thenLet last be the TV of TemplateMiddle.Else,Let last be the TRV of TemplateMiddle.Append last as the last element of the List front.Return front.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.9.2">
	<buginformation>
		<summary>Runtime Semantics: ArgumentListEvaluation</summary>
		<description>TemplateLiteral:NoSubstitutionTemplate  Let templateLiteral be this TemplateLiteral.Let siteObj be GetTemplateObject(templateLiteral).Return a List containing the one element which is siteObj.           TemplateLiteral:TemplateHeadExpressionTemplateSpans  Let templateLiteral be this TemplateLiteral.Let siteObj be GetTemplateObject(templateLiteral).Let firstSubRef be the result of evaluating Expression.Let firstSub be ? GetValue(firstSubRef).Let restSub be SubstitutionEvaluation of TemplateSpans.ReturnIfAbrupt(restSub).Assert: restSub is a List.Return a List whose first element is siteObj, whose second elements is firstSub, and whose subsequent elements are the elements of restSub, in order. restSub may contain no elements.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.9.3">
	<buginformation>
		<summary>Runtime Semantics: GetTemplateObject ( templateLiteral )</summary>
		<description>The abstract operation GetTemplateObject is called with a Parse Node, templateLiteral, as an argument. It performs the following steps: Let rawStrings be TemplateStrings of templateLiteral with argument true.Let realm be the current Realm Record.Let templateRegistry be realm.[[TemplateMap]].For each element e of templateRegistry, doIf e.[[Strings]] and rawStrings contain the same values in the same order, thenReturn e.[[Array]].Let cookedStrings be TemplateStrings of templateLiteral with argument false.Let count be the number of elements in the List cookedStrings.Let template be ! ArrayCreate(count).Let rawObj be ! ArrayCreate(count).Let index be 0.Repeat, while index &lt; countLet prop be ! ToString(index).Let cookedValue be the String value cookedStrings[index].Call template.[[DefineOwnProperty]](prop, PropertyDescriptor{[[Value]]: cookedValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false}).Let rawValue be the String value rawStrings[index].Call rawObj.[[DefineOwnProperty]](prop, PropertyDescriptor{[[Value]]: rawValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false}).Let index be index+1.Perform SetIntegrityLevel(rawObj, &amp;quot;frozen&amp;quot;).Call template.[[DefineOwnProperty]](&amp;quot;raw&amp;quot;, PropertyDescriptor{[[Value]]: rawObj, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}).Perform SetIntegrityLevel(template, &amp;quot;frozen&amp;quot;).Append the Record{[[Strings]]: rawStrings, [[Array]]: template} to templateRegistry.Return template.          Note 1 The creation of a template object cannot result in an abrupt completion.  Note 2 Each TemplateLiteral in the program code of a realm is associated with a unique template object that is used in the evaluation of tagged Templates (12.2.9.5).  The template objects are frozen and the same template object is used  each time a specific tagged Template is evaluated. Whether template  objects are created lazily upon first evaluation of the TemplateLiteral or eagerly prior to first evaluation is an implementation choice that is not observable to ECMAScript code.  Note 3 Future editions of this specification may define additional non-enumerable properties of template objects.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.9.4">
	<buginformation>
		<summary>Runtime Semantics: SubstitutionEvaluation</summary>
		<description>TemplateSpans:TemplateTail  Return a new empty List.           TemplateSpans:TemplateMiddleListTemplateTail  Return the result of SubstitutionEvaluation of TemplateMiddleList.           TemplateMiddleList:TemplateMiddleExpression  Let subRef be the result of evaluating Expression.Let sub be ? GetValue(subRef).Return a List containing only sub.           TemplateMiddleList:TemplateMiddleListTemplateMiddleExpression  Let preceding be the result of SubstitutionEvaluation of TemplateMiddleList.ReturnIfAbrupt(preceding).Let nextRef be the result of evaluating Expression.Let next be ? GetValue(nextRef).Append next as the last element of the List preceding.Return preceding.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.9.5">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>TemplateLiteral:NoSubstitutionTemplate  Return the String value whose code units are the elements of the TV of NoSubstitutionTemplate as defined in 11.8.6.           TemplateLiteral:TemplateHeadExpressionTemplateSpans  Let head be the TV of TemplateHead as defined in 11.8.6.Let sub be the result of evaluating Expression.ReturnIfAbrupt(sub).Let middle be ? ToString(sub).Let tail be the result of evaluating TemplateSpans.ReturnIfAbrupt(tail).Return the String value whose code units are the elements of head followed by the elements of middle followed by the elements of tail.          Note 1 The string conversion semantics applied to the Expression value are like String.prototype.concat rather than the + operator.   TemplateSpans:TemplateTail  Let tail be the TV of TemplateTail as defined in 11.8.6.Return the String consisting of the code units of tail.           TemplateSpans:TemplateMiddleListTemplateTail  Let head be the result of evaluating TemplateMiddleList.ReturnIfAbrupt(head).Let tail be the TV of TemplateTail as defined in 11.8.6.Return the String value whose code units are the elements of head followed by the elements of tail.           TemplateMiddleList:TemplateMiddleExpression  Let head be the TV of TemplateMiddle as defined in 11.8.6.Let sub be the result of evaluating Expression.ReturnIfAbrupt(sub).Let middle be ? ToString(sub).Return the sequence of code units consisting of the code units of head followed by the elements of middle.          Note 2 The string conversion semantics applied to the Expression value are like String.prototype.concat rather than the + operator.   TemplateMiddleList:TemplateMiddleListTemplateMiddleExpression  Let rest be the result of evaluating TemplateMiddleList.ReturnIfAbrupt(rest).Let middle be the TV of TemplateMiddle as defined in 11.8.6.Let sub be the result of evaluating Expression.ReturnIfAbrupt(sub).Let last be ? ToString(sub).Return the sequence of code units consisting of the elements of rest followed by the code units of middle followed by the elements of last.          Note 3 The string conversion semantics applied to the Expression value are like String.prototype.concat rather than the + operator.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.10.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>PrimaryExpression:CoverParenthesizedExpressionAndArrowParameterList                It is a Syntax Error if the lexical token sequence matched by CoverParenthesizedExpressionAndArrowParameterList cannot be parsed with no tokens left over using ParenthesizedExpression as the goal symbol.                                    All Early Error rules for ParenthesizedExpression and its derived productions also apply to CoveredParenthesizedExpression of CoverParenthesizedExpressionAndArrowParameterList.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.10.2">
	<buginformation>
		<summary>Static Semantics: IsFunctionDefinition</summary>
		<description>ParenthesizedExpression:(Expression)  Return IsFunctionDefinition of Expression.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.10.3">
	<buginformation>
		<summary>Static Semantics: IsValidSimpleAssignmentTarget</summary>
		<description>ParenthesizedExpression:(Expression)  Return IsValidSimpleAssignmentTarget of Expression.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.2.10.4">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>PrimaryExpression:CoverParenthesizedExpressionAndArrowParameterList  Let expr be CoveredParenthesizedExpression of CoverParenthesizedExpressionAndArrowParameterList.Return the result of evaluating expr.           ParenthesizedExpression:(Expression)  Return the result of evaluating Expression. This may be of type Reference.          Note This algorithm does not apply GetValue to the result of evaluating Expression. The principal motivation for this is so that operators such as delete and typeof may be applied to parenthesized expressions.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.3.1.1">
	<buginformation>
		<summary>Static Semantics: CoveredCallExpression</summary>
		<description>CallExpression:CoverCallExpressionAndAsyncArrowHead  Return the result of parsing the lexical token stream matched by CoverCallExpressionAndAsyncArrowHead using CallMemberExpression as the goal symbol with its [Yield] and [Await] parameters set to the values used when parsing CoverCallExpressionAndAsyncArrowHead.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.3.1.2">
	<buginformation>
		<summary>Static Semantics: Contains</summary>
		<description>With parameter symbol.   MemberExpression:MemberExpression.IdentifierName  If MemberExpression Contains symbol is true, return true.If symbol is a ReservedWord, return false.If symbol is an Identifier and StringValue of symbol is the same value as the StringValue of IdentifierName, return true.Return false.           SuperProperty:super.IdentifierName  If symbol is the ReservedWord super, return true.If symbol is a ReservedWord, return false.If symbol is an Identifier and StringValue of symbol is the same value as the StringValue of IdentifierName, return true.Return false.           CallExpression:CallExpression.IdentifierName  If CallExpression Contains symbol is true, return true.If symbol is a ReservedWord, return false.If symbol is an Identifier and StringValue of symbol is the same value as the StringValue of IdentifierName, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.3.1.3">
	<buginformation>
		<summary>Static Semantics: IsFunctionDefinition</summary>
		<description>MemberExpression:MemberExpression[Expression] MemberExpression.IdentifierName MemberExpressionTemplateLiteral SuperProperty MetaProperty newMemberExpressionArguments   NewExpression:newNewExpression   LeftHandSideExpression:CallExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.3.1.4">
	<buginformation>
		<summary>Static Semantics: IsDestructuring</summary>
		<description>MemberExpression:PrimaryExpression  If PrimaryExpression is either an ObjectLiteral or an ArrayLiteral, return true.Return false.           MemberExpression:MemberExpression[Expression] MemberExpression.IdentifierName MemberExpressionTemplateLiteral SuperProperty MetaProperty newMemberExpressionArguments   NewExpression:newNewExpression   LeftHandSideExpression:CallExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.3.1.5">
	<buginformation>
		<summary>Static Semantics: IsIdentifierRef</summary>
		<description>MemberExpression:MemberExpression[Expression] MemberExpression.IdentifierName MemberExpressionTemplateLiteral SuperProperty MetaProperty newMemberExpressionArguments   NewExpression:newNewExpression   LeftHandSideExpression:CallExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.3.1.6">
	<buginformation>
		<summary>Static Semantics: IsValidSimpleAssignmentTarget</summary>
		<description>CallExpression:CallExpression[Expression] CallExpression.IdentifierName   MemberExpression:MemberExpression[Expression] MemberExpression.IdentifierName SuperProperty  Return true.           CallExpression:CoverCallExpressionAndAsyncArrowHead SuperCall CallExpressionArguments CallExpressionTemplateLiteral   NewExpression:newNewExpression   MemberExpression:MemberExpressionTemplateLiteral newMemberExpressionArguments   NewTarget:new.target  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.3.2.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>MemberExpression:MemberExpression[Expression]  Let baseReference be the result of evaluating MemberExpression.Let baseValue be ? GetValue(baseReference).Let propertyNameReference be the result of evaluating Expression.Let propertyNameValue be ? GetValue(propertyNameReference).Let bv be ? RequireObjectCoercible(baseValue).Let propertyKey be ? ToPropertyKey(propertyNameValue).If the code matched by this MemberExpression is strict mode code, let strict be true, else let strict be false.Return a value of type Reference whose base value component is bv, whose referenced name component is propertyKey, and whose strict reference flag is strict.           MemberExpression:MemberExpression.IdentifierName  Let baseReference be the result of evaluating MemberExpression.Let baseValue be ? GetValue(baseReference).Let bv be ? RequireObjectCoercible(baseValue).Let propertyNameString be StringValue of IdentifierName.If the code matched by this MemberExpression is strict mode code, let strict be true, else let strict be false.Return a value of type Reference whose base value component is bv, whose referenced name component is propertyNameString, and whose strict reference flag is strict.           CallExpression:CallExpression[Expression]  Is evaluated in exactly the same manner as   MemberExpression:MemberExpression[Expression]  except that the contained CallExpression is evaluated in step 1.  CallExpression:CallExpression.IdentifierName  Is evaluated in exactly the same manner as   MemberExpression:MemberExpression.IdentifierName  except that the contained CallExpression is evaluated in step 1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.3.3.1.1">
	<buginformation>
		<summary>Runtime Semantics: EvaluateNew ( constructExpr, arguments )</summary>
		<description>The abstract operation EvaluateNew with arguments constructExpr, and arguments performs the following steps: Assert: constructExpr is either a NewExpression or a MemberExpression.Assert: arguments is either empty or an Arguments.Let ref be the result of evaluating constructExpr.Let constructor be ? GetValue(ref).If arguments is empty, let argList be a new empty List.Else,Let argList be ArgumentListEvaluation of arguments.ReturnIfAbrupt(argList).If IsConstructor(constructor) is false, throw a TypeError exception.Return ? Construct(constructor, argList).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.3.4.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>CallExpression:CoverCallExpressionAndAsyncArrowHead  Let expr be CoveredCallExpression of CoverCallExpressionAndAsyncArrowHead.Let memberExpr be the MemberExpression of expr.Let arguments be the Arguments of expr.Let ref be the result of evaluating memberExpr.Let func be ? GetValue(ref).If Type(ref) is Reference and IsPropertyReference(ref) is false and GetReferencedName(ref) is &amp;quot;eval&amp;quot;, thenIf SameValue(func, %eval%) is true, thenLet argList be ? ArgumentListEvaluation(arguments).If argList has no elements, return undefined.Let evalText be the first element of argList.If the source code matching this CallExpression is strict mode code, let strictCaller be true. Otherwise let strictCaller be false.Let evalRealm be the current Realm Record.Perform ? HostEnsureCanCompileStrings(evalRealm, evalRealm).Return ? PerformEval(evalText, evalRealm, strictCaller, true).If Type(ref) is Reference, thenIf IsPropertyReference(ref) is true, thenLet thisValue be GetThisValue(ref).Else the base of ref is an Environment Record,Let refEnv be GetBase(ref).Let thisValue be refEnv.WithBaseObject().Else Type(ref) is not Reference,Let thisValue be undefined.Let thisCall be this CallExpression.Let tailCall be IsInTailPosition(thisCall).Return ? EvaluateDirectCall(func, thisValue, arguments, tailCall).          A CallExpression evaluation that executes step 6.a.vii is a  direct eval.  CallExpression:CallExpressionArguments  Let ref be the result of evaluating CallExpression.Let thisCall be this CallExpression.Let tailCall be IsInTailPosition(thisCall).Return ? EvaluateCall(ref, Arguments, tailCall).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.3.4.2">
	<buginformation>
		<summary>Runtime Semantics: EvaluateCall( ref, arguments, tailPosition )</summary>
		<description>The abstract operation EvaluateCall takes as arguments a value ref, a Parse Node arguments, and a Boolean argument tailPosition. It performs the following steps: Let func be ? GetValue(ref).If Type(ref) is Reference, thenIf IsPropertyReference(ref) is true, thenLet thisValue be GetThisValue(ref).Else the base of ref is an Environment Record,Let refEnv be GetBase(ref).Let thisValue be refEnv.WithBaseObject().Else Type(ref) is not Reference,Let thisValue be undefined.Return ? EvaluateDirectCall(func, thisValue, arguments, tailPosition).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.3.4.3">
	<buginformation>
		<summary>Runtime Semantics: EvaluateDirectCall( func, thisValue, arguments, tailPosition )</summary>
		<description>The abstract operation EvaluateDirectCall takes as arguments a value func, a value thisValue, a Parse Node arguments, and a Boolean argument tailPosition. It performs the following steps: Let argList be ? ArgumentListEvaluation(arguments).If Type(func) is not Object, throw a TypeError exception.If IsCallable(func) is false, throw a TypeError exception.If tailPosition is true, perform PrepareForTailCall().Let result be Call(func, thisValue, argList).Assert: If tailPosition is true, the above call will not return here, but instead evaluation will continue as if the following return has already occurred.Assert: If result is not an abrupt completion, then Type(result) is an ECMAScript language type.Return result.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.3.5.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>SuperProperty:super[Expression]  Let propertyNameReference be the result of evaluating Expression.Let propertyNameValue be ? GetValue(propertyNameReference).Let propertyKey be ? ToPropertyKey(propertyNameValue).If the code matched by this SuperProperty is strict mode code, let strict be true, else let strict be false.Return ? MakeSuperPropertyReference(propertyKey, strict).           SuperProperty:super.IdentifierName  Let propertyKey be StringValue of IdentifierName.If the code matched by this SuperProperty is strict mode code, let strict be true, else let strict be false.Return ? MakeSuperPropertyReference(propertyKey, strict).           SuperCall:superArguments  Let newTarget be GetNewTarget().Assert: Type(newTarget) is Object.Let func be ? GetSuperConstructor().Let argList be ArgumentListEvaluation of Arguments.ReturnIfAbrupt(argList).Let result be ? Construct(func, argList, newTarget).Let thisER be GetThisEnvironment( ).Return ? thisER.BindThisValue(result).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.3.5.2">
	<buginformation>
		<summary>Runtime Semantics: GetSuperConstructor ( )</summary>
		<description>The abstract operation GetSuperConstructor performs the following steps: Let envRec be GetThisEnvironment( ).Assert: envRec is a function Environment Record.Let activeFunction be envRec.[[FunctionObject]].Assert: activeFunction is an ECMAScript function object.Let superConstructor be ! activeFunction.[[GetPrototypeOf]]().If IsConstructor(superConstructor) is false, throw a TypeError exception.Return superConstructor.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.3.5.3">
	<buginformation>
		<summary>Runtime Semantics: MakeSuperPropertyReference ( propertyKey, strict )</summary>
		<description>The abstract operation MakeSuperPropertyReference with arguments propertyKey and strict performs the following steps: Let env be GetThisEnvironment( ).Assert: env.HasSuperBinding() is true.Let actualThis be ? env.GetThisBinding().Let baseValue be ? env.GetSuperBase().Let bv be ? RequireObjectCoercible(baseValue).Return a value of type Reference that is a Super Reference whose base value component is bv, whose referenced name component is propertyKey, whose thisValue component is actualThis, and whose strict reference flag is strict.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.3.6.1">
	<buginformation>
		<summary>Runtime Semantics: ArgumentListEvaluation</summary>
		<description>Arguments:()  Return a new empty List.           ArgumentList:AssignmentExpression  Let ref be the result of evaluating AssignmentExpression.Let arg be ? GetValue(ref).Return a List whose sole item is arg.           ArgumentList:...AssignmentExpression  Let list be a new empty List.Let spreadRef be the result of evaluating AssignmentExpression.Let spreadObj be ? GetValue(spreadRef).Let iterator be ? GetIterator(spreadObj).Repeat,Let next be ? IteratorStep(iterator).If next is false, return list.Let nextArg be ? IteratorValue(next).Append nextArg as the last element of list.           ArgumentList:ArgumentList,AssignmentExpression  Let precedingArgs be ArgumentListEvaluation of ArgumentList.ReturnIfAbrupt(precedingArgs).Let ref be the result of evaluating AssignmentExpression.Let arg be ? GetValue(ref).Append arg to the end of precedingArgs.Return precedingArgs.           ArgumentList:ArgumentList,...AssignmentExpression  Let precedingArgs be ArgumentListEvaluation of ArgumentList.ReturnIfAbrupt(precedingArgs).Let spreadRef be the result of evaluating AssignmentExpression.Let iterator be ? GetIterator(? GetValue(spreadRef)).Repeat,Let next be ? IteratorStep(iterator).If next is false, return precedingArgs.Let nextArg be ? IteratorValue(next).Append nextArg as the last element of precedingArgs.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.3.7.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>MemberExpression:MemberExpressionTemplateLiteral  Let tagRef be the result of evaluating MemberExpression.Let thisCall be this MemberExpression.Let tailCall be IsInTailPosition(thisCall).Return ? EvaluateCall(tagRef, TemplateLiteral, tailCall).           CallExpression:CallExpressionTemplateLiteral  Let tagRef be the result of evaluating CallExpression.Let thisCall be this CallExpression.Let tailCall be IsInTailPosition(thisCall).Return ? EvaluateCall(tagRef, TemplateLiteral, tailCall).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.3.8.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>NewTarget:new.target  Return GetNewTarget().</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.4.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>UpdateExpression:LeftHandSideExpression++ LeftHandSideExpression--              It is an early Reference Error if IsValidSimpleAssignmentTarget of LeftHandSideExpression is false.                     UpdateExpression:++UnaryExpression --UnaryExpression              It is an early Reference Error if IsValidSimpleAssignmentTarget of UnaryExpression is false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.4.2">
	<buginformation>
		<summary>Static Semantics: IsFunctionDefinition</summary>
		<description>UpdateExpression:LeftHandSideExpression++ LeftHandSideExpression-- ++UnaryExpression --UnaryExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.4.3">
	<buginformation>
		<summary>Static Semantics: IsValidSimpleAssignmentTarget</summary>
		<description>UpdateExpression:LeftHandSideExpression++ LeftHandSideExpression-- ++UnaryExpression --UnaryExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.4.4.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>UpdateExpression:LeftHandSideExpression++  Let lhs be the result of evaluating LeftHandSideExpression.Let oldValue be ? ToNumber(? GetValue(lhs)).Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator (see 12.8.5).Perform ? PutValue(lhs, newValue).Return oldValue.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.4.5.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>UpdateExpression:LeftHandSideExpression--  Let lhs be the result of evaluating LeftHandSideExpression.Let oldValue be ? ToNumber(? GetValue(lhs)).Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the - operator (see 12.8.5).Perform ? PutValue(lhs, newValue).Return oldValue.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.4.6.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>UpdateExpression:++UnaryExpression  Let expr be the result of evaluating UnaryExpression.Let oldValue be ? ToNumber(? GetValue(expr)).Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator (see 12.8.5).Perform ? PutValue(expr, newValue).Return newValue.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.4.7.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>UpdateExpression:--UnaryExpression  Let expr be the result of evaluating UnaryExpression.Let oldValue be ? ToNumber(? GetValue(expr)).Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the - operator (see 12.8.5).Perform ? PutValue(expr, newValue).Return newValue.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.5.1">
	<buginformation>
		<summary>Static Semantics: IsFunctionDefinition</summary>
		<description>UnaryExpression:deleteUnaryExpression voidUnaryExpression typeofUnaryExpression +UnaryExpression -UnaryExpression ~UnaryExpression !UnaryExpression AwaitExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.5.2">
	<buginformation>
		<summary>Static Semantics: IsValidSimpleAssignmentTarget</summary>
		<description>UnaryExpression:deleteUnaryExpression voidUnaryExpression typeofUnaryExpression +UnaryExpression -UnaryExpression ~UnaryExpression !UnaryExpression AwaitExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.5.3.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>UnaryExpression:deleteUnaryExpression                It is a Syntax Error if the UnaryExpression is contained in strict mode code and the derived UnaryExpression is   PrimaryExpression:IdentifierReference .                        It is a Syntax Error if the derived UnaryExpression is                                PrimaryExpression:CoverParenthesizedExpressionAndArrowParameterList                 and CoverParenthesizedExpressionAndArrowParameterList ultimately derives a phrase that, if used in place of UnaryExpression, would produce a Syntax Error according to these rules. This rule is recursively applied.   Note The last rule means that expressions such as delete (((foo))) produce early errors because of recursive application of the first rule.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.5.3.2">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>UnaryExpression:deleteUnaryExpression  Let ref be the result of evaluating UnaryExpression.ReturnIfAbrupt(ref).If Type(ref) is not Reference, return true.If IsUnresolvableReference(ref) is true, thenAssert: IsStrictReference(ref) is false.Return true.If IsPropertyReference(ref) is true, thenIf IsSuperReference(ref) is true, throw a ReferenceError exception.Let baseObj be ! ToObject(GetBase(ref)).Let deleteStatus be ? baseObj.[[Delete]](GetReferencedName(ref)).If deleteStatus is false and IsStrictReference(ref) is true, throw a TypeError exception.Return deleteStatus.Else ref is a Reference to an Environment Record binding,Let bindings be GetBase(ref).Return ? bindings.DeleteBinding(GetReferencedName(ref)).          Note When a delete operator occurs within strict mode code, a SyntaxError exception is thrown if its UnaryExpression is a direct reference to a variable, function argument, or function name. In addition, if a delete operator occurs within strict mode code and the property to be deleted has the attribute { [[Configurable]]: false }, a TypeError exception is thrown.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.5.4.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>UnaryExpression:voidUnaryExpression  Let expr be the result of evaluating UnaryExpression.Perform ? GetValue(expr).Return undefined.          Note GetValue must be called even though its value is not used because it may have observable side-effects.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.5.5.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>UnaryExpression:typeofUnaryExpression  Let val be the result of evaluating UnaryExpression.If Type(val) is Reference, thenIf IsUnresolvableReference(val) is true, return &amp;quot;undefined&amp;quot;.Set val to ? GetValue(val).Return a String according to Table 35.          Table 35: typeof Operator Results                     Type of val                   Result                                                  Undefined                                &amp;quot;undefined&amp;quot;                     Null                                &amp;quot;object&amp;quot;                     Boolean                                &amp;quot;boolean&amp;quot;                     Number                                &amp;quot;number&amp;quot;                     String                                &amp;quot;string&amp;quot;                     Symbol                                &amp;quot;symbol&amp;quot;                     Object (ordinary and does not implement [[Call]])                                &amp;quot;object&amp;quot;                     Object (standard exotic and does not implement [[Call]])                                &amp;quot;object&amp;quot;                     Object (implements [[Call]])                                &amp;quot;function&amp;quot;                     Object (non-standard exotic and does not implement [[Call]])                                                Implementation-defined. Must not be &amp;quot;undefined&amp;quot;, &amp;quot;boolean&amp;quot;, &amp;quot;function&amp;quot;, &amp;quot;number&amp;quot;, &amp;quot;symbol&amp;quot;, or &amp;quot;string&amp;quot;.                                   Note Implementations are discouraged from defining new typeof result values for non-standard exotic objects. If possible &amp;quot;object&amp;quot; should be used for such objects.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.5.6.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>UnaryExpression:+UnaryExpression  Let expr be the result of evaluating UnaryExpression.Return ? ToNumber(? GetValue(expr)).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.5.7.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>UnaryExpression:-UnaryExpression  Let expr be the result of evaluating UnaryExpression.Let oldValue be ? ToNumber(? GetValue(expr)).If oldValue is NaN, return NaN.Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite sign.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.5.8.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>UnaryExpression:~UnaryExpression  Let expr be the result of evaluating UnaryExpression.Let oldValue be ? ToInt32(? GetValue(expr)).Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.5.9.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>UnaryExpression:!UnaryExpression  Let expr be the result of evaluating UnaryExpression.Let oldValue be ToBoolean(? GetValue(expr)).If oldValue is true, return false.Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.6.1">
	<buginformation>
		<summary>Static Semantics: IsFunctionDefinition</summary>
		<description>ExponentiationExpression:UpdateExpression**ExponentiationExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.6.2">
	<buginformation>
		<summary>Static Semantics: IsValidSimpleAssignmentTarget</summary>
		<description>ExponentiationExpression:UpdateExpression**ExponentiationExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.6.3">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>ExponentiationExpression:UpdateExpression**ExponentiationExpression  Let left be the result of evaluating UpdateExpression.Let leftValue be ? GetValue(left).Let right be the result of evaluating ExponentiationExpression.Let rightValue be ? GetValue(right).Let base be ? ToNumber(leftValue).Let exponent be ? ToNumber(rightValue).Return the result of Applying the ** operator with base and exponent as specified in 12.6.4.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.6.4">
	<buginformation>
		<summary>Applying the ** Operator</summary>
		<description>Returns an implementation-dependent approximation of the result of raising base to the power exponent.                If exponent is NaN, the result is NaN. If exponent is +0, the result is 1, even if base is NaN. If exponent is -0, the result is 1, even if base is NaN. If base is NaN and exponent is nonzero, the result is NaN. If abs(base) &gt; 1 and exponent is +∞, the result is +∞. If abs(base) &gt; 1 and exponent is -∞, the result is +0. If abs(base) is 1 and exponent is +∞, the result is NaN. If abs(base) is 1 and exponent is -∞, the result is NaN. If abs(base) &lt; 1 and exponent is +∞, the result is +0. If abs(base) &lt; 1 and exponent is -∞, the result is +∞. If base is +∞ and exponent &gt; 0, the result is +∞. If base is +∞ and exponent &lt; 0, the result is +0. If base is -∞ and exponent &gt; 0 and exponent is an odd integer, the result is -∞. If base is -∞ and exponent &gt; 0 and exponent is not an odd integer, the result is +∞. If base is -∞ and exponent &lt; 0 and exponent is an odd integer, the result is -0. If base is -∞ and exponent &lt; 0 and exponent is not an odd integer, the result is +0. If base is +0 and exponent &gt; 0, the result is +0. If base is +0 and exponent &lt; 0, the result is +∞. If base is -0 and exponent &gt; 0 and exponent is an odd integer, the result is -0. If base is -0 and exponent &gt; 0 and exponent is not an odd integer, the result is +0. If base is -0 and exponent &lt; 0 and exponent is an odd integer, the result is -∞. If base is -0 and exponent &lt; 0 and exponent is not an odd integer, the result is +∞. If base &lt; 0 and base is finite and exponent is finite and exponent is not an integer, the result is NaN.  Note The result of base ** exponent when base is 1 or -1 and exponent is +Infinity or -Infinity differs from IEEE 754-2008. The first edition of ECMAScript specified a result of NaN for this operation, whereas later versions of IEEE 754-2008 specified 1. The historical ECMAScript behaviour is preserved for compatibility reasons.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.7.1">
	<buginformation>
		<summary>Static Semantics: IsFunctionDefinition</summary>
		<description>MultiplicativeExpression:MultiplicativeExpressionMultiplicativeOperatorExponentiationExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.7.2">
	<buginformation>
		<summary>Static Semantics: IsValidSimpleAssignmentTarget</summary>
		<description>MultiplicativeExpression:MultiplicativeExpressionMultiplicativeOperatorExponentiationExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.7.3.1">
	<buginformation>
		<summary>Applying the * Operator</summary>
		<description>The * MultiplicativeOperator  performs multiplication, producing the product of its operands.  Multiplication is commutative. Multiplication is not always associative  in ECMAScript, because of finite precision. The result of a floating-point multiplication is governed by the rules of IEEE 754-2008 binary double-precision arithmetic:               If either operand is NaN, the result is NaN.                                    The sign of the result is positive if both operands have the  same sign, negative if the operands have different signs.                                    Multiplication of an infinity by a zero results in NaN.                                    Multiplication of an infinity by an infinity results in an  infinity. The sign is determined by the rule already stated above.                                    Multiplication of an infinity by a finite nonzero value  results in a signed infinity. The sign is determined by the rule already  stated above.                                    In the remaining cases, where neither an infinity nor NaN  is involved, the product is computed and rounded to the nearest  representable value using IEEE 754-2008 round to nearest, ties to even  mode. If the magnitude is too large to represent, the result is then an  infinity of appropriate sign. If the magnitude is too small to  represent, the result is then a zero of appropriate sign. The ECMAScript  language requires support of gradual underflow as defined by IEEE  754-2008.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.7.3.2">
	<buginformation>
		<summary>Applying the / Operator</summary>
		<description>The / MultiplicativeOperator  performs division, producing the quotient of its operands. The left  operand is the dividend and the right operand is the divisor. ECMAScript  does not perform integer division. The operands and result of all  division operations are double-precision floating-point numbers. The  result of division is determined by the specification of IEEE 754-2008  arithmetic:               If either operand is NaN, the result is NaN.                                    The sign of the result is positive if both operands have the  same sign, negative if the operands have different signs.                                    Division of an infinity by an infinity results in NaN.                                    Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated above.                                    Division of an infinity by a nonzero finite value results in  a signed infinity. The sign is determined by the rule already stated  above.                                    Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated above.                                    Division of a zero by a zero results in NaN; division of zero by any other finite value results in zero, with the sign determined by the rule already stated above.                                    Division of a nonzero finite value by a zero results in a  signed infinity. The sign is determined by the rule already stated  above.                                    In the remaining cases, where neither an infinity, nor a zero, nor NaN  is involved, the quotient is computed and rounded to the nearest  representable value using IEEE 754-2008 round to nearest, ties to even  mode. If the magnitude is too large to represent, the operation  overflows; the result is then an infinity of appropriate sign. If the  magnitude is too small to represent, the operation underflows and the  result is a zero of the appropriate sign. The ECMAScript language  requires support of gradual underflow as defined by IEEE 754-2008.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.7.3.3">
	<buginformation>
		<summary>Applying the % Operator</summary>
		<description>The % MultiplicativeOperator  yields the remainder of its operands from an implied division; the left  operand is the dividend and the right operand is the divisor. Note In C and C++, the remainder operator accepts only integral operands; in ECMAScript, it also accepts floating-point operands.  The result of a floating-point remainder operation as computed by the %  operator is not the same as the “remainder” operation defined by IEEE  754-2008. The IEEE 754-2008 “remainder” operation computes the remainder  from a rounding division, not a truncating division, and so its  behaviour is not analogous to that of the usual integer remainder  operator. Instead the ECMAScript language defines % on  floating-point operations to behave in a manner analogous to that of the  Java integer remainder operator; this may be compared with the C  library function fmod. The result of an ECMAScript floating-point remainder operation is determined by the rules of IEEE arithmetic:               If either operand is NaN, the result is NaN.                                    The sign of the result equals the sign of the dividend.                                    If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.                                    If the dividend is finite and the divisor is an infinity, the result equals the dividend.                                    If the dividend is a zero and the divisor is nonzero and finite, the result is the same as the dividend.                                    In the remaining cases, where neither an infinity, nor a zero, nor NaN  is involved, the floating-point remainder r from a dividend n and a  divisor d is defined by the mathematical relation r</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.8.1">
	<buginformation>
		<summary>Static Semantics: IsFunctionDefinition</summary>
		<description>AdditiveExpression:AdditiveExpression+MultiplicativeExpression AdditiveExpression-MultiplicativeExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.8.2">
	<buginformation>
		<summary>Static Semantics: IsValidSimpleAssignmentTarget</summary>
		<description>AdditiveExpression:AdditiveExpression+MultiplicativeExpression AdditiveExpression-MultiplicativeExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.8.3.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>AdditiveExpression:AdditiveExpression+MultiplicativeExpression  Let lref be the result of evaluating AdditiveExpression.Let lval be ? GetValue(lref).Let rref be the result of evaluating MultiplicativeExpression.Let rval be ? GetValue(rref).Let lprim be ? ToPrimitive(lval).Let rprim be ? ToPrimitive(rval).If Type(lprim) is String or Type(rprim) is String, thenLet lstr be ? ToString(lprim).Let rstr be ? ToString(rprim).Return the String that is the result of concatenating lstr and rstr.Let lnum be ? ToNumber(lprim).Let rnum be ? ToNumber(rprim).Return the result of applying the addition operation to lnum and rnum. See the Note below 12.8.5.          Note 1 No hint is provided in the calls to ToPrimitive  in steps 5 and 6. All standard objects except Date objects handle the  absence of a hint as if the hint Number were given; Date objects handle  the absence of a hint as if the hint String were given. Exotic objects  may handle the absence of a hint in some other manner.  Note 2 Step 7 differs from step 3 of the Abstract Relational Comparison algorithm, by using the logical-or operation instead of the logical-and operation.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.8.4.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>AdditiveExpression:AdditiveExpression-MultiplicativeExpression  Let lref be the result of evaluating AdditiveExpression.Let lval be ? GetValue(lref).Let rref be the result of evaluating MultiplicativeExpression.Let rval be ? GetValue(rref).Let lnum be ? ToNumber(lval).Let rnum be ? ToNumber(rval).Return the result of applying the subtraction operation to lnum and rnum. See the note below 12.8.5.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.8.5">
	<buginformation>
		<summary>Applying the Additive Operators to Numbers</summary>
		<description>The + operator performs addition when applied to two operands of numeric type, producing the sum of the operands. The - operator performs subtraction, producing the difference of two numeric operands. Addition is a commutative operation, but not always associative. The result of an addition is determined using the rules of IEEE 754-2008 binary double-precision arithmetic:             If either operand is NaN, the result is NaN.                              The sum of two infinities of opposite sign is NaN.                              The sum of two infinities of the same sign is the infinity of that sign.                              The sum of an infinity and a finite value is equal to the infinite operand.                              The sum of two negative zeroes is -0. The sum of two positive zeroes, or of two zeroes of opposite sign, is +0.                              The sum of a zero and a nonzero finite value is equal to the nonzero operand.                              The sum of two nonzero finite values of the same magnitude and opposite sign is +0.                              In the remaining cases, where neither an infinity, nor a zero, nor NaN  is involved, and the operands have the same sign or have different  magnitudes, the sum is computed and rounded to the nearest representable  value using IEEE 754-2008 round to nearest, ties to even mode. If the  magnitude is too large to represent, the operation overflows and the  result is then an infinity of appropriate sign. The ECMAScript language  requires support of gradual underflow as defined by IEEE 754-2008.                    Note The - operator performs subtraction when applied  to two operands of numeric type, producing the difference of its  operands; the left operand is the minuend and the right operand is the  subtrahend. Given numeric operands a and b, it is always the case that a-b produces the same result as a+(-b).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.9.1">
	<buginformation>
		<summary>Static Semantics: IsFunctionDefinition</summary>
		<description>ShiftExpression:ShiftExpression&lt;&lt;AdditiveExpression ShiftExpression&gt;&gt;AdditiveExpression ShiftExpression&gt;&gt;&gt;AdditiveExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.9.2">
	<buginformation>
		<summary>Static Semantics: IsValidSimpleAssignmentTarget</summary>
		<description>ShiftExpression:ShiftExpression&lt;&lt;AdditiveExpression ShiftExpression&gt;&gt;AdditiveExpression ShiftExpression&gt;&gt;&gt;AdditiveExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.9.3.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>ShiftExpression:ShiftExpression&lt;&lt;AdditiveExpression  Let lref be the result of evaluating ShiftExpression.Let lval be ? GetValue(lref).Let rref be the result of evaluating AdditiveExpression.Let rval be ? GetValue(rref).Let lnum be ? ToInt32(lval).Let rnum be ? ToUint32(rval).Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum &amp; 0x1F.Return the result of left shifting lnum by shiftCount bits. The result is a signed 32-bit integer.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.9.4.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>ShiftExpression:ShiftExpression&gt;&gt;AdditiveExpression  Let lref be the result of evaluating ShiftExpression.Let lval be ? GetValue(lref).Let rref be the result of evaluating AdditiveExpression.Let rval be ? GetValue(rref).Let lnum be ? ToInt32(lval).Let rnum be ? ToUint32(rval).Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum &amp; 0x1F.Return the result of performing a sign-extending right shift of lnum by shiftCount bits. The most significant bit is propagated. The result is a signed 32-bit integer.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.9.5.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>ShiftExpression:ShiftExpression&gt;&gt;&gt;AdditiveExpression  Let lref be the result of evaluating ShiftExpression.Let lval be ? GetValue(lref).Let rref be the result of evaluating AdditiveExpression.Let rval be ? GetValue(rref).Let lnum be ? ToUint32(lval).Let rnum be ? ToUint32(rval).Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum &amp; 0x1F.Return the result of performing a zero-filling right shift of lnum by shiftCount bits. Vacated bits are filled with zero. The result is an unsigned 32-bit integer.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.10.1">
	<buginformation>
		<summary>Static Semantics: IsFunctionDefinition</summary>
		<description>RelationalExpression:RelationalExpression&lt;ShiftExpression RelationalExpression&gt;ShiftExpression RelationalExpression&lt;</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.10.2">
	<buginformation>
		<summary>Static Semantics: IsValidSimpleAssignmentTarget</summary>
		<description>RelationalExpression:RelationalExpression&lt;ShiftExpression RelationalExpression&gt;ShiftExpression RelationalExpression&lt;</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.10.3">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>RelationalExpression:RelationalExpression&lt;ShiftExpression  Let lref be the result of evaluating RelationalExpression.Let lval be ? GetValue(lref).Let rref be the result of evaluating ShiftExpression.Let rval be ? GetValue(rref).Let r be the result of performing Abstract Relational Comparison lval &lt; rval.ReturnIfAbrupt(r).If r is undefined, return false. Otherwise, return r.         RelationalExpression:RelationalExpression&gt;ShiftExpression  Let lref be the result of evaluating RelationalExpression.Let lval be ? GetValue(lref).Let rref be the result of evaluating ShiftExpression.Let rval be ? GetValue(rref).Let r be the result of performing Abstract Relational Comparison rval &lt; lval with LeftFirst equal to false.ReturnIfAbrupt(r).If r is undefined, return false. Otherwise, return r.         RelationalExpression:RelationalExpression&lt;</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.10.4">
	<buginformation>
		<summary>Runtime Semantics: InstanceofOperator ( O, C )</summary>
		<description>The abstract operation InstanceofOperator(O, C) implements the generic algorithm for determining if an object O inherits from the inheritance path defined by constructor C. This abstract operation performs the following steps: If Type(C) is not Object, throw a TypeError exception.Let instOfHandler be ? GetMethod(C, @@hasInstance).If instOfHandler is not undefined, thenReturn ToBoolean(? Call(instOfHandler, C, « O »)).If IsCallable(C) is false, throw a TypeError exception.Return ? OrdinaryHasInstance(C, O).        Note Steps 4 and 5 provide compatibility with previous editions of ECMAScript that did not use a @@hasInstance method to define the instanceof operator semantics. If a function object does not define or inherit @@hasInstance it uses the default instanceof semantics.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.11.1">
	<buginformation>
		<summary>Static Semantics: IsFunctionDefinition</summary>
		<description>EqualityExpression:EqualityExpression</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.11.2">
	<buginformation>
		<summary>Static Semantics: IsValidSimpleAssignmentTarget</summary>
		<description>EqualityExpression:EqualityExpression</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.11.3">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>EqualityExpression:EqualityExpression</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.12.1">
	<buginformation>
		<summary>Static Semantics: IsFunctionDefinition</summary>
		<description>BitwiseANDExpression:BitwiseANDExpression&amp;EqualityExpression   BitwiseXORExpression:BitwiseXORExpression^BitwiseANDExpression   BitwiseORExpression:BitwiseORExpression|BitwiseXORExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.12.2">
	<buginformation>
		<summary>Static Semantics: IsValidSimpleAssignmentTarget</summary>
		<description>BitwiseANDExpression:BitwiseANDExpression&amp;EqualityExpression   BitwiseXORExpression:BitwiseXORExpression^BitwiseANDExpression   BitwiseORExpression:BitwiseORExpression|BitwiseXORExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.12.3">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>The production   A:A@B , where @ is one of the bitwise operators in the productions above, is evaluated as follows: Let lref be the result of evaluating A.Let lval be ? GetValue(lref).Let rref be the result of evaluating B.Let rval be ? GetValue(rref).Let lnum be ? ToInt32(lval).Let rnum be ? ToInt32(rval).Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32-bit integer.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.13.1">
	<buginformation>
		<summary>Static Semantics: IsFunctionDefinition</summary>
		<description>LogicalANDExpression:LogicalANDExpression&amp;&amp;BitwiseORExpression   LogicalORExpression:LogicalORExpression||LogicalANDExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.13.2">
	<buginformation>
		<summary>Static Semantics: IsValidSimpleAssignmentTarget</summary>
		<description>LogicalANDExpression:LogicalANDExpression&amp;&amp;BitwiseORExpression   LogicalORExpression:LogicalORExpression||LogicalANDExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.13.3">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>LogicalANDExpression:LogicalANDExpression&amp;&amp;BitwiseORExpression  Let lref be the result of evaluating LogicalANDExpression.Let lval be ? GetValue(lref).Let lbool be ToBoolean(lval).If lbool is false, return lval.Let rref be the result of evaluating BitwiseORExpression.Return ? GetValue(rref).         LogicalORExpression:LogicalORExpression||LogicalANDExpression  Let lref be the result of evaluating LogicalORExpression.Let lval be ? GetValue(lref).Let lbool be ToBoolean(lval).If lbool is true, return lval.Let rref be the result of evaluating LogicalANDExpression.Return ? GetValue(rref).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.14.1">
	<buginformation>
		<summary>Static Semantics: IsFunctionDefinition</summary>
		<description>ConditionalExpression:LogicalORExpression?AssignmentExpression:AssignmentExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.14.2">
	<buginformation>
		<summary>Static Semantics: IsValidSimpleAssignmentTarget</summary>
		<description>ConditionalExpression:LogicalORExpression?AssignmentExpression:AssignmentExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.14.3">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>ConditionalExpression:LogicalORExpression?AssignmentExpression:AssignmentExpression  Let lref be the result of evaluating LogicalORExpression.Let lval be ToBoolean(? GetValue(lref)).If lval is true, thenLet trueRef be the result of evaluating the first AssignmentExpression.Return ? GetValue(trueRef).Else,Let falseRef be the result of evaluating the second AssignmentExpression.Return ? GetValue(falseRef).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.15.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>AssignmentExpression:LeftHandSideExpression</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.15.2">
	<buginformation>
		<summary>Static Semantics: IsFunctionDefinition</summary>
		<description>AssignmentExpression:ArrowFunction AsyncArrowFunction  Return true.         AssignmentExpression:YieldExpression LeftHandSideExpression</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.15.3">
	<buginformation>
		<summary>Static Semantics: IsValidSimpleAssignmentTarget</summary>
		<description>AssignmentExpression:YieldExpression ArrowFunction AsyncArrowFunction LeftHandSideExpression</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.15.4">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>AssignmentExpression[In, Yield, Await]:LeftHandSideExpression[?Yield, ?Await]</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.15.5.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>AssignmentProperty:IdentifierReferenceInitializeropt                It is a Syntax Error if IsValidSimpleAssignmentTarget of IdentifierReference is false.                         DestructuringAssignmentTarget:LeftHandSideExpression                It is a Syntax Error if LeftHandSideExpression is either an ObjectLiteral or an ArrayLiteral and if the lexical token sequence matched by LeftHandSideExpression cannot be parsed with no tokens left over using AssignmentPattern as the goal symbol.                                    It is a Syntax Error if LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral and IsValidSimpleAssignmentTarget(LeftHandSideExpression) is false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.15.5.2">
	<buginformation>
		<summary>Runtime Semantics: DestructuringAssignmentEvaluation</summary>
		<description>With parameter value.  ObjectAssignmentPattern:{}  Perform ? RequireObjectCoercible(value).Return NormalCompletion(empty).           ObjectAssignmentPattern:{AssignmentPropertyList} {AssignmentPropertyList,}  Perform ? RequireObjectCoercible(value).Return the result of performing DestructuringAssignmentEvaluation for AssignmentPropertyList using value as the argument.           ArrayAssignmentPattern:[]  Let iterator be ? GetIterator(value).Return ? IteratorClose(iterator, NormalCompletion(empty)).           ArrayAssignmentPattern:[Elision]  Let iterator be ? GetIterator(value).Let iteratorRecord be Record {[[Iterator]]: iterator, [[Done]]: false}.Let result be the result of performing IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).Return result.           ArrayAssignmentPattern:[ElisionoptAssignmentRestElement]  Let iterator be ? GetIterator(value).Let iteratorRecord be Record {[[Iterator]]: iterator, [[Done]]: false}.If Elision is present, thenLet status be the result of performing IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.NOTE: In the event of an abrupt completion, the above IteratorDestructuringAssignmentEvaluation will always set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(status).Let result be the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentRestElement with iteratorRecord as the argument.If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).Return result.           ArrayAssignmentPattern:[AssignmentElementList]  Let iterator be ? GetIterator(value).Let iteratorRecord be Record {[[Iterator]]: iterator, [[Done]]: false}.Let result be the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentElementList using iteratorRecord as the argument.If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).Return result.           ArrayAssignmentPattern:[AssignmentElementList,ElisionoptAssignmentRestElementopt]  Let iterator be ? GetIterator(value).Let iteratorRecord be Record {[[Iterator]]: iterator, [[Done]]: false}.Let status be the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentElementList using iteratorRecord as the argument.If status is an abrupt completion, thenIf iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, status).Return Completion(status).If Elision is present, thenSet status to the result of performing IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.NOTE: In the event of an abrupt completion, the above IteratorDestructuringAssignmentEvaluation will always set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(status).If AssignmentRestElement is present, thenSet status to the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentRestElement with iteratorRecord as the argument.If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, status).Return Completion(status).           AssignmentPropertyList:AssignmentPropertyList,AssignmentProperty  Let status be the result of performing DestructuringAssignmentEvaluation for AssignmentPropertyList using value as the argument.ReturnIfAbrupt(status).Return the result of performing DestructuringAssignmentEvaluation for AssignmentProperty using value as the argument.           AssignmentProperty:IdentifierReferenceInitializeropt  Let P be StringValue of IdentifierReference.Let lref be ? ResolveBinding(P).Let v be ? GetV(value, P).If Initializeropt is present and v is undefined, thenLet defaultValue be the result of evaluating Initializer.Set v to ? GetValue(defaultValue).If IsAnonymousFunctionDefinition(Initializer) is true, thenLet hasNameProperty be ? HasOwnProperty(v, &amp;quot;name&amp;quot;).If hasNameProperty is false, perform SetFunctionName(v, P).Return ? PutValue(lref, v).           AssignmentProperty:PropertyName:AssignmentElement  Let name be the result of evaluating PropertyName.ReturnIfAbrupt(name).Return the result of performing KeyedDestructuringAssignmentEvaluation of AssignmentElement with value and name as the arguments.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.15.5.3">
	<buginformation>
		<summary>Runtime Semantics: IteratorDestructuringAssignmentEvaluation</summary>
		<description>With parameter iteratorRecord.  AssignmentElementList:AssignmentElisionElement  Return the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentElisionElement using iteratorRecord as the argument.           AssignmentElementList:AssignmentElementList,AssignmentElisionElement  Let status be the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentElementList using iteratorRecord as the argument.ReturnIfAbrupt(status).Return the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentElisionElement using iteratorRecord as the argument.           AssignmentElisionElement:AssignmentElement  Return the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentElement with iteratorRecord as the argument.           AssignmentElisionElement:ElisionAssignmentElement  Let status be the result of performing IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.ReturnIfAbrupt(status).Return the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentElement with iteratorRecord as the argument.           Elision:,  If iteratorRecord.[[Done]] is false, thenLet next be IteratorStep(iteratorRecord.[[Iterator]]).If next is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(next).If next is false, set iteratorRecord.[[Done]] to true.Return NormalCompletion(empty).           Elision:Elision,  Let status be the result of performing IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.ReturnIfAbrupt(status).If iteratorRecord.[[Done]] is false, thenLet next be IteratorStep(iteratorRecord.[[Iterator]]).If next is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(next).If next is false, set iteratorRecord.[[Done]] to true.Return NormalCompletion(empty).           AssignmentElement[Yield, Await]:DestructuringAssignmentTargetInitializeropt  If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, thenLet lref be the result of evaluating DestructuringAssignmentTarget.ReturnIfAbrupt(lref).If iteratorRecord.[[Done]] is false, thenLet next be IteratorStep(iteratorRecord.[[Iterator]]).If next is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(next).If next is false, set iteratorRecord.[[Done]] to true.Else,Let value be IteratorValue(next).If value is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(value).If iteratorRecord.[[Done]] is true, let value be undefined.If Initializer is present and value is undefined, thenLet defaultValue be the result of evaluating Initializer.Let v be ? GetValue(defaultValue).Else, let v be value.If DestructuringAssignmentTarget is an ObjectLiteral or an ArrayLiteral, thenLet nestedAssignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using AssignmentPattern as the goal symbol with its [Yield] and [Await] parameters set to the values used when parsing this DestructuringAssignmentTarget.Return the result of performing DestructuringAssignmentEvaluation of nestedAssignmentPattern with v as the argument.If Initializer is present and value is undefined and IsAnonymousFunctionDefinition(Initializer) and IsIdentifierRef of DestructuringAssignmentTarget are both true, thenLet hasNameProperty be ? HasOwnProperty(v, &amp;quot;name&amp;quot;).If hasNameProperty is false, perform SetFunctionName(v, GetReferencedName(lref)).Return ? PutValue(lref, v).          Note Left to right evaluation order is maintained by evaluating a DestructuringAssignmentTarget that is not a destructuring pattern prior to accessing the iterator or evaluating the Initializer.   AssignmentRestElement[Yield, Await]:...DestructuringAssignmentTarget  If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, thenLet lref be the result of evaluating DestructuringAssignmentTarget.ReturnIfAbrupt(lref).Let A be ! ArrayCreate(0).Let n be 0.Repeat, while iteratorRecord.[[Done]] is false,Let next be IteratorStep(iteratorRecord.[[Iterator]]).If next is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(next).If next is false, set iteratorRecord.[[Done]] to true.Else,Let nextValue be IteratorValue(next).If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(nextValue).Let status be CreateDataProperty(A, ! ToString(n), nextValue).Assert: status is true.Increment n by 1.If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, thenReturn ? PutValue(lref, A).Let nestedAssignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using AssignmentPattern as the goal symbol with its [Yield] and [Await] parameters set to the values used when parsing this AssignmentRestElement.Return the result of performing DestructuringAssignmentEvaluation of nestedAssignmentPattern with A as the argument.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.15.5.4">
	<buginformation>
		<summary>Runtime Semantics: KeyedDestructuringAssignmentEvaluation</summary>
		<description>With parameters value and propertyName.  AssignmentElement[Yield, Await]:DestructuringAssignmentTargetInitializeropt  If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, thenLet lref be the result of evaluating DestructuringAssignmentTarget.ReturnIfAbrupt(lref).Let v be ? GetV(value, propertyName).If Initializer is present and v is undefined, thenLet defaultValue be the result of evaluating Initializer.Let rhsValue be ? GetValue(defaultValue).Else, let rhsValue be v.If DestructuringAssignmentTarget is an ObjectLiteral or an ArrayLiteral, thenLet assignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using AssignmentPattern as the goal symbol with its [Yield] and [Await] parameters set to the values used when parsing this DestructuringAssignmentTarget.Return the result of performing DestructuringAssignmentEvaluation of assignmentPattern with rhsValue as the argument.If Initializer is present and v is undefined and IsAnonymousFunctionDefinition(Initializer) and IsIdentifierRef of DestructuringAssignmentTarget are both true, thenLet hasNameProperty be ? HasOwnProperty(rhsValue, &amp;quot;name&amp;quot;).If hasNameProperty is false, perform SetFunctionName(rhsValue, GetReferencedName(lref)).Return ? PutValue(lref, rhsValue).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.16.1">
	<buginformation>
		<summary>Static Semantics: IsFunctionDefinition</summary>
		<description>Expression:Expression,AssignmentExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.16.2">
	<buginformation>
		<summary>Static Semantics: IsValidSimpleAssignmentTarget</summary>
		<description>Expression:Expression,AssignmentExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="12.16.3">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>Expression:Expression,AssignmentExpression  Let lref be the result of evaluating Expression.Perform ? GetValue(lref).Let rref be the result of evaluating AssignmentExpression.Return ? GetValue(rref).        Note GetValue must be called even though its value is not used because it may have observable side-effects.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.1.1">
	<buginformation>
		<summary>Static Semantics: ContainsDuplicateLabels</summary>
		<description>With parameter labelSet.   Statement:VariableStatement EmptyStatement ExpressionStatement ContinueStatement BreakStatement ReturnStatement ThrowStatement DebuggerStatement  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.1.2">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedBreakTarget</summary>
		<description>With parameter labelSet.   Statement:VariableStatement EmptyStatement ExpressionStatement ContinueStatement ReturnStatement ThrowStatement DebuggerStatement  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.1.3">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedContinueTarget</summary>
		<description>With parameters iterationSet and labelSet.   Statement:VariableStatement EmptyStatement ExpressionStatement BreakStatement ReturnStatement ThrowStatement DebuggerStatement  Return false.         BreakableStatement:IterationStatement  Let newIterationSet be a copy of iterationSet with all the elements of labelSet appended.Return ContainsUndefinedContinueTarget of IterationStatement with arguments newIterationSet and « ».</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.1.4">
	<buginformation>
		<summary>Static Semantics: DeclarationPart</summary>
		<description>HoistableDeclaration:FunctionDeclaration  Return FunctionDeclaration.         HoistableDeclaration:GeneratorDeclaration  Return GeneratorDeclaration.         HoistableDeclaration:AsyncFunctionDeclaration  Return AsyncFunctionDeclaration.         Declaration:ClassDeclaration  Return ClassDeclaration.         Declaration:LexicalDeclaration  Return LexicalDeclaration.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.1.5">
	<buginformation>
		<summary>Static Semantics: VarDeclaredNames</summary>
		<description>Statement:EmptyStatement ExpressionStatement ContinueStatement BreakStatement ReturnStatement ThrowStatement DebuggerStatement  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.1.6">
	<buginformation>
		<summary>Static Semantics: VarScopedDeclarations</summary>
		<description>Statement:EmptyStatement ExpressionStatement ContinueStatement BreakStatement ReturnStatement ThrowStatement DebuggerStatement  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.1.7">
	<buginformation>
		<summary>Runtime Semantics: LabelledEvaluation</summary>
		<description>With parameter labelSet.   BreakableStatement:IterationStatement  Let stmtResult be the result of performing LabelledEvaluation of IterationStatement with argument labelSet.If stmtResult.[[Type]] is break, thenIf stmtResult.[[Target]] is empty, thenIf stmtResult.[[Value]] is empty, set stmtResult to NormalCompletion(undefined).Else, set stmtResult to NormalCompletion(stmtResult.[[Value]]).Return Completion(stmtResult).         BreakableStatement:SwitchStatement  Let stmtResult be the result of evaluating SwitchStatement.If stmtResult.[[Type]] is break, thenIf stmtResult.[[Target]] is empty, thenIf stmtResult.[[Value]] is empty, set stmtResult to NormalCompletion(undefined).Else, set stmtResult to NormalCompletion(stmtResult.[[Value]]).Return Completion(stmtResult).        Note A BreakableStatement is one that can be exited via an unlabelled BreakStatement.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.1.8">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>HoistableDeclaration:GeneratorDeclaration  Return NormalCompletion(empty).         HoistableDeclaration:AsyncFunctionDeclaration  Return NormalCompletion(empty).         HoistableDeclaration:FunctionDeclaration  Return the result of evaluating FunctionDeclaration.         BreakableStatement:IterationStatement SwitchStatement  Let newLabelSet be a new empty List.Return the result of performing LabelledEvaluation of this BreakableStatement with argument newLabelSet.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.2.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>Block:{StatementList}              It is a Syntax Error if the LexicallyDeclaredNames of StatementList contains any duplicate entries.                              It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList also occurs in the VarDeclaredNames of StatementList.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.2.2">
	<buginformation>
		<summary>Static Semantics: ContainsDuplicateLabels</summary>
		<description>With parameter labelSet.   Block:{}  Return false.         StatementList:StatementListStatementListItem  Let hasDuplicates be ContainsDuplicateLabels of StatementList with argument labelSet.If hasDuplicates is true, return true.Return ContainsDuplicateLabels of StatementListItem with argument labelSet.         StatementListItem:Declaration  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.2.3">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedBreakTarget</summary>
		<description>With parameter labelSet.   Block:{}  Return false.         StatementList:StatementListStatementListItem  Let hasUndefinedLabels be ContainsUndefinedBreakTarget of StatementList with argument labelSet.If hasUndefinedLabels is true, return true.Return ContainsUndefinedBreakTarget of StatementListItem with argument labelSet.         StatementListItem:Declaration  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.2.4">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedContinueTarget</summary>
		<description>With parameters iterationSet and labelSet.   Block:{}  Return false.         StatementList:StatementListStatementListItem  Let hasUndefinedLabels be ContainsUndefinedContinueTarget of StatementList with arguments iterationSet and « ».If hasUndefinedLabels is true, return true.Return ContainsUndefinedContinueTarget of StatementListItem with arguments iterationSet and « ».         StatementListItem:Declaration  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.2.5">
	<buginformation>
		<summary>Static Semantics: LexicallyDeclaredNames</summary>
		<description>Block:{}  Return a new empty List.         StatementList:StatementListStatementListItem  Let names be LexicallyDeclaredNames of StatementList.Append to names the elements of the LexicallyDeclaredNames of StatementListItem.Return names.         StatementListItem:Statement  If Statement is  Statement:LabelledStatement  , return LexicallyDeclaredNames of LabelledStatement.Return a new empty List.         StatementListItem:Declaration  Return the BoundNames of Declaration.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.2.6">
	<buginformation>
		<summary>Static Semantics: LexicallyScopedDeclarations</summary>
		<description>StatementList:StatementListStatementListItem  Let declarations be LexicallyScopedDeclarations of StatementList.Append to declarations the elements of the LexicallyScopedDeclarations of StatementListItem.Return declarations.         StatementListItem:Statement  If Statement is  Statement:LabelledStatement  , return LexicallyScopedDeclarations of LabelledStatement.Return a new empty List.         StatementListItem:Declaration  Return a new List containing DeclarationPart of Declaration.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.2.7">
	<buginformation>
		<summary>Static Semantics: TopLevelLexicallyDeclaredNames</summary>
		<description>StatementList:StatementListStatementListItem  Let names be TopLevelLexicallyDeclaredNames of StatementList.Append to names the elements of the TopLevelLexicallyDeclaredNames of StatementListItem.Return names.         StatementListItem:Statement  Return a new empty List.         StatementListItem:Declaration  If Declaration is  Declaration:HoistableDeclaration  , thenReturn « ».Return the BoundNames of Declaration.        Note At the top level of a function, or script, function  declarations are treated like var declarations rather than like lexical  declarations.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.2.8">
	<buginformation>
		<summary>Static Semantics: TopLevelLexicallyScopedDeclarations</summary>
		<description>Block:{}  Return a new empty List.         StatementList:StatementListStatementListItem  Let declarations be TopLevelLexicallyScopedDeclarations of StatementList.Append to declarations the elements of the TopLevelLexicallyScopedDeclarations of StatementListItem.Return declarations.         StatementListItem:Statement  Return a new empty List.         StatementListItem:Declaration  If Declaration is  Declaration:HoistableDeclaration  , thenReturn « ».Return a new List containing Declaration.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.2.9">
	<buginformation>
		<summary>Static Semantics: TopLevelVarDeclaredNames</summary>
		<description>Block:{}  Return a new empty List.         StatementList:StatementListStatementListItem  Let names be TopLevelVarDeclaredNames of StatementList.Append to names the elements of the TopLevelVarDeclaredNames of StatementListItem.Return names.         StatementListItem:Declaration  If Declaration is  Declaration:HoistableDeclaration  , thenReturn the BoundNames of HoistableDeclaration.Return a new empty List.         StatementListItem:Statement  If Statement is  Statement:LabelledStatement  , return TopLevelVarDeclaredNames of Statement.Return VarDeclaredNames of Statement.        Note At the top level of a function or script, inner function declarations are treated like var declarations.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.2.10">
	<buginformation>
		<summary>Static Semantics: TopLevelVarScopedDeclarations</summary>
		<description>Block:{}  Return a new empty List.         StatementList:StatementListStatementListItem  Let declarations be TopLevelVarScopedDeclarations of StatementList.Append to declarations the elements of the TopLevelVarScopedDeclarations of StatementListItem.Return declarations.         StatementListItem:Statement  If Statement is  Statement:LabelledStatement  , return TopLevelVarScopedDeclarations of Statement.Return VarScopedDeclarations of Statement.         StatementListItem:Declaration  If Declaration is  Declaration:HoistableDeclaration  , thenLet declaration be DeclarationPart of HoistableDeclaration.Return « declaration ».Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.2.11">
	<buginformation>
		<summary>Static Semantics: VarDeclaredNames</summary>
		<description>Block:{}  Return a new empty List.         StatementList:StatementListStatementListItem  Let names be VarDeclaredNames of StatementList.Append to names the elements of the VarDeclaredNames of StatementListItem.Return names.         StatementListItem:Declaration  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.2.12">
	<buginformation>
		<summary>Static Semantics: VarScopedDeclarations</summary>
		<description>Block:{}  Return a new empty List.         StatementList:StatementListStatementListItem  Let declarations be VarScopedDeclarations of StatementList.Append to declarations the elements of the VarScopedDeclarations of StatementListItem.Return declarations.         StatementListItem:Declaration  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.2.13">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>Block:{}  Return NormalCompletion(empty).         Block:{StatementList}  Let oldEnv be the running execution context&apos;s LexicalEnvironment.Let blockEnv be NewDeclarativeEnvironment(oldEnv).Perform BlockDeclarationInstantiation(StatementList, blockEnv).Set the running execution context&apos;s LexicalEnvironment to blockEnv.Let blockValue be the result of evaluating StatementList.Set the running execution context&apos;s LexicalEnvironment to oldEnv.Return blockValue.        Note 1 No matter how control leaves the Block the LexicalEnvironment is always restored to its former state.   StatementList:StatementListStatementListItem  Let sl be the result of evaluating StatementList.ReturnIfAbrupt(sl).Let s be the result of evaluating StatementListItem.Return Completion(UpdateEmpty(s, sl)).        Note 2 The value of a StatementList is the value of the last value producing item in the StatementList. For example, the following calls to the eval function all return the value 1: eval(&amp;quot;1;;;;;&amp;quot;) eval(&amp;quot;1;{}&amp;quot;) eval(&amp;quot;1;var a;&amp;quot;)</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.2.14">
	<buginformation>
		<summary>Runtime Semantics: BlockDeclarationInstantiation( code, env )</summary>
		<description>Note When a Block or CaseBlock is evaluated a new declarative Environment Record  is created and bindings for each block scoped variable, constant,  function, or class declared in the block are instantiated in the Environment Record.  BlockDeclarationInstantiation is performed as follows using arguments code and env. code is the Parse Node corresponding to the body of the block. env is the Lexical Environment in which bindings are to be created.  Let envRec be env&apos;s EnvironmentRecord.Assert: envRec is a declarative Environment Record.Let declarations be the LexicallyScopedDeclarations of code.For each element d in declarations, doFor each element dn of the BoundNames of d, doIf IsConstantDeclaration of d is true, thenPerform ! envRec.CreateImmutableBinding(dn, true).Else,Perform ! envRec.CreateMutableBinding(dn, false).If d is a FunctionDeclaration, a GeneratorDeclaration, or an AsyncFunctionDeclaration, thenLet fn be the sole element of the BoundNames of d.Let fo be the result of performing InstantiateFunctionObject for d with argument env.Perform envRec.InitializeBinding(fn, fo).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.3.1.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>LexicalDeclaration:LetOrConstBindingList;                It is a Syntax Error if the BoundNames of BindingList contains &amp;quot;let&amp;quot;.                                    It is a Syntax Error if the BoundNames of BindingList contains any duplicate entries.                         LexicalBinding:BindingIdentifierInitializeropt                It is a Syntax Error if Initializer is not present and IsConstantDeclaration of the LexicalDeclaration containing this LexicalBinding is true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.3.1.2">
	<buginformation>
		<summary>Static Semantics: BoundNames</summary>
		<description>LexicalDeclaration:LetOrConstBindingList;  Return the BoundNames of BindingList.           BindingList:BindingList,LexicalBinding  Let names be the BoundNames of BindingList.Append to names the elements of the BoundNames of LexicalBinding.Return names.           LexicalBinding:BindingIdentifierInitializeropt  Return the BoundNames of BindingIdentifier.           LexicalBinding:BindingPatternInitializer  Return the BoundNames of BindingPattern.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.3.1.3">
	<buginformation>
		<summary>Static Semantics: IsConstantDeclaration</summary>
		<description>LexicalDeclaration:LetOrConstBindingList;  Return IsConstantDeclaration of LetOrConst.           LetOrConst:let  Return false.           LetOrConst:const  Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.3.1.4">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>LexicalDeclaration:LetOrConstBindingList;  Let next be the result of evaluating BindingList.ReturnIfAbrupt(next).Return NormalCompletion(empty).           BindingList:BindingList,LexicalBinding  Let next be the result of evaluating BindingList.ReturnIfAbrupt(next).Return the result of evaluating LexicalBinding.           LexicalBinding:BindingIdentifier  Let lhs be ResolveBinding(StringValue of BindingIdentifier).Return InitializeReferencedBinding(lhs, undefined).          Note A static semantics rule ensures that this form of LexicalBinding never occurs in a const declaration.   LexicalBinding:BindingIdentifierInitializer  Let bindingId be StringValue of BindingIdentifier.Let lhs be ResolveBinding(bindingId).Let rhs be the result of evaluating Initializer.Let value be ? GetValue(rhs).If IsAnonymousFunctionDefinition(Initializer) is true, thenLet hasNameProperty be ? HasOwnProperty(value, &amp;quot;name&amp;quot;).If hasNameProperty is false, perform SetFunctionName(value, bindingId).Return InitializeReferencedBinding(lhs, value).           LexicalBinding:BindingPatternInitializer  Let rhs be the result of evaluating Initializer.Let value be ? GetValue(rhs).Let env be the running execution context&apos;s LexicalEnvironment.Return the result of performing BindingInitialization for BindingPattern using value and env as the arguments.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.3.2.1">
	<buginformation>
		<summary>Static Semantics: BoundNames</summary>
		<description>VariableDeclarationList:VariableDeclarationList,VariableDeclaration  Let names be BoundNames of VariableDeclarationList.Append to names the elements of BoundNames of VariableDeclaration.Return names.           VariableDeclaration:BindingIdentifierInitializeropt  Return the BoundNames of BindingIdentifier.           VariableDeclaration:BindingPatternInitializer  Return the BoundNames of BindingPattern.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.3.2.2">
	<buginformation>
		<summary>Static Semantics: VarDeclaredNames</summary>
		<description>VariableStatement:varVariableDeclarationList;  Return BoundNames of VariableDeclarationList.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.3.2.3">
	<buginformation>
		<summary>Static Semantics: VarScopedDeclarations</summary>
		<description>VariableDeclarationList:VariableDeclaration  Return a new List containing VariableDeclaration.           VariableDeclarationList:VariableDeclarationList,VariableDeclaration  Let declarations be VarScopedDeclarations of VariableDeclarationList.Append VariableDeclaration to declarations.Return declarations.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.3.2.4">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>VariableStatement:varVariableDeclarationList;  Let next be the result of evaluating VariableDeclarationList.ReturnIfAbrupt(next).Return NormalCompletion(empty).           VariableDeclarationList:VariableDeclarationList,VariableDeclaration  Let next be the result of evaluating VariableDeclarationList.ReturnIfAbrupt(next).Return the result of evaluating VariableDeclaration.           VariableDeclaration:BindingIdentifier  Return NormalCompletion(empty).           VariableDeclaration:BindingIdentifierInitializer  Let bindingId be StringValue of BindingIdentifier.Let lhs be ? ResolveBinding(bindingId).Let rhs be the result of evaluating Initializer.Let value be ? GetValue(rhs).If IsAnonymousFunctionDefinition(Initializer) is true, thenLet hasNameProperty be ? HasOwnProperty(value, &amp;quot;name&amp;quot;).If hasNameProperty is false, perform SetFunctionName(value, bindingId).Return ? PutValue(lhs, value).          Note If a VariableDeclaration is nested within a with statement and the BindingIdentifier in the VariableDeclaration is the same as a property name of the binding object of the with statement&apos;s object Environment Record, then step 6 will assign value to the property instead of assigning to the VariableEnvironment binding of the Identifier.   VariableDeclaration:BindingPatternInitializer  Let rhs be the result of evaluating Initializer.Let rval be ? GetValue(rhs).Return the result of performing BindingInitialization for BindingPattern passing rval and undefined as arguments.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.3.3.1">
	<buginformation>
		<summary>Static Semantics: BoundNames</summary>
		<description>ObjectBindingPattern:{}  Return a new empty List.           ArrayBindingPattern:[Elisionopt]  Return a new empty List.           ArrayBindingPattern:[ElisionoptBindingRestElement]  Return the BoundNames of BindingRestElement.           ArrayBindingPattern:[BindingElementList,Elisionopt]  Return the BoundNames of BindingElementList.           ArrayBindingPattern:[BindingElementList,ElisionoptBindingRestElement]  Let names be BoundNames of BindingElementList.Append to names the elements of BoundNames of BindingRestElement.Return names.           BindingPropertyList:BindingPropertyList,BindingProperty  Let names be BoundNames of BindingPropertyList.Append to names the elements of BoundNames of BindingProperty.Return names.           BindingElementList:BindingElementList,BindingElisionElement  Let names be BoundNames of BindingElementList.Append to names the elements of BoundNames of BindingElisionElement.Return names.           BindingElisionElement:ElisionoptBindingElement  Return BoundNames of BindingElement.           BindingProperty:PropertyName:BindingElement  Return the BoundNames of BindingElement.           SingleNameBinding:BindingIdentifierInitializeropt  Return the BoundNames of BindingIdentifier.           BindingElement:BindingPatternInitializeropt  Return the BoundNames of BindingPattern.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.3.3.2">
	<buginformation>
		<summary>Static Semantics: ContainsExpression</summary>
		<description>ObjectBindingPattern:{}  Return false.           ArrayBindingPattern:[Elisionopt]  Return false.           ArrayBindingPattern:[ElisionoptBindingRestElement]  Return ContainsExpression of BindingRestElement.           ArrayBindingPattern:[BindingElementList,Elisionopt]  Return ContainsExpression of BindingElementList.           ArrayBindingPattern:[BindingElementList,ElisionoptBindingRestElement]  Let has be ContainsExpression of BindingElementList.If has is true, return true.Return ContainsExpression of BindingRestElement.           BindingPropertyList:BindingPropertyList,BindingProperty  Let has be ContainsExpression of BindingPropertyList.If has is true, return true.Return ContainsExpression of BindingProperty.           BindingElementList:BindingElementList,BindingElisionElement  Let has be ContainsExpression of BindingElementList.If has is true, return true.Return ContainsExpression of BindingElisionElement.           BindingElisionElement:ElisionoptBindingElement  Return ContainsExpression of BindingElement.           BindingProperty:PropertyName:BindingElement  Let has be IsComputedPropertyKey of PropertyName.If has is true, return true.Return ContainsExpression of BindingElement.           BindingElement:BindingPatternInitializer  Return true.           SingleNameBinding:BindingIdentifier  Return false.           SingleNameBinding:BindingIdentifierInitializer  Return true.           BindingRestElement:...BindingIdentifier  Return false.           BindingRestElement:...BindingPattern  Return ContainsExpression of BindingPattern.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.3.3.3">
	<buginformation>
		<summary>Static Semantics: HasInitializer</summary>
		<description>BindingElement:BindingPattern  Return false.           BindingElement:BindingPatternInitializer  Return true.           SingleNameBinding:BindingIdentifier  Return false.           SingleNameBinding:BindingIdentifierInitializer  Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.3.3.4">
	<buginformation>
		<summary>Static Semantics: IsSimpleParameterList</summary>
		<description>BindingElement:BindingPattern  Return false.           BindingElement:BindingPatternInitializer  Return false.           SingleNameBinding:BindingIdentifier  Return true.           SingleNameBinding:BindingIdentifierInitializer  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.3.3.5">
	<buginformation>
		<summary>Runtime Semantics: BindingInitialization</summary>
		<description>With parameters value and environment.  Note When undefined is passed for environment it indicates that a PutValue  operation should be used to assign the initialization value. This is  the case for formal parameter lists of non-strict functions. In that  case the formal parameter bindings are preinitialized in order to deal  with the possibility of multiple parameters with the same name.   BindingPattern:ObjectBindingPattern  Perform ? RequireObjectCoercible(value).Return the result of performing BindingInitialization for ObjectBindingPattern using value and environment as arguments.           BindingPattern:ArrayBindingPattern  Let iterator be ? GetIterator(value).Let iteratorRecord be Record {[[Iterator]]: iterator, [[Done]]: false}.Let result be IteratorBindingInitialization for ArrayBindingPattern using iteratorRecord and environment as arguments.If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).Return result.           ObjectBindingPattern:{}  Return NormalCompletion(empty).           BindingPropertyList:BindingPropertyList,BindingProperty  Let status be the result of performing BindingInitialization for BindingPropertyList using value and environment as arguments.ReturnIfAbrupt(status).Return the result of performing BindingInitialization for BindingProperty using value and environment as arguments.           BindingProperty:SingleNameBinding  Let name be the string that is the only element of BoundNames of SingleNameBinding.Return the result of performing KeyedBindingInitialization for SingleNameBinding using value, environment, and name as the arguments.           BindingProperty:PropertyName:BindingElement  Let P be the result of evaluating PropertyName.ReturnIfAbrupt(P).Return the result of performing KeyedBindingInitialization for BindingElement using value, environment, and P as arguments.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.3.3.6">
	<buginformation>
		<summary>Runtime Semantics: IteratorBindingInitialization</summary>
		<description>With parameters iteratorRecord and environment.  Note When undefined is passed for environment it indicates that a PutValue  operation should be used to assign the initialization value. This is  the case for formal parameter lists of non-strict functions. In that  case the formal parameter bindings are preinitialized in order to deal  with the possibility of multiple parameters with the same name.   ArrayBindingPattern:[]  Return NormalCompletion(empty).           ArrayBindingPattern:[Elision]  Return the result of performing IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.           ArrayBindingPattern:[ElisionoptBindingRestElement]  If Elision is present, thenLet status be the result of performing IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.ReturnIfAbrupt(status).Return the result of performing IteratorBindingInitialization for BindingRestElement with iteratorRecord and environment as arguments.           ArrayBindingPattern:[BindingElementList]  Return the result of performing IteratorBindingInitialization for BindingElementList with iteratorRecord and environment as arguments.           ArrayBindingPattern:[BindingElementList,]  Return the result of performing IteratorBindingInitialization for BindingElementList with iteratorRecord and environment as arguments.           ArrayBindingPattern:[BindingElementList,Elision]  Let status be the result of performing IteratorBindingInitialization for BindingElementList with iteratorRecord and environment as arguments.ReturnIfAbrupt(status).Return the result of performing IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.           ArrayBindingPattern:[BindingElementList,ElisionoptBindingRestElement]  Let status be the result of performing IteratorBindingInitialization for BindingElementList with iteratorRecord and environment as arguments.ReturnIfAbrupt(status).If Elision is present, thenLet status be the result of performing IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.ReturnIfAbrupt(status).Return the result of performing IteratorBindingInitialization for BindingRestElement with iteratorRecord and environment as arguments.           BindingElementList:BindingElisionElement  Return the result of performing IteratorBindingInitialization for BindingElisionElement with iteratorRecord and environment as arguments.           BindingElementList:BindingElementList,BindingElisionElement  Let status be the result of performing IteratorBindingInitialization for BindingElementList with iteratorRecord and environment as arguments.ReturnIfAbrupt(status).Return the result of performing IteratorBindingInitialization for BindingElisionElement using iteratorRecord and environment as arguments.           BindingElisionElement:BindingElement  Return the result of performing IteratorBindingInitialization of BindingElement with iteratorRecord and environment as the arguments.           BindingElisionElement:ElisionBindingElement  Let status be the result of performing IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.ReturnIfAbrupt(status).Return the result of performing IteratorBindingInitialization of BindingElement with iteratorRecord and environment as the arguments.           BindingElement:SingleNameBinding  Return the result of performing IteratorBindingInitialization for SingleNameBinding with iteratorRecord and environment as the arguments.           SingleNameBinding:BindingIdentifierInitializeropt  Let bindingId be StringValue of BindingIdentifier.Let lhs be ? ResolveBinding(bindingId, environment).If iteratorRecord.[[Done]] is false, thenLet next be IteratorStep(iteratorRecord.[[Iterator]]).If next is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(next).If next is false, set iteratorRecord.[[Done]] to true.Else,Let v be IteratorValue(next).If v is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(v).If iteratorRecord.[[Done]] is true, let v be undefined.If Initializer is present and v is undefined, thenLet defaultValue be the result of evaluating Initializer.Set v to ? GetValue(defaultValue).If IsAnonymousFunctionDefinition(Initializer) is true, thenLet hasNameProperty be ? HasOwnProperty(v, &amp;quot;name&amp;quot;).If hasNameProperty is false, perform SetFunctionName(v, bindingId).If environment is undefined, return ? PutValue(lhs, v).Return InitializeReferencedBinding(lhs, v).           BindingElement:BindingPatternInitializeropt  If iteratorRecord.[[Done]] is false, thenLet next be IteratorStep(iteratorRecord.[[Iterator]]).If next is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(next).If next is false, set iteratorRecord.[[Done]] to true.Else,Let v be IteratorValue(next).If v is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(v).If iteratorRecord.[[Done]] is true, let v be undefined.If Initializer is present and v is undefined, thenLet defaultValue be the result of evaluating Initializer.Set v to ? GetValue(defaultValue).Return the result of performing BindingInitialization of BindingPattern with v and environment as the arguments.           BindingRestElement:...BindingIdentifier  Let lhs be ? ResolveBinding(StringValue of BindingIdentifier, environment).Let A be ! ArrayCreate(0).Let n be 0.Repeat,If iteratorRecord.[[Done]] is false, thenLet next be IteratorStep(iteratorRecord.[[Iterator]]).If next is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(next).If next is false, set iteratorRecord.[[Done]] to true.If iteratorRecord.[[Done]] is true, thenIf environment is undefined, return ? PutValue(lhs, A).Return InitializeReferencedBinding(lhs, A).Let nextValue be IteratorValue(next).If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(nextValue).Let status be CreateDataProperty(A, ! ToString(n), nextValue).Assert: status is true.Increment n by 1.           BindingRestElement:...BindingPattern  Let A be ! ArrayCreate(0).Let n be 0.Repeat,If iteratorRecord.[[Done]] is false, thenLet next be IteratorStep(iteratorRecord.[[Iterator]]).If next is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(next).If next is false, set iteratorRecord.[[Done]] to true.If iteratorRecord.[[Done]] is true, thenReturn the result of performing BindingInitialization of BindingPattern with A and environment as the arguments.Let nextValue be IteratorValue(next).If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(nextValue).Let status be CreateDataProperty(A, ! ToString(n), nextValue).Assert: status is true.Increment n by 1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.3.3.7">
	<buginformation>
		<summary>Runtime Semantics: KeyedBindingInitialization</summary>
		<description>With parameters value, environment, and propertyName. Note When undefined is passed for environment it indicates that a PutValue  operation should be used to assign the initialization value. This is  the case for formal parameter lists of non-strict functions. In that  case the formal parameter bindings are preinitialized in order to deal  with the possibility of multiple parameters with the same name.   BindingElement:BindingPatternInitializeropt  Let v be ? GetV(value, propertyName).If Initializer is present and v is undefined, thenLet defaultValue be the result of evaluating Initializer.Set v to ? GetValue(defaultValue).Return the result of performing BindingInitialization for BindingPattern passing v and environment as arguments.           SingleNameBinding:BindingIdentifierInitializeropt  Let bindingId be StringValue of BindingIdentifier.Let lhs be ? ResolveBinding(bindingId, environment).Let v be ? GetV(value, propertyName).If Initializer is present and v is undefined, thenLet defaultValue be the result of evaluating Initializer.Set v to ? GetValue(defaultValue).If IsAnonymousFunctionDefinition(Initializer) is true, thenLet hasNameProperty be ? HasOwnProperty(v, &amp;quot;name&amp;quot;).If hasNameProperty is false, perform SetFunctionName(v, bindingId).If environment is undefined, return ? PutValue(lhs, v).Return InitializeReferencedBinding(lhs, v).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.4.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>EmptyStatement:;  Return NormalCompletion(empty).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.5.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>ExpressionStatement:Expression;  Let exprRef be the result of evaluating Expression.Return ? GetValue(exprRef).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.6.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>IfStatement:if(Expression)StatementelseStatement if(Expression)Statement              It is a Syntax Error if IsLabelledFunction(Statement) is true.                    Note It is only necessary to apply this rule if the extension specified in  B.3.2 is implemented.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.6.2">
	<buginformation>
		<summary>Static Semantics: ContainsDuplicateLabels</summary>
		<description>With parameter labelSet.   IfStatement:if(Expression)StatementelseStatement  Let hasDuplicate be ContainsDuplicateLabels of the first Statement with argument labelSet.If hasDuplicate is true, return true.Return ContainsDuplicateLabels of the second Statement with argument labelSet.         IfStatement:if(Expression)Statement  Return ContainsDuplicateLabels of Statement with argument labelSet.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.6.3">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedBreakTarget</summary>
		<description>With parameter labelSet.   IfStatement:if(Expression)StatementelseStatement  Let hasUndefinedLabels be ContainsUndefinedBreakTarget of the first Statement with argument labelSet.If hasUndefinedLabels is true, return true.Return ContainsUndefinedBreakTarget of the second Statement with argument labelSet.         IfStatement:if(Expression)Statement  Return ContainsUndefinedBreakTarget of Statement with argument labelSet.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.6.4">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedContinueTarget</summary>
		<description>With parameters iterationSet and labelSet.   IfStatement:if(Expression)StatementelseStatement  Let hasUndefinedLabels be ContainsUndefinedContinueTarget of the first Statement with arguments iterationSet and « ».If hasUndefinedLabels is true, return true.Return ContainsUndefinedContinueTarget of the second Statement with arguments iterationSet and « ».         IfStatement:if(Expression)Statement  Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and « ».</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.6.5">
	<buginformation>
		<summary>Static Semantics: VarDeclaredNames</summary>
		<description>IfStatement:if(Expression)StatementelseStatement  Let names be VarDeclaredNames of the first Statement.Append to names the elements of the VarDeclaredNames of the second Statement.Return names.         IfStatement:if(Expression)Statement  Return the VarDeclaredNames of Statement.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.6.6">
	<buginformation>
		<summary>Static Semantics: VarScopedDeclarations</summary>
		<description>IfStatement:if(Expression)StatementelseStatement  Let declarations be VarScopedDeclarations of the first Statement.Append to declarations the elements of the VarScopedDeclarations of the second Statement.Return declarations.         IfStatement:if(Expression)Statement  Return the VarScopedDeclarations of Statement.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.6.7">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>IfStatement:if(Expression)StatementelseStatement  Let exprRef be the result of evaluating Expression.Let exprValue be ToBoolean(? GetValue(exprRef)).If exprValue is true, thenLet stmtCompletion be the result of evaluating the first Statement.Else,Let stmtCompletion be the result of evaluating the second Statement.Return Completion(UpdateEmpty(stmtCompletion, undefined)).         IfStatement:if(Expression)Statement  Let exprRef be the result of evaluating Expression.Let exprValue be ToBoolean(? GetValue(exprRef)).If exprValue is false, thenReturn NormalCompletion(undefined).Else,Let stmtCompletion be the result of evaluating Statement.Return Completion(UpdateEmpty(stmtCompletion, undefined)).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.1.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>IterationStatement:doStatementwhile(Expression); while(Expression)Statement for(Expressionopt;Expressionopt;Expressionopt)Statement for(varVariableDeclarationList;Expressionopt;Expressionopt)Statement for(LexicalDeclarationExpressionopt;Expressionopt)Statement for(LeftHandSideExpressioninExpression)Statement for(varForBindinginExpression)Statement for(ForDeclarationinExpression)Statement for(LeftHandSideExpressionofAssignmentExpression)Statement for(varForBindingofAssignmentExpression)Statement for(ForDeclarationofAssignmentExpression)Statement                It is a Syntax Error if IsLabelledFunction(Statement) is true.                        Note It is only necessary to apply this rule if the extension specified in  B.3.2 is implemented.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.1.2">
	<buginformation>
		<summary>Runtime Semantics: LoopContinues ( completion, labelSet )</summary>
		<description>The abstract operation LoopContinues with arguments completion and labelSet is defined by the following steps: If completion.[[Type]] is normal, return true.If completion.[[Type]] is not continue, return false.If completion.[[Target]] is empty, return true.If completion.[[Target]] is an element of labelSet, return true.Return false.          Note Within the Statement part of an IterationStatement a ContinueStatement may be used to begin a new iteration.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.2.1">
	<buginformation>
		<summary>Static Semantics: ContainsDuplicateLabels</summary>
		<description>With parameter labelSet.   IterationStatement:doStatementwhile(Expression);  Return ContainsDuplicateLabels of Statement with argument labelSet.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.2.2">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedBreakTarget</summary>
		<description>With parameter labelSet.   IterationStatement:doStatementwhile(Expression);  Return ContainsUndefinedBreakTarget of Statement with argument labelSet.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.2.3">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedContinueTarget</summary>
		<description>With parameters iterationSet and labelSet.   IterationStatement:doStatementwhile(Expression);  Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and « ».</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.2.4">
	<buginformation>
		<summary>Static Semantics: VarDeclaredNames</summary>
		<description>IterationStatement:doStatementwhile(Expression);  Return the VarDeclaredNames of Statement.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.2.5">
	<buginformation>
		<summary>Static Semantics: VarScopedDeclarations</summary>
		<description>IterationStatement:doStatementwhile(Expression);  Return the VarScopedDeclarations of Statement.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.2.6">
	<buginformation>
		<summary>Runtime Semantics: LabelledEvaluation</summary>
		<description>With parameter labelSet.   IterationStatement:doStatementwhile(Expression);  Let V be undefined.Repeat,Let stmtResult be the result of evaluating Statement.If LoopContinues(stmtResult, labelSet) is false, return Completion(UpdateEmpty(stmtResult, V)).If stmtResult.[[Value]] is not empty, set V to stmtResult.[[Value]].Let exprRef be the result of evaluating Expression.Let exprValue be ? GetValue(exprRef).If ToBoolean(exprValue) is false, return NormalCompletion(V).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.3.1">
	<buginformation>
		<summary>Static Semantics: ContainsDuplicateLabels</summary>
		<description>With parameter labelSet.   IterationStatement:while(Expression)Statement  Return ContainsDuplicateLabels of Statement with argument labelSet.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.3.2">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedBreakTarget</summary>
		<description>With parameter labelSet.   IterationStatement:while(Expression)Statement  Return ContainsUndefinedBreakTarget of Statement with argument labelSet.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.3.3">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedContinueTarget</summary>
		<description>With parameters iterationSet and labelSet.   IterationStatement:while(Expression)Statement  Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and « ».</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.3.4">
	<buginformation>
		<summary>Static Semantics: VarDeclaredNames</summary>
		<description>IterationStatement:while(Expression)Statement  Return the VarDeclaredNames of Statement.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.3.5">
	<buginformation>
		<summary>Static Semantics: VarScopedDeclarations</summary>
		<description>IterationStatement:while(Expression)Statement  Return the VarScopedDeclarations of Statement.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.3.6">
	<buginformation>
		<summary>Runtime Semantics: LabelledEvaluation</summary>
		<description>With parameter labelSet.   IterationStatement:while(Expression)Statement  Let V be undefined.Repeat,Let exprRef be the result of evaluating Expression.Let exprValue be ? GetValue(exprRef).If ToBoolean(exprValue) is false, return NormalCompletion(V).Let stmtResult be the result of evaluating Statement.If LoopContinues(stmtResult, labelSet) is false, return Completion(UpdateEmpty(stmtResult, V)).If stmtResult.[[Value]] is not empty, set V to stmtResult.[[Value]].</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.4.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>IterationStatement:for(LexicalDeclarationExpressionopt;Expressionopt)Statement                It is a Syntax Error if any element of the BoundNames of LexicalDeclaration also occurs in the VarDeclaredNames of Statement.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.4.2">
	<buginformation>
		<summary>Static Semantics: ContainsDuplicateLabels</summary>
		<description>With parameter labelSet.   IterationStatement:for(Expressionopt;Expressionopt;Expressionopt)Statement for(varVariableDeclarationList;Expressionopt;Expressionopt)Statement for(LexicalDeclarationExpressionopt;Expressionopt)Statement  Return ContainsDuplicateLabels of Statement with argument labelSet.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.4.3">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedBreakTarget</summary>
		<description>With parameter labelSet.   IterationStatement:for(Expressionopt;Expressionopt;Expressionopt)Statement for(varVariableDeclarationList;Expressionopt;Expressionopt)Statement for(LexicalDeclarationExpressionopt;Expressionopt)Statement  Return ContainsUndefinedBreakTarget of Statement with argument labelSet.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.4.4">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedContinueTarget</summary>
		<description>With parameters iterationSet and labelSet.   IterationStatement:for(Expressionopt;Expressionopt;Expressionopt)Statement for(varVariableDeclarationList;Expressionopt;Expressionopt)Statement for(LexicalDeclarationExpressionopt;Expressionopt)Statement  Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and « ».</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.4.5">
	<buginformation>
		<summary>Static Semantics: VarDeclaredNames</summary>
		<description>IterationStatement:for(Expressionopt;Expressionopt;Expressionopt)Statement  Return the VarDeclaredNames of Statement.           IterationStatement:for(varVariableDeclarationList;Expressionopt;Expressionopt)Statement  Let names be BoundNames of VariableDeclarationList.Append to names the elements of the VarDeclaredNames of Statement.Return names.           IterationStatement:for(LexicalDeclarationExpressionopt;Expressionopt)Statement  Return the VarDeclaredNames of Statement.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.4.6">
	<buginformation>
		<summary>Static Semantics: VarScopedDeclarations</summary>
		<description>IterationStatement:for(Expressionopt;Expressionopt;Expressionopt)Statement  Return the VarScopedDeclarations of Statement.           IterationStatement:for(varVariableDeclarationList;Expressionopt;Expressionopt)Statement  Let declarations be VarScopedDeclarations of VariableDeclarationList.Append to declarations the elements of the VarScopedDeclarations of Statement.Return declarations.           IterationStatement:for(LexicalDeclarationExpressionopt;Expressionopt)Statement  Return the VarScopedDeclarations of Statement.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.4.7">
	<buginformation>
		<summary>Runtime Semantics: LabelledEvaluation</summary>
		<description>With parameter labelSet.   IterationStatement:for(Expressionopt;Expressionopt;Expressionopt)Statement  If the first Expression is present, thenLet exprRef be the result of evaluating the first Expression.Perform ? GetValue(exprRef).Return ? ForBodyEvaluation(the second Expression, the third Expression, Statement, « », labelSet).           IterationStatement:for(varVariableDeclarationList;Expressionopt;Expressionopt)Statement  Let varDcl be the result of evaluating VariableDeclarationList.ReturnIfAbrupt(varDcl).Return ? ForBodyEvaluation(the first Expression, the second Expression, Statement, « », labelSet).           IterationStatement:for(LexicalDeclarationExpressionopt;Expressionopt)Statement  Let oldEnv be the running execution context&apos;s LexicalEnvironment.Let loopEnv be NewDeclarativeEnvironment(oldEnv).Let loopEnvRec be loopEnv&apos;s EnvironmentRecord.Let isConst be the result of performing IsConstantDeclaration of LexicalDeclaration.Let boundNames be the BoundNames of LexicalDeclaration.For each element dn of boundNames, doIf isConst is true, thenPerform ! loopEnvRec.CreateImmutableBinding(dn, true).Else,Perform ! loopEnvRec.CreateMutableBinding(dn, false).Set the running execution context&apos;s LexicalEnvironment to loopEnv.Let forDcl be the result of evaluating LexicalDeclaration.If forDcl is an abrupt completion, thenSet the running execution context&apos;s LexicalEnvironment to oldEnv.Return Completion(forDcl).If isConst is false, let perIterationLets be boundNames; otherwise let perIterationLets be « ».Let bodyResult be ForBodyEvaluation(the first Expression, the second Expression, Statement, perIterationLets, labelSet).Set the running execution context&apos;s LexicalEnvironment to oldEnv.Return Completion(bodyResult).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.4.8">
	<buginformation>
		<summary>Runtime Semantics: ForBodyEvaluation( test, increment, stmt, perIterationBindings, labelSet )</summary>
		<description>The abstract operation ForBodyEvaluation with arguments test, increment, stmt, perIterationBindings, and labelSet is performed as follows: Let V be undefined.Perform ? CreatePerIterationEnvironment(perIterationBindings).Repeat,If test is not [empty], thenLet testRef be the result of evaluating test.Let testValue be ? GetValue(testRef).If ToBoolean(testValue) is false, return NormalCompletion(V).Let result be the result of evaluating stmt.If LoopContinues(result, labelSet) is false, return Completion(UpdateEmpty(result, V)).If result.[[Value]] is not empty, set V to result.[[Value]].Perform ? CreatePerIterationEnvironment(perIterationBindings).If increment is not [empty], thenLet incRef be the result of evaluating increment.Perform ? GetValue(incRef).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.4.9">
	<buginformation>
		<summary>Runtime Semantics: CreatePerIterationEnvironment( perIterationBindings )</summary>
		<description>The abstract operation CreatePerIterationEnvironment with argument perIterationBindings is performed as follows: If perIterationBindings has any elements, thenLet lastIterationEnv be the running execution context&apos;s LexicalEnvironment.Let lastIterationEnvRec be lastIterationEnv&apos;s EnvironmentRecord.Let outer be lastIterationEnv&apos;s outer environment reference.Assert: outer is not null.Let thisIterationEnv be NewDeclarativeEnvironment(outer).Let thisIterationEnvRec be thisIterationEnv&apos;s EnvironmentRecord.For each element bn of perIterationBindings, doPerform ! thisIterationEnvRec.CreateMutableBinding(bn, false).Let lastValue be ? lastIterationEnvRec.GetBindingValue(bn, true).Perform thisIterationEnvRec.InitializeBinding(bn, lastValue).Set the running execution context&apos;s LexicalEnvironment to thisIterationEnv.Return undefined.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.5.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>IterationStatement:for(LeftHandSideExpressioninExpression)Statement for(LeftHandSideExpressionofAssignmentExpression)Statement                It is a Syntax Error if LeftHandSideExpression is either an ObjectLiteral or an ArrayLiteral and if the lexical token sequence matched by LeftHandSideExpression cannot be parsed with no tokens left over using AssignmentPattern as the goal symbol.                        If LeftHandSideExpression is either an ObjectLiteral or an ArrayLiteral and if the lexical token sequence matched by LeftHandSideExpression can be parsed with no tokens left over using AssignmentPattern as the goal symbol then the following rules are not applied. Instead, the Early Error rules for AssignmentPattern are used.               It is a Syntax Error if IsValidSimpleAssignmentTarget of LeftHandSideExpression is false.                                    It is a Syntax Error if the LeftHandSideExpression is   CoverParenthesizedExpressionAndArrowParameterList:(Expression)  and Expression derives a phrase that would produce a Syntax Error according to these rules if that phrase were substituted for LeftHandSideExpression. This rule is recursively applied.                        Note The last rule means that the other rules are applied even if parentheses surround Expression.   IterationStatement:for(ForDeclarationinExpression)Statement for(ForDeclarationofAssignmentExpression)Statement                It is a Syntax Error if the BoundNames of ForDeclaration contains &amp;quot;let&amp;quot;.                                    It is a Syntax Error if any element of the BoundNames of ForDeclaration also occurs in the VarDeclaredNames of Statement.                                    It is a Syntax Error if the BoundNames of ForDeclaration contains any duplicate entries.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.5.2">
	<buginformation>
		<summary>Static Semantics: BoundNames</summary>
		<description>ForDeclaration:LetOrConstForBinding  Return the BoundNames of ForBinding.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.5.3">
	<buginformation>
		<summary>Static Semantics: ContainsDuplicateLabels</summary>
		<description>With parameter labelSet.   IterationStatement:for(LeftHandSideExpressioninExpression)Statement for(varForBindinginExpression)Statement for(ForDeclarationinExpression)Statement for(LeftHandSideExpressionofAssignmentExpression)Statement for(varForBindingofAssignmentExpression)Statement for(ForDeclarationofAssignmentExpression)Statement  Return ContainsDuplicateLabels of Statement with argument labelSet.          Note This section is extended by Annex  B.3.6.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.5.4">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedBreakTarget</summary>
		<description>With parameter labelSet.   IterationStatement:for(LeftHandSideExpressioninExpression)Statement for(varForBindinginExpression)Statement for(ForDeclarationinExpression)Statement for(LeftHandSideExpressionofAssignmentExpression)Statement for(varForBindingofAssignmentExpression)Statement for(ForDeclarationofAssignmentExpression)Statement  Return ContainsUndefinedBreakTarget of Statement with argument labelSet.          Note This section is extended by Annex  B.3.6.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.5.5">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedContinueTarget</summary>
		<description>With parameters iterationSet and labelSet.   IterationStatement:for(LeftHandSideExpressioninExpression)Statement for(varForBindinginExpression)Statement for(ForDeclarationinExpression)Statement for(LeftHandSideExpressionofAssignmentExpression)Statement for(varForBindingofAssignmentExpression)Statement for(ForDeclarationofAssignmentExpression)Statement  Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and « ».          Note This section is extended by Annex  B.3.6.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.5.6">
	<buginformation>
		<summary>Static Semantics: IsDestructuring</summary>
		<description>ForDeclaration:LetOrConstForBinding  Return IsDestructuring of ForBinding.           ForBinding:BindingIdentifier  Return false.           ForBinding:BindingPattern  Return true.          Note This section is extended by Annex  B.3.6.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.5.7">
	<buginformation>
		<summary>Static Semantics: VarDeclaredNames</summary>
		<description>IterationStatement:for(LeftHandSideExpressioninExpression)Statement  Return the VarDeclaredNames of Statement.           IterationStatement:for(varForBindinginExpression)Statement  Let names be the BoundNames of ForBinding.Append to names the elements of the VarDeclaredNames of Statement.Return names.           IterationStatement:for(ForDeclarationinExpression)Statement  Return the VarDeclaredNames of Statement.           IterationStatement:for(LeftHandSideExpressionofAssignmentExpression)Statement  Return the VarDeclaredNames of Statement.           IterationStatement:for(varForBindingofAssignmentExpression)Statement  Let names be the BoundNames of ForBinding.Append to names the elements of the VarDeclaredNames of Statement.Return names.           IterationStatement:for(ForDeclarationofAssignmentExpression)Statement  Return the VarDeclaredNames of Statement.          Note This section is extended by Annex  B.3.6.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.5.8">
	<buginformation>
		<summary>Static Semantics: VarScopedDeclarations</summary>
		<description>IterationStatement:for(LeftHandSideExpressioninExpression)Statement  Return the VarScopedDeclarations of Statement.           IterationStatement:for(varForBindinginExpression)Statement  Let declarations be a List containing ForBinding.Append to declarations the elements of the VarScopedDeclarations of Statement.Return declarations.           IterationStatement:for(ForDeclarationinExpression)Statement  Return the VarScopedDeclarations of Statement.           IterationStatement:for(LeftHandSideExpressionofAssignmentExpression)Statement  Return the VarScopedDeclarations of Statement.           IterationStatement:for(varForBindingofAssignmentExpression)Statement  Let declarations be a List containing ForBinding.Append to declarations the elements of the VarScopedDeclarations of Statement.Return declarations.           IterationStatement:for(ForDeclarationofAssignmentExpression)Statement  Return the VarScopedDeclarations of Statement.          Note This section is extended by Annex  B.3.6.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.5.9">
	<buginformation>
		<summary>Runtime Semantics: BindingInitialization</summary>
		<description>With parameters value and environment.  Note undefined is passed for environment to indicate that a PutValue operation should be used to assign the initialization value. This is the case for var statements and the formal parameter lists of some non-strict functions (see  9.2.12). In those cases a lexical binding is hoisted and preinitialized prior to evaluation of its initializer.   ForDeclaration:LetOrConstForBinding  Return the result of performing BindingInitialization for ForBinding passing value and environment as the arguments.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.5.10">
	<buginformation>
		<summary>Runtime Semantics: BindingInstantiation</summary>
		<description>With parameter environment.  ForDeclaration:LetOrConstForBinding  Let envRec be environment&apos;s EnvironmentRecord.Assert: envRec is a declarative Environment Record.For each element name of the BoundNames of ForBinding, doIf IsConstantDeclaration of LetOrConst is true, thenPerform ! envRec.CreateImmutableBinding(name, true).Else,Perform ! envRec.CreateMutableBinding(name, false).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.5.11">
	<buginformation>
		<summary>Runtime Semantics: LabelledEvaluation</summary>
		<description>With parameter labelSet.   IterationStatement:for(LeftHandSideExpressioninExpression)Statement  Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, enumerate, assignment, labelSet).           IterationStatement:for(varForBindinginExpression)Statement  Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, enumerate, varBinding, labelSet).           IterationStatement:for(ForDeclarationinExpression)Statement  Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, Expression, enumerate).Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, enumerate, lexicalBinding, labelSet).           IterationStatement:for(LeftHandSideExpressionofAssignmentExpression)Statement  Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, iterate, assignment, labelSet).           IterationStatement:for(varForBindingofAssignmentExpression)Statement  Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, iterate, varBinding, labelSet).           IterationStatement:for(ForDeclarationofAssignmentExpression)Statement  Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, iterate).Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, iterate, lexicalBinding, labelSet).          Note This section is extended by Annex  B.3.6.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.5.12">
	<buginformation>
		<summary>Runtime Semantics: ForIn/OfHeadEvaluation ( TDZnames, expr, iterationKind )</summary>
		<description>The abstract operation ForIn/OfHeadEvaluation is called with arguments TDZnames, expr, and iterationKind. The value of iterationKind is either enumerate or iterate. Let oldEnv be the running execution context&apos;s LexicalEnvironment.If TDZnames is not an empty List, thenAssert: TDZnames has no duplicate entries.Let TDZ be NewDeclarativeEnvironment(oldEnv).Let TDZEnvRec be TDZ&apos;s EnvironmentRecord.For each string name in TDZnames, doPerform ! TDZEnvRec.CreateMutableBinding(name, false).Set the running execution context&apos;s LexicalEnvironment to TDZ.Let exprRef be the result of evaluating expr.Set the running execution context&apos;s LexicalEnvironment to oldEnv.Let exprValue be ? GetValue(exprRef).If iterationKind is enumerate, thenIf exprValue is undefined or null, thenReturn Completion{[[Type]]: break, [[Value]]: empty, [[Target]]: empty}.Let obj be ! ToObject(exprValue).Return ? EnumerateObjectProperties(obj).Else,Assert: iterationKind is iterate.Return ? GetIterator(exprValue).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.5.13">
	<buginformation>
		<summary>Runtime Semantics: ForIn/OfBodyEvaluation ( lhs, stmt, iterator, iterationKind, lhsKind, labelSet )</summary>
		<description>The abstract operation ForIn/OfBodyEvaluation is called with arguments lhs, stmt, iterator, iterationKind, lhsKind, and labelSet. The value of iterationKind is either enumerate or iterate. The value of lhsKind is either assignment, varBinding or lexicalBinding. Let oldEnv be the running execution context&apos;s LexicalEnvironment.Let V be undefined.Let destructuring be IsDestructuring of lhs.If destructuring is true and if lhsKind is assignment, thenAssert: lhs is a LeftHandSideExpression.Let assignmentPattern be the parse of the source text corresponding to lhs using AssignmentPattern as the goal symbol.Repeat,Let nextResult be ? IteratorStep(iterator).If nextResult is false, return NormalCompletion(V).Let nextValue be ? IteratorValue(nextResult).If lhsKind is either assignment or varBinding, thenIf destructuring is false, thenLet lhsRef be the result of evaluating lhs. (It may be evaluated repeatedly.)Else,Assert: lhsKind is lexicalBinding.Assert: lhs is a ForDeclaration.Let iterationEnv be NewDeclarativeEnvironment(oldEnv).Perform BindingInstantiation for lhs passing iterationEnv as the argument.Set the running execution context&apos;s LexicalEnvironment to iterationEnv.If destructuring is false, thenAssert: lhs binds a single name.Let lhsName be the sole element of BoundNames of lhs.Let lhsRef be ! ResolveBinding(lhsName).If destructuring is false, thenIf lhsRef is an abrupt completion, thenLet status be lhsRef.Else if lhsKind is lexicalBinding, thenLet status be InitializeReferencedBinding(lhsRef, nextValue).Else,Let status be PutValue(lhsRef, nextValue).Else,If lhsKind is assignment, thenLet status be the result of performing DestructuringAssignmentEvaluation of assignmentPattern using nextValue as the argument.Else if lhsKind is varBinding, thenAssert: lhs is a ForBinding.Let status be the result of performing BindingInitialization for lhs passing nextValue and undefined as the arguments.Else,Assert: lhsKind is lexicalBinding.Assert: lhs is a ForDeclaration.Let status be the result of performing BindingInitialization for lhs passing nextValue and iterationEnv as arguments.If status is an abrupt completion, thenSet the running execution context&apos;s LexicalEnvironment to oldEnv.If iterationKind is enumerate, thenReturn status.Else,Assert: iterationKind is iterate.Return ? IteratorClose(iterator, status).Let result be the result of evaluating stmt.Set the running execution context&apos;s LexicalEnvironment to oldEnv.If LoopContinues(result, labelSet) is false, thenIf iterationKind is enumerate, thenReturn Completion(UpdateEmpty(result, V)).Else,Assert: iterationKind is iterate.Return ? IteratorClose(iterator, UpdateEmpty(result, V)).If result.[[Value]] is not empty, set V to result.[[Value]].</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.5.14">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>ForBinding:BindingIdentifier  Let bindingId be StringValue of BindingIdentifier.Return ? ResolveBinding(bindingId).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.7.5.15">
	<buginformation>
		<summary>EnumerateObjectProperties ( O )</summary>
		<description>When the abstract operation EnumerateObjectProperties is called with argument O, the following steps are taken: Assert: Type(O) is Object.Return an Iterator object (25.1.1.2) whose next method iterates over all the String-valued keys of enumerable properties of O.  The iterator object is never directly accessible to ECMAScript code.  The mechanics and order of enumerating the properties is not specified  but must conform to the rules specified below.          The iterator&apos;s throw and return methods are null and are never invoked. The iterator&apos;s next  method processes object properties to determine whether the property  key should be returned as an iterator value. Returned property keys do  not include keys that are Symbols. Properties of the target object may  be deleted during enumeration. A property that is deleted before it is  processed by the iterator&apos;s next method is ignored. If new  properties are added to the target object during enumeration, the newly  added properties are not guaranteed to be processed in the active  enumeration. A property name will be returned by the iterator&apos;s next method at most once in any enumeration. Enumerating the properties of the target object includes  enumerating properties of its prototype, and the prototype of the  prototype, and so on, recursively; but a property of a prototype is not  processed if it has the same name as a property that has already been  processed by the iterator&apos;s next method. The values of  [[Enumerable]] attributes are not considered when determining if a  property of a prototype object has already been processed. The  enumerable property names of prototype objects must be obtained by  invoking EnumerateObjectProperties passing the prototype object as the  argument. EnumerateObjectProperties must obtain the own property keys of  the target object by calling its [[OwnPropertyKeys]] internal method.  Property attributes of the target object must be obtained by calling its  [[GetOwnProperty]] internal method. Note The following is an informative definition of an ECMAScript generator function that conforms to these rules: function* EnumerateObjectProperties(obj) {   const visited</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.8.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>ContinueStatement:continue;   ContinueStatement:continueLabelIdentifier;              It is a Syntax Error if this ContinueStatement is not nested, directly or indirectly (but not crossing function boundaries), within an IterationStatement.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.8.2">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedContinueTarget</summary>
		<description>With parameters iterationSet and labelSet.   ContinueStatement:continue;  Return false.         ContinueStatement:continueLabelIdentifier;  If the StringValue of LabelIdentifier is not an element of iterationSet, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.8.3">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>ContinueStatement:continue;  Return Completion{[[Type]]: continue, [[Value]]: empty, [[Target]]: empty}.         ContinueStatement:continueLabelIdentifier;  Let label be the StringValue of LabelIdentifier.Return Completion{[[Type]]: continue, [[Value]]: empty, [[Target]]: label }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.9.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>BreakStatement:break;              It is a Syntax Error if this BreakStatement is not nested, directly or indirectly (but not crossing function boundaries), within an IterationStatement or a SwitchStatement.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.9.2">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedBreakTarget</summary>
		<description>With parameter labelSet.   BreakStatement:break;  Return false.         BreakStatement:breakLabelIdentifier;  If the StringValue of LabelIdentifier is not an element of labelSet, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.9.3">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>BreakStatement:break;  Return Completion{[[Type]]: break, [[Value]]: empty, [[Target]]: empty}.         BreakStatement:breakLabelIdentifier;  Let label be the StringValue of LabelIdentifier.Return Completion{[[Type]]: break, [[Value]]: empty, [[Target]]: label }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.10.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>ReturnStatement:return;  Return Completion{[[Type]]: return, [[Value]]: undefined, [[Target]]: empty}.         ReturnStatement:returnExpression;  Let exprRef be the result of evaluating Expression.Let exprValue be ? GetValue(exprRef).Return Completion{[[Type]]: return, [[Value]]: exprValue, [[Target]]: empty}.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.11.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>WithStatement:with(Expression)Statement              It is a Syntax Error if the code that matches this production is contained in strict mode code.                              It is a Syntax Error if IsLabelledFunction(Statement) is true.                    Note It is only necessary to apply the second rule if the extension specified in  B.3.2 is implemented.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.11.2">
	<buginformation>
		<summary>Static Semantics: ContainsDuplicateLabels</summary>
		<description>With parameter labelSet.   WithStatement:with(Expression)Statement  Return ContainsDuplicateLabels of Statement with argument labelSet.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.11.3">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedBreakTarget</summary>
		<description>With parameter labelSet.   WithStatement:with(Expression)Statement  Return ContainsUndefinedBreakTarget of Statement with argument labelSet.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.11.4">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedContinueTarget</summary>
		<description>With parameters iterationSet and labelSet.   WithStatement:with(Expression)Statement  Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and « ».</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.11.5">
	<buginformation>
		<summary>Static Semantics: VarDeclaredNames</summary>
		<description>WithStatement:with(Expression)Statement  Return the VarDeclaredNames of Statement.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.11.6">
	<buginformation>
		<summary>Static Semantics: VarScopedDeclarations</summary>
		<description>WithStatement:with(Expression)Statement  Return the VarScopedDeclarations of Statement.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.11.7">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>WithStatement:with(Expression)Statement  Let val be the result of evaluating Expression.Let obj be ? ToObject(? GetValue(val)).Let oldEnv be the running execution context&apos;s LexicalEnvironment.Let newEnv be NewObjectEnvironment(obj, oldEnv).Set the withEnvironment flag of newEnv&apos;s EnvironmentRecord to true.Set the running execution context&apos;s LexicalEnvironment to newEnv.Let C be the result of evaluating Statement.Set the running execution context&apos;s LexicalEnvironment to oldEnv.Return Completion(UpdateEmpty(C, undefined)).        Note No matter how control leaves the embedded Statement, whether normally or by some form of abrupt completion or exception, the LexicalEnvironment is always restored to its former state.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.12.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>SwitchStatement:switch(Expression)CaseBlock              It is a Syntax Error if the LexicallyDeclaredNames of CaseBlock contains any duplicate entries.                              It is a Syntax Error if any element of the LexicallyDeclaredNames of CaseBlock also occurs in the VarDeclaredNames of CaseBlock.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.12.2">
	<buginformation>
		<summary>Static Semantics: ContainsDuplicateLabels</summary>
		<description>With parameter labelSet.   SwitchStatement:switch(Expression)CaseBlock  Return ContainsDuplicateLabels of CaseBlock with argument labelSet.         CaseBlock:{}  Return false.         CaseBlock:{CaseClausesoptDefaultClauseCaseClausesopt}  If the first CaseClauses is present, thenLet hasDuplicates be ContainsDuplicateLabels of the first CaseClauses with argument labelSet.If hasDuplicates is true, return true.Let hasDuplicates be ContainsDuplicateLabels of DefaultClause with argument labelSet.If hasDuplicates is true, return true.If the second CaseClauses is not present, return false.Return ContainsDuplicateLabels of the second CaseClauses with argument labelSet.         CaseClauses:CaseClausesCaseClause  Let hasDuplicates be ContainsDuplicateLabels of CaseClauses with argument labelSet.If hasDuplicates is true, return true.Return ContainsDuplicateLabels of CaseClause with argument labelSet.         CaseClause:caseExpression:StatementListopt  If the StatementList is present, return ContainsDuplicateLabels of StatementList with argument labelSet.Return false.         DefaultClause:default:StatementListopt  If the StatementList is present, return ContainsDuplicateLabels of StatementList with argument labelSet.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.12.3">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedBreakTarget</summary>
		<description>With parameter labelSet.   SwitchStatement:switch(Expression)CaseBlock  Return ContainsUndefinedBreakTarget of CaseBlock with argument labelSet.         CaseBlock:{}  Return false.         CaseBlock:{CaseClausesoptDefaultClauseCaseClausesopt}  If the first CaseClauses is present, thenLet hasUndefinedLabels be ContainsUndefinedBreakTarget of the first CaseClauses with argument labelSet.If hasUndefinedLabels is true, return true.Let hasUndefinedLabels be ContainsUndefinedBreakTarget of DefaultClause with argument labelSet.If hasUndefinedLabels is true, return true.If the second CaseClauses is not present, return false.Return ContainsUndefinedBreakTarget of the second CaseClauses with argument labelSet.         CaseClauses:CaseClausesCaseClause  Let hasUndefinedLabels be ContainsUndefinedBreakTarget of CaseClauses with argument labelSet.If hasUndefinedLabels is true, return true.Return ContainsUndefinedBreakTarget of CaseClause with argument labelSet.         CaseClause:caseExpression:StatementListopt  If the StatementList is present, return ContainsUndefinedBreakTarget of StatementList with argument labelSet.Return false.         DefaultClause:default:StatementListopt  If the StatementList is present, return ContainsUndefinedBreakTarget of StatementList with argument labelSet.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.12.4">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedContinueTarget</summary>
		<description>With parameters iterationSet and labelSet.   SwitchStatement:switch(Expression)CaseBlock  Return ContainsUndefinedContinueTarget of CaseBlock with arguments iterationSet and « ».         CaseBlock:{}  Return false.         CaseBlock:{CaseClausesoptDefaultClauseCaseClausesopt}  If the first CaseClauses is present, thenLet hasUndefinedLabels be ContainsUndefinedContinueTarget of the first CaseClauses with arguments iterationSet and « ».If hasUndefinedLabels is true, return true.Let hasUndefinedLabels be ContainsUndefinedContinueTarget of DefaultClause with arguments iterationSet and « ».If hasUndefinedLabels is true, return true.If the second CaseClauses is not present, return false.Return ContainsUndefinedContinueTarget of the second CaseClauses with arguments iterationSet and « ».         CaseClauses:CaseClausesCaseClause  Let hasUndefinedLabels be ContainsUndefinedContinueTarget of CaseClauses with arguments iterationSet and « ».If hasUndefinedLabels is true, return true.Return ContainsUndefinedContinueTarget of CaseClause with arguments iterationSet and « ».         CaseClause:caseExpression:StatementListopt  If the StatementList is present, return ContainsUndefinedContinueTarget of StatementList with arguments iterationSet and « ».Return false.         DefaultClause:default:StatementListopt  If the StatementList is present, return ContainsUndefinedContinueTarget of StatementList with arguments iterationSet and « ».Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.12.5">
	<buginformation>
		<summary>Static Semantics: LexicallyDeclaredNames</summary>
		<description>CaseBlock:{}  Return a new empty List.         CaseBlock:{CaseClausesoptDefaultClauseCaseClausesopt}  If the first CaseClauses is present, let names be the LexicallyDeclaredNames of the first CaseClauses.Else, let names be a new empty List.Append to names the elements of the LexicallyDeclaredNames of the DefaultClause.If the second CaseClauses is not present, return names.Return the result of appending to names the elements of the LexicallyDeclaredNames of the second CaseClauses.         CaseClauses:CaseClausesCaseClause  Let names be LexicallyDeclaredNames of CaseClauses.Append to names the elements of the LexicallyDeclaredNames of CaseClause.Return names.         CaseClause:caseExpression:StatementListopt  If the StatementList is present, return the LexicallyDeclaredNames of StatementList.Return a new empty List.         DefaultClause:default:StatementListopt  If the StatementList is present, return the LexicallyDeclaredNames of StatementList.Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.12.6">
	<buginformation>
		<summary>Static Semantics: LexicallyScopedDeclarations</summary>
		<description>CaseBlock:{}  Return a new empty List.         CaseBlock:{CaseClausesoptDefaultClauseCaseClausesopt}  If the first CaseClauses is present, let declarations be the LexicallyScopedDeclarations of the first CaseClauses.Else, let declarations be a new empty List.Append to declarations the elements of the LexicallyScopedDeclarations of the DefaultClause.If the second CaseClauses is not present, return declarations.Return the result of appending to declarations the elements of the LexicallyScopedDeclarations of the second CaseClauses.         CaseClauses:CaseClausesCaseClause  Let declarations be LexicallyScopedDeclarations of CaseClauses.Append to declarations the elements of the LexicallyScopedDeclarations of CaseClause.Return declarations.         CaseClause:caseExpression:StatementListopt  If the StatementList is present, return the LexicallyScopedDeclarations of StatementList.Return a new empty List.         DefaultClause:default:StatementListopt  If the StatementList is present, return the LexicallyScopedDeclarations of StatementList.Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.12.7">
	<buginformation>
		<summary>Static Semantics: VarDeclaredNames</summary>
		<description>SwitchStatement:switch(Expression)CaseBlock  Return the VarDeclaredNames of CaseBlock.         CaseBlock:{}  Return a new empty List.         CaseBlock:{CaseClausesoptDefaultClauseCaseClausesopt}  If the first CaseClauses is present, let names be the VarDeclaredNames of the first CaseClauses.Else, let names be a new empty List.Append to names the elements of the VarDeclaredNames of the DefaultClause.If the second CaseClauses is not present, return names.Return the result of appending to names the elements of the VarDeclaredNames of the second CaseClauses.         CaseClauses:CaseClausesCaseClause  Let names be VarDeclaredNames of CaseClauses.Append to names the elements of the VarDeclaredNames of CaseClause.Return names.         CaseClause:caseExpression:StatementListopt  If the StatementList is present, return the VarDeclaredNames of StatementList.Return a new empty List.         DefaultClause:default:StatementListopt  If the StatementList is present, return the VarDeclaredNames of StatementList.Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.12.8">
	<buginformation>
		<summary>Static Semantics: VarScopedDeclarations</summary>
		<description>SwitchStatement:switch(Expression)CaseBlock  Return the VarScopedDeclarations of CaseBlock.         CaseBlock:{}  Return a new empty List.         CaseBlock:{CaseClausesoptDefaultClauseCaseClausesopt}  If the first CaseClauses is present, let declarations be the VarScopedDeclarations of the first CaseClauses.Else, let declarations be a new empty List.Append to declarations the elements of the VarScopedDeclarations of the DefaultClause.If the second CaseClauses is not present, return declarations.Return the result of appending to declarations the elements of the VarScopedDeclarations of the second CaseClauses.         CaseClauses:CaseClausesCaseClause  Let declarations be VarScopedDeclarations of CaseClauses.Append to declarations the elements of the VarScopedDeclarations of CaseClause.Return declarations.         CaseClause:caseExpression:StatementListopt  If the StatementList is present, return the VarScopedDeclarations of StatementList.Return a new empty List.         DefaultClause:default:StatementListopt  If the StatementList is present, return the VarScopedDeclarations of StatementList.Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.12.9">
	<buginformation>
		<summary>Runtime Semantics: CaseBlockEvaluation</summary>
		<description>With parameter input.  CaseBlock:{}  Return NormalCompletion(undefined).         CaseBlock:{CaseClauses}  Let V be undefined.Let A be the List of CaseClause items in CaseClauses, in source text order.Let found be false.For each CaseClause C in A, doIf found is false, thenLet clauseSelector be the result of CaseSelectorEvaluation of C.ReturnIfAbrupt(clauseSelector).Set found to the result of performing Strict Equality Comparison input</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.12.10">
	<buginformation>
		<summary>Runtime Semantics: CaseSelectorEvaluation</summary>
		<description>CaseClause:caseExpression:StatementListopt  Let exprRef be the result of evaluating Expression.Return ? GetValue(exprRef).        Note CaseSelectorEvaluation does not execute the associated StatementList. It simply evaluates the Expression and returns the value, which the CaseBlock algorithm uses to determine which StatementList to start executing.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.12.11">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>SwitchStatement:switch(Expression)CaseBlock  Let exprRef be the result of evaluating Expression.Let switchValue be ? GetValue(exprRef).Let oldEnv be the running execution context&apos;s LexicalEnvironment.Let blockEnv be NewDeclarativeEnvironment(oldEnv).Perform BlockDeclarationInstantiation(CaseBlock, blockEnv).Set the running execution context&apos;s LexicalEnvironment to blockEnv.Let R be the result of performing CaseBlockEvaluation of CaseBlock with argument switchValue.Set the running execution context&apos;s LexicalEnvironment to oldEnv.Return R.        Note No matter how control leaves the SwitchStatement the LexicalEnvironment is always restored to its former state.   CaseClause:caseExpression:  Return NormalCompletion(empty).         CaseClause:caseExpression:StatementList  Return the result of evaluating StatementList.         DefaultClause:default:  Return NormalCompletion(empty).         DefaultClause:default:StatementList  Return the result of evaluating StatementList.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.13.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>LabelledItem:FunctionDeclaration              It is a Syntax Error if any source text matches this rule.                    Note An alternative definition for this rule is provided in  B.3.2.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.13.2">
	<buginformation>
		<summary>Static Semantics: ContainsDuplicateLabels</summary>
		<description>With parameter labelSet.   LabelledStatement:LabelIdentifier:LabelledItem  Let label be the StringValue of LabelIdentifier.If label is an element of labelSet, return true.Let newLabelSet be a copy of labelSet with label appended.Return ContainsDuplicateLabels of LabelledItem with argument newLabelSet.         LabelledItem:FunctionDeclaration  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.13.3">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedBreakTarget</summary>
		<description>With parameter labelSet.   LabelledStatement:LabelIdentifier:LabelledItem  Let label be the StringValue of LabelIdentifier.Let newLabelSet be a copy of labelSet with label appended.Return ContainsUndefinedBreakTarget of LabelledItem with argument newLabelSet.         LabelledItem:FunctionDeclaration  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.13.4">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedContinueTarget</summary>
		<description>With parameters iterationSet and labelSet.   LabelledStatement:LabelIdentifier:LabelledItem  Let label be the StringValue of LabelIdentifier.Let newLabelSet be a copy of labelSet with label appended.Return ContainsUndefinedContinueTarget of LabelledItem with arguments iterationSet and newLabelSet.         LabelledItem:FunctionDeclaration  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.13.5">
	<buginformation>
		<summary>Static Semantics: IsLabelledFunction ( stmt )</summary>
		<description>The abstract operation IsLabelledFunction with argument stmt performs the following steps: If stmt is not a LabelledStatement, return false.Let item be the LabelledItem of stmt.If item is  LabelledItem:FunctionDeclaration  , return true.Let subStmt be the Statement of item.Return IsLabelledFunction(subStmt).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.13.6">
	<buginformation>
		<summary>Static Semantics: LexicallyDeclaredNames</summary>
		<description>LabelledStatement:LabelIdentifier:LabelledItem  Return the LexicallyDeclaredNames of LabelledItem.         LabelledItem:Statement  Return a new empty List.         LabelledItem:FunctionDeclaration  Return BoundNames of FunctionDeclaration.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.13.7">
	<buginformation>
		<summary>Static Semantics: LexicallyScopedDeclarations</summary>
		<description>LabelledStatement:LabelIdentifier:LabelledItem  Return the LexicallyScopedDeclarations of LabelledItem.         LabelledItem:Statement  Return a new empty List.         LabelledItem:FunctionDeclaration  Return a new List containing FunctionDeclaration.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.13.8">
	<buginformation>
		<summary>Static Semantics: TopLevelLexicallyDeclaredNames</summary>
		<description>LabelledStatement:LabelIdentifier:LabelledItem  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.13.9">
	<buginformation>
		<summary>Static Semantics: TopLevelLexicallyScopedDeclarations</summary>
		<description>LabelledStatement:LabelIdentifier:LabelledItem  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.13.10">
	<buginformation>
		<summary>Static Semantics: TopLevelVarDeclaredNames</summary>
		<description>LabelledStatement:LabelIdentifier:LabelledItem  Return the TopLevelVarDeclaredNames of LabelledItem.         LabelledItem:Statement  If Statement is  Statement:LabelledStatement  , return TopLevelVarDeclaredNames of Statement.Return VarDeclaredNames of Statement.         LabelledItem:FunctionDeclaration  Return BoundNames of FunctionDeclaration.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.13.11">
	<buginformation>
		<summary>Static Semantics: TopLevelVarScopedDeclarations</summary>
		<description>LabelledStatement:LabelIdentifier:LabelledItem  Return the TopLevelVarScopedDeclarations of LabelledItem.         LabelledItem:Statement  If Statement is  Statement:LabelledStatement  , return TopLevelVarScopedDeclarations of Statement.Return VarScopedDeclarations of Statement.         LabelledItem:FunctionDeclaration  Return a new List containing FunctionDeclaration.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.13.12">
	<buginformation>
		<summary>Static Semantics: VarDeclaredNames</summary>
		<description>LabelledStatement:LabelIdentifier:LabelledItem  Return the VarDeclaredNames of LabelledItem.         LabelledItem:FunctionDeclaration  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.13.13">
	<buginformation>
		<summary>Static Semantics: VarScopedDeclarations</summary>
		<description>LabelledStatement:LabelIdentifier:LabelledItem  Return the VarScopedDeclarations of LabelledItem.         LabelledItem:FunctionDeclaration  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.13.14">
	<buginformation>
		<summary>Runtime Semantics: LabelledEvaluation</summary>
		<description>With parameter labelSet.   LabelledStatement:LabelIdentifier:LabelledItem  Let label be the StringValue of LabelIdentifier.Append label as an element of labelSet.Let stmtResult be LabelledEvaluation of LabelledItem with argument labelSet.If stmtResult.[[Type]] is break and SameValue(stmtResult.[[Target]], label) is true, thenSet stmtResult to NormalCompletion(stmtResult.[[Value]]).Return Completion(stmtResult).         LabelledItem:Statement  If Statement is either a LabelledStatement or a BreakableStatement, thenReturn LabelledEvaluation of Statement with argument labelSet.Else,Return the result of evaluating Statement.         LabelledItem:FunctionDeclaration  Return the result of evaluating FunctionDeclaration.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.13.15">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>LabelledStatement:LabelIdentifier:LabelledItem  Let newLabelSet be a new empty List.Return LabelledEvaluation of this LabelledStatement with argument newLabelSet.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.14.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>ThrowStatement:throwExpression;  Let exprRef be the result of evaluating Expression.Let exprValue be ? GetValue(exprRef).Return Completion{[[Type]]: throw, [[Value]]: exprValue, [[Target]]: empty}.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.15.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>Catch:catch(CatchParameter)Block              It is a Syntax Error if BoundNames of CatchParameter contains any duplicate elements.                              It is a Syntax Error if any element of the BoundNames of CatchParameter also occurs in the LexicallyDeclaredNames of Block.                              It is a Syntax Error if any element of the BoundNames of CatchParameter also occurs in the VarDeclaredNames of Block.                    Note An alternative static semantics for this production is given in  B.3.5.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.15.2">
	<buginformation>
		<summary>Static Semantics: ContainsDuplicateLabels</summary>
		<description>With parameter labelSet.   TryStatement:tryBlockCatch  Let hasDuplicates be ContainsDuplicateLabels of Block with argument labelSet.If hasDuplicates is true, return true.Return ContainsDuplicateLabels of Catch with argument labelSet.         TryStatement:tryBlockFinally  Let hasDuplicates be ContainsDuplicateLabels of Block with argument labelSet.If hasDuplicates is true, return true.Return ContainsDuplicateLabels of Finally with argument labelSet.         TryStatement:tryBlockCatchFinally  Let hasDuplicates be ContainsDuplicateLabels of Block with argument labelSet.If hasDuplicates is true, return true.Let hasDuplicates be ContainsDuplicateLabels of Catch with argument labelSet.If hasDuplicates is true, return true.Return ContainsDuplicateLabels of Finally with argument labelSet.         Catch:catch(CatchParameter)Block  Return ContainsDuplicateLabels of Block with argument labelSet.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.15.3">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedBreakTarget</summary>
		<description>With parameter labelSet.   TryStatement:tryBlockCatch  Let hasUndefinedLabels be ContainsUndefinedBreakTarget of Block with argument labelSet.If hasUndefinedLabels is true, return true.Return ContainsUndefinedBreakTarget of Catch with argument labelSet.         TryStatement:tryBlockFinally  Let hasUndefinedLabels be ContainsUndefinedBreakTarget of Block with argument labelSet.If hasUndefinedLabels is true, return true.Return ContainsUndefinedBreakTarget of Finally with argument labelSet.         TryStatement:tryBlockCatchFinally  Let hasUndefinedLabels be ContainsUndefinedBreakTarget of Block with argument labelSet.If hasUndefinedLabels is true, return true.Let hasUndefinedLabels be ContainsUndefinedBreakTarget of Catch with argument labelSet.If hasUndefinedLabels is true, return true.Return ContainsUndefinedBreakTarget of Finally with argument labelSet.         Catch:catch(CatchParameter)Block  Return ContainsUndefinedBreakTarget of Block with argument labelSet.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.15.4">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedContinueTarget</summary>
		<description>With parameters iterationSet and labelSet.   TryStatement:tryBlockCatch  Let hasUndefinedLabels be ContainsUndefinedContinueTarget of Block with arguments iterationSet and « ».If hasUndefinedLabels is true, return true.Return ContainsUndefinedContinueTarget of Catch with arguments iterationSet and « ».         TryStatement:tryBlockFinally  Let hasUndefinedLabels be ContainsUndefinedContinueTarget of Block with arguments iterationSet and « ».If hasUndefinedLabels is true, return true.Return ContainsUndefinedContinueTarget of Finally with arguments iterationSet and « ».         TryStatement:tryBlockCatchFinally  Let hasUndefinedLabels be ContainsUndefinedContinueTarget of Block with arguments iterationSet and « ».If hasUndefinedLabels is true, return true.Let hasUndefinedLabels be ContainsUndefinedContinueTarget of Catch with arguments iterationSet and « ».If hasUndefinedLabels is true, return true.Return ContainsUndefinedContinueTarget of Finally with arguments iterationSet and « ».         Catch:catch(CatchParameter)Block  Return ContainsUndefinedContinueTarget of Block with arguments iterationSet and « ».</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.15.5">
	<buginformation>
		<summary>Static Semantics: VarDeclaredNames</summary>
		<description>TryStatement:tryBlockCatch  Let names be VarDeclaredNames of Block.Append to names the elements of the VarDeclaredNames of Catch.Return names.         TryStatement:tryBlockFinally  Let names be VarDeclaredNames of Block.Append to names the elements of the VarDeclaredNames of Finally.Return names.         TryStatement:tryBlockCatchFinally  Let names be VarDeclaredNames of Block.Append to names the elements of the VarDeclaredNames of Catch.Append to names the elements of the VarDeclaredNames of Finally.Return names.         Catch:catch(CatchParameter)Block  Return the VarDeclaredNames of Block.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.15.6">
	<buginformation>
		<summary>Static Semantics: VarScopedDeclarations</summary>
		<description>TryStatement:tryBlockCatch  Let declarations be VarScopedDeclarations of Block.Append to declarations the elements of the VarScopedDeclarations of Catch.Return declarations.         TryStatement:tryBlockFinally  Let declarations be VarScopedDeclarations of Block.Append to declarations the elements of the VarScopedDeclarations of Finally.Return declarations.         TryStatement:tryBlockCatchFinally  Let declarations be VarScopedDeclarations of Block.Append to declarations the elements of the VarScopedDeclarations of Catch.Append to declarations the elements of the VarScopedDeclarations of Finally.Return declarations.         Catch:catch(CatchParameter)Block  Return the VarScopedDeclarations of Block.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.15.7">
	<buginformation>
		<summary>Runtime Semantics: CatchClauseEvaluation</summary>
		<description>With parameter thrownValue.  Catch:catch(CatchParameter)Block  Let oldEnv be the running execution context&apos;s LexicalEnvironment.Let catchEnv be NewDeclarativeEnvironment(oldEnv).Let catchEnvRec be catchEnv&apos;s EnvironmentRecord.For each element argName of the BoundNames of CatchParameter, doPerform ! catchEnvRec.CreateMutableBinding(argName, false).Set the running execution context&apos;s LexicalEnvironment to catchEnv.Let status be the result of performing BindingInitialization for CatchParameter passing thrownValue and catchEnv as arguments.If status is an abrupt completion, thenSet the running execution context&apos;s LexicalEnvironment to oldEnv.Return Completion(status).Let B be the result of evaluating Block.Set the running execution context&apos;s LexicalEnvironment to oldEnv.Return Completion(B).        Note No matter how control leaves the Block the LexicalEnvironment is always restored to its former state.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.15.8">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>TryStatement:tryBlockCatch  Let B be the result of evaluating Block.If B.[[Type]] is throw, let C be CatchClauseEvaluation of Catch with parameter B.[[Value]].Else, let C be B.Return Completion(UpdateEmpty(C, undefined)).         TryStatement:tryBlockFinally  Let B be the result of evaluating Block.Let F be the result of evaluating Finally.If F.[[Type]] is normal, set F to B.Return Completion(UpdateEmpty(F, undefined)).         TryStatement:tryBlockCatchFinally  Let B be the result of evaluating Block.If B.[[Type]] is throw, let C be CatchClauseEvaluation of Catch with parameter B.[[Value]].Else, let C be B.Let F be the result of evaluating Finally.If F.[[Type]] is normal, set F to C.Return Completion(UpdateEmpty(F, undefined)).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="13.16.1">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>Note Evaluating a DebuggerStatement  may allow an implementation to cause a breakpoint when run under a  debugger. If a debugger is not present or active this statement has no  observable effect.   DebuggerStatement:debugger;  If an implementation-defined debugging facility is available and enabled, thenPerform an implementation-defined debugging action.Let result be an implementation-defined Completion value.Else,Let result be NormalCompletion(empty).Return result.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.1">
	<buginformation>
		<summary>Directive Prologues and the Use Strict Directive</summary>
		<description>A  Directive Prologue is the longest sequence of ExpressionStatements occurring as the initial StatementListItems or ModuleItems of a FunctionBody, a ScriptBody, or a ModuleBody and where each ExpressionStatement in the sequence consists entirely of a StringLiteral token followed by a semicolon. The semicolon may appear explicitly or may be inserted by automatic semicolon insertion. A Directive Prologue may be an empty sequence. A  Use Strict Directive is an ExpressionStatement in a Directive Prologue whose StringLiteral is either the exact code unit sequences &amp;quot;use strict&amp;quot; or &apos;use strict&apos;. A Use Strict Directive may not contain an EscapeSequence or LineContinuation. A Directive Prologue may contain more than one Use Strict Directive. However, an implementation may issue a warning if this occurs. Note The ExpressionStatements of a Directive Prologue  are evaluated normally during evaluation of the containing production.  Implementations may define implementation specific meanings for ExpressionStatements which are not a Use Strict Directive and which occur in a Directive Prologue. If an appropriate notification mechanism exists, an implementation should issue a warning if it encounters in a Directive Prologue an ExpressionStatement that is not a Use Strict Directive and which does not have a meaning defined by the implementation.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.2">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>FunctionDeclaration:functionBindingIdentifier(FormalParameters){FunctionBody}   FunctionDeclaration:function(FormalParameters){FunctionBody}   FunctionExpression:functionBindingIdentifieropt(FormalParameters){FunctionBody}              If the source code matching this production is strict mode code, the Early Error rules for   UniqueFormalParameters:FormalParameters  are applied.                              If the source code matching this production is strict mode code, it is a Syntax Error if BindingIdentifier is the IdentifierName eval or the IdentifierName arguments.                              It is a Syntax Error if ContainsUseStrict of FunctionBody is true and IsSimpleParameterList of FormalParameters is false.                              It is a Syntax Error if any element of the BoundNames of FormalParameters also occurs in the LexicallyDeclaredNames of FunctionBody.                              It is a Syntax Error if FormalParameters Contains SuperProperty is true.                              It is a Syntax Error if FunctionBody Contains SuperProperty is true.                              It is a Syntax Error if FormalParameters Contains SuperCall is true.                              It is a Syntax Error if FunctionBody Contains SuperCall is true.                    Note 1 The LexicallyDeclaredNames of a FunctionBody does not include identifiers bound using var or function declarations.   UniqueFormalParameters:FormalParameters              It is a Syntax Error if BoundNames of FormalParameters contains any duplicate elements.                     FormalParameters:FormalParameterList              It is a Syntax Error if IsSimpleParameterList of FormalParameterList is false and BoundNames of FormalParameterList contains any duplicate elements.                    Note 2 Multiple occurrences of the same BindingIdentifier in a FormalParameterList is only allowed for functions which have simple parameter lists and which are not defined in strict mode code.   FunctionBody:FunctionStatementList              It is a Syntax Error if the LexicallyDeclaredNames of FunctionStatementList contains any duplicate entries.                              It is a Syntax Error if any element of the LexicallyDeclaredNames of FunctionStatementList also occurs in the VarDeclaredNames of FunctionStatementList.                              It is a Syntax Error if ContainsDuplicateLabels of FunctionStatementList with argument « » is true.                              It is a Syntax Error if ContainsUndefinedBreakTarget of FunctionStatementList with argument « » is true.                              It is a Syntax Error if ContainsUndefinedContinueTarget of FunctionStatementList with arguments « » and « » is true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.3">
	<buginformation>
		<summary>Static Semantics: BoundNames</summary>
		<description>FunctionDeclaration:functionBindingIdentifier(FormalParameters){FunctionBody}  Return the BoundNames of BindingIdentifier.         FunctionDeclaration:function(FormalParameters){FunctionBody}  Return « &amp;quot;*default*&amp;quot; ».        Note &amp;quot;*default*&amp;quot; is used within this specification as  a synthetic name for hoistable anonymous functions that are defined  using export declarations.   FormalParameters:[empty]  Return a new empty List.         FormalParameters:FormalParameterList,FunctionRestParameter  Let names be BoundNames of FormalParameterList.Append to names the BoundNames of FunctionRestParameter.Return names.         FormalParameterList:FormalParameterList,FormalParameter  Let names be BoundNames of FormalParameterList.Append to names the BoundNames of FormalParameter.Return names.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.4">
	<buginformation>
		<summary>Static Semantics: Contains</summary>
		<description>With parameter symbol.   FunctionDeclaration:functionBindingIdentifier(FormalParameters){FunctionBody}   FunctionDeclaration:function(FormalParameters){FunctionBody}   FunctionExpression:functionBindingIdentifieropt(FormalParameters){FunctionBody}  Return false.        Note Static semantic rules that depend upon substructure generally do not look into function definitions.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.5">
	<buginformation>
		<summary>Static Semantics: ContainsExpression</summary>
		<description>FormalParameters:[empty]  Return false.         FormalParameters:FormalParameterList,FunctionRestParameter  If ContainsExpression of FormalParameterList is true, return true.Return ContainsExpression of FunctionRestParameter.         FormalParameterList:FormalParameterList,FormalParameter  If ContainsExpression of FormalParameterList is true, return true.Return ContainsExpression of FormalParameter.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.6">
	<buginformation>
		<summary>Static Semantics: ContainsUseStrict</summary>
		<description>FunctionBody:FunctionStatementList  If the Directive Prologue of FunctionStatementList contains a Use Strict Directive, return true; otherwise, return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.7">
	<buginformation>
		<summary>Static Semantics: ExpectedArgumentCount</summary>
		<description>FormalParameters:[empty]  Return 0.         FormalParameters:FormalParameterList,FunctionRestParameter  Return ExpectedArgumentCount of FormalParameterList.        Note The ExpectedArgumentCount of a FormalParameterList is the number of FormalParameters to the left of either the rest parameter or the first FormalParameter with an Initializer. A FormalParameter  without an initializer is allowed after the first parameter with an  initializer but such parameters are considered to be optional with undefined as their default value.   FormalParameterList:FormalParameterList,FormalParameter  Let count be ExpectedArgumentCount of FormalParameterList.If HasInitializer of FormalParameterList is true or HasInitializer of FormalParameter is true, return count.Return count + 1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.8">
	<buginformation>
		<summary>Static Semantics: HasInitializer</summary>
		<description>FormalParameterList:FormalParameterList,FormalParameter  If HasInitializer of FormalParameterList is true, return true.Return HasInitializer of FormalParameter.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.9">
	<buginformation>
		<summary>Static Semantics: HasName</summary>
		<description>FunctionExpression:function(FormalParameters){FunctionBody}  Return false.         FunctionExpression:functionBindingIdentifier(FormalParameters){FunctionBody}  Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.10">
	<buginformation>
		<summary>Static Semantics: IsAnonymousFunctionDefinition ( expr )</summary>
		<description>The abstract operation IsAnonymousFunctionDefinition determines  if its argument is a function definition that does not bind a name. The  argument expr is the result of parsing an AssignmentExpression or Initializer. The following steps are taken: If IsFunctionDefinition of expr is false, return false.Let hasName be the result of HasName of expr.If hasName is true, return false.Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.11">
	<buginformation>
		<summary>Static Semantics: IsConstantDeclaration</summary>
		<description>FunctionDeclaration:functionBindingIdentifier(FormalParameters){FunctionBody}   FunctionDeclaration:function(FormalParameters){FunctionBody}  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.12">
	<buginformation>
		<summary>Static Semantics: IsFunctionDefinition</summary>
		<description>FunctionExpression:functionBindingIdentifieropt(FormalParameters){FunctionBody}  Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.13">
	<buginformation>
		<summary>Static Semantics: IsSimpleParameterList</summary>
		<description>FormalParameters:[empty]  Return true.         FormalParameters:FormalParameterList,FunctionRestParameter  Return false.         FormalParameterList:FormalParameterList,FormalParameter  If IsSimpleParameterList of FormalParameterList is false, return false.Return IsSimpleParameterList of FormalParameter.         FormalParameter:BindingElement  Return IsSimpleParameterList of BindingElement.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.14">
	<buginformation>
		<summary>Static Semantics: LexicallyDeclaredNames</summary>
		<description>FunctionStatementList:[empty]  Return a new empty List.         FunctionStatementList:StatementList  Return TopLevelLexicallyDeclaredNames of StatementList.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.15">
	<buginformation>
		<summary>Static Semantics: LexicallyScopedDeclarations</summary>
		<description>FunctionStatementList:[empty]  Return a new empty List.         FunctionStatementList:StatementList  Return the TopLevelLexicallyScopedDeclarations of StatementList.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.16">
	<buginformation>
		<summary>Static Semantics: VarDeclaredNames</summary>
		<description>FunctionStatementList:[empty]  Return a new empty List.         FunctionStatementList:StatementList  Return TopLevelVarDeclaredNames of StatementList.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.17">
	<buginformation>
		<summary>Static Semantics: VarScopedDeclarations</summary>
		<description>FunctionStatementList:[empty]  Return a new empty List.         FunctionStatementList:StatementList  Return the TopLevelVarScopedDeclarations of StatementList.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.18">
	<buginformation>
		<summary>Runtime Semantics: EvaluateBody</summary>
		<description>With parameters functionObject and List argumentsList.   FunctionBody:FunctionStatementList  Perform ? FunctionDeclarationInstantiation(functionObject, argumentsList).Return the result of evaluating FunctionStatementList.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.19">
	<buginformation>
		<summary>Runtime Semantics: IteratorBindingInitialization</summary>
		<description>With parameters iteratorRecord and environment. Note 1 When undefined is passed for environment it indicates that a PutValue  operation should be used to assign the initialization value. This is  the case for formal parameter lists of non-strict functions. In that  case the formal parameter bindings are preinitialized in order to deal  with the possibility of multiple parameters with the same name.    FormalParameters:[empty]  Return NormalCompletion(empty).         FormalParameters:FormalParameterList,FunctionRestParameter  Let restIndex be the result of performing IteratorBindingInitialization for FormalParameterList using iteratorRecord and environment as the arguments.ReturnIfAbrupt(restIndex).Return the result of performing IteratorBindingInitialization for FunctionRestParameter using iteratorRecord and environment as the arguments.         FormalParameterList:FormalParameterList,FormalParameter  Let status be the result of performing IteratorBindingInitialization for FormalParameterList using iteratorRecord and environment as the arguments.ReturnIfAbrupt(status).Return the result of performing IteratorBindingInitialization for FormalParameter using iteratorRecord and environment as the arguments.         FormalParameter:BindingElement  If ContainsExpression of BindingElement is false, return the result of performing IteratorBindingInitialization for BindingElement using iteratorRecord and environment as the arguments.Let currentContext be the running execution context.Let originalEnv be the VariableEnvironment of currentContext.Assert: The VariableEnvironment and LexicalEnvironment of currentContext are the same.Assert: environment and originalEnv are the same.Let paramVarEnv be NewDeclarativeEnvironment(originalEnv).Set the VariableEnvironment of currentContext to paramVarEnv.Set the LexicalEnvironment of currentContext to paramVarEnv.Let result be the result of performing IteratorBindingInitialization for BindingElement using iteratorRecord and environment as the arguments.Set the VariableEnvironment of currentContext to originalEnv.Set the LexicalEnvironment of currentContext to originalEnv.Return result.        Note 2 The new Environment Record created in step 6 is only used if the BindingElement contains a direct eval.   FunctionRestParameter:BindingRestElement  If ContainsExpression of BindingRestElement is false, return the result of performing IteratorBindingInitialization for BindingRestElement using iteratorRecord and environment as the arguments.Let currentContext be the running execution context.Let originalEnv be the VariableEnvironment of currentContext.Assert: The VariableEnvironment and LexicalEnvironment of currentContext are the same.Assert: environment and originalEnv are the same.Let paramVarEnv be NewDeclarativeEnvironment(originalEnv).Set the VariableEnvironment of currentContext to paramVarEnv.Set the LexicalEnvironment of currentContext to paramVarEnv.Let result be the result of performing IteratorBindingInitialization for BindingRestElement using iteratorRecord and environment as the arguments.Set the VariableEnvironment of currentContext to originalEnv.Set the LexicalEnvironment of currentContext to originalEnv.Return result.        Note 3 The new Environment Record created in step 6 is only used if the BindingRestElement contains a direct eval.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.20">
	<buginformation>
		<summary>Runtime Semantics: InstantiateFunctionObject</summary>
		<description>With parameter scope.   FunctionDeclaration:functionBindingIdentifier(FormalParameters){FunctionBody}  If the function code for FunctionDeclaration is strict mode code, let strict be true. Otherwise let strict be false.Let name be StringValue of BindingIdentifier.Let F be FunctionCreate(Normal, FormalParameters, FunctionBody, scope, strict).Perform MakeConstructor(F).Perform SetFunctionName(F, name).Return F.         FunctionDeclaration:function(FormalParameters){FunctionBody}  Let F be FunctionCreate(Normal, FormalParameters, FunctionBody, scope, true).Perform MakeConstructor(F).Perform SetFunctionName(F, &amp;quot;default&amp;quot;).Return F.        Note An anonymous FunctionDeclaration can only occur as part of an export default declaration, and its function code is therefore always strict mode code.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.1.21">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>FunctionDeclaration:functionBindingIdentifier(FormalParameters){FunctionBody}  Return NormalCompletion(empty).        Note 1 An alternative semantics is provided in  B.3.3.   FunctionDeclaration:function(FormalParameters){FunctionBody}  Return NormalCompletion(empty).         FunctionExpression:function(FormalParameters){FunctionBody}  If the function code for FunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.Let scope be the LexicalEnvironment of the running execution context.Let closure be FunctionCreate(Normal, FormalParameters, FunctionBody, scope, strict).Perform MakeConstructor(closure).Return closure.         FunctionExpression:functionBindingIdentifier(FormalParameters){FunctionBody}  If the function code for FunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.Let scope be the running execution context&apos;s LexicalEnvironment.Let funcEnv be NewDeclarativeEnvironment(scope).Let envRec be funcEnv&apos;s EnvironmentRecord.Let name be StringValue of BindingIdentifier.Perform envRec.CreateImmutableBinding(name, false).Let closure be FunctionCreate(Normal, FormalParameters, FunctionBody, funcEnv, strict).Perform MakeConstructor(closure).Perform SetFunctionName(closure, name).Perform envRec.InitializeBinding(name, closure).Return closure.        Note 2 The BindingIdentifier in a FunctionExpression can be referenced from inside the FunctionExpression&apos;s FunctionBody to allow the function to call itself recursively. However, unlike in a FunctionDeclaration, the BindingIdentifier in a FunctionExpression cannot be referenced from and does not affect the scope enclosing the FunctionExpression.  Note 3 A prototype property is automatically created for every function defined using a FunctionDeclaration or FunctionExpression, to allow for the possibility that the function will be used as a constructor.   FunctionStatementList:[empty]  Return NormalCompletion(undefined).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.2.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>ArrowFunction:ArrowParameters</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.2.2">
	<buginformation>
		<summary>Static Semantics: BoundNames</summary>
		<description>ArrowParameters:CoverParenthesizedExpressionAndArrowParameterList  Let formals be CoveredFormalsList of CoverParenthesizedExpressionAndArrowParameterList.Return the BoundNames of formals.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.2.3">
	<buginformation>
		<summary>Static Semantics: Contains</summary>
		<description>With parameter symbol.   ArrowFunction:ArrowParameters</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.2.4">
	<buginformation>
		<summary>Static Semantics: ContainsExpression</summary>
		<description>ArrowParameters:BindingIdentifier  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.2.5">
	<buginformation>
		<summary>Static Semantics: ContainsUseStrict</summary>
		<description>ConciseBody:AssignmentExpression  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.2.6">
	<buginformation>
		<summary>Static Semantics: ExpectedArgumentCount</summary>
		<description>ArrowParameters:BindingIdentifier  Return 1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.2.7">
	<buginformation>
		<summary>Static Semantics: HasName</summary>
		<description>ArrowFunction:ArrowParameters</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.2.8">
	<buginformation>
		<summary>Static Semantics: IsSimpleParameterList</summary>
		<description>ArrowParameters:BindingIdentifier  Return true.         ArrowParameters:CoverParenthesizedExpressionAndArrowParameterList  Let formals be CoveredFormalsList of CoverParenthesizedExpressionAndArrowParameterList.Return IsSimpleParameterList of formals.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.2.9">
	<buginformation>
		<summary>Static Semantics: CoveredFormalsList</summary>
		<description>ArrowParameters:BindingIdentifier  Return this ArrowParameters.         CoverParenthesizedExpressionAndArrowParameterList[Yield, Await]:(Expression) () (...BindingIdentifier) (...BindingPattern) (Expression,...BindingIdentifier) (Expression,...BindingPattern)  Return the result of parsing the lexical token stream matched by CoverParenthesizedExpressionAndArrowParameterList using ArrowFormalParameters as the goal symbol with its [Yield] and [Await] parameters set to the values used when parsing this CoverParenthesizedExpressionAndArrowParameterList.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.2.10">
	<buginformation>
		<summary>Static Semantics: LexicallyDeclaredNames</summary>
		<description>ConciseBody:AssignmentExpression  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.2.11">
	<buginformation>
		<summary>Static Semantics: LexicallyScopedDeclarations</summary>
		<description>ConciseBody:AssignmentExpression  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.2.12">
	<buginformation>
		<summary>Static Semantics: VarDeclaredNames</summary>
		<description>ConciseBody:AssignmentExpression  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.2.13">
	<buginformation>
		<summary>Static Semantics: VarScopedDeclarations</summary>
		<description>ConciseBody:AssignmentExpression  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.2.14">
	<buginformation>
		<summary>Runtime Semantics: IteratorBindingInitialization</summary>
		<description>With parameters iteratorRecord and environment.  Note When undefined is passed for environment it indicates that a PutValue  operation should be used to assign the initialization value. This is  the case for formal parameter lists of non-strict functions. In that  case the formal parameter bindings are preinitialized in order to deal  with the possibility of multiple parameters with the same name.   ArrowParameters:BindingIdentifier  Assert: iteratorRecord.[[Done]] is false.Let next be IteratorStep(iteratorRecord.[[Iterator]]).If next is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(next).If next is false, set iteratorRecord.[[Done]] to true.Else,Let v be IteratorValue(next).If v is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(v).If iteratorRecord.[[Done]] is true, let v be undefined.Return the result of performing BindingInitialization for BindingIdentifier using v and environment as the arguments.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.2.15">
	<buginformation>
		<summary>Runtime Semantics: EvaluateBody</summary>
		<description>With parameters functionObject and List argumentsList.   ConciseBody:AssignmentExpression  Perform ? FunctionDeclarationInstantiation(functionObject, argumentsList).Let exprRef be the result of evaluating AssignmentExpression.Let exprValue be ? GetValue(exprRef).Return Completion{[[Type]]: return, [[Value]]: exprValue, [[Target]]: empty}.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.2.16">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>ArrowFunction:ArrowParameters</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.3.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>MethodDefinition:PropertyName(UniqueFormalParameters){FunctionBody}              It is a Syntax Error if ContainsUseStrict of FunctionBody is true and IsSimpleParameterList of UniqueFormalParameters is false.                              It is a Syntax Error if any element of the BoundNames of UniqueFormalParameters also occurs in the LexicallyDeclaredNames of FunctionBody.                     MethodDefinition:setPropertyName(PropertySetParameterList){FunctionBody}              It is a Syntax Error if BoundNames of PropertySetParameterList contains any duplicate elements.                              It is a Syntax Error if ContainsUseStrict of FunctionBody is true and IsSimpleParameterList of PropertySetParameterList is false.                              It is a Syntax Error if any element of the BoundNames of PropertySetParameterList also occurs in the LexicallyDeclaredNames of FunctionBody.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.3.2">
	<buginformation>
		<summary>Static Semantics: ComputedPropertyContains</summary>
		<description>With parameter symbol.   MethodDefinition:PropertyName(UniqueFormalParameters){FunctionBody} getPropertyName(){FunctionBody} setPropertyName(PropertySetParameterList){FunctionBody}  Return the result of ComputedPropertyContains for PropertyName with argument symbol.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.3.3">
	<buginformation>
		<summary>Static Semantics: ExpectedArgumentCount</summary>
		<description>PropertySetParameterList:FormalParameter  If HasInitializer of FormalParameter is true, return 0.Return 1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.3.4">
	<buginformation>
		<summary>Static Semantics: HasDirectSuper</summary>
		<description>MethodDefinition:PropertyName(UniqueFormalParameters){FunctionBody}  If UniqueFormalParameters Contains SuperCall is true, return true.Return FunctionBody Contains SuperCall.         MethodDefinition:getPropertyName(){FunctionBody}  Return FunctionBody Contains SuperCall.         MethodDefinition:setPropertyName(PropertySetParameterList){FunctionBody}  If PropertySetParameterList Contains SuperCall is true, return true.Return FunctionBody Contains SuperCall.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.3.5">
	<buginformation>
		<summary>Static Semantics: PropName</summary>
		<description>MethodDefinition:PropertyName(UniqueFormalParameters){FunctionBody} getPropertyName(){FunctionBody} setPropertyName(PropertySetParameterList){FunctionBody}  Return PropName of PropertyName.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.3.6">
	<buginformation>
		<summary>Static Semantics: SpecialMethod</summary>
		<description>MethodDefinition:PropertyName(UniqueFormalParameters){FunctionBody}  Return false.         MethodDefinition:GeneratorMethod AsyncMethod getPropertyName(){FunctionBody} setPropertyName(PropertySetParameterList){FunctionBody}  Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.3.7">
	<buginformation>
		<summary>Runtime Semantics: DefineMethod</summary>
		<description>With parameters object and optional parameter functionPrototype.  MethodDefinition:PropertyName(UniqueFormalParameters){FunctionBody}  Let propKey be the result of evaluating PropertyName.ReturnIfAbrupt(propKey).If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.Let scope be the running execution context&apos;s LexicalEnvironment.If functionPrototype was passed as a parameter, thenLet kind be Normal.Let prototype be functionPrototype.Else,Let kind be Method.Let prototype be the intrinsic object %FunctionPrototype%.Let closure be FunctionCreate(kind, UniqueFormalParameters, FunctionBody, scope, strict, prototype).Perform MakeMethod(closure, object).Return the Record{[[Key]]: propKey, [[Closure]]: closure}.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.3.8">
	<buginformation>
		<summary>Runtime Semantics: PropertyDefinitionEvaluation</summary>
		<description>With parameters object and enumerable.   MethodDefinition:PropertyName(UniqueFormalParameters){FunctionBody}  Let methodDef be DefineMethod of MethodDefinition with argument object.ReturnIfAbrupt(methodDef).Perform SetFunctionName(methodDef.[[Closure]], methodDef.[[Key]]).Let desc be the PropertyDescriptor{[[Value]]: methodDef.[[Closure]], [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true}.Return ? DefinePropertyOrThrow(object, methodDef.[[Key]], desc).         MethodDefinition:getPropertyName(){FunctionBody}  Let propKey be the result of evaluating PropertyName.ReturnIfAbrupt(propKey).If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.Let scope be the running execution context&apos;s LexicalEnvironment.Let formalParameterList be an instance of the production  FormalParameters:[empty] .Let closure be FunctionCreate(Method, formalParameterList, FunctionBody, scope, strict).Perform MakeMethod(closure, object).Perform SetFunctionName(closure, propKey, &amp;quot;get&amp;quot;).Let desc be the PropertyDescriptor{[[Get]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true}.Return ? DefinePropertyOrThrow(object, propKey, desc).         MethodDefinition:setPropertyName(PropertySetParameterList){FunctionBody}  Let propKey be the result of evaluating PropertyName.ReturnIfAbrupt(propKey).If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.Let scope be the running execution context&apos;s LexicalEnvironment.Let closure be FunctionCreate(Method, PropertySetParameterList, FunctionBody, scope, strict).Perform MakeMethod(closure, object).Perform SetFunctionName(closure, propKey, &amp;quot;set&amp;quot;).Let desc be the PropertyDescriptor{[[Set]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true}.Return ? DefinePropertyOrThrow(object, propKey, desc).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.4.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>GeneratorMethod:*PropertyName(UniqueFormalParameters){GeneratorBody}              It is a Syntax Error if HasDirectSuper of GeneratorMethod is true.                              It is a Syntax Error if UniqueFormalParameters Contains YieldExpression is true.                              It is a Syntax Error if ContainsUseStrict of GeneratorBody is true and IsSimpleParameterList of UniqueFormalParameters is false.                              It is a Syntax Error if any element of the BoundNames of UniqueFormalParameters also occurs in the LexicallyDeclaredNames of GeneratorBody.                     GeneratorDeclaration:function*BindingIdentifier(FormalParameters){GeneratorBody}   GeneratorDeclaration:function*(FormalParameters){GeneratorBody}   GeneratorExpression:function*BindingIdentifieropt(FormalParameters){GeneratorBody}              If the source code matching this production is strict mode code, the Early Error rules for   UniqueFormalParameters:FormalParameters  are applied.                              If the source code matching this production is strict mode code, it is a Syntax Error if BindingIdentifier is the IdentifierName eval or the IdentifierName arguments.                              It is a Syntax Error if ContainsUseStrict of GeneratorBody is true and IsSimpleParameterList of FormalParameters is false.                              It is a Syntax Error if any element of the BoundNames of FormalParameters also occurs in the LexicallyDeclaredNames of GeneratorBody.                              It is a Syntax Error if FormalParameters Contains YieldExpression is true.                              It is a Syntax Error if FormalParameters Contains SuperProperty is true.                              It is a Syntax Error if GeneratorBody Contains SuperProperty is true.                              It is a Syntax Error if FormalParameters Contains SuperCall is true.                              It is a Syntax Error if GeneratorBody Contains SuperCall is true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.4.2">
	<buginformation>
		<summary>Static Semantics: BoundNames</summary>
		<description>GeneratorDeclaration:function*BindingIdentifier(FormalParameters){GeneratorBody}  Return the BoundNames of BindingIdentifier.         GeneratorDeclaration:function*(FormalParameters){GeneratorBody}  Return « &amp;quot;*default*&amp;quot; ».        Note &amp;quot;*default*&amp;quot; is used within this specification as  a synthetic name for hoistable anonymous functions that are defined  using export declarations.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.4.3">
	<buginformation>
		<summary>Static Semantics: ComputedPropertyContains</summary>
		<description>With parameter symbol.   GeneratorMethod:*PropertyName(UniqueFormalParameters){GeneratorBody}  Return the result of ComputedPropertyContains for PropertyName with argument symbol.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.4.4">
	<buginformation>
		<summary>Static Semantics: Contains</summary>
		<description>With parameter symbol.   GeneratorDeclaration:function*BindingIdentifier(FormalParameters){GeneratorBody}   GeneratorDeclaration:function*(FormalParameters){GeneratorBody}   GeneratorExpression:function*BindingIdentifieropt(FormalParameters){GeneratorBody}  Return false.        Note Static semantic rules that depend upon substructure generally do not look into function definitions.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.4.5">
	<buginformation>
		<summary>Static Semantics: HasDirectSuper</summary>
		<description>GeneratorMethod:*PropertyName(UniqueFormalParameters){GeneratorBody}  If UniqueFormalParameters Contains SuperCall is true, return true.Return GeneratorBody Contains SuperCall.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.4.6">
	<buginformation>
		<summary>Static Semantics: HasName</summary>
		<description>GeneratorExpression:function*(FormalParameters){GeneratorBody}  Return false.         GeneratorExpression:function*BindingIdentifier(FormalParameters){GeneratorBody}  Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.4.7">
	<buginformation>
		<summary>Static Semantics: IsConstantDeclaration</summary>
		<description>GeneratorDeclaration:function*BindingIdentifier(FormalParameters){GeneratorBody}   GeneratorDeclaration:function*(FormalParameters){GeneratorBody}  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.4.8">
	<buginformation>
		<summary>Static Semantics: IsFunctionDefinition</summary>
		<description>GeneratorExpression:function*BindingIdentifieropt(FormalParameters){GeneratorBody}  Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.4.9">
	<buginformation>
		<summary>Static Semantics: PropName</summary>
		<description>GeneratorMethod:*PropertyName(UniqueFormalParameters){GeneratorBody}  Return PropName of PropertyName.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.4.10">
	<buginformation>
		<summary>Runtime Semantics: EvaluateBody</summary>
		<description>With parameters functionObject and List argumentsList.   GeneratorBody:FunctionBody  Perform ? FunctionDeclarationInstantiation(functionObject, argumentsList).Let G be ? OrdinaryCreateFromConstructor(functionObject, &amp;quot;%GeneratorPrototype%&amp;quot;, « [[GeneratorState]], [[GeneratorContext]] »).Perform GeneratorStart(G, FunctionBody).Return Completion{[[Type]]: return, [[Value]]: G, [[Target]]: empty}.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.4.11">
	<buginformation>
		<summary>Runtime Semantics: InstantiateFunctionObject</summary>
		<description>With parameter scope.   GeneratorDeclaration:function*BindingIdentifier(FormalParameters){GeneratorBody}  If the function code for GeneratorDeclaration is strict mode code, let strict be true. Otherwise let strict be false.Let name be StringValue of BindingIdentifier.Let F be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, strict).Let prototype be ObjectCreate(%GeneratorPrototype%).Perform DefinePropertyOrThrow(F, &amp;quot;prototype&amp;quot;, PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).Perform SetFunctionName(F, name).Return F.         GeneratorDeclaration:function*(FormalParameters){GeneratorBody}  Let F be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, true).Let prototype be ObjectCreate(%GeneratorPrototype%).Perform DefinePropertyOrThrow(F, &amp;quot;prototype&amp;quot;, PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).Perform SetFunctionName(F, &amp;quot;default&amp;quot;).Return F.        Note An anonymous GeneratorDeclaration can only occur as part of an export default declaration, and its function code is therefore always strict mode code.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.4.12">
	<buginformation>
		<summary>Runtime Semantics: PropertyDefinitionEvaluation</summary>
		<description>With parameters object and enumerable.   GeneratorMethod:*PropertyName(UniqueFormalParameters){GeneratorBody}  Let propKey be the result of evaluating PropertyName.ReturnIfAbrupt(propKey).If the function code for this GeneratorMethod is strict mode code, let strict be true. Otherwise let strict be false.Let scope be the running execution context&apos;s LexicalEnvironment.Let closure be GeneratorFunctionCreate(Method, UniqueFormalParameters, GeneratorBody, scope, strict).Perform MakeMethod(closure, object).Let prototype be ObjectCreate(%GeneratorPrototype%).Perform DefinePropertyOrThrow(closure, &amp;quot;prototype&amp;quot;, PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).Perform SetFunctionName(closure, propKey).Let desc be the PropertyDescriptor{[[Value]]: closure, [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true}.Return ? DefinePropertyOrThrow(object, propKey, desc).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.4.13">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>GeneratorExpression:function*(FormalParameters){GeneratorBody}  If the function code for this GeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.Let scope be the LexicalEnvironment of the running execution context.Let closure be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, strict).Let prototype be ObjectCreate(%GeneratorPrototype%).Perform DefinePropertyOrThrow(closure, &amp;quot;prototype&amp;quot;, PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).Return closure.         GeneratorExpression:function*BindingIdentifier(FormalParameters){GeneratorBody}  If the function code for this GeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.Let scope be the running execution context&apos;s LexicalEnvironment.Let funcEnv be NewDeclarativeEnvironment(scope).Let envRec be funcEnv&apos;s EnvironmentRecord.Let name be StringValue of BindingIdentifier.Perform envRec.CreateImmutableBinding(name, false).Let closure be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, funcEnv, strict).Let prototype be ObjectCreate(%GeneratorPrototype%).Perform DefinePropertyOrThrow(closure, &amp;quot;prototype&amp;quot;, PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).Perform SetFunctionName(closure, name).Perform envRec.InitializeBinding(name, closure).Return closure.        Note The BindingIdentifier in a GeneratorExpression can be referenced from inside the GeneratorExpression&apos;s FunctionBody to allow the generator code to call itself recursively. However, unlike in a GeneratorDeclaration, the BindingIdentifier in a GeneratorExpression cannot be referenced from and does not affect the scope enclosing the GeneratorExpression.   YieldExpression:yield  Return ? GeneratorYield(CreateIterResultObject(undefined, false)).         YieldExpression:yieldAssignmentExpression  Let exprRef be the result of evaluating AssignmentExpression.Let value be ? GetValue(exprRef).Return ? GeneratorYield(CreateIterResultObject(value, false)).         YieldExpression:yield*AssignmentExpression  Let exprRef be the result of evaluating AssignmentExpression.Let value be ? GetValue(exprRef).Let iterator be ? GetIterator(value).Let received be NormalCompletion(undefined).Repeat,If received.[[Type]] is normal, thenLet innerResult be ? IteratorNext(iterator, received.[[Value]]).Let done be ? IteratorComplete(innerResult).If done is true, thenReturn ? IteratorValue(innerResult).Set received to GeneratorYield(innerResult).Else if received.[[Type]] is throw, thenLet throw be ? GetMethod(iterator, &amp;quot;throw&amp;quot;).If throw is not undefined, thenLet innerResult be ? Call(throw, iterator, « received.[[Value]] »).NOTE: Exceptions from the inner iterator throw method are propagated. Normal completions from an inner throw method are processed similarly to an inner next.If Type(innerResult) is not Object, throw a TypeError exception.Let done be ? IteratorComplete(innerResult).If done is true, thenReturn ? IteratorValue(innerResult).Set received to GeneratorYield(innerResult).Else,NOTE: If iterator does not have a throw method, this throw is going to terminate the yield* loop. But first we need to give iterator a chance to clean up.Perform ? IteratorClose(iterator, Completion{[[Type]]: normal, [[Value]]: empty, [[Target]]: empty}).NOTE: The next step throws a TypeError to indicate that there was a yield* protocol violation: iterator does not have a throw method.Throw a TypeError exception.Else,Assert: received.[[Type]] is return.Let return be ? GetMethod(iterator, &amp;quot;return&amp;quot;).If return is undefined, return Completion(received).Let innerReturnResult be ? Call(return, iterator, « received.[[Value]] »).If Type(innerReturnResult) is not Object, throw a TypeError exception.Let done be ? IteratorComplete(innerReturnResult).If done is true, thenLet value be ? IteratorValue(innerReturnResult).Return Completion{[[Type]]: return, [[Value]]: value, [[Target]]: empty}.Set received to GeneratorYield(innerReturnResult).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.5.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>ClassTail:ClassHeritageopt{ClassBody}    It is a Syntax Error if ClassHeritage is not present and the following algorithm evaluates to true: Let constructor be ConstructorMethod of ClassBody.If constructor is empty, return false.Return HasDirectSuper of constructor.               ClassBody:ClassElementList              It is a Syntax Error if PrototypePropertyNameList of ClassElementList contains more than one occurrence of &amp;quot;constructor&amp;quot;.                     ClassElement:MethodDefinition              It is a Syntax Error if PropName of MethodDefinition is not &amp;quot;constructor&amp;quot; and HasDirectSuper of MethodDefinition is true.                              It is a Syntax Error if PropName of MethodDefinition is &amp;quot;constructor&amp;quot; and SpecialMethod of MethodDefinition is true.                     ClassElement:staticMethodDefinition              It is a Syntax Error if HasDirectSuper of MethodDefinition is true.                              It is a Syntax Error if PropName of MethodDefinition is &amp;quot;prototype&amp;quot;.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.5.2">
	<buginformation>
		<summary>Static Semantics: BoundNames</summary>
		<description>ClassDeclaration:classBindingIdentifierClassTail  Return the BoundNames of BindingIdentifier.         ClassDeclaration:classClassTail  Return « &amp;quot;*default*&amp;quot; ».</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.5.3">
	<buginformation>
		<summary>Static Semantics: ConstructorMethod</summary>
		<description>ClassElementList:ClassElement  If ClassElement is  ClassElement:;  , return empty.If IsStatic of ClassElement is true, return empty.If PropName of ClassElement is not &amp;quot;constructor&amp;quot;, return empty.Return ClassElement.         ClassElementList:ClassElementListClassElement  Let head be ConstructorMethod of ClassElementList.If head is not empty, return head.If ClassElement is  ClassElement:;  , return empty.If IsStatic of ClassElement is true, return empty.If PropName of ClassElement is not &amp;quot;constructor&amp;quot;, return empty.Return ClassElement.        Note Early Error rules ensure that there is only one method definition named &amp;quot;constructor&amp;quot; and that it is not an accessor property or generator definition.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.5.4">
	<buginformation>
		<summary>Static Semantics: Contains</summary>
		<description>With parameter symbol.   ClassTail:ClassHeritageopt{ClassBody}  If symbol is ClassBody, return true.If symbol is ClassHeritage, thenIf ClassHeritage is present, return true; otherwise return false.Let inHeritage be ClassHeritage Contains symbol.If inHeritage is true, return true.Return the result of ComputedPropertyContains for ClassBody with argument symbol.        Note Static semantic rules that depend upon substructure generally do not look into class bodies except for PropertyNames.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.5.5">
	<buginformation>
		<summary>Static Semantics: ComputedPropertyContains</summary>
		<description>With parameter symbol.   ClassElementList:ClassElementListClassElement  Let inList be the result of ComputedPropertyContains for ClassElementList with argument symbol.If inList is true, return true.Return the result of ComputedPropertyContains for ClassElement with argument symbol.         ClassElement:MethodDefinition  Return the result of ComputedPropertyContains for MethodDefinition with argument symbol.         ClassElement:staticMethodDefinition  Return the result of ComputedPropertyContains for MethodDefinition with argument symbol.         ClassElement:;  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.5.6">
	<buginformation>
		<summary>Static Semantics: HasName</summary>
		<description>ClassExpression:classClassTail  Return false.         ClassExpression:classBindingIdentifierClassTail  Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.5.7">
	<buginformation>
		<summary>Static Semantics: IsConstantDeclaration</summary>
		<description>ClassDeclaration:classBindingIdentifierClassTail   ClassDeclaration:classClassTail  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.5.8">
	<buginformation>
		<summary>Static Semantics: IsFunctionDefinition</summary>
		<description>ClassExpression:classBindingIdentifieroptClassTail  Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.5.9">
	<buginformation>
		<summary>Static Semantics: IsStatic</summary>
		<description>ClassElement:MethodDefinition  Return false.         ClassElement:staticMethodDefinition  Return true.         ClassElement:;  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.5.10">
	<buginformation>
		<summary>Static Semantics: NonConstructorMethodDefinitions</summary>
		<description>ClassElementList:ClassElement  If ClassElement is  ClassElement:;  , return a new empty List.If IsStatic of ClassElement is false and PropName of ClassElement is &amp;quot;constructor&amp;quot;, return a new empty List.Return a List containing ClassElement.         ClassElementList:ClassElementListClassElement  Let list be NonConstructorMethodDefinitions of ClassElementList.If ClassElement is  ClassElement:;  , return list.If IsStatic of ClassElement is false and PropName of ClassElement is &amp;quot;constructor&amp;quot;, return list.Append ClassElement to the end of list.Return list.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.5.11">
	<buginformation>
		<summary>Static Semantics: PrototypePropertyNameList</summary>
		<description>ClassElementList:ClassElement  If PropName of ClassElement is empty, return a new empty List.If IsStatic of ClassElement is true, return a new empty List.Return a List containing PropName of ClassElement.         ClassElementList:ClassElementListClassElement  Let list be PrototypePropertyNameList of ClassElementList.If PropName of ClassElement is empty, return list.If IsStatic of ClassElement is true, return list.Append PropName of ClassElement to the end of list.Return list.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.5.12">
	<buginformation>
		<summary>Static Semantics: PropName</summary>
		<description>ClassElement:;  Return empty.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.5.13">
	<buginformation>
		<summary>Runtime Semantics: ClassDefinitionEvaluation</summary>
		<description>With parameter className.  ClassTail:ClassHeritageopt{ClassBodyopt}  Let lex be the LexicalEnvironment of the running execution context.Let classScope be NewDeclarativeEnvironment(lex).Let classScopeEnvRec be classScope&apos;s EnvironmentRecord.If className is not undefined, thenPerform classScopeEnvRec.CreateImmutableBinding(className, true).If ClassHeritageopt is not present, thenLet protoParent be the intrinsic object %ObjectPrototype%.Let constructorParent be the intrinsic object %FunctionPrototype%.Else,Set the running execution context&apos;s LexicalEnvironment to classScope.Let superclass be the result of evaluating ClassHeritage.Set the running execution context&apos;s LexicalEnvironment to lex.ReturnIfAbrupt(superclass).If superclass is null, thenLet protoParent be null.Let constructorParent be the intrinsic object %FunctionPrototype%.Else if IsConstructor(superclass) is false, throw a TypeError exception.Else,Let protoParent be ? Get(superclass, &amp;quot;prototype&amp;quot;).If Type(protoParent) is neither Object nor Null, throw a TypeError exception.Let constructorParent be superclass.Let proto be ObjectCreate(protoParent).If ClassBodyopt is not present, let constructor be empty.Else, let constructor be ConstructorMethod of ClassBody.If constructor is empty, thenIf ClassHeritageopt is present, thenSet constructor to the result of parsing the source text               constructor(... args){ super (...args);}               using the syntactic grammar with the goal symbol MethodDefinition[~Yield, ~Await].Else,Set constructor to the result of parsing the source text               constructor( ){ }               using the syntactic grammar with the goal symbol MethodDefinition[~Yield, ~Await].Set the running execution context&apos;s LexicalEnvironment to classScope.Let constructorInfo be the result of performing DefineMethod for constructor with arguments proto and constructorParent as the optional functionPrototype argument.Assert: constructorInfo is not an abrupt completion.Let F be constructorInfo.[[Closure]].If ClassHeritageopt is present, set F.[[ConstructorKind]] to &amp;quot;derived&amp;quot;.Perform MakeConstructor(F, false, proto).Perform MakeClassConstructor(F).Perform CreateMethodProperty(proto, &amp;quot;constructor&amp;quot;, F).If ClassBodyopt is not present, let methods be a new empty List.Else, let methods be NonConstructorMethodDefinitions of ClassBody.For each ClassElement m in order from methods, doIf IsStatic of m is false, thenLet status be the result of performing PropertyDefinitionEvaluation for m with arguments proto and false.Else,Let status be the result of performing PropertyDefinitionEvaluation for m with arguments F and false.If status is an abrupt completion, thenSet the running execution context&apos;s LexicalEnvironment to lex.Return Completion(status).Set the running execution context&apos;s LexicalEnvironment to lex.If className is not undefined, thenPerform classScopeEnvRec.InitializeBinding(className, F).Return F.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.5.14">
	<buginformation>
		<summary>Runtime Semantics: BindingClassDeclarationEvaluation</summary>
		<description>ClassDeclaration:classBindingIdentifierClassTail  Let className be StringValue of BindingIdentifier.Let value be the result of ClassDefinitionEvaluation of ClassTail with argument className.ReturnIfAbrupt(value).Let hasNameProperty be ? HasOwnProperty(value, &amp;quot;name&amp;quot;).If hasNameProperty is false, perform SetFunctionName(value, className).Let env be the running execution context&apos;s LexicalEnvironment.Perform ? InitializeBoundName(className, value, env).Return value.         ClassDeclaration:classClassTail  Return the result of ClassDefinitionEvaluation of ClassTail with argument undefined.        Note  ClassDeclaration:classClassTail  only occurs as part of an ExportDeclaration  and the setting of a name property and establishing its binding are  handled as part of the evaluation action for that production. See  15.2.3.11.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.5.15">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>ClassDeclaration:classBindingIdentifierClassTail  Let status be the result of BindingClassDeclarationEvaluation of this ClassDeclaration.ReturnIfAbrupt(status).Return NormalCompletion(empty).        Note 1  ClassDeclaration:classClassTail  only occurs as part of an ExportDeclaration and is never directly evaluated.   ClassExpression:classBindingIdentifieroptClassTail  If BindingIdentifieropt is not present, let className be undefined.Else, let className be StringValue of BindingIdentifier.Let value be the result of ClassDefinitionEvaluation of ClassTail with argument className.ReturnIfAbrupt(value).If className is not undefined, thenLet hasNameProperty be ? HasOwnProperty(value, &amp;quot;name&amp;quot;).If hasNameProperty is false, thenPerform SetFunctionName(value, className).Return NormalCompletion(value).        Note 2 If the class definition included a name static method then that method is not over-written with a name data property for the class name.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.6.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>AsyncMethod:async[no LineTerminator here]PropertyName(UniqueFormalParameters){AsyncFunctionBody}   It is a Syntax Error if ContainsUseStrict of AsyncFunctionBody is true and IsSimpleParameterList of UniqueFormalParameters is false. It is a Syntax Error if HasDirectSuper of AsyncMethod is true. It is a Syntax Error if UniqueFormalParameters Contains AwaitExpression is true. It is a Syntax Error if any element of the BoundNames of UniqueFormalParameters also occurs in the LexicallyDeclaredNames of AsyncFunctionBody.   AsyncFunctionDeclaration:async[no LineTerminator here]functionBindingIdentifier(FormalParameters){AsyncFunctionBody}   AsyncFunctionDeclaration:async[no LineTerminator here]function(FormalParameters){AsyncFunctionBody}   AsyncFunctionExpression:async[no LineTerminator here]function(FormalParameters){AsyncFunctionBody}   AsyncFunctionExpression:async[no LineTerminator here]functionBindingIdentifier(FormalParameters){AsyncFunctionBody}   It is a Syntax Error if ContainsUseStrict of AsyncFunctionBody is true and IsSimpleParameterList of FormalParameters is false. It is a Syntax Error if FormalParameters Contains AwaitExpression is true. If the source code matching this production is strict code, the Early Error rules for   UniqueFormalParameters:FormalParameters  are applied. If the source code matching this production is strict code, it is a Syntax Error if BindingIdentifier is the IdentifierName eval or the IdentifierName arguments. It is a Syntax Error if any element of the BoundNames of FormalParameters also occurs in the LexicallyDeclaredNames of AsyncFunctionBody. It is a Syntax Error if FormalParameters Contains SuperProperty is true. It is a Syntax Error if AsyncFunctionBody Contains SuperProperty is true. It is a Syntax Error if FormalParameters Contains SuperCall is true. It is a Syntax Error if AsyncFunctionBody Contains SuperCall is true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.6.2">
	<buginformation>
		<summary>Static Semantics: BoundNames</summary>
		<description>AsyncFunctionDeclaration:async[no LineTerminator here]functionBindingIdentifier(FormalParameters){AsyncFunctionBody}  Return the BoundNames of BindingIdentifier.         AsyncFunctionDeclaration:async[no LineTerminator here]function(FormalParameters){AsyncFunctionBody}  Return «&amp;quot;*default*&amp;quot;».        Note&amp;quot;*default*&amp;quot;  is used within this specification as a synthetic name for hoistable  anonymous functions that are defined using export declarations.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.6.3">
	<buginformation>
		<summary>Static Semantics: ComputedPropertyContains</summary>
		<description>With parameter symbol.  AsyncMethod:async[no LineTerminator here]PropertyName(UniqueFormalParameters){AsyncFunctionBody}  Return the result of ComputedPropertyContains for PropertyName with argument symbol.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.6.4">
	<buginformation>
		<summary>Static Semantics: Contains</summary>
		<description>With parameter symbol.  AsyncFunctionDeclaration:async[no LineTerminator here]functionBindingIdentifier(FormalParameters){AsyncFunctionBody}   AsyncFunctionDeclaration:async[no LineTerminator here]function(FormalParameters){AsyncFunctionBody}   AsyncFunctionExpression:async[no LineTerminator here]function(FormalParameters){AsyncFunctionBody}   AsyncFunctionExpression:async[no LineTerminator here]functionBindingIdentifier(FormalParameters){AsyncFunctionBody}  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.6.5">
	<buginformation>
		<summary>Static Semantics: HasDirectSuper</summary>
		<description>AsyncMethod:async[no LineTerminator here]PropertyName(UniqueFormalParameters){AsyncFunctionBody}  If UniqueFormalParameters Contains SuperCall is true, return true.Return AsyncFunctionBody Contains SuperCall.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.6.6">
	<buginformation>
		<summary>Static Semantics: HasName</summary>
		<description>AsyncFunctionExpression:async[no LineTerminator here]function(FormalParameters){AsyncFunctionBody}  Return false.         AsyncFunctionExpression:async[no LineTerminator here]functionBindingIdentifier(FormalParameters){AsyncFunctionBody}  Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.6.7">
	<buginformation>
		<summary>Static Semantics: IsConstantDeclaration</summary>
		<description>AsyncFunctionDeclaration:async[no LineTerminator here]functionBindingIdentifier(FormalParameters){AsyncFunctionBody}   AsyncFunctionDeclaration:async[no LineTerminator here]function(FormalParameters){AsyncFunctionBody}  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.6.8">
	<buginformation>
		<summary>Static Semantics: IsFunctionDefinition</summary>
		<description>AsyncFunctionExpression:async[no LineTerminator here]function(FormalParameters){AsyncFunctionBody}   AsyncFunctionExpression:async[no LineTerminator here]functionBindingIdentifier(FormalParameters){AsyncFunctionBody}  Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.6.9">
	<buginformation>
		<summary>Static Semantics: PropName</summary>
		<description>AsyncMethod:async[no LineTerminator here]PropertyName(UniqueFormalParameters){AsyncFunctionBody}  Return PropName of PropertyName.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.6.10">
	<buginformation>
		<summary>Runtime Semantics: InstantiateFunctionObject</summary>
		<description>With parameter scope.  AsyncFunctionDeclaration:async[no LineTerminator here]functionBindingIdentifier(FormalParameters){AsyncFunctionBody}  If the function code for AsyncFunctionDeclaration is strict mode code, let strict be true. Otherwise, let strict be false.Let name be StringValue of BindingIdentifier.Let F be ! AsyncFunctionCreate(Normal, FormalParameters, AsyncFunctionBody, scope, strict).Perform ! SetFunctionName(F, name).Return F.         AsyncFunctionDeclaration:async[no LineTerminator here]function(FormalParameters){AsyncFunctionBody}  If the function code for AsyncFunctionDeclaration is strict mode code, let strict be true. Otherwise, let strict be false.Let F be ! AsyncFunctionCreate(Normal, FormalParameters, AsyncFunctionBody, scope, strict).Perform ! SetFunctionName(F, &amp;quot;default&amp;quot;).Return F.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.6.11">
	<buginformation>
		<summary>Runtime Semantics: EvaluateBody</summary>
		<description>With parameters functionObject and List argumentsList.  AsyncFunctionBody:FunctionBody  Let promiseCapability be ! NewPromiseCapability(%Promise%).Let declResult be ! FunctionDeclarationInstantiation(functionObject, argumentsList).If declResult is not an abrupt completion, thenPerform ! AsyncFunctionStart(promiseCapability, FunctionBody).Else declResult is an abrupt completion,Perform ! Call(promiseCapability.[[Reject]], undefined, «declResult.[[Value]]»).Return Completion{[[Type]]: return, [[Value]]: promiseCapability.[[Promise]], [[Target]]: empty}.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.6.12">
	<buginformation>
		<summary>Runtime Semantics: PropertyDefinitionEvaluation</summary>
		<description>With parameters object and enumerable.  AsyncMethod:async[no LineTerminator here]PropertyName(UniqueFormalParameters){AsyncFunctionBody}  Let propKey be the result of evaluating PropertyName.ReturnIfAbrupt(propKey).If the function code for this AsyncMethod is strict mode code, let strict be true. Otherwise let strict be false.Let scope be the LexicalEnvironment of the running execution context.Let closure be ! AsyncFunctionCreate(Method, UniqueFormalParameters, AsyncFunctionBody, scope, strict).Perform ! MakeMethod(closure, object).Perform ! SetFunctionName(closure, propKey).Let desc be the PropertyDescriptor{[[Value]]: closure, [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true}.Return ? DefinePropertyOrThrow(object, propKey, desc).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.6.13">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>AsyncFunctionDeclaration:async[no LineTerminator here]functionBindingIdentifier(FormalParameters){AsyncFunctionBody}  Return NormalCompletion(empty).         AsyncFunctionDeclaration:async[no LineTerminator here]function(FormalParameters){AsyncFunctionBody}  Return NormalCompletion(empty).         AsyncFunctionExpression:async[no LineTerminator here]function(FormalParameters){AsyncFunctionBody}  If the function code for AsyncFunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.Let scope be the LexicalEnvironment of the running execution context.Let closure be ! AsyncFunctionCreate(Normal, FormalParameters, AsyncFunctionBody, scope, strict).Return closure.         AsyncFunctionExpression:async[no LineTerminator here]functionBindingIdentifier(FormalParameters){AsyncFunctionBody}  If the function code for AsyncFunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.Let scope be the LexicalEnvironment of the running execution context.Let funcEnv be ! NewDeclarativeEnvironment(scope).Let envRec be funcEnv&apos;s EnvironmentRecord.Let name be StringValue of BindingIdentifier.Perform ! envRec.CreateImmutableBinding(name).Let closure be ! AsyncFunctionCreate(Normal, FormalParameters, AsyncFunctionBody, funcEnv, strict).Perform ! SetFunctionName(closure, name).Perform ! envRec.InitializeBinding(name, closure).Return closure.         AwaitExpression:awaitUnaryExpression  Let exprRef be the result of evaluating UnaryExpression.Let value be ? GetValue(exprRef).Return ? AsyncFunctionAwait(value).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.7.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>AsyncArrowFunction:async[no LineTerminator here]AsyncArrowBindingIdentifier[no LineTerminator here]</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.7.2">
	<buginformation>
		<summary>Static Semantics: CoveredAsyncArrowHead</summary>
		<description>CoverCallExpressionAndAsyncArrowHead:MemberExpressionArguments  Return the result of parsing the lexical token stream matched by CoverCallExpressionAndAsyncArrowHead using AsyncArrowHead as the goal symbol.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.7.3">
	<buginformation>
		<summary>Static Semantics: BoundNames</summary>
		<description>CoverCallExpressionAndAsyncArrowHead:MemberExpressionArguments  Let head be CoveredAsyncArrowHead of CoverCallExpressionAndAsyncArrowHead.Return the BoundNames of head.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.7.4">
	<buginformation>
		<summary>Static Semantics: Contains</summary>
		<description>With parameter symbol.  AsyncArrowFunction:async[no LineTerminator here]AsyncArrowBindingIdentifier[no LineTerminator here]</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.7.5">
	<buginformation>
		<summary>Static Semantics: ContainsExpression</summary>
		<description>AsyncArrowBindingIdentifier:BindingIdentifier  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.7.6">
	<buginformation>
		<summary>Static Semantics: ExpectedArgumentCount</summary>
		<description>AsyncArrowBindingIdentifier:BindingIdentifier  Return 1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.7.7">
	<buginformation>
		<summary>Static Semantics: HasName</summary>
		<description>AsyncArrowFunction:async[no LineTerminator here]AsyncArrowBindingIdentifier[no LineTerminator here]</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.7.8">
	<buginformation>
		<summary>Static Semantics: IsSimpleParameterList</summary>
		<description>AsyncArrowBindingIdentifier[Yield]:BindingIdentifier[?Yield, +Await]  Return true.         CoverCallExpressionAndAsyncArrowHead:MemberExpressionArguments  Let head be CoveredAsyncArrowHead of CoverCallExpressionAndAsyncArrowHead.Return IsSimpleParameterList of head.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.7.9">
	<buginformation>
		<summary>Static Semantics: LexicallyDeclaredNames</summary>
		<description>AsyncConciseBody:[lookahead ≠ {]AssignmentExpression  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.7.10">
	<buginformation>
		<summary>Static Semantics: LexicallyScopedDeclarations</summary>
		<description>AsyncConciseBody:[lookahead ≠ {]AssignmentExpression  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.7.11">
	<buginformation>
		<summary>Static Semantics: VarDeclaredNames</summary>
		<description>AsyncConciseBody:[lookahead ≠ {]AssignmentExpression  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.7.12">
	<buginformation>
		<summary>Static Semantics: VarScopedDeclarations</summary>
		<description>AsyncConciseBody:[lookahead ≠ {]AssignmentExpression  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.7.13">
	<buginformation>
		<summary>Runtime Semantics: IteratorBindingInitialization</summary>
		<description>With parameters iteratorRecord and environment.  AsyncArrowBindingIdentifier:BindingIdentifier  Assert: iteratorRecord.[[Done]] is false.Let next be ? IteratorStep(iteratorRecord.[[Iterator]]).If next is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(next).If next is false, set iteratorRecord.[[Done]] to true.Else,Let v be ? IteratorValue(next).If v is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(v).If iteratorRecord.[[Done]] is true, let v be undefined.Return the result of performing BindingInitialization for BindingIdentifier using v and environment as the arguments.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.7.14">
	<buginformation>
		<summary>Runtime Semantics: EvaluateBody</summary>
		<description>With parameters functionObject and List argumentsList.  AsyncConciseBody:[lookahead ≠ {]AssignmentExpression  Let promiseCapability be ! NewPromiseCapability(%Promise%).Let declResult be ! FunctionDeclarationInstantiation(functionObject, argumentsList).If declResult is not an abrupt completion, thenPerform ! AsyncFunctionStart(promiseCapability, AssignmentExpression).Else declResult is an abrupt completion,Perform ! Call(promiseCapability.[[Reject]], undefined, «declResult.[[Value]]»).Return Completion{[[Type]]: return, [[Value]]: promiseCapability.[[Promise]], [[Target]]: empty}.         AsyncConciseBody:{AsyncFunctionBody}  Return the result of EvaluateBody of AsyncFunctionBody passing functionObject and argumentsList as the arguments.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.7.15">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>AsyncArrowFunction:async[no LineTerminator here]AsyncArrowBindingIdentifier[no LineTerminator here]</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.8.1">
	<buginformation>
		<summary>Static Semantics: IsInTailPosition( call )</summary>
		<description>The abstract operation IsInTailPosition with argument call performs the following steps: Assert: call is a Parse Node.If the source code matching call is non-strict code, return false.If call is not contained within a FunctionBody, ConciseBody, or AsyncConciseBody, return false.Let body be the FunctionBody, ConciseBody, or AsyncConciseBody that most closely contains call.If body is the FunctionBody of a GeneratorBody, return false.If body is the FunctionBody of an AsyncFunctionBody, return false.If body is an AsyncConciseBody, return false.Return the result of HasCallInTailPosition of body with argument call.        Note Tail Position calls are only defined in strict mode code because of a common non-standard language extension (see  9.2.7) that enables observation of the chain of caller contexts.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.8.2.1">
	<buginformation>
		<summary>Statement Rules</summary>
		<description>ConciseBody:AssignmentExpression  Return HasCallInTailPosition of AssignmentExpression with argument call.           StatementList:StatementListStatementListItem  Let has be HasCallInTailPosition of StatementList with argument call.If has is true, return true.Return HasCallInTailPosition of StatementListItem with argument call.           FunctionStatementList:[empty]   StatementListItem:Declaration   Statement:VariableStatement EmptyStatement ExpressionStatement ContinueStatement BreakStatement ThrowStatement DebuggerStatement   Block:{}   ReturnStatement:return;   LabelledItem:FunctionDeclaration   IterationStatement:for(LeftHandSideExpressionofAssignmentExpression)Statement for(varForBindingofAssignmentExpression)Statement for(ForDeclarationofAssignmentExpression)Statement   CaseBlock:{}  Return false.           IfStatement:if(Expression)StatementelseStatement  Let has be HasCallInTailPosition of the first Statement with argument call.If has is true, return true.Return HasCallInTailPosition of the second Statement with argument call.           IfStatement:if(Expression)Statement   IterationStatement:doStatementwhile(Expression); while(Expression)Statement for(Expressionopt;Expressionopt;Expressionopt)Statement for(varVariableDeclarationList;Expressionopt;Expressionopt)Statement for(LexicalDeclarationExpressionopt;Expressionopt)Statement for(LeftHandSideExpressioninExpression)Statement for(varForBindinginExpression)Statement for(ForDeclarationinExpression)Statement   WithStatement:with(Expression)Statement  Return HasCallInTailPosition of Statement with argument call.           LabelledStatement:LabelIdentifier:LabelledItem  Return HasCallInTailPosition of LabelledItem with argument call.           ReturnStatement:returnExpression;  Return HasCallInTailPosition of Expression with argument call.           SwitchStatement:switch(Expression)CaseBlock  Return HasCallInTailPosition of CaseBlock with argument call.           CaseBlock:{CaseClausesoptDefaultClauseCaseClausesopt}  Let has be false.If the first CaseClauses is present, let has be HasCallInTailPosition of the first CaseClauses with argument call.If has is true, return true.Let has be HasCallInTailPosition of the DefaultClause with argument call.If has is true, return true.If the second CaseClauses is present, let has be HasCallInTailPosition of the second CaseClauses with argument call.Return has.           CaseClauses:CaseClausesCaseClause  Let has be HasCallInTailPosition of CaseClauses with argument call.If has is true, return true.Return HasCallInTailPosition of CaseClause with argument call.           CaseClause:caseExpression:StatementListopt   DefaultClause:default:StatementListopt  If StatementList is present, return HasCallInTailPosition of StatementList with argument call.Return false.           TryStatement:tryBlockCatch  Return HasCallInTailPosition of Catch with argument call.           TryStatement:tryBlockFinally   TryStatement:tryBlockCatchFinally  Return HasCallInTailPosition of Finally with argument call.           Catch:catch(CatchParameter)Block  Return HasCallInTailPosition of Block with argument call.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.8.2.2">
	<buginformation>
		<summary>Expression Rules</summary>
		<description>Note A potential tail position call that is immediately followed by return GetValue of the call result is also a possible tail position call. Function calls cannot return reference values, so such a GetValue operation will always return the same value as the actual function call result.   AssignmentExpression:YieldExpression ArrowFunction AsyncArrowFunction LeftHandSideExpression</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="14.8.3">
	<buginformation>
		<summary>Runtime Semantics: PrepareForTailCall ( )</summary>
		<description>The abstract operation PrepareForTailCall performs the following steps: Let leafContext be the running execution context.Suspend leafContext.Pop leafContext from the execution context stack. The execution context now on the top of the stack becomes the running execution context.Assert: leafContext has no further use. It will never be activated as the running execution context.        A tail position call must either release any transient internal resources associated with the currently executing function execution context before invoking the target function or reuse those resources in support of the target function. Note For example, a tail position call should only grow an  implementation&apos;s activation record stack by the amount that the size of  the target function&apos;s activation record exceeds the size of the calling  function&apos;s activation record. If the target function&apos;s activation record  is smaller, then the total size of the stack should decrease.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.1.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>Script:ScriptBody              It is a Syntax Error if the LexicallyDeclaredNames of ScriptBody contains any duplicate entries.                              It is a Syntax Error if any element of the LexicallyDeclaredNames of ScriptBody also occurs in the VarDeclaredNames of ScriptBody.                     ScriptBody:StatementList              It is a Syntax Error if StatementList Contains super unless the source code containing super is eval code that is being processed by a direct eval. Additional early error rules for super within direct eval are defined in  18.2.1.1.                              It is a Syntax Error if StatementList Contains NewTarget unless the source code containing NewTarget is eval code that is being processed by a direct eval. Additional early error rules for NewTarget in direct eval are defined in  18.2.1.1.                              It is a Syntax Error if ContainsDuplicateLabels of StatementList with argument « » is true.                              It is a Syntax Error if ContainsUndefinedBreakTarget of StatementList with argument « » is true.                              It is a Syntax Error if ContainsUndefinedContinueTarget of StatementList with arguments « » and « » is true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.1.2">
	<buginformation>
		<summary>Static Semantics: IsStrict</summary>
		<description>ScriptBody:StatementList  If the Directive Prologue of StatementList contains a Use Strict Directive, return true; otherwise, return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.1.3">
	<buginformation>
		<summary>Static Semantics: LexicallyDeclaredNames</summary>
		<description>ScriptBody:StatementList  Return TopLevelLexicallyDeclaredNames of StatementList.        Note At the top level of a Script, function declarations are treated like var declarations rather than like lexical declarations.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.1.4">
	<buginformation>
		<summary>Static Semantics: LexicallyScopedDeclarations</summary>
		<description>ScriptBody:StatementList  Return TopLevelLexicallyScopedDeclarations of StatementList.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.1.5">
	<buginformation>
		<summary>Static Semantics: VarDeclaredNames</summary>
		<description>ScriptBody:StatementList  Return TopLevelVarDeclaredNames of StatementList.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.1.6">
	<buginformation>
		<summary>Static Semantics: VarScopedDeclarations</summary>
		<description>ScriptBody:StatementList  Return TopLevelVarScopedDeclarations of StatementList.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.1.7">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>Script:[empty]  Return NormalCompletion(undefined).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.1.8">
	<buginformation>
		<summary>Script Records</summary>
		<description>A  Script Record encapsulates information about a script being evaluated. Each script record contains the fields listed in  Table 36. Table 36: Script Record Fields                   Field Name                                          Value Type                                          Meaning                                              [[Realm]]                            Realm Record | undefined                 The realm within which this script was created. undefined if not yet assigned.                                            [[Environment]]                            Lexical Environment | undefined                 The Lexical Environment containing the top level bindings for this script. This field is set when the script is instantiated.                                            [[ECMAScriptCode]]                                          a Parse Node                 The result of parsing the source text of this module using Script as the goal symbol.                                            [[HostDefined]]                                          Any, default value is undefined.                                          Field reserved for use by host environments that need to associate additional information with a script.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.1.9">
	<buginformation>
		<summary>ParseScript ( sourceText, realm, hostDefined )</summary>
		<description>The abstract operation ParseScript with arguments sourceText, realm, and hostDefined creates a Script Record based upon the result of parsing sourceText as a Script. ParseScript performs the following steps: Assert: sourceText is an ECMAScript source text (see clause 10).Parse sourceText using Script as the goal symbol and analyse the parse result for any Early Error conditions. If the parse was successful and no early errors were found, let body be the resulting parse tree. Otherwise, let body be a List of one or more SyntaxError or ReferenceError objects representing the parsing errors and/or early errors. Parsing and early error detection may be interweaved in an implementation-dependent manner. If more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-dependent, but at least one must be present.If body is a List of errors, return body.Return Script Record {[[Realm]]: realm, [[Environment]]: undefined, [[ECMAScriptCode]]: body, [[HostDefined]]: hostDefined}.        Note An implementation may parse script source text and analyse it  for Early Error conditions prior to evaluation of ParseScript for that  script source text. However, the reporting of any errors must be  deferred until the point where this specification actually performs  ParseScript upon that source text.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.1.10">
	<buginformation>
		<summary>ScriptEvaluation ( scriptRecord )</summary>
		<description>Let globalEnv be scriptRecord.[[Realm]].[[GlobalEnv]].Let scriptCxt be a new ECMAScript code execution context.Set the Function of scriptCxt to null.Set the Realm of scriptCxt to scriptRecord.[[Realm]].Set the ScriptOrModule of scriptCxt to scriptRecord.Set the VariableEnvironment of scriptCxt to globalEnv.Set the LexicalEnvironment of scriptCxt to globalEnv.Suspend the currently running execution context.Push scriptCxt on to the execution context stack; scriptCxt is now the running execution context.Let scriptBody be scriptRecord.[[ECMAScriptCode]].Let result be GlobalDeclarationInstantiation(scriptBody, globalEnv).If result.[[Type]] is normal, thenSet result to the result of evaluating scriptBody.If result.[[Type]] is normal and result.[[Value]] is empty, thenSet result to NormalCompletion(undefined).Suspend scriptCxt and remove it from the execution context stack.Assert: The execution context stack is not empty.Resume the context that is now on the top of the execution context stack as the running execution context.Return Completion(result).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.1.11">
	<buginformation>
		<summary>Runtime Semantics: GlobalDeclarationInstantiation ( script, env )</summary>
		<description>Note 1 When an execution context is established for evaluating scripts, declarations are instantiated in the current global environment. Each global binding declared in the code is instantiated.  GlobalDeclarationInstantiation is performed as follows using arguments script and env. script is the ScriptBody for which the execution context is being established. env is the global lexical environment in which bindings are to be created.  Let envRec be env&apos;s EnvironmentRecord.Assert: envRec is a global Environment Record.Let lexNames be the LexicallyDeclaredNames of script.Let varNames be the VarDeclaredNames of script.For each name in lexNames, doIf envRec.HasVarDeclaration(name) is true, throw a SyntaxError exception.If envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.Let hasRestrictedGlobal be ? envRec.HasRestrictedGlobalProperty(name).If hasRestrictedGlobal is true, throw a SyntaxError exception.For each name in varNames, doIf envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.Let varDeclarations be the VarScopedDeclarations of script.Let functionsToInitialize be a new empty List.Let declaredFunctionNames be a new empty List.For each d in varDeclarations, in reverse list order, doIf d is neither a VariableDeclaration nor a ForBinding nor a BindingIdentifier, thenAssert: d is either a FunctionDeclaration, a GeneratorDeclaration, or an AsyncFunctionDeclaration.NOTE: If there are multiple function declarations for the same name, the last declaration is used.Let fn be the sole element of the BoundNames of d.If fn is not an element of declaredFunctionNames, thenLet fnDefinable be ? envRec.CanDeclareGlobalFunction(fn).If fnDefinable is false, throw a TypeError exception.Append fn to declaredFunctionNames.Insert d as the first element of functionsToInitialize.Let declaredVarNames be a new empty List.For each d in varDeclarations, doIf d is a VariableDeclaration, a ForBinding, or a BindingIdentifier, thenFor each String vn in the BoundNames of d, doIf vn is not an element of declaredFunctionNames, thenLet vnDefinable be ? envRec.CanDeclareGlobalVar(vn).If vnDefinable is false, throw a TypeError exception.If vn is not an element of declaredVarNames, thenAppend vn to declaredVarNames.NOTE: No abnormal terminations occur after this algorithm step if the global object is an ordinary object. However, if the global object is a Proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps.NOTE: Annex B.3.3.2 adds additional steps at this point.Let lexDeclarations be the LexicallyScopedDeclarations of script.For each element d in lexDeclarations, doNOTE: Lexically declared names are only instantiated here but not initialized.For each element dn of the BoundNames of d, doIf IsConstantDeclaration of d is true, thenPerform ? envRec.CreateImmutableBinding(dn, true).Else,Perform ? envRec.CreateMutableBinding(dn, false).For each Parse Node f in functionsToInitialize, doLet fn be the sole element of the BoundNames of f.Let fo be the result of performing InstantiateFunctionObject for f with argument env.Perform ? envRec.CreateGlobalFunctionBinding(fn, fo, false).For each String vn in declaredVarNames, in list order, doPerform ? envRec.CreateGlobalVarBinding(vn, false).Return NormalCompletion(empty).        Note 2 Early errors specified in  15.1.1  prevent name conflicts between function/var declarations and  let/const/class declarations as well as redeclaration of let/const/class  bindings for declaration contained within a single Script. However, such conflicts and redeclarations that span more than one Script  are detected as runtime errors during GlobalDeclarationInstantiation.  If any such errors are detected, no bindings are instantiated for the  script. However, if the global object is defined using Proxy exotic objects then the runtime tests for conflicting declarations may be unreliable resulting in an abrupt completion and some global declarations not being instantiated. If this occurs, the code for the Script is not evaluated. Unlike explicit var or function declarations, properties that are directly created on the global object result in global bindings that may be shadowed by let/const/class declarations.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.1.12">
	<buginformation>
		<summary>Runtime Semantics: ScriptEvaluationJob ( sourceText, hostDefined )</summary>
		<description>The job ScriptEvaluationJob with parameters sourceText and hostDefined parses, validates, and evaluates sourceText as a Script. Assert: sourceText is an ECMAScript source text (see clause 10).Let realm be the current Realm Record.Let s be ParseScript(sourceText, realm, hostDefined).If s is a List of errors, thenPerform HostReportErrors(s).Return NormalCompletion(undefined).Return ? ScriptEvaluation(s).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>ModuleBody:ModuleItemList                It is a Syntax Error if the LexicallyDeclaredNames of ModuleItemList contains any duplicate entries.                                    It is a Syntax Error if any element of the LexicallyDeclaredNames of ModuleItemList also occurs in the VarDeclaredNames of ModuleItemList.                                    It is a Syntax Error if the ExportedNames of ModuleItemList contains any duplicate entries.                                    It is a Syntax Error if any element of the ExportedBindings of ModuleItemList does not also occur in either the VarDeclaredNames of ModuleItemList, or the LexicallyDeclaredNames of ModuleItemList.                                    It is a Syntax Error if ModuleItemList Contains super.                                    It is a Syntax Error if ModuleItemList Contains NewTarget.                                    It is a Syntax Error if ContainsDuplicateLabels of ModuleItemList with argument « » is true.                                    It is a Syntax Error if ContainsUndefinedBreakTarget of ModuleItemList with argument « » is true.                                    It is a Syntax Error if ContainsUndefinedContinueTarget of ModuleItemList with arguments « » and « » is true.                        Note The duplicate ExportedNames rule implies that multiple export default ExportDeclaration items within a ModuleBody  is a Syntax Error. Additional error conditions relating to conflicting  or duplicate declarations are checked during module linking prior to  evaluation of a Module. If any such errors are detected the Module is not evaluated.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.2">
	<buginformation>
		<summary>Static Semantics: ContainsDuplicateLabels</summary>
		<description>With parameter labelSet.   ModuleItemList:ModuleItemListModuleItem  Let hasDuplicates be ContainsDuplicateLabels of ModuleItemList with argument labelSet.If hasDuplicates is true, return true.Return ContainsDuplicateLabels of ModuleItem with argument labelSet.           ModuleItem:ImportDeclaration ExportDeclaration  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.3">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedBreakTarget</summary>
		<description>With parameter labelSet.   ModuleItemList:ModuleItemListModuleItem  Let hasUndefinedLabels be ContainsUndefinedBreakTarget of ModuleItemList with argument labelSet.If hasUndefinedLabels is true, return true.Return ContainsUndefinedBreakTarget of ModuleItem with argument labelSet.           ModuleItem:ImportDeclaration ExportDeclaration  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.4">
	<buginformation>
		<summary>Static Semantics: ContainsUndefinedContinueTarget</summary>
		<description>With parameters iterationSet and labelSet.   ModuleItemList:ModuleItemListModuleItem  Let hasUndefinedLabels be ContainsUndefinedContinueTarget of ModuleItemList with arguments iterationSet and « ».If hasUndefinedLabels is true, return true.Return ContainsUndefinedContinueTarget of ModuleItem with arguments iterationSet and « ».           ModuleItem:ImportDeclaration ExportDeclaration  Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.5">
	<buginformation>
		<summary>Static Semantics: ExportedBindings</summary>
		<description>Note ExportedBindings are the locally bound names that are explicitly associated with a Module&apos;s ExportedNames.   ModuleItemList:ModuleItemListModuleItem  Let names be ExportedBindings of ModuleItemList.Append to names the elements of the ExportedBindings of ModuleItem.Return names.           ModuleItem:ImportDeclaration StatementListItem  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.6">
	<buginformation>
		<summary>Static Semantics: ExportedNames</summary>
		<description>Note ExportedNames are the externally visible names that a Module explicitly maps to one of its local name bindings.   ModuleItemList:ModuleItemListModuleItem  Let names be ExportedNames of ModuleItemList.Append to names the elements of the ExportedNames of ModuleItem.Return names.           ModuleItem:ExportDeclaration  Return the ExportedNames of ExportDeclaration.           ModuleItem:ImportDeclaration StatementListItem  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.7">
	<buginformation>
		<summary>Static Semantics: ExportEntries</summary>
		<description>Module:[empty]  Return a new empty List.           ModuleItemList:ModuleItemListModuleItem  Let entries be ExportEntries of ModuleItemList.Append to entries the elements of the ExportEntries of ModuleItem.Return entries.           ModuleItem:ImportDeclaration StatementListItem  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.8">
	<buginformation>
		<summary>Static Semantics: ImportEntries</summary>
		<description>Module:[empty]  Return a new empty List.           ModuleItemList:ModuleItemListModuleItem  Let entries be ImportEntries of ModuleItemList.Append to entries the elements of the ImportEntries of ModuleItem.Return entries.           ModuleItem:ExportDeclaration StatementListItem  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.9">
	<buginformation>
		<summary>Static Semantics: ImportedLocalNames ( importEntries )</summary>
		<description>The abstract operation ImportedLocalNames with argument importEntries creates a List of all of the local name bindings defined by a List of ImportEntry Records (see  Table 40). ImportedLocalNames performs the following steps: Let localNames be a new empty List.For each ImportEntry Record i in importEntries, doAppend i.[[LocalName]] to localNames.Return localNames.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.10">
	<buginformation>
		<summary>Static Semantics: ModuleRequests</summary>
		<description>Module:[empty]  Return a new empty List.           ModuleItemList:ModuleItem  Return ModuleRequests of ModuleItem.           ModuleItemList:ModuleItemListModuleItem  Let moduleNames be ModuleRequests of ModuleItemList.Let additionalNames be ModuleRequests of ModuleItem.Append to moduleNames each element of additionalNames that is not already an element of moduleNames.Return moduleNames.           ModuleItem:StatementListItem  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.11">
	<buginformation>
		<summary>Static Semantics: LexicallyDeclaredNames</summary>
		<description>Note 1 The LexicallyDeclaredNames of a Module includes the names of all of its imported bindings.   ModuleItemList:ModuleItemListModuleItem  Let names be LexicallyDeclaredNames of ModuleItemList.Append to names the elements of the LexicallyDeclaredNames of ModuleItem.Return names.           ModuleItem:ImportDeclaration  Return the BoundNames of ImportDeclaration.           ModuleItem:ExportDeclaration  If ExportDeclaration is export VariableStatement, return a new empty List.Return the BoundNames of ExportDeclaration.           ModuleItem:StatementListItem  Return LexicallyDeclaredNames of StatementListItem.          Note 2 At the top level of a Module, function declarations are treated like lexical declarations rather than like var declarations.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.12">
	<buginformation>
		<summary>Static Semantics: LexicallyScopedDeclarations</summary>
		<description>Module:[empty]  Return a new empty List.           ModuleItemList:ModuleItemListModuleItem  Let declarations be LexicallyScopedDeclarations of ModuleItemList.Append to declarations the elements of the LexicallyScopedDeclarations of ModuleItem.Return declarations.           ModuleItem:ImportDeclaration  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.13">
	<buginformation>
		<summary>Static Semantics: VarDeclaredNames</summary>
		<description>Module:[empty]  Return a new empty List.           ModuleItemList:ModuleItemListModuleItem  Let names be VarDeclaredNames of ModuleItemList.Append to names the elements of the VarDeclaredNames of ModuleItem.Return names.           ModuleItem:ImportDeclaration  Return a new empty List.           ModuleItem:ExportDeclaration  If ExportDeclaration is export VariableStatement, return BoundNames of ExportDeclaration.Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.14">
	<buginformation>
		<summary>Static Semantics: VarScopedDeclarations</summary>
		<description>Module:[empty]  Return a new empty List.           ModuleItemList:ModuleItemListModuleItem  Let declarations be VarScopedDeclarations of ModuleItemList.Append to declarations the elements of the VarScopedDeclarations of ModuleItem.Return declarations.           ModuleItem:ImportDeclaration  Return a new empty List.           ModuleItem:ExportDeclaration  If ExportDeclaration is export VariableStatement, return VarScopedDeclarations of VariableStatement.Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.15">
	<buginformation>
		<summary>Abstract Module Records</summary>
		<description>A  Module Record encapsulates structural  information about the imports and exports of a single module. This  information is used to link the imports and exports of sets of connected  modules. A Module Record includes four fields that are only used when  evaluating a module. For specification purposes Module Record values are values of the Record  specification type and can be thought of as existing in a simple  object-oriented hierarchy where Module Record is an abstract class with  concrete subclasses. This specification only defines a single Module  Record concrete subclass named Source Text Module Record.  Other specifications and implementations may define additional Module  Record subclasses corresponding to alternative module definition  facilities that they defined. Module Record defines the fields listed in  Table 37. All Module Definition subclasses include at least those fields. Module Record also defines the abstract method list in  Table 38. All Module definition subclasses must provide concrete implementations of these abstract methods. Table 37: Module Record Fields                     Field Name                                                Value Type                                                Meaning                                                    [[Realm]]                                Realm Record | undefined                   The Realm within which this module was created. undefined if not yet assigned.                                                  [[Environment]]                                Lexical Environment | undefined                   The Lexical Environment containing the top level bindings for this module. This field is set when the module is instantiated.                                                  [[Namespace]]                                                Object | undefined                   The Module Namespace Object (26.3) if one has been created for this module. Otherwise undefined.                                                  [[Evaluated]]                                                Boolean                                                Initially false, true if evaluation of this module has started. Remains true when evaluation completes, even if it is an abrupt completion.                                                  [[HostDefined]]                                                Any, default value is undefined.                                                Field reserved for use by host environments that need to associate additional information with a module.                                   Table 38: Abstract Methods of Module Records                     Method                                                Purpose                                                  GetExportedNames(exportStarSet)                                                Return a list of all names that are either directly or indirectly exported from this module.                                                  ResolveExport(exportName, resolveSet)                                                Return the binding of a name exported by this module. Bindings are represented by a  ResolvedBinding Record, of the form {[[Module]]: Module Record, [[BindingName]]: String}. Return null if the name cannot be resolved, or &amp;quot;ambiguous&amp;quot; if multiple bindings were found.                                                  ModuleDeclarationInstantiation()                                                Transitively resolve all module dependencies and create a module Environment Record for the module.                                                  ModuleEvaluation()                                Do nothing if this module has already been evaluated.  Otherwise, transitively evaluate all module dependences of this module  and then evaluate this module. ModuleDeclarationInstantiation must be completed prior to invoking this method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.16.1">
	<buginformation>
		<summary>ParseModule ( sourceText, realm, hostDefined )</summary>
		<description>The abstract operation ParseModule with arguments sourceText, realm, and hostDefined creates a Source Text Module Record based upon the result of parsing sourceText as a Module. ParseModule performs the following steps: Assert: sourceText is an ECMAScript source text (see clause 10).Parse sourceText using Module as the goal symbol and analyse the parse result for any Early Error conditions. If the parse was successful and no early errors were found, let body be the resulting parse tree. Otherwise, let body be a List of one or more SyntaxError or ReferenceError objects representing the parsing errors and/or early errors. Parsing and early error detection may be interweaved in an implementation-dependent manner. If more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-dependent, but at least one must be present.If body is a List of errors, return body.Let requestedModules be the ModuleRequests of body.Let importEntries be ImportEntries of body.Let importedBoundNames be ImportedLocalNames(importEntries).Let indirectExportEntries be a new empty List.Let localExportEntries be a new empty List.Let starExportEntries be a new empty List.Let exportEntries be ExportEntries of body.For each ExportEntry Record ee in exportEntries, doIf ee.[[ModuleRequest]] is null, thenIf ee.[[LocalName]] is not an element of importedBoundNames, thenAppend ee to localExportEntries.Else,Let ie be the element of importEntries whose [[LocalName]] is the same as ee.[[LocalName]].If ie.[[ImportName]] is &amp;quot;*&amp;quot;, thenAssert: This is a re-export of an imported module namespace object.Append ee to localExportEntries.Else this is a re-export of a single name,Append the ExportEntry Record {[[ModuleRequest]]: ie.[[ModuleRequest]], [[ImportName]]: ie.[[ImportName]], [[LocalName]]: null, [[ExportName]]: ee.[[ExportName]] } to indirectExportEntries.Else if ee.[[ImportName]] is &amp;quot;*&amp;quot;, thenAppend ee to starExportEntries.Else,Append ee to indirectExportEntries.Return Source Text Module Record {[[Realm]]: realm, [[Environment]]: undefined, [[HostDefined]]: hostDefined, [[Namespace]]: undefined, [[Evaluated]]: false, [[ECMAScriptCode]]: body, [[RequestedModules]]: requestedModules, [[ImportEntries]]: importEntries, [[LocalExportEntries]]: localExportEntries, [[StarExportEntries]]: starExportEntries, [[IndirectExportEntries]]: indirectExportEntries}.            Note An implementation may parse module source text and  analyse it for Early Error conditions prior to the evaluation of  ParseModule for that module source text. However, the reporting of any  errors must be deferred until the point where this specification  actually performs ParseModule upon that source text.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.16.2">
	<buginformation>
		<summary>GetExportedNames( exportStarSet ) Concrete Method</summary>
		<description>The GetExportedNames concrete method of a Source Text Module Record with argument exportStarSet performs the following steps: Let module be this Source Text Module Record.If exportStarSet contains module, thenAssert: We&apos;ve reached the starting point of an import * circularity.Return a new empty List.Append module to exportStarSet.Let exportedNames be a new empty List.For each ExportEntry Record e in module.[[LocalExportEntries]], doAssert: module provides the direct binding for this export.Append e.[[ExportName]] to exportedNames.For each ExportEntry Record e in module.[[IndirectExportEntries]], doAssert: module imports a specific binding for this export.Append e.[[ExportName]] to exportedNames.For each ExportEntry Record e in module.[[StarExportEntries]], doLet requestedModule be ? HostResolveImportedModule(module, e.[[ModuleRequest]]).Let starNames be ? requestedModule.GetExportedNames(exportStarSet).For each element n of starNames, doIf SameValue(n, &amp;quot;default&amp;quot;) is false, thenIf n is not an element of exportedNames, thenAppend n to exportedNames.Return exportedNames.            Note GetExportedNames does not filter out or throw an exception for names that have ambiguous star export bindings.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.16.3">
	<buginformation>
		<summary>ResolveExport( exportName, resolveSet ) Concrete Method</summary>
		<description>The ResolveExport concrete method of a Source Text Module Record with arguments exportName, and resolveSet performs the following steps: Let module be this Source Text Module Record.For each Record {[[Module]], [[ExportName]]} r in resolveSet, doIf module and r.[[Module]] are the same Module Record and SameValue(exportName, r.[[ExportName]]) is true, thenAssert: This is a circular import request.Return null.Append the Record {[[Module]]: module, [[ExportName]]: exportName} to resolveSet.For each ExportEntry Record e in module.[[LocalExportEntries]], doIf SameValue(exportName, e.[[ExportName]]) is true, thenAssert: module provides the direct binding for this export.Return ResolvedBinding Record {[[Module]]: module, [[BindingName]]: e.[[LocalName]]}.For each ExportEntry Record e in module.[[IndirectExportEntries]], doIf SameValue(exportName, e.[[ExportName]]) is true, thenAssert: module imports a specific binding for this export.Let importedModule be ? HostResolveImportedModule(module, e.[[ModuleRequest]]).Return ? importedModule.ResolveExport(e.[[ImportName]], resolveSet).If SameValue(exportName, &amp;quot;default&amp;quot;) is true, thenAssert: A default export was not explicitly defined by this module.Return null.NOTE: A default export cannot be provided by an export *.Let starResolution be null.For each ExportEntry Record e in module.[[StarExportEntries]], doLet importedModule be ? HostResolveImportedModule(module, e.[[ModuleRequest]]).Let resolution be ? importedModule.ResolveExport(exportName, resolveSet).If resolution is &amp;quot;ambiguous&amp;quot;, return &amp;quot;ambiguous&amp;quot;.If resolution is not null, thenIf starResolution is null, set starResolution to resolution.Else,Assert: There is more than one * import that includes the requested name.If resolution.[[Module]] and starResolution.[[Module]] are not the same Module Record or SameValue(resolution.[[BindingName]], starResolution.[[BindingName]]) is false, return &amp;quot;ambiguous&amp;quot;.Return starResolution.            Note ResolveExport attempts to resolve an imported binding to  the actual defining module and local binding name. The defining module  may be the module represented by the Module Record this method was invoked on or some other module that is imported by that module. The parameter resolveSet is use to detect unresolved circular import/export paths. If a pair consisting of specific Module Record and exportName is reached that is already in resolveSet, an import circularity has been encountered. Before recursively calling ResolveExport, a pair consisting of module and exportName is added to resolveSet. If a defining module is found, a ResolvedBinding Record  {[[Module]], [[BindingName]]} is returned. This record identifies the  resolved binding of the originally requested export. If no definition  was found or the request is found to be circular, null is returned. If the request is found to be ambiguous, the string &amp;quot;ambiguous&amp;quot; is returned.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.16.4">
	<buginformation>
		<summary>ModuleDeclarationInstantiation( ) Concrete Method</summary>
		<description>The ModuleDeclarationInstantiation concrete method of a Source Text Module Record performs the following steps: Let module be this Source Text Module Record.Let realm be module.[[Realm]].Assert: realm is not undefined.Let code be module.[[ECMAScriptCode]].If module.[[Environment]] is not undefined, return NormalCompletion(empty).Let env be NewModuleEnvironment(realm.[[GlobalEnv]]).Set module.[[Environment]] to env.For each String required that is an element of module.[[RequestedModules]], doNOTE:  Before instantiating a module, all of the modules it requested must be  available. An implementation may perform this test at any time prior to  this point.Let requiredModule be ? HostResolveImportedModule(module, required).Perform ? requiredModule.ModuleDeclarationInstantiation().For each ExportEntry Record e in module.[[IndirectExportEntries]], doLet resolution be ? module.ResolveExport(e.[[ExportName]], « »).If resolution is null or resolution is &amp;quot;ambiguous&amp;quot;, throw a SyntaxError exception.Assert: All named exports from module are resolvable.Let envRec be env&apos;s EnvironmentRecord.For each ImportEntry Record in in module.[[ImportEntries]], doLet importedModule be ! HostResolveImportedModule(module, in.[[ModuleRequest]]).NOTE: The above call cannot fail because imported module requests are a subset of module.[[RequestedModules]], and these have been resolved earlier in this algorithm.If in.[[ImportName]] is &amp;quot;*&amp;quot;, thenLet namespace be ? GetModuleNamespace(importedModule).Perform ! envRec.CreateImmutableBinding(in.[[LocalName]], true).Call envRec.InitializeBinding(in.[[LocalName]], namespace).Else,Let resolution be ? importedModule.ResolveExport(in.[[ImportName]], « »).If resolution is null or resolution is &amp;quot;ambiguous&amp;quot;, throw a SyntaxError exception.Call envRec.CreateImportBinding(in.[[LocalName]], resolution.[[Module]], resolution.[[BindingName]]).Let varDeclarations be the VarScopedDeclarations of code.Let declaredVarNames be a new empty List.For each element d in varDeclarations, doFor each element dn of the BoundNames of d, doIf dn is not an element of declaredVarNames, thenPerform ! envRec.CreateMutableBinding(dn, false).Call envRec.InitializeBinding(dn, undefined).Append dn to declaredVarNames.Let lexDeclarations be the LexicallyScopedDeclarations of code.For each element d in lexDeclarations, doFor each element dn of the BoundNames of d, doIf IsConstantDeclaration of d is true, thenPerform ! envRec.CreateImmutableBinding(dn, true).Else,Perform ! envRec.CreateMutableBinding(dn, false).If d is a FunctionDeclaration, a GeneratorDeclaration, or an AsyncFunctionDeclaration, thenLet fo be the result of performing InstantiateFunctionObject for d with argument env.Call envRec.InitializeBinding(dn, fo).Return NormalCompletion(empty).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.16.5">
	<buginformation>
		<summary>ModuleEvaluation( ) Concrete Method</summary>
		<description>The ModuleEvaluation concrete method of a Source Text Module Record performs the following steps: Let module be this Source Text Module Record.Assert: ModuleDeclarationInstantiation has already been invoked on module and successfully completed.Assert: module.[[Realm]] is not undefined.If module.[[Evaluated]] is true, return undefined.Set module.[[Evaluated]] to true.For each String required that is an element of module.[[RequestedModules]], doLet requiredModule be ! HostResolveImportedModule(module, required).NOTE:  ModuleDeclarationInstantiation must be completed prior to invoking this  method, so every requested module is guaranteed to resolve  successfully.Perform ? requiredModule.ModuleEvaluation().Let moduleCxt be a new ECMAScript code execution context.Set the Function of moduleCxt to null.Set the Realm of moduleCxt to module.[[Realm]].Set the ScriptOrModule of moduleCxt to module.Assert: module has been linked and declarations in its module environment have been instantiated.Set the VariableEnvironment of moduleCxt to module.[[Environment]].Set the LexicalEnvironment of moduleCxt to module.[[Environment]].Suspend the currently running execution context.Push moduleCxt on to the execution context stack; moduleCxt is now the running execution context.Let result be the result of evaluating module.[[ECMAScriptCode]].Suspend moduleCxt and remove it from the execution context stack.Resume the context that is now on the top of the execution context stack as the running execution context.Return Completion(result).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.17">
	<buginformation>
		<summary>Runtime Semantics: HostResolveImportedModule ( referencingModule, specifier )</summary>
		<description>HostResolveImportedModule is an implementation-defined abstract operation that provides the concrete Module Record subclass instance that corresponds to the ModuleSpecifier String, specifier, occurring within the context of the module represented by the Module Record referencingModule. The implementation of HostResolveImportedModule must conform to the following requirements:               The normal return value must be an instance of a concrete subclass of Module Record.                                    If a Module Record corresponding to the pair referencingModule, specifier does not exist or cannot be created, an exception must be thrown.                                    This operation must be idempotent if it completes normally. Each time it is called with a specific referencingModule, specifier pair as arguments it must return the same Module Record instance.                        Multiple different referencingModule, specifier pairs may map to the same Module Record instance. The actual mapping semantic is implementation-defined but typically a normalization process is applied to specifier  as part of the mapping process. A typical normalization process would  include actions such as alphabetic case folding and expansion of  relative and abbreviated path specifiers.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.18">
	<buginformation>
		<summary>Runtime Semantics: GetModuleNamespace( module )</summary>
		<description>The abstract operation GetModuleNamespace called with argument module performs the following steps: Assert: module is an instance of a concrete subclass of Module Record.Let namespace be module.[[Namespace]].If namespace is undefined, thenLet exportedNames be ? module.GetExportedNames(« »).Let unambiguousNames be a new empty List.For each name that is an element of exportedNames, doLet resolution be ? module.ResolveExport(name, « »).If resolution is null, throw a SyntaxError exception.If resolution is not &amp;quot;ambiguous&amp;quot;, append name to unambiguousNames.Set namespace to ModuleNamespaceCreate(module, unambiguousNames).Return namespace.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.19">
	<buginformation>
		<summary>Runtime Semantics: TopLevelModuleEvaluationJob ( sourceText, hostDefined )</summary>
		<description>A TopLevelModuleEvaluationJob with parameters sourceText and hostDefined is a job that parses, validates, and evaluates sourceText as a Module. Assert: sourceText is an ECMAScript source text (see clause 10).Let realm be the current Realm Record.Let m be ParseModule(sourceText, realm, hostDefined).If m is a List of errors, thenPerform HostReportErrors(m).Return NormalCompletion(undefined).Perform ? m.ModuleDeclarationInstantiation().Assert: All dependencies of m have been transitively resolved and m is ready for evaluation.Return ? m.ModuleEvaluation().          Note An implementation may parse a sourceText as a Module, analyse it for Early Error conditions, and instantiate it prior to the execution of the TopLevelModuleEvaluationJob for that sourceText. An implementation may also resolve, pre-parse and pre-analyse, and pre-instantiate module dependencies of sourceText.  However, the reporting of any errors detected by these actions must be  deferred until the TopLevelModuleEvaluationJob is actually executed.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.1.20">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>Module:[empty]  Return NormalCompletion(undefined).           ModuleBody:ModuleItemList  Let result be the result of evaluating ModuleItemList.If result.[[Type]] is normal and result.[[Value]] is empty, thenReturn NormalCompletion(undefined).Return Completion(result).           ModuleItemList:ModuleItemListModuleItem  Let sl be the result of evaluating ModuleItemList.ReturnIfAbrupt(sl).Let s be the result of evaluating ModuleItem.Return Completion(UpdateEmpty(s, sl.[[Value]])).          Note The value of a ModuleItemList is the value of the last value producing item in the ModuleItemList.   ModuleItem:ImportDeclaration  Return NormalCompletion(empty).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.2.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>ModuleItem:ImportDeclaration                It is a Syntax Error if the BoundNames of ImportDeclaration contains any duplicate entries.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.2.2">
	<buginformation>
		<summary>Static Semantics: BoundNames</summary>
		<description>ImportDeclaration:importImportClauseFromClause;  Return the BoundNames of ImportClause.           ImportDeclaration:importModuleSpecifier;  Return a new empty List.           ImportClause:ImportedDefaultBinding,NameSpaceImport  Let names be the BoundNames of ImportedDefaultBinding.Append to names the elements of the BoundNames of NameSpaceImport.Return names.           ImportClause:ImportedDefaultBinding,NamedImports  Let names be the BoundNames of ImportedDefaultBinding.Append to names the elements of the BoundNames of NamedImports.Return names.           NamedImports:{}  Return a new empty List.           ImportsList:ImportsList,ImportSpecifier  Let names be the BoundNames of ImportsList.Append to names the elements of the BoundNames of ImportSpecifier.Return names.           ImportSpecifier:IdentifierNameasImportedBinding  Return the BoundNames of ImportedBinding.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.2.3">
	<buginformation>
		<summary>Static Semantics: ImportEntries</summary>
		<description>ImportDeclaration:importImportClauseFromClause;  Let module be the sole element of ModuleRequests of FromClause.Return ImportEntriesForModule of ImportClause with argument module.           ImportDeclaration:importModuleSpecifier;  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.2.4">
	<buginformation>
		<summary>Static Semantics: ImportEntriesForModule</summary>
		<description>With parameter module.  ImportClause:ImportedDefaultBinding,NameSpaceImport  Let entries be ImportEntriesForModule of ImportedDefaultBinding with argument module.Append to entries the elements of the ImportEntriesForModule of NameSpaceImport with argument module.Return entries.           ImportClause:ImportedDefaultBinding,NamedImports  Let entries be ImportEntriesForModule of ImportedDefaultBinding with argument module.Append to entries the elements of the ImportEntriesForModule of NamedImports with argument module.Return entries.           ImportedDefaultBinding:ImportedBinding  Let localName be the sole element of BoundNames of ImportedBinding.Let defaultEntry be the ImportEntry Record {[[ModuleRequest]]: module, [[ImportName]]: &amp;quot;default&amp;quot;, [[LocalName]]: localName }.Return a new List containing defaultEntry.           NameSpaceImport:*asImportedBinding  Let localName be the StringValue of ImportedBinding.Let entry be the ImportEntry Record {[[ModuleRequest]]: module, [[ImportName]]: &amp;quot;*&amp;quot;, [[LocalName]]: localName }.Return a new List containing entry.           NamedImports:{}  Return a new empty List.           ImportsList:ImportsList,ImportSpecifier  Let specs be the ImportEntriesForModule of ImportsList with argument module.Append to specs the elements of the ImportEntriesForModule of ImportSpecifier with argument module.Return specs.           ImportSpecifier:ImportedBinding  Let localName be the sole element of BoundNames of ImportedBinding.Let entry be the ImportEntry Record {[[ModuleRequest]]: module, [[ImportName]]: localName, [[LocalName]]: localName }.Return a new List containing entry.           ImportSpecifier:IdentifierNameasImportedBinding  Let importName be the StringValue of IdentifierName.Let localName be the StringValue of ImportedBinding.Let entry be the ImportEntry Record {[[ModuleRequest]]: module, [[ImportName]]: importName, [[LocalName]]: localName }.Return a new List containing entry.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.2.5">
	<buginformation>
		<summary>Static Semantics: ModuleRequests</summary>
		<description>ImportDeclaration:importImportClauseFromClause;  Return ModuleRequests of FromClause.           ModuleSpecifier:StringLiteral  Return a List containing the StringValue of StringLiteral.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.3.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>ExportDeclaration:exportExportClause;                For each IdentifierName n in ReferencedBindings of ExportClause: It is a Syntax Error if StringValue of n is a ReservedWord or if the StringValue of n is one of: &amp;quot;implements&amp;quot;, &amp;quot;interface&amp;quot;, &amp;quot;let&amp;quot;, &amp;quot;package&amp;quot;, &amp;quot;private&amp;quot;, &amp;quot;protected&amp;quot;, &amp;quot;public&amp;quot;, or &amp;quot;static&amp;quot;.                        Note The above rule means that each ReferencedBindings of ExportClause is treated as an IdentifierReference.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.3.2">
	<buginformation>
		<summary>Static Semantics: BoundNames</summary>
		<description>ExportDeclaration:export*FromClause; exportExportClauseFromClause; exportExportClause;  Return a new empty List.           ExportDeclaration:exportVariableStatement  Return the BoundNames of VariableStatement.           ExportDeclaration:exportDeclaration  Return the BoundNames of Declaration.           ExportDeclaration:exportdefaultHoistableDeclaration  Let declarationNames be the BoundNames of HoistableDeclaration.If declarationNames does not include the element &amp;quot;*default*&amp;quot;, append &amp;quot;*default*&amp;quot; to declarationNames.Return declarationNames.           ExportDeclaration:exportdefaultClassDeclaration  Let declarationNames be the BoundNames of ClassDeclaration.If declarationNames does not include the element &amp;quot;*default*&amp;quot;, append &amp;quot;*default*&amp;quot; to declarationNames.Return declarationNames.           ExportDeclaration:exportdefaultAssignmentExpression;  Return « &amp;quot;*default*&amp;quot; ».</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.3.3">
	<buginformation>
		<summary>Static Semantics: ExportedBindings</summary>
		<description>ExportDeclaration:exportExportClauseFromClause; export*FromClause;  Return a new empty List.           ExportDeclaration:exportExportClause;  Return the ExportedBindings of ExportClause.           ExportDeclaration:exportVariableStatement  Return the BoundNames of VariableStatement.           ExportDeclaration:exportDeclaration  Return the BoundNames of Declaration.           ExportDeclaration:exportdefaultHoistableDeclaration   ExportDeclaration:exportdefaultClassDeclaration   ExportDeclaration:exportdefaultAssignmentExpression;  Return the BoundNames of this ExportDeclaration.           ExportClause:{}  Return a new empty List.           ExportsList:ExportsList,ExportSpecifier  Let names be the ExportedBindings of ExportsList.Append to names the elements of the ExportedBindings of ExportSpecifier.Return names.           ExportSpecifier:IdentifierName  Return a List containing the StringValue of IdentifierName.           ExportSpecifier:IdentifierNameasIdentifierName  Return a List containing the StringValue of the first IdentifierName.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.3.4">
	<buginformation>
		<summary>Static Semantics: ExportedNames</summary>
		<description>ExportDeclaration:export*FromClause;  Return a new empty List.           ExportDeclaration:exportExportClauseFromClause;   ExportDeclaration:exportExportClause;  Return the ExportedNames of ExportClause.           ExportDeclaration:exportVariableStatement  Return the BoundNames of VariableStatement.           ExportDeclaration:exportDeclaration  Return the BoundNames of Declaration.           ExportDeclaration:exportdefaultHoistableDeclaration   ExportDeclaration:exportdefaultClassDeclaration   ExportDeclaration:exportdefaultAssignmentExpression;  Return « &amp;quot;default&amp;quot; ».           ExportClause:{}  Return a new empty List.           ExportsList:ExportsList,ExportSpecifier  Let names be the ExportedNames of ExportsList.Append to names the elements of the ExportedNames of ExportSpecifier.Return names.           ExportSpecifier:IdentifierName  Return a List containing the StringValue of IdentifierName.           ExportSpecifier:IdentifierNameasIdentifierName  Return a List containing the StringValue of the second IdentifierName.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.3.5">
	<buginformation>
		<summary>Static Semantics: ExportEntries</summary>
		<description>ExportDeclaration:export*FromClause;  Let module be the sole element of ModuleRequests of FromClause.Let entry be the ExportEntry Record {[[ModuleRequest]]: module, [[ImportName]]: &amp;quot;*&amp;quot;, [[LocalName]]: null, [[ExportName]]: null }.Return a new List containing entry.           ExportDeclaration:exportExportClauseFromClause;  Let module be the sole element of ModuleRequests of FromClause.Return ExportEntriesForModule of ExportClause with argument module.           ExportDeclaration:exportExportClause;  Return ExportEntriesForModule of ExportClause with argument null.           ExportDeclaration:exportVariableStatement  Let entries be a new empty List.Let names be the BoundNames of VariableStatement.For each name in names, doAppend the ExportEntry Record {[[ModuleRequest]]: null, [[ImportName]]: null, [[LocalName]]: name, [[ExportName]]: name } to entries.Return entries.           ExportDeclaration:exportDeclaration  Let entries be a new empty List.Let names be the BoundNames of Declaration.For each name in names, doAppend the ExportEntry Record {[[ModuleRequest]]: null, [[ImportName]]: null, [[LocalName]]: name, [[ExportName]]: name } to entries.Return entries.           ExportDeclaration:exportdefaultHoistableDeclaration  Let names be BoundNames of HoistableDeclaration.Let localName be the sole element of names.Return a new List containing the ExportEntry Record {[[ModuleRequest]]: null, [[ImportName]]: null, [[LocalName]]: localName, [[ExportName]]: &amp;quot;default&amp;quot;}.           ExportDeclaration:exportdefaultClassDeclaration  Let names be BoundNames of ClassDeclaration.Let localName be the sole element of names.Return a new List containing the ExportEntry Record {[[ModuleRequest]]: null, [[ImportName]]: null, [[LocalName]]: localName, [[ExportName]]: &amp;quot;default&amp;quot;}.           ExportDeclaration:exportdefaultAssignmentExpression;  Let entry be the ExportEntry Record {[[ModuleRequest]]: null, [[ImportName]]: null, [[LocalName]]: &amp;quot;*default*&amp;quot;, [[ExportName]]: &amp;quot;default&amp;quot;}.Return a new List containing entry.          Note &amp;quot;*default*&amp;quot; is used within this specification as a synthetic name for anonymous default export values.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.3.6">
	<buginformation>
		<summary>Static Semantics: ExportEntriesForModule</summary>
		<description>With parameter module.  ExportClause:{}  Return a new empty List.           ExportsList:ExportsList,ExportSpecifier  Let specs be the ExportEntriesForModule of ExportsList with argument module.Append to specs the elements of the ExportEntriesForModule of ExportSpecifier with argument module.Return specs.           ExportSpecifier:IdentifierName  Let sourceName be the StringValue of IdentifierName.If module is null, thenLet localName be sourceName.Let importName be null.Else,Let localName be null.Let importName be sourceName.Return a new List containing the ExportEntry Record {[[ModuleRequest]]: module, [[ImportName]]: importName, [[LocalName]]: localName, [[ExportName]]: sourceName }.           ExportSpecifier:IdentifierNameasIdentifierName  Let sourceName be the StringValue of the first IdentifierName.Let exportName be the StringValue of the second IdentifierName.If module is null, thenLet localName be sourceName.Let importName be null.Else,Let localName be null.Let importName be sourceName.Return a new List containing the ExportEntry Record {[[ModuleRequest]]: module, [[ImportName]]: importName, [[LocalName]]: localName, [[ExportName]]: exportName }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.3.7">
	<buginformation>
		<summary>Static Semantics: IsConstantDeclaration</summary>
		<description>ExportDeclaration:export*FromClause; exportExportClauseFromClause; exportExportClause; exportdefaultAssignmentExpression;  Return false.          Note It is not necessary to treat export default AssignmentExpression  as a constant declaration because there is no syntax that permits  assignment to the internal bound name used to reference a module&apos;s  default object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.3.8">
	<buginformation>
		<summary>Static Semantics: LexicallyScopedDeclarations</summary>
		<description>ExportDeclaration:export*FromClause; exportExportClauseFromClause; exportExportClause; exportVariableStatement  Return a new empty List.           ExportDeclaration:exportDeclaration  Return a new List containing DeclarationPart of Declaration.           ExportDeclaration:exportdefaultHoistableDeclaration  Return a new List containing DeclarationPart of HoistableDeclaration.           ExportDeclaration:exportdefaultClassDeclaration  Return a new List containing ClassDeclaration.           ExportDeclaration:exportdefaultAssignmentExpression;  Return a new List containing this ExportDeclaration.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.3.9">
	<buginformation>
		<summary>Static Semantics: ModuleRequests</summary>
		<description>ExportDeclaration:export*FromClause;   ExportDeclaration:exportExportClauseFromClause;  Return the ModuleRequests of FromClause.           ExportDeclaration:exportExportClause; exportVariableStatement exportDeclaration exportdefaultHoistableDeclaration exportdefaultClassDeclaration exportdefaultAssignmentExpression;  Return a new empty List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.3.10">
	<buginformation>
		<summary>Static Semantics: ReferencedBindings</summary>
		<description>ExportClause:{}  Return a new empty List.           ExportsList:ExportsList,ExportSpecifier  Let names be the ReferencedBindings of ExportsList.Append to names the elements of the ReferencedBindings of ExportSpecifier.Return names.           ExportSpecifier:IdentifierName  Return a List containing the IdentifierName.           ExportSpecifier:IdentifierNameasIdentifierName  Return a List containing the first IdentifierName.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="15.2.3.11">
	<buginformation>
		<summary>Runtime Semantics: Evaluation</summary>
		<description>ExportDeclaration:export*FromClause; exportExportClauseFromClause; exportExportClause;  Return NormalCompletion(empty).           ExportDeclaration:exportVariableStatement  Return the result of evaluating VariableStatement.           ExportDeclaration:exportDeclaration  Return the result of evaluating Declaration.           ExportDeclaration:exportdefaultHoistableDeclaration  Return the result of evaluating HoistableDeclaration.           ExportDeclaration:exportdefaultClassDeclaration  Let value be the result of BindingClassDeclarationEvaluation of ClassDeclaration.ReturnIfAbrupt(value).Let className be the sole element of BoundNames of ClassDeclaration.If className is &amp;quot;*default*&amp;quot;, thenLet hasNameProperty be ? HasOwnProperty(value, &amp;quot;name&amp;quot;).If hasNameProperty is false, perform SetFunctionName(value, &amp;quot;default&amp;quot;).Let env be the running execution context&apos;s LexicalEnvironment.Perform ? InitializeBoundName(&amp;quot;*default*&amp;quot;, value, env).Return NormalCompletion(empty).           ExportDeclaration:exportdefaultAssignmentExpression;  Let rhs be the result of evaluating AssignmentExpression.Let value be ? GetValue(rhs).If IsAnonymousFunctionDefinition(AssignmentExpression) is true, thenLet hasNameProperty be ? HasOwnProperty(value, &amp;quot;name&amp;quot;).If hasNameProperty is false, perform SetFunctionName(value, &amp;quot;default&amp;quot;).Let env be the running execution context&apos;s LexicalEnvironment.Perform ? InitializeBoundName(&amp;quot;*default*&amp;quot;, value, env).Return NormalCompletion(empty).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="16.1">
	<buginformation>
		<summary>HostReportErrors ( errorList )</summary>
		<description>HostReportErrors is an implementation-defined abstract operation  that allows host environments to report parsing errors, early errors,  and runtime errors. An implementation of HostReportErrors must complete normally in  all cases. The default implementation of HostReportErrors is to  unconditionally return an empty normal completion. Note errorList will be a List of ECMAScript language values. If the errors are parsing errors or early errors, these will always be SyntaxError or ReferenceError objects. Runtime errors, however, can be any ECMAScript value.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="16.2">
	<buginformation>
		<summary>Forbidden Extensions</summary>
		<description>An implementation must not extend this specification in the following ways:           ECMAScript function objects defined using syntactic constructors in strict mode code must not be created with own properties named &amp;quot;caller&amp;quot; or &amp;quot;arguments&amp;quot;. Such own properties also must not be created for function objects defined using an ArrowFunction, MethodDefinition, GeneratorDeclaration, GeneratorExpression, ClassDeclaration, ClassExpression, AsyncFunctionDeclaration, AsyncFunctionExpression, or AsyncArrowFunction regardless of whether the definition is contained in strict mode code. Built-in functions, strict functions created using the Function constructor, generator functions created using the Generator constructor, async functions created using the AsyncFunction constructor, and functions created using the bind method also must not be created with such own properties.                        If an implementation extends non-strict or built-in function objects with an own property named &amp;quot;caller&amp;quot; the value of that property, as observed using [[Get]] or [[GetOwnProperty]], must not be a strict function object. If it is an accessor property, the function that is the value of the property&apos;s [[Get]] attribute must never return a strict function when called.                        Neither mapped nor unmapped arguments objects may be created with an own property named &amp;quot;caller&amp;quot;.                        The behaviour of the following methods must not be extended except as specified in ECMA-402: Object.prototype.toLocaleString, Array.prototype.toLocaleString, Number.prototype.toLocaleString, Date.prototype.toLocaleDateString, Date.prototype.toLocaleString, Date.prototype.toLocaleTimeString, String.prototype.localeCompare, %TypedArray%.prototype.toLocaleString.                        The RegExp pattern grammars in  21.2.1 and  B.1.4 must not be extended to recognize any of the source characters A-Z or a-z as IdentityEscape[+U] when the  [U] grammar parameter is present.                        The Syntactic Grammar must not be extended in any manner that allows the token : to immediately follow source text that matches the BindingIdentifier nonterminal symbol.                        When processing strict mode code, the syntax of NumericLiteral must not be extended to include  LegacyOctalIntegerLiteral and the syntax of DecimalIntegerLiteral must not be extended to include  NonOctalDecimalIntegerLiteral as described in  B.1.1.                TemplateCharacter must not be extended to include  LegacyOctalEscapeSequence as defined in  B.1.2.                        When processing strict mode code, the extensions defined in  B.3.2,  B.3.3,  B.3.4, and  B.3.6 must not be supported.                        When parsing for the Module goal symbol, the lexical grammar extensions defined in  B.1.3 must not be supported.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="17">
	<buginformation>
		<summary>ECMAScript Standard Built-in Objects</summary>
		<description>There are certain built-in objects available whenever an ECMAScript Script or Module begins execution. One, the global object, is part of the lexical environment of the executing program. Others are accessible as initial properties of the global object or indirectly as properties of accessible built-in objects. Unless specified otherwise, a built-in object that is callable as a  function is a built-in function object with the characteristics  described in  9.3. Unless specified otherwise, the [[Extensible]] internal slot of a built-in object initially has the value true. Every built-in function object has a [[Realm]] internal slot whose value is the Realm Record of the realm for which the object was initially created. Many built-in objects are functions: they can be invoked with  arguments. Some of them furthermore are constructors: they are functions  intended for use with the new operator. For each built-in  function, this specification describes the arguments required by that  function and the properties of that function object. For each built-in  constructor, this specification furthermore describes properties of the  prototype object of that constructor and properties of specific object  instances returned by a new expression that invokes that constructor. Unless otherwise specified in the description of a particular  function, if a built-in function or constructor is given fewer arguments  than the function is specified to require, the function or constructor  shall behave exactly as if it had been given sufficient additional  arguments, each such argument being the undefined  value. Such missing arguments are considered to be “not present” and may  be identified in that manner by specification algorithms. In the  description of a particular function, the terms “this value” and “NewTarget” have the meanings given in  9.3. Unless otherwise specified in the description of a particular  function, if a built-in function or constructor described is given more  arguments than the function is specified to allow, the extra arguments  are evaluated by the call and then ignored by the function. However, an  implementation may define implementation specific behaviour relating to  such arguments as long as the behaviour is not the throwing of a TypeError exception that is predicated simply on the presence of an extra argument. Note 1 Implementations that add additional capabilities to the set of  built-in functions are encouraged to do so by adding new functions  rather than adding new parameters to existing functions.  Unless otherwise specified every built-in function and every  built-in constructor has the Function prototype object, which is the  initial value of the expression Function.prototype (19.2.3), as the value of its [[Prototype]] internal slot. Unless otherwise specified every built-in prototype object has the  Object prototype object, which is the initial value of the expression Object.prototype (19.1.3), as the value of its [[Prototype]] internal slot, except the Object prototype object itself. Built-in function objects that are not identified as constructors  do not implement the [[Construct]] internal method unless otherwise  specified in the description of a particular function. Unless otherwise specified, each built-in function defined in this specification is created as if by calling the CreateBuiltinFunction abstract operation (9.3.3). Every built-in function object, including constructors, has a length  property whose value is an integer. Unless otherwise specified, this  value is equal to the largest number of named arguments shown in the  subclause headings for the function description. Optional parameters  (which are indicated with brackets: [ ]) or rest parameters (which are shown using the form «...name») are not included in the default argument count. Note 2 For example, the function object that is the initial value of the map  property of the Array prototype object is described under the subclause  heading «Array.prototype.map (callbackFn [ , thisArg])» which shows the  two named arguments callbackFn and thisArg, the latter being optional;  therefore the value of the length property of that function object is 1.  Unless otherwise specified, the length property of a built-in function object has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. Every built-in function object, including constructors, that is not identified as an anonymous function has a name  property whose value is a String. Unless otherwise specified, this  value is the name that is given to the function in this specification.  For functions that are specified as properties of objects, the name  value is the property name string used to access the function. Functions  that are specified as get or set accessor functions of built-in  properties have &amp;quot;get &amp;quot; or &amp;quot;set &amp;quot; prepended to the property name string. The value of the name property is explicitly specified for each built-in functions whose property key is a Symbol value. Unless otherwise specified, the name property of a built-in function object, if it exists, has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. Every other data property described in clauses 18 through 26 and in Annex  B.2 has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } unless otherwise specified. Every accessor property described in clauses 18 through 26 and in Annex  B.2 has the attributes { [[Enumerable]]: false, [[Configurable]]: true } unless otherwise specified. If only a get accessor function is described, the set accessor function is the default value, undefined. If only a set accessor is described the get accessor is the default value, undefined.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.1.1">
	<buginformation>
		<summary>Infinity</summary>
		<description>The value of Infinity is +∞ (see  6.1.6). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.1.2">
	<buginformation>
		<summary>NaN</summary>
		<description>The value of NaN is NaN (see  6.1.6). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.1.3">
	<buginformation>
		<summary>undefined</summary>
		<description>The value of undefined is undefined (see  6.1.1). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.2.1.1.1">
	<buginformation>
		<summary>Additional Early Error Rules for Eval Outside Functions</summary>
		<description>These static semantics are applied by PerformEval when a direct eval call occurs outside of any function.  ScriptBody:StatementList   It is a Syntax Error if StatementList Contains NewTarget.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.2.1.1.2">
	<buginformation>
		<summary>Additional Early Error Rules for Eval Outside Methods</summary>
		<description>These static semantics are applied by PerformEval when a direct eval call occurs outside of a MethodDefinition.  ScriptBody:StatementList   It is a Syntax Error if StatementList Contains SuperProperty.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.2.1.1.3">
	<buginformation>
		<summary>Additional Early Error Rules for Eval Outside Constructor Methods</summary>
		<description>These static semantics are applied by PerformEval when a direct eval call occurs outside of the  constructor method of a ClassDeclaration or ClassExpression.  ScriptBody:StatementList   It is a Syntax Error if StatementList Contains SuperCall.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.2.1.2">
	<buginformation>
		<summary>HostEnsureCanCompileStrings( callerRealm, calleeRealm )</summary>
		<description>HostEnsureCanCompileStrings is an implementation-defined  abstract operation that allows host environments to block certain  ECMAScript functions which allow developers to compile strings into  ECMAScript code. An implementation of HostEnsureCanCompileStrings may complete  normally or abruptly. Any abrupt completions will be propagated to its  callers. The default implementation of HostEnsureCanCompileStrings is to  unconditionally return an empty normal completion.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.2.1.3">
	<buginformation>
		<summary>Runtime Semantics: EvalDeclarationInstantiation( body, varEnv, lexEnv, strict )</summary>
		<description>When the abstract operation EvalDeclarationInstantiation is called with arguments body, varEnv, lexEnv, and strict, the following steps are taken:  Let varNames be the VarDeclaredNames of body.Let varDeclarations be the VarScopedDeclarations of body.Let lexEnvRec be lexEnv&apos;s EnvironmentRecord.Let varEnvRec be varEnv&apos;s EnvironmentRecord.If strict is false, thenIf varEnvRec is a global Environment Record, thenFor each name in varNames, doIf varEnvRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.NOTE: eval will not create a global var declaration that would be shadowed by a global lexical declaration.Let thisLex be lexEnv.Assert: The following loop will terminate.Repeat, while thisLex is not the same as varEnv,Let thisEnvRec be thisLex&apos;s EnvironmentRecord.If thisEnvRec is not an object Environment Record, thenNOTE:  The environment of with statements cannot contain any lexical  declaration so it doesn&apos;t need to be checked for var/let hoisting  conflicts.For each name in varNames, doIf thisEnvRec.HasBinding(name) is true, thenThrow a SyntaxError exception.NOTE: Annex B.3.5 defines alternate semantics for the above step.NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration.Set thisLex to thisLex&apos;s outer environment reference.Let functionsToInitialize be a new empty List.Let declaredFunctionNames be a new empty List.For each d in varDeclarations, in reverse list order, doIf d is neither a VariableDeclaration nor a ForBinding nor a BindingIdentifier, thenAssert: d is either a FunctionDeclaration, a GeneratorDeclaration, or an AsyncFunctionDeclaration.NOTE: If there are multiple function declarations for the same name, the last declaration is used.Let fn be the sole element of the BoundNames of d.If fn is not an element of declaredFunctionNames, thenIf varEnvRec is a global Environment Record, thenLet fnDefinable be ? varEnvRec.CanDeclareGlobalFunction(fn).If fnDefinable is false, throw a TypeError exception.Append fn to declaredFunctionNames.Insert d as the first element of functionsToInitialize.NOTE: Annex B.3.3.3 adds additional steps at this point.Let declaredVarNames be a new empty List.For each d in varDeclarations, doIf d is a VariableDeclaration, a ForBinding, or a BindingIdentifier, thenFor each String vn in the BoundNames of d, doIf vn is not an element of declaredFunctionNames, thenIf varEnvRec is a global Environment Record, thenLet vnDefinable be ? varEnvRec.CanDeclareGlobalVar(vn).If vnDefinable is false, throw a TypeError exception.If vn is not an element of declaredVarNames, thenAppend vn to declaredVarNames.NOTE: No abnormal terminations occur after this algorithm step unless varEnvRec is a global Environment Record and the global object is a Proxy exotic object.Let lexDeclarations be the LexicallyScopedDeclarations of body.For each element d in lexDeclarations, doNOTE: Lexically declared names are only instantiated here but not initialized.For each element dn of the BoundNames of d, doIf IsConstantDeclaration of d is true, thenPerform ? lexEnvRec.CreateImmutableBinding(dn, true).Else,Perform ? lexEnvRec.CreateMutableBinding(dn, false).For each Parse Node f in functionsToInitialize, doLet fn be the sole element of the BoundNames of f.Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.If varEnvRec is a global Environment Record, thenPerform ? varEnvRec.CreateGlobalFunctionBinding(fn, fo, true).Else,Let bindingExists be varEnvRec.HasBinding(fn).If bindingExists is false, thenLet status be ! varEnvRec.CreateMutableBinding(fn, true).Assert: status is not an abrupt completion because of validation preceding step 12.Perform ! varEnvRec.InitializeBinding(fn, fo).Else,Perform ! varEnvRec.SetMutableBinding(fn, fo, false).For each String vn in declaredVarNames, in list order, doIf varEnvRec is a global Environment Record, thenPerform ? varEnvRec.CreateGlobalVarBinding(vn, true).Else,Let bindingExists be varEnvRec.HasBinding(vn).If bindingExists is false, thenLet status be ! varEnvRec.CreateMutableBinding(vn, true).Assert: status is not an abrupt completion because of validation preceding step 12.Perform ! varEnvRec.InitializeBinding(vn, undefined).Return NormalCompletion(empty).          Note An alternative version of this algorithm is described in  B.3.5.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.2.2">
	<buginformation>
		<summary>isFinite ( number )</summary>
		<description>The isFinite function is the  %isFinite% intrinsic object. When the isFinite function is called with one argument number, the following steps are taken: Let num be ? ToNumber(number).If num is NaN, +∞, or -∞, return false.Otherwise, return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.2.3">
	<buginformation>
		<summary>isNaN ( number )</summary>
		<description>The isNaN function is the  %isNaN% intrinsic object. When the isNaN function is called with one argument number, the following steps are taken: Let num be ? ToNumber(number).If num is NaN, return true.Otherwise, return false.        Note A reliable way for ECMAScript code to test if a value X is a NaN is an expression of the form X !</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.2.4">
	<buginformation>
		<summary>parseFloat ( string )</summary>
		<description>The parseFloat function produces a Number value dictated by interpretation of the contents of the string argument as a decimal literal. The parseFloat function is the  %parseFloat% intrinsic object. When the parseFloat function is called with one argument string, the following steps are taken: Let inputString be ? ToString(string).Let trimmedString be a substring of inputString consisting of the leftmost code unit that is not a StrWhiteSpaceChar and all code units to the right of that code unit. (In other words, remove leading white space.) If inputString does not contain any such code units, let trimmedString be the empty string.If neither trimmedString nor any prefix of trimmedString satisfies the syntax of a StrDecimalLiteral (see 7.1.3.1), return NaN.Let numberString be the longest prefix of trimmedString, which might be trimmedString itself, that satisfies the syntax of a StrDecimalLiteral.Let mathFloat be MV of numberString.If mathFloat</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.2.5">
	<buginformation>
		<summary>parseInt ( string, radix )</summary>
		<description>The parseInt function produces an integer value dictated by interpretation of the contents of the string argument according to the specified radix. Leading white space in string is ignored. If radix is undefined or 0, it is assumed to be 10 except when the number begins with the code unit pairs 0x or 0X, in which case a radix of 16 is assumed. If radix is 16, the number may also optionally begin with the code unit pairs 0x or 0X. The parseInt function is the  %parseInt% intrinsic object. When the parseInt function is called, the following steps are taken: Let inputString be ? ToString(string).Let S be a newly created substring of inputString consisting of the first code unit that is not a StrWhiteSpaceChar and all code units following that code unit. (In other words, remove leading white space.) If inputString does not contain any such code unit, let S be the empty string.Let sign be 1.If S is not empty and the first code unit of S is 0x002D (HYPHEN-MINUS), let sign be -1.If S is not empty and the first code unit of S is 0x002B (PLUS SIGN) or 0x002D (HYPHEN-MINUS), remove the first code unit from S.Let R be ? ToInt32(radix).Let stripPrefix be true.If R ≠ 0, thenIf R &lt; 2 or R &gt; 36, return NaN.If R ≠ 16, let stripPrefix be false.Else R</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.2.6.1.1">
	<buginformation>
		<summary>Runtime Semantics: Encode ( string, unescapedSet )</summary>
		<description>The encoding and escaping process is described by the abstract operation Encode taking two String arguments string and unescapedSet. Let strLen be the number of code units in string.Let R be the empty String.Let k be 0.Repeat,If k equals strLen, return R.Let C be the code unit at index k within string.If C is in unescapedSet, thenLet S be a String containing only the code unit C.Set R to a new String value computed by concatenating the previous value of R and S.Else C is not in unescapedSet,If the code unit value of C is not less than 0xDC00 and not greater than 0xDFFF, throw a URIError exception.If the code unit value of C is less than 0xD800 or greater than 0xDBFF, thenLet V be the code point with the same numeric value as code unit C.Else,Increase k by 1.If k equals strLen, throw a URIError exception.Let kChar be the code unit value of the code unit at index k within string.If kChar is less than 0xDC00 or greater than 0xDFFF, throw a URIError exception.Let V be UTF16Decode(C, kChar).Let Octets be the array of octets resulting by applying the UTF-8 transformation to V, and let L be the array size.Let j be 0.Repeat, while j &lt; LLet jOctet be the value at index j within Octets.Let S be a String containing three code units &amp;quot;%XY&amp;quot; where XY are two uppercase hexadecimal digits encoding jOctet.Set R to a new String value computed by concatenating the previous value of R and S.Increase j by 1.Increase k by 1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.2.6.1.2">
	<buginformation>
		<summary>Runtime Semantics: Decode ( string, reservedSet )</summary>
		<description>The unescaping and decoding process is described by the abstract operation Decode taking two String arguments string and reservedSet. Let strLen be the number of code units in string.Let R be the empty String.Let k be 0.Repeat,If k equals strLen, return R.Let C be the code unit at index k within string.If C is not &amp;quot;%&amp;quot;, thenLet S be the String containing only the code unit C.Else C is &amp;quot;%&amp;quot;,Let start be k.If k + 2 is greater than or equal to strLen, throw a URIError exception.If the code units at index (k + 1) and (k + 2) within string do not represent hexadecimal digits, throw a URIError exception.Let B be the 8-bit value represented by the two hexadecimal digits at index (k + 1) and (k + 2).Increment k by 2.If the most significant bit in B is 0, thenLet C be the code unit with code unit value B.If C is not in reservedSet, thenLet S be the String containing only the code unit C.Else C is in reservedSet,Let S be the substring of string from index start to index k inclusive.Else the most significant bit in B is 1,Let n be the smallest nonnegative integer such that (B &lt;&lt; n) &amp; 0x80 is equal to 0.If n equals 1 or n is greater than 4, throw a URIError exception.Let Octets be an array of 8-bit integers of size n.Put B into Octets at index 0.If k + (3 × (n - 1)) is greater than or equal to strLen, throw a URIError exception.Let j be 1.Repeat, while j &lt; nIncrement k by 1.If the code unit at index k within string is not &amp;quot;%&amp;quot;, throw a URIError exception.If the code units at index (k + 1) and (k + 2) within string do not represent hexadecimal digits, throw a URIError exception.Let B be the 8-bit value represented by the two hexadecimal digits at index (k + 1) and (k + 2).If the two most significant bits in B are not 10, throw a URIError exception.Increment k by 2.Put B into Octets at index j.Increment j by 1.Let V be the value obtained by applying the UTF-8 transformation to Octets, that is, from an array of octets into a 21-bit value. If Octets does not contain a valid UTF-8 encoding of a Unicode code point, throw a URIError exception.If V &lt; 0x10000, thenLet C be the code unit V.If C is not in reservedSet, thenLet S be the String containing only the code unit C.Else C is in reservedSet,Let S be the substring of string from index start to index k inclusive.Else V ≥ 0x10000,Let S be the String value whose elements are, in order, the elements in UTF16Encoding(V).Set R to a new String value computed by concatenating the previous value of R and S.Increase k by 1.            Note This syntax of Uniform Resource Identifiers is based upon  RFC 2396 and does not reflect the more recent RFC 3986 which replaces  RFC 2396. A formal description and implementation of UTF-8 is given in  RFC 3629. In UTF-8, characters are encoded using sequences of 1 to 6  octets. The only octet of a sequence of one has the higher-order bit  set to 0, the remaining 7 bits being used to encode the character value.  In a sequence of n octets, n&gt;1, the initial octet has the n  higher-order bits set to 1, followed by a bit set to 0. The remaining  bits of that octet contain bits from the value of the character to be  encoded. The following octets all have the higher-order bit set to 1 and  the following bit set to 0, leaving 6 bits in each to contain bits from  the character to be encoded. The possible UTF-8 encodings of ECMAScript  characters are specified in  Table 44. Table 44 (Informative): UTF-8 Encodings                         Code Unit Value                                                            Representation                                                            1st Octet                                                            2nd Octet                                                            3rd Octet                                                            4th Octet                                          0x0000 - 0x007F   00000000 0zzzzzzz   0zzzzzzz           0x0080 - 0x07FF   00000yyy yyzzzzzz   110yyyyy   10zzzzzz         0x0800 - 0xD7FF   xxxxyyyy yyzzzzzz   1110xxxx   10yyyyyy   10zzzzzz       0xD800 - 0xDBFF                      followed by                                           0xDC00 - 0xDFFF   110110vv vvwwwwxx                      followed by                                           110111yy yyzzzzzz   11110uuu   10uuwwww   10xxyyyy   10zzzzzz     0xD800 - 0xDBFF                      not followed by                                           0xDC00 - 0xDFFF                       causes URIError             0xDC00 - 0xDFFF                       causes URIError             0xE000 - 0xFFFF   xxxxyyyy yyzzzzzz   1110xxxx   10yyyyyy   10zzzzzz        Where                               uuuuu</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.2.6.2">
	<buginformation>
		<summary>decodeURI ( encodedURI )</summary>
		<description>The decodeURI function computes a new version of  a URI in which each escape sequence and UTF-8 encoding of the sort that  might be introduced by the encodeURI function is replaced  with the UTF-16 encoding of the code points that it represents. Escape  sequences that could not have been introduced by encodeURI are not replaced. The decodeURI function is the  %decodeURI% intrinsic object. When the decodeURI function is called with one argument encodedURI, the following steps are taken: Let uriString be ? ToString(encodedURI).Let reservedURISet be a String containing one instance of each code unit valid in uriReserved plus &amp;quot;#&amp;quot;.Return ? Decode(uriString, reservedURISet).          Note The code point &amp;quot;#&amp;quot; is not decoded from escape sequences even though it is not a reserved URI code point.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.2.6.3">
	<buginformation>
		<summary>decodeURIComponent ( encodedURIComponent )</summary>
		<description>The decodeURIComponent function computes a new  version of a URI in which each escape sequence and UTF-8 encoding of the  sort that might be introduced by the encodeURIComponent function is replaced with the UTF-16 encoding of the code points that it represents. The decodeURIComponent function is the  %decodeURIComponent% intrinsic object. When the decodeURIComponent function is called with one argument encodedURIComponent, the following steps are taken: Let componentString be ? ToString(encodedURIComponent).Let reservedURIComponentSet be the empty String.Return ? Decode(componentString, reservedURIComponentSet).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.2.6.4">
	<buginformation>
		<summary>encodeURI ( uri )</summary>
		<description>The encodeURI function computes a new version of a UTF-16 encoded (6.1.4)  URI in which each instance of certain code points is replaced by one,  two, three, or four escape sequences representing the UTF-8 encoding of  the code points. The encodeURI function is the  %encodeURI% intrinsic object. When the encodeURI function is called with one argument uri, the following steps are taken: Let uriString be ? ToString(uri).Let unescapedURISet be a String containing one instance of each code unit valid in uriReserved and uriUnescaped plus &amp;quot;#&amp;quot;.Return ? Encode(uriString, unescapedURISet).          Note The code unit &amp;quot;#&amp;quot; is not encoded to an escape sequence even though it is not a reserved or unescaped URI code point.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.2.6.5">
	<buginformation>
		<summary>encodeURIComponent ( uriComponent )</summary>
		<description>The encodeURIComponent function computes a new version of a UTF-16 encoded (6.1.4)  URI in which each instance of certain code points is replaced by one,  two, three, or four escape sequences representing the UTF-8 encoding of  the code point. The encodeURIComponent function is the  %encodeURIComponent% intrinsic object. When the encodeURIComponent function is called with one argument uriComponent, the following steps are taken: Let componentString be ? ToString(uriComponent).Let unescapedURIComponentSet be a String containing one instance of each code unit valid in uriUnescaped.Return ? Encode(componentString, unescapedURIComponentSet).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.1">
	<buginformation>
		<summary>Array ( . . . )</summary>
		<description>See  22.1.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.2">
	<buginformation>
		<summary>ArrayBuffer ( . . . )</summary>
		<description>See  24.1.2.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.3">
	<buginformation>
		<summary>Boolean ( . . . )</summary>
		<description>See  19.3.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.4">
	<buginformation>
		<summary>DataView ( . . . )</summary>
		<description>See  24.3.2.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.5">
	<buginformation>
		<summary>Date ( . . . )</summary>
		<description>See  20.3.2.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.6">
	<buginformation>
		<summary>Error ( . . . )</summary>
		<description>See  19.5.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.7">
	<buginformation>
		<summary>EvalError ( . . . )</summary>
		<description>See  19.5.5.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.8">
	<buginformation>
		<summary>Float32Array ( . . . )</summary>
		<description>See  22.2.4.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.9">
	<buginformation>
		<summary>Float64Array ( . . . )</summary>
		<description>See  22.2.4.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.10">
	<buginformation>
		<summary>Function ( . . . )</summary>
		<description>See  19.2.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.11">
	<buginformation>
		<summary>Int8Array ( . . . )</summary>
		<description>See  22.2.4.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.12">
	<buginformation>
		<summary>Int16Array ( . . . )</summary>
		<description>See  22.2.4.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.13">
	<buginformation>
		<summary>Int32Array ( . . . )</summary>
		<description>See  22.2.4.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.14">
	<buginformation>
		<summary>Map ( . . . )</summary>
		<description>See  23.1.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.15">
	<buginformation>
		<summary>Number ( . . . )</summary>
		<description>See  20.1.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.16">
	<buginformation>
		<summary>Object ( . . . )</summary>
		<description>See  19.1.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.17">
	<buginformation>
		<summary>Proxy ( . . . )</summary>
		<description>See  26.2.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.18">
	<buginformation>
		<summary>Promise ( . . . )</summary>
		<description>See  25.4.3.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.19">
	<buginformation>
		<summary>RangeError ( . . . )</summary>
		<description>See  19.5.5.2.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.20">
	<buginformation>
		<summary>ReferenceError ( . . . )</summary>
		<description>See  19.5.5.3.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.21">
	<buginformation>
		<summary>RegExp ( . . . )</summary>
		<description>See  21.2.3.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.22">
	<buginformation>
		<summary>Set ( . . . )</summary>
		<description>See  23.2.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.23">
	<buginformation>
		<summary>SharedArrayBuffer ( . . . )</summary>
		<description>See  24.2.2.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.24">
	<buginformation>
		<summary>String ( . . . )</summary>
		<description>See  21.1.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.25">
	<buginformation>
		<summary>Symbol ( . . . )</summary>
		<description>See  19.4.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.26">
	<buginformation>
		<summary>SyntaxError ( . . . )</summary>
		<description>See  19.5.5.4.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.27">
	<buginformation>
		<summary>TypeError ( . . . )</summary>
		<description>See  19.5.5.5.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.28">
	<buginformation>
		<summary>Uint8Array ( . . . )</summary>
		<description>See  22.2.4.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.29">
	<buginformation>
		<summary>Uint8ClampedArray ( . . . )</summary>
		<description>See  22.2.4.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.30">
	<buginformation>
		<summary>Uint16Array ( . . . )</summary>
		<description>See  22.2.4.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.31">
	<buginformation>
		<summary>Uint32Array ( . . . )</summary>
		<description>See  22.2.4.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.32">
	<buginformation>
		<summary>URIError ( . . . )</summary>
		<description>See  19.5.5.6.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.33">
	<buginformation>
		<summary>WeakMap ( . . . )</summary>
		<description>See  23.3.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.3.34">
	<buginformation>
		<summary>WeakSet ( . . . )</summary>
		<description>See  23.4.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.4.1">
	<buginformation>
		<summary>Atomics</summary>
		<description>See  24.4.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.4.2">
	<buginformation>
		<summary>JSON</summary>
		<description>See  24.5.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.4.3">
	<buginformation>
		<summary>Math</summary>
		<description>See  20.2.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="18.4.4">
	<buginformation>
		<summary>Reflect</summary>
		<description>See  26.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.1.1">
	<buginformation>
		<summary>Object ( [ value ] )</summary>
		<description>When Object function is called with optional argument value, the following steps are taken: If NewTarget is neither undefined nor the active function, thenReturn ? OrdinaryCreateFromConstructor(NewTarget, &amp;quot;%ObjectPrototype%&amp;quot;).If value is null, undefined or not supplied, return ObjectCreate(%ObjectPrototype%).Return ! ToObject(value).          The length property of the Object constructor function is 1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.1">
	<buginformation>
		<summary>Object.assign ( target, ...sources )</summary>
		<description>The assign function is used to copy the values of all of the enumerable own properties from one or more source objects to a target object. When the assign function is called, the following steps are taken: Let to be ? ToObject(target).If only one argument was passed, return to.Let sources be the List of argument values starting with the second argument.For each element nextSource of sources, in ascending index order, doIf nextSource is undefined or null, let keys be a new empty List.Else,Let from be ! ToObject(nextSource).Let keys be ? from.[[OwnPropertyKeys]]().For each element nextKey of keys in List order, doLet desc be ? from.[[GetOwnProperty]](nextKey).If desc is not undefined and desc.[[Enumerable]] is true, thenLet propValue be ? Get(from, nextKey).Perform ? Set(to, nextKey, propValue, true).Return to.          The length property of the assign function is 2.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.2">
	<buginformation>
		<summary>Object.create ( O, Properties )</summary>
		<description>The create function creates a new object with a specified prototype. When the create function is called, the following steps are taken: If Type(O) is neither Object nor Null, throw a TypeError exception.Let obj be ObjectCreate(O).If Properties is not undefined, thenReturn ? ObjectDefineProperties(obj, Properties).Return obj.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.3.1">
	<buginformation>
		<summary>Runtime Semantics: ObjectDefineProperties ( O, Properties )</summary>
		<description>The abstract operation ObjectDefineProperties with arguments O and Properties performs the following steps: If Type(O) is not Object, throw a TypeError exception.Let props be ? ToObject(Properties).Let keys be ? props.[[OwnPropertyKeys]]().Let descriptors be a new empty List.For each element nextKey of keys in List order, doLet propDesc be ? props.[[GetOwnProperty]](nextKey).If propDesc is not undefined and propDesc.[[Enumerable]] is true, thenLet descObj be ? Get(props, nextKey).Let desc be ? ToPropertyDescriptor(descObj).Append the pair (a two element List) consisting of nextKey and desc to the end of descriptors.For each pair from descriptors in list order, doLet P be the first element of pair.Let desc be the second element of pair.Perform ? DefinePropertyOrThrow(O, P, desc).Return O.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.4">
	<buginformation>
		<summary>Object.defineProperty ( O, P, Attributes )</summary>
		<description>The defineProperty function is used to add an own property and/or update the attributes of an existing own property of an object. When the defineProperty function is called, the following steps are taken: If Type(O) is not Object, throw a TypeError exception.Let key be ? ToPropertyKey(P).Let desc be ? ToPropertyDescriptor(Attributes).Perform ? DefinePropertyOrThrow(O, key, desc).Return O.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.5">
	<buginformation>
		<summary>Object.entries ( O )</summary>
		<description>When the entries function is called with argument O, the following steps are taken: Let obj be ? ToObject(O).Let nameList be ? EnumerableOwnProperties(obj, &amp;quot;key+value&amp;quot;).Return CreateArrayFromList(nameList).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.6">
	<buginformation>
		<summary>Object.freeze ( O )</summary>
		<description>When the freeze function is called, the following steps are taken: If Type(O) is not Object, return O.Let status be ? SetIntegrityLevel(O, &amp;quot;frozen&amp;quot;).If status is false, throw a TypeError exception.Return O.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.7">
	<buginformation>
		<summary>Object.getOwnPropertyDescriptor ( O, P )</summary>
		<description>When the getOwnPropertyDescriptor function is called, the following steps are taken: Let obj be ? ToObject(O).Let key be ? ToPropertyKey(P).Let desc be ? obj.[[GetOwnProperty]](key).Return FromPropertyDescriptor(desc).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.8">
	<buginformation>
		<summary>Object.getOwnPropertyDescriptors ( O )</summary>
		<description>When the getOwnPropertyDescriptors function is called, the following steps are taken: Let obj be ? ToObject(O).Let ownKeys be ? obj.[[OwnPropertyKeys]]().Let descriptors be ! ObjectCreate(%ObjectPrototype%).For each element key of ownKeys in List order, doLet desc be ? obj.[[GetOwnProperty]](key).Let descriptor be ! FromPropertyDescriptor(desc).If descriptor is not undefined, perform ! CreateDataProperty(descriptors, key, descriptor).Return descriptors.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.9">
	<buginformation>
		<summary>Object.getOwnPropertyNames ( O )</summary>
		<description>When the getOwnPropertyNames function is called, the following steps are taken: Return ? GetOwnPropertyKeys(O, String).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.10.1">
	<buginformation>
		<summary>Runtime Semantics: GetOwnPropertyKeys ( O, Type )</summary>
		<description>The abstract operation GetOwnPropertyKeys is called with arguments O and Type where O is an Object and Type is one of the ECMAScript specification types String or Symbol. The following steps are taken: Let obj be ? ToObject(O).Let keys be ? obj.[[OwnPropertyKeys]]().Let nameList be a new empty List.For each element nextKey of keys in List order, doIf Type(nextKey) is Type, thenAppend nextKey as the last element of nameList.Return CreateArrayFromList(nameList).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.11">
	<buginformation>
		<summary>Object.getPrototypeOf ( O )</summary>
		<description>When the getPrototypeOf function is called with argument O, the following steps are taken: Let obj be ? ToObject(O).Return ? obj.[[GetPrototypeOf]]().</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.12">
	<buginformation>
		<summary>Object.is ( value1, value2 )</summary>
		<description>When the is function is called with arguments value1 and value2, the following steps are taken: Return SameValue(value1, value2).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.13">
	<buginformation>
		<summary>Object.isExtensible ( O )</summary>
		<description>When the isExtensible function is called with argument O, the following steps are taken: If Type(O) is not Object, return false.Return ? IsExtensible(O).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.14">
	<buginformation>
		<summary>Object.isFrozen ( O )</summary>
		<description>When the isFrozen function is called with argument O, the following steps are taken: If Type(O) is not Object, return true.Return ? TestIntegrityLevel(O, &amp;quot;frozen&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.15">
	<buginformation>
		<summary>Object.isSealed ( O )</summary>
		<description>When the isSealed function is called with argument O, the following steps are taken: If Type(O) is not Object, return true.Return ? TestIntegrityLevel(O, &amp;quot;sealed&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.16">
	<buginformation>
		<summary>Object.keys ( O )</summary>
		<description>When the keys function is called with argument O, the following steps are taken: Let obj be ? ToObject(O).Let nameList be ? EnumerableOwnProperties(obj, &amp;quot;key&amp;quot;).Return CreateArrayFromList(nameList).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.17">
	<buginformation>
		<summary>Object.preventExtensions ( O )</summary>
		<description>When the preventExtensions function is called, the following steps are taken: If Type(O) is not Object, return O.Let status be ? O.[[PreventExtensions]]().If status is false, throw a TypeError exception.Return O.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.18">
	<buginformation>
		<summary>Object.prototype</summary>
		<description>The initial value of Object.prototype is the intrinsic object %ObjectPrototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.19">
	<buginformation>
		<summary>Object.seal ( O )</summary>
		<description>When the seal function is called, the following steps are taken: If Type(O) is not Object, return O.Let status be ? SetIntegrityLevel(O, &amp;quot;sealed&amp;quot;).If status is false, throw a TypeError exception.Return O.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.20">
	<buginformation>
		<summary>Object.setPrototypeOf ( O, proto )</summary>
		<description>When the setPrototypeOf function is called with arguments O and proto, the following steps are taken: Let O be ? RequireObjectCoercible(O).If Type(proto) is neither Object nor Null, throw a TypeError exception.If Type(O) is not Object, return O.Let status be ? O.[[SetPrototypeOf]](proto).If status is false, throw a TypeError exception.Return O.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.2.21">
	<buginformation>
		<summary>Object.values ( O )</summary>
		<description>When the values function is called with argument O, the following steps are taken: Let obj be ? ToObject(O).Let nameList be ? EnumerableOwnProperties(obj, &amp;quot;value&amp;quot;).Return CreateArrayFromList(nameList).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.3.1">
	<buginformation>
		<summary>Object.prototype.constructor</summary>
		<description>The initial value of Object.prototype.constructor is the intrinsic object %Object%.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.3.2">
	<buginformation>
		<summary>Object.prototype.hasOwnProperty ( V )</summary>
		<description>When the hasOwnProperty method is called with argument V, the following steps are taken: Let P be ? ToPropertyKey(V).Let O be ? ToObject(this value).Return ? HasOwnProperty(O, P).          Note The ordering of steps 1 and 2 is chosen to ensure that any  exception that would have been thrown by step 1 in previous editions of  this specification will continue to be thrown even if the this value is undefined or null.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.3.3">
	<buginformation>
		<summary>Object.prototype.isPrototypeOf ( V )</summary>
		<description>When the isPrototypeOf method is called with argument V, the following steps are taken: If Type(V) is not Object, return false.Let O be ? ToObject(this value).Repeat,Let V be ? V.[[GetPrototypeOf]]().If V is null, return false.If SameValue(O, V) is true, return true.          Note The ordering of steps 1 and 2 preserves the behaviour specified by previous editions of this specification for the case where V is not an object and the this value is undefined or null.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.3.4">
	<buginformation>
		<summary>Object.prototype.propertyIsEnumerable ( V )</summary>
		<description>When the propertyIsEnumerable method is called with argument V, the following steps are taken: Let P be ? ToPropertyKey(V).Let O be ? ToObject(this value).Let desc be ? O.[[GetOwnProperty]](P).If desc is undefined, return false.Return desc.[[Enumerable]].          Note 1 This method does not consider objects in the prototype chain.  Note 2 The ordering of steps 1 and 2 is chosen to ensure that any  exception that would have been thrown by step 1 in previous editions of  this specification will continue to be thrown even if the this value is undefined or null.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.3.5">
	<buginformation>
		<summary>Object.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )</summary>
		<description>When the toLocaleString method is called, the following steps are taken: Let O be the this value.Return ? Invoke(O, &amp;quot;toString&amp;quot;).          The optional parameters to this function are not used but are intended to correspond to the parameter pattern used by ECMA-402 toLocaleString functions. Implementations that do not include ECMA-402 support must not use those parameter positions for other purposes. Note 1 This function provides a generic toLocaleString implementation for objects that have no locale-specific toString behaviour. Array, Number, Date, and Typed Arrays provide their own locale-sensitive toLocaleString methods.  Note 2 ECMA-402 intentionally does not provide an alternative to this default implementation.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.3.6">
	<buginformation>
		<summary>Object.prototype.toString ( )</summary>
		<description>When the toString method is called, the following steps are taken: If the this value is undefined, return &amp;quot;[object Undefined]&amp;quot;.If the this value is null, return &amp;quot;[object Null]&amp;quot;.Let O be ! ToObject(this value).Let isArray be ? IsArray(O).If isArray is true, let builtinTag be &amp;quot;Array&amp;quot;.Else if O is a String exotic object, let builtinTag be &amp;quot;String&amp;quot;.Else if O has a [[ParameterMap]] internal slot, let builtinTag be &amp;quot;Arguments&amp;quot;.Else if O has a [[Call]] internal method, let builtinTag be &amp;quot;Function&amp;quot;.Else if O has an [[ErrorData]] internal slot, let builtinTag be &amp;quot;Error&amp;quot;.Else if O has a [[BooleanData]] internal slot, let builtinTag be &amp;quot;Boolean&amp;quot;.Else if O has a [[NumberData]] internal slot, let builtinTag be &amp;quot;Number&amp;quot;.Else if O has a [[DateValue]] internal slot, let builtinTag be &amp;quot;Date&amp;quot;.Else if O has a [[RegExpMatcher]] internal slot, let builtinTag be &amp;quot;RegExp&amp;quot;.Else, let builtinTag be &amp;quot;Object&amp;quot;.Let tag be ? Get(O, @@toStringTag).If Type(tag) is not String, let tag be builtinTag.Return the String that is the result of concatenating &amp;quot;[object &amp;quot;, tag, and &amp;quot;]&amp;quot;.          This function is the  %ObjProto_toString% intrinsic object. Note Historically, this function was occasionally used to access  the String value of the [[Class]] internal slot that was used in  previous editions of this specification as a nominal type tag for  various built-in objects. The above definition of toString preserves compatibility for legacy code that uses toString  as a test for those specific kinds of built-in objects. It does not  provide a reliable type testing mechanism for other kinds of built-in or  program defined objects. In addition, programs can use @@toStringTag in  ways that will invalidate the reliability of such legacy type tests.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.3.7">
	<buginformation>
		<summary>Object.prototype.valueOf ( )</summary>
		<description>When the valueOf method is called, the following steps are taken: Return ? ToObject(this value).          This function is the  %ObjProto_valueOf% intrinsic object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.1.4">
	<buginformation>
		<summary>Properties of Object Instances</summary>
		<description>Object instances have no special properties beyond those inherited from the Object prototype object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.2.1.1.1">
	<buginformation>
		<summary>Runtime Semantics: CreateDynamicFunction( constructor, newTarget, kind, args )</summary>
		<description>The abstract operation CreateDynamicFunction is called with arguments constructor, newTarget, kind, and args. constructor is the constructor function that is performing this action, newTarget is the constructor that new was initially applied to, kind is either &amp;quot;normal&amp;quot;, &amp;quot;generator&amp;quot;, or &amp;quot;async&amp;quot;, and args is a List containing the actual argument values that were passed to constructor. The following steps are taken: Assert: The execution context stack has at least two elements.Let callerContext be the second to top element of the execution context stack.Let callerRealm be callerContext&apos;s Realm.Let calleeRealm be the current Realm Record.Perform ? HostEnsureCanCompileStrings(callerRealm, calleeRealm).If newTarget is undefined, set newTarget to constructor.If kind is &amp;quot;normal&amp;quot;, thenLet goal be the grammar symbol FunctionBody[~Yield, ~Await].Let parameterGoal be the grammar symbol FormalParameters[~Yield, ~Await].Let fallbackProto be &amp;quot;%FunctionPrototype%&amp;quot;.Else if kind is &amp;quot;generator&amp;quot;, thenLet goal be the grammar symbol GeneratorBody.Let parameterGoal be the grammar symbol FormalParameters[+Yield, ~Await].Let fallbackProto be &amp;quot;%Generator%&amp;quot;.Else,Assert: kind is &amp;quot;async&amp;quot;.Let goal be the grammar symbol AsyncFunctionBody.Let parameterGoal be the grammar symbol FormalParameters[~Yield, +Await].Let fallbackProto be &amp;quot;%AsyncFunctionPrototype%&amp;quot;.Let argCount be the number of elements in args.Let P be the empty String.If argCount</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.2.2.1">
	<buginformation>
		<summary>Function.length</summary>
		<description>This is a data property with a value of 1. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.2.2.2">
	<buginformation>
		<summary>Function.prototype</summary>
		<description>The value of Function.prototype is %FunctionPrototype%, the intrinsic Function prototype object. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.2.3.1">
	<buginformation>
		<summary>Function.prototype.apply ( thisArg, argArray )</summary>
		<description>When the apply method is called on an object func with arguments thisArg and argArray, the following steps are taken: If IsCallable(func) is false, throw a TypeError exception.If argArray is undefined or null, thenPerform PrepareForTailCall().Return ? Call(func, thisArg).Let argList be ? CreateListFromArrayLike(argArray).Perform PrepareForTailCall().Return ? Call(func, thisArg, argList).          Note 1 The thisArg value is passed without modification as the this value. This is a change from Edition 3, where an undefined or null thisArg is replaced with the global object and ToObject is applied to all other values and that result is passed as the this value. Even though the thisArg is passed without modification, non-strict functions still perform these transformations upon entry to the function.  Note 2 If func is an arrow function or a bound function then the thisArg will be ignored by the function [[Call]] in step 5.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.2.3.2">
	<buginformation>
		<summary>Function.prototype.bind ( thisArg, ...args )</summary>
		<description>When the bind method is called with argument thisArg and zero or more args, it performs the following steps: Let Target be the this value.If IsCallable(Target) is false, throw a TypeError exception.Let args be a new (possibly empty) List consisting of all of the argument values provided after thisArg in order.Let F be ? BoundFunctionCreate(Target, thisArg, args).Let targetHasLength be ? HasOwnProperty(Target, &amp;quot;length&amp;quot;).If targetHasLength is true, thenLet targetLen be ? Get(Target, &amp;quot;length&amp;quot;).If Type(targetLen) is not Number, let L be 0.Else,Let targetLen be ToInteger(targetLen).Let L be the larger of 0 and the result of targetLen minus the number of elements of args.Else, let L be 0.Perform ! DefinePropertyOrThrow(F, &amp;quot;length&amp;quot;, PropertyDescriptor {[[Value]]: L, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).Let targetName be ? Get(Target, &amp;quot;name&amp;quot;).If Type(targetName) is not String, let targetName be the empty string.Perform SetFunctionName(F, targetName, &amp;quot;bound&amp;quot;).Return F.          Note 1 Function objects created using Function.prototype.bind are exotic objects. They also do not have a prototype property.  Note 2 If Target is an arrow function or a bound function then the thisArg passed to this method will not be used by subsequent calls to F.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.2.3.3">
	<buginformation>
		<summary>Function.prototype.call ( thisArg, ...args )</summary>
		<description>When the call method is called on an object func with argument, thisArg and zero or more args, the following steps are taken: If IsCallable(func) is false, throw a TypeError exception.Let argList be a new empty List.If  this method was called with more than one argument, then in left to  right order, starting with the second argument, append each argument as  the last element of argList.Perform PrepareForTailCall().Return ? Call(func, thisArg, argList).          Note 1 The thisArg value is passed without modification as the this value. This is a change from Edition 3, where an undefined or null thisArg is replaced with the global object and ToObject is applied to all other values and that result is passed as the this value. Even though the thisArg is passed without modification, non-strict functions still perform these transformations upon entry to the function.  Note 2 If func is an arrow function or a bound function then the thisArg will be ignored by the function [[Call]] in step 5.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.2.3.4">
	<buginformation>
		<summary>Function.prototype.constructor</summary>
		<description>The initial value of Function.prototype.constructor is the intrinsic object %Function%.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.2.3.5">
	<buginformation>
		<summary>Function.prototype.toString ( )</summary>
		<description>When the toString method is called on an object func, the following steps are taken: If func is a Bound Function exotic object, thenReturn an implementation-dependent String source code representation of func. The representation must conform to the rules below. It is implementation-dependent whether the representation includes bound function information or information about the target function.If Type(func) is Object and is either a built-in function object or has an [[ECMAScriptCode]] internal slot, thenReturn an implementation-dependent String source code representation of func. The representation must conform to the rules below.Throw a TypeError exception.          toString Representation Requirements:               The string representation must have the syntax of a FunctionDeclaration, FunctionExpression, GeneratorDeclaration, GeneratorExpression, AsyncFunctionDeclaration, AsyncFunctionExpression, ClassDeclaration, ClassExpression, ArrowFunction, AsyncArrowFunction, or MethodDefinition depending upon the actual characteristics of the object.                                    The use and placement of white space, line terminators, and  semicolons within the representation String is implementation-dependent.                                    If the object was defined using ECMAScript code and the returned string representation is not in the form of a MethodDefinition or GeneratorMethod then the representation must be such that if the string is evaluated, using eval  in a lexical context that is equivalent to the lexical context used to  create the original object, it will result in a new functionally  equivalent object. In that case the returned source code must not  mention freely any variables that were not mentioned freely by the  original function&apos;s source code, even if these “extra” names were  originally in scope.                                    If the implementation cannot produce a source code string  that meets these criteria then it must return a string for which eval will throw a SyntaxError exception.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.2.3.6">
	<buginformation>
		<summary>Function.prototype [ @@hasInstance ] ( V )</summary>
		<description>When the @@hasInstance method of an object F is called with value V, the following steps are taken: Let F be the this value.Return ? OrdinaryHasInstance(F, V).          The value of the name property of this function is &amp;quot;[Symbol.hasInstance]&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. Note This is the default implementation of @@hasInstance that most functions inherit. @@hasInstance is called by the instanceof operator to determine whether a value is an instance of a specific constructor. An expression such as v instanceof F evaluates as F[@@hasInstance](v) A constructor function can control which objects are recognized as its instances by instanceof by exposing a different @@hasInstance method on the function.  This property is non-writable and non-configurable to prevent  tampering that could be used to globally expose the target function of a  bound function.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.2.4.1">
	<buginformation>
		<summary>length</summary>
		<description>The value of the length property is an integer  that indicates the typical number of arguments expected by the function.  However, the language permits the function to be invoked with some  other number of arguments. The behaviour of a function when invoked on a  number of arguments other than the number specified by its length property depends on the function. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.2.4.2">
	<buginformation>
		<summary>name</summary>
		<description>The value of the name property is a String that  is descriptive of the function. The name has no semantic significance  but is typically a variable or property name that is used to refer to  the function at its point of definition in ECMAScript code. This  property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. Anonymous functions objects that do not have a contextual name associated with them by this specification do not have a name own property but inherit the name property of %FunctionPrototype%.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.2.4.3">
	<buginformation>
		<summary>prototype</summary>
		<description>Function instances that can be used as a constructor have a prototype  property. Whenever such a Function instance is created another ordinary  object is also created and is the initial value of the function&apos;s prototype property. Unless otherwise specified, the value of the prototype  property is used to initialize the [[Prototype]] internal slot of the  object created when that function is invoked as a constructor. This property has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }. Note Function objects created using Function.prototype.bind, or by evaluating a MethodDefinition (that is not a GeneratorMethod) or an ArrowFunction do not have a prototype property.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.3.1.1">
	<buginformation>
		<summary>Boolean ( value )</summary>
		<description>When Boolean is called with argument value, the following steps are taken: Let b be ToBoolean(value).If NewTarget is undefined, return b.Let O be ? OrdinaryCreateFromConstructor(NewTarget, &amp;quot;%BooleanPrototype%&amp;quot;, « [[BooleanData]] »).Set O.[[BooleanData]] to b.Return O.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.3.2.1">
	<buginformation>
		<summary>Boolean.prototype</summary>
		<description>The initial value of Boolean.prototype is the intrinsic object %BooleanPrototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.3.3.1">
	<buginformation>
		<summary>Boolean.prototype.constructor</summary>
		<description>The initial value of Boolean.prototype.constructor is the intrinsic object %Boolean%.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.3.3.2">
	<buginformation>
		<summary>Boolean.prototype.toString ( )</summary>
		<description>The following steps are taken: Let b be ? thisBooleanValue(this value).If b is true, return &amp;quot;true&amp;quot;; else return &amp;quot;false&amp;quot;.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.3.3.3">
	<buginformation>
		<summary>Boolean.prototype.valueOf ( )</summary>
		<description>The following steps are taken: Return ? thisBooleanValue(this value).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.3.4">
	<buginformation>
		<summary>Properties of Boolean Instances</summary>
		<description>Boolean instances are ordinary objects that inherit properties  from the Boolean prototype object. Boolean instances have a  [[BooleanData]] internal slot. The [[BooleanData]] internal slot is the  Boolean value represented by this Boolean object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.1.1">
	<buginformation>
		<summary>Symbol ( [ description ] )</summary>
		<description>When Symbol is called with optional argument description, the following steps are taken: If NewTarget is not undefined, throw a TypeError exception.If description is undefined, let descString be undefined.Else, let descString be ? ToString(description).Return a new unique Symbol value whose [[Description]] value is descString.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.2.1">
	<buginformation>
		<summary>Symbol.for ( key )</summary>
		<description>When Symbol.for is called with argument key it performs the following steps: Let stringKey be ? ToString(key).For each element e of the GlobalSymbolRegistry List, doIf SameValue(e.[[Key]], stringKey) is true, return e.[[Symbol]].Assert: GlobalSymbolRegistry does not currently contain an entry for stringKey.Let newSymbol be a new unique Symbol value whose [[Description]] value is stringKey.Append the Record { [[Key]]: stringKey, [[Symbol]]: newSymbol } to the GlobalSymbolRegistry List.Return newSymbol.          The GlobalSymbolRegistry is a List  that is globally available. It is shared by all realms. Prior to the  evaluation of any ECMAScript code it is initialized as a new empty List. Elements of the GlobalSymbolRegistry are Records with the structure defined in  Table 45. Table 45: GlobalSymbolRegistry Record Fields                     Field Name                                                Value                                                Usage                                                  [[Key]]                                                A String                                                A string key used to globally identify a Symbol.                                                  [[Symbol]]                                                A Symbol                                                A symbol that can be retrieved from any realm.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.2.2">
	<buginformation>
		<summary>Symbol.hasInstance</summary>
		<description>The initial value of Symbol.hasInstance is the well-known symbol @@hasInstance (Table 1). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.2.3">
	<buginformation>
		<summary>Symbol.isConcatSpreadable</summary>
		<description>The initial value of Symbol.isConcatSpreadable is the well-known symbol @@isConcatSpreadable (Table 1). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.2.4">
	<buginformation>
		<summary>Symbol.iterator</summary>
		<description>The initial value of Symbol.iterator is the well-known symbol @@iterator (Table 1). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.2.5">
	<buginformation>
		<summary>Symbol.keyFor ( sym )</summary>
		<description>When Symbol.keyFor is called with argument sym it performs the following steps: If Type(sym) is not Symbol, throw a TypeError exception.For each element e of the GlobalSymbolRegistry List (see 19.4.2.1), doIf SameValue(e.[[Symbol]], sym) is true, return e.[[Key]].Assert: GlobalSymbolRegistry does not currently contain an entry for sym.Return undefined.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.2.6">
	<buginformation>
		<summary>Symbol.match</summary>
		<description>The initial value of Symbol.match is the well-known symbol @@match (Table 1). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.2.7">
	<buginformation>
		<summary>Symbol.prototype</summary>
		<description>The initial value of Symbol.prototype is the intrinsic object %SymbolPrototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.2.8">
	<buginformation>
		<summary>Symbol.replace</summary>
		<description>The initial value of Symbol.replace is the well-known symbol @@replace (Table 1). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.2.9">
	<buginformation>
		<summary>Symbol.search</summary>
		<description>The initial value of Symbol.search is the well-known symbol @@search (Table 1). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.2.10">
	<buginformation>
		<summary>Symbol.species</summary>
		<description>The initial value of Symbol.species is the well-known symbol @@species (Table 1). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.2.11">
	<buginformation>
		<summary>Symbol.split</summary>
		<description>The initial value of Symbol.split is the well-known symbol @@split (Table 1). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.2.12">
	<buginformation>
		<summary>Symbol.toPrimitive</summary>
		<description>The initial value of Symbol.toPrimitive is the well-known symbol @@toPrimitive (Table 1). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.2.13">
	<buginformation>
		<summary>Symbol.toStringTag</summary>
		<description>The initial value of Symbol.toStringTag is the well-known symbol @@toStringTag (Table 1). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.2.14">
	<buginformation>
		<summary>Symbol.unscopables</summary>
		<description>The initial value of Symbol.unscopables is the well-known symbol @@unscopables (Table 1). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.3.1">
	<buginformation>
		<summary>Symbol.prototype.constructor</summary>
		<description>The initial value of Symbol.prototype.constructor is the intrinsic object %Symbol%.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.3.2.1">
	<buginformation>
		<summary>Runtime Semantics: SymbolDescriptiveString ( sym )</summary>
		<description>When the abstract operation SymbolDescriptiveString is called with argument sym, the following steps are taken: Assert: Type(sym) is Symbol.Let desc be sym&apos;s [[Description]] value.If desc is undefined, let desc be the empty string.Assert: Type(desc) is String.Return the result of concatenating the strings &amp;quot;Symbol(&amp;quot;, desc, and &amp;quot;)&amp;quot;.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.3.3">
	<buginformation>
		<summary>Symbol.prototype.valueOf ( )</summary>
		<description>The following steps are taken: Let s be the this value.If Type(s) is Symbol, return s.If Type(s) is not Object, throw a TypeError exception.If s does not have a [[SymbolData]] internal slot, throw a TypeError exception.Return s.[[SymbolData]].</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.3.4">
	<buginformation>
		<summary>Symbol.prototype [ @@toPrimitive ] ( hint )</summary>
		<description>This function is called by ECMAScript language operators to  convert a Symbol object to a primitive value. The allowed values for hint are &amp;quot;default&amp;quot;, &amp;quot;number&amp;quot;, and &amp;quot;string&amp;quot;. When the @@toPrimitive method is called with argument hint, the following steps are taken: Let s be the this value.If Type(s) is Symbol, return s.If Type(s) is not Object, throw a TypeError exception.If s does not have a [[SymbolData]] internal slot, throw a TypeError exception.Return s.[[SymbolData]].          The value of the name property of this function is &amp;quot;[Symbol.toPrimitive]&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.3.5">
	<buginformation>
		<summary>Symbol.prototype [ @@toStringTag ]</summary>
		<description>The initial value of the @@toStringTag property is the String value &amp;quot;Symbol&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.4.4">
	<buginformation>
		<summary>Properties of Symbol Instances</summary>
		<description>Symbol instances are ordinary objects that inherit properties  from the Symbol prototype object. Symbol instances have a [[SymbolData]]  internal slot. The [[SymbolData]] internal slot is the Symbol value  represented by this Symbol object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.5.1.1">
	<buginformation>
		<summary>Error ( message )</summary>
		<description>When the Error function is called with argument message, the following steps are taken: If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.Let O be ? OrdinaryCreateFromConstructor(newTarget, &amp;quot;%ErrorPrototype%&amp;quot;, « [[ErrorData]] »).If message is not undefined, thenLet msg be ? ToString(message).Let msgDesc be the PropertyDescriptor{[[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}.Perform ! DefinePropertyOrThrow(O, &amp;quot;message&amp;quot;, msgDesc).Return O.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.5.2.1">
	<buginformation>
		<summary>Error.prototype</summary>
		<description>The initial value of Error.prototype is the intrinsic object %ErrorPrototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.5.3.1">
	<buginformation>
		<summary>Error.prototype.constructor</summary>
		<description>The initial value of Error.prototype.constructor is the intrinsic object %Error%.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.5.3.2">
	<buginformation>
		<summary>Error.prototype.message</summary>
		<description>The initial value of Error.prototype.message is the empty String.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.5.3.3">
	<buginformation>
		<summary>Error.prototype.name</summary>
		<description>The initial value of Error.prototype.name is &amp;quot;Error&amp;quot;.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.5.3.4">
	<buginformation>
		<summary>Error.prototype.toString ( )</summary>
		<description>The following steps are taken: Let O be the this value.If Type(O) is not Object, throw a TypeError exception.Let name be ? Get(O, &amp;quot;name&amp;quot;).If name is undefined, let name be &amp;quot;Error&amp;quot;; otherwise let name be ? ToString(name).Let msg be ? Get(O, &amp;quot;message&amp;quot;).If msg is undefined, let msg be the empty String; otherwise let msg be ? ToString(msg).If name is the empty String, return msg.If msg is the empty String, return name.Return the result of concatenating name, the code unit 0x003A (COLON), the code unit 0x0020 (SPACE), and msg.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.5.4">
	<buginformation>
		<summary>Properties of Error Instances</summary>
		<description>Error instances are ordinary objects that inherit properties  from the Error prototype object and have an [[ErrorData]] internal slot  whose value is undefined. The only specified uses of [[ErrorData]] is to identify Error and NativeError instances as Error objects within Object.prototype.toString.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.5.5.1">
	<buginformation>
		<summary>EvalError</summary>
		<description>This exception is not currently used within this  specification. This object remains for compatibility with previous  editions of this specification.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.5.5.2">
	<buginformation>
		<summary>RangeError</summary>
		<description>Indicates a value that is not in the set or range of allowable values.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.5.5.3">
	<buginformation>
		<summary>ReferenceError</summary>
		<description>Indicate that an invalid reference value has been detected.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.5.5.4">
	<buginformation>
		<summary>SyntaxError</summary>
		<description>Indicates that a parsing error has occurred.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.5.5.5">
	<buginformation>
		<summary>TypeError</summary>
		<description>TypeError is used to indicate an unsuccessful operation when none of the other NativeError objects are an appropriate indication of the failure cause.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.5.5.6">
	<buginformation>
		<summary>URIError</summary>
		<description>Indicates that one of the global URI handling functions was used in a way that is incompatible with its definition.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.5.6.1.1">
	<buginformation>
		<summary>NativeError ( message )</summary>
		<description>When a NativeError function is called with argument message, the following steps are taken: If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.Let O be ? OrdinaryCreateFromConstructor(newTarget, &amp;quot;%NativeErrorPrototype%&amp;quot;, « [[ErrorData]] »).If message is not undefined, thenLet msg be ? ToString(message).Let msgDesc be the PropertyDescriptor{[[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}.Perform ! DefinePropertyOrThrow(O, &amp;quot;message&amp;quot;, msgDesc).Return O.            The actual value of the string passed in step 2 is either &amp;quot;%EvalErrorPrototype%&amp;quot;, &amp;quot;%RangeErrorPrototype%&amp;quot;, &amp;quot;%ReferenceErrorPrototype%&amp;quot;, &amp;quot;%SyntaxErrorPrototype%&amp;quot;, &amp;quot;%TypeErrorPrototype%&amp;quot;, or &amp;quot;%URIErrorPrototype%&amp;quot; corresponding to which NativeError constructor is being defined.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.5.6.2.1">
	<buginformation>
		<summary>NativeError.prototype</summary>
		<description>The initial value of  NativeError.prototype is a NativeError prototype object (19.5.6.3). Each NativeError constructor has a distinct prototype object. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.5.6.3.1">
	<buginformation>
		<summary>NativeError.prototype.constructor</summary>
		<description>The initial value of the constructor property of the prototype for a given NativeError constructor is the corresponding intrinsic object %NativeError% (19.5.6.1).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.5.6.3.2">
	<buginformation>
		<summary>NativeError.prototype.message</summary>
		<description>The initial value of the message property of the prototype for a given NativeError constructor is the empty String.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.5.6.3.3">
	<buginformation>
		<summary>NativeError.prototype.name</summary>
		<description>The initial value of the name property of the prototype for a given NativeError constructor is a String consisting of the name of the constructor (the name used instead of NativeError).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="19.5.6.4">
	<buginformation>
		<summary>Properties of NativeError Instances</summary>
		<description>NativeError instances are ordinary objects that inherit properties from their NativeError prototype object and have an [[ErrorData]] internal slot whose value is undefined. The only specified use of [[ErrorData]] is by Object.prototype.toString (19.1.3.6) to identify Error or NativeError instances.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.1.1">
	<buginformation>
		<summary>Number ( value )</summary>
		<description>When Number is called with argument value, the following steps are taken: If no arguments were passed to this function invocation, let n be +0.Else, let n be ? ToNumber(value).If NewTarget is undefined, return n.Let O be ? OrdinaryCreateFromConstructor(NewTarget, &amp;quot;%NumberPrototype%&amp;quot;, « [[NumberData]] »).Set O.[[NumberData]] to n.Return O.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.2.1">
	<buginformation>
		<summary>Number.EPSILON</summary>
		<description>The value of Number.EPSILON is the difference between 1 and  the smallest value greater than 1 that is representable as a Number  value, which is approximately 2.2204460492503130808472633361816 x 10-16. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.2.2">
	<buginformation>
		<summary>Number.isFinite ( number )</summary>
		<description>When Number.isFinite is called with one argument number, the following steps are taken: If Type(number) is not Number, return false.If number is NaN, +∞, or -∞, return false.Otherwise, return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.2.3">
	<buginformation>
		<summary>Number.isInteger ( number )</summary>
		<description>When Number.isInteger is called with one argument number, the following steps are taken: If Type(number) is not Number, return false.If number is NaN, +∞, or -∞, return false.Let integer be ToInteger(number).If integer is not equal to number, return false.Otherwise, return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.2.4">
	<buginformation>
		<summary>Number.isNaN ( number )</summary>
		<description>When Number.isNaN is called with one argument number, the following steps are taken: If Type(number) is not Number, return false.If number is NaN, return true.Otherwise, return false.          Note This function differs from the global isNaN function (18.2.3) in that it does not convert its argument to a Number before determining whether it is NaN.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.2.5">
	<buginformation>
		<summary>Number.isSafeInteger ( number )</summary>
		<description>When Number.isSafeInteger is called with one argument number, the following steps are taken: If Type(number) is not Number, return false.If number is NaN, +∞, or -∞, return false.Let integer be ToInteger(number).If integer is not equal to number, return false.If abs(integer) ≤ 253-1, return true.Otherwise, return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.2.6">
	<buginformation>
		<summary>Number.MAX_SAFE_INTEGER</summary>
		<description>Note The value of Number.MAX_SAFE_INTEGER is the largest integer n such that n and n + 1 are both exactly representable as a Number value.  The value of Number.MAX_SAFE_INTEGER is 9007199254740991 (253-1). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.2.7">
	<buginformation>
		<summary>Number.MAX_VALUE</summary>
		<description>The value of Number.MAX_VALUE is the largest positive finite value of the Number type, which is approximately  1.7976931348623157 × 10308. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.2.8">
	<buginformation>
		<summary>Number.MIN_SAFE_INTEGER</summary>
		<description>Note The value of Number.MIN_SAFE_INTEGER is the smallest integer n such that n and n - 1 are both exactly representable as a Number value.  The value of Number.MIN_SAFE_INTEGER is -9007199254740991 (-(253-1)). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.2.9">
	<buginformation>
		<summary>Number.MIN_VALUE</summary>
		<description>The value of Number.MIN_VALUE is the smallest positive value of the Number type, which is approximately  5 × 10-324. In the IEEE 754-2008 double precision binary representation,  the smallest possible value is a denormalized number. If an  implementation does not support denormalized values, the value of Number.MIN_VALUE must be the smallest non-zero positive value that can actually be represented by the implementation. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.2.10">
	<buginformation>
		<summary>Number.NaN</summary>
		<description>The value of Number.NaN is NaN. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.2.11">
	<buginformation>
		<summary>Number.NEGATIVE_INFINITY</summary>
		<description>The value of Number.NEGATIVE_INFINITY is -∞. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.2.12">
	<buginformation>
		<summary>Number.parseFloat ( string )</summary>
		<description>The value of the Number.parseFloat data property is the same built-in function object that is the value of the parseFloat property of the global object defined in  18.2.4.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.2.13">
	<buginformation>
		<summary>Number.parseInt ( string, radix )</summary>
		<description>The value of the Number.parseInt data property is the same built-in function object that is the value of the parseInt property of the global object defined in  18.2.5.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.2.14">
	<buginformation>
		<summary>Number.POSITIVE_INFINITY</summary>
		<description>The value of Number.POSITIVE_INFINITY is +∞. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.2.15">
	<buginformation>
		<summary>Number.prototype</summary>
		<description>The initial value of Number.prototype is the intrinsic object %NumberPrototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.3.1">
	<buginformation>
		<summary>Number.prototype.constructor</summary>
		<description>The initial value of Number.prototype.constructor is the intrinsic object %Number%.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.3.2">
	<buginformation>
		<summary>Number.prototype.toExponential ( fractionDigits )</summary>
		<description>Return a String containing this Number value represented in  decimal exponential notation with one digit before the significand&apos;s  decimal point and fractionDigits digits after the significand&apos;s decimal point. If fractionDigits is undefined, include as many significand digits as necessary to uniquely specify the Number (just like in ToString except that in this case the Number is always output in exponential notation). Specifically, perform the following steps: Let x be ? thisNumberValue(this value).Let f be ? ToInteger(fractionDigits).Assert: f is 0, when fractionDigits is undefined.If x is NaN, return the String &amp;quot;NaN&amp;quot;.Let s be the empty String.If x &lt; 0, thenLet s be &amp;quot;-&amp;quot;.Let x be -x.If x</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.3.3">
	<buginformation>
		<summary>Number.prototype.toFixed ( fractionDigits )</summary>
		<description>Note 1 toFixed returns a String containing this Number value represented in decimal fixed-point notation with fractionDigits digits after the decimal point. If fractionDigits is undefined, 0 is assumed.  The following steps are performed: Let x be ? thisNumberValue(this value).Let f be ? ToInteger(fractionDigits). (If fractionDigits is undefined, this step produces the value 0.)If f &lt; 0 or f &gt; 20, throw a RangeError exception. However, an implementation is permitted to extend the behaviour of toFixed for values of f less than 0 or greater than 20. In this case toFixed would not necessarily throw RangeError for such values.If x is NaN, return the String &amp;quot;NaN&amp;quot;.Let s be the empty String.If x &lt; 0, thenLet s be &amp;quot;-&amp;quot;.Let x be -x.If x ≥ 1021, thenLet m be ! ToString(x).Else x &lt; 1021,Let n be an integer for which the exact mathematical value of n ÷ 10f - x is as close to zero as possible. If there are two such n, pick the larger n.If n</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.3.4">
	<buginformation>
		<summary>Number.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )</summary>
		<description>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the Number.prototype.toLocaleString  method as specified in the ECMA-402 specification. If an ECMAScript  implementation does not include the ECMA-402 API the following  specification of the toLocaleString method is used. Produces a String value that represents this Number value  formatted according to the conventions of the host environment&apos;s current  locale. This function is implementation-dependent, and it is  permissible, but not encouraged, for it to return the same thing as toString. The meanings of the optional parameters to this method are  defined in the ECMA-402 specification; implementations that do not  include ECMA-402 support must not use those parameter positions for  anything else.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.3.5">
	<buginformation>
		<summary>Number.prototype.toPrecision ( precision )</summary>
		<description>Return a String containing this Number value represented  either in decimal exponential notation with one digit before the  significand&apos;s decimal point and  precision-1 digits after the significand&apos;s decimal point or in decimal fixed notation with precision significant digits. If precision is undefined, call ToString instead. Specifically, perform the following steps: Let x be ? thisNumberValue(this value).If precision is undefined, return ! ToString(x).Let p be ? ToInteger(precision).If x is NaN, return the String &amp;quot;NaN&amp;quot;.Let s be the empty String.If x &lt; 0, thenLet s be code unit 0x002D (HYPHEN-MINUS).Let x be -x.If x</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.3.6">
	<buginformation>
		<summary>Number.prototype.toString ( [ radix ] )</summary>
		<description>Note The optional radix should be an integer value in the inclusive range 2 to 36. If radix not present or is undefined the Number 10 is used as the value of radix.  The following steps are performed: Let x be ? thisNumberValue(this value).If radix is not present, let radixNumber be 10.Else if radix is undefined, let radixNumber be 10.Else, let radixNumber be ? ToInteger(radix).If radixNumber &lt; 2 or radixNumber &gt; 36, throw a RangeError exception.If radixNumber</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.3.7">
	<buginformation>
		<summary>Number.prototype.valueOf ( )</summary>
		<description>Return ? thisNumberValue(this value).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.1.4">
	<buginformation>
		<summary>Properties of Number Instances</summary>
		<description>Number instances are ordinary objects that inherit properties  from the Number prototype object. Number instances also have a  [[NumberData]] internal slot. The [[NumberData]] internal slot is the  Number value represented by this Number object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.1.1">
	<buginformation>
		<summary>Math.E</summary>
		<description>The Number value for e, the base of the natural logarithms, which is approximately 2.7182818284590452354. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.1.2">
	<buginformation>
		<summary>Math.LN10</summary>
		<description>The Number value for the natural logarithm of 10, which is approximately 2.302585092994046. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.1.3">
	<buginformation>
		<summary>Math.LN2</summary>
		<description>The Number value for the natural logarithm of 2, which is approximately 0.6931471805599453. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.1.4">
	<buginformation>
		<summary>Math.LOG10E</summary>
		<description>The Number value for the base-10 logarithm of e, the base of the natural logarithms; this value is approximately 0.4342944819032518. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. Note The value of Math.LOG10E is approximately the reciprocal of the value of Math.LN10.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.1.5">
	<buginformation>
		<summary>Math.LOG2E</summary>
		<description>The Number value for the base-2 logarithm of e, the base of the natural logarithms; this value is approximately 1.4426950408889634. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. Note The value of Math.LOG2E is approximately the reciprocal of the value of Math.LN2.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.1.6">
	<buginformation>
		<summary>Math.PI</summary>
		<description>The Number value for π, the ratio of the circumference of a circle to its diameter, which is approximately 3.1415926535897932. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.1.7">
	<buginformation>
		<summary>Math.SQRT1_2</summary>
		<description>The Number value for the square root of ½, which is approximately 0.7071067811865476. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. Note The value of Math.SQRT1_2 is approximately the reciprocal of the value of Math.SQRT2.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.1.8">
	<buginformation>
		<summary>Math.SQRT2</summary>
		<description>The Number value for the square root of 2, which is approximately 1.4142135623730951. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.1.9">
	<buginformation>
		<summary>Math [ @@toStringTag ]</summary>
		<description>The initial value of the @@toStringTag property is the String value &amp;quot;Math&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.1">
	<buginformation>
		<summary>Math.abs ( x )</summary>
		<description>Returns the absolute value of x; the result has the same magnitude as x but has positive sign.               If x is NaN, the result is NaN.                                    If x is -0, the result is +0.                                    If x is -∞, the result is +∞.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.2">
	<buginformation>
		<summary>Math.acos ( x )</summary>
		<description>Returns an implementation-dependent approximation to the arc cosine of x. The result is expressed in radians and ranges from +0 to +π.               If x is NaN, the result is NaN.                                    If x is greater than 1, the result is NaN.                                    If x is less than -1, the result is NaN.                                    If x is exactly 1, the result is +0.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.3">
	<buginformation>
		<summary>Math.acosh ( x )</summary>
		<description>Returns an implementation-dependent approximation to the inverse hyperbolic cosine of x.               If x is NaN, the result is NaN.                                    If x is less than 1, the result is NaN.                                    If x is 1, the result is +0.                                    If x is +∞, the result is +∞.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.4">
	<buginformation>
		<summary>Math.asin ( x )</summary>
		<description>Returns an implementation-dependent approximation to the arc sine of x. The result is expressed in radians and ranges from -π/2 to +π/2.               If x is NaN, the result is NaN.                                    If x is greater than 1, the result is NaN.                                    If x is less than -1, the result is NaN.                                    If x is +0, the result is +0.                                    If x is -0, the result is -0.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.5">
	<buginformation>
		<summary>Math.asinh ( x )</summary>
		<description>Returns an implementation-dependent approximation to the inverse hyperbolic sine of x.               If x is NaN, the result is NaN.                                    If x is +0, the result is +0.                                    If x is -0, the result is -0.                                    If x is +∞, the result is +∞.                                    If x is -∞, the result is -∞.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.6">
	<buginformation>
		<summary>Math.atan ( x )</summary>
		<description>Returns an implementation-dependent approximation to the arc tangent of x. The result is expressed in radians and ranges from -π/2 to +π/2.               If x is NaN, the result is NaN.                                    If x is +0, the result is +0.                                    If x is -0, the result is -0.                                    If x is +∞, the result is an implementation-dependent approximation to +π/2.                                    If x is -∞, the result is an implementation-dependent approximation to -π/2.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.7">
	<buginformation>
		<summary>Math.atanh ( x )</summary>
		<description>Returns an implementation-dependent approximation to the inverse hyperbolic tangent of x.               If x is NaN, the result is NaN.                                    If x is less than -1, the result is NaN.                                    If x is greater than 1, the result is NaN.                                    If x is -1, the result is -∞.                                    If x is +1, the result is +∞.                                    If x is +0, the result is +0.                                    If x is -0, the result is -0.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.8">
	<buginformation>
		<summary>Math.atan2 ( y, x )</summary>
		<description>Returns an implementation-dependent approximation to the arc tangent of the quotient  y/x of the arguments y and x, where the signs of y and x  are used to determine the quadrant of the result. Note that it is  intentional and traditional for the two-argument arc tangent function  that the argument named y be first and the argument named x be second. The result is expressed in radians and ranges from -π to +π.               If either x or y is NaN, the result is NaN.                                    If y&gt;0 and x is +0, the result is an implementation-dependent approximation to +π/2.                                    If y&gt;0 and x is -0, the result is an implementation-dependent approximation to +π/2.                                    If y is +0 and x&gt;0, the result is +0.                                    If y is +0 and x is +0, the result is +0.                                    If y is +0 and x is -0, the result is an implementation-dependent approximation to +π.                                    If y is +0 and x&lt;0, the result is an implementation-dependent approximation to +π.                                    If y is -0 and x&gt;0, the result is -0.                                    If y is -0 and x is +0, the result is -0.                                    If y is -0 and x is -0, the result is an implementation-dependent approximation to -π.                                    If y is -0 and x&lt;0, the result is an implementation-dependent approximation to -π.                                    If y&lt;0 and x is +0, the result is an implementation-dependent approximation to -π/2.                                    If y&lt;0 and x is -0, the result is an implementation-dependent approximation to -π/2.                                    If y&gt;0 and y is finite and x is +∞, the result is +0.                                    If y&gt;0 and y is finite and x is -∞, the result is an implementation-dependent approximation to +π.                                    If y&lt;0 and y is finite and x is +∞, the result is -0.                                    If y&lt;0 and y is finite and x is -∞, the result is an implementation-dependent approximation to -π.                                    If y is +∞ and x is finite, the result is an implementation-dependent approximation to +π/2.                                    If y is -∞ and x is finite, the result is an implementation-dependent approximation to -π/2.                                    If y is +∞ and x is +∞, the result is an implementation-dependent approximation to +π/4.                                    If y is +∞ and x is -∞, the result is an implementation-dependent approximation to +3π/4.                                    If y is -∞ and x is +∞, the result is an implementation-dependent approximation to -π/4.                                    If y is -∞ and x is -∞, the result is an implementation-dependent approximation to -3π/4.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.9">
	<buginformation>
		<summary>Math.cbrt ( x )</summary>
		<description>Returns an implementation-dependent approximation to the cube root of x.               If x is NaN, the result is NaN.                                    If x is +0, the result is +0.                                    If x is -0, the result is -0.                                    If x is +∞, the result is +∞.                                    If x is -∞, the result is -∞.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.10">
	<buginformation>
		<summary>Math.ceil ( x )</summary>
		<description>Returns the smallest (closest to -∞) Number value that is not less than x and is equal to a mathematical integer. If x is already an integer, the result is x.               If x is NaN, the result is NaN.                                    If x is +0, the result is +0.                                    If x is -0, the result is -0.                                    If x is +∞, the result is +∞.                                    If x is -∞, the result is -∞.                                    If x is less than 0 but greater than -1, the result is -0.                        The value of Math.ceil(x) is the same as the value of -Math.floor(-x).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.11">
	<buginformation>
		<summary>Math.clz32 ( x )</summary>
		<description>When Math.clz32 is called with one argument x, the following steps are taken: Let n be ToUint32(x).Let p be the number of leading zero bits in the 32-bit binary representation of n.Return p.          Note If n is 0, p will be 32. If the most significant bit of the 32-bit binary encoding of n is 1, p will be 0.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.12">
	<buginformation>
		<summary>Math.cos ( x )</summary>
		<description>Returns an implementation-dependent approximation to the cosine of x. The argument is expressed in radians.               If x is NaN, the result is NaN.                                    If x is +0, the result is 1.                                    If x is -0, the result is 1.                                    If x is +∞, the result is NaN.                                    If x is -∞, the result is NaN.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.13">
	<buginformation>
		<summary>Math.cosh ( x )</summary>
		<description>Returns an implementation-dependent approximation to the hyperbolic cosine of x.               If x is NaN, the result is NaN.                                    If x is +0, the result is 1.                                    If x is -0, the result is 1.                                    If x is +∞, the result is +∞.                                    If x is -∞, the result is +∞.                        Note The value of cosh(x) is the same as  (exp(x) + exp(-x))/2.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.14">
	<buginformation>
		<summary>Math.exp ( x )</summary>
		<description>Returns an implementation-dependent approximation to the exponential function of x (e raised to the power of x, where e is the base of the natural logarithms).               If x is NaN, the result is NaN.                                    If x is +0, the result is 1.                                    If x is -0, the result is 1.                                    If x is +∞, the result is +∞.                                    If x is -∞, the result is +0.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.15">
	<buginformation>
		<summary>Math.expm1 ( x )</summary>
		<description>Returns an implementation-dependent approximation to subtracting 1 from the exponential function of x (e raised to the power of x, where e is the base of the natural logarithms). The result is computed in a way that is accurate even when the value of x is close 0.               If x is NaN, the result is NaN.                                    If x is +0, the result is +0.                                    If x is -0, the result is -0.                                    If x is +∞, the result is +∞.                                    If x is -∞, the result is -1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.16">
	<buginformation>
		<summary>Math.floor ( x )</summary>
		<description>Returns the greatest (closest to +∞) Number value that is not greater than x and is equal to a mathematical integer. If x is already an integer, the result is x.               If x is NaN, the result is NaN.                                    If x is +0, the result is +0.                                    If x is -0, the result is -0.                                    If x is +∞, the result is +∞.                                    If x is -∞, the result is -∞.                                    If x is greater than 0 but less than 1, the result is +0.                        Note The value of Math.floor(x) is the same as the value of -Math.ceil(-x).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.17">
	<buginformation>
		<summary>Math.fround ( x )</summary>
		<description>When Math.fround is called with argument x, the following steps are taken: If x is NaN, return NaN.If x is one of +0, -0, +∞, -∞, return x.Let x32 be the result of converting x to a value in IEEE 754-2008 binary32 format using roundTiesToEven.Let x64 be the result of converting x32 to a value in IEEE 754-2008 binary64 format.Return the ECMAScript Number value corresponding to x64.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.18">
	<buginformation>
		<summary>Math.hypot ( value1, value2, ...values )</summary>
		<description>Math.hypot returns an implementation-dependent approximation of the square root of the sum of squares of its arguments.               If no arguments are passed, the result is +0.                                    If any argument is +∞, the result is +∞.                                    If any argument is -∞, the result is +∞.                                    If no argument is +∞ or -∞, and any argument is NaN, the result is NaN.                                    If all arguments are either +0 or -0, the result is +0.                        Note Implementations should take care to avoid the loss of  precision from overflows and underflows that are prone to occur in naive  implementations when this function is called with two or more  arguments.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.19">
	<buginformation>
		<summary>Math.imul ( x, y )</summary>
		<description>When Math.imul is called with arguments x and y, the following steps are taken: Let a be ToUint32(x).Let b be ToUint32(y).Let product be (a × b) modulo 232.If product ≥ 231, return product - 232; otherwise return product.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.20">
	<buginformation>
		<summary>Math.log ( x )</summary>
		<description>Returns an implementation-dependent approximation to the natural logarithm of x.               If x is NaN, the result is NaN.                                    If x is less than 0, the result is NaN.                                    If x is +0 or -0, the result is -∞.                                    If x is 1, the result is +0.                                    If x is +∞, the result is +∞.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.21">
	<buginformation>
		<summary>Math.log1p ( x )</summary>
		<description>Returns an implementation-dependent approximation to the natural logarithm of 1 + x. The result is computed in a way that is accurate even when the value of x is close to zero.               If x is NaN, the result is NaN.                                    If x is less than -1, the result is NaN.                                    If x is -1, the result is -∞.                                    If x is +0, the result is +0.                                    If x is -0, the result is -0.                                    If x is +∞, the result is +∞.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.22">
	<buginformation>
		<summary>Math.log10 ( x )</summary>
		<description>Returns an implementation-dependent approximation to the base 10 logarithm of x.               If x is NaN, the result is NaN.                                    If x is less than 0, the result is NaN.                                    If x is +0, the result is -∞.                                    If x is -0, the result is -∞.                                    If x is 1, the result is +0.                                    If x is +∞, the result is +∞.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.23">
	<buginformation>
		<summary>Math.log2 ( x )</summary>
		<description>Returns an implementation-dependent approximation to the base 2 logarithm of x.               If x is NaN, the result is NaN.                                    If x is less than 0, the result is NaN.                                    If x is +0, the result is -∞.                                    If x is -0, the result is -∞.                                    If x is 1, the result is +0.                                    If x is +∞, the result is +∞.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.24">
	<buginformation>
		<summary>Math.max ( value1, value2, ...values )</summary>
		<description>Given zero or more arguments, calls ToNumber on each of the arguments and returns the largest of the resulting values.               If no arguments are given, the result is -∞.                                    If any value is NaN, the result is NaN.                                    The comparison of values to determine the largest value is done using the Abstract Relational Comparison algorithm except that +0 is considered to be larger than -0.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.25">
	<buginformation>
		<summary>Math.min ( value1, value2, ...values )</summary>
		<description>Given zero or more arguments, calls ToNumber on each of the arguments and returns the smallest of the resulting values.               If no arguments are given, the result is +∞.                                    If any value is NaN, the result is NaN.                                    The comparison of values to determine the smallest value is done using the Abstract Relational Comparison algorithm except that +0 is considered to be larger than -0.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.26">
	<buginformation>
		<summary>Math.pow ( base, exponent )</summary>
		<description>Return the result of  Applying the ** operator with base and exponent as specified in  12.6.4.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.27">
	<buginformation>
		<summary>Math.random ( )</summary>
		<description>Returns a Number value with positive sign, greater than or  equal to 0 but less than 1, chosen randomly or pseudo randomly with  approximately uniform distribution over that range, using an  implementation-dependent algorithm or strategy. This function takes no  arguments. Each Math.random function created for distinct realms must produce a distinct sequence of values from successive calls.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.28">
	<buginformation>
		<summary>Math.round ( x )</summary>
		<description>Returns the Number value that is closest to x and is equal to a mathematical integer. If two integer Number values are equally close to x, then the result is the Number value that is closer to +∞. If x is already an integer, the result is x.               If x is NaN, the result is NaN.                                    If x is +0, the result is +0.                                    If x is -0, the result is -0.                                    If x is +∞, the result is +∞.                                    If x is -∞, the result is -∞.                                    If x is greater than 0 but less than 0.5, the result is +0.                                    If x is less than 0 but greater than or equal to -0.5, the result is -0.                        Note 1 Math.round(3.5) returns 4, but Math.round(-3.5) returns -3.  Note 2 The value of Math.round(x) is not always the same as the value of Math.floor(x+0.5). When x is -0 or is less than 0 but greater than or equal to -0.5, Math.round(x) returns -0, but Math.floor(x+0.5) returns +0. Math.round(x) may also differ from the value of Math.floor(x+0.5)because of internal rounding when computing x+0.5.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.29">
	<buginformation>
		<summary>Math.sign ( x )</summary>
		<description>Returns the sign of x, indicating whether x is positive, negative, or zero.               If x is NaN, the result is NaN.                                    If x is -0, the result is -0.                                    If x is +0, the result is +0.                                    If x is negative and not -0, the result is -1.                                    If x is positive and not +0, the result is +1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.30">
	<buginformation>
		<summary>Math.sin ( x )</summary>
		<description>Returns an implementation-dependent approximation to the sine of x. The argument is expressed in radians.               If x is NaN, the result is NaN.                                    If x is +0, the result is +0.                                    If x is -0, the result is -0.                                    If x is +∞ or -∞, the result is NaN.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.31">
	<buginformation>
		<summary>Math.sinh ( x )</summary>
		<description>Returns an implementation-dependent approximation to the hyperbolic sine of x.               If x is NaN, the result is NaN.                                    If x is +0, the result is +0.                                    If x is -0, the result is -0.                                    If x is +∞, the result is +∞.                                    If x is -∞, the result is -∞.                        Note The value of sinh(x) is the same as  (exp(x) - exp(-x))/2.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.32">
	<buginformation>
		<summary>Math.sqrt ( x )</summary>
		<description>Returns an implementation-dependent approximation to the square root of x.               If x is NaN, the result is NaN.                                    If x is less than 0, the result is NaN.                                    If x is +0, the result is +0.                                    If x is -0, the result is -0.                                    If x is +∞, the result is +∞.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.33">
	<buginformation>
		<summary>Math.tan ( x )</summary>
		<description>Returns an implementation-dependent approximation to the tangent of x. The argument is expressed in radians.               If x is NaN, the result is NaN.                                    If x is +0, the result is +0.                                    If x is -0, the result is -0.                                    If x is +∞ or -∞, the result is NaN.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.34">
	<buginformation>
		<summary>Math.tanh ( x )</summary>
		<description>Returns an implementation-dependent approximation to the hyperbolic tangent of x.               If x is NaN, the result is NaN.                                    If x is +0, the result is +0.                                    If x is -0, the result is -0.                                    If x is +∞, the result is +1.                                    If x is -∞, the result is -1.                        Note The value of tanh(x) is the same as  (exp(x) - exp(-x))/(exp(x) + exp(-x)).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.2.2.35">
	<buginformation>
		<summary>Math.trunc ( x )</summary>
		<description>Returns the integral part of the number x, removing any fractional digits. If x is already an integer, the result is x.               If x is NaN, the result is NaN.                                    If x is -0, the result is -0.                                    If x is +0, the result is +0.                                    If x is +∞, the result is +∞.                                    If x is -∞, the result is -∞.                                    If x is greater than 0 but less than 1, the result is +0.                                    If x is less than 0 but greater than -1, the result is -0.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.1.1">
	<buginformation>
		<summary>Time Values and Time Range</summary>
		<description>A Date object contains a Number indicating a particular instant in time to within a millisecond. Such a Number is called a  time value. A time value may also be NaN, indicating that the Date object does not represent a specific instant of time. Time is measured in ECMAScript in milliseconds since 01  January, 1970 UTC. In time values leap seconds are ignored. It is  assumed that there are exactly 86,400,000 milliseconds per day.  ECMAScript Number values can represent all integers from  -9,007,199,254,740,992 to 9,007,199,254,740,992; this range suffices to  measure times to millisecond precision for any instant that is within  approximately 285,616 years, either forward or backward, from 01  January, 1970 UTC. The actual range of times supported by ECMAScript Date  objects is slightly smaller: exactly -100,000,000 days to 100,000,000  days measured relative to midnight at the beginning of 01 January, 1970  UTC. This gives a range of 8,640,000,000,000,000 milliseconds to either  side of 01 January, 1970 UTC. The exact moment of midnight at the beginning of 01 January, 1970 UTC is represented by the value +0.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.1.2">
	<buginformation>
		<summary>Day Number and Time within Day</summary>
		<description>A given time value t belongs to day number Day(t)</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.1.3">
	<buginformation>
		<summary>Year Number</summary>
		<description>ECMAScript uses an extrapolated Gregorian system to map a day  number to a year number and to determine the month and date within that  year. In this system, leap years are precisely those which are  (divisible by 4) and ((not divisible by 100) or (divisible by 400)). The  number of days in year number y is therefore defined by DaysInYear(y)</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.1.4">
	<buginformation>
		<summary>Month Number</summary>
		<description>Months are identified by an integer in the range 0 to 11, inclusive. The mapping MonthFromTime(t) from a time value t to a month number is defined by: MonthFromTime(t)</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.1.5">
	<buginformation>
		<summary>Date Number</summary>
		<description>A date number is identified by an integer in the range 1 through 31, inclusive. The mapping DateFromTime(t) from a time value t to a date number is defined by: DateFromTime(t)</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.1.6">
	<buginformation>
		<summary>Week Day</summary>
		<description>The weekday for a particular time value t is defined as WeekDay(t)</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.1.7">
	<buginformation>
		<summary>Local Time Zone Adjustment</summary>
		<description>An implementation of ECMAScript is expected to determine the  local time zone adjustment. The local time zone adjustment is a value  LocalTZA measured in milliseconds which when added to UTC represents the local  standard time. Daylight saving time is  not reflected by LocalTZA. Note It is recommended that implementations use the time zone information of the IANA Time Zone Database  https://www.iana.org/time-zones/.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.1.8">
	<buginformation>
		<summary>Daylight Saving Time Adjustment</summary>
		<description>An implementation-dependent algorithm using best available  information on time zones to determine the local daylight saving time  adjustment DaylightSavingTA(t), measured in milliseconds. An  implementation of ECMAScript is expected to make its best effort to  determine the local daylight saving time adjustment. Note It is recommended that implementations use the time zone information of the IANA Time Zone Database  https://www.iana.org/time-zones/.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.1.9">
	<buginformation>
		<summary>LocalTime ( t )</summary>
		<description>The abstract operation LocalTime with argument t converts t from UTC to local time by performing the following steps: Return t + LocalTZA + DaylightSavingTA(t).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.1.10">
	<buginformation>
		<summary>UTC ( t )</summary>
		<description>The abstract operation UTC with argument t converts t from local time to UTC. It performs the following steps: Return t - LocalTZA - DaylightSavingTA(t - LocalTZA).          Note UTC(LocalTime(t)) is not necessarily always equal to t.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.1.11">
	<buginformation>
		<summary>Hours, Minutes, Second, and Milliseconds</summary>
		<description>The following abstract operations are useful in decomposing time values: HourFromTime(t)</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.1.12">
	<buginformation>
		<summary>MakeTime ( hour, min, sec, ms )</summary>
		<description>The abstract operation MakeTime calculates a number of  milliseconds from its four arguments, which must be ECMAScript Number  values. This operator functions as follows: If hour is not finite or min is not finite or sec is not finite or ms is not finite, return NaN.Let h be ! ToInteger(hour).Let m be ! ToInteger(min).Let s be ! ToInteger(sec).Let milli be ! ToInteger(ms).Let t be h * msPerHour + m * msPerMinute + s * msPerSecond + milli, performing the arithmetic according to IEEE 754-2008 rules (that is, as if using the ECMAScript operators * and +).Return t.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.1.13">
	<buginformation>
		<summary>MakeDay ( year, month, date )</summary>
		<description>The abstract operation MakeDay calculates a number of days  from its three arguments, which must be ECMAScript Number values. This  operator functions as follows: If year is not finite or month is not finite or date is not finite, return NaN.Let y be ! ToInteger(year).Let m be ! ToInteger(month).Let dt be ! ToInteger(date).Let ym be y + floor(m / 12).Let mn be m modulo 12.Find a value t such that YearFromTime(t) is ym and MonthFromTime(t) is mn and DateFromTime(t) is 1; but if this is not possible (because some argument is out of range), return NaN.Return Day(t) + dt - 1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.1.14">
	<buginformation>
		<summary>MakeDate ( day, time )</summary>
		<description>The abstract operation MakeDate calculates a number of  milliseconds from its two arguments, which must be ECMAScript Number  values. This operator functions as follows: If day is not finite or time is not finite, return NaN.Return day × msPerDay + time.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.1.15">
	<buginformation>
		<summary>TimeClip ( time )</summary>
		<description>The abstract operation TimeClip calculates a number of  milliseconds from its argument, which must be an ECMAScript Number  value. This operator functions as follows: If time is not finite, return NaN.If abs(time) &gt; 8.64 × 1015, return NaN.Let clippedTime be ! ToInteger(time).If clippedTime is -0, set clippedTime to +0.Return clippedTime.          Note The point of step 4 is that an implementation is permitted a  choice of internal representations of time values, for example as a  64-bit signed integer or as a 64-bit floating-point value. Depending on  the implementation, this internal representation may or may not  distinguish -0 and +0.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.1.16.1">
	<buginformation>
		<summary>Extended Years</summary>
		<description>ECMAScript requires the ability to specify 6 digit years  (extended years); approximately 285,426 years, either forward or  backward, from 01 January, 1970 UTC. To represent years before 0 or  after 9999, ISO 8601 permits the expansion of the year representation,  but only by prior agreement between the sender and the receiver. In the  simplified ECMAScript format such an expanded year representation shall  have 2 extra year digits and is always prefixed with a + or - sign. The  year 0 is considered positive and hence prefixed with a + sign. Note Examples of extended years:     -283457-03-21T15:00:59.008Z 283458 B.C.   -000001-01-01T00:00:00Z 2 B.C.   +000000-01-01T00:00:00Z 1 B.C.   +000001-01-01T00:00:00Z 1 A.D.   +001970-01-01T00:00:00Z 1970 A.D.   +002009-12-15T00:00:00Z 2009 A.D.   +287396-10-12T08:59:00.992Z 287396 A.D.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.2.1">
	<buginformation>
		<summary>Date ( year, month [ , date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] )</summary>
		<description>This description applies only if the Date constructor is called with at least two arguments. When the Date function is called, the following steps are taken: Let numberOfArgs be the number of arguments passed to this function call.Assert: numberOfArgs ≥ 2.If NewTarget is not undefined, thenLet y be ? ToNumber(year).Let m be ? ToNumber(month).If date is supplied, let dt be ? ToNumber(date); else let dt be 1.If hours is supplied, let h be ? ToNumber(hours); else let h be 0.If minutes is supplied, let min be ? ToNumber(minutes); else let min be 0.If seconds is supplied, let s be ? ToNumber(seconds); else let s be 0.If ms is supplied, let milli be ? ToNumber(ms); else let milli be 0.If y is not NaN and 0 ≤ ToInteger(y) ≤ 99, let yr be 1900+ToInteger(y); otherwise, let yr be y.Let finalDate be MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli)).Let O be ? OrdinaryCreateFromConstructor(NewTarget, &amp;quot;%DatePrototype%&amp;quot;, « [[DateValue]] »).Set O.[[DateValue]] to TimeClip(UTC(finalDate)).Return O.Else,Let now be the Number that is the time value (UTC) identifying the current time.Return ToDateString(now).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.2.2">
	<buginformation>
		<summary>Date ( value )</summary>
		<description>This description applies only if the Date constructor is called with exactly one argument. When the Date function is called, the following steps are taken: Let numberOfArgs be the number of arguments passed to this function call.Assert: numberOfArgs</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.2.3">
	<buginformation>
		<summary>Date ( )</summary>
		<description>This description applies only if the Date constructor is called with no arguments. When the Date function is called, the following steps are taken: Let numberOfArgs be the number of arguments passed to this function call.Assert: numberOfArgs</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.3.1">
	<buginformation>
		<summary>Date.now ( )</summary>
		<description>The now function returns a Number value that is the time value designating the UTC date and time of the occurrence of the call to now.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.3.2">
	<buginformation>
		<summary>Date.parse ( string )</summary>
		<description>The parse function applies the ToString operator to its argument. If ToString results in an abrupt completion the Completion Record is immediately returned. Otherwise, parse interprets the resulting String as a date and time; it returns a Number, the UTC time value  corresponding to the date and time. The String may be interpreted as a  local time, a UTC time, or a time in some other time zone, depending on  the contents of the String. The function first attempts to parse the  format of the String according to the rules (including extended years)  called out in Date Time String Format (20.3.1.16).  If the String does not conform to that format the function may fall  back to any implementation-specific heuristics or  implementation-specific date formats. Unrecognizable Strings or dates  containing illegal element values in the format String shall cause Date.parse to return NaN. If x is any Date object whose milliseconds  amount is zero within a particular implementation of ECMAScript, then  all of the following expressions should produce the same numeric value  in that implementation, if all the properties referenced have their  initial values: x.valueOf() Date.parse(x.toString()) Date.parse(x.toUTCString()) Date.parse(x.toISOString()) However, the expression Date.parse(x.toLocaleString()) is not required to produce the same Number value as the preceding three expressions and, in general, the value produced by Date.parse is implementation-dependent when given any String value that does not conform to the Date Time String Format (20.3.1.16) and that could not be produced in that implementation by the toString or toUTCString method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.3.3">
	<buginformation>
		<summary>Date.prototype</summary>
		<description>The initial value of Date.prototype is the intrinsic object %DatePrototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.3.4">
	<buginformation>
		<summary>Date.UTC ( year [ , month [ , date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] ] )</summary>
		<description>When the UTC function is called, the following steps are taken: Let y be ? ToNumber(year).If month is supplied, let m be ? ToNumber(month); else let m be 0.If date is supplied, let dt be ? ToNumber(date); else let dt be 1.If hours is supplied, let h be ? ToNumber(hours); else let h be 0.If minutes is supplied, let min be ? ToNumber(minutes); else let min be 0.If seconds is supplied, let s be ? ToNumber(seconds); else let s be 0.If ms is supplied, let milli be ? ToNumber(ms); else let milli be 0.If y is not NaN and 0 ≤ ToInteger(y) ≤ 99, let yr be 1900+ToInteger(y); otherwise, let yr be y.Return TimeClip(MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli))).          The length property of the UTC function is 7. Note The UTC function differs from the Date constructor in two ways: it returns a time value as a Number, rather than creating a Date object, and it interprets the arguments in UTC rather than as local time.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.1">
	<buginformation>
		<summary>Date.prototype.constructor</summary>
		<description>The initial value of Date.prototype.constructor is the intrinsic object %Date%.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.2">
	<buginformation>
		<summary>Date.prototype.getDate ( )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).If t is NaN, return NaN.Return DateFromTime(LocalTime(t)).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.3">
	<buginformation>
		<summary>Date.prototype.getDay ( )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).If t is NaN, return NaN.Return WeekDay(LocalTime(t)).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.4">
	<buginformation>
		<summary>Date.prototype.getFullYear ( )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).If t is NaN, return NaN.Return YearFromTime(LocalTime(t)).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.5">
	<buginformation>
		<summary>Date.prototype.getHours ( )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).If t is NaN, return NaN.Return HourFromTime(LocalTime(t)).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.6">
	<buginformation>
		<summary>Date.prototype.getMilliseconds ( )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).If t is NaN, return NaN.Return msFromTime(LocalTime(t)).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.7">
	<buginformation>
		<summary>Date.prototype.getMinutes ( )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).If t is NaN, return NaN.Return MinFromTime(LocalTime(t)).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.8">
	<buginformation>
		<summary>Date.prototype.getMonth ( )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).If t is NaN, return NaN.Return MonthFromTime(LocalTime(t)).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.9">
	<buginformation>
		<summary>Date.prototype.getSeconds ( )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).If t is NaN, return NaN.Return SecFromTime(LocalTime(t)).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.10">
	<buginformation>
		<summary>Date.prototype.getTime ( )</summary>
		<description>The following steps are performed: Return ? thisTimeValue(this value).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.11">
	<buginformation>
		<summary>Date.prototype.getTimezoneOffset ( )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).If t is NaN, return NaN.Return (t - LocalTime(t)) / msPerMinute.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.12">
	<buginformation>
		<summary>Date.prototype.getUTCDate ( )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).If t is NaN, return NaN.Return DateFromTime(t).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.13">
	<buginformation>
		<summary>Date.prototype.getUTCDay ( )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).If t is NaN, return NaN.Return WeekDay(t).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.14">
	<buginformation>
		<summary>Date.prototype.getUTCFullYear ( )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).If t is NaN, return NaN.Return YearFromTime(t).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.15">
	<buginformation>
		<summary>Date.prototype.getUTCHours ( )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).If t is NaN, return NaN.Return HourFromTime(t).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.16">
	<buginformation>
		<summary>Date.prototype.getUTCMilliseconds ( )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).If t is NaN, return NaN.Return msFromTime(t).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.17">
	<buginformation>
		<summary>Date.prototype.getUTCMinutes ( )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).If t is NaN, return NaN.Return MinFromTime(t).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.18">
	<buginformation>
		<summary>Date.prototype.getUTCMonth ( )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).If t is NaN, return NaN.Return MonthFromTime(t).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.19">
	<buginformation>
		<summary>Date.prototype.getUTCSeconds ( )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).If t is NaN, return NaN.Return SecFromTime(t).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.20">
	<buginformation>
		<summary>Date.prototype.setDate ( date )</summary>
		<description>The following steps are performed: Let t be LocalTime(? thisTimeValue(this value)).Let dt be ? ToNumber(date).Let newDate be MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t)).Let u be TimeClip(UTC(newDate)).Set the [[DateValue]] internal slot of this Date object to u.Return u.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.21">
	<buginformation>
		<summary>Date.prototype.setFullYear ( year [ , month [ , date ] ] )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).If t is NaN, let t be +0; otherwise, let t be LocalTime(t).Let y be ? ToNumber(year).If month is not specified, let m be MonthFromTime(t); otherwise, let m be ? ToNumber(month).If date is not specified, let dt be DateFromTime(t); otherwise, let dt be ? ToNumber(date).Let newDate be MakeDate(MakeDay(y, m, dt), TimeWithinDay(t)).Let u be TimeClip(UTC(newDate)).Set the [[DateValue]] internal slot of this Date object to u.Return u.          The length property of the setFullYear method is 3. Note If month is not specified, this method behaves as if month were specified with the value getMonth(). If date is not specified, it behaves as if date were specified with the value getDate().</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.22">
	<buginformation>
		<summary>Date.prototype.setHours ( hour [ , min [ , sec [ , ms ] ] ] )</summary>
		<description>The following steps are performed: Let t be LocalTime(? thisTimeValue(this value)).Let h be ? ToNumber(hour).If min is not specified, let m be MinFromTime(t); otherwise, let m be ? ToNumber(min).If sec is not specified, let s be SecFromTime(t); otherwise, let s be ? ToNumber(sec).If ms is not specified, let milli be msFromTime(t); otherwise, let milli be ? ToNumber(ms).Let date be MakeDate(Day(t), MakeTime(h, m, s, milli)).Let u be TimeClip(UTC(date)).Set the [[DateValue]] internal slot of this Date object to u.Return u.          The length property of the setHours method is 4. Note If min is not specified, this method behaves as if min were specified with the value getMinutes(). If sec is not specified, it behaves as if sec were specified with the value getSeconds(). If ms is not specified, it behaves as if ms were specified with the value getMilliseconds().</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.23">
	<buginformation>
		<summary>Date.prototype.setMilliseconds ( ms )</summary>
		<description>The following steps are performed: Let t be LocalTime(? thisTimeValue(this value)).Let ms be ? ToNumber(ms).Let time be MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), ms).Let u be TimeClip(UTC(MakeDate(Day(t), time))).Set the [[DateValue]] internal slot of this Date object to u.Return u.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.24">
	<buginformation>
		<summary>Date.prototype.setMinutes ( min [ , sec [ , ms ] ] )</summary>
		<description>The following steps are performed: Let t be LocalTime(? thisTimeValue(this value)).Let m be ? ToNumber(min).If sec is not specified, let s be SecFromTime(t); otherwise, let s be ? ToNumber(sec).If ms is not specified, let milli be msFromTime(t); otherwise, let milli be ? ToNumber(ms).Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli)).Let u be TimeClip(UTC(date)).Set the [[DateValue]] internal slot of this Date object to u.Return u.          The length property of the setMinutes method is 3. Note If sec is not specified, this method behaves as if sec were specified with the value getSeconds(). If ms is not specified, this behaves as if ms were specified with the value getMilliseconds().</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.25">
	<buginformation>
		<summary>Date.prototype.setMonth ( month [ , date ] )</summary>
		<description>The following steps are performed: Let t be LocalTime(? thisTimeValue(this value)).Let m be ? ToNumber(month).If date is not specified, let dt be DateFromTime(t); otherwise, let dt be ? ToNumber(date).Let newDate be MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t)).Let u be TimeClip(UTC(newDate)).Set the [[DateValue]] internal slot of this Date object to u.Return u.          The length property of the setMonth method is 2. Note If date is not specified, this method behaves as if date were specified with the value getDate().</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.26">
	<buginformation>
		<summary>Date.prototype.setSeconds ( sec [ , ms ] )</summary>
		<description>The following steps are performed: Let t be LocalTime(? thisTimeValue(this value)).Let s be ? ToNumber(sec).If ms is not specified, let milli be msFromTime(t); otherwise, let milli be ? ToNumber(ms).Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli)).Let u be TimeClip(UTC(date)).Set the [[DateValue]] internal slot of this Date object to u.Return u.          The length property of the setSeconds method is 2. Note If ms is not specified, this method behaves as if ms were specified with the value getMilliseconds().</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.27">
	<buginformation>
		<summary>Date.prototype.setTime ( time )</summary>
		<description>The following steps are performed: Perform ? thisTimeValue(this value).Let t be ? ToNumber(time).Let v be TimeClip(t).Set the [[DateValue]] internal slot of this Date object to v.Return v.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.28">
	<buginformation>
		<summary>Date.prototype.setUTCDate ( date )</summary>
		<description>Let t be ? thisTimeValue(this value).Let dt be ? ToNumber(date).Let newDate be MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t)).Let v be TimeClip(newDate).Set the [[DateValue]] internal slot of this Date object to v.Return v.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.29">
	<buginformation>
		<summary>Date.prototype.setUTCFullYear ( year [ , month [ , date ] ] )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).If t is NaN, let t be +0.Let y be ? ToNumber(year).If month is not specified, let m be MonthFromTime(t); otherwise, let m be ? ToNumber(month).If date is not specified, let dt be DateFromTime(t); otherwise, let dt be ? ToNumber(date).Let newDate be MakeDate(MakeDay(y, m, dt), TimeWithinDay(t)).Let v be TimeClip(newDate).Set the [[DateValue]] internal slot of this Date object to v.Return v.          The length property of the setUTCFullYear method is 3. Note If month is not specified, this method behaves as if month were specified with the value getUTCMonth(). If date is not specified, it behaves as if date were specified with the value getUTCDate().</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.30">
	<buginformation>
		<summary>Date.prototype.setUTCHours ( hour [ , min [ , sec [ , ms ] ] ] )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).Let h be ? ToNumber(hour).If min is not specified, let m be MinFromTime(t); otherwise, let m be ? ToNumber(min).If sec is not specified, let s be SecFromTime(t); otherwise, let s be ? ToNumber(sec).If ms is not specified, let milli be msFromTime(t); otherwise, let milli be ? ToNumber(ms).Let newDate be MakeDate(Day(t), MakeTime(h, m, s, milli)).Let v be TimeClip(newDate).Set the [[DateValue]] internal slot of this Date object to v.Return v.          The length property of the setUTCHours method is 4. Note If min is not specified, this method behaves as if min were specified with the value getUTCMinutes(). If sec is not specified, it behaves as if sec were specified with the value getUTCSeconds(). If ms is not specified, it behaves as if ms were specified with the value getUTCMilliseconds().</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.31">
	<buginformation>
		<summary>Date.prototype.setUTCMilliseconds ( ms )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).Let milli be ? ToNumber(ms).Let time be MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), milli).Let v be TimeClip(MakeDate(Day(t), time)).Set the [[DateValue]] internal slot of this Date object to v.Return v.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.32">
	<buginformation>
		<summary>Date.prototype.setUTCMinutes ( min [ , sec [ , ms ] ] )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).Let m be ? ToNumber(min).If sec is not specified, let s be SecFromTime(t).Else,Let s be ? ToNumber(sec).If ms is not specified, let milli be msFromTime(t).Else,Let milli be ? ToNumber(ms).Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli)).Let v be TimeClip(date).Set the [[DateValue]] internal slot of this Date object to v.Return v.          The length property of the setUTCMinutes method is 3. Note If sec is not specified, this method behaves as if sec were specified with the value getUTCSeconds(). If ms is not specified, it function behaves as if ms were specified with the value return by getUTCMilliseconds().</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.33">
	<buginformation>
		<summary>Date.prototype.setUTCMonth ( month [ , date ] )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).Let m be ? ToNumber(month).If date is not specified, let dt be DateFromTime(t).Else,Let dt be ? ToNumber(date).Let newDate be MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t)).Let v be TimeClip(newDate).Set the [[DateValue]] internal slot of this Date object to v.Return v.          The length property of the setUTCMonth method is 2. Note If date is not specified, this method behaves as if date were specified with the value getUTCDate().</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.34">
	<buginformation>
		<summary>Date.prototype.setUTCSeconds ( sec [ , ms ] )</summary>
		<description>The following steps are performed: Let t be ? thisTimeValue(this value).Let s be ? ToNumber(sec).If ms is not specified, let milli be msFromTime(t).Else,Let milli be ? ToNumber(ms).Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli)).Let v be TimeClip(date).Set the [[DateValue]] internal slot of this Date object to v.Return v.          The length property of the setUTCSeconds method is 2. Note If ms is not specified, this method behaves as if ms were specified with the value getUTCMilliseconds().</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.35">
	<buginformation>
		<summary>Date.prototype.toDateString ( )</summary>
		<description>This function returns a String value. The contents of the  String are implementation-dependent, but are intended to represent the  “date” portion of the Date in the current time zone in a convenient,  human-readable form.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.36">
	<buginformation>
		<summary>Date.prototype.toISOString ( )</summary>
		<description>This function returns a String value representing the instance in time corresponding to this time value. The format of the String is the Date Time string format defined in  20.3.1.16. All fields are present in the String. The time zone is always UTC, denoted by the suffix Z. If this time value  is not a finite Number or if the year is not a value that can be  represented in that format (if necessary using extended year format), a RangeError exception is thrown.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.37">
	<buginformation>
		<summary>Date.prototype.toJSON ( key )</summary>
		<description>This function provides a String representation of a Date object for use by JSON.stringify (24.5.2). When the toJSON method is called with argument key, the following steps are taken: Let O be ? ToObject(this value).Let tv be ? ToPrimitive(O, hint Number).If Type(tv) is Number and tv is not finite, return null.Return ? Invoke(O, &amp;quot;toISOString&amp;quot;).          Note 1 The argument is ignored.  Note 2 The toJSON function is intentionally generic; it does not require that its this  value be a Date object. Therefore, it can be transferred to other kinds  of objects for use as a method. However, it does require that any such  object have a toISOString method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.38">
	<buginformation>
		<summary>Date.prototype.toLocaleDateString ( [ reserved1 [ , reserved2 ] ] )</summary>
		<description>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the Date.prototype.toLocaleDateString  method as specified in the ECMA-402 specification. If an ECMAScript  implementation does not include the ECMA-402 API the following  specification of the toLocaleDateString method is used. This function returns a String value. The contents of the  String are implementation-dependent, but are intended to represent the  “date” portion of the Date in the current time zone in a convenient,  human-readable form that corresponds to the conventions of the host  environment&apos;s current locale. The meaning of the optional parameters to this method are  defined in the ECMA-402 specification; implementations that do not  include ECMA-402 support must not use those parameter positions for  anything else.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.39">
	<buginformation>
		<summary>Date.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )</summary>
		<description>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the Date.prototype.toLocaleString  method as specified in the ECMA-402 specification. If an ECMAScript  implementation does not include the ECMA-402 API the following  specification of the toLocaleString method is used. This function returns a String value. The contents of the  String are implementation-dependent, but are intended to represent the  Date in the current time zone in a convenient, human-readable form that  corresponds to the conventions of the host environment&apos;s current locale. The meaning of the optional parameters to this method are  defined in the ECMA-402 specification; implementations that do not  include ECMA-402 support must not use those parameter positions for  anything else.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.40">
	<buginformation>
		<summary>Date.prototype.toLocaleTimeString ( [ reserved1 [ , reserved2 ] ] )</summary>
		<description>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the Date.prototype.toLocaleTimeString  method as specified in the ECMA-402 specification. If an ECMAScript  implementation does not include the ECMA-402 API the following  specification of the toLocaleTimeString method is used. This function returns a String value. The contents of the  String are implementation-dependent, but are intended to represent the  “time” portion of the Date in the current time zone in a convenient,  human-readable form that corresponds to the conventions of the host  environment&apos;s current locale. The meaning of the optional parameters to this method are  defined in the ECMA-402 specification; implementations that do not  include ECMA-402 support must not use those parameter positions for  anything else.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.41.1">
	<buginformation>
		<summary>Runtime Semantics: ToDateString( tv )</summary>
		<description>The following steps are performed: Assert: Type(tv) is Number.If tv is NaN, return &amp;quot;Invalid Date&amp;quot;.Return an implementation-dependent String value that represents tv as a date and time in the current time zone using a convenient, human-readable form.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.42">
	<buginformation>
		<summary>Date.prototype.toTimeString ( )</summary>
		<description>This function returns a String value. The contents of the  String are implementation-dependent, but are intended to represent the  “time” portion of the Date in the current time zone in a convenient,  human-readable form.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.43">
	<buginformation>
		<summary>Date.prototype.toUTCString ( )</summary>
		<description>This function returns a String value. The contents of the String are implementation-dependent, but are intended to represent this time value in a convenient, human-readable form in UTC. Note The intent is to produce a String representation of a date that is more readable than the format specified in  20.3.1.16.  It is not essential that the chosen format be unambiguous or easily  machine parsable. If an implementation does not have a preferred  human-readable format it is recommended to use the format defined in  20.3.1.16 but with a space rather than a &amp;quot;T&amp;quot; used to separate the date and time elements.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.44">
	<buginformation>
		<summary>Date.prototype.valueOf ( )</summary>
		<description>The following steps are performed: Return ? thisTimeValue(this value).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.4.45">
	<buginformation>
		<summary>Date.prototype [ @@toPrimitive ] ( hint )</summary>
		<description>This function is called by ECMAScript language operators to convert a Date object to a primitive value. The allowed values for hint are &amp;quot;default&amp;quot;, &amp;quot;number&amp;quot;, and &amp;quot;string&amp;quot;. Date objects, are unique among built-in ECMAScript object in that they treat &amp;quot;default&amp;quot; as being equivalent to &amp;quot;string&amp;quot;, All other built-in ECMAScript objects treat &amp;quot;default&amp;quot; as being equivalent to &amp;quot;number&amp;quot;. When the @@toPrimitive method is called with argument hint, the following steps are taken: Let O be the this value.If Type(O) is not Object, throw a TypeError exception.If hint is the String value &amp;quot;string&amp;quot; or the String value &amp;quot;default&amp;quot;, thenLet tryFirst be &amp;quot;string&amp;quot;.Else if hint is the String value &amp;quot;number&amp;quot;, thenLet tryFirst be &amp;quot;number&amp;quot;.Else, throw a TypeError exception.Return ? OrdinaryToPrimitive(O, tryFirst).          The value of the name property of this function is &amp;quot;[Symbol.toPrimitive]&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="20.3.5">
	<buginformation>
		<summary>Properties of Date Instances</summary>
		<description>Date instances are ordinary objects that inherit properties  from the Date prototype object. Date instances also have a [[DateValue]]  internal slot. The [[DateValue]] internal slot is the time value represented by this Date object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.1.1">
	<buginformation>
		<summary>String ( value )</summary>
		<description>When String is called with argument value, the following steps are taken: If no arguments were passed to this function invocation, let s be &amp;quot;&amp;quot;.Else,If NewTarget is undefined and Type(value) is Symbol, return SymbolDescriptiveString(value).Let s be ? ToString(value).If NewTarget is undefined, return s.Return ? StringCreate(s, ? GetPrototypeFromConstructor(NewTarget, &amp;quot;%StringPrototype%&amp;quot;)).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.2.1">
	<buginformation>
		<summary>String.fromCharCode ( ...codeUnits )</summary>
		<description>The String.fromCharCode function may be called with any number of arguments which form the rest parameter codeUnits. The following steps are taken: Let codeUnits be a List containing the arguments passed to this function.Let length be the number of elements in codeUnits.Let elements be a new empty List.Let nextIndex be 0.Repeat, while nextIndex &lt; lengthLet next be codeUnits[nextIndex].Let nextCU be ? ToUint16(next).Append nextCU to the end of elements.Let nextIndex be nextIndex + 1.Return the String value whose elements are, in order, the elements in the List elements. If length is 0, the empty string is returned.          The length property of the fromCharCode function is 1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.2.2">
	<buginformation>
		<summary>String.fromCodePoint ( ...codePoints )</summary>
		<description>The String.fromCodePoint function may be called with any number of arguments which form the rest parameter codePoints. The following steps are taken: Let codePoints be a List containing the arguments passed to this function.Let length be the number of elements in codePoints.Let elements be a new empty List.Let nextIndex be 0.Repeat, while nextIndex &lt; lengthLet next be codePoints[nextIndex].Let nextCP be ? ToNumber(next).If SameValue(nextCP, ToInteger(nextCP)) is false, throw a RangeError exception.If nextCP &lt; 0 or nextCP &gt; 0x10FFFF, throw a RangeError exception.Append the elements of the UTF16Encoding of nextCP to the end of elements.Let nextIndex be nextIndex + 1.Return the String value whose elements are, in order, the elements in the List elements. If length is 0, the empty string is returned.          The length property of the fromCodePoint function is 1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.2.3">
	<buginformation>
		<summary>String.prototype</summary>
		<description>The initial value of String.prototype is the intrinsic object %StringPrototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.2.4">
	<buginformation>
		<summary>String.raw ( template, ...substitutions )</summary>
		<description>The String.raw function may be called with a variable number of arguments. The first argument is template and the remainder of the arguments form the List substitutions. The following steps are taken: Let substitutions be a List  consisting of all of the arguments passed to this function, starting  with the second argument. If fewer than two arguments were passed, the List is empty.Let numberOfSubstitutions be the number of elements in substitutions.Let cooked be ? ToObject(template).Let raw be ? ToObject(? Get(cooked, &amp;quot;raw&amp;quot;)).Let literalSegments be ? ToLength(? Get(raw, &amp;quot;length&amp;quot;)).If literalSegments ≤ 0, return the empty string.Let stringElements be a new empty List.Let nextIndex be 0.Repeat,Let nextKey be ! ToString(nextIndex).Let nextSeg be ? ToString(? Get(raw, nextKey)).Append in order the code unit elements of nextSeg to the end of stringElements.If nextIndex + 1</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.1">
	<buginformation>
		<summary>String.prototype.charAt ( pos )</summary>
		<description>Note 1 Returns a single element String containing the code unit at index pos  in the String value resulting from converting this object to a String.  If there is no element at that index, the result is the empty String.  The result is a String value, not a String object. If pos is a value of Number type that is an integer, then the result of x.charAt(pos) is equal to the result of x.substring(pos, pos+1).  When the charAt method is called with one argument pos, the following steps are taken: Let O be ? RequireObjectCoercible(this value).Let S be ? ToString(O).Let position be ? ToInteger(pos).Let size be the number of elements in S.If position &lt; 0 or position ≥ size, return the empty String.Return a String of length 1, containing one code unit from S, namely the code unit at index position.          Note 2 The charAt function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.2">
	<buginformation>
		<summary>String.prototype.charCodeAt ( pos )</summary>
		<description>Note 1 Returns a Number (a nonnegative integer less than 216) that is the code unit value of the string element at index pos in the String resulting from converting this object to a String. If there is no element at that index, the result is NaN.  When the charCodeAt method is called with one argument pos, the following steps are taken: Let O be ? RequireObjectCoercible(this value).Let S be ? ToString(O).Let position be ? ToInteger(pos).Let size be the number of elements in S.If position &lt; 0 or position ≥ size, return NaN.Return a value of Number type, whose value is the code unit value of the element at index position in the String S.          Note 2 The charCodeAt function is intentionally generic; it does not require that its this value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.3">
	<buginformation>
		<summary>String.prototype.codePointAt ( pos )</summary>
		<description>Note 1 Returns a nonnegative integer Number less than 0x110000 that is the code point value of the UTF-16 encoded code point (6.1.4) starting at the string element at index pos in the String resulting from converting this object to a String. If there is no element at that index, the result is undefined. If a valid UTF-16 surrogate pair does not begin at pos, the result is the code unit at pos.  When the codePointAt method is called with one argument pos, the following steps are taken: Let O be ? RequireObjectCoercible(this value).Let S be ? ToString(O).Let position be ? ToInteger(pos).Let size be the number of elements in S.If position &lt; 0 or position ≥ size, return undefined.Let first be the code unit value of the element at index position in the String S.If first &lt; 0xD800 or first &gt; 0xDBFF or position+1</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.4">
	<buginformation>
		<summary>String.prototype.concat ( ...args )</summary>
		<description>Note 1 When the concat method is called it returns a String consisting of the code units of the this  object (converted to a String) followed by the code units of each of  the arguments converted to a String. The result is a String value, not a  String object.  When the concat method is called with zero or more arguments, the following steps are taken: Let O be ? RequireObjectCoercible(this value).Let S be ? ToString(O).Let args be a List whose elements are the arguments passed to this function.Let R be S.Repeat, while args is not emptyRemove the first element from args and let next be the value of that element.Let nextString be ? ToString(next).Set R to the String value consisting of the code units of the previous value of R followed by the code units of nextString.Return R.          The length property of the concat method is 1. Note 2 The concat function is intentionally generic; it does not require that its this value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.5">
	<buginformation>
		<summary>String.prototype.constructor</summary>
		<description>The initial value of String.prototype.constructor is the intrinsic object %String%.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.6">
	<buginformation>
		<summary>String.prototype.endsWith ( searchString [ , endPosition ] )</summary>
		<description>The following steps are taken: Let O be ? RequireObjectCoercible(this value).Let S be ? ToString(O).Let isRegExp be ? IsRegExp(searchString).If isRegExp is true, throw a TypeError exception.Let searchStr be ? ToString(searchString).Let len be the number of elements in S.If endPosition is undefined, let pos be len, else let pos be ? ToInteger(endPosition).Let end be min(max(pos, 0), len).Let searchLength be the number of elements in searchStr.Let start be end - searchLength.If start is less than 0, return false.If the sequence of elements of S starting at start of length searchLength is the same as the full element sequence of searchStr, return true.Otherwise, return false.          Note 1 Returns true if the sequence of elements of searchString converted to a String is the same as the corresponding elements of this object (converted to a String) starting at endPosition - length(this). Otherwise returns false.  Note 2 Throwing an exception if the first argument is a RegExp is  specified in order to allow future editions to define extensions that  allow such argument values.  Note 3 The endsWith function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.7">
	<buginformation>
		<summary>String.prototype.includes ( searchString [ , position ] )</summary>
		<description>The includes method takes two arguments, searchString and position, and performs the following steps: Let O be ? RequireObjectCoercible(this value).Let S be ? ToString(O).Let isRegExp be ? IsRegExp(searchString).If isRegExp is true, throw a TypeError exception.Let searchStr be ? ToString(searchString).Let pos be ? ToInteger(position). (If position is undefined, this step produces the value 0.)Let len be the number of elements in S.Let start be min(max(pos, 0), len).Let searchLen be the number of elements in searchStr.If there exists any integer k not smaller than start such that k + searchLen is not greater than len, and for all nonnegative integers j less than searchLen, the code unit at index k+j of S is the same as the code unit at index j of searchStr, return true; but if there is no such integer k, return false.          Note 1 If searchString appears as a substring of the  result of converting this object to a String, at one or more indices  that are greater than or equal to position, return true; otherwise, returns false. If position is undefined, 0 is assumed, so as to search all of the String.  Note 2 Throwing an exception if the first argument is a RegExp is  specified in order to allow future editions to define extensions that  allow such argument values.  Note 3 The includes function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.8">
	<buginformation>
		<summary>String.prototype.indexOf ( searchString [ , position ] )</summary>
		<description>Note 1 If searchString appears as a substring of the  result of converting this object to a String, at one or more indices  that are greater than or equal to position, then the smallest such index is returned; otherwise, -1 is returned. If position is undefined, 0 is assumed, so as to search all of the String.  The indexOf method takes two arguments, searchString and position, and performs the following steps: Let O be ? RequireObjectCoercible(this value).Let S be ? ToString(O).Let searchStr be ? ToString(searchString).Let pos be ? ToInteger(position). (If position is undefined, this step produces the value 0.)Let len be the number of elements in S.Let start be min(max(pos, 0), len).Let searchLen be the number of elements in searchStr.Return the smallest possible integer k not smaller than start such that k+searchLen is not greater than len, and for all nonnegative integers j less than searchLen, the code unit at index k+j of S is the same as the code unit at index j of searchStr; but if there is no such integer k, return the value -1.          Note 2 The indexOf function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.9">
	<buginformation>
		<summary>String.prototype.lastIndexOf ( searchString [ , position ] )</summary>
		<description>Note 1 If searchString appears as a substring of the  result of converting this object to a String at one or more indices that  are smaller than or equal to position, then the greatest such index is returned; otherwise, -1 is returned. If position is undefined, the length of the String value is assumed, so as to search all of the String.  The lastIndexOf method takes two arguments, searchString and position, and performs the following steps: Let O be ? RequireObjectCoercible(this value).Let S be ? ToString(O).Let searchStr be ? ToString(searchString).Let numPos be ? ToNumber(position). (If position is undefined, this step produces the value NaN.)If numPos is NaN, let pos be +∞; otherwise, let pos be ToInteger(numPos).Let len be the number of elements in S.Let start be min(max(pos, 0), len).Let searchLen be the number of elements in searchStr.Return the largest possible nonnegative integer k not larger than start such that k+searchLen is not greater than len, and for all nonnegative integers j less than searchLen, the code unit at index k+j of S is the same as the code unit at index j of searchStr; but if there is no such integer k, return the value -1.          Note 2 The lastIndexOf function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.10">
	<buginformation>
		<summary>String.prototype.localeCompare ( that [ , reserved1 [ , reserved2 ] ] )</summary>
		<description>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the localeCompare  method as specified in the ECMA-402 specification. If an ECMAScript  implementation does not include the ECMA-402 API the following  specification of the localeCompare method is used. When the localeCompare method is called with argument that, it returns a Number other than NaN that represents the result of a locale-sensitive String comparison of the this value (converted to a String) with that (converted to a String). The two Strings are S and That.  The two Strings are compared in an implementation-defined fashion. The  result is intended to order String values in the sort order specified by  a host default locale, and will be negative, zero, or positive,  depending on whether S comes before That in the sort order, the Strings are equal, or S comes after That in the sort order, respectively. Before performing the comparisons, the following steps are performed to prepare the Strings: Let O be ? RequireObjectCoercible(this value).Let S be ? ToString(O).Let That be ? ToString(that).          The meaning of the optional second and third parameters to  this method are defined in the ECMA-402 specification; implementations  that do not include ECMA-402 support must not assign any other  interpretation to those parameter positions. The localeCompare method, if considered as a function of two arguments this and that, is a consistent comparison function (as defined in  22.1.3.25) on the set of all Strings. The actual return values are implementation-defined to permit  implementers to encode additional information in the value, but the  function is required to define a total ordering on all Strings. This  function must treat Strings that are canonically equivalent according to  the Unicode standard as identical and must return 0 when comparing Strings that are considered canonically equivalent. Note 1 The localeCompare method itself is not directly suitable as an argument to Array.prototype.sort because the latter requires a function of two arguments.  Note 2 This function is intended to rely on whatever  language-sensitive comparison functionality is available to the  ECMAScript environment from the host environment, and to compare  according to the rules of the host environment&apos;s current locale.  However, regardless of the host provided comparison capabilities, this  function must treat Strings that are canonically equivalent according to  the Unicode standard as identical. It is recommended that this function  should not honour Unicode compatibility equivalences or decompositions.  For a definition and discussion of canonical equivalence see the  Unicode Standard, chapters 2 and 3, as well as Unicode Standard Annex  #15, Unicode Normalization Forms (http://www.unicode.org/reports/tr15/) and Unicode Technical Note #5, Canonical Equivalence in Applications (http://www.unicode.org/notes/tn5/). Also see Unicode Technical Standard #10, Unicode Collation Algorithm (http://www.unicode.org/reports/tr10/).  Note 3 The localeCompare function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.11">
	<buginformation>
		<summary>String.prototype.match ( regexp )</summary>
		<description>When the match method is called with argument regexp, the following steps are taken: Let O be ? RequireObjectCoercible(this value).If regexp is neither undefined nor null, thenLet matcher be ? GetMethod(regexp, @@match).If matcher is not undefined, thenReturn ? Call(matcher, regexp, « O »).Let S be ? ToString(O).Let rx be ? RegExpCreate(regexp, undefined).Return ? Invoke(rx, @@match, « S »).          Note The match function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.12">
	<buginformation>
		<summary>String.prototype.normalize ( [ form ] )</summary>
		<description>When the normalize method is called with one argument form, the following steps are taken: Let O be ? RequireObjectCoercible(this value).Let S be ? ToString(O).If form is not provided or form is undefined, let form be &amp;quot;NFC&amp;quot;.Let f be ? ToString(form).If f is not one of &amp;quot;NFC&amp;quot;, &amp;quot;NFD&amp;quot;, &amp;quot;NFKC&amp;quot;, or &amp;quot;NFKD&amp;quot;, throw a RangeError exception.Let ns be the String value that is the result of normalizing S into the normalization form named by f as specified in http://www.unicode.org/reports/tr15/.Return ns.          Note The normalize function is intentionally generic; it does not require that its this value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.13">
	<buginformation>
		<summary>String.prototype.padEnd( maxLength [ , fillString ] )</summary>
		<description>When the padEnd method is called, the following steps are taken: Let O be ? RequireObjectCoercible(this value).Let S be ? ToString(O).Let intMaxLength be ? ToLength(maxLength).Let stringLength be the number of elements in S.If intMaxLength is not greater than stringLength, return S.If fillString is undefined, let filler be a String consisting solely of the code unit 0x0020 (SPACE).Else, let filler be ? ToString(fillString).If filler is the empty String, return S.Let fillLen be intMaxLength - stringLength.Let truncatedStringFiller be a new String value consisting of repeated concatenations of filler truncated to length fillLen.Return a new String value computed by the concatenation of S and truncatedStringFiller.          Note 1 The first argument maxLength will be clamped such that it can be no smaller than the length of the this value.  Note 2 The optional second argument fillString defaults to &amp;quot; &amp;quot; (a String consisting of 0x0020 SPACE).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.14">
	<buginformation>
		<summary>String.prototype.padStart( maxLength [ , fillString ] )</summary>
		<description>When the padStart method is called, the following steps are taken: Let O be ? RequireObjectCoercible(this value).Let S be ? ToString(O).Let intMaxLength be ? ToLength(maxLength).Let stringLength be the number of elements in S.If intMaxLength is not greater than stringLength, return S.If fillString is undefined, let filler be a String consisting solely of the code unit 0x0020 (SPACE).Else, let filler be ? ToString(fillString).If filler is the empty String, return S.Let fillLen be intMaxLength - stringLength.Let truncatedStringFiller be a new String value consisting of repeated concatenations of filler truncated to length fillLen.Return a new String value computed by the concatenation of truncatedStringFiller and S.          Note 1 The first argument maxLength will be clamped such that it can be no smaller than the length of the this value.  Note 2 The optional second argument fillString defaults to &amp;quot; &amp;quot; (a String consisting of 0x0020 SPACE).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.15">
	<buginformation>
		<summary>String.prototype.repeat ( count )</summary>
		<description>The following steps are taken: Let O be ? RequireObjectCoercible(this value).Let S be ? ToString(O).Let n be ? ToInteger(count).If n &lt; 0, throw a RangeError exception.If n is +∞, throw a RangeError exception.Let T be a String value that is made from n copies of S appended together. If n is 0, T is the empty String.Return T.          Note 1 This method creates a String consisting of the code units of the this object (converted to String) repeated count times.  Note 2 The repeat function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.16.1">
	<buginformation>
		<summary>Runtime Semantics: GetSubstitution( matched, str, position, captures, replacement )</summary>
		<description>The abstract operation GetSubstitution performs the following steps: Assert: Type(matched) is String.Let matchLength be the number of code units in matched.Assert: Type(str) is String.Let stringLength be the number of code units in str.Assert: position is a nonnegative integer.Assert: position ≤ stringLength.Assert: captures is a possibly empty List of Strings.Assert: Type(replacement) is String.Let tailPos be position + matchLength.Let m be the number of elements in captures.Let result be a String value derived from replacement by copying code unit elements from replacement to result while performing replacements as specified in Table 46. These $  replacements are done left-to-right, and, once such a replacement is  performed, the new replacement text is not subject to further  replacements.Return result.            Table 46: Replacement Text Symbol Substitutions                       Code units                                                      Unicode Characters                                                      Replacement text                                                        0x0024, 0x0024                                    $$   $                       0x0024, 0x0026                                    $&amp;   matched                       0x0024, 0x0060                                    $`                     If position is 0, the replacement is the empty String. Otherwise the replacement is the substring of str that starts at index 0 and whose last code unit is at index position - 1.                                                        0x0024, 0x0027                                    $&apos;                     If tailPos ≥ stringLength, the replacement is the empty String. Otherwise the replacement is the substring of str that starts at index tailPos and continues to the end of str.                                                        0x0024, N                                                         Where                                                         0x0031 ≤ N ≤ 0x0039                                    $n where                                       n is one of 1 2 3 4 5 6 7 8 9 and $n is not followed by a decimal digit                                                      The nth element of captures, where n is a single digit in the range 1 to 9. If n≤m and the nth element of captures is undefined, use the empty String instead. If n&gt;m, the result is implementation-defined.                                                        0x0024, N, N                                                         Where                                                         0x0030 ≤ N ≤ 0x0039                                    $nn where                                       n is one of 0 1 2 3 4 5 6 7 8 9                     The nnth element of captures, where nn is a two-digit decimal number in the range 01 to 99. If nn≤m and the nnth element of captures is undefined, use the empty String instead. If nn is 00 or nn&gt;m, the result is implementation-defined.                                                        0x0024                                    $ in any context that does not match any of the above.                                    $</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.17">
	<buginformation>
		<summary>String.prototype.search ( regexp )</summary>
		<description>When the search method is called with argument regexp, the following steps are taken: Let O be ? RequireObjectCoercible(this value).If regexp is neither undefined nor null, thenLet searcher be ? GetMethod(regexp, @@search).If searcher is not undefined, thenReturn ? Call(searcher, regexp, « O »).Let string be ? ToString(O).Let rx be ? RegExpCreate(regexp, undefined).Return ? Invoke(rx, @@search, « string »).          Note The search function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.18">
	<buginformation>
		<summary>String.prototype.slice ( start, end )</summary>
		<description>The slice method takes two arguments, start and end, and returns a substring of the result of converting this object to a String, starting from index start and running to, but not including, index end (or through the end of the String if end is undefined). If start is negative, it is treated as  sourceLength+start where sourceLength is the length of the String. If end is negative, it is treated as  sourceLength+end where sourceLength is the length of the String. The result is a String value, not a String object. The following steps are taken: Let O be ? RequireObjectCoercible(this value).Let S be ? ToString(O).Let len be the number of elements in S.Let intStart be ? ToInteger(start).If end is undefined, let intEnd be len; else let intEnd be ? ToInteger(end).If intStart &lt; 0, let from be max(len + intStart, 0); otherwise let from be min(intStart, len).If intEnd &lt; 0, let to be max(len + intEnd, 0); otherwise let to be min(intEnd, len).Let span be max(to - from, 0).Return a String value containing span consecutive elements from S beginning with the element at index from.          Note The slice function is intentionally generic; it does not require that its this value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.19.1">
	<buginformation>
		<summary>Runtime Semantics: SplitMatch ( S, q, R )</summary>
		<description>The abstract operation SplitMatch takes three parameters, a String S, an integer q, and a String R, and performs the following steps in order to return either false or the end index of a match: Assert: Type(R) is String.Let r be the number of code units in R.Let s be the number of code units in S.If q+r &gt; s, return false.If there exists an integer i between 0 (inclusive) and r (exclusive) such that the code unit at index q+i of S is different from the code unit at index i of R, return false.Return q+r.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.20">
	<buginformation>
		<summary>String.prototype.startsWith ( searchString [ , position ] )</summary>
		<description>The following steps are taken: Let O be ? RequireObjectCoercible(this value).Let S be ? ToString(O).Let isRegExp be ? IsRegExp(searchString).If isRegExp is true, throw a TypeError exception.Let searchStr be ? ToString(searchString).Let pos be ? ToInteger(position). (If position is undefined, this step produces the value 0.)Let len be the number of elements in S.Let start be min(max(pos, 0), len).Let searchLength be the number of elements in searchStr.If searchLength+start is greater than len, return false.If the sequence of elements of S starting at start of length searchLength is the same as the full element sequence of searchStr, return true.Otherwise, return false.          Note 1 This method returns true if the sequence of elements of searchString converted to a String is the same as the corresponding elements of this object (converted to a String) starting at index position. Otherwise returns false.  Note 2 Throwing an exception if the first argument is a RegExp is  specified in order to allow future editions to define extensions that  allow such argument values.  Note 3 The startsWith function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.21">
	<buginformation>
		<summary>String.prototype.substring ( start, end )</summary>
		<description>The substring method takes two arguments, start and end, and returns a substring of the result of converting this object to a String, starting from index start and running to, but not including, index end of the String (or through the end of the String if end is undefined). The result is a String value, not a String object. If either argument is NaN or negative, it  is replaced with zero; if either argument is larger than the length of  the String, it is replaced with the length of the String. If start is larger than end, they are swapped. The following steps are taken: Let O be ? RequireObjectCoercible(this value).Let S be ? ToString(O).Let len be the number of elements in S.Let intStart be ? ToInteger(start).If end is undefined, let intEnd be len; else let intEnd be ? ToInteger(end).Let finalStart be min(max(intStart, 0), len).Let finalEnd be min(max(intEnd, 0), len).Let from be min(finalStart, finalEnd).Let to be max(finalStart, finalEnd).Return a String whose length is to - from, containing code units from S, namely the code units with indices from through to - 1, in ascending order.          Note The substring function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.22">
	<buginformation>
		<summary>String.prototype.toLocaleLowerCase ( [ reserved1 [ , reserved2 ] ] )</summary>
		<description>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the toLocaleLowerCase  method as specified in the ECMA-402 specification. If an ECMAScript  implementation does not include the ECMA-402 API the following  specification of the toLocaleLowerCase method is used. This function interprets a String value as a sequence of UTF-16 encoded code points, as described in  6.1.4. This function works exactly the same as toLowerCase  except that its result is intended to yield the correct result for the  host environment&apos;s current locale, rather than a locale-independent  result. There will only be a difference in the few cases (such as  Turkish) where the rules for that language conflict with the regular  Unicode case mappings. The meaning of the optional parameters to this method are  defined in the ECMA-402 specification; implementations that do not  include ECMA-402 support must not use those parameter positions for  anything else. Note The toLocaleLowerCase function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.23">
	<buginformation>
		<summary>String.prototype.toLocaleUpperCase ( [ reserved1 [ , reserved2 ] ] )</summary>
		<description>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the toLocaleUpperCase  method as specified in the ECMA-402 specification. If an ECMAScript  implementation does not include the ECMA-402 API the following  specification of the toLocaleUpperCase method is used. This function interprets a String value as a sequence of UTF-16 encoded code points, as described in  6.1.4. This function works exactly the same as toUpperCase  except that its result is intended to yield the correct result for the  host environment&apos;s current locale, rather than a locale-independent  result. There will only be a difference in the few cases (such as  Turkish) where the rules for that language conflict with the regular  Unicode case mappings. The meaning of the optional parameters to this method are  defined in the ECMA-402 specification; implementations that do not  include ECMA-402 support must not use those parameter positions for  anything else. Note The toLocaleUpperCase function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.24">
	<buginformation>
		<summary>String.prototype.toLowerCase ( )</summary>
		<description>This function interprets a String value as a sequence of UTF-16 encoded code points, as described in  6.1.4. The following steps are taken: Let O be ? RequireObjectCoercible(this value).Let S be ? ToString(O).Let cpList be a List containing in order the code points as defined in 6.1.4 of S, starting at the first element of S.For each code point c in cpList, if the Unicode Character Database provides a language insensitive lower case equivalent of c, then replace c in cpList with that equivalent code point(s).Let cuList be a new empty List.For each code point c in cpList, in order, append to cuList the elements of the UTF16Encoding of c.Let L be a String whose elements are, in order, the elements of cuList.Return L.          The result must be derived according to the  locale-insensitive case mappings in the Unicode Character Database (this  explicitly includes not only the UnicodeData.txt file, but also all  locale-insensitive mappings in the SpecialCasings.txt file that  accompanies it). Note 1 The case mapping of some code points may produce multiple  code points. In this case the result String may not be the same length  as the source String. Because both toUpperCase and toLowerCase have context-sensitive behaviour, the functions are not symmetrical. In other words, s.toUpperCase().toLowerCase() is not necessarily equal to s.toLowerCase().  Note 2 The toLowerCase function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.25">
	<buginformation>
		<summary>String.prototype.toString ( )</summary>
		<description>When the toString method is called, the following steps are taken: Return ? thisStringValue(this value).          Note For a String object, the toString method happens to return the same thing as the valueOf method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.26">
	<buginformation>
		<summary>String.prototype.toUpperCase ( )</summary>
		<description>This function interprets a String value as a sequence of UTF-16 encoded code points, as described in  6.1.4. This function behaves in exactly the same way as String.prototype.toLowerCase, except that code points are mapped to their uppercase equivalents as specified in the Unicode Character Database. Note The toUpperCase function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.27">
	<buginformation>
		<summary>String.prototype.trim ( )</summary>
		<description>This function interprets a String value as a sequence of UTF-16 encoded code points, as described in  6.1.4. The following steps are taken: Let O be ? RequireObjectCoercible(this value).Let S be ? ToString(O).Let T be a String value that is a copy of S with both leading and trailing white space removed. The definition of white space is the union of WhiteSpace and LineTerminator.  When determining whether a Unicode code point is in Unicode general  category “Space_Separator” (“Zs”), code unit sequences are interpreted  as UTF-16 encoded code point sequences as specified in 6.1.4.Return T.          Note The trim function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.28">
	<buginformation>
		<summary>String.prototype.valueOf ( )</summary>
		<description>When the valueOf method is called, the following steps are taken: Return ? thisStringValue(this value).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.3.29">
	<buginformation>
		<summary>String.prototype [ @@iterator ] ( )</summary>
		<description>When the @@iterator method is called it returns an Iterator object (25.1.1.2)  that iterates over the code points of a String value, returning each  code point as a String value. The following steps are taken: Let O be ? RequireObjectCoercible(this value).Let S be ? ToString(O).Return CreateStringIterator(S).          The value of the name property of this function is &amp;quot;[Symbol.iterator]&amp;quot;.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.4.1">
	<buginformation>
		<summary>length</summary>
		<description>The number of elements in the String value represented by this String object. Once a String object is initialized, this property is unchanging. It has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.5.1">
	<buginformation>
		<summary>CreateStringIterator ( string )</summary>
		<description>Several methods of String objects return Iterator objects. The abstract operation CreateStringIterator with argument string is used to create such iterator objects. It performs the following steps: Assert: Type(string) is String.Let iterator be ObjectCreate(%StringIteratorPrototype%, « [[IteratedString]], [[StringIteratorNextIndex]] »).Set iterator.[[IteratedString]] to string.Set iterator.[[StringIteratorNextIndex]] to 0.Return iterator.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.5.2.1">
	<buginformation>
		<summary>%StringIteratorPrototype%.next ( )</summary>
		<description>Let O be the this value.If Type(O) is not Object, throw a TypeError exception.If O does not have all of the internal slots of a String Iterator Instance (21.1.5.3), throw a TypeError exception.Let s be O.[[IteratedString]].If s is undefined, return CreateIterResultObject(undefined, true).Let position be O.[[StringIteratorNextIndex]].Let len be the number of elements in s.If position ≥ len, thenSet O.[[IteratedString]] to undefined.Return CreateIterResultObject(undefined, true).Let first be the code unit value at index position in s.If first &lt; 0xD800 or first &gt; 0xDBFF or position+1</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.5.2.2">
	<buginformation>
		<summary>%StringIteratorPrototype% [ @@toStringTag ]</summary>
		<description>The initial value of the @@toStringTag property is the String value &amp;quot;String Iterator&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.1.5.3">
	<buginformation>
		<summary>Properties of String Iterator Instances</summary>
		<description>String Iterator instances are ordinary objects that inherit properties from the %StringIteratorPrototype% intrinsic object. String Iterator instances are initially created with the internal slots listed in  Table 47. Table 47: Internal Slots of String Iterator Instances                     Internal Slot                                                Description                                                  [[IteratedString]]                                                The String value whose elements are being iterated.                                                  [[StringIteratorNextIndex]]                                                The integer index of the next string index to be examined by this iteration.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.1.1">
	<buginformation>
		<summary>Static Semantics: Early Errors</summary>
		<description>RegExpUnicodeEscapeSequence::u{HexDigits}                It is a Syntax Error if the MV of HexDigits &gt; 0x10FFFF.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.1">
	<buginformation>
		<summary>Notation</summary>
		<description>The descriptions below use the following variables:   Input is a List  consisting of all of the characters, in order, of the String being  matched by the regular expression pattern. Each character is either a  code unit or a code point, depending upon the kind of pattern involved.  The notation Input[n] means the nth character of Input, where n can range between 0 (inclusive) and InputLength (exclusive).                        InputLength is the number of characters in Input.                        NcapturingParens is the total number of left-capturing parentheses (i.e. the total number of   Atom::(Disjunction)  Parse Nodes) in the pattern. A left-capturing parenthesis is any ( pattern character that is matched by the ( terminal of the   Atom::(Disjunction)  production.                        IgnoreCase is true if the RegExp object&apos;s [[OriginalFlags]] internal slot contains &amp;quot;i&amp;quot; and otherwise is false.                        Multiline is true if the RegExp object&apos;s [[OriginalFlags]] internal slot contains &amp;quot;m&amp;quot; and otherwise is false.                        Unicode is true if the RegExp object&apos;s [[OriginalFlags]] internal slot contains &amp;quot;u&amp;quot; and otherwise is false.                        Furthermore, the descriptions below use the following internal data structures:               A  CharSet is a mathematical set of characters, either code units or code points depending up the state of the Unicode flag. “All characters” means either all code unit values or all code point values also depending upon the state if Unicode.                                    A  State is an ordered pair (endIndex, captures) where endIndex is an integer and captures is a List of NcapturingParens values. States are used to represent partial match states in the regular expression matching algorithms. The endIndex is one plus the index of the last input character matched so far by the pattern, while captures holds the results of capturing parentheses. The nth element of captures is either a List that represents the value obtained by the nth set of capturing parentheses or undefined if the nth  set of capturing parentheses hasn&apos;t been reached yet. Due to  backtracking, many States may be in use at any time during the matching  process.                                    A  MatchResult is either a State or the special token failure that indicates that the match failed.                                    A  Continuation procedure is an internal closure  (i.e. an internal procedure with some arguments already bound to values)  that takes one State argument and returns a MatchResult result. If an  internal closure references variables which are bound in the function  that creates the closure, the closure uses the values that these  variables had at the time the closure was created. The Continuation  attempts to match the remaining portion (specified by the closure&apos;s  already-bound arguments) of the pattern against Input,  starting at the intermediate state given by its State argument. If the  match succeeds, the Continuation returns the final State that it  reached; if the match fails, the Continuation returns failure.                                    A  Matcher procedure is an internal closure that  takes two arguments — a State and a Continuation — and returns a  MatchResult result. A Matcher attempts to match a middle subpattern  (specified by the closure&apos;s already-bound arguments) of the pattern  against Input, starting at the intermediate state given by  its State argument. The Continuation argument should be a closure that  matches the rest of the pattern. After matching the subpattern of a  pattern to obtain a new State, the Matcher then calls Continuation on  that new State to test if the rest of the pattern can match as well. If  it can, the Matcher returns the State returned by Continuation; if not,  the Matcher may try different choices at its choice points, repeatedly  calling Continuation until it either succeeds or all possibilities have  been exhausted.                                    An  AssertionTester procedure is an internal  closure that takes a State argument and returns a Boolean result. The  assertion tester tests a specific condition (specified by the closure&apos;s  already-bound arguments) against the current place in Input and returns true if the condition matched or false if not.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.2">
	<buginformation>
		<summary>Pattern</summary>
		<description>The production   Pattern::Disjunction  evaluates as follows: Evaluate Disjunction to obtain a Matcher m.Return an internal closure that takes two arguments, a String str and an integer index, and performs the following steps:Assert: index ≤ the number of elements in str.If Unicode is true, let Input be a List consisting of the sequence of code points of str interpreted as a UTF-16 encoded (6.1.4) Unicode string. Otherwise, let Input be a List consisting of the sequence of code units that are the elements of str. Input will be used throughout the algorithms in 21.2.2. Each element of Input is considered to be a character.Let InputLength be the number of characters contained in Input. This variable will be used throughout the algorithms in 21.2.2.Let listIndex be the index into Input of the character that was obtained from element index of str.Let c be a Continuation that always returns its State argument as a successful MatchResult.Let cap be a List of NcapturingParens undefined values, indexed 1 through NcapturingParens.Let x be the State (listIndex, cap).Call m(x, c) and return its result.          Note A Pattern evaluates (“compiles”) to an internal procedure value. RegExpBuiltinExec  can then apply this procedure to a String and an offset within the  String to determine whether the pattern would match starting at exactly  that offset within the String, and, if it does match, what the values of  the capturing parentheses would be. The algorithms in  21.2.2 are designed so that compiling a pattern may throw a SyntaxError  exception; on the other hand, once the pattern is successfully  compiled, applying the resulting internal procedure to find a match in a  String cannot throw an exception (except for any host-defined  exceptions that can occur anywhere such as out-of-memory).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.3">
	<buginformation>
		<summary>Disjunction</summary>
		<description>The production   Disjunction::Alternative  evaluates as follows: Evaluate Alternative to obtain a Matcher m.Return m.          The production   Disjunction::Alternative|Disjunction  evaluates as follows: Evaluate Alternative to obtain a Matcher m1.Evaluate Disjunction to obtain a Matcher m2.Return an internal Matcher closure that takes two arguments, a State x and a Continuation c, and performs the following steps when evaluated:Call m1(x, c) and let r be its result.If r is not failure, return r.Call m2(x, c) and return its result.          Note The | regular expression operator separates two alternatives. The pattern first tries to match the left Alternative (followed by the sequel of the regular expression); if it fails, it tries to match the right Disjunction (followed by the sequel of the regular expression). If the left Alternative, the right Disjunction, and the sequel all have choice points, all choices in the sequel are tried before moving on to the next choice in the left Alternative. If choices in the left Alternative are exhausted, the right Disjunction is tried instead of the left Alternative. Any capturing parentheses inside a portion of the pattern skipped by | produce undefined values instead of Strings. Thus, for example, /a|ab/.exec(&amp;quot;abc&amp;quot;) returns the result &amp;quot;a&amp;quot; and not &amp;quot;ab&amp;quot;. Moreover, /((a)|(ab))((c)|(bc))/.exec(&amp;quot;abc&amp;quot;) returns the array [&amp;quot;abc&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, undefined, &amp;quot;bc&amp;quot;, undefined, &amp;quot;bc&amp;quot;] and not [&amp;quot;abc&amp;quot;, &amp;quot;ab&amp;quot;, undefined, &amp;quot;ab&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;c&amp;quot;, undefined]</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.4">
	<buginformation>
		<summary>Alternative</summary>
		<description>The production   Alternative::[empty]  evaluates as follows: Return a Matcher that takes two arguments, a State x and a Continuation c, and returns the result of calling c(x).          The production   Alternative::AlternativeTerm  evaluates as follows: Evaluate Alternative to obtain a Matcher m1.Evaluate Term to obtain a Matcher m2.Return an internal Matcher closure that takes two arguments, a State x and a Continuation c, and performs the following steps when evaluated:Let d be a Continuation that takes a State argument y and returns the result of calling m2(y, c).Call m1(x, d) and return its result.          Note Consecutive Terms try to simultaneously match consecutive portions of Input. If the left Alternative, the right Term,  and the sequel of the regular expression all have choice points, all  choices in the sequel are tried before moving on to the next choice in  the right Term, and all choices in the right Term are tried before moving on to the next choice in the left Alternative.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.5.1">
	<buginformation>
		<summary>Runtime Semantics: RepeatMatcher ( m, min, max, greedy, x, c, parenIndex, parenCount )</summary>
		<description>The abstract operation RepeatMatcher takes eight parameters, a Matcher m, an integer min, an integer (or ∞) max, a Boolean greedy, a State x, a Continuation c, an integer parenIndex, and an integer parenCount, and performs the following steps: If max is zero, return c(x).Let d be an internal Continuation closure that takes one State argument y and performs the following steps when evaluated:If min is zero and y&apos;s endIndex is equal to x&apos;s endIndex, return failure.If min is zero, let min2 be zero; otherwise let min2 be min-1.If max is ∞, let max2 be ∞; otherwise let max2 be max-1.Call RepeatMatcher(m, min2, max2, greedy, y, c, parenIndex, parenCount) and return its result.Let cap be a fresh copy of x&apos;s captures List.For each integer k that satisfies parenIndex &lt; k and k ≤ parenIndex+parenCount, set cap[k] to undefined.Let e be x&apos;s endIndex.Let xr be the State (e, cap).If min is not zero, return m(xr, d).If greedy is false, thenCall c(x) and let z be its result.If z is not failure, return z.Call m(xr, d) and return its result.Call m(xr, d) and let z be its result.If z is not failure, return z.Call c(x) and return its result.            Note 1 An Atom followed by a Quantifier is repeated the number of times specified by the Quantifier. A Quantifier can be non-greedy, in which case the Atom pattern is repeated as few times as possible while still matching the sequel, or it can be greedy, in which case the Atom pattern is repeated as many times as possible while still matching the sequel. The Atom pattern is repeated rather than the input character sequence that it matches, so different repetitions of the Atom can match different input substrings.  Note 2 If the Atom and the sequel of the regular expression all have choice points, the Atom  is first matched as many (or as few, if non-greedy) times as possible.  All choices in the sequel are tried before moving on to the next choice  in the last repetition of Atom. All choices in the last (nth) repetition of Atom are tried before moving on to the next choice in the next-to-last (n-1)st repetition of Atom; at which point it may turn out that more or fewer repetitions of Atom  are now possible; these are exhausted (again, starting with either as  few or as many as possible) before moving on to the next choice in the  (n-1)st repetition of Atom and so on. Compare /a[a-z]{2,4}/.exec(&amp;quot;abcdefghi&amp;quot;) which returns &amp;quot;abcde&amp;quot; with /a[a-z]{2,4}?/.exec(&amp;quot;abcdefghi&amp;quot;) which returns &amp;quot;abc&amp;quot;. Consider also /(aa|aabaac|ba|b|c)*/.exec(&amp;quot;aabaac&amp;quot;) which, by the choice point ordering above, returns the array [&amp;quot;aaba&amp;quot;, &amp;quot;ba&amp;quot;] and not any of: [&amp;quot;aabaac&amp;quot;, &amp;quot;aabaac&amp;quot;] [&amp;quot;aabaac&amp;quot;, &amp;quot;c&amp;quot;] The above ordering of choice points can be used to write a  regular expression that calculates the greatest common divisor of two  numbers (represented in unary notation). The following example  calculates the gcd of 10 and 15: &amp;quot;aaaaaaaaaa,aaaaaaaaaaaaaaa&amp;quot;.replace(/^(a+)\1*,\1+$/,&amp;quot;$1&amp;quot;) which returns the gcd in unary notation &amp;quot;aaaaa&amp;quot;.  Note 3 Step 4 of the RepeatMatcher clears Atom&apos;s captures each time Atom is repeated. We can see its behaviour in the regular expression /(z)((a+)?(b+)?(c))*/.exec(&amp;quot;zaacbbbcac&amp;quot;) which returns the array [&amp;quot;zaacbbbcac&amp;quot;, &amp;quot;z&amp;quot;, &amp;quot;ac&amp;quot;, &amp;quot;a&amp;quot;, undefined, &amp;quot;c&amp;quot;] and not [&amp;quot;zaacbbbcac&amp;quot;, &amp;quot;z&amp;quot;, &amp;quot;ac&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;bbb&amp;quot;, &amp;quot;c&amp;quot;] because each iteration of the outermost * clears all captured Strings contained in the quantified Atom, which in this case includes capture Strings numbered 2, 3, 4, and 5.  Note 4 Step 1 of the RepeatMatcher&apos;s d closure states that, once the minimum number of repetitions has been satisfied, any more expansions of Atom  that match the empty character sequence are not considered for further  repetitions. This prevents the regular expression engine from falling  into an infinite loop on patterns such as: /(a*)*/.exec(&amp;quot;b&amp;quot;) or the slightly more complicated: /(a*)b\1+/.exec(&amp;quot;baaaac&amp;quot;) which returns the array [&amp;quot;b&amp;quot;, &amp;quot;&amp;quot;]</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.6.1">
	<buginformation>
		<summary>Runtime Semantics: WordCharacters ( )</summary>
		<description>The abstract operation WordCharacters performs the following steps: Let A be a set of characters containing the sixty-three characters:                  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z     A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z     0   1   2   3   4   5   6   7   8   9   _                                   Let U be an empty set.For each character c not in set A where Canonicalize(c) is in A, add c to U.Assert: Unless Unicode and IgnoreCase are both true, U is empty.Add the characters in set U to set A.Return A.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.6.2">
	<buginformation>
		<summary>Runtime Semantics: IsWordChar ( e )</summary>
		<description>The abstract operation IsWordChar takes an integer parameter e and performs the following steps: If e is -1 or e is InputLength, return false.Let c be the character Input[e].Let wordChars be the result of ! WordCharacters().If c is in wordChars, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.7">
	<buginformation>
		<summary>Quantifier</summary>
		<description>The production   Quantifier::QuantifierPrefix  evaluates as follows: Evaluate QuantifierPrefix to obtain the two results: an integer min and an integer (or ∞) max.Return the three results min, max, and true.          The production   Quantifier::QuantifierPrefix?  evaluates as follows: Evaluate QuantifierPrefix to obtain the two results: an integer min and an integer (or ∞) max.Return the three results min, max, and false.          The production   QuantifierPrefix::*  evaluates as follows: Return the two results 0 and ∞.          The production   QuantifierPrefix::+  evaluates as follows: Return the two results 1 and ∞.          The production   QuantifierPrefix::?  evaluates as follows: Return the two results 0 and 1.          The production   QuantifierPrefix::{DecimalDigits}  evaluates as follows: Let i be the MV of DecimalDigits (see 11.8.3).Return the two results i and i.          The production   QuantifierPrefix::{DecimalDigits,}  evaluates as follows: Let i be the MV of DecimalDigits.Return the two results i and ∞.          The production   QuantifierPrefix::{DecimalDigits,DecimalDigits}  evaluates as follows: Let i be the MV of the first DecimalDigits.Let j be the MV of the second DecimalDigits.Return the two results i and j.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.8.1">
	<buginformation>
		<summary>Runtime Semantics: CharacterSetMatcher ( A, invert )</summary>
		<description>The abstract operation CharacterSetMatcher takes two arguments, a CharSet A and a Boolean flag invert, and performs the following steps: Return an internal Matcher closure that takes two arguments, a State x and a Continuation c, and performs the following steps when evaluated:Let e be x&apos;s endIndex.If e is InputLength, return failure.Let ch be the character Input[e].Let cc be Canonicalize(ch).If invert is false, thenIf there does not exist a member a of set A such that Canonicalize(a) is cc, return failure.Else invert is true,If there exists a member a of set A such that Canonicalize(a) is cc, return failure.Let cap be x&apos;s captures List.Let y be the State (e+1, cap).Call c(y) and return its result.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.8.2">
	<buginformation>
		<summary>Runtime Semantics: Canonicalize ( ch )</summary>
		<description>The abstract operation Canonicalize takes a character parameter ch and performs the following steps: If IgnoreCase is false, return ch.If Unicode is true, thenIf the file CaseFolding.txt of the Unicode Character Database provides a simple or common case folding mapping for ch, return the result of applying that mapping to ch.Return ch.Else,Assert: ch is a UTF-16 code unit.Let s be the ECMAScript String value consisting of the single code unit ch.Let u be the same result produced as if by performing the algorithm for String.prototype.toUpperCase using s as the this value.Assert: u is a String value.If u does not consist of a single code unit, return ch.Let cu be u&apos;s single code unit element.If ch&apos;s code unit value ≥ 128 and cu&apos;s code unit value &lt; 128, return ch.Return cu.            Note 1 Parentheses of the form ( Disjunction ) serve both to group the components of the Disjunction pattern together and to save the result of the match. The result can be used either in a backreference (\  followed by a nonzero decimal number), referenced in a replace String,  or returned as part of an array from the regular expression matching  internal procedure. To inhibit the capturing behaviour of parentheses,  use the form (?: Disjunction ) instead.  Note 2 The form (?</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.9">
	<buginformation>
		<summary>AtomEscape</summary>
		<description>The production   AtomEscape::DecimalEscape  evaluates as follows: Evaluate DecimalEscape to obtain an integer n.If n&gt;NcapturingParens, throw a SyntaxError exception.Return an internal Matcher closure that takes two arguments, a State x and a Continuation c, and performs the following steps:Let cap be x&apos;s captures List.Let s be cap[n].If s is undefined, return c(x).Let e be x&apos;s endIndex.Let len be s&apos;s length.Let f be e+len.If f&gt;InputLength, return failure.If there exists an integer i between 0 (inclusive) and len (exclusive) such that Canonicalize(s[i]) is not the same character value as Canonicalize(Input[e+i]), return failure.Let y be the State (f, cap).Call c(y) and return its result.          The production   AtomEscape::CharacterEscape  evaluates as follows: Evaluate CharacterEscape to obtain a character ch.Let A be a one-element CharSet containing the character ch.Call CharacterSetMatcher(A, false) and return its Matcher result.          The production   AtomEscape::CharacterClassEscape  evaluates as follows: Evaluate CharacterClassEscape to obtain a CharSet A.Call CharacterSetMatcher(A, false) and return its Matcher result.          Note An escape sequence of the form \ followed by a nonzero decimal number n matches the result of the nth set of capturing parentheses (21.2.2.1). It is an error if the regular expression has fewer than n capturing parentheses. If the regular expression has n or more capturing parentheses but the nth one is undefined because it has not captured anything, then the backreference always succeeds.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.10">
	<buginformation>
		<summary>CharacterEscape</summary>
		<description>The production   CharacterEscape::0  evaluates as follows: Return the character U+0000 (NULL).          Note \0 represents the &lt;NUL&gt; character and cannot be followed by a decimal digit.  The production   CharacterEscape::ControlEscape  evaluates as follows: Return the character according to Table 48.          Table 48: ControlEscape Character Values                     ControlEscape                                                Character Value                                                Code Point                                                Unicode Name                                                Symbol                                  t                   9                                U+0009                   CHARACTER TABULATION                                                &lt;HT&gt;                                  n                   10                                U+000A                   LINE FEED (LF)                                                &lt;LF&gt;                                  v                   11                                U+000B                   LINE TABULATION                                                &lt;VT&gt;                                  f                   12                                U+000C                   FORM FEED (FF)                                                &lt;FF&gt;                                  r                   13                                U+000D                   CARRIAGE RETURN (CR)                                                &lt;CR&gt;                                   The production   CharacterEscape::cControlLetter  evaluates as follows: Let ch be the character matched by ControlLetter.Let i be ch&apos;s character value.Let j be the remainder of dividing i by 32.Return the character whose character value is j.          The production   CharacterEscape::HexEscapeSequence  evaluates as follows: Return the character whose code is the SV of HexEscapeSequence.          The production   CharacterEscape::RegExpUnicodeEscapeSequence  evaluates as follows: Return the result of evaluating RegExpUnicodeEscapeSequence.          The production   CharacterEscape::IdentityEscape  evaluates as follows: Return the character matched by IdentityEscape.          The production   RegExpUnicodeEscapeSequence::uLeadSurrogate\uTrailSurrogate  evaluates as follows: Let lead be the result of evaluating LeadSurrogate.Let trail be the result of evaluating TrailSurrogate.Let cp be UTF16Decode(lead, trail).Return the character whose character value is cp.          The production   RegExpUnicodeEscapeSequence::uLeadSurrogate  evaluates as follows: Return the character whose code is the result of evaluating LeadSurrogate.          The production   RegExpUnicodeEscapeSequence::uTrailSurrogate  evaluates as follows: Return the character whose code is the result of evaluating TrailSurrogate.          The production   RegExpUnicodeEscapeSequence::uNonSurrogate  evaluates as follows: Return the character whose code is the result of evaluating NonSurrogate.          The production   RegExpUnicodeEscapeSequence::uHex4Digits  evaluates as follows: Return the character whose code is the SV of Hex4Digits.          The production   RegExpUnicodeEscapeSequence::u{HexDigits}  evaluates as follows: Return the character whose code is the MV of HexDigits.          The production   LeadSurrogate::Hex4Digits  evaluates as follows: Return the character whose code is the SV of Hex4Digits.          The production   TrailSurrogate::Hex4Digits  evaluates as follows: Return the character whose code is the SV of Hex4Digits.          The production   NonSurrogate::Hex4Digits  evaluates as follows: Return the character whose code is the SV of Hex4Digits.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.11">
	<buginformation>
		<summary>DecimalEscape</summary>
		<description>The production   DecimalEscape::NonZeroDigit  evaluates as follows: Return the MV of NonZeroDigit.          The production   DecimalEscape::NonZeroDigitDecimalDigits  evaluates as follows: Let n be the number of code points in DecimalDigits.Return (the MV of NonZeroDigit × 10n) plus the MV of DecimalDigits.          The definitions of “the MV of NonZeroDigit” and “the MV of DecimalDigits” are in  11.8.3. Note If \ is followed by a decimal number n whose first digit is not 0, then the escape sequence is considered to be a backreference. It is an error if n is greater than the total number of left-capturing parentheses in the entire regular expression.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.12">
	<buginformation>
		<summary>CharacterClassEscape</summary>
		<description>The production   CharacterClassEscape::d  evaluates as follows: Return the ten-element set of characters containing the characters 0 through 9 inclusive.          The production   CharacterClassEscape::D  evaluates as follows: Return the set of all characters not included in the set returned by  CharacterClassEscape::d .          The production   CharacterClassEscape::s  evaluates as follows: Return the set of characters containing the characters that are on the right-hand side of the WhiteSpace or LineTerminator productions.          The production   CharacterClassEscape::S  evaluates as follows: Return the set of all characters not included in the set returned by  CharacterClassEscape::s  .          The production   CharacterClassEscape::w  evaluates as follows: Return the set of all characters returned by WordCharacters().          The production   CharacterClassEscape::W  evaluates as follows: Return the set of all characters not included in the set returned by  CharacterClassEscape::w  .</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.13">
	<buginformation>
		<summary>CharacterClass</summary>
		<description>The production   CharacterClass::[ClassRanges]  evaluates as follows: Evaluate ClassRanges to obtain a CharSet A.Return the two results A and false.          The production   CharacterClass::[^ClassRanges]  evaluates as follows: Evaluate ClassRanges to obtain a CharSet A.Return the two results A and true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.14">
	<buginformation>
		<summary>ClassRanges</summary>
		<description>The production   ClassRanges::[empty]  evaluates as follows: Return the empty CharSet.          The production   ClassRanges::NonemptyClassRanges  evaluates as follows: Evaluate NonemptyClassRanges to obtain a CharSet A.Return A.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.15.1">
	<buginformation>
		<summary>Runtime Semantics: CharacterRange ( A, B )</summary>
		<description>The abstract operation CharacterRange takes two CharSet parameters A and B and performs the following steps: If A does not contain exactly one character or B does not contain exactly one character, throw a SyntaxError exception.Let a be the one character in CharSet A.Let b be the one character in CharSet B.Let i be the character value of character a.Let j be the character value of character b.If i &gt; j, throw a SyntaxError exception.Return the set containing all characters numbered i through j, inclusive.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.16">
	<buginformation>
		<summary>NonemptyClassRangesNoDash</summary>
		<description>The production   NonemptyClassRangesNoDash::ClassAtom  evaluates as follows: Return the CharSet that is the result of evaluating ClassAtom.          The production   NonemptyClassRangesNoDash::ClassAtomNoDashNonemptyClassRangesNoDash  evaluates as follows: Evaluate ClassAtomNoDash to obtain a CharSet A.Evaluate NonemptyClassRangesNoDash to obtain a CharSet B.Return the union of CharSets A and B.          The production   NonemptyClassRangesNoDash::ClassAtomNoDash-ClassAtomClassRanges  evaluates as follows: Evaluate ClassAtomNoDash to obtain a CharSet A.Evaluate ClassAtom to obtain a CharSet B.Evaluate ClassRanges to obtain a CharSet C.Call CharacterRange(A, B) and let D be the resulting CharSet.Return the union of CharSets D and C.          Note 1 ClassRanges can expand into a single ClassAtom and/or ranges of two ClassAtom separated by dashes. In the latter case the ClassRanges includes all characters between the first ClassAtom and the second ClassAtom, inclusive; an error occurs if either ClassAtom does not represent a single character (for example, if one is \w) or if the first ClassAtom&apos;s character value is greater than the second ClassAtom&apos;s character value.  Note 2 Even if the pattern ignores case, the case of the two ends  of a range is significant in determining which characters belong to the  range. Thus, for example, the pattern /[E-F]/i matches only the letters E, F, e, and f, while the pattern /[E-f]/i matches all upper and lower-case letters in the Unicode Basic Latin block as well as the symbols [, \, ], ^, _, and  `.  Note 3 A - character can be treated literally or it can denote a range. It is treated literally if it is the first or last character of ClassRanges, the beginning or end limit of a range specification, or immediately follows a range specification.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.17">
	<buginformation>
		<summary>ClassAtom</summary>
		<description>The production   ClassAtom::-  evaluates as follows: Return the CharSet containing the one character -.          The production   ClassAtom::ClassAtomNoDash  evaluates as follows: Evaluate ClassAtomNoDash to obtain a CharSet A.Return A.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.18">
	<buginformation>
		<summary>ClassAtomNoDash</summary>
		<description>The production   ClassAtomNoDash::SourceCharacterbut not one of \ or ] or -  evaluates as follows: Return the CharSet containing the character matched by SourceCharacter.          The production   ClassAtomNoDash::\ClassEscape  evaluates as follows: Return the CharSet that is the result of evaluating ClassEscape.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.2.19">
	<buginformation>
		<summary>ClassEscape</summary>
		<description>The production   ClassEscape::b  evaluates as follows: Return the CharSet containing the single character &lt;BS&gt; U+0008 (BACKSPACE).          The production   ClassEscape::-  evaluates as follows: Return the CharSet containing the single character - U+002D (HYPHEN-MINUS).          The production   ClassEscape::CharacterEscape  evaluates as follows: Return the CharSet containing the single character that is the result of evaluating CharacterEscape.          The production   ClassEscape::CharacterClassEscape  evaluates as follows: Return the CharSet that is the result of evaluating CharacterClassEscape.          Note A ClassAtom can use any of the escape sequences that are allowed in the rest of the regular expression except for \b, \B, and backreferences. Inside a CharacterClass, \b means the backspace character, while \B and backreferences raise errors. Using a backreference inside a ClassAtom causes an error.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.3.1">
	<buginformation>
		<summary>RegExp ( pattern, flags )</summary>
		<description>The following steps are taken: Let patternIsRegExp be ? IsRegExp(pattern).If NewTarget is not undefined, let newTarget be NewTarget.Else,Let newTarget be the active function object.If patternIsRegExp is true and flags is undefined, thenLet patternConstructor be ? Get(pattern, &amp;quot;constructor&amp;quot;).If SameValue(newTarget, patternConstructor) is true, return pattern.If Type(pattern) is Object and pattern has a [[RegExpMatcher]] internal slot, thenLet P be pattern.[[OriginalSource]].If flags is undefined, let F be pattern.[[OriginalFlags]].Else, let F be flags.Else if patternIsRegExp is true, thenLet P be ? Get(pattern, &amp;quot;source&amp;quot;).If flags is undefined, thenLet F be ? Get(pattern, &amp;quot;flags&amp;quot;).Else, let F be flags.Else,Let P be pattern.Let F be flags.Let O be ? RegExpAlloc(newTarget).Return ? RegExpInitialize(O, P, F).          Note If pattern is supplied using a StringLiteral,  the usual escape sequence substitutions are performed before the String  is processed by RegExp. If pattern must contain an escape sequence to  be recognized by RegExp, any U+005C (REVERSE SOLIDUS) code points must  be escaped within the StringLiteral to prevent them being removed when the contents of the StringLiteral are formed.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.3.2.1">
	<buginformation>
		<summary>Runtime Semantics: RegExpAlloc ( newTarget )</summary>
		<description>When the abstract operation RegExpAlloc with argument newTarget is called, the following steps are taken: Let obj be ? OrdinaryCreateFromConstructor(newTarget, &amp;quot;%RegExpPrototype%&amp;quot;, « [[RegExpMatcher]], [[OriginalSource]], [[OriginalFlags]] »).Perform ! DefinePropertyOrThrow(obj, &amp;quot;lastIndex&amp;quot;, PropertyDescriptor {[[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).Return obj.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.3.2.2">
	<buginformation>
		<summary>Runtime Semantics: RegExpInitialize ( obj, pattern, flags )</summary>
		<description>When the abstract operation RegExpInitialize with arguments obj, pattern, and flags is called, the following steps are taken: If pattern is undefined, let P be the empty String.Else, let P be ? ToString(pattern).If flags is undefined, let F be the empty String.Else, let F be ? ToString(flags).If F contains any code unit other than &amp;quot;g&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;u&amp;quot;, or &amp;quot;y&amp;quot; or if it contains the same code unit more than once, throw a SyntaxError exception.If F contains &amp;quot;u&amp;quot;, let BMP be false; else let BMP be true.If BMP is true, thenParse P using the grammars in 21.2.1 and interpreting each of its 16-bit elements as a Unicode BMP code point. UTF-16 decoding is not applied to the elements. The goal symbol for the parse is Pattern[~U]. Throw a SyntaxError exception if P did not conform to the grammar, if any elements of P were not matched by the parse, or if any Early Error conditions exist.Let patternCharacters be a List whose elements are the code unit elements of P.Else,Parse P using the grammars in 21.2.1 and interpreting P as UTF-16 encoded Unicode code points (6.1.4). The goal symbol for the parse is Pattern[+U]. Throw a SyntaxError exception if P did not conform to the grammar, if any elements of P were not matched by the parse, or if any Early Error conditions exist.Let patternCharacters be a List whose elements are the code points resulting from applying UTF-16 decoding to P&apos;s sequence of elements.Set obj.[[OriginalSource]] to P.Set obj.[[OriginalFlags]] to F.Set obj.[[RegExpMatcher]] to the internal procedure that evaluates the above parse of P by applying the semantics provided in 21.2.2 using patternCharacters as the pattern&apos;s List of SourceCharacter values and F as the flag parameters.Perform ? Set(obj, &amp;quot;lastIndex&amp;quot;, 0, true).Return obj.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.3.2.3">
	<buginformation>
		<summary>Runtime Semantics: RegExpCreate ( P, F )</summary>
		<description>When the abstract operation RegExpCreate with arguments P and F is called, the following steps are taken: Let obj be ? RegExpAlloc(%RegExp%).Return ? RegExpInitialize(obj, P, F).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.3.2.4">
	<buginformation>
		<summary>Runtime Semantics: EscapeRegExpPattern ( P, F )</summary>
		<description>When the abstract operation EscapeRegExpPattern with arguments P and F is called, the following occurs: Let S be a String in the form of a Pattern[~U] (Pattern[+U] if F contains &amp;quot;u&amp;quot;) equivalent to P interpreted as UTF-16 encoded Unicode code points (6.1.4), in which certain code points are escaped as described below. S may or may not be identical to P; however, the internal procedure that would result from evaluating S as a Pattern[~U] (Pattern[+U] if F contains &amp;quot;u&amp;quot;)  must behave identically to the internal procedure given by the  constructed object&apos;s [[RegExpMatcher]] internal slot. Multiple calls to  this abstract operation using the same values for P and F must produce identical results.The code points / or any LineTerminator occurring in the pattern shall be escaped in S as necessary to ensure that the String value formed by concatenating the Strings &amp;quot;/&amp;quot;, S, &amp;quot;/&amp;quot;, and F can be parsed (in an appropriate lexical context) as a RegularExpressionLiteral that behaves identically to the constructed regular expression. For example, if P is &amp;quot;/&amp;quot;, then S could be &amp;quot;\/&amp;quot; or &amp;quot;\u002F&amp;quot;, among other possibilities, but not &amp;quot;/&amp;quot;, because /// followed by F would be parsed as a SingleLineComment rather than a RegularExpressionLiteral. If P is the empty String, this specification can be met by letting S be &amp;quot;(?:)&amp;quot;.Return S.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.4.1">
	<buginformation>
		<summary>RegExp.prototype</summary>
		<description>The initial value of RegExp.prototype is the intrinsic object %RegExpPrototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.4.2">
	<buginformation>
		<summary>get RegExp [ @@species ]</summary>
		<description>RegExp[@@species] is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Return the this value.          The value of the name property of this function is &amp;quot;get [Symbol.species]&amp;quot;. Note RegExp prototype methods normally use their this  object&apos;s constructor to create a derived object. However, a subclass  constructor may over-ride that default behaviour by redefining its  @@species property.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.5.1">
	<buginformation>
		<summary>RegExp.prototype.constructor</summary>
		<description>The initial value of RegExp.prototype.constructor is the intrinsic object %RegExp%.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.5.2.1">
	<buginformation>
		<summary>Runtime Semantics: RegExpExec ( R, S )</summary>
		<description>The abstract operation RegExpExec with arguments R and S performs the following steps: Assert: Type(R) is Object.Assert: Type(S) is String.Let exec be ? Get(R, &amp;quot;exec&amp;quot;).If IsCallable(exec) is true, thenLet result be ? Call(exec, R, « S »).If Type(result) is neither Object or Null, throw a TypeError exception.Return result.If R does not have a [[RegExpMatcher]] internal slot, throw a TypeError exception.Return ? RegExpBuiltinExec(R, S).            Note If a callable exec property is not found  this algorithm falls back to attempting to use the built-in RegExp  matching algorithm. This provides compatible behaviour for code written  for prior editions where most built-in algorithms that use regular  expressions did not perform a dynamic property lookup of exec.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.5.2.2">
	<buginformation>
		<summary>Runtime Semantics: RegExpBuiltinExec ( R, S )</summary>
		<description>The abstract operation RegExpBuiltinExec with arguments R and S performs the following steps: Assert: R is an initialized RegExp instance.Assert: Type(S) is String.Let length be the number of code units in S.Let lastIndex be ? ToLength(? Get(R, &amp;quot;lastIndex&amp;quot;)).Let flags be R.[[OriginalFlags]].If flags contains &amp;quot;g&amp;quot;, let global be true, else let global be false.If flags contains &amp;quot;y&amp;quot;, let sticky be true, else let sticky be false.If global is false and sticky is false, set lastIndex to 0.Let matcher be R.[[RegExpMatcher]].If flags contains &amp;quot;u&amp;quot;, let fullUnicode be true, else let fullUnicode be false.Let matchSucceeded be false.Repeat, while matchSucceeded is falseIf lastIndex &gt; length, thenIf global is true or sticky is true, thenPerform ? Set(R, &amp;quot;lastIndex&amp;quot;, 0, true).Return null.Let r be matcher(S, lastIndex).If r is failure, thenIf sticky is true, thenPerform ? Set(R, &amp;quot;lastIndex&amp;quot;, 0, true).Return null.Set lastIndex to AdvanceStringIndex(S, lastIndex, fullUnicode).Else,Assert: r is a State.Set matchSucceeded to true.Let e be r&apos;s endIndex value.If fullUnicode is true, thene is an index into the Input character list, derived from S, matched by matcher. Let eUTF be the smallest index into S that corresponds to the character at element e of Input. If e is greater than or equal to the length of Input, then eUTF is the number of code units in S.Set e to eUTF.If global is true or sticky is true, thenPerform ? Set(R, &amp;quot;lastIndex&amp;quot;, e, true).Let n be the length of r&apos;s captures List. (This is the same value as 21.2.2.1&apos;s NcapturingParens.)Let A be ! ArrayCreate(n + 1).Assert: The value of A&apos;s &amp;quot;length&amp;quot; property is n + 1.Let matchIndex be lastIndex.Perform ! CreateDataProperty(A, &amp;quot;index&amp;quot;, matchIndex).Perform ! CreateDataProperty(A, &amp;quot;input&amp;quot;, S).Let matchedSubstr be the matched substring (i.e. the portion of S between offset lastIndex inclusive and offset e exclusive).Perform ! CreateDataProperty(A, &amp;quot;0&amp;quot;, matchedSubstr).For each integer i such that i &gt; 0 and i ≤ n, doLet captureI be ith element of r&apos;s captures List.If captureI is undefined, let capturedValue be undefined.Else if fullUnicode is true, thenAssert: captureI is a List of code points.Let capturedValue be a String value whose code units are the UTF16Encoding of the code points of captureI.Else fullUnicode is false,Assert: captureI is a List of code units.Let capturedValue be a String consisting of the code units of captureI.Perform ! CreateDataProperty(A, ! ToString(i), capturedValue).Return A.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.5.2.3">
	<buginformation>
		<summary>AdvanceStringIndex ( S, index, unicode )</summary>
		<description>The abstract operation AdvanceStringIndex with arguments S, index, and unicode performs the following steps: Assert: Type(S) is String.Assert: index is an integer such that 0≤index≤253-1.Assert: Type(unicode) is Boolean.If unicode is false, return index+1.Let length be the number of code units in S.If index+1 ≥ length, return index+1.Let first be the code unit value at index index in S.If first &lt; 0xD800 or first &gt; 0xDBFF, return index+1.Let second be the code unit value at index index+1 in S.If second &lt; 0xDC00 or second &gt; 0xDFFF, return index+1.Return index+2.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.5.3">
	<buginformation>
		<summary>get RegExp.prototype.flags</summary>
		<description>RegExp.prototype.flags is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let R be the this value.If Type(R) is not Object, throw a TypeError exception.Let result be the empty String.Let global be ToBoolean(? Get(R, &amp;quot;global&amp;quot;)).If global is true, append &amp;quot;g&amp;quot; as the last code unit of result.Let ignoreCase be ToBoolean(? Get(R, &amp;quot;ignoreCase&amp;quot;)).If ignoreCase is true, append &amp;quot;i&amp;quot; as the last code unit of result.Let multiline be ToBoolean(? Get(R, &amp;quot;multiline&amp;quot;)).If multiline is true, append &amp;quot;m&amp;quot; as the last code unit of result.Let unicode be ToBoolean(? Get(R, &amp;quot;unicode&amp;quot;)).If unicode is true, append &amp;quot;u&amp;quot; as the last code unit of result.Let sticky be ToBoolean(? Get(R, &amp;quot;sticky&amp;quot;)).If sticky is true, append &amp;quot;y&amp;quot; as the last code unit of result.Return result.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.5.4">
	<buginformation>
		<summary>get RegExp.prototype.global</summary>
		<description>RegExp.prototype.global is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let R be the this value.If Type(R) is not Object, throw a TypeError exception.If R does not have an [[OriginalFlags]] internal slot, thenIf SameValue(R, %RegExpPrototype%) is true, return undefined.Otherwise, throw a TypeError exception.Let flags be R.[[OriginalFlags]].If flags contains the code unit &amp;quot;g&amp;quot;, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.5.5">
	<buginformation>
		<summary>get RegExp.prototype.ignoreCase</summary>
		<description>RegExp.prototype.ignoreCase is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let R be the this value.If Type(R) is not Object, throw a TypeError exception.If R does not have an [[OriginalFlags]] internal slot, thenIf SameValue(R, %RegExpPrototype%) is true, return undefined.Otherwise, throw a TypeError exception.Let flags be R.[[OriginalFlags]].If flags contains the code unit &amp;quot;i&amp;quot;, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.5.6">
	<buginformation>
		<summary>RegExp.prototype [ @@match ] ( string )</summary>
		<description>When the @@match method is called with argument string, the following steps are taken: Let rx be the this value.If Type(rx) is not Object, throw a TypeError exception.Let S be ? ToString(string).Let global be ToBoolean(? Get(rx, &amp;quot;global&amp;quot;)).If global is false, thenReturn ? RegExpExec(rx, S).Else global is true,Let fullUnicode be ToBoolean(? Get(rx, &amp;quot;unicode&amp;quot;)).Perform ? Set(rx, &amp;quot;lastIndex&amp;quot;, 0, true).Let A be ! ArrayCreate(0).Let n be 0.Repeat,Let result be ? RegExpExec(rx, S).If result is null, thenIf n</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.5.7">
	<buginformation>
		<summary>get RegExp.prototype.multiline</summary>
		<description>RegExp.prototype.multiline is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let R be the this value.If Type(R) is not Object, throw a TypeError exception.If R does not have an [[OriginalFlags]] internal slot, thenIf SameValue(R, %RegExpPrototype%) is true, return undefined.Otherwise, throw a TypeError exception.Let flags be R.[[OriginalFlags]].If flags contains the code unit &amp;quot;m&amp;quot;, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.5.8">
	<buginformation>
		<summary>RegExp.prototype [ @@replace ] ( string, replaceValue )</summary>
		<description>When the @@replace method is called with arguments string and replaceValue, the following steps are taken: Let rx be the this value.If Type(rx) is not Object, throw a TypeError exception.Let S be ? ToString(string).Let lengthS be the number of code unit elements in S.Let functionalReplace be IsCallable(replaceValue).If functionalReplace is false, thenLet replaceValue be ? ToString(replaceValue).Let global be ToBoolean(? Get(rx, &amp;quot;global&amp;quot;)).If global is true, thenLet fullUnicode be ToBoolean(? Get(rx, &amp;quot;unicode&amp;quot;)).Perform ? Set(rx, &amp;quot;lastIndex&amp;quot;, 0, true).Let results be a new empty List.Let done be false.Repeat, while done is falseLet result be ? RegExpExec(rx, S).If result is null, set done to true.Else result is not null,Append result to the end of results.If global is false, set done to true.Else,Let matchStr be ? ToString(? Get(result, &amp;quot;0&amp;quot;)).If matchStr is the empty String, thenLet thisIndex be ? ToLength(? Get(rx, &amp;quot;lastIndex&amp;quot;)).Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode).Perform ? Set(rx, &amp;quot;lastIndex&amp;quot;, nextIndex, true).Let accumulatedResult be the empty String value.Let nextSourcePosition be 0.For each result in results, doLet nCaptures be ? ToLength(? Get(result, &amp;quot;length&amp;quot;)).Let nCaptures be max(nCaptures - 1, 0).Let matched be ? ToString(? Get(result, &amp;quot;0&amp;quot;)).Let matchLength be the number of code units in matched.Let position be ? ToInteger(? Get(result, &amp;quot;index&amp;quot;)).Let position be max(min(position, lengthS), 0).Let n be 1.Let captures be a new empty List.Repeat, while n ≤ nCapturesLet capN be ? Get(result, ! ToString(n)).If capN is not undefined, thenLet capN be ? ToString(capN).Append capN as the last element of captures.Let n be n+1.If functionalReplace is true, thenLet replacerArgs be « matched ».Append in list order the elements of captures to the end of the List replacerArgs.Append position and S as the last two elements of replacerArgs.Let replValue be ? Call(replaceValue, undefined, replacerArgs).Let replacement be ? ToString(replValue).Else,Let replacement be GetSubstitution(matched, S, position, captures, replaceValue).If position ≥ nextSourcePosition, thenNOTE: position  should not normally move backwards. If it does, it is an indication of  an ill-behaving RegExp subclass or use of an access triggered  side-effect to change the global flag or other characteristics of rx. In such cases, the corresponding substitution is ignored.Let accumulatedResult be the String formed by concatenating the code units of the current value of accumulatedResult with the substring of S consisting of the code units from nextSourcePosition (inclusive) up to position (exclusive) and with the code units of replacement.Let nextSourcePosition be position + matchLength.If nextSourcePosition ≥ lengthS, return accumulatedResult.Return the String formed by concatenating the code units of accumulatedResult with the substring of S consisting of the code units from nextSourcePosition (inclusive) up through the final code unit of S (inclusive).          The value of the name property of this function is &amp;quot;[Symbol.replace]&amp;quot;.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.5.9">
	<buginformation>
		<summary>RegExp.prototype [ @@search ] ( string )</summary>
		<description>When the @@search method is called with argument string, the following steps are taken: Let rx be the this value.If Type(rx) is not Object, throw a TypeError exception.Let S be ? ToString(string).Let previousLastIndex be ? Get(rx, &amp;quot;lastIndex&amp;quot;).If SameValue(previousLastIndex, 0) is false, thenPerform ? Set(rx, &amp;quot;lastIndex&amp;quot;, 0, true).Let result be ? RegExpExec(rx, S).Let currentLastIndex be ? Get(rx, &amp;quot;lastIndex&amp;quot;).If SameValue(currentLastIndex, previousLastIndex) is false, thenPerform ? Set(rx, &amp;quot;lastIndex&amp;quot;, previousLastIndex, true).If result is null, return -1.Return ? Get(result, &amp;quot;index&amp;quot;).          The value of the name property of this function is &amp;quot;[Symbol.search]&amp;quot;. Note The lastIndex and global properties of this RegExp object are ignored when performing the search. The lastIndex property is left unchanged.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.5.10">
	<buginformation>
		<summary>get RegExp.prototype.source</summary>
		<description>RegExp.prototype.source is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let R be the this value.If Type(R) is not Object, throw a TypeError exception.If R does not have an [[OriginalSource]] internal slot, thenIf SameValue(R, %RegExpPrototype%) is true, return &amp;quot;(?:)&amp;quot;.Otherwise, throw a TypeError exception.Assert: R has an [[OriginalFlags]] internal slot.Let src be R.[[OriginalSource]].Let flags be R.[[OriginalFlags]].Return EscapeRegExpPattern(src, flags).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.5.11">
	<buginformation>
		<summary>RegExp.prototype [ @@split ] ( string, limit )</summary>
		<description>Note 1 Returns an Array object into which substrings of the result of converting string to a String have been stored. The substrings are determined by searching from left to right for matches of the this  value regular expression; these occurrences are not part of any  substring in the returned array, but serve to divide up the String  value. The this value may be an empty regular  expression or a regular expression that can match an empty String. In  this case, the regular expression does not match the empty substring at  the beginning or end of the input String, nor does it match the empty  substring at the end of the previous separator match. (For example, if  the regular expression matches the empty String, the String is split up  into individual code unit elements; the length of the result array  equals the length of the String, and each substring contains one code  unit.) Only the first match at a given index of the String is  considered, even if backtracking could yield a non-empty-substring match  at that index. (For example, /a*?/[Symbol.split](&amp;quot;ab&amp;quot;) evaluates to the array [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;], while /a*/[Symbol.split](&amp;quot;ab&amp;quot;) evaluates to the array [&amp;quot;&amp;quot;,&amp;quot;b&amp;quot;].) If the string is (or converts to) the empty  String, the result depends on whether the regular expression can match  the empty String. If it can, the result array contains no elements.  Otherwise, the result array contains one element, which is the empty  String. If the regular expression contains capturing parentheses, then each time separator is matched the results (including any undefined results) of the capturing parentheses are spliced into the output array. For example, /&lt;(\/)?([^&lt;&gt;]+)&gt;/[Symbol.split](&amp;quot;A&lt;B&gt;bold&lt;/B&gt;and&lt;CODE&gt;coded&lt;/CODE&gt;&amp;quot;) evaluates to the array [&amp;quot;A&amp;quot;,undefined,&amp;quot;B&amp;quot;,&amp;quot;bold&amp;quot;,&amp;quot;/&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;and&amp;quot;,undefined,&amp;quot;CODE&amp;quot;,&amp;quot;coded&amp;quot;,&amp;quot;/&amp;quot;,&amp;quot;CODE&amp;quot;,&amp;quot;&amp;quot;] If limit is not undefined, then the output array is truncated so that it contains no more than limit elements.  When the @@split method is called, the following steps are taken: Let rx be the this value.If Type(rx) is not Object, throw a TypeError exception.Let S be ? ToString(string).Let C be ? SpeciesConstructor(rx, %RegExp%).Let flags be ? ToString(? Get(rx, &amp;quot;flags&amp;quot;)).If flags contains &amp;quot;u&amp;quot;, let unicodeMatching be true.Else, let unicodeMatching be false.If flags contains &amp;quot;y&amp;quot;, let newFlags be flags.Else, let newFlags be the String that is the concatenation of flags and &amp;quot;y&amp;quot;.Let splitter be ? Construct(C, « rx, newFlags »).Let A be ! ArrayCreate(0).Let lengthA be 0.If limit is undefined, let lim be 232-1; else let lim be ? ToUint32(limit).Let size be the number of elements in S.Let p be 0.If lim</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.5.12">
	<buginformation>
		<summary>get RegExp.prototype.sticky</summary>
		<description>RegExp.prototype.sticky is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let R be the this value.If Type(R) is not Object, throw a TypeError exception.If R does not have an [[OriginalFlags]] internal slot, thenIf SameValue(R, %RegExpPrototype%) is true, return undefined.Otherwise, throw a TypeError exception.Let flags be R.[[OriginalFlags]].If flags contains the code unit &amp;quot;y&amp;quot;, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.5.13">
	<buginformation>
		<summary>RegExp.prototype.test ( S )</summary>
		<description>The following steps are taken: Let R be the this value.If Type(R) is not Object, throw a TypeError exception.Let string be ? ToString(S).Let match be ? RegExpExec(R, string).If match is not null, return true; else return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.5.14">
	<buginformation>
		<summary>RegExp.prototype.toString ( )</summary>
		<description>Let R be the this value.If Type(R) is not Object, throw a TypeError exception.Let pattern be ? ToString(? Get(R, &amp;quot;source&amp;quot;)).Let flags be ? ToString(? Get(R, &amp;quot;flags&amp;quot;)).Let result be the String value formed by concatenating &amp;quot;/&amp;quot;, pattern, &amp;quot;/&amp;quot;, and flags.Return result.          Note The returned String has the form of a RegularExpressionLiteral that evaluates to another RegExp object with the same behaviour as this object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.5.15">
	<buginformation>
		<summary>get RegExp.prototype.unicode</summary>
		<description>RegExp.prototype.unicode is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let R be the this value.If Type(R) is not Object, throw a TypeError exception.If R does not have an [[OriginalFlags]] internal slot, thenIf SameValue(R, %RegExpPrototype%) is true, return undefined.Otherwise, throw a TypeError exception.Let flags be R.[[OriginalFlags]].If flags contains the code unit &amp;quot;u&amp;quot;, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="21.2.6.1">
	<buginformation>
		<summary>lastIndex</summary>
		<description>The value of the lastIndex property specifies the String index at which to start the next match. It is coerced to an integer when used (see  21.2.5.2.2). This property shall have the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.1.1">
	<buginformation>
		<summary>Array ( )</summary>
		<description>This description applies if and only if the Array constructor is called with no arguments. Let numberOfArgs be the number of arguments passed to this function call.Assert: numberOfArgs</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.1.2">
	<buginformation>
		<summary>Array ( len )</summary>
		<description>This description applies if and only if the Array constructor is called with exactly one argument. Let numberOfArgs be the number of arguments passed to this function call.Assert: numberOfArgs</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.1.3">
	<buginformation>
		<summary>Array ( ...items )</summary>
		<description>This description applies if and only if the Array constructor is called with at least two arguments. When the Array function is called, the following steps are taken: Let numberOfArgs be the number of arguments passed to this function call.Assert: numberOfArgs ≥ 2.If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.Let proto be ? GetPrototypeFromConstructor(newTarget, &amp;quot;%ArrayPrototype%&amp;quot;).Let array be ? ArrayCreate(numberOfArgs, proto).Let k be 0.Let items be a zero-origined List containing the argument items in order.Repeat, while k &lt; numberOfArgsLet Pk be ! ToString(k).Let itemK be items[k].Let defineStatus be CreateDataProperty(array, Pk, itemK).Assert: defineStatus is true.Increase k by 1.Assert: The value of array&apos;s length property is numberOfArgs.Return array.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.2.1">
	<buginformation>
		<summary>Array.from ( items [ , mapfn [ , thisArg ] ] )</summary>
		<description>When the from method is called with argument items and optional arguments mapfn and thisArg, the following steps are taken: Let C be the this value.If mapfn is undefined, let mapping be false.Else,If IsCallable(mapfn) is false, throw a TypeError exception.If thisArg was supplied, let T be thisArg; else let T be undefined.Let mapping be true.Let usingIterator be ? GetMethod(items, @@iterator).If usingIterator is not undefined, thenIf IsConstructor(C) is true, thenLet A be ? Construct(C).Else,Let A be ! ArrayCreate(0).Let iterator be ? GetIterator(items, usingIterator).Let k be 0.Repeat,If k ≥ 253-1, thenLet error be Completion{[[Type]]: throw, [[Value]]: a newly created TypeError object, [[Target]]: empty}.Return ? IteratorClose(iterator, error).Let Pk be ! ToString(k).Let next be ? IteratorStep(iterator).If next is false, thenPerform ? Set(A, &amp;quot;length&amp;quot;, k, true).Return A.Let nextValue be ? IteratorValue(next).If mapping is true, thenLet mappedValue be Call(mapfn, T, « nextValue, k »).If mappedValue is an abrupt completion, return ? IteratorClose(iterator, mappedValue).Let mappedValue be mappedValue.[[Value]].Else, let mappedValue be nextValue.Let defineStatus be CreateDataPropertyOrThrow(A, Pk, mappedValue).If defineStatus is an abrupt completion, return ? IteratorClose(iterator, defineStatus).Increase k by 1.NOTE: items is not an Iterable so assume it is an array-like object.Let arrayLike be ! ToObject(items).Let len be ? ToLength(? Get(arrayLike, &amp;quot;length&amp;quot;)).If IsConstructor(C) is true, thenLet A be ? Construct(C, « len »).Else,Let A be ? ArrayCreate(len).Let k be 0.Repeat, while k &lt; lenLet Pk be ! ToString(k).Let kValue be ? Get(arrayLike, Pk).If mapping is true, thenLet mappedValue be ? Call(mapfn, T, « kValue, k »).Else, let mappedValue be kValue.Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue).Increase k by 1.Perform ? Set(A, &amp;quot;length&amp;quot;, len, true).Return A.          Note The from function is an intentionally generic factory method; it does not require that its this  value be the Array constructor. Therefore it can be transferred to or  inherited by any other constructors that may be called with a single  numeric argument.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.2.2">
	<buginformation>
		<summary>Array.isArray ( arg )</summary>
		<description>The isArray function takes one argument arg, and performs the following steps: Return ? IsArray(arg).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.2.3">
	<buginformation>
		<summary>Array.of ( ...items )</summary>
		<description>When the of method is called with any number of arguments, the following steps are taken: Let len be the actual number of arguments passed to this function.Let items be the List of arguments passed to this function.Let C be the this value.If IsConstructor(C) is true, thenLet A be ? Construct(C, « len »).Else,Let A be ? ArrayCreate(len).Let k be 0.Repeat, while k &lt; lenLet kValue be items[k].Let Pk be ! ToString(k).Perform ? CreateDataPropertyOrThrow(A, Pk, kValue).Increase k by 1.Perform ? Set(A, &amp;quot;length&amp;quot;, len, true).Return A.          Note 1 The items argument is assumed to be a well-formed rest argument value.  Note 2 The of function is an intentionally generic factory method; it does not require that its this  value be the Array constructor. Therefore it can be transferred to or  inherited by other constructors that may be called with a single numeric  argument.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.2.4">
	<buginformation>
		<summary>Array.prototype</summary>
		<description>The value of Array.prototype is %ArrayPrototype%, the intrinsic Array prototype object. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.2.5">
	<buginformation>
		<summary>get Array [ @@species ]</summary>
		<description>Array[@@species] is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Return the this value.          The value of the name property of this function is &amp;quot;get [Symbol.species]&amp;quot;. Note Array prototype methods normally use their this  object&apos;s constructor to create a derived object. However, a subclass  constructor may over-ride that default behaviour by redefining its  @@species property.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.1.1">
	<buginformation>
		<summary>Runtime Semantics: IsConcatSpreadable ( O )</summary>
		<description>The abstract operation IsConcatSpreadable with argument O performs the following steps: If Type(O) is not Object, return false.Let spreadable be ? Get(O, @@isConcatSpreadable).If spreadable is not undefined, return ToBoolean(spreadable).Return ? IsArray(O).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.2">
	<buginformation>
		<summary>Array.prototype.constructor</summary>
		<description>The initial value of Array.prototype.constructor is the intrinsic object %Array%.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.3">
	<buginformation>
		<summary>Array.prototype.copyWithin ( target, start [ , end ] )</summary>
		<description>The copyWithin method takes up to three arguments target, start and end. Note 1 The end argument is optional with the length of the this object as its default value. If target is negative, it is treated as  length+target where length is the length of the array. If start is negative, it is treated as  length+start. If end is negative, it is treated as  length+end.  The following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).Let relativeTarget be ? ToInteger(target).If relativeTarget &lt; 0, let to be max((len + relativeTarget), 0); else let to be min(relativeTarget, len).Let relativeStart be ? ToInteger(start).If relativeStart &lt; 0, let from be max((len + relativeStart), 0); else let from be min(relativeStart, len).If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).If relativeEnd &lt; 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).Let count be min(final-from, len-to).If from&lt;to and to&lt;from+count, thenLet direction be -1.Let from be from + count - 1.Let to be to + count - 1.Else,Let direction be 1.Repeat, while count &gt; 0Let fromKey be ! ToString(from).Let toKey be ! ToString(to).Let fromPresent be ? HasProperty(O, fromKey).If fromPresent is true, thenLet fromVal be ? Get(O, fromKey).Perform ? Set(O, toKey, fromVal, true).Else fromPresent is false,Perform ? DeletePropertyOrThrow(O, toKey).Let from be from + direction.Let to be to + direction.Let count be count - 1.Return O.          Note 2 The copyWithin function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.4">
	<buginformation>
		<summary>Array.prototype.entries ( )</summary>
		<description>The following steps are taken: Let O be ? ToObject(this value).Return CreateArrayIterator(O, &amp;quot;key+value&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.5">
	<buginformation>
		<summary>Array.prototype.every ( callbackfn [ , thisArg ] )</summary>
		<description>Note 1 callbackfn should be a function that accepts three arguments and returns a value that is coercible to the Boolean value true or false. every calls callbackfn once for each element present in the array, in ascending order, until it finds one where callbackfn returns false. If such an element is found, every immediately returns false. Otherwise, if callbackfn returned true for all elements, every will return true. callbackfn is called only for elements of the array which actually exist; it is not called for missing elements of the array. If a thisArg parameter is provided, it will be used as the this value for each invocation of callbackfn. If it is not provided, undefined is used instead. callbackfn is called with three arguments: the value of the element, the index of the element, and the object being traversed. every does not directly mutate the object on which it is called but the object may be mutated by the calls to callbackfn. The range of elements processed by every is set before the first call to callbackfn. Elements which are appended to the array after the call to every begins will not be visited by callbackfn. If existing elements of the array are changed, their value as passed to callbackfn will be the value at the time every visits them; elements that are deleted after the call to every begins and before being visited are not visited. every acts like the &amp;quot;for all&amp;quot; quantifier in mathematics. In particular, for an empty array, it returns true.  When the every method is called with one or two arguments, the following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).If IsCallable(callbackfn) is false, throw a TypeError exception.If thisArg was supplied, let T be thisArg; else let T be undefined.Let k be 0.Repeat, while k &lt; lenLet Pk be ! ToString(k).Let kPresent be ? HasProperty(O, Pk).If kPresent is true, thenLet kValue be ? Get(O, Pk).Let testResult be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).If testResult is false, return false.Increase k by 1.Return true.          Note 2 The every function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.6">
	<buginformation>
		<summary>Array.prototype.fill ( value [ , start [ , end ] ] )</summary>
		<description>The fill method takes up to three arguments value, start and end. Note 1 The start and end arguments are optional with default values of 0 and the length of the this object. If start is negative, it is treated as  length+start where length is the length of the array. If end is negative, it is treated as  length+end.  The following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).Let relativeStart be ? ToInteger(start).If relativeStart &lt; 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).If relativeEnd &lt; 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).Repeat, while k &lt; finalLet Pk be ! ToString(k).Perform ? Set(O, Pk, value, true).Increase k by 1.Return O.          Note 2 The fill function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.7">
	<buginformation>
		<summary>Array.prototype.filter ( callbackfn [ , thisArg ] )</summary>
		<description>Note 1 callbackfn should be a function that accepts three arguments and returns a value that is coercible to the Boolean value true or false. filter calls callbackfn once for each element in the array, in ascending order, and constructs a new array of all the values for which callbackfn returns true. callbackfn is called only for elements of the array which actually exist; it is not called for missing elements of the array. If a thisArg parameter is provided, it will be used as the this value for each invocation of callbackfn. If it is not provided, undefined is used instead. callbackfn is called with three arguments: the value of the element, the index of the element, and the object being traversed. filter does not directly mutate the object on which it is called but the object may be mutated by the calls to callbackfn. The range of elements processed by filter is set before the first call to callbackfn. Elements which are appended to the array after the call to filter begins will not be visited by callbackfn. If existing elements of the array are changed their value as passed to callbackfn will be the value at the time filter visits them; elements that are deleted after the call to filter begins and before being visited are not visited.  When the filter method is called with one or two arguments, the following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).If IsCallable(callbackfn) is false, throw a TypeError exception.If thisArg was supplied, let T be thisArg; else let T be undefined.Let A be ? ArraySpeciesCreate(O, 0).Let k be 0.Let to be 0.Repeat, while k &lt; lenLet Pk be ! ToString(k).Let kPresent be ? HasProperty(O, Pk).If kPresent is true, thenLet kValue be ? Get(O, Pk).Let selected be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).If selected is true, thenPerform ? CreateDataPropertyOrThrow(A, ! ToString(to), kValue).Increase to by 1.Increase k by 1.Return A.          Note 2 The filter function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.8">
	<buginformation>
		<summary>Array.prototype.find ( predicate [ , thisArg ] )</summary>
		<description>The find method is called with one or two arguments, predicate and thisArg. Note 1 predicate should be a function that accepts three arguments and returns a value that is coercible to a Boolean value. find calls predicate once for each element of the array, in ascending order, until it finds one where predicate returns true. If such an element is found, find immediately returns that element value. Otherwise, find returns undefined. If a thisArg parameter is provided, it will be used as the this value for each invocation of predicate. If it is not provided, undefined is used instead. predicate is called with three arguments: the value of the element, the index of the element, and the object being traversed. find does not directly mutate the object on which it is called but the object may be mutated by the calls to predicate. The range of elements processed by find is set before the first call to callbackfn. Elements that are appended to the array after the call to find begins will not be visited by callbackfn. If existing elements of the array are changed, their value as passed to predicate will be the value at the time that find visits them.  When the find method is called, the following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).If IsCallable(predicate) is false, throw a TypeError exception.If thisArg was supplied, let T be thisArg; else let T be undefined.Let k be 0.Repeat, while k &lt; lenLet Pk be ! ToString(k).Let kValue be ? Get(O, Pk).Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).If testResult is true, return kValue.Increase k by 1.Return undefined.          Note 2 The find function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.9">
	<buginformation>
		<summary>Array.prototype.findIndex ( predicate [ , thisArg ] )</summary>
		<description>Note 1 predicate should be a function that accepts three arguments and returns a value that is coercible to the Boolean value true or false. findIndex calls predicate once for each element of the array, in ascending order, until it finds one where predicate returns true. If such an element is found, findIndex immediately returns the index of that element value. Otherwise, findIndex returns -1. If a thisArg parameter is provided, it will be used as the this value for each invocation of predicate. If it is not provided, undefined is used instead. predicate is called with three arguments: the value of the element, the index of the element, and the object being traversed. findIndex does not directly mutate the object on which it is called but the object may be mutated by the calls to predicate. The range of elements processed by findIndex is set before the first call to callbackfn. Elements that are appended to the array after the call to findIndex begins will not be visited by callbackfn. If existing elements of the array are changed, their value as passed to predicate will be the value at the time that findIndex visits them.  When the findIndex method is called with one or two arguments, the following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).If IsCallable(predicate) is false, throw a TypeError exception.If thisArg was supplied, let T be thisArg; else let T be undefined.Let k be 0.Repeat, while k &lt; lenLet Pk be ! ToString(k).Let kValue be ? Get(O, Pk).Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).If testResult is true, return k.Increase k by 1.Return -1.          Note 2 The findIndex function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.10">
	<buginformation>
		<summary>Array.prototype.forEach ( callbackfn [ , thisArg ] )</summary>
		<description>Note 1 callbackfn should be a function that accepts three arguments. forEach calls callbackfn once for each element present in the array, in ascending order. callbackfn is called only for elements of the array which actually exist; it is not called for missing elements of the array. If a thisArg parameter is provided, it will be used as the this value for each invocation of callbackfn. If it is not provided, undefined is used instead. callbackfn is called with three arguments: the value of the element, the index of the element, and the object being traversed. forEach does not directly mutate the object on which it is called but the object may be mutated by the calls to callbackfn.  When the forEach method is called with one or two arguments, the following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).If IsCallable(callbackfn) is false, throw a TypeError exception.If thisArg was supplied, let T be thisArg; else let T be undefined.Let k be 0.Repeat, while k &lt; lenLet Pk be ! ToString(k).Let kPresent be ? HasProperty(O, Pk).If kPresent is true, thenLet kValue be ? Get(O, Pk).Perform ? Call(callbackfn, T, « kValue, k, O »).Increase k by 1.Return undefined.          Note 2 The forEach function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.11">
	<buginformation>
		<summary>Array.prototype.includes ( searchElement [ , fromIndex ] )</summary>
		<description>Note 1 includes compares searchElement to the elements of the array, in ascending order, using the SameValueZero algorithm, and if found at any position, returns true; otherwise, false is returned. The optional second argument fromIndex defaults to 0 (i.e. the whole array is searched). If it is greater than or equal to the length of the array, false  is returned, i.e. the array will not be searched. If it is negative, it  is used as the offset from the end of the array to compute fromIndex. If the computed index is less than 0, the whole array will be searched.  When the includes method is called, the following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).If len is 0, return false.Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)If n ≥ 0, thenLet k be n.Else n &lt; 0,Let k be len + n.If k &lt; 0, let k be 0.Repeat, while k &lt; lenLet elementK be the result of ? Get(O, ! ToString(k)).If SameValueZero(searchElement, elementK) is true, return true.Increase k by 1.Return false.          Note 2 The includes function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.  Note 3 The includes method intentionally differs from the similar indexOf method in two ways. First, it uses the SameValueZero algorithm, instead of Strict Equality Comparison, allowing it to detect NaN array elements. Second, it does not skip missing array elements, instead treating them as undefined.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.12">
	<buginformation>
		<summary>Array.prototype.indexOf ( searchElement [ , fromIndex ] )</summary>
		<description>Note 1 indexOf compares searchElement to the elements of the array, in ascending order, using the Strict Equality Comparison algorithm, and if found at one or more indices, returns the smallest such index; otherwise, -1 is returned. The optional second argument fromIndex defaults  to 0 (i.e. the whole array is searched). If it is greater than or equal  to the length of the array, -1 is returned, i.e. the array will not be  searched. If it is negative, it is used as the offset from the end of  the array to compute fromIndex. If the computed index is less than 0, the whole array will be searched.  When the indexOf method is called with one or two arguments, the following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).If len is 0, return -1.Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)If n ≥ len, return -1.If n ≥ 0, thenIf n is -0, let k be +0; else let k be n.Else n &lt; 0,Let k be len + n.If k &lt; 0, let k be 0.Repeat, while k &lt; lenLet kPresent be ? HasProperty(O, ! ToString(k)).If kPresent is true, thenLet elementK be ? Get(O, ! ToString(k)).Let same be the result of performing Strict Equality Comparison searchElement</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.13">
	<buginformation>
		<summary>Array.prototype.join ( separator )</summary>
		<description>Note 1 The elements of the array are converted to Strings, and these Strings are then concatenated, separated by occurrences of the separator. If no separator is provided, a single comma is used as the separator.  The join method takes one argument, separator, and performs the following steps: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).If separator is undefined, let sep be the single-element String &amp;quot;,&amp;quot;.Else, let sep be ? ToString(separator).Let R be the empty String.Let k be 0.Repeat, while k &lt; lenIf k &gt; 0, let R be a String value produced by concatenating R and sep.Let element be ? Get(O, ! ToString(k)).If element is undefined or null, let next be the empty String; otherwise, let next be ? ToString(element).Set R to a String value produced by concatenating R and next.Increase k by 1.Return R.          Note 2 The join function is intentionally generic; it does not require that its this value be an Array object. Therefore, it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.14">
	<buginformation>
		<summary>Array.prototype.keys ( )</summary>
		<description>The following steps are taken: Let O be ? ToObject(this value).Return CreateArrayIterator(O, &amp;quot;key&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.15">
	<buginformation>
		<summary>Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] )</summary>
		<description>Note 1 lastIndexOf compares searchElement to the elements of the array in descending order using the Strict Equality Comparison algorithm, and if found at one or more indices, returns the largest such index; otherwise, -1 is returned. The optional second argument fromIndex defaults  to the array&apos;s length minus one (i.e. the whole array is searched). If  it is greater than or equal to the length of the array, the whole array  will be searched. If it is negative, it is used as the offset from the  end of the array to compute fromIndex. If the computed index is less than 0, -1 is returned.  When the lastIndexOf method is called with one or two arguments, the following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).If len is 0, return -1.If argument fromIndex was passed, let n be ? ToInteger(fromIndex); else let n be len-1.If n ≥ 0, thenIf n is -0, let k be +0; else let k be min(n, len - 1).Else n &lt; 0,Let k be len + n.Repeat, while k ≥ 0Let kPresent be ? HasProperty(O, ! ToString(k)).If kPresent is true, thenLet elementK be ? Get(O, ! ToString(k)).Let same be the result of performing Strict Equality Comparison searchElement</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.16">
	<buginformation>
		<summary>Array.prototype.map ( callbackfn [ , thisArg ] )</summary>
		<description>Note 1 callbackfn should be a function that accepts three arguments. map calls callbackfn once for each element in the array, in ascending order, and constructs a new Array from the results. callbackfn is called only for elements of the array which actually exist; it is not called for missing elements of the array. If a thisArg parameter is provided, it will be used as the this value for each invocation of callbackfn. If it is not provided, undefined is used instead. callbackfn is called with three arguments: the value of the element, the index of the element, and the object being traversed. map does not directly mutate the object on which it is called but the object may be mutated by the calls to callbackfn. The range of elements processed by map is set before the first call to callbackfn. Elements which are appended to the array after the call to map begins will not be visited by callbackfn. If existing elements of the array are changed, their value as passed to callbackfn will be the value at the time map visits them; elements that are deleted after the call to map begins and before being visited are not visited.  When the map method is called with one or two arguments, the following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).If IsCallable(callbackfn) is false, throw a TypeError exception.If thisArg was supplied, let T be thisArg; else let T be undefined.Let A be ? ArraySpeciesCreate(O, len).Let k be 0.Repeat, while k &lt; lenLet Pk be ! ToString(k).Let kPresent be ? HasProperty(O, Pk).If kPresent is true, thenLet kValue be ? Get(O, Pk).Let mappedValue be ? Call(callbackfn, T, « kValue, k, O »).Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue).Increase k by 1.Return A.          Note 2 The map function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.17">
	<buginformation>
		<summary>Array.prototype.pop ( )</summary>
		<description>Note 1 The last element of the array is removed from the array and returned.  When the pop method is called, the following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).If len is zero, thenPerform ? Set(O, &amp;quot;length&amp;quot;, 0, true).Return undefined.Else len &gt; 0,Let newLen be len-1.Let index be ! ToString(newLen).Let element be ? Get(O, index).Perform ? DeletePropertyOrThrow(O, index).Perform ? Set(O, &amp;quot;length&amp;quot;, newLen, true).Return element.          Note 2 The pop function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.18">
	<buginformation>
		<summary>Array.prototype.push ( ...items )</summary>
		<description>Note 1 The arguments are appended to the end of the array, in the  order in which they appear. The new length of the array is returned as  the result of the call.  When the push method is called with zero or more arguments, the following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).Let items be a List whose elements are, in left to right order, the arguments that were passed to this function invocation.Let argCount be the number of elements in items.If len + argCount &gt; 253-1, throw a TypeError exception.Repeat, while items is not emptyRemove the first element from items and let E be the value of the element.Perform ? Set(O, ! ToString(len), E, true).Let len be len+1.Perform ? Set(O, &amp;quot;length&amp;quot;, len, true).Return len.          The length property of the push method is 1. Note 2 The push function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.19">
	<buginformation>
		<summary>Array.prototype.reduce ( callbackfn [ , initialValue ] )</summary>
		<description>Note 1 callbackfn should be a function that takes four arguments. reduce calls the callback, as a function, once for each element after the first element present in the array, in ascending order. callbackfn is called with four arguments: the previousValue (value from the previous call to callbackfn), the currentValue (value of the current element), the currentIndex, and the object being traversed. The first time that callback is called, the previousValue and currentValue can be one of two values. If an initialValue was provided in the call to reduce, then previousValue will be equal to initialValue and currentValue will be equal to the first value in the array. If no initialValue was provided, then previousValue will be equal to the first value in the array and currentValue will be equal to the second. It is a TypeError if the array contains no elements and initialValue is not provided. reduce does not directly mutate the object on which it is called but the object may be mutated by the calls to callbackfn. The range of elements processed by reduce is set before the first call to callbackfn. Elements that are appended to the array after the call to reduce begins will not be visited by callbackfn. If existing elements of the array are changed, their value as passed to callbackfn will be the value at the time reduce visits them; elements that are deleted after the call to reduce begins and before being visited are not visited.  When the reduce method is called with one or two arguments, the following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).If IsCallable(callbackfn) is false, throw a TypeError exception.If len is 0 and initialValue is not present, throw a TypeError exception.Let k be 0.If initialValue is present, thenSet accumulator to initialValue.Else initialValue is not present,Let kPresent be false.Repeat, while kPresent is false and k &lt; lenLet Pk be ! ToString(k).Let kPresent be ? HasProperty(O, Pk).If kPresent is true, thenLet accumulator be ? Get(O, Pk).Increase k by 1.If kPresent is false, throw a TypeError exception.Repeat, while k &lt; lenLet Pk be ! ToString(k).Let kPresent be ? HasProperty(O, Pk).If kPresent is true, thenLet kValue be ? Get(O, Pk).Let accumulator be ? Call(callbackfn, undefined, « accumulator, kValue, k, O »).Increase k by 1.Return accumulator.          Note 2 The reduce function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.20">
	<buginformation>
		<summary>Array.prototype.reduceRight ( callbackfn [ , initialValue ] )</summary>
		<description>Note 1 callbackfn should be a function that takes four arguments. reduceRight calls the callback, as a function, once for each element after the first element present in the array, in descending order. callbackfn is called with four arguments: the previousValue (value from the previous call to callbackfn), the currentValue (value of the current element), the currentIndex, and the object being traversed. The first time the function is called, the previousValue and currentValue can be one of two values. If an initialValue was provided in the call to reduceRight, then previousValue will be equal to initialValue and currentValue will be equal to the last value in the array. If no initialValue was provided, then previousValue will be equal to the last value in the array and currentValue will be equal to the second-to-last value. It is a TypeError if the array contains no elements and initialValue is not provided. reduceRight does not directly mutate the object on which it is called but the object may be mutated by the calls to callbackfn. The range of elements processed by reduceRight is set before the first call to callbackfn. Elements that are appended to the array after the call to reduceRight begins will not be visited by callbackfn. If existing elements of the array are changed by callbackfn, their value as passed to callbackfn will be the value at the time reduceRight visits them; elements that are deleted after the call to reduceRight begins and before being visited are not visited.  When the reduceRight method is called with one or two arguments, the following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).If IsCallable(callbackfn) is false, throw a TypeError exception.If len is 0 and initialValue is not present, throw a TypeError exception.Let k be len-1.If initialValue is present, thenSet accumulator to initialValue.Else initialValue is not present,Let kPresent be false.Repeat, while kPresent is false and k ≥ 0Let Pk be ! ToString(k).Let kPresent be ? HasProperty(O, Pk).If kPresent is true, thenLet accumulator be ? Get(O, Pk).Decrease k by 1.If kPresent is false, throw a TypeError exception.Repeat, while k ≥ 0Let Pk be ! ToString(k).Let kPresent be ? HasProperty(O, Pk).If kPresent is true, thenLet kValue be ? Get(O, Pk).Let accumulator be ? Call(callbackfn, undefined, « accumulator, kValue, k, O »).Decrease k by 1.Return accumulator.          Note 2 The reduceRight function is intentionally  generic; it does not require that its this value be an Array object.  Therefore it can be transferred to other kinds of objects for use as a  method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.21">
	<buginformation>
		<summary>Array.prototype.reverse ( )</summary>
		<description>Note 1 The elements of the array are rearranged so as to reverse their order. The object is returned as the result of the call.  When the reverse method is called, the following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).Let middle be floor(len/2).Let lower be 0.Repeat, while lower ≠ middleLet upper be len - lower - 1.Let upperP be ! ToString(upper).Let lowerP be ! ToString(lower).Let lowerExists be ? HasProperty(O, lowerP).If lowerExists is true, thenLet lowerValue be ? Get(O, lowerP).Let upperExists be ? HasProperty(O, upperP).If upperExists is true, thenLet upperValue be ? Get(O, upperP).If lowerExists is true and upperExists is true, thenPerform ? Set(O, lowerP, upperValue, true).Perform ? Set(O, upperP, lowerValue, true).Else if lowerExists is false and upperExists is true, thenPerform ? Set(O, lowerP, upperValue, true).Perform ? DeletePropertyOrThrow(O, upperP).Else if lowerExists is true and upperExists is false, thenPerform ? DeletePropertyOrThrow(O, lowerP).Perform ? Set(O, upperP, lowerValue, true).Else both lowerExists and upperExists are false,No action is required.Increase lower by 1.Return O.          Note 2 The reverse function is intentionally generic; it does not require that its this value be an Array object. Therefore, it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.22">
	<buginformation>
		<summary>Array.prototype.shift ( )</summary>
		<description>Note 1 The first element of the array is removed from the array and returned.  When the shift method is called, the following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).If len is zero, thenPerform ? Set(O, &amp;quot;length&amp;quot;, 0, true).Return undefined.Let first be ? Get(O, &amp;quot;0&amp;quot;).Let k be 1.Repeat, while k &lt; lenLet from be ! ToString(k).Let to be ! ToString(k-1).Let fromPresent be ? HasProperty(O, from).If fromPresent is true, thenLet fromVal be ? Get(O, from).Perform ? Set(O, to, fromVal, true).Else fromPresent is false,Perform ? DeletePropertyOrThrow(O, to).Increase k by 1.Perform ? DeletePropertyOrThrow(O, ! ToString(len-1)).Perform ? Set(O, &amp;quot;length&amp;quot;, len-1, true).Return first.          Note 2 The shift function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.23">
	<buginformation>
		<summary>Array.prototype.slice ( start, end )</summary>
		<description>Note 1 The slice method takes two arguments, start and end, and returns an array containing the elements of the array from element start up to, but not including, element end (or through the end of the array if end is undefined). If start is negative, it is treated as  length+start where length is the length of the array. If end is negative, it is treated as  length+end where length is the length of the array.  The following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).Let relativeStart be ? ToInteger(start).If relativeStart &lt; 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).If relativeEnd &lt; 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).Let count be max(final - k, 0).Let A be ? ArraySpeciesCreate(O, count).Let n be 0.Repeat, while k &lt; finalLet Pk be ! ToString(k).Let kPresent be ? HasProperty(O, Pk).If kPresent is true, thenLet kValue be ? Get(O, Pk).Perform ? CreateDataPropertyOrThrow(A, ! ToString(n), kValue).Increase k by 1.Increase n by 1.Perform ? Set(A, &amp;quot;length&amp;quot;, n, true).Return A.          Note 2 The explicit setting of the length property of  the result Array in step 11 was necessary in previous editions of  ECMAScript to ensure that its length was correct in situations where the  trailing elements of the result Array were not present. Setting length  became unnecessary starting in ES2015 when the result Array was  initialized to its proper length rather than an empty Array but is  carried forward to preserve backward compatibility.  Note 3 The slice function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.24">
	<buginformation>
		<summary>Array.prototype.some ( callbackfn [ , thisArg ] )</summary>
		<description>Note 1 callbackfn should be a function that accepts three arguments and returns a value that is coercible to the Boolean value true or false. some calls callbackfn once for each element present in the array, in ascending order, until it finds one where callbackfn returns true. If such an element is found, some immediately returns true. Otherwise, some returns false. callbackfn is called only for elements of the array which actually exist; it is not called for missing elements of the array. If a thisArg parameter is provided, it will be used as the this value for each invocation of callbackfn. If it is not provided, undefined is used instead. callbackfn is called with three arguments: the value of the element, the index of the element, and the object being traversed. some does not directly mutate the object on which it is called but the object may be mutated by the calls to callbackfn. The range of elements processed by some is set before the first call to callbackfn. Elements that are appended to the array after the call to some begins will not be visited by callbackfn. If existing elements of the array are changed, their value as passed to callbackfn will be the value at the time that some visits them; elements that are deleted after the call to some begins and before being visited are not visited. some acts like the &amp;quot;exists&amp;quot; quantifier in mathematics. In particular, for an empty array, it returns false.  When the some method is called with one or two arguments, the following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).If IsCallable(callbackfn) is false, throw a TypeError exception.If thisArg was supplied, let T be thisArg; else let T be undefined.Let k be 0.Repeat, while k &lt; lenLet Pk be ! ToString(k).Let kPresent be ? HasProperty(O, Pk).If kPresent is true, thenLet kValue be ? Get(O, Pk).Let testResult be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).If testResult is true, return true.Increase k by 1.Return false.          Note 2 The some function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.25.1">
	<buginformation>
		<summary>Runtime Semantics: SortCompare( x, y )</summary>
		<description>The SortCompare abstract operation is called with two arguments x and y. It also has access to the comparefn argument passed to the current invocation of the sort method. The following steps are taken: If x and y are both undefined, return +0.If x is undefined, return 1.If y is undefined, return -1.If the argument comparefn is not undefined, thenLet v be ? ToNumber(? Call(comparefn, undefined, « x, y »)).If v is NaN, return +0.Return v.Let xString be ? ToString(x).Let yString be ? ToString(y).Let xSmaller be the result of performing Abstract Relational Comparison xString &lt; yString.If xSmaller is true, return -1.Let ySmaller be the result of performing Abstract Relational Comparison yString &lt; xString.If ySmaller is true, return 1.Return +0.            Note 1 Because non-existent property values always compare greater than undefined property values, and undefined always compares greater than any other value, undefined property values always sort to the end of the result, followed by non-existent property values.  Note 2 Method calls performed by the ToString abstract operations in steps 5 and 7 have the potential to cause SortCompare to not behave as a consistent comparison function.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.26">
	<buginformation>
		<summary>Array.prototype.splice ( start, deleteCount, ...items )</summary>
		<description>Note 1 When the splice method is called with two or more arguments start, deleteCount and zero or more items, the deleteCount elements of the array starting at integer index start are replaced by the arguments items. An Array object containing the deleted elements (if any) is returned.  The following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).Let relativeStart be ? ToInteger(start).If relativeStart &lt; 0, let actualStart be max((len + relativeStart), 0); else let actualStart be min(relativeStart, len).If the number of actual arguments is 0, thenLet insertCount be 0.Let actualDeleteCount be 0.Else if the number of actual arguments is 1, thenLet insertCount be 0.Let actualDeleteCount be len - actualStart.Else,Let insertCount be the number of actual arguments minus 2.Let dc be ? ToInteger(deleteCount).Let actualDeleteCount be min(max(dc, 0), len - actualStart).If len+insertCount-actualDeleteCount &gt; 253-1, throw a TypeError exception.Let A be ? ArraySpeciesCreate(O, actualDeleteCount).Let k be 0.Repeat, while k &lt; actualDeleteCountLet from be ! ToString(actualStart+k).Let fromPresent be ? HasProperty(O, from).If fromPresent is true, thenLet fromValue be ? Get(O, from).Perform ? CreateDataPropertyOrThrow(A, ! ToString(k), fromValue).Increment k by 1.Perform ? Set(A, &amp;quot;length&amp;quot;, actualDeleteCount, true).Let items be a List  whose elements are, in left to right order, the portion of the actual  argument list starting with the third argument. The list is empty if  fewer than three arguments were passed.Let itemCount be the number of elements in items.If itemCount &lt; actualDeleteCount, thenLet k be actualStart.Repeat, while k &lt; (len - actualDeleteCount)Let from be ! ToString(k+actualDeleteCount).Let to be ! ToString(k+itemCount).Let fromPresent be ? HasProperty(O, from).If fromPresent is true, thenLet fromValue be ? Get(O, from).Perform ? Set(O, to, fromValue, true).Else fromPresent is false,Perform ? DeletePropertyOrThrow(O, to).Increase k by 1.Let k be len.Repeat, while k &gt; (len - actualDeleteCount + itemCount)Perform ? DeletePropertyOrThrow(O, ! ToString(k-1)).Decrease k by 1.Else if itemCount &gt; actualDeleteCount, thenLet k be (len - actualDeleteCount).Repeat, while k &gt; actualStartLet from be ! ToString(k + actualDeleteCount - 1).Let to be ! ToString(k + itemCount - 1).Let fromPresent be ? HasProperty(O, from).If fromPresent is true, thenLet fromValue be ? Get(O, from).Perform ? Set(O, to, fromValue, true).Else fromPresent is false,Perform ? DeletePropertyOrThrow(O, to).Decrease k by 1.Let k be actualStart.Repeat, while items is not emptyRemove the first element from items and let E be the value of that element.Perform ? Set(O, ! ToString(k), E, true).Increase k by 1.Perform ? Set(O, &amp;quot;length&amp;quot;, len - actualDeleteCount + itemCount, true).Return A.          Note 2 The explicit setting of the length property of  the result Array in step 19 was necessary in previous editions of  ECMAScript to ensure that its length was correct in situations where the  trailing elements of the result Array were not present. Setting length  became unnecessary starting in ES2015 when the result Array was  initialized to its proper length rather than an empty Array but is  carried forward to preserve backward compatibility.  Note 3 The splice function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.27">
	<buginformation>
		<summary>Array.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )</summary>
		<description>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the Array.prototype.toLocaleString  method as specified in the ECMA-402 specification. If an ECMAScript  implementation does not include the ECMA-402 API the following  specification of the toLocaleString method is used. Note 1 The first edition of ECMA-402 did not include a replacement specification for the Array.prototype.toLocaleString method.  The meanings of the optional parameters to this method are  defined in the ECMA-402 specification; implementations that do not  include ECMA-402 support must not use those parameter positions for  anything else. The following steps are taken: Let array be ? ToObject(this value).Let len be ? ToLength(? Get(array, &amp;quot;length&amp;quot;)).Let separator  be the String value for the list-separator String appropriate for the  host environment&apos;s current locale (this is derived in an  implementation-defined way).Let R be the empty String.Let k be 0.Repeat, while k &lt; lenIf k &gt; 0, thenSet R to a String value produced by concatenating R and separator.Let nextElement be ? Get(array, ! ToString(k)).If nextElement is not undefined or null, thenLet S be ? ToString(? Invoke(nextElement, &amp;quot;toLocaleString&amp;quot;)).Set R to a String value produced by concatenating R and S.Increase k by 1.Return R.          Note 2 The elements of the array are converted to Strings using their toLocaleString  methods, and these Strings are then concatenated, separated by  occurrences of a separator String that has been derived in an  implementation-defined locale-specific way. The result of calling this  function is intended to be analogous to the result of toString, except that the result of this function is intended to be locale-specific.  Note 3 The toLocaleString function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.28">
	<buginformation>
		<summary>Array.prototype.toString ( )</summary>
		<description>When the toString method is called, the following steps are taken: Let array be ? ToObject(this value).Let func be ? Get(array, &amp;quot;join&amp;quot;).If IsCallable(func) is false, let func be the intrinsic function %ObjProto_toString%.Return ? Call(func, array).          Note The toString function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.29">
	<buginformation>
		<summary>Array.prototype.unshift ( ...items )</summary>
		<description>Note 1 The arguments are prepended to the start of the array, such  that their order within the array is the same as the order in which  they appear in the argument list.  When the unshift method is called with zero or more arguments item1, item2, etc., the following steps are taken: Let O be ? ToObject(this value).Let len be ? ToLength(? Get(O, &amp;quot;length&amp;quot;)).Let argCount be the number of actual arguments.If argCount &gt; 0, thenIf len+argCount &gt; 253-1, throw a TypeError exception.Let k be len.Repeat, while k &gt; 0,Let from be ! ToString(k-1).Let to be ! ToString(k+argCount-1).Let fromPresent be ? HasProperty(O, from).If fromPresent is true, thenLet fromValue be ? Get(O, from).Perform ? Set(O, to, fromValue, true).Else fromPresent is false,Perform ? DeletePropertyOrThrow(O, to).Decrease k by 1.Let j be 0.Let items be a List whose elements are, in left to right order, the arguments that were passed to this function invocation.Repeat, while items is not emptyRemove the first element from items and let E be the value of that element.Perform ? Set(O, ! ToString(j), E, true).Increase j by 1.Perform ? Set(O, &amp;quot;length&amp;quot;, len+argCount, true).Return len+argCount.          The length property of the unshift method is 1. Note 2 The unshift function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.30">
	<buginformation>
		<summary>Array.prototype.values ( )</summary>
		<description>The following steps are taken: Let O be ? ToObject(this value).Return CreateArrayIterator(O, &amp;quot;value&amp;quot;).          This function is the  %ArrayProto_values% intrinsic object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.31">
	<buginformation>
		<summary>Array.prototype [ @@iterator ] ( )</summary>
		<description>The initial value of the @@iterator property is the same function object as the initial value of the Array.prototype.values property.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.3.32">
	<buginformation>
		<summary>Array.prototype [ @@unscopables ]</summary>
		<description>The initial value of the @@unscopables data property is an object created by the following steps: Let unscopableList be ObjectCreate(null).Perform CreateDataProperty(unscopableList, &amp;quot;copyWithin&amp;quot;, true).Perform CreateDataProperty(unscopableList, &amp;quot;entries&amp;quot;, true).Perform CreateDataProperty(unscopableList, &amp;quot;fill&amp;quot;, true).Perform CreateDataProperty(unscopableList, &amp;quot;find&amp;quot;, true).Perform CreateDataProperty(unscopableList, &amp;quot;findIndex&amp;quot;, true).Perform CreateDataProperty(unscopableList, &amp;quot;includes&amp;quot;, true).Perform CreateDataProperty(unscopableList, &amp;quot;keys&amp;quot;, true).Perform CreateDataProperty(unscopableList, &amp;quot;values&amp;quot;, true).Assert: Each of the above calls will return true.Return unscopableList.          This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. Note The own property names of this object are property names that were not included as standard properties of Array.prototype prior to the ECMAScript 2015 specification. These names are ignored for with  statement binding purposes in order to preserve the behaviour of  existing code that might use one of these names as a binding in an outer  scope that is shadowed by a with statement whose binding object is an Array object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.4.1">
	<buginformation>
		<summary>length</summary>
		<description>The length property of an Array instance is a  data property whose value is always numerically greater than the name of  every configurable own property whose name is an array index. The length property initially has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }. Note Reducing the value of the length property has  the side-effect of deleting own array elements whose array index is  between the old and new length values. However, non-configurable  properties can not be deleted. Attempting to set the length property of  an Array object to a value that is numerically less than or equal to the  largest numeric own property name of an existing non-configurable array  indexed property of the array will result in the length being set to a  numeric value that is one greater than that non-configurable numeric own  property name. See  9.4.2.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.5.1">
	<buginformation>
		<summary>CreateArrayIterator ( array, kind )</summary>
		<description>Several methods of Array objects return Iterator objects. The abstract operation CreateArrayIterator with arguments array and kind is used to create such iterator objects. It performs the following steps: Assert: Type(array) is Object.Let iterator be ObjectCreate(%ArrayIteratorPrototype%, « [[IteratedObject]], [[ArrayIteratorNextIndex]], [[ArrayIterationKind]] »).Set iterator.[[IteratedObject]] to array.Set iterator.[[ArrayIteratorNextIndex]] to 0.Set iterator.[[ArrayIterationKind]] to kind.Return iterator.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.5.2.1">
	<buginformation>
		<summary>%ArrayIteratorPrototype%.next( )</summary>
		<description>Let O be the this value.If Type(O) is not Object, throw a TypeError exception.If O does not have all of the internal slots of an Array Iterator Instance (22.1.5.3), throw a TypeError exception.Let a be O.[[IteratedObject]].If a is undefined, return CreateIterResultObject(undefined, true).Let index be O.[[ArrayIteratorNextIndex]].Let itemKind be O.[[ArrayIterationKind]].If a has a [[TypedArrayName]] internal slot, thenIf IsDetachedBuffer(a.[[ViewedArrayBuffer]]) is true, throw a TypeError exception.Let len be a.[[ArrayLength]].Else,Let len be ? ToLength(? Get(a, &amp;quot;length&amp;quot;)).If index ≥ len, thenSet O.[[IteratedObject]] to undefined.Return CreateIterResultObject(undefined, true).Set O.[[ArrayIteratorNextIndex]] to index+1.If itemKind is &amp;quot;key&amp;quot;, return CreateIterResultObject(index, false).Let elementKey be ! ToString(index).Let elementValue be ? Get(a, elementKey).If itemKind is &amp;quot;value&amp;quot;, let result be elementValue.Else,Assert: itemKind is &amp;quot;key+value&amp;quot;.Let result be CreateArrayFromList(« index, elementValue »).Return CreateIterResultObject(result, false).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.5.2.2">
	<buginformation>
		<summary>%ArrayIteratorPrototype% [ @@toStringTag ]</summary>
		<description>The initial value of the @@toStringTag property is the String value &amp;quot;Array Iterator&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.1.5.3">
	<buginformation>
		<summary>Properties of Array Iterator Instances</summary>
		<description>Array Iterator instances are ordinary objects that inherit properties from the %ArrayIteratorPrototype% intrinsic object. Array Iterator instances are initially created with the internal slots listed in  Table 49. Table 49: Internal Slots of Array Iterator Instances                     Internal Slot                                                Description                                                  [[IteratedObject]]                                                The object whose array elements are being iterated.                                                  [[ArrayIteratorNextIndex]]                                                The integer index of the next integer index to be examined by this iteration.                                                  [[ArrayIterationKind]]                                                A String value that identifies what is returned for each element of the iteration. The possible values are: &amp;quot;key&amp;quot;, &amp;quot;value&amp;quot;, &amp;quot;key+value&amp;quot;.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.1.1">
	<buginformation>
		<summary>%TypedArray% ( )</summary>
		<description>The %TypedArray% constructor performs the following steps: Throw a TypeError exception.          The length property of the %TypedArray% constructor function is 0.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.2.1.1">
	<buginformation>
		<summary>Runtime Semantics: IterableToList( items, method )</summary>
		<description>The abstract operation IterableToList performs the following steps: Let iterator be ? GetIterator(items, method).Let values be a new empty List.Let next be true.Repeat, while next is not falseSet next to ? IteratorStep(iterator).If next is not false, thenLet nextValue be ? IteratorValue(next).Append nextValue to the end of the List values.Return values.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.2.2">
	<buginformation>
		<summary>%TypedArray%.of ( ...items )</summary>
		<description>When the of method is called with any number of arguments, the following steps are taken: Let len be the actual number of arguments passed to this function.Let items be the List of arguments passed to this function.Let C be the this value.If IsConstructor(C) is false, throw a TypeError exception.Let newObj be ? TypedArrayCreate(C, « len »).Let k be 0.Repeat, while k &lt; lenLet kValue be items[k].Let Pk be ! ToString(k).Perform ? Set(newObj, Pk, kValue, true).Increase k by 1.Return newObj.          Note The items argument is assumed to be a well-formed rest argument value.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.2.3">
	<buginformation>
		<summary>%TypedArray%.prototype</summary>
		<description>The initial value of %TypedArray%.prototype is the %TypedArrayPrototype% intrinsic object. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.2.4">
	<buginformation>
		<summary>get %TypedArray% [ @@species ]</summary>
		<description>%TypedArray%[@@species] is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Return the this value.          The value of the name property of this function is &amp;quot;get [Symbol.species]&amp;quot;. Note %TypedArrayPrototype% methods normally use their this  object&apos;s constructor to create a derived object. However, a subclass  constructor may over-ride that default behaviour by redefining its  @@species property.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.1">
	<buginformation>
		<summary>get %TypedArray%.prototype.buffer</summary>
		<description>%TypedArray%.prototype.buffer is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let O be the this value.If Type(O) is not Object, throw a TypeError exception.If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.Assert: O has a [[ViewedArrayBuffer]] internal slot.Let buffer be O.[[ViewedArrayBuffer]].Return buffer.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.2">
	<buginformation>
		<summary>get %TypedArray%.prototype.byteLength</summary>
		<description>%TypedArray%.prototype.byteLength is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let O be the this value.If Type(O) is not Object, throw a TypeError exception.If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.Assert: O has a [[ViewedArrayBuffer]] internal slot.Let buffer be O.[[ViewedArrayBuffer]].If IsDetachedBuffer(buffer) is true, return 0.Let size be O.[[ByteLength]].Return size.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.3">
	<buginformation>
		<summary>get %TypedArray%.prototype.byteOffset</summary>
		<description>%TypedArray%.prototype.byteOffset is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let O be the this value.If Type(O) is not Object, throw a TypeError exception.If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.Assert: O has a [[ViewedArrayBuffer]] internal slot.Let buffer be O.[[ViewedArrayBuffer]].If IsDetachedBuffer(buffer) is true, return 0.Let offset be O.[[ByteOffset]].Return offset.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.4">
	<buginformation>
		<summary>%TypedArray%.prototype.constructor</summary>
		<description>The initial value of %TypedArray%.prototype.constructor is the %TypedArray% intrinsic object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.5.1">
	<buginformation>
		<summary>Runtime Semantics: ValidateTypedArray ( O )</summary>
		<description>When called with argument O, the following steps are taken: If Type(O) is not Object, throw a TypeError exception.If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.Assert: O has a [[ViewedArrayBuffer]] internal slot.Let buffer be O.[[ViewedArrayBuffer]].If IsDetachedBuffer(buffer) is true, throw a TypeError exception.Return buffer.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.6">
	<buginformation>
		<summary>%TypedArray%.prototype.entries ( )</summary>
		<description>The following steps are taken: Let O be the this value.Perform ? ValidateTypedArray(O).Return CreateArrayIterator(O, &amp;quot;key+value&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.7">
	<buginformation>
		<summary>%TypedArray%.prototype.every ( callbackfn [ , thisArg ] )</summary>
		<description>%TypedArray%.prototype.every is a distinct function that implements the same algorithm as Array.prototype.every as defined in  22.1.3.5 except that the this object&apos;s [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of &amp;quot;length&amp;quot;. The implementation of the algorithm may be optimized with the knowledge that the this  value is an object that has a fixed length and whose integer indexed  properties are not sparse. However, such optimization must not introduce  any observable changes in the specified behaviour of the algorithm and  must take into account the possibility that calls to callbackfn may cause the this value to become detached. This function is not generic. ValidateTypedArray is applied to the this value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.8">
	<buginformation>
		<summary>%TypedArray%.prototype.fill ( value [ , start [ , end ] ] )</summary>
		<description>%TypedArray%.prototype.fill is a distinct function that implements the same algorithm as Array.prototype.fill as defined in  22.1.3.6 except that the this object&apos;s [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of &amp;quot;length&amp;quot;. The implementation of the algorithm may be optimized with the knowledge that the this  value is an object that has a fixed length and whose integer indexed  properties are not sparse. However, such optimization must not introduce  any observable changes in the specified behaviour of the algorithm. This function is not generic. ValidateTypedArray is applied to the this value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.9">
	<buginformation>
		<summary>%TypedArray%.prototype.filter ( callbackfn [ , thisArg ] )</summary>
		<description>The interpretation and use of the arguments of %TypedArray%.prototype.filter are the same as for Array.prototype.filter as defined in  22.1.3.7. When the filter method is called with one or two arguments, the following steps are taken: Let O be the this value.Perform ? ValidateTypedArray(O).Let len be O.[[ArrayLength]].If IsCallable(callbackfn) is false, throw a TypeError exception.If thisArg was supplied, let T be thisArg; else let T be undefined.Let kept be a new empty List.Let k be 0.Let captured be 0.Repeat, while k &lt; lenLet Pk be ! ToString(k).Let kValue be ? Get(O, Pk).Let selected be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).If selected is true, thenAppend kValue to the end of kept.Increase captured by 1.Increase k by 1.Let A be ? TypedArraySpeciesCreate(O, « captured »).Let n be 0.For each element e of kept, doPerform ! Set(A, ! ToString(n), e, true).Increment n by 1.Return A.          This function is not generic. The this value must be an object with a [[TypedArrayName]] internal slot.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.10">
	<buginformation>
		<summary>%TypedArray%.prototype.find ( predicate [ , thisArg ] )</summary>
		<description>%TypedArray%.prototype.find is a distinct function that implements the same algorithm as Array.prototype.find as defined in  22.1.3.8 except that the this object&apos;s [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of &amp;quot;length&amp;quot;. The implementation of the algorithm may be optimized with the knowledge that the this  value is an object that has a fixed length and whose integer indexed  properties are not sparse. However, such optimization must not introduce  any observable changes in the specified behaviour of the algorithm and  must take into account the possibility that calls to predicate may cause the this value to become detached. This function is not generic. ValidateTypedArray is applied to the this value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.11">
	<buginformation>
		<summary>%TypedArray%.prototype.findIndex ( predicate [ , thisArg ] )</summary>
		<description>%TypedArray%.prototype.findIndex is a distinct function that implements the same algorithm as Array.prototype.findIndex as defined in  22.1.3.9 except that the this object&apos;s [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of &amp;quot;length&amp;quot;. The implementation of the algorithm may be optimized with the knowledge that the this  value is an object that has a fixed length and whose integer indexed  properties are not sparse. However, such optimization must not introduce  any observable changes in the specified behaviour of the algorithm and  must take into account the possibility that calls to predicate may cause the this value to become detached. This function is not generic. ValidateTypedArray is applied to the this value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.12">
	<buginformation>
		<summary>%TypedArray%.prototype.forEach ( callbackfn [ , thisArg ] )</summary>
		<description>%TypedArray%.prototype.forEach is a distinct function that implements the same algorithm as Array.prototype.forEach as defined in  22.1.3.10 except that the this object&apos;s [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of &amp;quot;length&amp;quot;. The implementation of the algorithm may be optimized with the knowledge that the this  value is an object that has a fixed length and whose integer indexed  properties are not sparse. However, such optimization must not introduce  any observable changes in the specified behaviour of the algorithm and  must take into account the possibility that calls to callbackfn may cause the this value to become detached. This function is not generic. ValidateTypedArray is applied to the this value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.13">
	<buginformation>
		<summary>%TypedArray%.prototype.includes ( searchElement [ , fromIndex ] )</summary>
		<description>%TypedArray%.prototype.includes is a distinct function that implements the same algorithm as Array.prototype.includes as defined in  22.1.3.11 except that the this object&apos;s [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of &amp;quot;length&amp;quot;. The implementation of the algorithm may be optimized with the knowledge that the this  value is an object that has a fixed length and whose integer indexed  properties are not sparse. However, such optimization must not introduce  any observable changes in the specified behaviour of the algorithm. This function is not generic. ValidateTypedArray is applied to the this value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.14">
	<buginformation>
		<summary>%TypedArray%.prototype.indexOf ( searchElement [ , fromIndex ] )</summary>
		<description>%TypedArray%.prototype.indexOf is a distinct function that implements the same algorithm as Array.prototype.indexOf as defined in  22.1.3.12 except that the this object&apos;s [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of &amp;quot;length&amp;quot;. The implementation of the algorithm may be optimized with the knowledge that the this  value is an object that has a fixed length and whose integer indexed  properties are not sparse. However, such optimization must not introduce  any observable changes in the specified behaviour of the algorithm. This function is not generic. ValidateTypedArray is applied to the this value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.15">
	<buginformation>
		<summary>%TypedArray%.prototype.join ( separator )</summary>
		<description>%TypedArray%.prototype.join is a distinct function that implements the same algorithm as Array.prototype.join as defined in  22.1.3.13 except that the this object&apos;s [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of &amp;quot;length&amp;quot;. The implementation of the algorithm may be optimized with the knowledge that the this  value is an object that has a fixed length and whose integer indexed  properties are not sparse. However, such optimization must not introduce  any observable changes in the specified behaviour of the algorithm. This function is not generic. ValidateTypedArray is applied to the this value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.16">
	<buginformation>
		<summary>%TypedArray%.prototype.keys ( )</summary>
		<description>The following steps are taken: Let O be the this value.Perform ? ValidateTypedArray(O).Return CreateArrayIterator(O, &amp;quot;key&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.17">
	<buginformation>
		<summary>%TypedArray%.prototype.lastIndexOf ( searchElement [ , fromIndex ] )</summary>
		<description>%TypedArray%.prototype.lastIndexOf is a distinct function that implements the same algorithm as Array.prototype.lastIndexOf as defined in  22.1.3.15 except that the this object&apos;s [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of &amp;quot;length&amp;quot;. The implementation of the algorithm may be optimized with the knowledge that the this  value is an object that has a fixed length and whose integer indexed  properties are not sparse. However, such optimization must not introduce  any observable changes in the specified behaviour of the algorithm. This function is not generic. ValidateTypedArray is applied to the this value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.18">
	<buginformation>
		<summary>get %TypedArray%.prototype.length</summary>
		<description>%TypedArray%.prototype.length is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let O be the this value.If Type(O) is not Object, throw a TypeError exception.If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.Assert: O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.Let buffer be O.[[ViewedArrayBuffer]].If IsDetachedBuffer(buffer) is true, return 0.Let length be O.[[ArrayLength]].Return length.          This function is not generic. The this value must be an object with a [[TypedArrayName]] internal slot.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.19">
	<buginformation>
		<summary>%TypedArray%.prototype.map ( callbackfn [ , thisArg ] )</summary>
		<description>The interpretation and use of the arguments of %TypedArray%.prototype.map are the same as for Array.prototype.map as defined in  22.1.3.16. When the map method is called with one or two arguments, the following steps are taken: Let O be the this value.Perform ? ValidateTypedArray(O).Let len be O.[[ArrayLength]].If IsCallable(callbackfn) is false, throw a TypeError exception.If thisArg was supplied, let T be thisArg; else let T be undefined.Let A be ? TypedArraySpeciesCreate(O, « len »).Let k be 0.Repeat, while k &lt; lenLet Pk be ! ToString(k).Let kValue be ? Get(O, Pk).Let mappedValue be ? Call(callbackfn, T, « kValue, k, O »).Perform ? Set(A, Pk, mappedValue, true).Increase k by 1.Return A.          This function is not generic. The this value must be an object with a [[TypedArrayName]] internal slot.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.20">
	<buginformation>
		<summary>%TypedArray%.prototype.reduce ( callbackfn [ , initialValue ] )</summary>
		<description>%TypedArray%.prototype.reduce is a distinct function that implements the same algorithm as Array.prototype.reduce as defined in  22.1.3.19 except that the this object&apos;s [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of &amp;quot;length&amp;quot;. The implementation of the algorithm may be optimized with the knowledge that the this  value is an object that has a fixed length and whose integer indexed  properties are not sparse. However, such optimization must not introduce  any observable changes in the specified behaviour of the algorithm and  must take into account the possibility that calls to callbackfn may cause the this value to become detached. This function is not generic. ValidateTypedArray is applied to the this value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.21">
	<buginformation>
		<summary>%TypedArray%.prototype.reduceRight ( callbackfn [ , initialValue ] )</summary>
		<description>%TypedArray%.prototype.reduceRight is a distinct function that implements the same algorithm as Array.prototype.reduceRight as defined in  22.1.3.20 except that the this object&apos;s [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of &amp;quot;length&amp;quot;. The implementation of the algorithm may be optimized with the knowledge that the this  value is an object that has a fixed length and whose integer indexed  properties are not sparse. However, such optimization must not introduce  any observable changes in the specified behaviour of the algorithm and  must take into account the possibility that calls to callbackfn may cause the this value to become detached. This function is not generic. ValidateTypedArray is applied to the this value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.22">
	<buginformation>
		<summary>%TypedArray%.prototype.reverse ( )</summary>
		<description>%TypedArray%.prototype.reverse is a distinct function that implements the same algorithm as Array.prototype.reverse as defined in  22.1.3.21 except that the this object&apos;s [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of &amp;quot;length&amp;quot;. The implementation of the algorithm may be optimized with the knowledge that the this  value is an object that has a fixed length and whose integer indexed  properties are not sparse. However, such optimization must not introduce  any observable changes in the specified behaviour of the algorithm. This function is not generic. ValidateTypedArray is applied to the this value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.23.1">
	<buginformation>
		<summary>%TypedArray%.prototype.set ( array [ , offset ] )</summary>
		<description>Sets multiple values in this TypedArray, reading the values from the object array. The optional offset value indicates the first element index in this TypedArray where values are written. If omitted, it is assumed to be 0. Assert: array is any ECMAScript language value other than an Object with a [[TypedArrayName]] internal slot. If it is such an Object, the definition in 22.2.3.23.2 applies.Let target be the this value.If Type(target) is not Object, throw a TypeError exception.If target does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.Assert: target has a [[ViewedArrayBuffer]] internal slot.Let targetOffset be ? ToInteger(offset).If targetOffset &lt; 0, throw a RangeError exception.Let targetBuffer be target.[[ViewedArrayBuffer]].If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.Let targetLength be target.[[ArrayLength]].Let targetName be the String value of target.[[TypedArrayName]].Let targetElementSize be the Number value of the Element Size value specified in Table 50 for targetName.Let targetType be the String value of the Element Type value in Table 50 for targetName.Let targetByteOffset be target.[[ByteOffset]].Let src be ? ToObject(array).Let srcLength be ? ToLength(? Get(src, &amp;quot;length&amp;quot;)).If srcLength + targetOffset &gt; targetLength, throw a RangeError exception.Let targetByteIndex be targetOffset × targetElementSize + targetByteOffset.Let k be 0.Let limit be targetByteIndex + targetElementSize × srcLength.Repeat, while targetByteIndex &lt; limitLet Pk be ! ToString(k).Let kNumber be ? ToNumber(? Get(src, Pk)).If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.Perform SetValueInBuffer(targetBuffer, targetByteIndex, targetType, kNumber, true, &amp;quot;Unordered&amp;quot;).Set k to k + 1.Set targetByteIndex to targetByteIndex + targetElementSize.Return undefined.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.23.2">
	<buginformation>
		<summary>%TypedArray%.prototype.set( typedArray [ , offset ] )</summary>
		<description>Sets multiple values in this TypedArray, reading the values from the typedArray argument object. The optional offset value indicates the first element index in this TypedArray where values are written. If omitted, it is assumed to be 0. Assert: typedArray has a [[TypedArrayName]] internal slot. If it does not, the definition in 22.2.3.23.1 applies.Let target be the this value.If Type(target) is not Object, throw a TypeError exception.If target does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.Assert: target has a [[ViewedArrayBuffer]] internal slot.Let targetOffset be ? ToInteger(offset).If targetOffset &lt; 0, throw a RangeError exception.Let targetBuffer be target.[[ViewedArrayBuffer]].If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.Let targetLength be target.[[ArrayLength]].Let srcBuffer be typedArray.[[ViewedArrayBuffer]].If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.Let targetName be the String value of target.[[TypedArrayName]].Let targetType be the String value of the Element Type value in Table 50 for targetName.Let targetElementSize be the Number value of the Element Size value specified in Table 50 for targetName.Let targetByteOffset be target.[[ByteOffset]].Let srcName be the String value of typedArray.[[TypedArrayName]].Let srcType be the String value of the Element Type value in Table 50 for srcName.Let srcElementSize be the Number value of the Element Size value specified in Table 50 for srcName.Let srcLength be typedArray.[[ArrayLength]].Let srcByteOffset be typedArray.[[ByteOffset]].If srcLength + targetOffset &gt; targetLength, throw a RangeError exception.If both IsSharedArrayBuffer(srcBuffer) and IsSharedArrayBuffer(targetBuffer) are true, thenIf srcBuffer.[[ArrayBufferData]] and targetBuffer.[[ArrayBufferData]] are the same Shared Data Block values, let same be true; else let same be false.Else, let same be SameValue(srcBuffer, targetBuffer).If same is true, thenLet srcByteLength be typedArray.[[ByteLength]].Let srcBuffer be ? CloneArrayBuffer(srcBuffer, srcByteOffset, srcByteLength, %ArrayBuffer%).NOTE: %ArrayBuffer% is used to clone srcBuffer because is it known to not have any observable side-effects.Let srcByteIndex be 0.Else, let srcByteIndex be srcByteOffset.Let targetByteIndex be targetOffset × targetElementSize + targetByteOffset.Let limit be targetByteIndex + targetElementSize × srcLength.If SameValue(srcType, targetType) is true, thenNOTE: If srcType and targetType are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.Repeat, while targetByteIndex &lt; limitLet value be GetValueFromBuffer(srcBuffer, srcByteIndex, &amp;quot;Uint8&amp;quot;, true, &amp;quot;Unordered&amp;quot;).Perform SetValueInBuffer(targetBuffer, targetByteIndex, &amp;quot;Uint8&amp;quot;, value, true, &amp;quot;Unordered&amp;quot;).Set srcByteIndex to srcByteIndex + 1.Set targetByteIndex to targetByteIndex + 1.Else,Repeat, while targetByteIndex &lt; limitLet value be GetValueFromBuffer(srcBuffer, srcByteIndex, srcType, true, &amp;quot;Unordered&amp;quot;).Perform SetValueInBuffer(targetBuffer, targetByteIndex, targetType, value, true, &amp;quot;Unordered&amp;quot;).Set srcByteIndex to srcByteIndex + srcElementSize.Set targetByteIndex to targetByteIndex + targetElementSize.Return undefined.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.24">
	<buginformation>
		<summary>%TypedArray%.prototype.slice ( start, end )</summary>
		<description>The interpretation and use of the arguments of %TypedArray%.prototype.slice are the same as for Array.prototype.slice as defined in  22.1.3.23. The following steps are taken: Let O be the this value.Perform ? ValidateTypedArray(O).Let len be O.[[ArrayLength]].Let relativeStart be ? ToInteger(start).If relativeStart &lt; 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).If relativeEnd &lt; 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).Let count be max(final - k, 0).Let A be ? TypedArraySpeciesCreate(O, « count »).Let srcName be the String value of O.[[TypedArrayName]].Let srcType be the String value of the Element Type value in Table 50 for srcName.Let targetName be the String value of A.[[TypedArrayName]].Let targetType be the String value of the Element Type value in Table 50 for targetName.If SameValue(srcType, targetType) is false, thenLet n be 0.Repeat, while k &lt; finalLet Pk be ! ToString(k).Let kValue be ? Get(O, Pk).Perform ! Set(A, ! ToString(n), kValue).Increase k by 1.Increase n by 1.Else if count &gt; 0, thenLet srcBuffer be O.[[ViewedArrayBuffer]].If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.Let targetBuffer be A.[[ViewedArrayBuffer]].Let elementSize be the Number value of the Element Size value specified in Table 50 for srcType.NOTE: If srcType and targetType are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.Let srcByteOffet be O.[[ByteOffset]].Let targetByteIndex be A.[[ByteOffset]].Let srcByteIndex be (k × elementSize) + srcByteOffet.Let limit be targetByteIndex + count × elementSize.Repeat, while targetByteIndex &lt; limitLet value be GetValueFromBuffer(srcBuffer, srcByteIndex, &amp;quot;Uint8&amp;quot;, true, &amp;quot;Unordered&amp;quot;).Perform SetValueInBuffer(targetBuffer, targetByteIndex, &amp;quot;Uint8&amp;quot;, value, true, &amp;quot;Unordered&amp;quot;).Increase srcByteIndex by 1.Increase targetByteIndex by 1.Return A.          This function is not generic. The this value must be an object with a [[TypedArrayName]] internal slot.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.25">
	<buginformation>
		<summary>%TypedArray%.prototype.some ( callbackfn [ , thisArg ] )</summary>
		<description>%TypedArray%.prototype.some is a distinct function that implements the same algorithm as Array.prototype.some as defined in  22.1.3.24 except that the this object&apos;s [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of &amp;quot;length&amp;quot;. The implementation of the algorithm may be optimized with the knowledge that the this  value is an object that has a fixed length and whose integer indexed  properties are not sparse. However, such optimization must not introduce  any observable changes in the specified behaviour of the algorithm and  must take into account the possibility that calls to callbackfn may cause the this value to become detached. This function is not generic. ValidateTypedArray is applied to the this value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.26">
	<buginformation>
		<summary>%TypedArray%.prototype.sort ( comparefn )</summary>
		<description>%TypedArray%.prototype.sort is a distinct function that, except as described below, implements the same requirements as those of Array.prototype.sort as defined in  22.1.3.25. The implementation of the %TypedArray%.prototype.sort specification may be optimized with the knowledge that the this  value is an object that has a fixed length and whose integer indexed  properties are not sparse. The only internal methods of the this object that the algorithm may call are [[Get]] and [[Set]]. This function is not generic. The this value must be an object with a [[TypedArrayName]] internal slot. Upon entry, the following steps are performed to initialize evaluation of the sort function. These steps are used instead of the entry steps in  22.1.3.25: Let obj be the this value.Let buffer be ? ValidateTypedArray(obj).Let len be obj.[[ArrayLength]].          The implementation-defined sort order condition for exotic objects is not applied by %TypedArray%.prototype.sort. The following version of SortCompare is used by %TypedArray%.prototype.sort. It performs a numeric comparison rather than the string comparison used in  22.1.3.25. SortCompare has access to the comparefn and buffer values of the current invocation of the sort method. When the TypedArray SortCompare abstract operation is called with two arguments x and y, the following steps are taken: Assert: Both Type(x) and Type(y) is Number.If the argument comparefn is not undefined, thenLet v be ? Call(comparefn, undefined, « x, y »).If IsDetachedBuffer(buffer) is true, throw a TypeError exception.If v is NaN, return +0.Return v.If x and y are both NaN, return +0.If x is NaN, return 1.If y is NaN, return -1.If x &lt; y, return -1.If x &gt; y, return 1.If x is -0 and y is +0, return -1.If x is +0 and y is -0, return 1.Return +0.          Note Because NaN always compares greater than any other value, NaN property values always sort to the end of the result when comparefn is not provided.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.27">
	<buginformation>
		<summary>%TypedArray%.prototype.subarray( begin, end )</summary>
		<description>Returns a new TypedArray object whose element type is the same as this TypedArray and whose ArrayBuffer is the same as the ArrayBuffer of this TypedArray, referencing the elements at begin, inclusive, up to end, exclusive. If either begin or end is negative, it refers to an index from the end of the array, as opposed to from the beginning. Let O be the this value.If Type(O) is not Object, throw a TypeError exception.If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.Assert: O has a [[ViewedArrayBuffer]] internal slot.Let buffer be O.[[ViewedArrayBuffer]].Let srcLength be O.[[ArrayLength]].Let relativeBegin be ? ToInteger(begin).If relativeBegin &lt; 0, let beginIndex be max((srcLength + relativeBegin), 0); else let beginIndex be min(relativeBegin, srcLength).If end is undefined, let relativeEnd be srcLength; else, let relativeEnd be ? ToInteger(end).If relativeEnd &lt; 0, let endIndex be max((srcLength + relativeEnd), 0); else let endIndex be min(relativeEnd, srcLength).Let newLength be max(endIndex - beginIndex, 0).Let constructorName be the String value of O.[[TypedArrayName]].Let elementSize be the Number value of the Element Size value specified in Table 50 for constructorName.Let srcByteOffset be O.[[ByteOffset]].Let beginByteOffset be srcByteOffset + beginIndex × elementSize.Let argumentsList be « buffer, beginByteOffset, newLength ».Return ? TypedArraySpeciesCreate(O, argumentsList).          This function is not generic. The this value must be an object with a [[TypedArrayName]] internal slot.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.28">
	<buginformation>
		<summary>%TypedArray%.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )</summary>
		<description>%TypedArray%.prototype.toLocaleString is a distinct function that implements the same algorithm as Array.prototype.toLocaleString as defined in  22.1.3.27 except that the this object&apos;s [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of &amp;quot;length&amp;quot;. The implementation of the algorithm may be optimized with the knowledge that the this  value is an object that has a fixed length and whose integer indexed  properties are not sparse. However, such optimization must not introduce  any observable changes in the specified behaviour of the algorithm. This function is not generic. ValidateTypedArray is applied to the this value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm. Note If the ECMAScript implementation includes the ECMA-402 Internationalization API this function is based upon the algorithm for Array.prototype.toLocaleString that is in the ECMA-402 specification.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.29">
	<buginformation>
		<summary>%TypedArray%.prototype.toString ( )</summary>
		<description>The initial value of the %TypedArray%.prototype.toString data property is the same built-in function object as the Array.prototype.toString method defined in  22.1.3.28.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.30">
	<buginformation>
		<summary>%TypedArray%.prototype.values ( )</summary>
		<description>The following steps are taken: Let O be the this value.Perform ? ValidateTypedArray(O).Return CreateArrayIterator(O, &amp;quot;value&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.31">
	<buginformation>
		<summary>%TypedArray%.prototype [ @@iterator ] ( )</summary>
		<description>The initial value of the @@iterator property is the same function object as the initial value of the %TypedArray%.prototype.values property.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.3.32">
	<buginformation>
		<summary>get %TypedArray%.prototype [ @@toStringTag ]</summary>
		<description>%TypedArray%.prototype[@@toStringTag] is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let O be the this value.If Type(O) is not Object, return undefined.If O does not have a [[TypedArrayName]] internal slot, return undefined.Let name be O.[[TypedArrayName]].Assert: name is a String value.Return name.          This property has the attributes { [[Enumerable]]: false, [[Configurable]]: true }. The initial value of the name property of this function is &amp;quot;get [Symbol.toStringTag]&amp;quot;.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.4.1">
	<buginformation>
		<summary>TypedArray ( )</summary>
		<description>This description applies only if the TypedArray function is called with no arguments. If NewTarget is undefined, throw a TypeError exception.Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.Return ? AllocateTypedArray(constructorName, NewTarget, &amp;quot;%TypedArrayPrototype%&amp;quot;, 0).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.4.2.1">
	<buginformation>
		<summary>Runtime Semantics: AllocateTypedArray ( constructorName, newTarget, defaultProto [ , length ] )</summary>
		<description>The abstract operation AllocateTypedArray with arguments constructorName, newTarget, defaultProto and optional argument length is used to validate and create an instance of a TypedArray constructor. constructorName is required to be the name of a TypedArray constructor in  Table 50. If the length  argument is passed, an ArrayBuffer of that length is also allocated and  associated with the new TypedArray instance. AllocateTypedArray  provides common semantics that is used by all of the TypedArray overloads. AllocateTypedArray performs the following steps: Let proto be ? GetPrototypeFromConstructor(newTarget, defaultProto).Let obj be IntegerIndexedObjectCreate(proto, « [[ViewedArrayBuffer]], [[TypedArrayName]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] »).Assert: obj.[[ViewedArrayBuffer]] is undefined.Set obj.[[TypedArrayName]] to constructorName.If length was not passed, thenSet obj.[[ByteLength]] to 0.Set obj.[[ByteOffset]] to 0.Set obj.[[ArrayLength]] to 0.Else,Perform ? AllocateTypedArrayBuffer(obj, length).Return obj.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.4.2.2">
	<buginformation>
		<summary>Runtime Semantics: AllocateTypedArrayBuffer ( O, length )</summary>
		<description>The abstract operation AllocateTypedArrayBuffer with arguments O and length allocates and associates an ArrayBuffer with the TypedArray instance O. It performs the following steps: Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.Assert: O.[[ViewedArrayBuffer]] is undefined.Assert: length ≥ 0.Let constructorName be the String value of O.[[TypedArrayName]].Let elementSize be the Element Size value in Table 50 for constructorName.Let byteLength be elementSize × length.Let data be ? AllocateArrayBuffer(%ArrayBuffer%, byteLength).Set O.[[ViewedArrayBuffer]] to data.Set O.[[ByteLength]] to byteLength.Set O.[[ByteOffset]] to 0.Set O.[[ArrayLength]] to length.Return O.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.4.3">
	<buginformation>
		<summary>TypedArray ( typedArray )</summary>
		<description>This description applies only if the TypedArray  function is called with at least one argument and the Type of the first  argument is Object and that object has a [[TypedArrayName]] internal  slot. TypedArray called with argument typedArray performs the following steps: Assert: Type(typedArray) is Object and typedArray has a [[TypedArrayName]] internal slot.If NewTarget is undefined, throw a TypeError exception.Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.Let O be ? AllocateTypedArray(constructorName, NewTarget, &amp;quot;%TypedArrayPrototype%&amp;quot;).Let srcArray be typedArray.Let srcData be srcArray.[[ViewedArrayBuffer]].If IsDetachedBuffer(srcData) is true, throw a TypeError exception.Let elementType be the String value of the Element Type value in Table 50 for constructorName.Let elementLength be srcArray.[[ArrayLength]].Let srcName be the String value of srcArray.[[TypedArrayName]].Let srcType be the String value of the Element Type value in Table 50 for srcName.Let srcElementSize be the Element Size value in Table 50 for srcName.Let srcByteOffset be srcArray.[[ByteOffset]].Let elementSize be the Element Size value in Table 50 for constructorName.Let byteLength be elementSize × elementLength.If SameValue(elementType, srcType) is true, thenIf IsSharedArrayBuffer(srcData) is false, thenLet data be ? CloneArrayBuffer(srcData, srcByteOffset, byteLength).Else,Let data be ? CloneArrayBuffer(srcData, srcByteOffset, byteLength, %ArrayBuffer%).Else,If IsSharedArrayBuffer(srcData) is false, thenLet bufferConstructor be ? SpeciesConstructor(srcData, %ArrayBuffer%).Else,Let bufferConstructor be %ArrayBuffer%.Let data be ? AllocateArrayBuffer(bufferConstructor, byteLength).If IsDetachedBuffer(srcData) is true, throw a TypeError exception.Let srcByteIndex be srcByteOffset.Let targetByteIndex be 0.Let count be elementLength.Repeat, while count &gt; 0Let value be GetValueFromBuffer(srcData, srcByteIndex, srcType, true, &amp;quot;Unordered&amp;quot;).Perform SetValueInBuffer(data, targetByteIndex, elementType, value, true, &amp;quot;Unordered&amp;quot;).Set srcByteIndex to srcByteIndex + srcElementSize.Set targetByteIndex to targetByteIndex + elementSize.Decrement count by 1.Set O.[[ViewedArrayBuffer]] to data.Set O.[[ByteLength]] to byteLength.Set O.[[ByteOffset]] to 0.Set O.[[ArrayLength]] to elementLength.Return O.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.4.4">
	<buginformation>
		<summary>TypedArray ( object )</summary>
		<description>This description applies only if the TypedArray  function is called with at least one argument and the Type of the first  argument is Object and that object does not have either a  [[TypedArrayName]] or an [[ArrayBufferData]] internal slot. TypedArray called with argument object performs the following steps: Assert: Type(object) is Object and object does not have either a [[TypedArrayName]] or an [[ArrayBufferData]] internal slot.If NewTarget is undefined, throw a TypeError exception.Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.Let O be ? AllocateTypedArray(constructorName, NewTarget, &amp;quot;%TypedArrayPrototype%&amp;quot;).Let usingIterator be ? GetMethod(object, @@iterator).If usingIterator is not undefined, thenLet values be ? IterableToList(object, usingIterator).Let len be the number of elements in values.Perform ? AllocateTypedArrayBuffer(O, len).Let k be 0.Repeat, while k &lt; lenLet Pk be ! ToString(k).Let kValue be the first element of values and remove that element from values.Perform ? Set(O, Pk, kValue, true).Increase k by 1.Assert: values is now an empty List.Return O.NOTE: object is not an Iterable so assume it is already an array-like object.Let arrayLike be object.Let len be ? ToLength(? Get(arrayLike, &amp;quot;length&amp;quot;)).Perform ? AllocateTypedArrayBuffer(O, len).Let k be 0.Repeat, while k &lt; lenLet Pk be ! ToString(k).Let kValue be ? Get(arrayLike, Pk).Perform ? Set(O, Pk, kValue, true).Increase k by 1.Return O.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.4.5">
	<buginformation>
		<summary>TypedArray ( buffer [ , byteOffset [ , length ] ] )</summary>
		<description>This description applies only if the TypedArray  function is called with at least one argument and the Type of the first  argument is Object and that object has an [[ArrayBufferData]] internal  slot. TypedArray called with at least one argument buffer performs the following steps: Assert: Type(buffer) is Object and buffer has an [[ArrayBufferData]] internal slot.If NewTarget is undefined, throw a TypeError exception.Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.Let O be ? AllocateTypedArray(constructorName, NewTarget, &amp;quot;%TypedArrayPrototype%&amp;quot;).Let elementSize be the Number value of the Element Size value in Table 50 for constructorName.Let offset be ? ToIndex(byteOffset).If offset modulo elementSize ≠ 0, throw a RangeError exception.If IsDetachedBuffer(buffer) is true, throw a TypeError exception.Let bufferByteLength be buffer.[[ArrayBufferByteLength]].If length is either not present or undefined, thenIf bufferByteLength modulo elementSize ≠ 0, throw a RangeError exception.Let newByteLength be bufferByteLength - offset.If newByteLength &lt; 0, throw a RangeError exception.Else,Let newLength be ? ToIndex(length).Let newByteLength be newLength × elementSize.If offset+newByteLength &gt; bufferByteLength, throw a RangeError exception.Set O.[[ViewedArrayBuffer]] to buffer.Set O.[[ByteLength]] to newByteLength.Set O.[[ByteOffset]] to offset.Set O.[[ArrayLength]] to newByteLength / elementSize.Return O.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.4.6">
	<buginformation>
		<summary>TypedArrayCreate ( constructor, argumentList )</summary>
		<description>The abstract operation TypedArrayCreate with arguments constructor and argumentList is used to specify the creation of a new TypedArray object using a constructor function. It performs the following steps: Let newTypedArray be ? Construct(constructor, argumentList).Perform ? ValidateTypedArray(newTypedArray).If argumentList is a List of a single Number, thenIf newTypedArray.[[ArrayLength]] &lt; argumentList[0], throw a TypeError exception.Return newTypedArray.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.4.7">
	<buginformation>
		<summary>TypedArraySpeciesCreate ( exemplar, argumentList )</summary>
		<description>The abstract operation TypedArraySpeciesCreate with arguments exemplar and argumentList is used to specify the creation of a new TypedArray object using a constructor function that is derived from exemplar. It performs the following steps: Assert: exemplar is an Object that has a [[TypedArrayName]] internal slot.Let defaultConstructor be the intrinsic object listed in column one of Table 50 for exemplar.[[TypedArrayName]].Let constructor be ? SpeciesConstructor(exemplar, defaultConstructor).Return ? TypedArrayCreate(constructor, argumentList).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.5.1">
	<buginformation>
		<summary>TypedArray.BYTES_PER_ELEMENT</summary>
		<description>The value of TypedArray.BYTES_PER_ELEMENT is the Number value of the Element Size value specified in  Table 50 for TypedArray. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.5.2">
	<buginformation>
		<summary>TypedArray.prototype</summary>
		<description>The initial value of TypedArray.prototype is the corresponding TypedArray prototype intrinsic object (22.2.6). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.6.1">
	<buginformation>
		<summary>TypedArray.prototype.BYTES_PER_ELEMENT</summary>
		<description>The value of  TypedArray.prototype.BYTES_PER_ELEMENT is the Number value of the Element Size value specified in  Table 50 for TypedArray. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.6.2">
	<buginformation>
		<summary>TypedArray.prototype.constructor</summary>
		<description>The initial value of a  TypedArray.prototype.constructor is the corresponding %TypedArray% intrinsic object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="22.2.7">
	<buginformation>
		<summary>Properties of TypedArray Instances</summary>
		<description>TypedArray instances are Integer Indexed exotic objects. Each TypedArray instance inherits properties from the corresponding TypedArray prototype object. Each TypedArray  instance has the following internal slots: [[TypedArrayName]],  [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]], and  [[ArrayLength]].</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.1.1">
	<buginformation>
		<summary>Map ( [ iterable ] )</summary>
		<description>When the Map function is called with optional argument, the following steps are taken: If NewTarget is undefined, throw a TypeError exception.Let map be ? OrdinaryCreateFromConstructor(NewTarget, &amp;quot;%MapPrototype%&amp;quot;, « [[MapData]] »).Set map.[[MapData]] to a new empty List.If iterable is not present, let iterable be undefined.If iterable is either undefined or null, let iter be undefined.Else,Let adder be ? Get(map, &amp;quot;set&amp;quot;).If IsCallable(adder) is false, throw a TypeError exception.Let iter be ? GetIterator(iterable).If iter is undefined, return map.Repeat,Let next be ? IteratorStep(iter).If next is false, return map.Let nextItem be ? IteratorValue(next).If Type(nextItem) is not Object, thenLet error be Completion{[[Type]]: throw, [[Value]]: a newly created TypeError object, [[Target]]: empty}.Return ? IteratorClose(iter, error).Let k be Get(nextItem, &amp;quot;0&amp;quot;).If k is an abrupt completion, return ? IteratorClose(iter, k).Let v be Get(nextItem, &amp;quot;1&amp;quot;).If v is an abrupt completion, return ? IteratorClose(iter, v).Let status be Call(adder, map, « k.[[Value]], v.[[Value]] »).If status is an abrupt completion, return ? IteratorClose(iter, status).          Note If the parameter iterable is present, it is  expected to be an object that implements an @@iterator method that  returns an iterator object that produces a two element array-like object  whose first element is a value that will be used as a Map key and whose  second element is the value to associate with that key.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.2.1">
	<buginformation>
		<summary>Map.prototype</summary>
		<description>The initial value of Map.prototype is the intrinsic object %MapPrototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.2.2">
	<buginformation>
		<summary>get Map [ @@species ]</summary>
		<description>Map[@@species] is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Return the this value.          The value of the name property of this function is &amp;quot;get [Symbol.species]&amp;quot;. Note Methods that create derived collection objects should call  @@species to determine the constructor to use to create the derived  objects. Subclass constructor may over-ride @@species to change the  default constructor assignment.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.3.1">
	<buginformation>
		<summary>Map.prototype.clear ( )</summary>
		<description>The following steps are taken: Let M be the this value.If Type(M) is not Object, throw a TypeError exception.If M does not have a [[MapData]] internal slot, throw a TypeError exception.Let entries be the List that is M.[[MapData]].For each Record {[[Key]], [[Value]]} p that is an element of entries, doSet p.[[Key]] to empty.Set p.[[Value]] to empty.Return undefined.          Note The existing [[MapData]] List is preserved because there may be existing Map Iterator objects that are suspended midway through iterating over that List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.3.2">
	<buginformation>
		<summary>Map.prototype.constructor</summary>
		<description>The initial value of Map.prototype.constructor is the intrinsic object %Map%.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.3.3">
	<buginformation>
		<summary>Map.prototype.delete ( key )</summary>
		<description>The following steps are taken: Let M be the this value.If Type(M) is not Object, throw a TypeError exception.If M does not have a [[MapData]] internal slot, throw a TypeError exception.Let entries be the List that is M.[[MapData]].For each Record {[[Key]], [[Value]]} p that is an element of entries, doIf p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, thenSet p.[[Key]] to empty.Set p.[[Value]] to empty.Return true.Return false.          Note The value empty is used as a  specification device to indicate that an entry has been deleted. Actual  implementations may take other actions such as physically removing the  entry from internal data structures.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.3.4">
	<buginformation>
		<summary>Map.prototype.entries ( )</summary>
		<description>The following steps are taken: Let M be the this value.Return ? CreateMapIterator(M, &amp;quot;key+value&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.3.5">
	<buginformation>
		<summary>Map.prototype.forEach ( callbackfn [ , thisArg ] )</summary>
		<description>When the forEach method is called with one or two arguments, the following steps are taken: Let M be the this value.If Type(M) is not Object, throw a TypeError exception.If M does not have a [[MapData]] internal slot, throw a TypeError exception.If IsCallable(callbackfn) is false, throw a TypeError exception.If thisArg was supplied, let T be thisArg; else let T be undefined.Let entries be the List that is M.[[MapData]].For each Record {[[Key]], [[Value]]} e that is an element of entries, in original key insertion order, doIf e.[[Key]] is not empty, thenPerform ? Call(callbackfn, T, « e.[[Value]], e.[[Key]], M »).Return undefined.          Note callbackfn should be a function that accepts three arguments. forEach calls callbackfn once for each key/value pair present in the map object, in key insertion order. callbackfn is called only for keys of the map which actually exist; it is not called for keys that have been deleted from the map. If a thisArg parameter is provided, it will be used as the this value for each invocation of callbackfn. If it is not provided, undefined is used instead. callbackfn is called with three arguments: the value of the item, the key of the item, and the Map object being traversed. forEach does not directly mutate the object on which it is called but the object may be mutated by the calls to callbackfn. Each entry of a map&apos;s [[MapData]] is only visited once. New keys added after the call to forEach begins are visited. A key will be revisited if it is deleted after it has been visited and then re-added before the forEach call completes. Keys that are deleted after the call to forEach begins and before being visited are not visited unless the key is added again before the forEach call completes.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.3.6">
	<buginformation>
		<summary>Map.prototype.get ( key )</summary>
		<description>The following steps are taken: Let M be the this value.If Type(M) is not Object, throw a TypeError exception.If M does not have a [[MapData]] internal slot, throw a TypeError exception.Let entries be the List that is M.[[MapData]].For each Record {[[Key]], [[Value]]} p that is an element of entries, doIf p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, return p.[[Value]].Return undefined.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.3.7">
	<buginformation>
		<summary>Map.prototype.has ( key )</summary>
		<description>The following steps are taken: Let M be the this value.If Type(M) is not Object, throw a TypeError exception.If M does not have a [[MapData]] internal slot, throw a TypeError exception.Let entries be the List that is M.[[MapData]].For each Record {[[Key]], [[Value]]} p that is an element of entries, doIf p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.3.8">
	<buginformation>
		<summary>Map.prototype.keys ( )</summary>
		<description>The following steps are taken: Let M be the this value.Return ? CreateMapIterator(M, &amp;quot;key&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.3.9">
	<buginformation>
		<summary>Map.prototype.set ( key, value )</summary>
		<description>The following steps are taken: Let M be the this value.If Type(M) is not Object, throw a TypeError exception.If M does not have a [[MapData]] internal slot, throw a TypeError exception.Let entries be the List that is M.[[MapData]].For each Record {[[Key]], [[Value]]} p that is an element of entries, doIf p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, thenSet p.[[Value]] to value.Return M.If key is -0, let key be +0.Let p be the Record {[[Key]]: key, [[Value]]: value}.Append p as the last element of entries.Return M.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.3.10">
	<buginformation>
		<summary>get Map.prototype.size</summary>
		<description>Map.prototype.size is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let M be the this value.If Type(M) is not Object, throw a TypeError exception.If M does not have a [[MapData]] internal slot, throw a TypeError exception.Let entries be the List that is M.[[MapData]].Let count be 0.For each Record {[[Key]], [[Value]]} p that is an element of entries, doIf p.[[Key]] is not empty, set count to count+1.Return count.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.3.11">
	<buginformation>
		<summary>Map.prototype.values ( )</summary>
		<description>The following steps are taken: Let M be the this value.Return ? CreateMapIterator(M, &amp;quot;value&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.3.12">
	<buginformation>
		<summary>Map.prototype [ @@iterator ] ( )</summary>
		<description>The initial value of the @@iterator property is the same function object as the initial value of the entries property.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.3.13">
	<buginformation>
		<summary>Map.prototype [ @@toStringTag ]</summary>
		<description>The initial value of the @@toStringTag property is the String value &amp;quot;Map&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.4">
	<buginformation>
		<summary>Properties of Map Instances</summary>
		<description>Map instances are ordinary objects that inherit properties from  the Map prototype. Map instances also have a [[MapData]] internal slot.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.5.1">
	<buginformation>
		<summary>CreateMapIterator ( map, kind )</summary>
		<description>Several methods of Map objects return Iterator objects. The abstract operation CreateMapIterator with arguments map and kind is used to create such iterator objects. It performs the following steps: If Type(map) is not Object, throw a TypeError exception.If map does not have a [[MapData]] internal slot, throw a TypeError exception.Let iterator be ObjectCreate(%MapIteratorPrototype%, « [[Map]], [[MapNextIndex]], [[MapIterationKind]] »).Set iterator.[[Map]] to map.Set iterator.[[MapNextIndex]] to 0.Set iterator.[[MapIterationKind]] to kind.Return iterator.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.5.2.1">
	<buginformation>
		<summary>%MapIteratorPrototype%.next ( )</summary>
		<description>Let O be the this value.If Type(O) is not Object, throw a TypeError exception.If O does not have all of the internal slots of a Map Iterator Instance (23.1.5.3), throw a TypeError exception.Let m be O.[[Map]].Let index be O.[[MapNextIndex]].Let itemKind be O.[[MapIterationKind]].If m is undefined, return CreateIterResultObject(undefined, true).Assert: m has a [[MapData]] internal slot.Let entries be the List that is m.[[MapData]].Repeat, while index is less than the total number of elements of entries. The number of elements must be redetermined each time this method is evaluated.Let e be the Record {[[Key]], [[Value]]} that is the value of entries[index].Set index to index+1.Set O.[[MapNextIndex]] to index.If e.[[Key]] is not empty, thenIf itemKind is &amp;quot;key&amp;quot;, let result be e.[[Key]].Else if itemKind is &amp;quot;value&amp;quot;, let result be e.[[Value]].Else,Assert: itemKind is &amp;quot;key+value&amp;quot;.Let result be CreateArrayFromList(« e.[[Key]], e.[[Value]] »).Return CreateIterResultObject(result, false).Set O.[[Map]] to undefined.Return CreateIterResultObject(undefined, true).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.5.2.2">
	<buginformation>
		<summary>%MapIteratorPrototype% [ @@toStringTag ]</summary>
		<description>The initial value of the @@toStringTag property is the String value &amp;quot;Map Iterator&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.1.5.3">
	<buginformation>
		<summary>Properties of Map Iterator Instances</summary>
		<description>Map Iterator instances are ordinary objects that inherit properties from the %MapIteratorPrototype% intrinsic object. Map Iterator instances are initially created with the internal slots described in  Table 51. Table 51: Internal Slots of Map Iterator Instances                     Internal Slot                                                Description                                                  [[Map]]                                                The Map object that is being iterated.                                                  [[MapNextIndex]]                                                The integer index of the next Map data element to be examined by this iterator.                                                  [[MapIterationKind]]                                                A String value that identifies what is to be returned  for each element of the iteration. The possible values are: &amp;quot;key&amp;quot;, &amp;quot;value&amp;quot;, &amp;quot;key+value&amp;quot;.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.2.1.1">
	<buginformation>
		<summary>Set ( [ iterable ] )</summary>
		<description>When the Set function is called with optional argument iterable, the following steps are taken: If NewTarget is undefined, throw a TypeError exception.Let set be ? OrdinaryCreateFromConstructor(NewTarget, &amp;quot;%SetPrototype%&amp;quot;, « [[SetData]] »).Set set.[[SetData]] to a new empty List.If iterable is not present, let iterable be undefined.If iterable is either undefined or null, let iter be undefined.Else,Let adder be ? Get(set, &amp;quot;add&amp;quot;).If IsCallable(adder) is false, throw a TypeError exception.Let iter be ? GetIterator(iterable).If iter is undefined, return set.Repeat,Let next be ? IteratorStep(iter).If next is false, return set.Let nextValue be ? IteratorValue(next).Let status be Call(adder, set, « nextValue.[[Value]] »).If status is an abrupt completion, return ? IteratorClose(iter, status).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.2.2.1">
	<buginformation>
		<summary>Set.prototype</summary>
		<description>The initial value of Set.prototype is the intrinsic %SetPrototype% object. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.2.2.2">
	<buginformation>
		<summary>get Set [ @@species ]</summary>
		<description>Set[@@species] is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Return the this value.          The value of the name property of this function is &amp;quot;get [Symbol.species]&amp;quot;. Note Methods that create derived collection objects should call  @@species to determine the constructor to use to create the derived  objects. Subclass constructor may over-ride @@species to change the  default constructor assignment.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.2.3.1">
	<buginformation>
		<summary>Set.prototype.add ( value )</summary>
		<description>The following steps are taken: Let S be the this value.If Type(S) is not Object, throw a TypeError exception.If S does not have a [[SetData]] internal slot, throw a TypeError exception.Let entries be the List that is S.[[SetData]].For each e that is an element of entries, doIf e is not empty and SameValueZero(e, value) is true, thenReturn S.If value is -0, let value be +0.Append value as the last element of entries.Return S.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.2.3.2">
	<buginformation>
		<summary>Set.prototype.clear ( )</summary>
		<description>The following steps are taken: Let S be the this value.If Type(S) is not Object, throw a TypeError exception.If S does not have a [[SetData]] internal slot, throw a TypeError exception.Let entries be the List that is S.[[SetData]].For each e that is an element of entries, doReplace the element of entries whose value is e with an element whose value is empty.Return undefined.          Note The existing [[SetData]] List is preserved because there may be existing Set Iterator objects that are suspended midway through iterating over that List.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.2.3.3">
	<buginformation>
		<summary>Set.prototype.constructor</summary>
		<description>The initial value of Set.prototype.constructor is the intrinsic object %Set%.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.2.3.4">
	<buginformation>
		<summary>Set.prototype.delete ( value )</summary>
		<description>The following steps are taken: Let S be the this value.If Type(S) is not Object, throw a TypeError exception.If S does not have a [[SetData]] internal slot, throw a TypeError exception.Let entries be the List that is S.[[SetData]].For each e that is an element of entries, doIf e is not empty and SameValueZero(e, value) is true, thenReplace the element of entries whose value is e with an element whose value is empty.Return true.Return false.          Note The value empty is used as a  specification device to indicate that an entry has been deleted. Actual  implementations may take other actions such as physically removing the  entry from internal data structures.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.2.3.5">
	<buginformation>
		<summary>Set.prototype.entries ( )</summary>
		<description>The following steps are taken: Let S be the this value.Return ? CreateSetIterator(S, &amp;quot;key+value&amp;quot;).          Note For iteration purposes, a Set appears similar to a Map where each entry has the same value for its key and value.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.2.3.6">
	<buginformation>
		<summary>Set.prototype.forEach ( callbackfn [ , thisArg ] )</summary>
		<description>When the forEach method is called with one or two arguments, the following steps are taken: Let S be the this value.If Type(S) is not Object, throw a TypeError exception.If S does not have a [[SetData]] internal slot, throw a TypeError exception.If IsCallable(callbackfn) is false, throw a TypeError exception.If thisArg was supplied, let T be thisArg; else let T be undefined.Let entries be the List that is S.[[SetData]].For each e that is an element of entries, in original insertion order, doIf e is not empty, thenPerform ? Call(callbackfn, T, « e, e, S »).Return undefined.          Note callbackfn should be a function that accepts three arguments. forEach calls callbackfn once for each value present in the set object, in value insertion order. callbackfn is called only for values of the Set which actually exist; it is not called for keys that have been deleted from the set. If a thisArg parameter is provided, it will be used as the this value for each invocation of callbackfn. If it is not provided, undefined is used instead. callbackfn is called with three arguments: the  first two arguments are a value contained in the Set. The same value is  passed for both arguments. The Set object being traversed is passed as  the third argument. The callbackfn is called with three arguments to be consistent with the call back functions used by forEach methods for Map and Array. For Sets, each item value is considered to be both the key and the value. forEach does not directly mutate the object on which it is called but the object may be mutated by the calls to callbackfn. Each value is normally visited only once. However, a value  will be revisited if it is deleted after it has been visited and then  re-added before the forEach call completes. Values that are deleted after the call to forEach begins and before being visited are not visited unless the value is added again before the forEach call completes. New values added after the call to forEach begins are visited.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.2.3.7">
	<buginformation>
		<summary>Set.prototype.has ( value )</summary>
		<description>The following steps are taken: Let S be the this value.If Type(S) is not Object, throw a TypeError exception.If S does not have a [[SetData]] internal slot, throw a TypeError exception.Let entries be the List that is S.[[SetData]].For each e that is an element of entries, doIf e is not empty and SameValueZero(e, value) is true, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.2.3.8">
	<buginformation>
		<summary>Set.prototype.keys ( )</summary>
		<description>The initial value of the keys property is the same function object as the initial value of the values property. Note For iteration purposes, a Set appears similar to a Map where each entry has the same value for its key and value.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.2.3.9">
	<buginformation>
		<summary>get Set.prototype.size</summary>
		<description>Set.prototype.size is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let S be the this value.If Type(S) is not Object, throw a TypeError exception.If S does not have a [[SetData]] internal slot, throw a TypeError exception.Let entries be the List that is S.[[SetData]].Let count be 0.For each e that is an element of entries, doIf e is not empty, set count to count+1.Return count.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.2.3.10">
	<buginformation>
		<summary>Set.prototype.values ( )</summary>
		<description>The following steps are taken: Let S be the this value.Return ? CreateSetIterator(S, &amp;quot;value&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.2.3.11">
	<buginformation>
		<summary>Set.prototype [ @@iterator ] ( )</summary>
		<description>The initial value of the @@iterator property is the same function object as the initial value of the values property.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.2.3.12">
	<buginformation>
		<summary>Set.prototype [ @@toStringTag ]</summary>
		<description>The initial value of the @@toStringTag property is the String value &amp;quot;Set&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.2.4">
	<buginformation>
		<summary>Properties of Set Instances</summary>
		<description>Set instances are ordinary objects that inherit properties from  the Set prototype. Set instances also have a [[SetData]] internal slot.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.2.5.1">
	<buginformation>
		<summary>CreateSetIterator ( set, kind )</summary>
		<description>Several methods of Set objects return Iterator objects. The abstract operation CreateSetIterator with arguments set and kind is used to create such iterator objects. It performs the following steps: If Type(set) is not Object, throw a TypeError exception.If set does not have a [[SetData]] internal slot, throw a TypeError exception.Let iterator be ObjectCreate(%SetIteratorPrototype%, « [[IteratedSet]], [[SetNextIndex]], [[SetIterationKind]] »).Set iterator.[[IteratedSet]] to set.Set iterator.[[SetNextIndex]] to 0.Set iterator.[[SetIterationKind]] to kind.Return iterator.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.2.5.2.1">
	<buginformation>
		<summary>%SetIteratorPrototype%.next ( )</summary>
		<description>Let O be the this value.If Type(O) is not Object, throw a TypeError exception.If O does not have all of the internal slots of a Set Iterator Instance (23.2.5.3), throw a TypeError exception.Let s be O.[[IteratedSet]].Let index be O.[[SetNextIndex]].Let itemKind be O.[[SetIterationKind]].If s is undefined, return CreateIterResultObject(undefined, true).Assert: s has a [[SetData]] internal slot.Let entries be the List that is s.[[SetData]].Repeat, while index is less than the total number of elements of entries. The number of elements must be redetermined each time this method is evaluated.Let e be entries[index].Set index to index+1.Set O.[[SetNextIndex]] to index.If e is not empty, thenIf itemKind is &amp;quot;key+value&amp;quot;, thenReturn CreateIterResultObject(CreateArrayFromList(« e, e »), false).Return CreateIterResultObject(e, false).Set O.[[IteratedSet]] to undefined.Return CreateIterResultObject(undefined, true).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.2.5.2.2">
	<buginformation>
		<summary>%SetIteratorPrototype% [ @@toStringTag ]</summary>
		<description>The initial value of the @@toStringTag property is the String value &amp;quot;Set Iterator&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.2.5.3">
	<buginformation>
		<summary>Properties of Set Iterator Instances</summary>
		<description>Set Iterator instances are ordinary objects that inherit properties from the %SetIteratorPrototype% intrinsic object. Set Iterator instances are initially created with the internal slots specified in  Table 52. Table 52: Internal Slots of Set Iterator Instances                     Internal Slot                                                Description                                                  [[IteratedSet]]                                                The Set object that is being iterated.                                                  [[SetNextIndex]]                                                The integer index of the next Set data element to be examined by this iterator                                                  [[SetIterationKind]]                                                A String value that identifies what is to be returned  for each element of the iteration. The possible values are: &amp;quot;key&amp;quot;, &amp;quot;value&amp;quot;, &amp;quot;key+value&amp;quot;. &amp;quot;key&amp;quot; and &amp;quot;value&amp;quot; have the same meaning.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.3.1.1">
	<buginformation>
		<summary>WeakMap ( [ iterable ] )</summary>
		<description>When the WeakMap function is called with optional argument iterable, the following steps are taken: If NewTarget is undefined, throw a TypeError exception.Let map be ? OrdinaryCreateFromConstructor(NewTarget, &amp;quot;%WeakMapPrototype%&amp;quot;, « [[WeakMapData]] »).Set map.[[WeakMapData]] to a new empty List.If iterable is not present, let iterable be undefined.If iterable is either undefined or null, let iter be undefined.Else,Let adder be ? Get(map, &amp;quot;set&amp;quot;).If IsCallable(adder) is false, throw a TypeError exception.Let iter be ? GetIterator(iterable).If iter is undefined, return map.Repeat,Let next be ? IteratorStep(iter).If next is false, return map.Let nextItem be ? IteratorValue(next).If Type(nextItem) is not Object, thenLet error be Completion{[[Type]]: throw, [[Value]]: a newly created TypeError object, [[Target]]: empty}.Return ? IteratorClose(iter, error).Let k be Get(nextItem, &amp;quot;0&amp;quot;).If k is an abrupt completion, return ? IteratorClose(iter, k).Let v be Get(nextItem, &amp;quot;1&amp;quot;).If v is an abrupt completion, return ? IteratorClose(iter, v).Let status be Call(adder, map, « k.[[Value]], v.[[Value]] »).If status is an abrupt completion, return ? IteratorClose(iter, status).          Note If the parameter iterable is present, it is  expected to be an object that implements an @@iterator method that  returns an iterator object that produces a two element array-like object  whose first element is a value that will be used as a WeakMap key and  whose second element is the value to associate with that key.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.3.2.1">
	<buginformation>
		<summary>WeakMap.prototype</summary>
		<description>The initial value of WeakMap.prototype is the intrinsic object %WeakMapPrototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.3.3.1">
	<buginformation>
		<summary>WeakMap.prototype.constructor</summary>
		<description>The initial value of WeakMap.prototype.constructor is the intrinsic object %WeakMap%.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.3.3.2">
	<buginformation>
		<summary>WeakMap.prototype.delete ( key )</summary>
		<description>The following steps are taken: Let M be the this value.If Type(M) is not Object, throw a TypeError exception.If M does not have a [[WeakMapData]] internal slot, throw a TypeError exception.Let entries be the List that is M.[[WeakMapData]].If Type(key) is not Object, return false.For each Record {[[Key]], [[Value]]} p that is an element of entries, doIf p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, thenSet p.[[Key]] to empty.Set p.[[Value]] to empty.Return true.Return false.          Note The value empty is used as a  specification device to indicate that an entry has been deleted. Actual  implementations may take other actions such as physically removing the  entry from internal data structures.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.3.3.3">
	<buginformation>
		<summary>WeakMap.prototype.get ( key )</summary>
		<description>The following steps are taken: Let M be the this value.If Type(M) is not Object, throw a TypeError exception.If M does not have a [[WeakMapData]] internal slot, throw a TypeError exception.Let entries be the List that is M.[[WeakMapData]].If Type(key) is not Object, return undefined.For each Record {[[Key]], [[Value]]} p that is an element of entries, doIf p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, return p.[[Value]].Return undefined.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.3.3.4">
	<buginformation>
		<summary>WeakMap.prototype.has ( key )</summary>
		<description>The following steps are taken: Let M be the this value.If Type(M) is not Object, throw a TypeError exception.If M does not have a [[WeakMapData]] internal slot, throw a TypeError exception.Let entries be the List that is M.[[WeakMapData]].If Type(key) is not Object, return false.For each Record {[[Key]], [[Value]]} p that is an element of entries, doIf p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.3.3.5">
	<buginformation>
		<summary>WeakMap.prototype.set ( key, value )</summary>
		<description>The following steps are taken: Let M be the this value.If Type(M) is not Object, throw a TypeError exception.If M does not have a [[WeakMapData]] internal slot, throw a TypeError exception.Let entries be the List that is M.[[WeakMapData]].If Type(key) is not Object, throw a TypeError exception.For each Record {[[Key]], [[Value]]} p that is an element of entries, doIf p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, thenSet p.[[Value]] to value.Return M.Let p be the Record {[[Key]]: key, [[Value]]: value}.Append p as the last element of entries.Return M.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.3.3.6">
	<buginformation>
		<summary>WeakMap.prototype [ @@toStringTag ]</summary>
		<description>The initial value of the @@toStringTag property is the String value &amp;quot;WeakMap&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.3.4">
	<buginformation>
		<summary>Properties of WeakMap Instances</summary>
		<description>WeakMap instances are ordinary objects that inherit properties  from the WeakMap prototype. WeakMap instances also have a  [[WeakMapData]] internal slot.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.4.1.1">
	<buginformation>
		<summary>WeakSet ( [ iterable ] )</summary>
		<description>When the WeakSet function is called with optional argument iterable, the following steps are taken: If NewTarget is undefined, throw a TypeError exception.Let set be ? OrdinaryCreateFromConstructor(NewTarget, &amp;quot;%WeakSetPrototype%&amp;quot;, « [[WeakSetData]] »).Set set.[[WeakSetData]] to a new empty List.If iterable is not present, let iterable be undefined.If iterable is either undefined or null, let iter be undefined.Else,Let adder be ? Get(set, &amp;quot;add&amp;quot;).If IsCallable(adder) is false, throw a TypeError exception.Let iter be ? GetIterator(iterable).If iter is undefined, return set.Repeat,Let next be ? IteratorStep(iter).If next is false, return set.Let nextValue be ? IteratorValue(next).Let status be Call(adder, set, « nextValue »).If status is an abrupt completion, return ? IteratorClose(iter, status).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.4.2.1">
	<buginformation>
		<summary>WeakSet.prototype</summary>
		<description>The initial value of WeakSet.prototype is the intrinsic %WeakSetPrototype% object. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.4.3.1">
	<buginformation>
		<summary>WeakSet.prototype.add ( value )</summary>
		<description>The following steps are taken: Let S be the this value.If Type(S) is not Object, throw a TypeError exception.If S does not have a [[WeakSetData]] internal slot, throw a TypeError exception.If Type(value) is not Object, throw a TypeError exception.Let entries be the List that is S.[[WeakSetData]].For each e that is an element of entries, doIf e is not empty and SameValue(e, value) is true, thenReturn S.Append value as the last element of entries.Return S.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.4.3.2">
	<buginformation>
		<summary>WeakSet.prototype.constructor</summary>
		<description>The initial value of WeakSet.prototype.constructor is the %WeakSet% intrinsic object.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.4.3.3">
	<buginformation>
		<summary>WeakSet.prototype.delete ( value )</summary>
		<description>The following steps are taken: Let S be the this value.If Type(S) is not Object, throw a TypeError exception.If S does not have a [[WeakSetData]] internal slot, throw a TypeError exception.If Type(value) is not Object, return false.Let entries be the List that is S.[[WeakSetData]].For each e that is an element of entries, doIf e is not empty and SameValue(e, value) is true, thenReplace the element of entries whose value is e with an element whose value is empty.Return true.Return false.          Note The value empty is used as a  specification device to indicate that an entry has been deleted. Actual  implementations may take other actions such as physically removing the  entry from internal data structures.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.4.3.4">
	<buginformation>
		<summary>WeakSet.prototype.has ( value )</summary>
		<description>The following steps are taken: Let S be the this value.If Type(S) is not Object, throw a TypeError exception.If S does not have a [[WeakSetData]] internal slot, throw a TypeError exception.Let entries be the List that is S.[[WeakSetData]].If Type(value) is not Object, return false.For each e that is an element of entries, doIf e is not empty and SameValue(e, value) is true, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.4.3.5">
	<buginformation>
		<summary>WeakSet.prototype [ @@toStringTag ]</summary>
		<description>The initial value of the @@toStringTag property is the String value &amp;quot;WeakSet&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="23.4.4">
	<buginformation>
		<summary>Properties of WeakSet Instances</summary>
		<description>WeakSet instances are ordinary objects that inherit properties  from the WeakSet prototype. WeakSet instances also have a  [[WeakSetData]] internal slot.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.1.1.1">
	<buginformation>
		<summary>AllocateArrayBuffer ( constructor, byteLength )</summary>
		<description>The abstract operation AllocateArrayBuffer with arguments constructor and byteLength is used to create an ArrayBuffer object. It performs the following steps: Let obj be ? OrdinaryCreateFromConstructor(constructor, &amp;quot;%ArrayBufferPrototype%&amp;quot;, « [[ArrayBufferData]], [[ArrayBufferByteLength]] »).Assert: byteLength is an integer value ≥ 0.Let block be ? CreateByteDataBlock(byteLength).Set obj.[[ArrayBufferData]] to block.Set obj.[[ArrayBufferByteLength]] to byteLength.Return obj.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.1.1.2">
	<buginformation>
		<summary>IsDetachedBuffer ( arrayBuffer )</summary>
		<description>The abstract operation IsDetachedBuffer with argument arrayBuffer performs the following steps: Assert: Type(arrayBuffer) is Object and it has an [[ArrayBufferData]] internal slot.If arrayBuffer.[[ArrayBufferData]] is null, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.1.1.3">
	<buginformation>
		<summary>DetachArrayBuffer ( arrayBuffer )</summary>
		<description>The abstract operation DetachArrayBuffer with argument arrayBuffer performs the following steps: Assert: Type(arrayBuffer) is Object and it has [[ArrayBufferData]] and [[ArrayBufferByteLength]] internal slots.Assert: IsSharedArrayBuffer(arrayBuffer) is false.Set arrayBuffer.[[ArrayBufferData]] to null.Set arrayBuffer.[[ArrayBufferByteLength]] to 0.Return NormalCompletion(null).          Note Detaching an ArrayBuffer instance disassociates the Data Block  used as its backing store from the instance and sets the byte length of  the buffer to 0. No operations defined by this specification use the  DetachArrayBuffer abstract operation. However, an ECMAScript  implementation or host environment may define such operations.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.1.1.4">
	<buginformation>
		<summary>CloneArrayBuffer ( srcBuffer, srcByteOffset, srcLength [ , cloneConstructor ] )</summary>
		<description>The abstract operation CloneArrayBuffer takes four parameters, an ArrayBuffer srcBuffer, an integer offset srcByteOffset, an integer length srcLength, and optionally a constructor function cloneConstructor. It creates a new ArrayBuffer whose data is a copy of srcBuffer&apos;s data over the range starting at srcByteOffset and continuing for srcLength bytes. This operation performs the following steps: Assert: Type(srcBuffer) is Object and it has an [[ArrayBufferData]] internal slot.If cloneConstructor is not present, thenSet cloneConstructor to ? SpeciesConstructor(srcBuffer, %ArrayBuffer%).If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.Else, Assert: IsConstructor(cloneConstructor) is true.Let srcBlock be srcBuffer.[[ArrayBufferData]].Let targetBuffer be ? AllocateArrayBuffer(cloneConstructor, srcLength).If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.Let targetBlock be targetBuffer.[[ArrayBufferData]].Perform CopyDataBlockBytes(targetBlock, 0, srcBlock, srcByteOffset, srcLength).Return targetBuffer.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.1.1.5">
	<buginformation>
		<summary>RawBytesToNumber( type, rawBytes, isLittleEndian )</summary>
		<description>The abstract operation RawBytesToNumber takes three parameters, a String type, a List rawBytes, and a Boolean isLittleEndian. This operation performs the following steps: Let elementSize be the Number value of the Element Size value specified in Table 50 for Element Type type.If isLittleEndian is false, reverse the order of the elements of rawBytes.If type is &amp;quot;Float32&amp;quot;, thenLet value be the byte elements of rawBytes concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary32 value.If value is an IEEE 754-2008 binary32 NaN value, return the NaN Number value.Return the Number value that corresponds to value.If type is &amp;quot;Float64&amp;quot;, thenLet value be the byte elements of rawBytes concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary64 value.If value is an IEEE 754-2008 binary64 NaN value, return the NaN Number value.Return the Number value that corresponds to value.If the first code unit of type is &amp;quot;U&amp;quot;, thenLet intValue be the byte elements of rawBytes concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.Else,Let intValue be the byte elements of rawBytes concatenated and interpreted as a bit string encoding of a binary little-endian 2&apos;s complement number of bit length elementSize × 8.Return the Number value that corresponds to intValue.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.1.1.6">
	<buginformation>
		<summary>GetValueFromBuffer ( arrayBuffer, byteIndex, type, isTypedArray, order [ , isLittleEndian ] )</summary>
		<description>The abstract operation GetValueFromBuffer takes six parameters, an ArrayBuffer or SharedArrayBuffer arrayBuffer, an integer byteIndex, a String type, a Boolean isTypedArray, a String order, and optionally a Boolean isLittleEndian. This operation performs the following steps: Assert: IsDetachedBuffer(arrayBuffer) is false.Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.Assert: byteIndex is an integer value ≥ 0.Let block be arrayBuffer.[[ArrayBufferData]].Let elementSize be the Number value of the Element Size value specified in Table 50 for Element Type type.If IsSharedArrayBuffer(arrayBuffer) is true, thenLet execution be the [[CandidateExecution]] field of the surrounding agent&apos;s Agent Record.Let eventList be the [[EventList]] field of the element in execution.[[EventLists]] whose [[AgentSignifier]] is AgentSignifier().If isTypedArray is true and type is &amp;quot;Int8&amp;quot;, &amp;quot;Uint8&amp;quot;, &amp;quot;Int16&amp;quot;, &amp;quot;Uint16&amp;quot;, &amp;quot;Int32&amp;quot;, or &amp;quot;Uint32&amp;quot;, let noTear be true; otherwise let noTear be false.Let rawValue be a List of length elementSize of nondeterministically chosen byte values.NOTE: In implementations, rawValue  is the result of a non-atomic or atomic read instruction on the  underlying hardware. The nondeterminism is a semantic prescription of  the memory model to describe observable behaviour of hardware with weak consistency.Let readEvent be ReadSharedMemory{ [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize }.Append readEvent to eventList.Append Chosen Value Record { [[Event]]: readEvent, [[ChosenValue]]: rawValue } to execution.[[ChosenValues]].Else, let rawValue be a List of elementSize containing, in order, the elementSize sequence of bytes starting with block[byteIndex].If isLittleEndian is not present, set isLittleEndian to the value of the [[LittleEndian]] field of the surrounding agent&apos;s Agent Record.Return RawBytesToNumber(type, rawValue, isLittleEndian).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.1.1.7">
	<buginformation>
		<summary>NumberToRawBytes( type, value, isLittleEndian )</summary>
		<description>The abstract operation NumberToRawBytes takes three parameters, a String type, a Number value, and a Boolean isLittleEndian. This operation performs the following steps: If type is &amp;quot;Float32&amp;quot;, thenLet rawBytes be a List containing the 4 bytes that are the result of converting value to IEEE 754-2008 binary32 format using “Round to nearest, ties to even” rounding mode. If isLittleEndian is false, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If value is NaN, rawBytes  may be set to any implementation chosen IEEE 754-2008 binary32 format  Not-a-Number encoding. An implementation must always choose the same  encoding for each implementation distinguishable NaN value.Else if type is &amp;quot;Float64&amp;quot;, thenLet rawBytes be a List containing the 8 bytes that are the IEEE 754-2008 binary64 format encoding of value. If isLittleEndian is false, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If value is NaN, rawBytes  may be set to any implementation chosen IEEE 754-2008 binary64 format  Not-a-Number encoding. An implementation must always choose the same  encoding for each implementation distinguishable NaN value.Else,Let n be the Number value of the Element Size specified in Table 50 for Element Type type.Let convOp be the abstract operation named in the Conversion Operation column in Table 50 for Element Type type.Let intValue be convOp(value).If intValue ≥ 0, thenLet rawBytes be a List containing the n-byte binary encoding of intValue. If isLittleEndian is false, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.Else,Let rawBytes be a List containing the n-byte binary 2&apos;s complement encoding of intValue. If isLittleEndian is false, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.Return rawBytes.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.1.1.8">
	<buginformation>
		<summary>SetValueInBuffer ( arrayBuffer, byteIndex, type, value, isTypedArray, order [ , isLittleEndian ] )</summary>
		<description>The abstract operation SetValueInBuffer takes seven parameters, an ArrayBuffer or SharedArrayBuffer arrayBuffer, an integer byteIndex, a String type, a Number value, a Boolean isTypedArray, a String order, and optionally a Boolean isLittleEndian. This operation performs the following steps: Assert: IsDetachedBuffer(arrayBuffer) is false.Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.Assert: byteIndex is an integer value ≥ 0.Assert: Type(value) is Number.Let block be arrayBuffer.[[ArrayBufferData]].Let elementSize be the Number value of the Element Size value specified in Table 50 for Element Type type.If isLittleEndian is not present, set isLittleEndian to the value of the [[LittleEndian]] field of the surrounding agent&apos;s Agent Record.Let rawBytes be NumberToRawBytes(type, value, isLittleEndian).If IsSharedArrayBuffer(arrayBuffer) is true, thenLet execution be the [[CandidateExecution]] field of the surrounding agent&apos;s Agent Record.Let eventList be the [[EventList]] field of the element in execution.[[EventLists]] whose [[AgentSignifier]] is AgentSignifier().If isTypedArray is true and type is &amp;quot;Int8&amp;quot;, &amp;quot;Uint8&amp;quot;, &amp;quot;Int16&amp;quot;, &amp;quot;Uint16&amp;quot;, &amp;quot;Int32&amp;quot;, or &amp;quot;Uint32&amp;quot;, let noTear be true; otherwise let noTear be false.Append WriteSharedMemory{ [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize, [[Payload]]: rawBytes } to eventList.Else, store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].Return NormalCompletion(undefined).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.1.1.9">
	<buginformation>
		<summary>GetModifySetValueInBuffer( arrayBuffer, byteIndex, type, value, op [ , isLittleEndian ] )</summary>
		<description>The abstract operation GetModifySetValueInBuffer takes six parameters, a SharedArrayBuffer arrayBuffer, a nonnegative integer byteIndex, a String type, a Number value, a semantic function op, and optionally a Boolean isLittleEndian. This operation performs the following steps: Assert: IsSharedArrayBuffer(arrayBuffer) is true.Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.Assert: byteIndex is an integer value ≥ 0.Assert: Type(value) is Number.Let block be arrayBuffer.[[ArrayBufferData]].Let elementSize be the Number value of the Element Size value specified in Table 50 for Element Type type.If isLittleEndian is not present, set isLittleEndian to the value of the [[LittleEndian]] field of the surrounding agent&apos;s Agent Record.Let rawBytes be NumberToRawBytes(type, value, isLittleEndian).Let execution be the [[CandidateExecution]] field of the surrounding agent&apos;s Agent Record.Let eventList be the [[EventList]] field of the element in execution.[[EventLists]] whose [[AgentSignifier]] is AgentSignifier().Let rawBytesRead be a List of length elementSize of nondeterministically chosen byte values.NOTE: In implementations, rawBytesRead  is the result of a load-link, of a load-exclusive, or of an operand of a  read-modify-write instruction on the underlying hardware. The  nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.Let rmwEvent be ReadModifyWriteSharedMemory{ [[Order]]: &amp;quot;SeqCst&amp;quot;, [[NoTear]]: true, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize, [[Payload]]: rawBytes, [[ModifyOp]]: op }.Append rmwEvent to eventList.Append Chosen Value Record { [[Event]]: rmwEvent, [[ChosenValue]]: rawBytesRead } to execution.[[ChosenValues]].Return RawBytesToNumber(type, rawBytesRead, isLittleEndian).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.1.2.1">
	<buginformation>
		<summary>ArrayBuffer ( length )</summary>
		<description>When the ArrayBuffer function is called with argument length, the following steps are taken: If NewTarget is undefined, throw a TypeError exception.Let byteLength be ? ToIndex(length).Return ? AllocateArrayBuffer(NewTarget, byteLength).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.1.3.1">
	<buginformation>
		<summary>ArrayBuffer.isView ( arg )</summary>
		<description>The isView function takes one argument arg, and performs, the following steps are taken: If Type(arg) is not Object, return false.If arg has a [[ViewedArrayBuffer]] internal slot, return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.1.3.2">
	<buginformation>
		<summary>ArrayBuffer.prototype</summary>
		<description>The initial value of ArrayBuffer.prototype is the intrinsic object %ArrayBufferPrototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.1.3.3">
	<buginformation>
		<summary>get ArrayBuffer [ @@species ]</summary>
		<description>ArrayBuffer[@@species] is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Return the this value.          The value of the name property of this function is &amp;quot;get [Symbol.species]&amp;quot;. Note ArrayBuffer prototype methods normally use their this  object&apos;s constructor to create a derived object. However, a subclass  constructor may over-ride that default behaviour by redefining its  @@species property.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.1.4.1">
	<buginformation>
		<summary>get ArrayBuffer.prototype.byteLength</summary>
		<description>ArrayBuffer.prototype.byteLength is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let O be the this value.If Type(O) is not Object, throw a TypeError exception.If O does not have an [[ArrayBufferData]] internal slot, throw a TypeError exception.If IsSharedArrayBuffer(O) is true, throw a TypeError exception.If IsDetachedBuffer(O) is true, throw a TypeError exception.Let length be O.[[ArrayBufferByteLength]].Return length.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.1.4.2">
	<buginformation>
		<summary>ArrayBuffer.prototype.constructor</summary>
		<description>The initial value of ArrayBuffer.prototype.constructor is the intrinsic object %ArrayBuffer%.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.1.4.3">
	<buginformation>
		<summary>ArrayBuffer.prototype.slice ( start, end )</summary>
		<description>The following steps are taken: Let O be the this value.If Type(O) is not Object, throw a TypeError exception.If O does not have an [[ArrayBufferData]] internal slot, throw a TypeError exception.If IsSharedArrayBuffer(O) is true, throw a TypeError exception.If IsDetachedBuffer(O) is true, throw a TypeError exception.Let len be O.[[ArrayBufferByteLength]].Let relativeStart be ? ToInteger(start).If relativeStart &lt; 0, let first be max((len + relativeStart), 0); else let first be min(relativeStart, len).If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).If relativeEnd &lt; 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).Let newLen be max(final-first, 0).Let ctor be ? SpeciesConstructor(O, %ArrayBuffer%).Let new be ? Construct(ctor, « newLen »).If new does not have an [[ArrayBufferData]] internal slot, throw a TypeError exception.If IsSharedArrayBuffer(new) is true, throw a TypeError exception.If IsDetachedBuffer(new) is true, throw a TypeError exception.If SameValue(new, O) is true, throw a TypeError exception.If new.[[ArrayBufferByteLength]] &lt; newLen, throw a TypeError exception.NOTE: Side-effects of the above steps may have detached O.If IsDetachedBuffer(O) is true, throw a TypeError exception.Let fromBuf be O.[[ArrayBufferData]].Let toBuf be new.[[ArrayBufferData]].Perform CopyDataBlockBytes(toBuf, 0, fromBuf, first, newLen).Return new.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.1.4.4">
	<buginformation>
		<summary>ArrayBuffer.prototype [ @@toStringTag ]</summary>
		<description>The initial value of the @@toStringTag property is the String value &amp;quot;ArrayBuffer&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.1.5">
	<buginformation>
		<summary>Properties of the ArrayBuffer Instances</summary>
		<description>ArrayBuffer instances inherit properties from the ArrayBuffer  prototype object. ArrayBuffer instances each have an [[ArrayBufferData]]  internal slot and an [[ArrayBufferByteLength]] internal slot. ArrayBuffer instances whose [[ArrayBufferData]] is null are considered to be detached and all operators to access or modify data contained in the ArrayBuffer instance will fail.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.2.1.1">
	<buginformation>
		<summary>AllocateSharedArrayBuffer( constructor, byteLength )</summary>
		<description>The abstract operation AllocateSharedArrayBuffer with arguments constructor and byteLength is used to create a SharedArrayBuffer object. It performs the following steps: Let obj be ? OrdinaryCreateFromConstructor(constructor, &amp;quot;%SharedArrayBufferPrototype%&amp;quot;, « [[ArrayBufferData]], [[ArrayBufferByteLength]] »).Assert: byteLength is a nonnegative integer.Let block be ? CreateSharedByteDataBlock(byteLength).Set obj.[[ArrayBufferData]] to block.Set obj.[[ArrayBufferByteLength]] to byteLength.Return obj.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.2.1.2">
	<buginformation>
		<summary>IsSharedArrayBuffer( obj )</summary>
		<description>IsSharedArrayBuffer tests whether an object is an  ArrayBuffer, a SharedArrayBuffer, or a subtype of either. It performs  the following steps: Assert: Type(obj) is Object and it has an [[ArrayBufferData]] internal slot.Let bufferData be obj.[[ArrayBufferData]].If bufferData is null, return false.If bufferData is a Data Block, return false.Assert: bufferData is a Shared Data Block.Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.2.2.1">
	<buginformation>
		<summary>SharedArrayBuffer( length )</summary>
		<description>When the SharedArrayBuffer function is called with optional argument length, the following steps are taken: If NewTarget is undefined, throw a TypeError exception.Let byteLength be ? ToIndex(length).Return ? AllocateSharedArrayBuffer(NewTarget, byteLength).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.2.3.1">
	<buginformation>
		<summary>SharedArrayBuffer.prototype</summary>
		<description>The initial value of SharedArrayBuffer.prototype is the intrinsic object %SharedArrayBufferPrototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.2.3.2">
	<buginformation>
		<summary>get SharedArrayBuffer [ @@species ]</summary>
		<description>SharedArrayBuffer[@@species] is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Return the this value.          The value of the name property of this function is &amp;quot;get [Symbol.species]&amp;quot;.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.2.4.1">
	<buginformation>
		<summary>get SharedArrayBuffer.prototype.byteLength</summary>
		<description>SharedArrayBuffer.prototype.byteLength is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let O be the this value.If Type(O) is not Object, throw a TypeError exception.If O does not have an [[ArrayBufferData]] internal slot, throw a TypeError exception.If IsSharedArrayBuffer(O) is false, throw a TypeError exception.Let length be O.[[ArrayBufferByteLength]].Return length.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.2.4.2">
	<buginformation>
		<summary>SharedArrayBuffer.prototype.constructor</summary>
		<description>The initial value of SharedArrayBuffer.prototype.constructor is the intrinsic object %SharedArrayBuffer%.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.2.4.3">
	<buginformation>
		<summary>SharedArrayBuffer.prototype.slice( start, end )</summary>
		<description>The following steps are taken: Let O be the this value.If Type(O) is not Object, throw a TypeError exception.If O does not have an [[ArrayBufferData]] internal slot, throw a TypeError exception.If IsSharedArrayBuffer(O) is false, throw a TypeError exception.Let len be O.[[ArrayBufferByteLength]].Let relativeStart be ? ToInteger(start).If relativeStart &lt; 0, let first be max((len + relativeStart), 0); else let first be min(relativeStart, len).If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).If relativeEnd &lt; 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).Let newLen be max(final - first, 0).Let ctor be ? SpeciesConstructor(O, %SharedArrayBuffer%).Let new be ? Construct(ctor, « newLen »).If new does not have an [[ArrayBufferData]] internal slot, throw a TypeError exception.If IsSharedArrayBuffer(new) is false, throw a TypeError exception.If new.[[ArrayBufferData]] and O.[[ArrayBufferData]] are the same Shared Data Block values, throw a TypeError exception.If new.[[ArrayBufferByteLength]] &lt; newLen, throw a TypeError exception.Let fromBuf be O.[[ArrayBufferData]].Let toBuf be new.[[ArrayBufferData]].Perform CopyDataBlockBytes(toBuf, 0, fromBuf, first, newLen).Return new.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.2.4.4">
	<buginformation>
		<summary>SharedArrayBuffer.prototype [ @@toStringTag ]</summary>
		<description>The initial value of the @@toStringTag property is the String value &amp;quot;SharedArrayBuffer&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.2.5">
	<buginformation>
		<summary>Properties of the SharedArrayBuffer Instances</summary>
		<description>SharedArrayBuffer instances inherit properties from the  SharedArrayBuffer prototype object. SharedArrayBuffer instances each  have an [[ArrayBufferData]] internal slot and an  [[ArrayBufferByteLength]] internal slot. Note SharedArrayBuffer instances, unlike ArrayBuffer instances, are never detached.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.1.1">
	<buginformation>
		<summary>GetViewValue ( view, requestIndex, isLittleEndian, type )</summary>
		<description>The abstract operation GetViewValue with arguments view, requestIndex, isLittleEndian, and type is used by functions on DataView instances to retrieve values from the view&apos;s buffer. It performs the following steps: If Type(view) is not Object, throw a TypeError exception.If view does not have a [[DataView]] internal slot, throw a TypeError exception.Assert: view has a [[ViewedArrayBuffer]] internal slot.Let getIndex be ? ToIndex(requestIndex).Set isLittleEndian to ToBoolean(isLittleEndian).Let buffer be view.[[ViewedArrayBuffer]].If IsDetachedBuffer(buffer) is true, throw a TypeError exception.Let viewOffset be view.[[ByteOffset]].Let viewSize be view.[[ByteLength]].Let elementSize be the Number value of the Element Size value specified in Table 50 for Element Type type.If getIndex + elementSize &gt; viewSize, throw a RangeError exception.Let bufferIndex be getIndex + viewOffset.Return GetValueFromBuffer(buffer, bufferIndex, type, false, &amp;quot;Unordered&amp;quot;, isLittleEndian).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.1.2">
	<buginformation>
		<summary>SetViewValue ( view, requestIndex, isLittleEndian, type, value )</summary>
		<description>The abstract operation SetViewValue with arguments view, requestIndex, isLittleEndian, type, and value is used by functions on DataView instances to store values into the view&apos;s buffer. It performs the following steps: If Type(view) is not Object, throw a TypeError exception.If view does not have a [[DataView]] internal slot, throw a TypeError exception.Assert: view has a [[ViewedArrayBuffer]] internal slot.Let getIndex be ? ToIndex(requestIndex).Let numberValue be ? ToNumber(value).Set isLittleEndian to ToBoolean(isLittleEndian).Let buffer be view.[[ViewedArrayBuffer]].If IsDetachedBuffer(buffer) is true, throw a TypeError exception.Let viewOffset be view.[[ByteOffset]].Let viewSize be view.[[ByteLength]].Let elementSize be the Number value of the Element Size value specified in Table 50 for Element Type type.If getIndex + elementSize &gt; viewSize, throw a RangeError exception.Let bufferIndex be getIndex + viewOffset.Return SetValueInBuffer(buffer, bufferIndex, type, numberValue, false, &amp;quot;Unordered&amp;quot;, isLittleEndian).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.2.1">
	<buginformation>
		<summary>DataView ( buffer [ , byteOffset [ , byteLength  ] ] )</summary>
		<description>When the DataView is called with at least one argument buffer, the following steps are taken: If NewTarget is undefined, throw a TypeError exception.If Type(buffer) is not Object, throw a TypeError exception.If buffer does not have an [[ArrayBufferData]] internal slot, throw a TypeError exception.Let offset be ? ToIndex(byteOffset).If IsDetachedBuffer(buffer) is true, throw a TypeError exception.Let bufferByteLength be buffer.[[ArrayBufferByteLength]].If offset &gt; bufferByteLength, throw a RangeError exception.If byteLength is either not present or undefined, thenLet viewByteLength be bufferByteLength - offset.Else,Let viewByteLength be ? ToIndex(byteLength).If offset+viewByteLength &gt; bufferByteLength, throw a RangeError exception.Let O be ? OrdinaryCreateFromConstructor(NewTarget, &amp;quot;%DataViewPrototype%&amp;quot;, « [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] »).Set O.[[ViewedArrayBuffer]] to buffer.Set O.[[ByteLength]] to viewByteLength.Set O.[[ByteOffset]] to offset.Return O.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.3.1">
	<buginformation>
		<summary>DataView.prototype</summary>
		<description>The initial value of DataView.prototype is the intrinsic object %DataViewPrototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.1">
	<buginformation>
		<summary>get DataView.prototype.buffer</summary>
		<description>DataView.prototype.buffer is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let O be the this value.If Type(O) is not Object, throw a TypeError exception.If O does not have a [[DataView]] internal slot, throw a TypeError exception.Assert: O has a [[ViewedArrayBuffer]] internal slot.Let buffer be O.[[ViewedArrayBuffer]].Return buffer.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.2">
	<buginformation>
		<summary>get DataView.prototype.byteLength</summary>
		<description>DataView.prototype.byteLength is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let O be the this value.If Type(O) is not Object, throw a TypeError exception.If O does not have a [[DataView]] internal slot, throw a TypeError exception.Assert: O has a [[ViewedArrayBuffer]] internal slot.Let buffer be O.[[ViewedArrayBuffer]].If IsDetachedBuffer(buffer) is true, throw a TypeError exception.Let size be O.[[ByteLength]].Return size.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.3">
	<buginformation>
		<summary>get DataView.prototype.byteOffset</summary>
		<description>DataView.prototype.byteOffset is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let O be the this value.If Type(O) is not Object, throw a TypeError exception.If O does not have a [[DataView]] internal slot, throw a TypeError exception.Assert: O has a [[ViewedArrayBuffer]] internal slot.Let buffer be O.[[ViewedArrayBuffer]].If IsDetachedBuffer(buffer) is true, throw a TypeError exception.Let offset be O.[[ByteOffset]].Return offset.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.4">
	<buginformation>
		<summary>DataView.prototype.constructor</summary>
		<description>The initial value of DataView.prototype.constructor is the intrinsic object %DataView%.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.5">
	<buginformation>
		<summary>DataView.prototype.getFloat32 ( byteOffset [ , littleEndian ] )</summary>
		<description>When the getFloat32 method is called with argument byteOffset and optional argument littleEndian, the following steps are taken: Let v be the this value.If littleEndian is not present, let littleEndian be false.Return ? GetViewValue(v, byteOffset, littleEndian, &amp;quot;Float32&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.6">
	<buginformation>
		<summary>DataView.prototype.getFloat64 ( byteOffset [ , littleEndian ] )</summary>
		<description>When the getFloat64 method is called with argument byteOffset and optional argument littleEndian, the following steps are taken: Let v be the this value.If littleEndian is not present, let littleEndian be false.Return ? GetViewValue(v, byteOffset, littleEndian, &amp;quot;Float64&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.7">
	<buginformation>
		<summary>DataView.prototype.getInt8 ( byteOffset )</summary>
		<description>When the getInt8 method is called with argument byteOffset, the following steps are taken: Let v be the this value.Return ? GetViewValue(v, byteOffset, true, &amp;quot;Int8&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.8">
	<buginformation>
		<summary>DataView.prototype.getInt16 ( byteOffset [ , littleEndian ] )</summary>
		<description>When the getInt16 method is called with argument byteOffset and optional argument littleEndian, the following steps are taken: Let v be the this value.If littleEndian is not present, let littleEndian be false.Return ? GetViewValue(v, byteOffset, littleEndian, &amp;quot;Int16&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.9">
	<buginformation>
		<summary>DataView.prototype.getInt32 ( byteOffset [ , littleEndian ] )</summary>
		<description>When the getInt32 method is called with argument byteOffset and optional argument littleEndian, the following steps are taken: Let v be the this value.If littleEndian is not present, let littleEndian be undefined.Return ? GetViewValue(v, byteOffset, littleEndian, &amp;quot;Int32&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.10">
	<buginformation>
		<summary>DataView.prototype.getUint8 ( byteOffset )</summary>
		<description>When the getUint8 method is called with argument byteOffset, the following steps are taken: Let v be the this value.Return ? GetViewValue(v, byteOffset, true, &amp;quot;Uint8&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.11">
	<buginformation>
		<summary>DataView.prototype.getUint16 ( byteOffset [ , littleEndian ] )</summary>
		<description>When the getUint16 method is called with argument byteOffset and optional argument littleEndian, the following steps are taken: Let v be the this value.If littleEndian is not present, let littleEndian be false.Return ? GetViewValue(v, byteOffset, littleEndian, &amp;quot;Uint16&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.12">
	<buginformation>
		<summary>DataView.prototype.getUint32 ( byteOffset [ , littleEndian ] )</summary>
		<description>When the getUint32 method is called with argument byteOffset and optional argument littleEndian, the following steps are taken: Let v be the this value.If littleEndian is not present, let littleEndian be false.Return ? GetViewValue(v, byteOffset, littleEndian, &amp;quot;Uint32&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.13">
	<buginformation>
		<summary>DataView.prototype.setFloat32 ( byteOffset, value [ , littleEndian ] )</summary>
		<description>When the setFloat32 method is called with arguments byteOffset and value and optional argument littleEndian, the following steps are taken: Let v be the this value.If littleEndian is not present, let littleEndian be false.Return ? SetViewValue(v, byteOffset, littleEndian, &amp;quot;Float32&amp;quot;, value).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.14">
	<buginformation>
		<summary>DataView.prototype.setFloat64 ( byteOffset, value [ , littleEndian ] )</summary>
		<description>When the setFloat64 method is called with arguments byteOffset and value and optional argument littleEndian, the following steps are taken: Let v be the this value.If littleEndian is not present, let littleEndian be false.Return ? SetViewValue(v, byteOffset, littleEndian, &amp;quot;Float64&amp;quot;, value).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.15">
	<buginformation>
		<summary>DataView.prototype.setInt8 ( byteOffset, value )</summary>
		<description>When the setInt8 method is called with arguments byteOffset and value, the following steps are taken: Let v be the this value.Return ? SetViewValue(v, byteOffset, true, &amp;quot;Int8&amp;quot;, value).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.16">
	<buginformation>
		<summary>DataView.prototype.setInt16 ( byteOffset, value [ , littleEndian ] )</summary>
		<description>When the setInt16 method is called with arguments byteOffset and value and optional argument littleEndian, the following steps are taken: Let v be the this value.If littleEndian is not present, let littleEndian be false.Return ? SetViewValue(v, byteOffset, littleEndian, &amp;quot;Int16&amp;quot;, value).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.17">
	<buginformation>
		<summary>DataView.prototype.setInt32 ( byteOffset, value [ , littleEndian ] )</summary>
		<description>When the setInt32 method is called with arguments byteOffset and value and optional argument littleEndian, the following steps are taken: Let v be the this value.If littleEndian is not present, let littleEndian be false.Return ? SetViewValue(v, byteOffset, littleEndian, &amp;quot;Int32&amp;quot;, value).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.18">
	<buginformation>
		<summary>DataView.prototype.setUint8 ( byteOffset, value )</summary>
		<description>When the setUint8 method is called with arguments byteOffset and value, the following steps are taken: Let v be the this value.Return ? SetViewValue(v, byteOffset, true, &amp;quot;Uint8&amp;quot;, value).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.19">
	<buginformation>
		<summary>DataView.prototype.setUint16 ( byteOffset, value [ , littleEndian ] )</summary>
		<description>When the setUint16 method is called with arguments byteOffset and value and optional argument littleEndian, the following steps are taken: Let v be the this value.If littleEndian is not present, let littleEndian be false.Return ? SetViewValue(v, byteOffset, littleEndian, &amp;quot;Uint16&amp;quot;, value).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.20">
	<buginformation>
		<summary>DataView.prototype.setUint32 ( byteOffset, value [ , littleEndian ] )</summary>
		<description>When the setUint32 method is called with arguments byteOffset and value and optional argument littleEndian, the following steps are taken: Let v be the this value.If littleEndian is not present, let littleEndian be false.Return ? SetViewValue(v, byteOffset, littleEndian, &amp;quot;Uint32&amp;quot;, value).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.4.21">
	<buginformation>
		<summary>DataView.prototype [ @@toStringTag ]</summary>
		<description>The initial value of the @@toStringTag property is the String value &amp;quot;DataView&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.3.5">
	<buginformation>
		<summary>Properties of DataView Instances</summary>
		<description>DataView instances are ordinary objects that inherit properties  from the DataView prototype object. DataView instances each have  [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], and [[ByteOffset]]  internal slots. Note The value of the [[DataView]] internal slot is not used  within this specification. The simple presence of that internal slot is  used within the specification to identify objects created using the DataView constructor.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.1.1">
	<buginformation>
		<summary>ValidateSharedIntegerTypedArray(typedArray [ , onlyInt32 ] )</summary>
		<description>The abstract operation ValidateSharedIntegerTypedArray takes one argument typedArray and an optional Boolean onlyInt32. It performs the following steps: If the onlyInt32 argument was not provided, set onlyInt32 to false.If Type(typedArray) is not Object, throw a TypeError exception.If typedArray does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.Let typeName be typedArray.[[TypedArrayName]].If onlyInt32 is true, thenIf typeName is not &amp;quot;Int32Array&amp;quot;, throw a TypeError exception.Else,If typeName is not &amp;quot;Int8Array&amp;quot;, &amp;quot;Uint8Array&amp;quot;, &amp;quot;Int16Array&amp;quot;, &amp;quot;Uint16Array&amp;quot;, &amp;quot;Int32Array&amp;quot;, or &amp;quot;Uint32Array&amp;quot;, throw a TypeError exception.Assert: typedArray has a [[ViewedArrayBuffer]] internal slot.Let buffer be typedArray.[[ViewedArrayBuffer]].If IsSharedArrayBuffer(buffer) is false, throw a TypeError exception.Return buffer.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.1.2">
	<buginformation>
		<summary>ValidateAtomicAccess( typedArray, requestIndex )</summary>
		<description>The abstract operation ValidateAtomicAccess takes two arguments, typedArray and requestIndex. It performs the following steps: Assert: typedArray is an Object that has a [[ViewedArrayBuffer]] internal slot.Let accessIndex be ? ToIndex(requestIndex).Let length be typedArray.[[ArrayLength]].Assert: accessIndex ≥ 0.If accessIndex ≥ length, throw a RangeError exception.Return accessIndex.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.1.3">
	<buginformation>
		<summary>GetWaiterList( block, i )</summary>
		<description>A  WaiterList is a semantic object that contains an ordered list of those agents that are waiting on a location (block, i) in shared memory; block is a Shared Data Block and i a byte offset into the memory of block. The agent cluster has a store of WaiterList objects; the store is indexed by (block, i). WaiterLists are agent-independent: a lookup in the store of WaiterLists by (block, i) will result in the same WaiterList object in any agent in the agent cluster. Operations on a WaiterList -- adding and removing waiting  agents, traversing the list of agents, suspending and waking agents on  the list -- may only be performed by agents that have entered the  WaiterList&apos;s critical section. The abstract operation GetWaiterList takes two arguments, a Shared Data Block block and a nonnegative integer i. It performs the following steps: Assert: block is a Shared Data Block.Assert: i and i+3 are valid byte offsets within the memory of block.Assert: i is divisible by 4.Return the WaiterList that is referenced by the pair (block, i).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.1.4">
	<buginformation>
		<summary>EnterCriticalSection( WL )</summary>
		<description>The abstract operation EnterCriticalSection takes one argument, a WaiterList WL. It performs the following steps: Assert: The calling agent is not in the critical section for any WaiterList.Wait until no agent is in the critical section for WL, then enter the critical section for WL (without allowing any other agent to enter).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.1.5">
	<buginformation>
		<summary>LeaveCriticalSection( WL )</summary>
		<description>The abstract operation LeaveCriticalSection takes one argument, a WaiterList WL. It performs the following steps: Assert: The calling agent is in the critical section for WL.Leave the critical section for WL.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.1.6">
	<buginformation>
		<summary>AddWaiter( WL, W )</summary>
		<description>The abstract operation AddWaiter takes two arguments, a WaiterList WL and an agent signifier W. It performs the following steps: Assert: The calling agent is in the critical section for WL.Assert: W is not on the list of waiters in any WaiterList.Add W to the end of the list of waiters in WL.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.1.7">
	<buginformation>
		<summary>RemoveWaiter( WL, W )</summary>
		<description>The abstract operation RemoveWaiter takes two arguments, a WaiterList WL and an agent signifier W. It performs the following steps: Assert: The calling agent is in the critical section for WL.Assert: W is on the list of waiters in WL.Remove W from the list of waiters in WL.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.1.8">
	<buginformation>
		<summary>RemoveWaiters( WL, c )</summary>
		<description>The abstract operation RemoveWaiters takes two arguments, a WaiterList WL and nonnegative integer c. It performs the following steps: Assert: The calling agent is in the critical section for WL.Let L be a new empty List.Let S be a reference to the list of waiters in WL.Repeat, while c &gt; 0 and S is not an empty List,Let W be the first waiter in S.Add W to the end of L.Remove W from S.Subtract 1 from c.Return L.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.1.9">
	<buginformation>
		<summary>Suspend( WL, W, timeout )</summary>
		<description>The abstract operation Suspend takes three arguments, a WaiterList WL, an agent signifier W, and a nonnegative, non-NaN Number timeout. It performs the following steps: Assert: The calling agent is in the critical section for WL.Assert: W is equal to AgentSignifier().Assert: W is on the list of waiters in WL.Assert: AgentCanSuspend() is true.Perform LeaveCriticalSection(WL) and suspend W for up to timeout  milliseconds, performing the combined operation in such a way that a  wakeup that arrives after the critical section is exited but before the  suspension takes effect is not lost.  W can wake up either because the timeout expired or because it was woken explicitly by another agent calling WakeWaiter(WL, W), and not for any other reasons at all.Perform EnterCriticalSection(WL).If W was woken explicitly by another agent calling WakeWaiter(WL, W), return true.Return false.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.1.10">
	<buginformation>
		<summary>WakeWaiter( WL, W )</summary>
		<description>The abstract operation WakeWaiter takes two arguments, a WaiterList WL and an agent signifier W. It performs the following steps: Assert: The calling agent is in the critical section for WL.Assert: W is on the list of waiters in WL.Wake the agent W.          Note The embedding may delay waking W, e.g. for resource management reasons, but W must eventually be woken in order to guarantee forward progress.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.1.11">
	<buginformation>
		<summary>AtomicReadModifyWrite( typedArray, index, value, op )</summary>
		<description>The abstract operation AtomicReadModifyWrite takes four arguments, typedArray, index, value, and a pure combining operation op. The pure combining operation op takes two List of byte values arguments and returns a List  of byte values. The operation atomically loads a value, combines it  with another value, and stores the result of the combination. It returns  the loaded value. It performs the following steps: Let buffer be ? ValidateSharedIntegerTypedArray(typedArray).Let i be ? ValidateAtomicAccess(typedArray, index).Let v be ? ToInteger(value).Let arrayTypeName be typedArray.[[TypedArrayName]].Let elementSize be the Number value of the Element Size value specified in Table 50 for arrayTypeName.Let elementType be the String value of the Element Type value in Table 50 for arrayTypeName.Let offset be typedArray.[[ByteOffset]].Let indexedPosition be (i × elementSize) + offset.Return GetModifySetValueInBuffer(buffer, indexedPosition, elementType, v, op).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.1.12">
	<buginformation>
		<summary>AtomicLoad( typedArray, index )</summary>
		<description>The abstract operation AtomicLoad takes two arguments, typedArray, index. The operation atomically loads a value and returns the loaded value. It performs the following steps: Let buffer be ? ValidateSharedIntegerTypedArray(typedArray).Let i be ? ValidateAtomicAccess(typedArray, index).Let arrayTypeName be typedArray.[[TypedArrayName]].Let elementSize be the Number value of the Element Size value specified in Table 50 for arrayTypeName.Let elementType be the String value of the Element Type value in Table 50 for arrayTypeName.Let offset be typedArray.[[ByteOffset]].Let indexedPosition be (i × elementSize) + offset.Return GetValueFromBuffer(buffer, indexedPosition, elementType, true, &amp;quot;SeqCst&amp;quot;).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.2">
	<buginformation>
		<summary>Atomics.add( typedArray, index, value )</summary>
		<description>Let add denote a semantic function of two List of byte values arguments that applies the addition operation to the Number values corresponding to the List of byte values arguments and returns a List of byte values corresponding to the result of that operation. The following steps are taken: Return ? AtomicReadModifyWrite(typedArray, index, value, add).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.3">
	<buginformation>
		<summary>Atomics.and( typedArray, index, value )</summary>
		<description>Let and denote a semantic function of two List of byte values arguments that applies the bitwise-and operation element-wise to the two arguments and returns a List of byte values corresponding to the result of that operation. The following steps are taken: Return ? AtomicReadModifyWrite(typedArray, index, value, and).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.4">
	<buginformation>
		<summary>Atomics.compareExchange( typedArray, index, expectedValue, replacementValue )</summary>
		<description>The following steps are taken: Let buffer be ? ValidateSharedIntegerTypedArray(typedArray).Let i be ? ValidateAtomicAccess(typedArray, index).Let expected be ? ToInteger(expectedValue).Let replacement be ? ToInteger(replacementValue).Let arrayTypeName be typedArray.[[TypedArrayName]].Let elementType be the String value of the Element Type value in Table 50 for arrayTypeName.Let isLittleEndian be the value of the [[LittleEndian]] field of the surrounding agent&apos;s Agent Record.Let expectedBytes be NumberToRawBytes(elementType, expected, isLittleEndian).Let elementSize be the Number value of the Element Size value specified in Table 50 for arrayTypeName.Let offset be typedArray.[[ByteOffset]].Let indexedPosition be (i × elementSize) + offset.Let compareExchange denote a semantic function of two List of byte values arguments that returns the second argument if the first argument is element-wise equal to expectedBytes.Return GetModifySetValueInBuffer(buffer, indexedPosition, elementType, replacement, compareExchange).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.5">
	<buginformation>
		<summary>Atomics.exchange( typedArray, index, value )</summary>
		<description>Let second denote a semantic function of two List of byte values arguments that returns its second argument. The following steps are taken: Return ? AtomicReadModifyWrite(typedArray, index, value, second).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.6">
	<buginformation>
		<summary>Atomics.isLockFree( size )</summary>
		<description>The following steps are taken: Let n be ? ToInteger(size).Let AR be the Agent Record of the surrounding agent.If n equals 1, return AR.[[IsLockFree1]].If n equals 2, return AR.[[IsLockFree2]].If n equals 4, return true.Return false.        Note Atomics.isLockFree() is an optimization primitive. The intuition is that if the atomic step of an atomic primitive (compareExchange, load, store, add, sub, and, or, xor, or exchange) on a datum of size n bytes will be performed without the calling agent acquiring a lock outside the n bytes comprising the datum, then Atomics.isLockFree(n) will return true.  High-performance algorithms will use Atomics.isLockFree to determine  whether to use locks or atomic operations in critical sections. If an  atomic primitive is not lock-free then it is often more efficient for an  algorithm to provide its own locking. Atomics.isLockFree(4) always returns true as that can be supported on all known relevant hardware. Being able to assume this will generally simplify programs.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.7">
	<buginformation>
		<summary>Atomics.load( typedArray, index )</summary>
		<description>The following steps are taken: Return ? AtomicLoad(typedArray, index).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.8">
	<buginformation>
		<summary>Atomics.or( typedArray, index, value )</summary>
		<description>Let or denote a semantic function of two List of byte values arguments that applies the bitwise-or operation element-wise to the two arguments and returns a List of byte values corresponding to the result of that operation. The following steps are taken: Return ? AtomicReadModifyWrite(typedArray, index, value, or).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.9">
	<buginformation>
		<summary>Atomics.store( typedArray, index, value )</summary>
		<description>The following steps are taken: Let buffer be ? ValidateSharedIntegerTypedArray(typedArray).Let i be ? ValidateAtomicAccess(typedArray, index).Let v be ? ToInteger(value).Let arrayTypeName be typedArray.[[TypedArrayName]].Let elementSize be the Number value of the Element Size value specified in Table 50 for arrayTypeName.Let elementType be the String value of the Element Type value in Table 50 for arrayTypeName.Let offset be typedArray.[[ByteOffset]].Let indexedPosition be (i × elementSize) + offset.Perform SetValueInBuffer(buffer, indexedPosition, elementType, v, true, &amp;quot;SeqCst&amp;quot;).Return v.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.10">
	<buginformation>
		<summary>Atomics.sub( typedArray, index, value )</summary>
		<description>Let subtract denote a semantic function of two List of byte values arguments that applies the subtraction operation to the Number values corresponding to the List of byte values arguments and returns a List of byte values corresponding to the result of that operation. The following steps are taken: Return ? AtomicReadModifyWrite(typedArray, index, value, subtract).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.11">
	<buginformation>
		<summary>Atomics.wait( typedArray, index, value, timeout )</summary>
		<description>Atomics.wait puts the calling agent in a wait queue and puts it to sleep until it is awoken or the sleep times out. The following steps are taken: Let buffer be ? ValidateSharedIntegerTypedArray(typedArray, true).Let i be ? ValidateAtomicAccess(typedArray, index).Let v be ? ToInt32(value).Let q be ? ToNumber(timeout).If q is NaN, let t be +∞, else let t be max(q, 0).Let B be AgentCanSuspend().If B is false, throw a TypeError exception.Let block be buffer.[[ArrayBufferData]].Let offset be typedArray.[[ByteOffset]].Let indexedPosition be (i × 4) + offset.Let WL be GetWaiterList(block, indexedPosition).Perform EnterCriticalSection(WL).Let w be ! AtomicLoad(typedArray, i).If v is not equal to w, thenPerform LeaveCriticalSection(WL).Return the String &amp;quot;not-equal&amp;quot;.Let W be AgentSignifier().Perform AddWaiter(WL, W).Let awoken be Suspend(WL, W, t).Perform RemoveWaiter(WL, W).Perform LeaveCriticalSection(WL).If awoken is true, return the String &amp;quot;ok&amp;quot;.Return the String &amp;quot;timed-out&amp;quot;.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.12">
	<buginformation>
		<summary>Atomics.wake( typedArray, index, count )</summary>
		<description>Atomics.wake wakes up some agents that are sleeping in the wait queue.  The following steps are taken: Let buffer be ? ValidateSharedIntegerTypedArray(typedArray, true).Let i be ? ValidateAtomicAccess(typedArray, index).If count is undefined, let c be +∞.Else,Let intCount be ? ToInteger(count).Let c be max(intCount, 0).Let block be buffer.[[ArrayBufferData]].Let offset be typedArray.[[ByteOffset]].Let indexedPosition be (i × 4) + offset.Let WL be GetWaiterList(block, indexedPosition).Let n be 0.Perform EnterCriticalSection(WL).Let S be RemoveWaiters(WL, c).Repeat, while S is not an empty List,Let W be the first agent in S.Remove W from the front of S.Perform WakeWaiter(WL, W).Add 1 to n.Perform LeaveCriticalSection(WL).Return n.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.13">
	<buginformation>
		<summary>Atomics.xor( typedArray, index, value )</summary>
		<description>Let xor denote a semantic function of two List of byte values arguments that applies the bitwise-xor operation element-wise to the two arguments and returns a List of byte values corresponding to the result of that operation. The following steps are taken: Return ? AtomicReadModifyWrite(typedArray, index, value, xor).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.4.14">
	<buginformation>
		<summary>Atomics [ @@toStringTag ]</summary>
		<description>The initial value of the @@toStringTag property is the String value &amp;quot;Atomics&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.5.1.1">
	<buginformation>
		<summary>Runtime Semantics: InternalizeJSONProperty( holder, name )</summary>
		<description>The abstract operation InternalizeJSONProperty is a recursive abstract operation that takes two parameters: a holder object and the String name of a property in that object. InternalizeJSONProperty uses the value of reviver that was originally passed to the above parse function. Let val be ? Get(holder, name).If Type(val) is Object, thenLet isArray be ? IsArray(val).If isArray is true, thenLet I be 0.Let len be ? ToLength(? Get(val, &amp;quot;length&amp;quot;)).Repeat, while I &lt; len,Let newElement be ? InternalizeJSONProperty(val, ! ToString(I)).If newElement is undefined, thenPerform ? val.[[Delete]](! ToString(I)).Else,Perform ? CreateDataProperty(val, ! ToString(I), newElement).NOTE: This algorithm intentionally does not throw an exception if CreateDataProperty returns false.Add 1 to I.Else,Let keys be ? EnumerableOwnProperties(val, &amp;quot;key&amp;quot;).For each String P in keys, doLet newElement be ? InternalizeJSONProperty(val, P).If newElement is undefined, thenPerform ? val.[[Delete]](P).Else,Perform ? CreateDataProperty(val, P, newElement).NOTE: This algorithm intentionally does not throw an exception if CreateDataProperty returns false.Return ? Call(reviver, holder, « name, val »).          It is not permitted for a conforming implementation of JSON.parse  to extend the JSON grammars. If an implementation wishes to support a  modified or extended JSON interchange format it must do so by defining a  different parse function. Note In the case where there are duplicate name Strings within  an object, lexically preceding values for the same key shall be  overwritten.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.5.2.1">
	<buginformation>
		<summary>Runtime Semantics: SerializeJSONProperty ( key, holder )</summary>
		<description>The abstract operation SerializeJSONProperty with arguments key, and holder has access to ReplacerFunction from the invocation of the stringify method. Its algorithm is as follows: Let value be ? Get(holder, key).If Type(value) is Object, thenLet toJSON be ? Get(value, &amp;quot;toJSON&amp;quot;).If IsCallable(toJSON) is true, thenSet value to ? Call(toJSON, value, « key »).If ReplacerFunction is not undefined, thenSet value to ? Call(ReplacerFunction, holder, « key, value »).If Type(value) is Object, thenIf value has a [[NumberData]] internal slot, thenSet value to ? ToNumber(value).Else if value has a [[StringData]] internal slot, thenSet value to ? ToString(value).Else if value has a [[BooleanData]] internal slot, thenSet value to value.[[BooleanData]].If value is null, return &amp;quot;null&amp;quot;.If value is true, return &amp;quot;true&amp;quot;.If value is false, return &amp;quot;false&amp;quot;.If Type(value) is String, return QuoteJSONString(value).If Type(value) is Number, thenIf value is finite, return ! ToString(value).Return &amp;quot;null&amp;quot;.If Type(value) is Object and IsCallable(value) is false, thenLet isArray be ? IsArray(value).If isArray is true, return ? SerializeJSONArray(value).Return ? SerializeJSONObject(value).Return undefined.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.5.2.2">
	<buginformation>
		<summary>Runtime Semantics: QuoteJSONString ( value )</summary>
		<description>The abstract operation QuoteJSONString with argument value wraps a String value in QUOTATION MARK code units and escapes certain other code units within it. Let product be code unit 0x0022 (QUOTATION MARK).For each code unit C in value, doIf C is 0x0022 (QUOTATION MARK) or 0x005C (REVERSE SOLIDUS), thenSet product to the concatenation of product and code unit 0x005C (REVERSE SOLIDUS).Set product to the concatenation of product and C.Else if C is 0x0008 (BACKSPACE), 0x000C (FORM FEED), 0x000A (LINE FEED), 0x000D (CARRIAGE RETURN), or 0x0009 (CHARACTER TABULATION), thenSet product to the concatenation of product and code unit 0x005C (REVERSE SOLIDUS).Let abbrev be the String value corresponding to the value of C as follows:                                           BACKSPACE                       &amp;quot;b&amp;quot;                           FORM FEED (FF)                       &amp;quot;f&amp;quot;                           LINE FEED (LF)                       &amp;quot;n&amp;quot;                           CARRIAGE RETURN (CR)                       &amp;quot;r&amp;quot;                           CHARACTER TABULATION                       &amp;quot;t&amp;quot;    Set product to the concatenation of product and abbrev.Else if C has a code unit value less than 0x0020 (SPACE), thenSet product to the concatenation of product and code unit 0x005C (REVERSE SOLIDUS).Set product to the concatenation of product and &amp;quot;u&amp;quot;.Let hex be the string result of converting the numeric code unit value of C to a String of four lowercase hexadecimal digits.Set product to the concatenation of product and hex.Else,Set product to the concatenation of product and C.Set product to the concatenation of product and code unit 0x0022 (QUOTATION MARK).Return product.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.5.2.3">
	<buginformation>
		<summary>Runtime Semantics: SerializeJSONObject ( value )</summary>
		<description>The abstract operation SerializeJSONObject with argument value serializes an object. It has access to the stack, indent, gap, and PropertyList values of the current invocation of the stringify method. If stack contains value, throw a TypeError exception because the structure is cyclical.Append value to stack.Let stepback be indent.Set indent to the concatenation of indent and gap.If PropertyList is not undefined, thenLet K be PropertyList.Else,Let K be ? EnumerableOwnProperties(value, &amp;quot;key&amp;quot;).Let partial be a new empty List.For each element P of K, doLet strP be ? SerializeJSONProperty(P, value).If strP is not undefined, thenLet member be QuoteJSONString(P).Set member to the concatenation of member and the String &amp;quot;:&amp;quot;.If gap is not the empty String, thenSet member to the concatenation of member and code unit 0x0020 (SPACE).Set member to the concatenation of member and strP.Append member to partial.If partial is empty, thenLet final be &amp;quot;{}&amp;quot;.Else,If gap is the empty String, thenLet properties be a String formed by concatenating all the element Strings of partial  with each adjacent pair of Strings separated with code unit 0x002C  (COMMA). A comma is not inserted either before the first String or after  the last String.Let final be the result of concatenating &amp;quot;{&amp;quot;, properties, and &amp;quot;}&amp;quot;.Else gap is not the empty String,Let separator be the result of concatenating code unit 0x002C (COMMA), code unit 0x000A (LINE FEED), and indent.Let properties be a String formed by concatenating all the element Strings of partial with each adjacent pair of Strings separated with separator. The separator String is not inserted either before the first String or after the last String.Let final be the result of concatenating &amp;quot;{&amp;quot;, code unit 0x000A (LINE FEED), indent, properties, code unit 0x000A (LINE FEED), stepback, and &amp;quot;}&amp;quot;.Remove the last element of stack.Set indent to stepback.Return final.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.5.2.4">
	<buginformation>
		<summary>Runtime Semantics: SerializeJSONArray ( value )</summary>
		<description>The abstract operation SerializeJSONArray with argument value serializes an array. It has access to the stack, indent, and gap values of the current invocation of the stringify method. If stack contains value, throw a TypeError exception because the structure is cyclical.Append value to stack.Let stepback be indent.Set indent to the concatenation of indent and gap.Let partial be a new empty List.Let len be ? ToLength(? Get(value, &amp;quot;length&amp;quot;)).Let index be 0.Repeat, while index &lt; lenLet strP be ? SerializeJSONProperty(! ToString(index), value).If strP is undefined, thenAppend &amp;quot;null&amp;quot; to partial.Else,Append strP to partial.Increment index by 1.If partial is empty, thenLet final be &amp;quot;[]&amp;quot;.Else,If gap is the empty String, thenLet properties be a String formed by concatenating all the element Strings of partial  with each adjacent pair of Strings separated with code unit 0x002C  (COMMA). A comma is not inserted either before the first String or after  the last String.Let final be the result of concatenating &amp;quot;[&amp;quot;, properties, and &amp;quot;]&amp;quot;.Else,Let separator be the result of concatenating code unit 0x002C (COMMA), code unit 0x000A (LINE FEED), and indent.Let properties be a String formed by concatenating all the element Strings of partial with each adjacent pair of Strings separated with separator. The separator String is not inserted either before the first String or after the last String.Let final be the result of concatenating &amp;quot;[&amp;quot;, code unit 0x000A (LINE FEED), indent, properties, code unit 0x000A (LINE FEED), stepback, and &amp;quot;]&amp;quot;.Remove the last element of stack.Set indent to stepback.Return final.          Note The representation of arrays includes only the elements between zero and  array.length - 1  inclusive. Properties whose keys are not array indexes are excluded  from the stringification. An array is stringified as an opening LEFT  SQUARE BRACKET, elements separated by COMMA, and a closing RIGHT SQUARE  BRACKET.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="24.5.3">
	<buginformation>
		<summary>JSON [ @@toStringTag ]</summary>
		<description>The initial value of the @@toStringTag property is the String value &amp;quot;JSON&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.1.1.1">
	<buginformation>
		<summary>The  Iterable Interface</summary>
		<description>The  Iterable interface includes the property described in  Table 53: Table 53:  Iterable Interface Required Properties                     Property                                                Value                                                Requirements                                  @@iterator                   A function that returns an  Iterator object.                                                The returned object must conform to the  Iterator interface.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.1.1.2">
	<buginformation>
		<summary>The  Iterator Interface</summary>
		<description>An object that implements the  Iterator interface must include the property in  Table 54. Such objects may also implement the properties in  Table 55. Table 54:  Iterator Interface Required Properties                     Property                                                Value                                                Requirements                                  next                   A function that returns an  IteratorResult object.                                                The returned object must conform to the  IteratorResult interface. If a previous call to the next method of an  Iterator has returned an  IteratorResult object whose done property is true, then all subsequent calls to the next method of that object should also return an  IteratorResult object whose done property is true. However, this requirement is not enforced.                                   Note 1 Arguments may be passed to the next function but their interpretation and validity is dependent upon the target  Iterator. The for-of statement and other common users of  Iterators do not pass any arguments, so  Iterator objects that expect to be used in such a manner must be prepared to deal with being called with no arguments.  Table 55:  Iterator Interface Optional Properties                     Property                                                Value                                                Requirements                                  return                   A function that returns an  IteratorResult object.                                                The returned object must conform to the  IteratorResult interface. Invoking this method notifies the  Iterator object that the caller does not intend to make any more next method calls to the  Iterator. The returned  IteratorResult object will typically have a done property whose value is true, and a value property with the value passed as the argument of the return method. However, this requirement is not enforced.                                  throw                   A function that returns an  IteratorResult object.                                                The returned object must conform to the  IteratorResult interface. Invoking this method notifies the  Iterator  object that the caller has detected an error condition. The argument  may be used to identify the error condition and typically will be an  exception object. A typical response is to throw the value passed as the argument. If the method does not throw, the returned  IteratorResult object will typically have a done property whose value is true.                                   Note 2 Typically callers of these methods should check for their  existence before invoking them. Certain ECMAScript language features  including for-of, yield*, and  array destructuring call these methods after performing an existence  check. Most ECMAScript library functions that accept  Iterable objects as arguments also conditionally call them.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.1.1.3">
	<buginformation>
		<summary>The IteratorResult Interface</summary>
		<description>The  IteratorResult interface includes the properties listed in  Table 56: Table 56:  IteratorResult Interface Properties                     Property                                                Value                                                Requirements                                  done                   Either true or false.                                                This is the result status of an  iterator next method call. If the end of the iterator was reached done is true. If the end was not reached done is false and a value is available. If a done property (either own or inherited) does not exist, it is consider to have the value false.                                  value                   Any ECMAScript language value.                                                If done is false, this is the current iteration element value. If done is true, this is the return value of the iterator, if it supplied one. If the iterator does not have a return value, value is undefined. In that case, the value property may be absent from the conforming object if it does not inherit an explicit value property.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.1.2.1">
	<buginformation>
		<summary>%IteratorPrototype% [ @@iterator ] ( )</summary>
		<description>The following steps are taken: Return the this value.          The value of the name property of this function is &amp;quot;[Symbol.iterator]&amp;quot;.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.2.1.1">
	<buginformation>
		<summary>GeneratorFunction ( p1, p2, … , pn, body )</summary>
		<description>The last argument specifies the body (executable code) of a  generator function; any preceding arguments specify formal parameters. When the GeneratorFunction function is called with some arguments p1, p2, … , pn, body (where n might be 0, that is, there are no “p” arguments, and where body might also not be provided), the following steps are taken: Let C be the active function object.Let args be the argumentsList that was passed to this function by [[Call]] or [[Construct]].Return ? CreateDynamicFunction(C, NewTarget, &amp;quot;generator&amp;quot;, args).          Note See NOTE for  19.2.1.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.2.2.1">
	<buginformation>
		<summary>GeneratorFunction.length</summary>
		<description>This is a data property with a value of 1. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.2.2.2">
	<buginformation>
		<summary>GeneratorFunction.prototype</summary>
		<description>The initial value of GeneratorFunction.prototype is the intrinsic object %Generator%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.2.3.1">
	<buginformation>
		<summary>GeneratorFunction.prototype.constructor</summary>
		<description>The initial value of GeneratorFunction.prototype.constructor is the intrinsic object %GeneratorFunction%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.2.3.2">
	<buginformation>
		<summary>GeneratorFunction.prototype.prototype</summary>
		<description>The value of GeneratorFunction.prototype.prototype is the %GeneratorPrototype% intrinsic object. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.2.3.3">
	<buginformation>
		<summary>GeneratorFunction.prototype [ @@toStringTag ]</summary>
		<description>The initial value of the @@toStringTag property is the String value &amp;quot;GeneratorFunction&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.2.4.1">
	<buginformation>
		<summary>length</summary>
		<description>The specification for the length property of Function instances given in  19.2.4.1 also applies to GeneratorFunction instances.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.2.4.2">
	<buginformation>
		<summary>name</summary>
		<description>The specification for the name property of Function instances given in  19.2.4.2 also applies to GeneratorFunction instances.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.2.4.3">
	<buginformation>
		<summary>prototype</summary>
		<description>Whenever a GeneratorFunction instance is created another  ordinary object is also created and is the initial value of the  generator function&apos;s prototype property. The value of the  prototype property is used to initialize the [[Prototype]] internal slot  of a newly created Generator object when the generator function object  is invoked using [[Call]]. This property has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }. Note Unlike Function instances, the object that is the value of the a GeneratorFunction&apos;s prototype property does not have a constructor property whose value is the GeneratorFunction instance.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.3.1.1">
	<buginformation>
		<summary>Generator.prototype.constructor</summary>
		<description>The initial value of Generator.prototype.constructor is the intrinsic object %Generator%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.3.1.2">
	<buginformation>
		<summary>Generator.prototype.next ( value )</summary>
		<description>The next method performs the following steps: Let g be the this value.Return ? GeneratorResume(g, value).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.3.1.3">
	<buginformation>
		<summary>Generator.prototype.return ( value )</summary>
		<description>The return method performs the following steps: Let g be the this value.Let C be Completion{[[Type]]: return, [[Value]]: value, [[Target]]: empty}.Return ? GeneratorResumeAbrupt(g, C).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.3.1.4">
	<buginformation>
		<summary>Generator.prototype.throw ( exception )</summary>
		<description>The throw method performs the following steps: Let g be the this value.Let C be Completion{[[Type]]: throw, [[Value]]: exception, [[Target]]: empty}.Return ? GeneratorResumeAbrupt(g, C).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.3.1.5">
	<buginformation>
		<summary>Generator.prototype [ @@toStringTag ]</summary>
		<description>The initial value of the @@toStringTag property is the String value &amp;quot;Generator&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.3.2">
	<buginformation>
		<summary>Properties of Generator Instances</summary>
		<description>Generator instances are initially created with the internal slots described in  Table 57. Table 57: Internal Slots of Generator Instances                   Internal Slot                                          Description                                            [[GeneratorState]]                                          The current execution state of the generator. The possible values are: undefined, &amp;quot;suspendedStart&amp;quot;, &amp;quot;suspendedYield&amp;quot;, &amp;quot;executing&amp;quot;, and &amp;quot;completed&amp;quot;.                                            [[GeneratorContext]]                                          The execution context that is used when executing the code of this generator.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.3.3.1">
	<buginformation>
		<summary>GeneratorStart ( generator, generatorBody )</summary>
		<description>The abstract operation GeneratorStart with arguments generator and generatorBody performs the following steps: Assert: The value of generator.[[GeneratorState]] is undefined.Let genContext be the running execution context.Set the Generator component of genContext to generator.Set the code evaluation state of genContext such that when evaluation is resumed for that execution context the following steps will be performed:Let result be the result of evaluating generatorBody.Assert: If we return here, the generator either threw an exception or performed either an implicit or explicit return.Remove genContext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.Set generator.[[GeneratorState]] to &amp;quot;completed&amp;quot;.Once a generator enters the &amp;quot;completed&amp;quot; state it never leaves it and its associated execution context is never resumed. Any execution state associated with generator can be discarded at this point.If result.[[Type]] is normal, let resultValue be undefined.Else if result.[[Type]] is return, let resultValue be result.[[Value]].Else,Assert: result.[[Type]] is throw.Return Completion(result).Return CreateIterResultObject(resultValue, true).Set generator.[[GeneratorContext]] to genContext.Set generator.[[GeneratorState]] to &amp;quot;suspendedStart&amp;quot;.Return NormalCompletion(undefined).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.3.3.2">
	<buginformation>
		<summary>GeneratorValidate ( generator )</summary>
		<description>The abstract operation GeneratorValidate with argument generator performs the following steps: If Type(generator) is not Object, throw a TypeError exception.If generator does not have a [[GeneratorState]] internal slot, throw a TypeError exception.Assert: generator also has a [[GeneratorContext]] internal slot.Let state be generator.[[GeneratorState]].If state is &amp;quot;executing&amp;quot;, throw a TypeError exception.Return state.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.3.3.3">
	<buginformation>
		<summary>GeneratorResume ( generator, value )</summary>
		<description>The abstract operation GeneratorResume with arguments generator and value performs the following steps: Let state be ? GeneratorValidate(generator).If state is &amp;quot;completed&amp;quot;, return CreateIterResultObject(undefined, true).Assert: state is either &amp;quot;suspendedStart&amp;quot; or &amp;quot;suspendedYield&amp;quot;.Let genContext be generator.[[GeneratorContext]].Let methodContext be the running execution context.Suspend methodContext.Set generator.[[GeneratorState]] to &amp;quot;executing&amp;quot;.Push genContext onto the execution context stack; genContext is now the running execution context.Resume the suspended evaluation of genContext using NormalCompletion(value) as the result of the operation that suspended it. Let result be the value returned by the resumed computation.Assert: When we return here, genContext has already been removed from the execution context stack and methodContext is the currently running execution context.Return Completion(result).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.3.3.4">
	<buginformation>
		<summary>GeneratorResumeAbrupt ( generator, abruptCompletion )</summary>
		<description>The abstract operation GeneratorResumeAbrupt with arguments generator and abruptCompletion performs the following steps: Let state be ? GeneratorValidate(generator).If state is &amp;quot;suspendedStart&amp;quot;, thenSet generator.[[GeneratorState]] to &amp;quot;completed&amp;quot;.Once a generator enters the &amp;quot;completed&amp;quot; state it never leaves it and its associated execution context is never resumed. Any execution state associated with generator can be discarded at this point.Set state to &amp;quot;completed&amp;quot;.If state is &amp;quot;completed&amp;quot;, thenIf abruptCompletion.[[Type]] is return, thenReturn CreateIterResultObject(abruptCompletion.[[Value]], true).Return Completion(abruptCompletion).Assert: state is &amp;quot;suspendedYield&amp;quot;.Let genContext be generator.[[GeneratorContext]].Let methodContext be the running execution context.Suspend methodContext.Set generator.[[GeneratorState]] to &amp;quot;executing&amp;quot;.Push genContext onto the execution context stack; genContext is now the running execution context.Resume the suspended evaluation of genContext using abruptCompletion as the result of the operation that suspended it. Let result be the completion record returned by the resumed computation.Assert: When we return here, genContext has already been removed from the execution context stack and methodContext is the currently running execution context.Return Completion(result).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.3.3.5">
	<buginformation>
		<summary>GeneratorYield ( iterNextObj )</summary>
		<description>The abstract operation GeneratorYield with argument iterNextObj performs the following steps: Assert: iterNextObj is an Object that implements the IteratorResult interface.Let genContext be the running execution context.Assert: genContext is the execution context of a generator.Let generator be the value of the Generator component of genContext.Set generator.[[GeneratorState]] to &amp;quot;suspendedYield&amp;quot;.Remove genContext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.Set the code evaluation state of genContext such that when evaluation is resumed with a Completion resumptionValue the following steps will be performed:Return resumptionValue.NOTE: This returns to the evaluation of the YieldExpression that originally called this abstract operation.Return NormalCompletion(iterNextObj).NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of genContext.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.1.1.1">
	<buginformation>
		<summary>IfAbruptRejectPromise ( value, capability )</summary>
		<description>IfAbruptRejectPromise is a short hand for a sequence of algorithm steps that use a PromiseCapability Record. An algorithm step of the form: IfAbruptRejectPromise(value, capability).            means the same thing as: If value is an abrupt completion, thenPerform ? Call(capability.[[Reject]], undefined, « value.[[Value]] »).Return capability.[[Promise]].Else if value is a Completion Record, let value be value.[[Value]].</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.1.2">
	<buginformation>
		<summary>PromiseReaction Records</summary>
		<description>The PromiseReaction is a Record  value used to store information about how a promise should react when  it becomes resolved or rejected with a given value. PromiseReaction  records are created by the PerformPromiseThen abstract operation, and are used by a PromiseReactionJob. PromiseReaction records have the fields listed in  Table 59. Table 59: PromiseReaction Record Fields                     Field Name                                                Value                                                Meaning                                                  [[Capability]]                                                A PromiseCapability Record                   The capabilities of the promise for which this record provides a reaction handler.                                                  [[Type]]                                                Either &amp;quot;Fulfill&amp;quot; or &amp;quot;Reject&amp;quot;.                                                The [[Type]] is used when [[Handler]] is undefined to allow for behaviour specific to the settlement type.                                                  [[Handler]]                                                A function object or undefined.                                                The function that should be applied to the incoming  value, and whose return value will govern what happens to the derived  promise. If [[Handler]] is undefined, a function that depends on the value of [[Type]] will be used instead.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.1.3.1">
	<buginformation>
		<summary>Promise Reject Functions</summary>
		<description>A promise reject function is an anonymous built-in function that has [[Promise]] and [[AlreadyResolved]] internal slots. When a promise reject function F is called with argument reason, the following steps are taken: Assert: F has a [[Promise]] internal slot whose value is an Object.Let promise be F.[[Promise]].Let alreadyResolved be F.[[AlreadyResolved]].If alreadyResolved.[[Value]] is true, return undefined.Set alreadyResolved.[[Value]] to true.Return RejectPromise(promise, reason).            The length property of a promise reject function is 1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.1.3.2">
	<buginformation>
		<summary>Promise Resolve Functions</summary>
		<description>A promise resolve function is an anonymous built-in function that has [[Promise]] and [[AlreadyResolved]] internal slots. When a promise resolve function F is called with argument resolution, the following steps are taken: Assert: F has a [[Promise]] internal slot whose value is an Object.Let promise be F.[[Promise]].Let alreadyResolved be F.[[AlreadyResolved]].If alreadyResolved.[[Value]] is true, return undefined.Set alreadyResolved.[[Value]] to true.If SameValue(resolution, promise) is true, thenLet selfResolutionError be a newly created TypeError object.Return RejectPromise(promise, selfResolutionError).If Type(resolution) is not Object, thenReturn FulfillPromise(promise, resolution).Let then be Get(resolution, &amp;quot;then&amp;quot;).If then is an abrupt completion, thenReturn RejectPromise(promise, then.[[Value]]).Let thenAction be then.[[Value]].If IsCallable(thenAction) is false, thenReturn FulfillPromise(promise, resolution).Perform EnqueueJob(&amp;quot;PromiseJobs&amp;quot;, PromiseResolveThenableJob, « promise, resolution, thenAction »).Return undefined.            The length property of a promise resolve function is 1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.1.4">
	<buginformation>
		<summary>FulfillPromise ( promise, value )</summary>
		<description>When the FulfillPromise abstract operation is called with arguments promise and value, the following steps are taken: Assert: The value of promise.[[PromiseState]] is &amp;quot;pending&amp;quot;.Let reactions be promise.[[PromiseFulfillReactions]].Set promise.[[PromiseResult]] to value.Set promise.[[PromiseFulfillReactions]] to undefined.Set promise.[[PromiseRejectReactions]] to undefined.Set promise.[[PromiseState]] to &amp;quot;fulfilled&amp;quot;.Return TriggerPromiseReactions(reactions, value).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.1.5.1">
	<buginformation>
		<summary>GetCapabilitiesExecutor Functions</summary>
		<description>A GetCapabilitiesExecutor function is an anonymous built-in function that has a [[Capability]] internal slot. When a GetCapabilitiesExecutor function F is called with arguments resolve and reject, the following steps are taken: Assert: F has a [[Capability]] internal slot whose value is a PromiseCapability Record.Let promiseCapability be F.[[Capability]].If promiseCapability.[[Resolve]] is not undefined, throw a TypeError exception.If promiseCapability.[[Reject]] is not undefined, throw a TypeError exception.Set promiseCapability.[[Resolve]] to resolve.Set promiseCapability.[[Reject]] to reject.Return undefined.            The length property of a GetCapabilitiesExecutor function is 2.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.1.6">
	<buginformation>
		<summary>IsPromise ( x )</summary>
		<description>The abstract operation IsPromise checks for the promise brand on an object. If Type(x) is not Object, return false.If x does not have a [[PromiseState]] internal slot, return false.Return true.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.1.7">
	<buginformation>
		<summary>RejectPromise ( promise, reason )</summary>
		<description>When the RejectPromise abstract operation is called with arguments promise and reason, the following steps are taken: Assert: The value of promise.[[PromiseState]] is &amp;quot;pending&amp;quot;.Let reactions be promise.[[PromiseRejectReactions]].Set promise.[[PromiseResult]] to reason.Set promise.[[PromiseFulfillReactions]] to undefined.Set promise.[[PromiseRejectReactions]] to undefined.Set promise.[[PromiseState]] to &amp;quot;rejected&amp;quot;.If promise.[[PromiseIsHandled]] is false, perform HostPromiseRejectionTracker(promise, &amp;quot;reject&amp;quot;).Return TriggerPromiseReactions(reactions, reason).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.1.8">
	<buginformation>
		<summary>TriggerPromiseReactions ( reactions, argument )</summary>
		<description>The abstract operation TriggerPromiseReactions takes a  collection of PromiseReactionRecords and enqueues a new Job for each  record. Each such Job processes the [[Type]] and [[Handler]] of the  PromiseReactionRecord, and if the [[Handler]] is a function, calls it  passing the given argument. If the [[Handler]] is undefined, the behaviour is determined by the [[Type]]. For each reaction in reactions, in original insertion order, doPerform EnqueueJob(&amp;quot;PromiseJobs&amp;quot;, PromiseReactionJob, « reaction, argument »).Return undefined.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.1.9">
	<buginformation>
		<summary>HostPromiseRejectionTracker ( promise, operation )</summary>
		<description>HostPromiseRejectionTracker is an implementation-defined  abstract operation that allows host environments to track promise  rejections. An implementation of HostPromiseRejectionTracker must  complete normally in all cases. The default implementation of  HostPromiseRejectionTracker is to unconditionally return an empty normal  completion. Note 1 HostPromiseRejectionTracker is called in two scenarios:  When a promise is rejected without any handlers, it is called with its operation argument set to &amp;quot;reject&amp;quot;. When a handler is added to a rejected promise for the first time, it is called with its operation argument set to &amp;quot;handle&amp;quot;.  A typical implementation of HostPromiseRejectionTracker  might try to notify developers of unhandled rejections, while also being  careful to notify them if such previous notifications are later  invalidated by new handlers being attached.  Note 2 If operation is &amp;quot;handle&amp;quot;, an implementation should not hold a reference to promise in a way that would interfere with garbage collection. An implementation may hold a reference to promise if operation is &amp;quot;reject&amp;quot;, since it is expected that rejections will be rare and not on hot code paths.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.2.1">
	<buginformation>
		<summary>PromiseReactionJob ( reaction, argument )</summary>
		<description>The job PromiseReactionJob with parameters reaction and argument  applies the appropriate handler to the incoming value, and uses the  handler&apos;s return value to resolve or reject the derived promise  associated with that handler. Assert: reaction is a PromiseReaction Record.Let promiseCapability be reaction.[[Capability]].Let type be reaction.[[Type]].Let handler be reaction.[[Handler]].If handler is undefined, thenIf type is &amp;quot;Fulfill&amp;quot;, let handlerResult be NormalCompletion(argument).Else,Assert: type is &amp;quot;Reject&amp;quot;.Let handlerResult be Completion {[[Type]]: throw, [[Value]]: argument, [[Target]]: empty}.Else, let handlerResult be Call(handler, undefined, « argument »).If handlerResult is an abrupt completion, thenLet status be Call(promiseCapability.[[Reject]], undefined, « handlerResult.[[Value]] »).Else,Let status be Call(promiseCapability.[[Resolve]], undefined, « handlerResult.[[Value]] »).Return Completion(status).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.2.2">
	<buginformation>
		<summary>PromiseResolveThenableJob ( promiseToResolve, thenable, then )</summary>
		<description>The job PromiseResolveThenableJob with parameters promiseToResolve, thenable, and then performs the following steps: Let resolvingFunctions be CreateResolvingFunctions(promiseToResolve).Let thenCallResult be Call(then, thenable, « resolvingFunctions.[[Resolve]], resolvingFunctions.[[Reject]] »).If thenCallResult is an abrupt completion, thenLet status be Call(resolvingFunctions.[[Reject]], undefined, « thenCallResult.[[Value]] »).Return Completion(status).Return Completion(thenCallResult).          Note This Job uses the supplied thenable and its then method to resolve the given promise. This process must take place as a Job to ensure that the evaluation of the then method occurs after evaluation of any surrounding code has completed.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.3.1">
	<buginformation>
		<summary>Promise ( executor )</summary>
		<description>When the Promise function is called with argument executor, the following steps are taken: If NewTarget is undefined, throw a TypeError exception.If IsCallable(executor) is false, throw a TypeError exception.Let promise be ? OrdinaryCreateFromConstructor(NewTarget, &amp;quot;%PromisePrototype%&amp;quot;, « [[PromiseState]], [[PromiseResult]], [[PromiseFulfillReactions]], [[PromiseRejectReactions]], [[PromiseIsHandled]] »).Set promise.[[PromiseState]] to &amp;quot;pending&amp;quot;.Set promise.[[PromiseFulfillReactions]] to a new empty List.Set promise.[[PromiseRejectReactions]] to a new empty List.Set promise.[[PromiseIsHandled]] to false.Let resolvingFunctions be CreateResolvingFunctions(promise).Let completion be Call(executor, undefined, « resolvingFunctions.[[Resolve]], resolvingFunctions.[[Reject]] »).If completion is an abrupt completion, thenPerform ? Call(resolvingFunctions.[[Reject]], undefined, « completion.[[Value]] »).Return promise.          Note The executor argument must be a function object.  It is called for initiating and reporting completion of the possibly  deferred action represented by this Promise object. The executor is  called with two arguments: resolve and reject. These are functions that may be used by the executor  function to report eventual completion or failure of the deferred  computation. Returning from the executor function does not mean that the  deferred action has been completed but only that the request to  eventually perform the deferred action has been accepted. The resolve function that is passed to an executor function accepts a single argument. The executor code may eventually call the resolve function to indicate that it wishes to resolve the associated Promise object. The argument passed to the resolve  function represents the eventual value of the deferred action and can  be either the actual fulfillment value or another Promise object which  will provide the value if it is fulfilled. The reject function that is passed to an executor function accepts a single argument. The executor code may eventually call the reject function to indicate that the associated Promise is rejected and will never be fulfilled. The argument passed to the reject function is used as the rejection value of the promise. Typically it will be an Error object. The resolve and reject functions passed to an executor  function by the Promise constructor have the capability to actually  resolve and reject the associated promise. Subclasses may have different  constructor behaviour that passes in customized values for resolve and  reject.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.4.1.1">
	<buginformation>
		<summary>Runtime Semantics: PerformPromiseAll( iteratorRecord, constructor, resultCapability )</summary>
		<description>When the PerformPromiseAll abstract operation is called with arguments iteratorRecord, constructor, and resultCapability, the following steps are taken: Assert: constructor is a constructor function.Assert: resultCapability is a PromiseCapability Record.Let values be a new empty List.Let remainingElementsCount be a new Record { [[Value]]: 1 }.Let index be 0.Repeat,Let next be IteratorStep(iteratorRecord.[[Iterator]]).If next is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(next).If next is false, thenSet iteratorRecord.[[Done]] to true.Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] - 1.If remainingElementsCount.[[Value]] is 0, thenLet valuesArray be CreateArrayFromList(values).Perform ? Call(resultCapability.[[Resolve]], undefined, « valuesArray »).Return resultCapability.[[Promise]].Let nextValue be IteratorValue(next).If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(nextValue).Append undefined to values.Let nextPromise be ? Invoke(constructor, &amp;quot;resolve&amp;quot;, « nextValue »).Let resolveElement be a new built-in function object as defined in Promise.all Resolve Element Functions.Set resolveElement.[[AlreadyCalled]] to a new Record { [[Value]]: false }.Set resolveElement.[[Index]] to index.Set resolveElement.[[Values]] to values.Set resolveElement.[[Capability]] to resultCapability.Set resolveElement.[[RemainingElements]] to remainingElementsCount.Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] + 1.Perform ? Invoke(nextPromise, &amp;quot;then&amp;quot;, « resolveElement, resultCapability.[[Reject]] »).Set index to index + 1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.4.1.2">
	<buginformation>
		<summary>Promise.all Resolve Element Functions</summary>
		<description>A Promise.all resolve element function is an anonymous built-in function that is used to resolve a specific Promise.all element. Each Promise.all  resolve element function has [[Index]], [[Values]], [[Capability]],  [[RemainingElements]], and [[AlreadyCalled]] internal slots. When a Promise.all resolve element function F is called with argument x, the following steps are taken: Let alreadyCalled be F.[[AlreadyCalled]].If alreadyCalled.[[Value]] is true, return undefined.Set alreadyCalled.[[Value]] to true.Let index be F.[[Index]].Let values be F.[[Values]].Let promiseCapability be F.[[Capability]].Let remainingElementsCount be F.[[RemainingElements]].Set values[index] to x.Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] - 1.If remainingElementsCount.[[Value]] is 0, thenLet valuesArray be CreateArrayFromList(values).Return ? Call(promiseCapability.[[Resolve]], undefined, « valuesArray »).Return undefined.            The length property of a Promise.all resolve element function is 1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.4.2">
	<buginformation>
		<summary>Promise.prototype</summary>
		<description>The initial value of Promise.prototype is the intrinsic object %PromisePrototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.4.3.1">
	<buginformation>
		<summary>Runtime Semantics: PerformPromiseRace ( iteratorRecord, constructor, resultCapability )</summary>
		<description>When the PerformPromiseRace abstract operation is called with arguments iteratorRecord, constructor, and resultCapability, the following steps are taken: Assert: constructor is a constructor function.Assert: resultCapability is a PromiseCapability Record.Repeat,Let next be IteratorStep(iteratorRecord.[[Iterator]]).If next is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(next).If next is false, thenSet iteratorRecord.[[Done]] to true.Return resultCapability.[[Promise]].Let nextValue be IteratorValue(next).If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.ReturnIfAbrupt(nextValue).Let nextPromise be ? Invoke(constructor, &amp;quot;resolve&amp;quot;, « nextValue »).Perform ? Invoke(nextPromise, &amp;quot;then&amp;quot;, « resultCapability.[[Resolve]], resultCapability.[[Reject]] »).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.4.4">
	<buginformation>
		<summary>Promise.reject ( r )</summary>
		<description>The reject function returns a new promise rejected with the passed argument. Let C be the this value.If Type(C) is not Object, throw a TypeError exception.Let promiseCapability be ? NewPromiseCapability(C).Perform ? Call(promiseCapability.[[Reject]], undefined, « r »).Return promiseCapability.[[Promise]].          Note The reject function expects its this value to be a constructor function that supports the parameter conventions of the Promise constructor.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.4.5">
	<buginformation>
		<summary>Promise.resolve ( x )</summary>
		<description>The resolve function returns either a new  promise resolved with the passed argument, or the argument itself if the  argument is a promise produced by this constructor. Let C be the this value.If Type(C) is not Object, throw a TypeError exception.If IsPromise(x) is true, thenLet xConstructor be ? Get(x, &amp;quot;constructor&amp;quot;).If SameValue(xConstructor, C) is true, return x.Let promiseCapability be ? NewPromiseCapability(C).Perform ? Call(promiseCapability.[[Resolve]], undefined, « x »).Return promiseCapability.[[Promise]].          Note The resolve function expects its this value to be a constructor function that supports the parameter conventions of the Promise constructor.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.4.6">
	<buginformation>
		<summary>get Promise [ @@species ]</summary>
		<description>Promise[@@species] is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Return the this value.          The value of the name property of this function is &amp;quot;get [Symbol.species]&amp;quot;. Note Promise prototype methods normally use their this  object&apos;s constructor to create a derived object. However, a subclass  constructor may over-ride that default behaviour by redefining its  @@species property.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.5.1">
	<buginformation>
		<summary>Promise.prototype.catch ( onRejected )</summary>
		<description>When the catch method is called with argument onRejected, the following steps are taken: Let promise be the this value.Return ? Invoke(promise, &amp;quot;then&amp;quot;, « undefined, onRejected »).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.5.2">
	<buginformation>
		<summary>Promise.prototype.constructor</summary>
		<description>The initial value of Promise.prototype.constructor is the intrinsic object %Promise%.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.5.3.1">
	<buginformation>
		<summary>PerformPromiseThen ( promise, onFulfilled, onRejected, resultCapability )</summary>
		<description>The abstract operation PerformPromiseThen performs the “then” operation on promise using onFulfilled and onRejected as its settlement actions. The result is resultCapability&apos;s promise. Assert: IsPromise(promise) is true.Assert: resultCapability is a PromiseCapability Record.If IsCallable(onFulfilled) is false, thenSet onFulfilled to undefined.If IsCallable(onRejected) is false, thenSet onRejected to undefined.Let fulfillReaction be the PromiseReaction { [[Capability]]: resultCapability, [[Type]]: &amp;quot;Fulfill&amp;quot;, [[Handler]]: onFulfilled }.Let rejectReaction be the PromiseReaction { [[Capability]]: resultCapability, [[Type]]: &amp;quot;Reject&amp;quot;, [[Handler]]: onRejected }.If promise.[[PromiseState]] is &amp;quot;pending&amp;quot;, thenAppend fulfillReaction as the last element of the List that is promise.[[PromiseFulfillReactions]].Append rejectReaction as the last element of the List that is promise.[[PromiseRejectReactions]].Else if promise.[[PromiseState]] is &amp;quot;fulfilled&amp;quot;, thenLet value be promise.[[PromiseResult]].Perform EnqueueJob(&amp;quot;PromiseJobs&amp;quot;, PromiseReactionJob, « fulfillReaction, value »).Else,Assert: The value of promise.[[PromiseState]] is &amp;quot;rejected&amp;quot;.Let reason be promise.[[PromiseResult]].If promise.[[PromiseIsHandled]] is false, perform HostPromiseRejectionTracker(promise, &amp;quot;handle&amp;quot;).Perform EnqueueJob(&amp;quot;PromiseJobs&amp;quot;, PromiseReactionJob, « rejectReaction, reason »).Set promise.[[PromiseIsHandled]] to true.Return resultCapability.[[Promise]].</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.5.4">
	<buginformation>
		<summary>Promise.prototype [ @@toStringTag ]</summary>
		<description>The initial value of the @@toStringTag property is the String value &amp;quot;Promise&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.4.6">
	<buginformation>
		<summary>Properties of Promise Instances</summary>
		<description>Promise instances are ordinary objects that inherit properties from the Promise prototype object (the intrinsic, %PromisePrototype%). Promise instances are initially created with the internal slots described in  Table 60. Table 60: Internal Slots of Promise Instances                   Internal Slot                                          Description                                            [[PromiseState]]                                          A String value that governs how a promise will react to incoming calls to its then method. The possible values are: &amp;quot;pending&amp;quot;, &amp;quot;fulfilled&amp;quot;, and &amp;quot;rejected&amp;quot;.                                            [[PromiseResult]]                                          The value with which the promise has been fulfilled or  rejected, if any. Only meaningful if [[PromiseState]] is not &amp;quot;pending&amp;quot;.                                            [[PromiseFulfillReactions]]                                          A List of PromiseReaction records to be processed when/if the promise transitions from the &amp;quot;pending&amp;quot; state to the &amp;quot;fulfilled&amp;quot; state.                                            [[PromiseRejectReactions]]                                          A List of PromiseReaction records to be processed when/if the promise transitions from the &amp;quot;pending&amp;quot; state to the &amp;quot;rejected&amp;quot; state.                                            [[PromiseIsHandled]]                                          A boolean indicating whether the promise has ever had a  fulfillment or rejection handler; used in unhandled rejection tracking.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.5.1.1">
	<buginformation>
		<summary>AsyncFunction( p1, p2, … , pn, body )</summary>
		<description>The last argument specifies the body (executable code) of an async function. Any preceding arguments specify formal parameters. When the AsyncFunction function is called with some arguments p1, p2, …, pn, body (where n might be 0, that is, there are no p arguments, and where body might also not be provided), the following steps are taken: Let C be the active function object.Let args be the argumentsList that was passed to this function by [[Call]] or [[Construct]].Return CreateDynamicFunction(C, NewTarget, &amp;quot;async&amp;quot;, args).          NoteSee NOTE for  19.2.1.1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.5.2.1">
	<buginformation>
		<summary>AsyncFunction.length</summary>
		<description>This is a data property with a value of 1. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.5.2.2">
	<buginformation>
		<summary>AsyncFunction.prototype</summary>
		<description>The initial value of AsyncFunction.prototype is the intrinsic object %AsyncFunctionPrototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.5.3.1">
	<buginformation>
		<summary>AsyncFunction.prototype.constructor</summary>
		<description>The initial value of AsyncFunction.prototype.constructor is the intrinsic object %AsyncFunction% This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.5.3.2">
	<buginformation>
		<summary>AsyncFunction.prototype [ @@toStringTag ]</summary>
		<description>The initial value of the @@toStringTag property is the string value &amp;quot;AsyncFunction&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.5.4.1">
	<buginformation>
		<summary>length</summary>
		<description>The specification for the length property of Function instances given in  19.2.4.1 also applies to AsyncFunction instances.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.5.4.2">
	<buginformation>
		<summary>name</summary>
		<description>The specification for the name property of Function instances given in  19.2.4.2 also applies to AsyncFunction instances.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.5.5.1">
	<buginformation>
		<summary>AsyncFunctionCreate ( kind, parameters, body, Scope, Strict )</summary>
		<description>The abstract operation AsyncFunctionCreate requires the arguments: kind which is one of (Normal, Method, Arrow), a parameter list Parse Node specified by parameters, a body Parse Node specified by body, a Lexical Environment specified by Scope, and a Boolean flag Strict. AsyncFunctionCreate performs the following steps: Let functionPrototype be the intrinsic object %AsyncFunctionPrototype%.Let F be ! FunctionAllocate(functionPrototype, Strict, &amp;quot;async&amp;quot;).Return ! FunctionInitialize(F, kind, parameters, body, Scope).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.5.5.2">
	<buginformation>
		<summary>AsyncFunctionStart ( promiseCapability, asyncFunctionBody )</summary>
		<description>Let runningContext be the running execution context.Let asyncContext be a copy of runningContext.Set the code evaluation state of asyncContext such that when evaluation is resumed for that execution context the following steps will be performed:Let result be the result of evaluating asyncFunctionBody.Assert:  If we return here, the async function either threw an exception or  performed an implicit or explicit return; all awaiting is done.Remove asyncContext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.If result.[[Type]] is normal, thenPerform ! Call(promiseCapability.[[Resolve]], undefined, «undefined»).Else if result.[[Type]] is return, thenPerform ! Call(promiseCapability.[[Resolve]], undefined, «result.[[Value]]»).Else,Assert: result.[[Type]] is throw.Perform ! Call(promiseCapability.[[Reject]], undefined, «result.[[Value]]»).Return.Push asyncContext onto the execution context stack; asyncContext is now the running execution context.Resume the suspended evaluation of asyncContext. Let result be the value returned by the resumed computation.Assert: When we return here, asyncContext has already been removed from the execution context stack and runningContext is the currently running execution context.Assert: result is a normal completion with a value of undefined. The possible sources of completion values are AsyncFunctionAwait or, if the async function doesn&apos;t await anything, the step 3.g above.Return.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.5.5.3">
	<buginformation>
		<summary>AsyncFunctionAwait ( value )</summary>
		<description>Let asyncContext be the running execution context.Let promiseCapability be ! NewPromiseCapability(%Promise%).Let resolveResult be ! Call(promiseCapability.[[Resolve]], undefined, « value »).Let onFulfilled be a new built-in function object as defined in AsyncFunction Awaited Fulfilled.Let onRejected be a new built-in function object as defined in AsyncFunction Awaited Rejected.Set onFulfilled.[[AsyncContext]] to asyncContext.Set onRejected.[[AsyncContext]] to asyncContext.Let throwawayCapability be ! NewPromiseCapability(%Promise%).Set throwawayCapability.[[Promise]].[[PromiseIsHandled]] to true.Perform ! PerformPromiseThen(promiseCapability.[[Promise]], onFulfilled, onRejected, throwawayCapability).Remove asyncContext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.Set the code evaluation state of asyncContext such that when evaluation is resumed with a Completion resumptionValue the following steps will be performed:Return resumptionValue.Return.          NoteThe return value of this abstract operation is unused. The interesting return is that of resumptionValue being returned to the AwaitExpression that originally called this abstract operation.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.5.5.4">
	<buginformation>
		<summary>AsyncFunction Awaited Fulfilled</summary>
		<description>An AsyncFunction Awaited Fulfilled function is an anonymous  built-in function that has an [[AsyncContext]] internal slot. The value  of the [[AsyncContext]] internal slot is the execution context that will be restored when the function is called. When an AsyncFunction Awaited Fulfilled function F is called with argument value, the following steps are taken: Let asyncContext be F.[[AsyncContext]].Let prevContext be the running execution context.Suspend prevContext.Push asyncContext onto the execution context stack; asyncContext is now the running execution context.Resume the suspended evaluation of asyncContext using NormalCompletion(value) as the result of the operation that suspended it. Let result be the value returned by the resumed computation.Assert: When we reach this step, asyncContext has already been removed from the execution context stack and prevContext is the currently running execution context.Return Completion(result).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="25.5.5.5">
	<buginformation>
		<summary>AsyncFunction Awaited Rejected</summary>
		<description>An AsyncFunction Awaited Rejected function is an anonymous  built-in function that has an [[AsyncContext]] internal slot. The value  of the [[AsyncContext]] internal slot is the execution context that will be restored when the function is called. When an AsyncFunction Awaited Rejected function F is called with argument reason, the following steps are taken: Let asyncContext be F.[[AsyncContext]].Let prevContext be the running execution context.Suspend prevContext.Push asyncContext onto the execution context stack; asyncContext is now the running execution context.Resume the suspended evaluation of asyncContext using Completion{[[Type]]: throw, [[Value]]: reason, [[Target]]: empty} as the result of the operation that suspended it. Let result be the value returned by the resumed computation.Assert: When we reach this step, asyncContext has already been removed from the execution context stack and prevContext is the currently running execution context.Return Completion(result).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="26.1.1">
	<buginformation>
		<summary>Reflect.apply ( target, thisArgument, argumentsList )</summary>
		<description>When the apply function is called with arguments target, thisArgument, and argumentsList, the following steps are taken: If IsCallable(target) is false, throw a TypeError exception.Let args be ? CreateListFromArrayLike(argumentsList).Perform PrepareForTailCall().Return ? Call(target, thisArgument, args).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="26.1.2">
	<buginformation>
		<summary>Reflect.construct ( target, argumentsList [ , newTarget ] )</summary>
		<description>When the construct function is called with arguments target, argumentsList, and newTarget, the following steps are taken: If IsConstructor(target) is false, throw a TypeError exception.If newTarget is not present, let newTarget be target.Else if IsConstructor(newTarget) is false, throw a TypeError exception.Let args be ? CreateListFromArrayLike(argumentsList).Return ? Construct(target, args, newTarget).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="26.1.3">
	<buginformation>
		<summary>Reflect.defineProperty ( target, propertyKey, attributes )</summary>
		<description>When the defineProperty function is called with arguments target, propertyKey, and attributes, the following steps are taken: If Type(target) is not Object, throw a TypeError exception.Let key be ? ToPropertyKey(propertyKey).Let desc be ? ToPropertyDescriptor(attributes).Return ? target.[[DefineOwnProperty]](key, desc).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="26.1.4">
	<buginformation>
		<summary>Reflect.deleteProperty ( target, propertyKey )</summary>
		<description>When the deleteProperty function is called with arguments target and propertyKey, the following steps are taken: If Type(target) is not Object, throw a TypeError exception.Let key be ? ToPropertyKey(propertyKey).Return ? target.[[Delete]](key).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="26.1.5">
	<buginformation>
		<summary>Reflect.get ( target, propertyKey [ , receiver ] )</summary>
		<description>When the get function is called with arguments target, propertyKey, and receiver, the following steps are taken: If Type(target) is not Object, throw a TypeError exception.Let key be ? ToPropertyKey(propertyKey).If receiver is not present, thenLet receiver be target.Return ? target.[[Get]](key, receiver).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="26.1.6">
	<buginformation>
		<summary>Reflect.getOwnPropertyDescriptor ( target, propertyKey )</summary>
		<description>When the getOwnPropertyDescriptor function is called with arguments target and propertyKey, the following steps are taken: If Type(target) is not Object, throw a TypeError exception.Let key be ? ToPropertyKey(propertyKey).Let desc be ? target.[[GetOwnProperty]](key).Return FromPropertyDescriptor(desc).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="26.1.7">
	<buginformation>
		<summary>Reflect.getPrototypeOf ( target )</summary>
		<description>When the getPrototypeOf function is called with argument target, the following steps are taken: If Type(target) is not Object, throw a TypeError exception.Return ? target.[[GetPrototypeOf]]().</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="26.1.8">
	<buginformation>
		<summary>Reflect.has ( target, propertyKey )</summary>
		<description>When the has function is called with arguments target and propertyKey, the following steps are taken: If Type(target) is not Object, throw a TypeError exception.Let key be ? ToPropertyKey(propertyKey).Return ? target.[[HasProperty]](key).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="26.1.9">
	<buginformation>
		<summary>Reflect.isExtensible ( target )</summary>
		<description>When the isExtensible function is called with argument target, the following steps are taken: If Type(target) is not Object, throw a TypeError exception.Return ? target.[[IsExtensible]]().</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="26.1.10">
	<buginformation>
		<summary>Reflect.ownKeys ( target )</summary>
		<description>When the ownKeys function is called with argument target, the following steps are taken: If Type(target) is not Object, throw a TypeError exception.Let keys be ? target.[[OwnPropertyKeys]]().Return CreateArrayFromList(keys).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="26.1.11">
	<buginformation>
		<summary>Reflect.preventExtensions ( target )</summary>
		<description>When the preventExtensions function is called with argument target, the following steps are taken: If Type(target) is not Object, throw a TypeError exception.Return ? target.[[PreventExtensions]]().</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="26.1.12">
	<buginformation>
		<summary>Reflect.set ( target, propertyKey, V [ , receiver ] )</summary>
		<description>When the set function is called with arguments target, V, propertyKey, and receiver, the following steps are taken: If Type(target) is not Object, throw a TypeError exception.Let key be ? ToPropertyKey(propertyKey).If receiver is not present, thenLet receiver be target.Return ? target.[[Set]](key, V, receiver).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="26.1.13">
	<buginformation>
		<summary>Reflect.setPrototypeOf ( target, proto )</summary>
		<description>When the setPrototypeOf function is called with arguments target and proto, the following steps are taken: If Type(target) is not Object, throw a TypeError exception.If Type(proto) is not Object and proto is not null, throw a TypeError exception.Return ? target.[[SetPrototypeOf]](proto).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="26.2.1.1">
	<buginformation>
		<summary>Proxy ( target, handler )</summary>
		<description>When Proxy is called with arguments target and handler performs the following steps: If NewTarget is undefined, throw a TypeError exception.Return ? ProxyCreate(target, handler).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="26.2.2.1.1">
	<buginformation>
		<summary>Proxy Revocation Functions</summary>
		<description>A Proxy revocation function is an anonymous function that has the ability to invalidate a specific Proxy object. Each Proxy revocation function has a [[RevocableProxy]] internal slot. When a Proxy revocation function, F, is called, the following steps are taken: Let p be F.[[RevocableProxy]].If p is null, return undefined.Set F.[[RevocableProxy]] to null.Assert: p is a Proxy object.Set p.[[ProxyTarget]] to null.Set p.[[ProxyHandler]] to null.Return undefined.            The length property of a Proxy revocation function is 0.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="26.3.1">
	<buginformation>
		<summary>@@toStringTag</summary>
		<description>The initial value of the @@toStringTag property is the String value &amp;quot;Module&amp;quot;. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.1">
	<buginformation>
		<summary>Memory Model Fundamentals</summary>
		<description>Shared memory accesses (reads and writes) are divided into two  groups, atomic accesses and data accesses, defined below. Atomic  accesses are sequentially consistent, i.e., there is a strict total  ordering of events agreed upon by all agents in an agent cluster. Non-atomic accesses do not have a strict total ordering agreed upon by all agents, i.e., unordered. Note 1 No orderings weaker than sequentially consistent and stronger than unordered, such as release-acquire, are supported.  A  Shared Data Block event is either a  ReadSharedMemory,  WriteSharedMemory, or  ReadModifyWriteSharedMemory Record. Table 61: ReadSharedMemory Event Fields    Field Value Meaning   [[Order]] &amp;quot;SeqCst&amp;quot; or &amp;quot;Unordered&amp;quot; The weakest ordering guaranteed by the memory model for the event.   [[NoTear]] A Boolean Whether this event is allowed to read from multiple write events on equal range as this event.   [[Block]] A Shared Data Block The block the event operates on.   [[ByteIndex]] A nonnegative integer The byte address of the read in [[Block]].   [[ElementSize]] A nonnegative integer The size of the read.     Table 62: WriteSharedMemory Event Fields    Field Value Meaning   [[Order]] &amp;quot;SeqCst&amp;quot;, &amp;quot;Unordered&amp;quot;, or &amp;quot;Init&amp;quot; The weakest ordering guaranteed by the memory model for the event.   [[NoTear]] A Boolean Whether this event is allowed to be read from multiple read events with equal range as this event.   [[Block]] A Shared Data Block The block the event operates on.   [[ByteIndex]] A nonnegative integer The byte address of the write in [[Block]].   [[ElementSize]] A nonnegative integer The size of the write.   [[Payload]] A List The List of byte values to be read by other events.     Table 63: ReadModifyWriteSharedMemory Event Fields    Field Value Meaning   [[Order]] &amp;quot;SeqCst&amp;quot; Read-modify-write events are always sequentially consistent.   [[NoTear]] true Read-modify-write events cannot tear.   [[Block]] A Shared Data Block The block the event operates on.   [[ByteIndex]] A nonnegative integer The byte address of the read-modify-write in [[Block]].   [[ElementSize]] A nonnegative integer The size of the read-modify-write.   [[Payload]] A List The List of byte values to be passed to [[ModifyOp]].   [[ModifyOp]] A semantic function A pure semantic function that returns a modified List of byte values from a read List of byte values and [[Payload]].     These events are introduced by abstract operations or by methods on the Atomics object. In addition to Shared Data Block events, there are host-specific events. Let the range of a ReadSharedMemory, WriteSharedMemory, or  ReadModifyWriteSharedMemory event be the Set of contiguous integers from  its [[ByteIndex]] to [[ByteIndex]]+[[ElementSize]]-1. Two events&apos;  ranges are equal when the events have the same [[Block]], and the ranges  are element-wise equal. Two events&apos; ranges are overlapping when the  events have the same [[Block]], the ranges are not equal and their  intersection is non-empty. Two events&apos; ranges are disjoint when the  events do not have the same [[Block]] or their ranges are neither equal  nor overlapping. Note 2 Examples of host-specific synchronizing events that should be accounted for are: sending a SharedArrayBuffer from one agent to another (e.g., by postMessage in a browser), starting and stopping agents, and communicating within the agent cluster via channels other than shared memory. It is assumed those events are appended to agent-order during evaluation like the other SharedArrayBuffer events.  Shared Data Block events are ordered within candidate executions by the relations defined below.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.2">
	<buginformation>
		<summary>Agent Events Records</summary>
		<description>An  Agent Events Record is a Record with the following fields. Table 64: Agent Events Record Fields    Field Value Meaning   [[AgentSignifier]] A value that admits equality testing The agent whose evaluation resulted in this ordering.   [[EventList]] A List of events Events are appended to the list during evaluation.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.3">
	<buginformation>
		<summary>Chosen Value Records</summary>
		<description>A  Chosen Value Record is a Record with the following fields. Table 65: Chosen Value Record Fields    Field Value Meaning   [[Event]] A Shared Data Block event The ReadSharedMemory or ReadModifyWriteSharedMemory event that was introduced for this chosen value.   [[ChosenValue]] A List of byte values The bytes that were nondeterministically chosen during evaluation.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.4">
	<buginformation>
		<summary>Candidate Executions</summary>
		<description>A  candidate execution of the evaluation of an agent cluster is a Record with the following fields. Table 66: Candidate Execution Record Fields    Field Value Meaning   [[EventLists]] A List of Agent Events Records. Maps an agent to Lists of events appended during the evaluation.   [[ChosenValues]] A List of Chosen Value Records. Maps ReadSharedMemory or ReadModifyWriteSharedMemory events to the List of byte values chosen during the evaluation.   [[AgentOrder]] An agent-order Relation. Defined below.   [[ReadsBytesFrom]] A reads-bytes-from semantic function. Defined below.   [[ReadsFrom]] A reads-from Relation. Defined below.   [[HostSynchronizesWith]] A host-synchronizes-with Relation. Defined below.   [[SynchronizesWith]] A synchronizes-with Relation. Defined below.   [[HappensBefore]] A happens-before Relation. Defined below.     An  empty candidate execution is a candidate execution Record whose fields are empty Lists and Relations.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.5.1">
	<buginformation>
		<summary>EventSet( execution )</summary>
		<description>The abstract operation EventSet takes one argument, a candidate execution execution. It performs the following steps: Let events be an empty Set.For each Agent Events Record aer in execution.[[EventLists]], doFor each event E in aer.[[EventList]], doAdd E to events.Return events.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.5.2">
	<buginformation>
		<summary>SharedDataBlockEventSet( execution )</summary>
		<description>The abstract operation SharedDataBlockEventSet takes one argument, a candidate execution execution. It performs the following steps: Let events be an empty Set.For each event E in EventSet(execution), doIf E is a ReadSharedMemory, WriteSharedMemory, or ReadModifyWriteSharedMemory event, add E to events.Return events.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.5.3">
	<buginformation>
		<summary>HostEventSet( execution )</summary>
		<description>The abstract operation HostEventSet takes one argument, a candidate execution execution. It performs the following steps: Let events be an empty Set.For each event E in EventSet(execution), doIf E is not in SharedDataBlockEventSet(execution), add E to events.Return events.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.5.4">
	<buginformation>
		<summary>ComposeWriteEventBytes( execution, byteIndex, Ws )</summary>
		<description>The abstract operation ComposeWriteEventBytes takes four arguments, a candidate execution execution, a nonnegative integer byteIndex, and a List Ws of WriteSharedMemory or ReadModifyWriteSharedMemory events. It performs the following steps: Let byteLocation be byteIndex.Let bytesRead be a new empty List.For each element W of Ws in List order, doAssert: W has byteLocation in its range.Let payloadIndex be byteLocation - W.[[ByteIndex]].If W is a WriteSharedMemory event, thenLet byte be W.[[Payload]][payloadIndex].Else,Assert: W is a ReadModifyWriteSharedMemory event.Let bytes be ValueOfReadEvent(execution, W).Let bytesModified be W.[[ModifyOp]](bytes, W.[[Payload]]).Let byte be bytesModified[payloadIndex].Append byte to bytesRead.Increment byteLocation by 1.Return bytesRead.        Note 1 The semantic function [[ModifyOp]] is given by the function properties on the Atomics object that introduce ReadModifyWriteSharedMemory events.  Note 2 This abstract operation composes a List of write events into a List of byte values. It is used in the event semantics of ReadSharedMemory and ReadModifyWriteSharedMemory events.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.5.5">
	<buginformation>
		<summary>ValueOfReadEvent( execution, R )</summary>
		<description>The abstract operation ValueOfReadEvent takes two arguments, a candidate execution execution and a ReadSharedMemory or ReadModifyWriteSharedMemory event R. It performs the following steps: Assert: R is a ReadSharedMemory or ReadModifyWriteSharedMemory event.Let reads-bytes-from be execution.[[ReadsBytesFrom]].Let Ws be reads-bytes-from(R).Assert: Ws is a List of WriteSharedMemory or ReadModifyWriteSharedMemory events with length equal to R.[[ElementSize]].Return ComposeWriteEventBytes(execution, R.[[ByteIndex]], Ws).</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.6.1">
	<buginformation>
		<summary>agent-order</summary>
		<description>For a candidate execution execution, execution.[[AgentOrder]] is a Relation that satisfies the following conditions. Let agent-order be execution.[[AgentOrder]].For each pair of events E and D in EventSet(execution), doFor each Agent Events Record aer in execution.[[EventLists]], doIf E and D are in aer.[[EventList]] and E is before D in List order of aer.[[EventList]], then E is agent-order before D.        Note Each agent introduces events in a per-agent strict total order during the evaluation. This is the union of those strict total orders.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.6.2">
	<buginformation>
		<summary>reads-bytes-from</summary>
		<description>For a candidate execution execution, execution.[[ReadsBytesFrom]] is a semantic function from events in SharedDataBlockEventSet(execution) to Lists of events in SharedDataBlockEventSet(execution) that satisfies the following conditions. Let reads-bytes-from be execution.[[ReadsBytesFrom]].For each ReadSharedMemory or ReadModifyWriteSharedMemory event R in SharedDataBlockEventSet(execution), doThere is a List of length equal to R.[[ElementSize]] of WriteSharedMemory or ReadModifyWriteSharedMemory events Ws such that reads-bytes-from(R) is Ws.Let byteLocation be R.[[ByteIndex]].For each element W of Ws in List order, doW has byteLocation in its range.W is not R.Increment byteLocation by 1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.6.3">
	<buginformation>
		<summary>reads-from</summary>
		<description>For a candidate execution execution, execution.[[ReadsFrom]] is the least Relation that satisfies the following conditions. Let reads-from be execution.[[ReadsFrom]].Let reads-bytes-from be execution.[[ReadsBytesFrom]].For each pair of events R and W in SharedDataBlockEventSet(execution), doLet Ws be reads-bytes-from(R).Assert: Ws is a List of WriteSharedMemory or ReadModifyWriteSharedMemory events.If Ws contains W, then R reads-from W.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.6.4">
	<buginformation>
		<summary>host-synchronizes-with</summary>
		<description>For a candidate execution execution, execution.[[HostSynchronizesWith]] is a host-provided strict partial order on host-specific events in HostEventSet(execution) that satisfies the following conditions. Let host-synchronizes-with be execution.[[HostSynchronizesWith]].Let agent-order be execution.[[AgentOrder]].There is no cycle in the union of host-synchronizes-with and agent-order.        Note 1 For two host-specific events E and D, E host-synchronizes-with D implies E happens-before D.  Note 2 The host-synchronizes-with relation allows the host to provide additional synchronization mechanisms, such as postMessage between HTML workers.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.6.5">
	<buginformation>
		<summary>synchronizes-with</summary>
		<description>For a candidate execution execution, execution.[[SynchronizesWith]] is the least Relation that satisfies the following conditions. Let synchronizes-with be execution.[[SynchronizesWith]].Let reads-from be execution.[[ReadsFrom]].Let host-synchronizes-with be execution.[[HostSynchronizesWith]].For each pair of events R and W in SharedDataBlockEventSet(execution) such that R.[[Order]] is &amp;quot;SeqCst&amp;quot; and R reads-from W, doAssert: R is a ReadSharedMemory or ReadModifyWriteSharedMemory event.Assert: W is a WriteSharedMemory or ReadModifyWriteSharedMemory event.If W.[[Order]] is &amp;quot;SeqCst&amp;quot; and R and W have equal ranges, then W synchronizes-with R.Else if W has order &amp;quot;Init&amp;quot;, thenLet allInitReads be true.For each event V such that R reads-from V, doIf V.[[Order]] is not &amp;quot;Init&amp;quot;, set allInitReads to false.If allInitReads is true, then W synchronizes-with R.For each pair of events E and D in HostEventSet(execution), doIf E host-synchronizes-with D, then E synchronizes-with D.        Note 1 Owing to convention, write events synchronizes-with read events, instead of read events synchronizes-with write events.  Note 2 Not all &amp;quot;SeqCst&amp;quot; events related by reads-from are related by synchronizes-with. Only events that also have equal ranges are related by synchronizes-with.  Note 3 For an event R and an event W such that W synchronizes-with R, R may reads-from other writes than W.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.6.6">
	<buginformation>
		<summary>happens-before</summary>
		<description>For a candidate execution execution, execution.[[HappensBefore]] is the least Relation that satisfies the following conditions. Let happens-before be execution.[[HappensBefore]].Let agent-order be execution.[[AgentOrder]].Let synchronizes-with be execution.[[SynchronizesWith]].For each pair of events E and D in EventSet(execution), doIf E is agent-order before D, then E happens-before D.If E synchronizes-with D, then E happens-before D.If E and D are in SharedDataBlockEventSet(execution), E.[[Order]] is &amp;quot;Init&amp;quot;, and E and D have overlapping ranges, thenAssert: D.[[Order]] is not &amp;quot;Init&amp;quot;.E happens-before D.If there is an event F such that E happens-before F and F happens-before D, then E happens-before D.        Note Because happens-before is a superset of agent-order, candidate executions are consistent with the single-thread evaluation semantics of ECMAScript.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.7.1">
	<buginformation>
		<summary>Valid Chosen Reads</summary>
		<description>A candidate execution execution has valid chosen reads if the following conditions hold. For each ReadSharedMemory or ReadModifyWriteSharedMemory event R in SharedDataBlockEventSet(execution), doLet chosenValue be the element of execution.[[ChosenValues]] whose [[Event]] field is R.Let readValue be ValueOfReadEvent(execution, R).Let chosenLen be the number of elements of chosenValue.Let readLen be the number of elements of readValue.chosenLen is equal to readLen and chosenValue[i] is equal to readValue[i] for all integer values i in the range 0 through chosenLen, exclusive.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.7.2">
	<buginformation>
		<summary>Coherent Reads</summary>
		<description>A candidate execution execution has coherent reads if the following conditions hold. Let happens-before be execution.[[HappensBefore]].Let reads-bytes-from be execution.[[ReadsBytesFrom]].For each ReadSharedMemory or ReadModifyWriteSharedMemory event R in SharedDataBlockEventSet(execution), doLet Ws be the List of events reads-bytes-from(R).Let byteLocation be R.[[ByteIndex]].For each element W of Ws in List order, doIt is not the case that R happens-before W, andThere is no WriteSharedMemory or ReadModifyWriteSharedMemory event V that has byteLocation in its range such that W happens-before V and V happens-before R.Increment byteLocation by 1.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.7.3">
	<buginformation>
		<summary>Tear Free Reads</summary>
		<description>A candidate execution execution has tear free reads if the following conditions hold. Let reads-from be execution.[[ReadsFrom]].For each ReadSharedMemory or ReadModifyWriteSharedMemory event R in SharedDataBlockEventSet(execution), doIf R.[[NoTear]] is true, thenAssert: The remainder of dividing R.[[ByteIndex]] by R.[[ElementSize]] is 0.For each event W such that R reads-from W and W.[[NoTear]] is true, doIf R and W have equal ranges, then there is no V such that V and W have equal range, V.[[NoTear]] is true, W is not V, and R reads-from V.        Note An event&apos;s [[NoTear]] field is true when that event was introduced via accessing an integer TypedArray, and false when introduced via accessing a floating point TypedArray or DataView. Intuitively, this requirement says when a memory range is  accessed in an aligned fashion via an integer TypedArray, a single write  event on that range must &amp;quot;win&amp;quot; when in a data race with other write  events with equal ranges. More precisely, this requirement says an  aligned read event cannot read a value composed of bytes from multiple,  different write events all with equal ranges. It is possible, however,  for an aligned read event to read from multiple write events with  overlapping ranges.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.7.4">
	<buginformation>
		<summary>Sequentially Consistent Atomics</summary>
		<description>For a candidate execution execution, memory-order is a strict total order of all events in EventSet(execution) that satisfies the following conditions. Let happens-before be execution.[[HappensBefore]].Let synchronizes-with be execution.[[SynchronizesWith]].For each pair of events E and D in EventSet(execution), doIf E happens-before D, then E is memory-order before D.If E and D are in SharedDataBlockEventSet(execution) and E synchronizes-with D, thenAssert: D.[[Order]] is &amp;quot;SeqCst&amp;quot;.There is no WriteSharedMemory or ReadModifyWriteSharedMemory event W in SharedDataBlockEventSet(execution) with equal range as D such that W is not E, E is memory-order before W, and W is memory-order before D.NOTE: This clause additionally constrains &amp;quot;SeqCst&amp;quot; events on equal ranges.For each WriteSharedMemory or ReadModifyWriteSharedMemory event W in SharedDataBlockEventSet(execution), doIf W.[[Order]] is &amp;quot;SeqCst&amp;quot;, then it is not the case that there is an infinite number of ReadSharedMemory or ReadModifyWriteSharedMemory events in SharedDataBlockEventSet(execution) with equal range that is memory-order before W.NOTE: This clause together with the forward progress guarantee on agents ensure the liveness condition that &amp;quot;SeqCst&amp;quot; writes become visible to &amp;quot;SeqCst&amp;quot; reads with equal range in finite time.        A candidate execution has sequentially consistent atomics if a memory-order exists. Note While memory-order includes all events in EventSet(execution), those that are not constrained by happens-before or synchronizes-with are allowed to occur anywhere in the order.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.7.5">
	<buginformation>
		<summary>Valid Executions</summary>
		<description>A candidate execution execution is a valid execution (or simply an execution) if the following conditions hold. The host provides a host-synchronizes-with Relation for execution.[[HostSynchronizesWith]], andexecution.[[HappensBefore]] is a strict partial order, andexecution has valid chosen reads, andexecution has coherent reads, andexecution has tear free reads, andexecution has sequentially consistent atomics.        All programs have at least one valid execution.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.8">
	<buginformation>
		<summary>Races</summary>
		<description>For an execution execution, two events E and D in SharedDataBlockEventSet(execution) are in a race if the following conditions hold. Let happens-before be execution.[[HappensBefore]].Let reads-from be execution.[[ReadsFrom]].E is not D, andIt is not the case that E happens-before D or D happens-before E, andIf E and D are both WriteSharedMemory or ReadModifyWriteSharedMemory events, thenE and D do not have disjoint ranges.Else,E reads-from D or D reads-from E.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.9">
	<buginformation>
		<summary>Data Races</summary>
		<description>For an execution execution, two events E and D in SharedDataBlockEventSet(execution) are in a data race if the following conditions hold. E and D are in a race in execution, andAt least one of E or D does not have [[Order]] &amp;quot;SeqCst&amp;quot; or E and D have overlapping ranges.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.10">
	<buginformation>
		<summary>Data Race Freedom</summary>
		<description>An execution execution is data race free if there are no two events in SharedDataBlockEventSet(execution) that are in a data race. A program is data race free if all its executions are data race free. The memory model guarantees sequential consistency of all events for data race free programs.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
<bug id="27.11">
	<buginformation>
		<summary>Shared Memory Guidelines</summary>
		<description>Note 1 The following are guidelines for ECMAScript programmers working with shared memory. We recommend programs be kept data race free, i.e., make it so  that it is impossible for there to be concurrent non-atomic operations  on the same memory location. Data race free programs have interleaving  semantics where each step in the evaluation semantics of each agent are interleaved with each other. For data race free programs, it is not necessary to understand the details of the memory model. The details are unlikely to build intuition that will help one to better write ECMAScript. More generally, even if a program is not data race free it may  have predictable behaviour, so long as atomic operations are not  involved in any data races and the operations that race all have the  same access size. The simplest way to arrange for atomics not to be  involved in races is to ensure that different memory cells are used by  atomic and non-atomic operations and that atomic accesses of different  sizes are not used to access the same cells at the same time.  Effectively, the program should treat shared memory as strongly typed as  much as possible. One still cannot depend on the ordering and timing of  non-atomic accesses that race, but if memory is treated as strongly  typed the racing accesses will not &amp;quot;tear&amp;quot; (bits of their values will not  be mixed).  Note 2 The following are guidelines for ECMAScript implementers writing compiler transformations for programs using shared memory. It is desirable to allow most program transformations that are valid in a single-agent setting in a multi-agent setting, to ensure that the performance of each agent in a multi-agent program is as good as it would be in a single-agent  setting. Frequently these transformations are hard to judge. We outline  some rules about program transformations that are intended to be taken  as normative (in that they are implied by the memory model or stronger than what the memory model  implies) but which are likely not exhaustive. These rules are intended  to apply to program transformations that precede the introductions of  the events that make up the agent-order. Let an  agent-order slice be the subset of the agent-order pertaining to a single agent. Let  possible read values of a read event be the set of all values of ValueOfReadEvent for that event across all valid executions. Any transformation of an agent-order slice that is valid in the  absence of shared memory is valid in the presence of shared memory,  with the following exceptions.   Atomics are carved in stone: Program transformations must not cause the  &amp;quot;SeqCst&amp;quot; events in an agent-order slice to be reordered with its  &amp;quot;Unordered&amp;quot; operations, nor its  &amp;quot;SeqCst&amp;quot; operations to be reordered with each other, nor may a program transformation remove a  &amp;quot;SeqCst&amp;quot; operation from the agent-order. (In practice, the prohibition on reorderings forces a compiler to assume that every  &amp;quot;SeqCst&amp;quot; operation is a synchronization and included in the final memory-order, which it would usually have to assume anyway in the absence of inter-agent program analysis. It also forces the compiler to assume that every call where the callee&apos;s effects on the memory-order are unknown may contain  &amp;quot;SeqCst&amp;quot; operations.)   Reads must be stable: Any given shared memory read must only observe a single value in an execution. (For example, if what is semantically a single read in the  program is executed multiple times then the program is subsequently  allowed to observe only one of the values read. A transformation known  as rematerialization can violate this rule.)   Writes must be stable: All observable writes to shared memory must follow from program semantics in an execution. (For example, a transformation may not introduce certain  observable writes, such as by using read-modify-write operations on a  larger location to write a smaller datum, writing a value to memory that  the program could not have written, or writing a just-read value back  to the location it was read from, if that location could have been  overwritten by another agent after the read.)   Possible read values must be nonempty: Program transformations cannot cause the possible read values of a shared memory read to become empty. (Counterintuitively, this rule in effect restricts transformations on writes, because writes have force in memory model insofar as to be read by read events. For example, writes may be moved and coalesced and sometimes reordered between two  &amp;quot;SeqCst&amp;quot; operations, but the transformation may not remove every write that updates a location; some write must be preserved.)   Examples of transformations that remain valid are: merging  multiple non-atomic reads from the same location, reordering non-atomic  reads, introducing speculative non-atomic reads, merging multiple  non-atomic writes to the same location, reordering non-atomic writes to  different locations, and hoisting non-atomic reads out of loops even if  that affects termination. Note in general that aliased TypedArrays make  it hard to prove that locations are different.  Note 3 The following are guidelines for ECMAScript implementers generating machine code for shared memory accesses. For architectures with memory models no weaker than those of  ARM or Power, non-atomic stores and loads may be compiled to bare stores  and loads on the target architecture. Atomic stores and loads may be  compiled down to instructions that guarantee sequential consistency. If  no such instructions exist, memory barriers are to be employed, such as  placing barriers on both sides of a bare store or load.  Read-modify-write operations may be compiled to read-modify-write  instructions on the target architectrue, such as  LOCK-prefixed  instructions on x86, load-exclusive/store-exclusive instructions on  ARM, and load-link/store-conditional instructions on Power. Specifically, the memory model is intended to allow code generation as follows.  Every atomic operation in the program is assumed to be necessary. Atomic operations are never rearranged with each other or with non-atomic operations. Functions are always assumed to perform atomic operations. Atomic operations are never implemented as read-modify-write  operations on larger data, but as non-lock-free atomics if the platform  does not have atomic operations of the appropriate size. (We already  assume that every platform has normal memory access operations of every  interesting size.)  Naive code generation uses these patterns:  Regular loads and stores compile to single load and store instructions. Lock-free atomic loads and stores compile to a full (sequentially consistent) fence, a regular load or store, and a full fence. Lock-free atomic read-modify-write accesses compile to a  full fence, an atomic read-modify-write instruction sequence, and a full  fence. Non-lock-free atomics compile to a spinlock acquire, a full  fence, a series of non-atomic load and store instructions, a full fence,  and a spinlock release.  That mapping is correct so long as an atomic operation on an  address range does not race with a non-atomic write or with an atomic  operation of different size. However, that is all we need: the memory model  effectively demotes the atomic operations involved in a race to  non-atomic status. On the other hand, the naive mapping is quite strong:  it allows atomic operations to be used as sequentially consistent  fences, which the memory model does not actually guarantee. A number of local improvements to those basic patterns are also intended to be legal:  There are obvious platform-dependent improvements that  remove redundant fences.  For example, on x86 the fences around  lock-free atomic loads and stores can always be omitted except for the  fence following a store, and no fence is needed for lock-free  read-modify-write instructions, as these all use LOCK-prefixed  instructions. On many platforms there are fences of several strengths,  and weaker fences can be used in certain contexts without destroying  sequential consistency. Most modern platforms support lock-free atomics for all the  data sizes required by ECMAScript atomics. Should non-lock-free atomics  be needed, the fences surrounding the body of the atomic operation can  usually be folded into the lock and unlock steps. The simplest solution  for non-lock-free atomics is to have a single lock word per  SharedArrayBuffer. There are also more complicated platform-dependent local  improvements, requiring some code analysis. For example, two  back-to-back fences often have the same effect as a single fence, so if  code is generated for two atomic operations in sequence, only a single  fence need separate them.  On x86, even a single fence separating atomic  stores can be omitted, as the fence following a store is only needed to  separate the store from a subsequent load.</description>
	</buginformation>
	<fixedFiles>
		<file>dummy</file>
	</fixedFiles>
</bug>
</bugrepository>
