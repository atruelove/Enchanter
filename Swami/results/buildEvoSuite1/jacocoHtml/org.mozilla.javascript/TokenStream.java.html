<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TokenStream.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rhino-Rhino1_7_9_Release</a> &gt; <a href="index.source.html" class="el_package">org.mozilla.javascript</a> &gt; <span class="el_source">TokenStream.java</span></div><h1>TokenStream.java</h1><pre class="source lang-java linenums">/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.javascript;

import java.io.*;

/**
 * This class implements the JavaScript scanner.
 *
 * It is based on the C source files jsscan.c and jsscan.h
 * in the jsref package.
 *
 * @see org.mozilla.javascript.Parser
 *
 * @author Mike McCabe
 * @author Brendan Eich
 */

<span class="pc bpc" id="L23" title="1 of 2 branches missed.">class TokenStream</span>
{
    /*
     * For chars - because we need something out-of-range
     * to check.  (And checking EOF by exception is annoying.)
     * Note distinction from EOF token type!
     */
    private final static int
        EOF_CHAR = -1;

    private final static char BYTE_ORDER_MARK = '\uFEFF';

    TokenStream(Parser parser, Reader sourceReader, String sourceString,
                int lineno)
<span class="fc" id="L37">    {</span>
<span class="fc" id="L38">        this.parser = parser;</span>
<span class="fc" id="L39">        this.lineno = lineno;</span>
<span class="fc bfc" id="L40" title="All 2 branches covered.">        if (sourceReader != null) {</span>
<span class="pc bpc" id="L41" title="1 of 2 branches missed.">            if (sourceString != null) Kit.codeBug();</span>
<span class="fc" id="L42">            this.sourceReader = sourceReader;</span>
<span class="fc" id="L43">            this.sourceBuffer = new char[512];</span>
<span class="fc" id="L44">            this.sourceEnd = 0;</span>
        } else {
<span class="pc bpc" id="L46" title="1 of 2 branches missed.">            if (sourceString == null) Kit.codeBug();</span>
<span class="fc" id="L47">            this.sourceString = sourceString;</span>
<span class="fc" id="L48">            this.sourceEnd = sourceString.length();</span>
        }
<span class="fc" id="L50">        this.sourceCursor = this.cursor = 0;</span>
<span class="fc" id="L51">    }</span>

    /* This function uses the cached op, string and number fields in
     * TokenStream; if getToken has been called since the passed token
     * was scanned, the op or string printed may be incorrect.
     */
    String tokenToString(int token)
    {
        if (Token.printTrees) {
            String name = Token.name(token);

            switch (token) {
            case Token.STRING:
            case Token.REGEXP:
            case Token.NAME:
                return name + &quot; `&quot; + this.string + &quot;'&quot;;

            case Token.NUMBER:
                return &quot;NUMBER &quot; + this.number;
            }

            return name;
        }
<span class="fc" id="L74">        return &quot;&quot;;</span>
    }

    static boolean isKeyword(String s, int version, boolean isStrict)
    {
<span class="fc bfc" id="L79" title="All 2 branches covered.">        return Token.EOF != stringToKeyword(s, version, isStrict);</span>
    }

    private static int stringToKeyword(String name, int version, boolean isStrict)
    {
<span class="fc bfc" id="L84" title="All 2 branches covered.">        if (version &lt; Context.VERSION_ES6) {</span>
<span class="fc" id="L85">            return stringToKeywordForJS(name);</span>
        } else {
<span class="fc" id="L87">            return stringToKeywordForES(name, isStrict);</span>
        }
    }

    /**
     * JavaScript 1.8 and earlier
     */
    private static int stringToKeywordForJS(String name)
    {
// #string_id_map#
// The following assumes that Token.EOF == 0
        final int
<span class="fc" id="L99">            Id_break         = Token.BREAK,</span>
<span class="fc" id="L100">            Id_case          = Token.CASE,</span>
<span class="fc" id="L101">            Id_continue      = Token.CONTINUE,</span>
<span class="fc" id="L102">            Id_default       = Token.DEFAULT,</span>
<span class="fc" id="L103">            Id_delete        = Token.DELPROP,</span>
<span class="fc" id="L104">            Id_do            = Token.DO,</span>
<span class="fc" id="L105">            Id_else          = Token.ELSE,</span>
<span class="fc" id="L106">            Id_export        = Token.RESERVED,</span>
<span class="fc" id="L107">            Id_false         = Token.FALSE,</span>
<span class="fc" id="L108">            Id_for           = Token.FOR,</span>
<span class="fc" id="L109">            Id_function      = Token.FUNCTION,</span>
<span class="fc" id="L110">            Id_if            = Token.IF,</span>
<span class="fc" id="L111">            Id_in            = Token.IN,</span>
<span class="fc" id="L112">            Id_let           = Token.LET,  // reserved ES5 strict</span>
<span class="fc" id="L113">            Id_new           = Token.NEW,</span>
<span class="fc" id="L114">            Id_null          = Token.NULL,</span>
<span class="fc" id="L115">            Id_return        = Token.RETURN,</span>
<span class="fc" id="L116">            Id_switch        = Token.SWITCH,</span>
<span class="fc" id="L117">            Id_this          = Token.THIS,</span>
<span class="fc" id="L118">            Id_true          = Token.TRUE,</span>
<span class="fc" id="L119">            Id_typeof        = Token.TYPEOF,</span>
<span class="fc" id="L120">            Id_var           = Token.VAR,</span>
<span class="fc" id="L121">            Id_void          = Token.VOID,</span>
<span class="fc" id="L122">            Id_while         = Token.WHILE,</span>
<span class="fc" id="L123">            Id_with          = Token.WITH,</span>
<span class="fc" id="L124">            Id_yield         = Token.YIELD,  // reserved ES5 strict</span>

            // the following are #ifdef RESERVE_JAVA_KEYWORDS in jsscan.c
<span class="fc" id="L127">            Id_abstract      = Token.RESERVED,  // ES3 only</span>
<span class="fc" id="L128">            Id_boolean       = Token.RESERVED,  // ES3 only</span>
<span class="fc" id="L129">            Id_byte          = Token.RESERVED,  // ES3 only</span>
<span class="fc" id="L130">            Id_catch         = Token.CATCH,</span>
<span class="fc" id="L131">            Id_char          = Token.RESERVED,  // ES3 only</span>
<span class="fc" id="L132">            Id_class         = Token.RESERVED,</span>
<span class="fc" id="L133">            Id_const         = Token.CONST,     // reserved</span>
<span class="fc" id="L134">            Id_debugger      = Token.DEBUGGER,</span>
<span class="fc" id="L135">            Id_double        = Token.RESERVED,  // ES3 only</span>
<span class="fc" id="L136">            Id_enum          = Token.RESERVED,</span>
<span class="fc" id="L137">            Id_extends       = Token.RESERVED,</span>
<span class="fc" id="L138">            Id_final         = Token.RESERVED,  // ES3 only</span>
<span class="fc" id="L139">            Id_finally       = Token.FINALLY,</span>
<span class="fc" id="L140">            Id_float         = Token.RESERVED,  // ES3 only</span>
<span class="fc" id="L141">            Id_goto          = Token.RESERVED,  // ES3 only</span>
<span class="fc" id="L142">            Id_implements    = Token.RESERVED,  // ES3, ES5 strict</span>
<span class="fc" id="L143">            Id_import        = Token.RESERVED,</span>
<span class="fc" id="L144">            Id_instanceof    = Token.INSTANCEOF,</span>
<span class="fc" id="L145">            Id_int           = Token.RESERVED,  // ES3</span>
<span class="fc" id="L146">            Id_interface     = Token.RESERVED,  // ES3, ES5 strict</span>
<span class="fc" id="L147">            Id_long          = Token.RESERVED,  // ES3 only</span>
<span class="fc" id="L148">            Id_native        = Token.RESERVED,  // ES3 only</span>
<span class="fc" id="L149">            Id_package       = Token.RESERVED,  // ES3, ES5 strict</span>
<span class="fc" id="L150">            Id_private       = Token.RESERVED,  // ES3, ES5 strict</span>
<span class="fc" id="L151">            Id_protected     = Token.RESERVED,  // ES3, ES5 strict</span>
<span class="fc" id="L152">            Id_public        = Token.RESERVED,  // ES3, ES5 strict</span>
<span class="fc" id="L153">            Id_short         = Token.RESERVED,  // ES3 only</span>
<span class="fc" id="L154">            Id_static        = Token.RESERVED,  // ES3, ES5 strict</span>
<span class="fc" id="L155">            Id_super         = Token.RESERVED,</span>
<span class="fc" id="L156">            Id_synchronized  = Token.RESERVED,  // ES3 only</span>
<span class="fc" id="L157">            Id_throw         = Token.THROW,</span>
<span class="fc" id="L158">            Id_throws        = Token.RESERVED,  // ES3 only</span>
<span class="fc" id="L159">            Id_transient     = Token.RESERVED,  // ES3 only</span>
<span class="fc" id="L160">            Id_try           = Token.TRY,</span>
<span class="fc" id="L161">            Id_volatile      = Token.RESERVED;  // ES3 only</span>

        int id;
<span class="fc" id="L164">        String s = name;</span>
// #generated# Last update: 2007-04-18 13:53:30 PDT
<span class="fc" id="L166">        L0: { id = 0; String X = null; int c;</span>
<span class="pc bpc" id="L167" title="1 of 11 branches missed.">            L: switch (s.length()) {</span>
<span class="fc" id="L168">            case 2: c=s.charAt(1);</span>
<span class="pc bpc" id="L169" title="3 of 4 branches missed.">                if (c=='f') { if (s.charAt(0)=='i') {id=Id_if; break L0;} }</span>
<span class="pc bpc" id="L170" title="3 of 4 branches missed.">                else if (c=='n') { if (s.charAt(0)=='i') {id=Id_in; break L0;} }</span>
<span class="pc bpc" id="L171" title="3 of 4 branches missed.">                else if (c=='o') { if (s.charAt(0)=='d') {id=Id_do; break L0;} }</span>
                break L;
<span class="pc bpc" id="L173" title="4 of 7 branches missed.">            case 3: switch (s.charAt(0)) {</span>
<span class="nc bnc" id="L174" title="All 4 branches missed.">                case 'f': if (s.charAt(2)=='r' &amp;&amp; s.charAt(1)=='o') {id=Id_for; break L0;} break L;</span>
<span class="nc bnc" id="L175" title="All 4 branches missed.">                case 'i': if (s.charAt(2)=='t' &amp;&amp; s.charAt(1)=='n') {id=Id_int; break L0;} break L;</span>
<span class="pc bpc" id="L176" title="2 of 4 branches missed.">                case 'l': if (s.charAt(2)=='t' &amp;&amp; s.charAt(1)=='e') {id=Id_let; break L0;} break L;</span>
<span class="pc bpc" id="L177" title="3 of 4 branches missed.">                case 'n': if (s.charAt(2)=='w' &amp;&amp; s.charAt(1)=='e') {id=Id_new; break L0;} break L;</span>
<span class="nc bnc" id="L178" title="All 4 branches missed.">                case 't': if (s.charAt(2)=='y' &amp;&amp; s.charAt(1)=='r') {id=Id_try; break L0;} break L;</span>
<span class="nc bnc" id="L179" title="All 4 branches missed.">                case 'v': if (s.charAt(2)=='r' &amp;&amp; s.charAt(1)=='a') {id=Id_var; break L0;} break L;</span>
<span class="fc" id="L180">                } break L;</span>
<span class="pc bpc" id="L181" title="6 of 10 branches missed.">            case 4: switch (s.charAt(0)) {</span>
<span class="nc" id="L182">                case 'b': X=&quot;byte&quot;;id=Id_byte; break L;</span>
<span class="nc" id="L183">                case 'c': c=s.charAt(3);</span>
<span class="nc bnc" id="L184" title="All 6 branches missed.">                    if (c=='e') { if (s.charAt(2)=='s' &amp;&amp; s.charAt(1)=='a') {id=Id_case; break L0;} }</span>
<span class="nc bnc" id="L185" title="All 6 branches missed.">                    else if (c=='r') { if (s.charAt(2)=='a' &amp;&amp; s.charAt(1)=='h') {id=Id_char; break L0;} }</span>
                    break L;
<span class="nc" id="L187">                case 'e': c=s.charAt(3);</span>
<span class="nc bnc" id="L188" title="All 6 branches missed.">                    if (c=='e') { if (s.charAt(2)=='s' &amp;&amp; s.charAt(1)=='l') {id=Id_else; break L0;} }</span>
<span class="nc bnc" id="L189" title="All 6 branches missed.">                    else if (c=='m') { if (s.charAt(2)=='u' &amp;&amp; s.charAt(1)=='n') {id=Id_enum; break L0;} }</span>
                    break L;
<span class="nc" id="L191">                case 'g': X=&quot;goto&quot;;id=Id_goto; break L;</span>
<span class="nc" id="L192">                case 'l': X=&quot;long&quot;;id=Id_long; break L;</span>
<span class="fc" id="L193">                case 'n': X=&quot;null&quot;;id=Id_null; break L;</span>
<span class="fc" id="L194">                case 't': c=s.charAt(3);</span>
<span class="pc bpc" id="L195" title="4 of 6 branches missed.">                    if (c=='e') { if (s.charAt(2)=='u' &amp;&amp; s.charAt(1)=='r') {id=Id_true; break L0;} }</span>
<span class="nc bnc" id="L196" title="All 6 branches missed.">                    else if (c=='s') { if (s.charAt(2)=='i' &amp;&amp; s.charAt(1)=='h') {id=Id_this; break L0;} }</span>
                    break L;
<span class="fc" id="L198">                case 'v': X=&quot;void&quot;;id=Id_void; break L;</span>
<span class="nc" id="L199">                case 'w': X=&quot;with&quot;;id=Id_with; break L;</span>
<span class="fc" id="L200">                } break L;</span>
<span class="pc bpc" id="L201" title="7 of 10 branches missed.">            case 5: switch (s.charAt(2)) {</span>
<span class="fc" id="L202">                case 'a': X=&quot;class&quot;;id=Id_class; break L;</span>
<span class="fc" id="L203">                case 'e': c=s.charAt(0);</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">                    if (c=='b') { X=&quot;break&quot;;id=Id_break; }</span>
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">                    else if (c=='y') { X=&quot;yield&quot;;id=Id_yield; }</span>
                    break L;
<span class="nc" id="L207">                case 'i': X=&quot;while&quot;;id=Id_while; break L;</span>
<span class="nc" id="L208">                case 'l': X=&quot;false&quot;;id=Id_false; break L;</span>
<span class="nc" id="L209">                case 'n': c=s.charAt(0);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">                    if (c=='c') { X=&quot;const&quot;;id=Id_const; }</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">                    else if (c=='f') { X=&quot;final&quot;;id=Id_final; }</span>
                    break L;
<span class="nc" id="L213">                case 'o': c=s.charAt(0);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">                    if (c=='f') { X=&quot;float&quot;;id=Id_float; }</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                    else if (c=='s') { X=&quot;short&quot;;id=Id_short; }</span>
                    break L;
<span class="nc" id="L217">                case 'p': X=&quot;super&quot;;id=Id_super; break L;</span>
<span class="nc" id="L218">                case 'r': X=&quot;throw&quot;;id=Id_throw; break L;</span>
<span class="nc" id="L219">                case 't': X=&quot;catch&quot;;id=Id_catch; break L;</span>
<span class="fc" id="L220">                } break L;</span>
<span class="pc bpc" id="L221" title="5 of 11 branches missed.">            case 6: switch (s.charAt(1)) {</span>
<span class="fc" id="L222">                case 'a': X=&quot;native&quot;;id=Id_native; break L;</span>
<span class="fc" id="L223">                case 'e': c=s.charAt(0);</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">                    if (c=='d') { X=&quot;delete&quot;;id=Id_delete; }</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">                    else if (c=='r') { X=&quot;return&quot;;id=Id_return; }</span>
                    break L;
<span class="nc" id="L227">                case 'h': X=&quot;throws&quot;;id=Id_throws; break L;</span>
<span class="fc" id="L228">                case 'm': X=&quot;import&quot;;id=Id_import; break L;</span>
<span class="nc" id="L229">                case 'o': X=&quot;double&quot;;id=Id_double; break L;</span>
<span class="nc" id="L230">                case 't': X=&quot;static&quot;;id=Id_static; break L;</span>
<span class="fc" id="L231">                case 'u': X=&quot;public&quot;;id=Id_public; break L;</span>
<span class="nc" id="L232">                case 'w': X=&quot;switch&quot;;id=Id_switch; break L;</span>
<span class="nc" id="L233">                case 'x': X=&quot;export&quot;;id=Id_export; break L;</span>
<span class="fc" id="L234">                case 'y': X=&quot;typeof&quot;;id=Id_typeof; break L;</span>
<span class="fc" id="L235">                } break L;</span>
<span class="pc bpc" id="L236" title="2 of 7 branches missed.">            case 7: switch (s.charAt(1)) {</span>
<span class="fc" id="L237">                case 'a': X=&quot;package&quot;;id=Id_package; break L;</span>
<span class="fc" id="L238">                case 'e': X=&quot;default&quot;;id=Id_default; break L;</span>
<span class="fc" id="L239">                case 'i': X=&quot;finally&quot;;id=Id_finally; break L;</span>
<span class="fc" id="L240">                case 'o': X=&quot;boolean&quot;;id=Id_boolean; break L;</span>
<span class="nc" id="L241">                case 'r': X=&quot;private&quot;;id=Id_private; break L;</span>
<span class="nc" id="L242">                case 'x': X=&quot;extends&quot;;id=Id_extends; break L;</span>
<span class="fc" id="L243">                } break L;</span>
<span class="pc bpc" id="L244" title="4 of 6 branches missed.">            case 8: switch (s.charAt(0)) {</span>
<span class="nc" id="L245">                case 'a': X=&quot;abstract&quot;;id=Id_abstract; break L;</span>
<span class="nc" id="L246">                case 'c': X=&quot;continue&quot;;id=Id_continue; break L;</span>
<span class="fc" id="L247">                case 'd': X=&quot;debugger&quot;;id=Id_debugger; break L;</span>
<span class="nc" id="L248">                case 'f': X=&quot;function&quot;;id=Id_function; break L;</span>
<span class="nc" id="L249">                case 'v': X=&quot;volatile&quot;;id=Id_volatile; break L;</span>
<span class="fc" id="L250">                } break L;</span>
<span class="fc" id="L251">            case 9: c=s.charAt(0);</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">                if (c=='i') { X=&quot;interface&quot;;id=Id_interface; }</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">                else if (c=='p') { X=&quot;protected&quot;;id=Id_protected; }</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">                else if (c=='t') { X=&quot;transient&quot;;id=Id_transient; }</span>
                break L;
<span class="fc" id="L256">            case 10: c=s.charAt(1);</span>
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">                if (c=='m') { X=&quot;implements&quot;;id=Id_implements; }</span>
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">                else if (c=='n') { X=&quot;instanceof&quot;;id=Id_instanceof; }</span>
                break L;
<span class="nc" id="L260">            case 12: X=&quot;synchronized&quot;;id=Id_synchronized; break L;</span>
            }
<span class="fc bfc" id="L262" title="All 6 branches covered.">            if (X!=null &amp;&amp; X!=s &amp;&amp; !X.equals(s)) id = 0;</span>
        }
// #/generated#
// #/string_id_map#
<span class="fc bfc" id="L266" title="All 2 branches covered.">        if (id == 0) { return Token.EOF; }</span>
<span class="fc" id="L267">        return id &amp; 0xff;</span>
    }

    /**
     * ECMAScript 6.
     */
    private static int stringToKeywordForES(String name, boolean isStrict)
    {
// #string_id_map#
// The following assumes that Token.EOF == 0
        final int
            // 11.6.2.1 Keywords (ECMAScript2015)
<span class="fc" id="L279">            Id_break         = Token.BREAK,</span>
<span class="fc" id="L280">            Id_case          = Token.CASE,</span>
<span class="fc" id="L281">            Id_catch         = Token.CATCH,</span>
<span class="fc" id="L282">            Id_class         = Token.RESERVED,</span>
<span class="fc" id="L283">            Id_const         = Token.CONST,</span>
<span class="fc" id="L284">            Id_continue      = Token.CONTINUE,</span>
<span class="fc" id="L285">            Id_debugger      = Token.DEBUGGER,</span>
<span class="fc" id="L286">            Id_default       = Token.DEFAULT,</span>
<span class="fc" id="L287">            Id_delete        = Token.DELPROP,</span>
<span class="fc" id="L288">            Id_do            = Token.DO,</span>
<span class="fc" id="L289">            Id_else          = Token.ELSE,</span>
<span class="fc" id="L290">            Id_export        = Token.RESERVED,</span>
<span class="fc" id="L291">            Id_extends       = Token.RESERVED,</span>
<span class="fc" id="L292">            Id_finally       = Token.FINALLY,</span>
<span class="fc" id="L293">            Id_for           = Token.FOR,</span>
<span class="fc" id="L294">            Id_function      = Token.FUNCTION,</span>
<span class="fc" id="L295">            Id_if            = Token.IF,</span>
<span class="fc" id="L296">            Id_import        = Token.RESERVED,</span>
<span class="fc" id="L297">            Id_in            = Token.IN,</span>
<span class="fc" id="L298">            Id_instanceof    = Token.INSTANCEOF,</span>
<span class="fc" id="L299">            Id_new           = Token.NEW,</span>
<span class="fc" id="L300">            Id_return        = Token.RETURN,</span>
<span class="fc" id="L301">            Id_super         = Token.RESERVED,</span>
<span class="fc" id="L302">            Id_switch        = Token.SWITCH,</span>
<span class="fc" id="L303">            Id_this          = Token.THIS,</span>
<span class="fc" id="L304">            Id_throw         = Token.THROW,</span>
<span class="fc" id="L305">            Id_try           = Token.TRY,</span>
<span class="fc" id="L306">            Id_typeof        = Token.TYPEOF,</span>
<span class="fc" id="L307">            Id_var           = Token.VAR,</span>
<span class="fc" id="L308">            Id_void          = Token.VOID,</span>
<span class="fc" id="L309">            Id_while         = Token.WHILE,</span>
<span class="fc" id="L310">            Id_with          = Token.WITH,</span>
<span class="fc" id="L311">            Id_yield         = Token.YIELD,</span>

            // 11.6.2.2 Future Reserved Words
<span class="fc" id="L314">            Id_await         = Token.RESERVED,</span>
<span class="fc" id="L315">            Id_enum          = Token.RESERVED,</span>

            // 11.6.2.2 NOTE Strict Future Reserved Words
<span class="fc" id="L318">            Id_implements    = Token.RESERVED,</span>
<span class="fc" id="L319">            Id_interface     = Token.RESERVED,</span>
<span class="fc" id="L320">            Id_package       = Token.RESERVED,</span>
<span class="fc" id="L321">            Id_private       = Token.RESERVED,</span>
<span class="fc" id="L322">            Id_protected     = Token.RESERVED,</span>
<span class="fc" id="L323">            Id_public        = Token.RESERVED,</span>

            // 11.8 Literals
<span class="fc" id="L326">            Id_false         = Token.FALSE,</span>
<span class="fc" id="L327">            Id_null          = Token.NULL,</span>
<span class="fc" id="L328">            Id_true          = Token.TRUE,</span>

            // Non ReservedWord, but Non IdentifierName in strict mode code.
            // 12.1.1 Static Semantics: Early Errors
<span class="fc" id="L332">            Id_let           = Token.LET,   // TODO : Valid IdentifierName in non-strict mode.</span>
<span class="fc" id="L333">            Id_static        = Token.RESERVED; </span>

        int id;
<span class="fc" id="L336">        String s = name;</span>
// #generated# Last update: 2007-04-18 13:53:30 PDT
<span class="fc" id="L338">        L0: { id = 0; String X = null; int c;</span>
<span class="pc bpc" id="L339" title="5 of 10 branches missed.">            L: switch (s.length()) {</span>
<span class="fc" id="L340">            case 2: c=s.charAt(1);</span>
<span class="pc bpc" id="L341" title="3 of 4 branches missed.">                if (c=='f') { if (s.charAt(0)=='i') {id=Id_if; break L0;} }</span>
<span class="pc bpc" id="L342" title="3 of 4 branches missed.">                else if (c=='n') { if (s.charAt(0)=='i') {id=Id_in; break L0;} }</span>
<span class="pc bpc" id="L343" title="3 of 4 branches missed.">                else if (c=='o') { if (s.charAt(0)=='d') {id=Id_do; break L0;} }</span>
                break L;
<span class="nc bnc" id="L345" title="All 6 branches missed.">            case 3: switch (s.charAt(0)) {</span>
<span class="nc bnc" id="L346" title="All 4 branches missed.">                case 'f': if (s.charAt(2)=='r' &amp;&amp; s.charAt(1)=='o') {id=Id_for; break L0;} break L;</span>
<span class="nc bnc" id="L347" title="All 4 branches missed.">                case 'l': if (s.charAt(2)=='t' &amp;&amp; s.charAt(1)=='e') {id=Id_let; break L0;} break L;</span>
<span class="nc bnc" id="L348" title="All 4 branches missed.">                case 'n': if (s.charAt(2)=='w' &amp;&amp; s.charAt(1)=='e') {id=Id_new; break L0;} break L;</span>
<span class="nc bnc" id="L349" title="All 4 branches missed.">                case 't': if (s.charAt(2)=='y' &amp;&amp; s.charAt(1)=='r') {id=Id_try; break L0;} break L;</span>
<span class="nc bnc" id="L350" title="All 4 branches missed.">                case 'v': if (s.charAt(2)=='r' &amp;&amp; s.charAt(1)=='a') {id=Id_var; break L0;} break L;</span>
<span class="nc" id="L351">                } break L;</span>
<span class="pc bpc" id="L352" title="6 of 7 branches missed.">            case 4: switch (s.charAt(0)) {</span>
<span class="nc" id="L353">                case 'c': c=s.charAt(3);</span>
<span class="nc bnc" id="L354" title="All 6 branches missed.">                    if (c=='e') { if (s.charAt(2)=='s' &amp;&amp; s.charAt(1)=='a') {id=Id_case; break L0;} }</span>
                    break L;
<span class="nc" id="L356">                case 'e': c=s.charAt(3);</span>
<span class="nc bnc" id="L357" title="All 6 branches missed.">                    if (c=='e') { if (s.charAt(2)=='s' &amp;&amp; s.charAt(1)=='l') {id=Id_else; break L0;} }</span>
<span class="nc bnc" id="L358" title="All 6 branches missed.">                    else if (c=='m') { if (s.charAt(2)=='u' &amp;&amp; s.charAt(1)=='n') {id=Id_enum; break L0;} }</span>
                    break L;
<span class="nc" id="L360">                case 'n': X=&quot;null&quot;;id=Id_null; break L;</span>
<span class="fc" id="L361">                case 't': c=s.charAt(3);</span>
<span class="pc bpc" id="L362" title="3 of 6 branches missed.">                    if (c=='e') { if (s.charAt(2)=='u' &amp;&amp; s.charAt(1)=='r') {id=Id_true; break L0;} }</span>
<span class="nc bnc" id="L363" title="All 6 branches missed.">                    else if (c=='s') { if (s.charAt(2)=='i' &amp;&amp; s.charAt(1)=='h') {id=Id_this; break L0;} }</span>
                    break L;
<span class="nc" id="L365">                case 'v': X=&quot;void&quot;;id=Id_void; break L;</span>
<span class="nc" id="L366">                case 'w': X=&quot;with&quot;;id=Id_with; break L;</span>
<span class="nc" id="L367">                } break L;</span>
<span class="nc bnc" id="L368" title="All 9 branches missed.">            case 5: switch (s.charAt(2)) {</span>
<span class="nc" id="L369">                case 'a': c=s.charAt(0);</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">                    if (c=='c') { X=&quot;class&quot;;id=Id_class; }</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">                    else if (c=='a') { X=&quot;await&quot;;id=Id_await; }</span>
                    break L;
<span class="nc" id="L373">                case 'e': c=s.charAt(0);</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">                    if (c=='b') { X=&quot;break&quot;;id=Id_break; }</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">                    else if (c=='y') { X=&quot;yield&quot;;id=Id_yield; }</span>
                    break L;
<span class="nc" id="L377">                case 'i': X=&quot;while&quot;;id=Id_while; break L;</span>
<span class="nc" id="L378">                case 'l': X=&quot;false&quot;;id=Id_false; break L;</span>
<span class="nc" id="L379">                case 'n': X=&quot;const&quot;;id=Id_const; break L;</span>
<span class="nc" id="L380">                case 'p': X=&quot;super&quot;;id=Id_super; break L;</span>
<span class="nc" id="L381">                case 'r': X=&quot;throw&quot;;id=Id_throw; break L;</span>
<span class="nc" id="L382">                case 't': X=&quot;catch&quot;;id=Id_catch; break L;</span>
<span class="nc" id="L383">                } break L;</span>
<span class="pc bpc" id="L384" title="5 of 8 branches missed.">            case 6: switch (s.charAt(1)) {</span>
<span class="fc" id="L385">                case 'e': c=s.charAt(0);</span>
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">                    if (c=='d') { X=&quot;delete&quot;;id=Id_delete; }</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">                    else if (c=='r') { X=&quot;return&quot;;id=Id_return; }</span>
                    break L;
<span class="nc" id="L389">                case 'm': X=&quot;import&quot;;id=Id_import; break L;</span>
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">                case 't': if (isStrict) {</span>
<span class="fc" id="L391">                    X=&quot;static&quot;;id=Id_static; break L;</span>
                }
                // fallthru
<span class="nc bnc" id="L394" title="All 2 branches missed.">                case 'u': if (isStrict) {</span>
<span class="nc" id="L395">                    X=&quot;public&quot;;id=Id_public; break L;</span>
                }
                // fallthru
<span class="nc" id="L398">                case 'w': X=&quot;switch&quot;;id=Id_switch; break L;</span>
<span class="nc" id="L399">                case 'x': X=&quot;export&quot;;id=Id_export; break L;</span>
<span class="nc" id="L400">                case 'y': X=&quot;typeof&quot;;id=Id_typeof; break L;</span>
<span class="fc" id="L401">                } break L;</span>
<span class="pc bpc" id="L402" title="5 of 6 branches missed.">            case 7: switch (s.charAt(1)) {</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">                case 'a': if (isStrict) {</span>
<span class="nc" id="L404">                    X=&quot;package&quot;;id=Id_package; break L;</span>
                }
                // fallthru
<span class="fc" id="L407">                case 'e': X=&quot;default&quot;;id=Id_default; break L;</span>
<span class="nc" id="L408">                case 'i': X=&quot;finally&quot;;id=Id_finally; break L;</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">                case 'r': if (isStrict) {</span>
<span class="nc" id="L410">                    X=&quot;private&quot;;id=Id_private; break L;</span>
                }
                // fallthru
<span class="nc" id="L413">                case 'x': X=&quot;extends&quot;;id=Id_extends; break L;</span>
<span class="nc" id="L414">                } break L;</span>
<span class="nc bnc" id="L415" title="All 4 branches missed.">            case 8: switch (s.charAt(0)) {</span>
<span class="nc" id="L416">                case 'c': X=&quot;continue&quot;;id=Id_continue; break L;</span>
<span class="nc" id="L417">                case 'd': X=&quot;debugger&quot;;id=Id_debugger; break L;</span>
<span class="nc" id="L418">                case 'f': X=&quot;function&quot;;id=Id_function; break L;</span>
<span class="nc" id="L419">                } break L;</span>
<span class="nc" id="L420">            case 9: c=s.charAt(0);</span>
<span class="nc bnc" id="L421" title="All 4 branches missed.">                if (c=='i' &amp;&amp; isStrict) { X=&quot;interface&quot;;id=Id_interface; }</span>
<span class="nc bnc" id="L422" title="All 4 branches missed.">                else if (c=='p' &amp;&amp; isStrict) { X=&quot;protected&quot;;id=Id_protected; }</span>
                break L;
<span class="fc" id="L424">            case 10: c=s.charAt(1);</span>
<span class="pc bpc" id="L425" title="3 of 4 branches missed.">                if (c=='m' &amp;&amp; isStrict) { X=&quot;implements&quot;;id=Id_implements; }</span>
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">                else if (c=='n') { X=&quot;instanceof&quot;;id=Id_instanceof; }</span>
                break L;
            }
<span class="pc bpc" id="L429" title="2 of 6 branches missed.">            if (X!=null &amp;&amp; X!=s &amp;&amp; !X.equals(s)) id = 0;</span>
        }
// #/generated#
// #/string_id_map#
<span class="fc bfc" id="L433" title="All 2 branches covered.">        if (id == 0) { return Token.EOF; }</span>
<span class="fc" id="L434">        return id &amp; 0xff;</span>
    }

<span class="fc" id="L437">    final String getSourceString() { return sourceString; }</span>

<span class="fc" id="L439">    final int getLineno() { return lineno; }</span>

<span class="fc" id="L441">    final String getString() { return string; }</span>

    final char getQuoteChar() {
<span class="fc" id="L444">        return (char) quoteChar;</span>
    }

<span class="fc" id="L447">    final double getNumber() { return number; }</span>
<span class="fc" id="L448">    final boolean isNumberBinary() { return isBinary; }</span>
<span class="fc" id="L449">    final boolean isNumberOldOctal() { return isOldOctal; }</span>
<span class="fc" id="L450">    final boolean isNumberOctal() { return isOctal; }</span>
<span class="fc" id="L451">    final boolean isNumberHex() { return isHex; }</span>

<span class="fc" id="L453">    final boolean eof() { return hitEOF; }</span>

    final int getToken() throws IOException
    {
        int c;

    retry:
        for (;;) {
            // Eat whitespace, possibly sensitive to newlines.
            for (;;) {
<span class="fc" id="L463">                c = getChar();</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">                if (c == EOF_CHAR) {</span>
<span class="fc" id="L465">                    tokenBeg = cursor - 1;</span>
<span class="fc" id="L466">                    tokenEnd = cursor;</span>
<span class="fc" id="L467">                    return Token.EOF;</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">                } else if (c == '\n') {</span>
<span class="fc" id="L469">                    dirtyLine = false;</span>
<span class="fc" id="L470">                    tokenBeg = cursor - 1;</span>
<span class="fc" id="L471">                    tokenEnd = cursor;</span>
<span class="fc" id="L472">                    return Token.EOL;</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">                } else if (!isJSSpace(c)) {</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">                    if (c != '-') {</span>
<span class="fc" id="L475">                        dirtyLine = true;</span>
                    }
                    break;
                }
            }

            // Assume the token will be 1 char - fixed up below.
<span class="fc" id="L482">            tokenBeg = cursor - 1;</span>
<span class="fc" id="L483">            tokenEnd = cursor;</span>

<span class="fc bfc" id="L485" title="All 2 branches covered.">            if (c == '@') return Token.XMLATTR;</span>

            // identifier/keyword/instanceof?
            // watch out for starting with a &lt;backslash&gt;
            boolean identifierStart;
<span class="fc" id="L490">            boolean isUnicodeEscapeStart = false;</span>
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">            if (c == '\\') {</span>
<span class="nc" id="L492">                c = getChar();</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">                if (c == 'u') {</span>
<span class="nc" id="L494">                    identifierStart = true;</span>
<span class="nc" id="L495">                    isUnicodeEscapeStart = true;</span>
<span class="nc" id="L496">                    stringBufferTop = 0;</span>
                } else {
<span class="nc" id="L498">                    identifierStart = false;</span>
<span class="nc" id="L499">                    ungetChar(c);</span>
<span class="nc" id="L500">                    c = '\\';</span>
                }
            } else {
<span class="fc" id="L503">                identifierStart = Character.isJavaIdentifierStart((char)c);</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">                if (identifierStart) {</span>
<span class="fc" id="L505">                    stringBufferTop = 0;</span>
<span class="fc" id="L506">                    addToString(c);</span>
                }
            }

<span class="fc bfc" id="L510" title="All 2 branches covered.">            if (identifierStart) {</span>
<span class="fc" id="L511">                boolean containsEscape = isUnicodeEscapeStart;</span>
                for (;;) {
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">                    if (isUnicodeEscapeStart) {</span>
                        // strictly speaking we should probably push-back
                        // all the bad characters if the &lt;backslash&gt;uXXXX
                        // sequence is malformed. But since there isn't a
                        // correct context(is there?) for a bad Unicode
                        // escape sequence in an identifier, we can report
                        // an error here.
<span class="nc" id="L520">                        int escapeVal = 0;</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">                        for (int i = 0; i != 4; ++i) {</span>
<span class="nc" id="L522">                            c = getChar();</span>
<span class="nc" id="L523">                            escapeVal = Kit.xDigitToInt(c, escapeVal);</span>
                            // Next check takes care about c &lt; 0 and bad escape
<span class="nc bnc" id="L525" title="All 2 branches missed.">                            if (escapeVal &lt; 0) { break; }</span>
                        }
<span class="nc bnc" id="L527" title="All 2 branches missed.">                        if (escapeVal &lt; 0) {</span>
<span class="nc" id="L528">                            parser.addError(&quot;msg.invalid.escape&quot;);</span>
<span class="nc" id="L529">                            return Token.ERROR;</span>
                        }
<span class="nc" id="L531">                        addToString(escapeVal);</span>
<span class="nc" id="L532">                        isUnicodeEscapeStart = false;</span>
<span class="nc" id="L533">                    } else {</span>
<span class="fc" id="L534">                        c = getChar();</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">                        if (c == '\\') {</span>
<span class="nc" id="L536">                            c = getChar();</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">                            if (c == 'u') {</span>
<span class="nc" id="L538">                                isUnicodeEscapeStart = true;</span>
<span class="nc" id="L539">                                containsEscape = true;</span>
                            } else {
<span class="nc" id="L541">                                parser.addError(&quot;msg.illegal.character&quot;, c);</span>
<span class="nc" id="L542">                                return Token.ERROR;</span>
                            }
                        } else {
<span class="pc bpc" id="L545" title="1 of 4 branches missed.">                            if (c == EOF_CHAR || c == BYTE_ORDER_MARK</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">                                || !Character.isJavaIdentifierPart((char)c))</span>
                            {
<span class="fc" id="L548">                                break;</span>
                            }
<span class="fc" id="L550">                            addToString(c);</span>
                        }
                    }
                }
<span class="fc" id="L554">                ungetChar(c);</span>

<span class="fc" id="L556">                String str = getStringFromBuffer();</span>
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">                if (!containsEscape) {</span>
                    // OPT we shouldn't have to make a string (object!) to
                    // check if it's a keyword.

                    // Return the corresponding token if it's a keyword
<span class="fc" id="L562">                    int result = stringToKeyword(str, parser.compilerEnv.getLanguageVersion(), parser.inUseStrictDirective());</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">                    if (result != Token.EOF) {</span>
<span class="pc bpc" id="L564" title="2 of 4 branches missed.">                        if ((result == Token.LET || result == Token.YIELD) &amp;&amp;</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">                            parser.compilerEnv.getLanguageVersion()</span>
                               &lt; Context.VERSION_1_7)
                        {
                            // LET and YIELD are tokens only in 1.7 and later
<span class="nc bnc" id="L569" title="All 2 branches missed.">                            string = result == Token.LET ? &quot;let&quot; : &quot;yield&quot;;</span>
<span class="nc" id="L570">                            result = Token.NAME;</span>
                        }
                        // Save the string in case we need to use in
                        // object literal definitions.
<span class="fc" id="L574">                        this.string = (String)allStrings.intern(str);</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">                        if (result != Token.RESERVED) {</span>
<span class="fc" id="L576">                            return result;</span>
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">                        } else if (parser.compilerEnv.getLanguageVersion() &gt;= Context.VERSION_ES6) {</span>
<span class="nc" id="L578">                            return result;</span>
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">                        } else if (!parser.compilerEnv.isReservedKeywordAsIdentifier()) {</span>
<span class="nc" id="L580">                            return result;</span>
                        }
                    }
<span class="pc bnc" id="L583" title="All 2 branches missed.">                } else if (isKeyword(str, parser.compilerEnv.getLanguageVersion(), parser.inUseStrictDirective())) {</span>
                    // If a string contains unicodes, and converted to a keyword,
                    // we convert the last character back to unicode
<span class="nc" id="L586">                    str = convertLastCharToHex(str);</span>
                }
<span class="fc" id="L588">                this.string = (String)allStrings.intern(str);</span>
<span class="fc" id="L589">                return Token.NAME;</span>
            }

            // is it a number?
<span class="pc bpc" id="L593" title="1 of 6 branches missed.">            if (isDigit(c) || (c == '.' &amp;&amp; isDigit(peekChar()))) {</span>
<span class="fc" id="L594">                stringBufferTop = 0;</span>
<span class="fc" id="L595">                int base = 10;</span>
<span class="fc" id="L596">                isHex = isOldOctal = isOctal = isBinary = false;</span>
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">                boolean es6 = parser.compilerEnv.getLanguageVersion() &gt;= Context.VERSION_ES6;</span>

<span class="fc bfc" id="L599" title="All 2 branches covered.">                if (c == '0') {</span>
<span class="fc" id="L600">                    c = getChar();</span>
<span class="pc bpc" id="L601" title="1 of 4 branches missed.">                    if (c == 'x' || c == 'X') {</span>
<span class="fc" id="L602">                        base = 16;</span>
<span class="fc" id="L603">                        isHex = true;</span>
<span class="fc" id="L604">                        c = getChar();</span>
<span class="pc bpc" id="L605" title="5 of 6 branches missed.">                    } else if (es6 &amp;&amp; (c == 'o' || c == 'O')) {</span>
<span class="nc" id="L606">                        base = 8;</span>
<span class="nc" id="L607">                        isOctal = true;</span>
<span class="nc" id="L608">                        c = getChar();</span>
<span class="pc bpc" id="L609" title="5 of 6 branches missed.">                    } else if (es6 &amp;&amp; (c == 'b' || c == 'B')) {</span>
<span class="nc" id="L610">                        base = 2;</span>
<span class="nc" id="L611">                        isBinary = true;</span>
<span class="nc" id="L612">                        c = getChar();</span>
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">                    } else if (isDigit(c)) {</span>
<span class="nc" id="L614">                        base = 8;</span>
<span class="nc" id="L615">                        isOldOctal = true;</span>
                    } else {
<span class="fc" id="L617">                        addToString('0');</span>
                    }
                }

<span class="fc" id="L621">                boolean isEmpty = true;</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">                if (base == 16) {</span>
<span class="pc bpc" id="L623" title="1 of 2 branches missed.">                    while (0 &lt;= Kit.xDigitToInt(c, 0)) {</span>
<span class="nc" id="L624">                        addToString(c);</span>
<span class="nc" id="L625">                        c = getChar();</span>
<span class="nc" id="L626">                        isEmpty = false;</span>
                    }
                } else {
<span class="fc bfc" id="L629" title="All 4 branches covered.">                    while ('0' &lt;= c &amp;&amp; c &lt;= '9') {</span>
<span class="pc bpc" id="L630" title="3 of 4 branches missed.">                        if (base == 8 &amp;&amp; c &gt;= '8') {</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">                            if (isOldOctal) {</span>
                                /*
                                 * We permit 08 and 09 as decimal numbers, which
                                 * makes our behavior a superset of the ECMA
                                 * numeric grammar.  We might not always be so
                                 * permissive, so we warn about it.
                                 */
<span class="nc bnc" id="L638" title="All 2 branches missed.">                                parser.addWarning(&quot;msg.bad.octal.literal&quot;,</span>
                                                  c == '8' ? &quot;8&quot; : &quot;9&quot;);
<span class="nc" id="L640">                                base = 10;</span>
                            } else {
<span class="nc" id="L642">                                parser.addError(&quot;msg.caught.nfe&quot;);</span>
<span class="nc" id="L643">                                return Token.ERROR;</span>
                            }
<span class="pc bpc" id="L645" title="3 of 4 branches missed.">                        } else if (base == 2 &amp;&amp; c &gt;= '2') {</span>
<span class="nc" id="L646">                            parser.addError(&quot;msg.caught.nfe&quot;);</span>
<span class="nc" id="L647">                            return Token.ERROR;</span>
                        }
<span class="fc" id="L649">                        addToString(c);</span>
<span class="fc" id="L650">                        c = getChar();</span>
<span class="fc" id="L651">                        isEmpty = false;</span>
                    }
                }
<span class="pc bpc" id="L654" title="2 of 8 branches missed.">                if (isEmpty &amp;&amp; (isBinary || isOctal || isHex)) {</span>
<span class="nc" id="L655">                    parser.addError(&quot;msg.caught.nfe&quot;);</span>
<span class="nc" id="L656">                    return Token.ERROR;</span>
                }

<span class="fc" id="L659">                boolean isInteger = true;</span>

<span class="pc bpc" id="L661" title="3 of 8 branches missed.">                if (base == 10 &amp;&amp; (c == '.' || c == 'e' || c == 'E')) {</span>
<span class="fc" id="L662">                    isInteger = false;</span>
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">                    if (c == '.') {</span>
                        do {
<span class="nc" id="L665">                            addToString(c);</span>
<span class="nc" id="L666">                            c = getChar();</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">                        } while (isDigit(c));</span>
                    }
<span class="pc bpc" id="L669" title="2 of 4 branches missed.">                    if (c == 'e' || c == 'E') {</span>
<span class="fc" id="L670">                        addToString(c);</span>
<span class="fc" id="L671">                        c = getChar();</span>
<span class="pc bpc" id="L672" title="2 of 4 branches missed.">                        if (c == '+' || c == '-') {</span>
<span class="nc" id="L673">                            addToString(c);</span>
<span class="nc" id="L674">                            c = getChar();</span>
                        }
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">                        if (!isDigit(c)) {</span>
<span class="fc" id="L677">                            parser.addError(&quot;msg.missing.exponent&quot;);</span>
<span class="fc" id="L678">                            return Token.ERROR;</span>
                        }
                        do {
<span class="nc" id="L681">                            addToString(c);</span>
<span class="nc" id="L682">                            c = getChar();</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">                        } while (isDigit(c));</span>
                    }
                }
<span class="fc" id="L686">                ungetChar(c);</span>
<span class="fc" id="L687">                String numString = getStringFromBuffer();</span>
<span class="fc" id="L688">                this.string = numString;</span>

                double dval;
<span class="pc bpc" id="L691" title="2 of 4 branches missed.">                if (base == 10 &amp;&amp; !isInteger) {</span>
                    try {
                        // Use Java conversion to number from string...
<span class="nc" id="L694">                        dval = Double.parseDouble(numString);</span>
                    }
<span class="nc" id="L696">                    catch (NumberFormatException ex) {</span>
<span class="nc" id="L697">                        parser.addError(&quot;msg.caught.nfe&quot;);</span>
<span class="nc" id="L698">                        return Token.ERROR;</span>
<span class="nc" id="L699">                    }</span>
                } else {
<span class="fc" id="L701">                    dval = ScriptRuntime.stringPrefixToNumber(numString, 0, base);</span>
                }

<span class="fc" id="L704">                this.number = dval;</span>
<span class="fc" id="L705">                return Token.NUMBER;</span>
            }

            // is it a string?
<span class="fc bfc" id="L709" title="All 4 branches covered.">            if (c == '&quot;' || c == '\'') {</span>
                // We attempt to accumulate a string the fast way, by
                // building it directly out of the reader.  But if there
                // are any escaped characters in the string, we revert to
                // building it out of a StringBuffer.

<span class="fc" id="L715">                quoteChar = c;</span>
<span class="fc" id="L716">                stringBufferTop = 0;</span>

<span class="fc" id="L718">                c = getChar(false);</span>
<span class="pc bpc" id="L719" title="1 of 2 branches missed.">            strLoop: while (c != quoteChar) {</span>
<span class="pc bpc" id="L720" title="1 of 4 branches missed.">                    if (c == '\n' || c == EOF_CHAR) {</span>
<span class="fc" id="L721">                        ungetChar(c);</span>
<span class="fc" id="L722">                        tokenEnd = cursor;</span>
<span class="fc" id="L723">                        parser.addError(&quot;msg.unterminated.string.lit&quot;);</span>
<span class="fc" id="L724">                        return Token.ERROR;</span>
                    }

<span class="pc bpc" id="L727" title="1 of 2 branches missed.">                    if (c == '\\') {</span>
                        // We've hit an escaped character
                        int escapeVal;

<span class="nc" id="L731">                        c = getChar();</span>
<span class="nc bnc" id="L732" title="All 10 branches missed.">                        switch (c) {</span>
<span class="nc" id="L733">                        case 'b': c = '\b'; break;</span>
<span class="nc" id="L734">                        case 'f': c = '\f'; break;</span>
<span class="nc" id="L735">                        case 'n': c = '\n'; break;</span>
<span class="nc" id="L736">                        case 'r': c = '\r'; break;</span>
<span class="nc" id="L737">                        case 't': c = '\t'; break;</span>

                        // \v a late addition to the ECMA spec,
                        // it is not in Java, so use 0xb
<span class="nc" id="L741">                        case 'v': c = 0xb; break;</span>

                        case 'u':
                            // Get 4 hex digits; if the u escape is not
                            // followed by 4 hex digits, use 'u' + the
                            // literal character sequence that follows.
<span class="nc" id="L747">                            int escapeStart = stringBufferTop;</span>
<span class="nc" id="L748">                            addToString('u');</span>
<span class="nc" id="L749">                            escapeVal = 0;</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">                            for (int i = 0; i != 4; ++i) {</span>
<span class="nc" id="L751">                                c = getChar();</span>
<span class="nc" id="L752">                                escapeVal = Kit.xDigitToInt(c, escapeVal);</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">                                if (escapeVal &lt; 0) {</span>
<span class="nc" id="L754">                                    continue strLoop;</span>
                                }
<span class="nc" id="L756">                                addToString(c);</span>
                            }
                            // prepare for replace of stored 'u' sequence
                            // by escape value
<span class="nc" id="L760">                            stringBufferTop = escapeStart;</span>
<span class="nc" id="L761">                            c = escapeVal;</span>
<span class="nc" id="L762">                            break;</span>
                        case 'x':
                            // Get 2 hex digits, defaulting to 'x'+literal
                            // sequence, as above.
<span class="nc" id="L766">                            c = getChar();</span>
<span class="nc" id="L767">                            escapeVal = Kit.xDigitToInt(c, 0);</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">                            if (escapeVal &lt; 0) {</span>
<span class="nc" id="L769">                                addToString('x');</span>
<span class="nc" id="L770">                                continue strLoop;</span>
                            } else {
<span class="nc" id="L772">                                int c1 = c;</span>
<span class="nc" id="L773">                                c = getChar();</span>
<span class="nc" id="L774">                                escapeVal = Kit.xDigitToInt(c, escapeVal);</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">                                if (escapeVal &lt; 0) {</span>
<span class="nc" id="L776">                                    addToString('x');</span>
<span class="nc" id="L777">                                    addToString(c1);</span>
<span class="nc" id="L778">                                    continue strLoop;</span>
                                } else {
                                    // got 2 hex digits
<span class="nc" id="L781">                                    c = escapeVal;</span>
                                }
                            }
<span class="nc" id="L784">                            break;</span>

                        case '\n':
                            // Remove line terminator after escape to follow
                            // SpiderMonkey and C/C++
<span class="nc" id="L789">                            c = getChar();</span>
<span class="nc" id="L790">                            continue strLoop;</span>

                        default:
<span class="nc bnc" id="L793" title="All 4 branches missed.">                            if ('0' &lt;= c &amp;&amp; c &lt; '8') {</span>
<span class="nc" id="L794">                                int val = c - '0';</span>
<span class="nc" id="L795">                                c = getChar();</span>
<span class="nc bnc" id="L796" title="All 4 branches missed.">                                if ('0' &lt;= c &amp;&amp; c &lt; '8') {</span>
<span class="nc" id="L797">                                    val = 8 * val + c - '0';</span>
<span class="nc" id="L798">                                    c = getChar();</span>
<span class="nc bnc" id="L799" title="All 6 branches missed.">                                    if ('0' &lt;= c &amp;&amp; c &lt; '8' &amp;&amp; val &lt;= 037) {</span>
                                        // c is 3rd char of octal sequence only
                                        // if the resulting val &lt;= 0377
<span class="nc" id="L802">                                        val = 8 * val + c - '0';</span>
<span class="nc" id="L803">                                        c = getChar();</span>
                                    }
                                }
<span class="nc" id="L806">                                ungetChar(c);</span>
<span class="nc" id="L807">                                c = val;</span>
                            }
                        }
                    }
<span class="fc" id="L811">                    addToString(c);</span>
<span class="fc" id="L812">                    c = getChar(false);</span>
                }

<span class="nc" id="L815">                String str = getStringFromBuffer();</span>
<span class="nc" id="L816">                this.string = (String)allStrings.intern(str);</span>
<span class="nc" id="L817">                return Token.STRING;</span>
            }

<span class="pc bpc" id="L820" title="5 of 25 branches missed.">            switch (c) {</span>
<span class="fc" id="L821">            case ';': return Token.SEMI;</span>
<span class="fc" id="L822">            case '[': return Token.LB;</span>
<span class="fc" id="L823">            case ']': return Token.RB;</span>
<span class="nc" id="L824">            case '{': return Token.LC;</span>
<span class="fc" id="L825">            case '}': return Token.RC;</span>
<span class="fc" id="L826">            case '(': return Token.LP;</span>
<span class="fc" id="L827">            case ')': return Token.RP;</span>
<span class="fc" id="L828">            case ',': return Token.COMMA;</span>
<span class="fc" id="L829">            case '?': return Token.HOOK;</span>
            case ':':
<span class="nc bnc" id="L831" title="All 2 branches missed.">                if (matchChar(':')) {</span>
<span class="nc" id="L832">                    return Token.COLONCOLON;</span>
                } else {
<span class="nc" id="L834">                    return Token.COLON;</span>
                }
            case '.':
<span class="pc bpc" id="L837" title="1 of 2 branches missed.">                if (matchChar('.')) {</span>
<span class="nc" id="L838">                    return Token.DOTDOT;</span>
<span class="pc bpc" id="L839" title="1 of 2 branches missed.">                } else if (matchChar('(')) {</span>
<span class="nc" id="L840">                    return Token.DOTQUERY;</span>
                } else {
<span class="fc" id="L842">                    return Token.DOT;</span>
                }

            case '|':
<span class="nc bnc" id="L846" title="All 2 branches missed.">                if (matchChar('|')) {</span>
<span class="nc" id="L847">                    return Token.OR;</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">                } else if (matchChar('=')) {</span>
<span class="nc" id="L849">                    return Token.ASSIGN_BITOR;</span>
                } else {
<span class="nc" id="L851">                    return Token.BITOR;</span>
                }

            case '^':
<span class="pc bpc" id="L855" title="1 of 2 branches missed.">                if (matchChar('=')) {</span>
<span class="nc" id="L856">                    return Token.ASSIGN_BITXOR;</span>
                } else {
<span class="fc" id="L858">                    return Token.BITXOR;</span>
                }

            case '&amp;':
<span class="pc bpc" id="L862" title="1 of 2 branches missed.">                if (matchChar('&amp;')) {</span>
<span class="nc" id="L863">                    return Token.AND;</span>
<span class="pc bpc" id="L864" title="1 of 2 branches missed.">                } else if (matchChar('=')) {</span>
<span class="fc" id="L865">                    return Token.ASSIGN_BITAND;</span>
                } else {
<span class="nc" id="L867">                    return Token.BITAND;</span>
                }

            case '=':
<span class="pc bpc" id="L871" title="1 of 2 branches missed.">                if (matchChar('=')) {</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">                    if (matchChar('=')) {</span>
<span class="nc" id="L873">                        return Token.SHEQ;</span>
                    } else {
<span class="nc" id="L875">                        return Token.EQ;</span>
                    }
<span class="pc bpc" id="L877" title="1 of 2 branches missed.">                } else if (matchChar('&gt;')) {</span>
<span class="nc" id="L878">                    return Token.ARROW;</span>
                } else {
<span class="fc" id="L880">                    return Token.ASSIGN;</span>
                }

            case '!':
<span class="pc bpc" id="L884" title="1 of 2 branches missed.">                if (matchChar('=')) {</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">                    if (matchChar('=')) {</span>
<span class="nc" id="L886">                        return Token.SHNE;</span>
                    } else {
<span class="nc" id="L888">                        return Token.NE;</span>
                    }
                } else {
<span class="fc" id="L891">                    return Token.NOT;</span>
                }

            case '&lt;':
                /* NB:treat HTML begin-comment as comment-till-eol */
<span class="nc bnc" id="L896" title="All 2 branches missed.">                if (matchChar('!')) {</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">                    if (matchChar('-')) {</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">                        if (matchChar('-')) {</span>
<span class="nc" id="L899">                            tokenBeg = cursor - 4;</span>
<span class="nc" id="L900">                            skipLine();</span>
<span class="nc" id="L901">                            commentType = Token.CommentType.HTML;</span>
<span class="nc" id="L902">                            return Token.COMMENT;</span>
                        }
<span class="nc" id="L904">                        ungetCharIgnoreLineEnd('-');</span>
                    }
<span class="nc" id="L906">                    ungetCharIgnoreLineEnd('!');</span>
                }
<span class="nc bnc" id="L908" title="All 2 branches missed.">                if (matchChar('&lt;')) {</span>
<span class="nc bnc" id="L909" title="All 2 branches missed.">                    if (matchChar('=')) {</span>
<span class="nc" id="L910">                        return Token.ASSIGN_LSH;</span>
                    } else {
<span class="nc" id="L912">                        return Token.LSH;</span>
                    }
                } else {
<span class="nc bnc" id="L915" title="All 2 branches missed.">                    if (matchChar('=')) {</span>
<span class="nc" id="L916">                        return Token.LE;</span>
                    } else {
<span class="nc" id="L918">                        return Token.LT;</span>
                    }
                }

            case '&gt;':
<span class="nc bnc" id="L923" title="All 2 branches missed.">                if (matchChar('&gt;')) {</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">                    if (matchChar('&gt;')) {</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">                        if (matchChar('=')) {</span>
<span class="nc" id="L926">                            return Token.ASSIGN_URSH;</span>
                        } else {
<span class="nc" id="L928">                            return Token.URSH;</span>
                        }
                    } else {
<span class="nc bnc" id="L931" title="All 2 branches missed.">                        if (matchChar('=')) {</span>
<span class="nc" id="L932">                            return Token.ASSIGN_RSH;</span>
                        } else {
<span class="nc" id="L934">                            return Token.RSH;</span>
                        }
                    }
                } else {
<span class="nc bnc" id="L938" title="All 2 branches missed.">                    if (matchChar('=')) {</span>
<span class="nc" id="L939">                        return Token.GE;</span>
                    } else {
<span class="nc" id="L941">                        return Token.GT;</span>
                    }
                }

            case '*':
<span class="pc bpc" id="L946" title="1 of 2 branches missed.">                if (matchChar('=')) {</span>
<span class="nc" id="L947">                    return Token.ASSIGN_MUL;</span>
                } else {
<span class="fc" id="L949">                    return Token.MUL;</span>
                }

            case '/':
<span class="fc" id="L953">                markCommentStart();</span>
                // is it a // comment?
<span class="pc bpc" id="L955" title="1 of 2 branches missed.">                if (matchChar('/')) {</span>
<span class="nc" id="L956">                    tokenBeg = cursor - 2;</span>
<span class="nc" id="L957">                    skipLine();</span>
<span class="nc" id="L958">                    commentType = Token.CommentType.LINE;</span>
<span class="nc" id="L959">                    return Token.COMMENT;</span>
                }
                // is it a /* or /** comment?
<span class="pc bpc" id="L962" title="1 of 2 branches missed.">                if (matchChar('*')) {</span>
<span class="nc" id="L963">                    boolean lookForSlash = false;</span>
<span class="nc" id="L964">                    tokenBeg = cursor - 2;</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">                    if (matchChar('*')) {</span>
<span class="nc" id="L966">                        lookForSlash = true;</span>
<span class="nc" id="L967">                        commentType = Token.CommentType.JSDOC;</span>
                    } else {
<span class="nc" id="L969">                        commentType = Token.CommentType.BLOCK_COMMENT;</span>
                    }
                    for (;;) {
<span class="nc" id="L972">                        c = getChar();</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">                        if (c == EOF_CHAR) {</span>
<span class="nc" id="L974">                            tokenEnd = cursor - 1;</span>
<span class="nc" id="L975">                            parser.addError(&quot;msg.unterminated.comment&quot;);</span>
<span class="nc" id="L976">                            return Token.COMMENT;</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">                        } else if (c == '*') {</span>
<span class="nc" id="L978">                            lookForSlash = true;</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">                        } else if (c == '/') {</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">                            if (lookForSlash) {</span>
<span class="nc" id="L981">                                tokenEnd = cursor;</span>
<span class="nc" id="L982">                                return Token.COMMENT;</span>
                            }
                        } else {
<span class="nc" id="L985">                            lookForSlash = false;</span>
<span class="nc" id="L986">                            tokenEnd = cursor;</span>
                        }
                    }
                }

<span class="pc bpc" id="L991" title="1 of 2 branches missed.">                if (matchChar('=')) {</span>
<span class="nc" id="L992">                    return Token.ASSIGN_DIV;</span>
                } else {
<span class="fc" id="L994">                    return Token.DIV;</span>
                }

            case '%':
<span class="pc bpc" id="L998" title="1 of 2 branches missed.">                if (matchChar('=')) {</span>
<span class="nc" id="L999">                    return Token.ASSIGN_MOD;</span>
                } else {
<span class="fc" id="L1001">                    return Token.MOD;</span>
                }

            case '~':
<span class="fc" id="L1005">                return Token.BITNOT;</span>

            case '+':
<span class="pc bpc" id="L1008" title="1 of 2 branches missed.">                if (matchChar('=')) {</span>
<span class="nc" id="L1009">                    return Token.ASSIGN_ADD;</span>
<span class="pc bpc" id="L1010" title="1 of 2 branches missed.">                } else if (matchChar('+')) {</span>
<span class="nc" id="L1011">                    return Token.INC;</span>
                } else {
<span class="fc" id="L1013">                    return Token.ADD;</span>
                }

            case '-':
<span class="pc bpc" id="L1017" title="1 of 2 branches missed.">                if (matchChar('=')) {</span>
<span class="nc" id="L1018">                    c = Token.ASSIGN_SUB;</span>
<span class="fc bfc" id="L1019" title="All 2 branches covered.">                } else if (matchChar('-')) {</span>
<span class="pc bpc" id="L1020" title="1 of 2 branches missed.">                    if (!dirtyLine) {</span>
                        // treat HTML end-comment after possible whitespace
                        // after line start as comment-until-eol
<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">                        if (matchChar('&gt;')) {</span>
<span class="nc" id="L1024">                            markCommentStart(&quot;--&quot;);</span>
<span class="nc" id="L1025">                            skipLine();</span>
<span class="nc" id="L1026">                            commentType = Token.CommentType.HTML;</span>
<span class="nc" id="L1027">                            return Token.COMMENT;</span>
                        }
                    }
<span class="fc" id="L1030">                    c = Token.DEC;</span>
                } else {
<span class="fc" id="L1032">                    c = Token.SUB;</span>
                }
<span class="fc" id="L1034">                dirtyLine = true;</span>
<span class="fc" id="L1035">                return c;</span>

            default:
<span class="fc" id="L1038">                parser.addError(&quot;msg.illegal.character&quot;, c);</span>
<span class="fc" id="L1039">                return Token.ERROR;</span>
            }
        }
    }

    private static boolean isAlpha(int c)
    {
        // Use 'Z' &lt; 'a'
<span class="pc bpc" id="L1047" title="1 of 2 branches missed.">        if (c &lt;= 'Z') {</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">            return 'A' &lt;= c;</span>
        } else {
<span class="pc bpc" id="L1050" title="2 of 4 branches missed.">            return 'a' &lt;= c &amp;&amp; c &lt;= 'z';</span>
        }
    }

    static boolean isDigit(int c)
    {
<span class="fc bfc" id="L1056" title="All 4 branches covered.">        return '0' &lt;= c &amp;&amp; c &lt;= '9';</span>
    }

    /* As defined in ECMA.  jsscan.c uses C isspace() (which allows
     * \v, I think.)  note that code in getChar() implicitly accepts
     * '\r' == \u000D as well.
     */
    static boolean isJSSpace(int c)
    {
<span class="fc bfc" id="L1065" title="All 2 branches covered.">        if (c &lt;= 127) {</span>
<span class="pc bpc" id="L1066" title="3 of 8 branches missed.">            return c == 0x20 || c == 0x9 || c == 0xC || c == 0xB;</span>
        } else {
<span class="pc bpc" id="L1068" title="2 of 4 branches missed.">            return c == 0xA0 || c == BYTE_ORDER_MARK</span>
<span class="pc bpc" id="L1069" title="1 of 2 branches missed.">                || Character.getType((char)c) == Character.SPACE_SEPARATOR;</span>
        }
    }

    private static boolean isJSFormatChar(int c)
    {
<span class="nc bnc" id="L1075" title="All 4 branches missed.">        return c &gt; 127 &amp;&amp; Character.getType((char)c) == Character.FORMAT;</span>
    }

    /**
     * Parser calls the method when it gets / or /= in literal context.
     */
    void readRegExp(int startToken)
        throws IOException
    {
<span class="fc" id="L1084">        int start = tokenBeg;</span>
<span class="fc" id="L1085">        stringBufferTop = 0;</span>
<span class="pc bpc" id="L1086" title="1 of 2 branches missed.">        if (startToken == Token.ASSIGN_DIV) {</span>
            // Miss-scanned /=
<span class="fc" id="L1088">            addToString('=');</span>
        } else {
<span class="nc bnc" id="L1090" title="All 2 branches missed.">            if (startToken != Token.DIV) Kit.codeBug();</span>
        }

<span class="fc" id="L1093">        boolean inCharSet = false; // true if inside a '['..']' pair</span>
        int c;
<span class="pc bpc" id="L1095" title="2 of 4 branches missed.">        while ((c = getChar()) != '/' || inCharSet) {</span>
<span class="nc bnc" id="L1096" title="All 4 branches missed.">            if (c == '\n' || c == EOF_CHAR) {</span>
<span class="nc" id="L1097">                ungetChar(c);</span>
<span class="nc" id="L1098">                tokenEnd = cursor - 1;</span>
<span class="nc" id="L1099">                this.string = new String(stringBuffer, 0, stringBufferTop);</span>
<span class="nc" id="L1100">                parser.reportError(&quot;msg.unterminated.re.lit&quot;);</span>
<span class="nc" id="L1101">                return;</span>
            }
<span class="nc bnc" id="L1103" title="All 2 branches missed.">            if (c == '\\') {</span>
<span class="nc" id="L1104">                addToString(c);</span>
<span class="nc" id="L1105">                c = getChar();</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">            } else if (c == '[') {</span>
<span class="nc" id="L1107">                inCharSet = true;</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">            } else if (c == ']') {</span>
<span class="nc" id="L1109">                inCharSet = false;</span>
            }
<span class="nc" id="L1111">            addToString(c);</span>
        }
<span class="fc" id="L1113">        int reEnd = stringBufferTop;</span>

        while (true) {
<span class="pc bpc" id="L1116" title="1 of 2 branches missed.">            if (matchChar('g'))</span>
<span class="nc" id="L1117">                addToString('g');</span>
<span class="pc bpc" id="L1118" title="1 of 2 branches missed.">            else if (matchChar('i'))</span>
<span class="nc" id="L1119">                addToString('i');</span>
<span class="pc bpc" id="L1120" title="1 of 2 branches missed.">            else if (matchChar('m'))</span>
<span class="nc" id="L1121">                addToString('m');</span>
<span class="pc bpc" id="L1122" title="1 of 2 branches missed.">            else if (matchChar('y'))  // FireFox 3</span>
<span class="nc" id="L1123">                addToString('y');</span>
            else
                break;
        }
<span class="fc" id="L1127">        tokenEnd = start + stringBufferTop + 2;  // include slashes</span>

<span class="pc bpc" id="L1129" title="1 of 2 branches missed.">        if (isAlpha(peekChar())) {</span>
<span class="nc" id="L1130">            parser.reportError(&quot;msg.invalid.re.flag&quot;);</span>
        }

<span class="nc" id="L1133">        this.string = new String(stringBuffer, 0, reEnd);</span>
<span class="nc" id="L1134">        this.regExpFlags = new String(stringBuffer, reEnd,</span>
                                      stringBufferTop - reEnd);
<span class="nc" id="L1136">    }</span>

    String readAndClearRegExpFlags() {
<span class="fc" id="L1139">        String flags = this.regExpFlags;</span>
<span class="fc" id="L1140">        this.regExpFlags = null;</span>
<span class="fc" id="L1141">        return flags;</span>
    }

    boolean isXMLAttribute()
    {
<span class="fc" id="L1146">        return xmlIsAttribute;</span>
    }

    int getFirstXMLToken() throws IOException
    {
<span class="fc" id="L1151">        xmlOpenTagsCount = 0;</span>
<span class="fc" id="L1152">        xmlIsAttribute = false;</span>
<span class="fc" id="L1153">        xmlIsTagContent = false;</span>
<span class="pc bpc" id="L1154" title="1 of 2 branches missed.">        if (!canUngetChar())</span>
<span class="nc" id="L1155">            return Token.ERROR;</span>
<span class="fc" id="L1156">        ungetChar('&lt;');</span>
<span class="nc" id="L1157">        return getNextXMLToken();</span>
    }

    int getNextXMLToken() throws IOException
    {
<span class="fc" id="L1162">        tokenBeg = cursor;</span>
<span class="fc" id="L1163">        stringBufferTop = 0; // remember the XML</span>

<span class="fc bfc" id="L1165" title="All 2 branches covered.">        for (int c = getChar(); c != EOF_CHAR; c = getChar()) {</span>
<span class="fc bfc" id="L1166" title="All 2 branches covered.">            if (xmlIsTagContent) {</span>
<span class="pc bpc" id="L1167" title="3 of 7 branches missed.">                switch (c) {</span>
                case '&gt;':
<span class="fc" id="L1169">                    addToString(c);</span>
<span class="fc" id="L1170">                    xmlIsTagContent = false;</span>
<span class="fc" id="L1171">                    xmlIsAttribute = false;</span>
<span class="fc" id="L1172">                    break;</span>
                case '/':
<span class="nc" id="L1174">                    addToString(c);</span>
<span class="nc bnc" id="L1175" title="All 2 branches missed.">                    if (peekChar() == '&gt;') {</span>
<span class="nc" id="L1176">                        c = getChar();</span>
<span class="nc" id="L1177">                        addToString(c);</span>
<span class="nc" id="L1178">                        xmlIsTagContent = false;</span>
<span class="nc" id="L1179">                        xmlOpenTagsCount--;</span>
                    }
                    break;
                case '{':
<span class="nc" id="L1183">                    ungetChar(c);</span>
<span class="nc" id="L1184">                    this.string = getStringFromBuffer();</span>
<span class="nc" id="L1185">                    return Token.XML;</span>
                case '\'':
                case '&quot;':
<span class="fc" id="L1188">                    addToString(c);</span>
<span class="nc bnc" id="L1189" title="All 2 branches missed.">                    if (!readQuotedString(c)) return Token.ERROR;</span>
                    break;
                case '=':
<span class="fc" id="L1192">                    addToString(c);</span>
<span class="fc" id="L1193">                    xmlIsAttribute = true;</span>
<span class="fc" id="L1194">                    break;</span>
                case ' ':
                case '\t':
                case '\r':
                case '\n':
<span class="nc" id="L1199">                    addToString(c);</span>
<span class="nc" id="L1200">                    break;</span>
                default:
<span class="fc" id="L1202">                    addToString(c);</span>
<span class="fc" id="L1203">                    xmlIsAttribute = false;</span>
                    break;
                }

<span class="pc bpc" id="L1207" title="1 of 4 branches missed.">                if (!xmlIsTagContent &amp;&amp; xmlOpenTagsCount == 0) {</span>
<span class="nc" id="L1208">                    this.string = getStringFromBuffer();</span>
<span class="nc" id="L1209">                    return Token.XMLEND;</span>
                }
            } else {
<span class="pc bpc" id="L1212" title="1 of 3 branches missed.">                switch (c) {</span>
                case '&lt;':
<span class="fc" id="L1214">                    addToString(c);</span>
<span class="fc" id="L1215">                    c = peekChar();</span>
<span class="pc bpc" id="L1216" title="2 of 4 branches missed.">                    switch (c) {</span>
                    case '!':
<span class="nc" id="L1218">                        c = getChar(); // Skip !</span>
<span class="nc" id="L1219">                        addToString(c);</span>
<span class="nc" id="L1220">                        c = peekChar();</span>
<span class="nc bnc" id="L1221" title="All 3 branches missed.">                        switch (c) {</span>
                        case '-':
<span class="nc" id="L1223">                            c = getChar(); // Skip -</span>
<span class="nc" id="L1224">                            addToString(c);</span>
<span class="nc" id="L1225">                            c = getChar();</span>
<span class="nc bnc" id="L1226" title="All 2 branches missed.">                            if (c == '-') {</span>
<span class="nc" id="L1227">                                addToString(c);</span>
<span class="nc bnc" id="L1228" title="All 2 branches missed.">                                if(!readXmlComment()) return Token.ERROR;</span>
                            } else {
                                // throw away the string in progress
<span class="nc" id="L1231">                                stringBufferTop = 0;</span>
<span class="nc" id="L1232">                                this.string = null;</span>
<span class="nc" id="L1233">                                parser.addError(&quot;msg.XML.bad.form&quot;);</span>
<span class="nc" id="L1234">                                return Token.ERROR;</span>
                            }
                            break;
                        case '[':
<span class="nc" id="L1238">                            c = getChar(); // Skip [</span>
<span class="nc" id="L1239">                            addToString(c);</span>
<span class="nc bnc" id="L1240" title="All 2 branches missed.">                            if (getChar() == 'C' &amp;&amp;</span>
<span class="nc bnc" id="L1241" title="All 2 branches missed.">                                getChar() == 'D' &amp;&amp;</span>
<span class="nc bnc" id="L1242" title="All 2 branches missed.">                                getChar() == 'A' &amp;&amp;</span>
<span class="nc bnc" id="L1243" title="All 2 branches missed.">                                getChar() == 'T' &amp;&amp;</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">                                getChar() == 'A' &amp;&amp;</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">                                getChar() == '[')</span>
                            {
<span class="nc" id="L1247">                                addToString('C');</span>
<span class="nc" id="L1248">                                addToString('D');</span>
<span class="nc" id="L1249">                                addToString('A');</span>
<span class="nc" id="L1250">                                addToString('T');</span>
<span class="nc" id="L1251">                                addToString('A');</span>
<span class="nc" id="L1252">                                addToString('[');</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">                                if (!readCDATA()) return Token.ERROR;</span>

                            } else {
                                // throw away the string in progress
<span class="nc" id="L1257">                                stringBufferTop = 0;</span>
<span class="nc" id="L1258">                                this.string = null;</span>
<span class="nc" id="L1259">                                parser.addError(&quot;msg.XML.bad.form&quot;);</span>
<span class="nc" id="L1260">                                return Token.ERROR;</span>
                            }
                            break;
                        default:
<span class="nc bnc" id="L1264" title="All 2 branches missed.">                            if(!readEntity()) return Token.ERROR;</span>
                            break;
                        }
                        break;
                    case '?':
<span class="nc" id="L1269">                        c = getChar(); // Skip ?</span>
<span class="nc" id="L1270">                        addToString(c);</span>
<span class="nc bnc" id="L1271" title="All 2 branches missed.">                        if (!readPI()) return Token.ERROR;</span>
                        break;
                    case '/':
                        // End tag
<span class="fc" id="L1275">                        c = getChar(); // Skip /</span>
<span class="fc" id="L1276">                        addToString(c);</span>
<span class="pc bpc" id="L1277" title="1 of 2 branches missed.">                        if (xmlOpenTagsCount == 0) {</span>
                            // throw away the string in progress
<span class="fc" id="L1279">                            stringBufferTop = 0;</span>
<span class="fc" id="L1280">                            this.string = null;</span>
<span class="nc" id="L1281">                            parser.addError(&quot;msg.XML.bad.form&quot;);</span>
<span class="nc" id="L1282">                            return Token.ERROR;</span>
                        }
<span class="nc" id="L1284">                        xmlIsTagContent = true;</span>
<span class="nc" id="L1285">                        xmlOpenTagsCount--;</span>
<span class="nc" id="L1286">                        break;</span>
                    default:
                        // Start tag
<span class="fc" id="L1289">                        xmlIsTagContent = true;</span>
<span class="fc" id="L1290">                        xmlOpenTagsCount++;</span>
<span class="fc" id="L1291">                        break;</span>
                    }
                    break;
                case '{':
<span class="nc" id="L1295">                    ungetChar(c);</span>
<span class="nc" id="L1296">                    this.string = getStringFromBuffer();</span>
<span class="nc" id="L1297">                    return Token.XML;</span>
                default:
<span class="fc" id="L1299">                    addToString(c);</span>
                    break;
                }
            }
        }

<span class="fc" id="L1305">        tokenEnd = cursor;</span>
<span class="fc" id="L1306">        stringBufferTop = 0; // throw away the string in progress</span>
<span class="fc" id="L1307">        this.string = null;</span>
<span class="nc" id="L1308">        parser.addError(&quot;msg.XML.bad.form&quot;);</span>
<span class="nc" id="L1309">        return Token.ERROR;</span>
    }

    /**
     *
     */
    private boolean readQuotedString(int quote) throws IOException
    {
<span class="fc bfc" id="L1317" title="All 2 branches covered.">        for (int c = getChar(); c != EOF_CHAR; c = getChar()) {</span>
<span class="fc" id="L1318">            addToString(c);</span>
<span class="pc bpc" id="L1319" title="1 of 2 branches missed.">            if (c == quote) return true;</span>
        }

<span class="fc" id="L1322">        stringBufferTop = 0; // throw away the string in progress</span>
<span class="fc" id="L1323">        this.string = null;</span>
<span class="nc" id="L1324">        parser.addError(&quot;msg.XML.bad.form&quot;);</span>
<span class="nc" id="L1325">        return false;</span>
    }

    /**
     *
     */
    private boolean readXmlComment() throws IOException
    {
<span class="nc bnc" id="L1333" title="All 2 branches missed.">        for (int c = getChar(); c != EOF_CHAR;) {</span>
<span class="nc" id="L1334">            addToString(c);</span>
<span class="nc bnc" id="L1335" title="All 4 branches missed.">            if (c == '-' &amp;&amp; peekChar() == '-') {</span>
<span class="nc" id="L1336">                c = getChar();</span>
<span class="nc" id="L1337">                addToString(c);</span>
<span class="nc bnc" id="L1338" title="All 2 branches missed.">                if (peekChar() == '&gt;') {</span>
<span class="nc" id="L1339">                    c = getChar(); // Skip &gt;</span>
<span class="nc" id="L1340">                    addToString(c);</span>
<span class="nc" id="L1341">                    return true;</span>
                } else {
                    continue;
                }
            }
<span class="nc" id="L1346">            c = getChar();</span>
        }

<span class="nc" id="L1349">        stringBufferTop = 0; // throw away the string in progress</span>
<span class="nc" id="L1350">        this.string = null;</span>
<span class="nc" id="L1351">        parser.addError(&quot;msg.XML.bad.form&quot;);</span>
<span class="nc" id="L1352">        return false;</span>
    }

    /**
     *
     */
    private boolean readCDATA() throws IOException
    {
<span class="nc bnc" id="L1360" title="All 2 branches missed.">        for (int c = getChar(); c != EOF_CHAR;) {</span>
<span class="nc" id="L1361">            addToString(c);</span>
<span class="nc bnc" id="L1362" title="All 4 branches missed.">            if (c == ']' &amp;&amp; peekChar() == ']') {</span>
<span class="nc" id="L1363">                c = getChar();</span>
<span class="nc" id="L1364">                addToString(c);</span>
<span class="nc bnc" id="L1365" title="All 2 branches missed.">                if (peekChar() == '&gt;') {</span>
<span class="nc" id="L1366">                    c = getChar(); // Skip &gt;</span>
<span class="nc" id="L1367">                    addToString(c);</span>
<span class="nc" id="L1368">                    return true;</span>
                } else {
                    continue;
                }
            }
<span class="nc" id="L1373">            c = getChar();</span>
        }

<span class="nc" id="L1376">        stringBufferTop = 0; // throw away the string in progress</span>
<span class="nc" id="L1377">        this.string = null;</span>
<span class="nc" id="L1378">        parser.addError(&quot;msg.XML.bad.form&quot;);</span>
<span class="nc" id="L1379">        return false;</span>
    }

    /**
     *
     */
    private boolean readEntity() throws IOException
    {
<span class="nc" id="L1387">        int declTags = 1;</span>
<span class="nc bnc" id="L1388" title="All 2 branches missed.">        for (int c = getChar(); c != EOF_CHAR; c = getChar()) {</span>
<span class="nc" id="L1389">            addToString(c);</span>
<span class="nc bnc" id="L1390" title="All 3 branches missed.">            switch (c) {</span>
            case '&lt;':
<span class="nc" id="L1392">                declTags++;</span>
<span class="nc" id="L1393">                break;</span>
            case '&gt;':
<span class="nc" id="L1395">                declTags--;</span>
<span class="nc bnc" id="L1396" title="All 2 branches missed.">                if (declTags == 0) return true;</span>
                break;
            }
        }

<span class="nc" id="L1401">        stringBufferTop = 0; // throw away the string in progress</span>
<span class="nc" id="L1402">        this.string = null;</span>
<span class="nc" id="L1403">        parser.addError(&quot;msg.XML.bad.form&quot;);</span>
<span class="nc" id="L1404">        return false;</span>
    }

    /**
     *
     */
    private boolean readPI() throws IOException
    {
<span class="nc bnc" id="L1412" title="All 2 branches missed.">        for (int c = getChar(); c != EOF_CHAR; c = getChar()) {</span>
<span class="nc" id="L1413">            addToString(c);</span>
<span class="nc bnc" id="L1414" title="All 4 branches missed.">            if (c == '?' &amp;&amp; peekChar() == '&gt;') {</span>
<span class="nc" id="L1415">                c = getChar(); // Skip &gt;</span>
<span class="nc" id="L1416">                addToString(c);</span>
<span class="nc" id="L1417">                return true;</span>
            }
        }

<span class="nc" id="L1421">        stringBufferTop = 0; // throw away the string in progress</span>
<span class="nc" id="L1422">        this.string = null;</span>
<span class="nc" id="L1423">        parser.addError(&quot;msg.XML.bad.form&quot;);</span>
<span class="nc" id="L1424">        return false;</span>
    }

    private String getStringFromBuffer()
    {
<span class="fc" id="L1429">        tokenEnd = cursor;</span>
<span class="fc" id="L1430">        return new String(stringBuffer, 0, stringBufferTop);</span>
    }

    private void addToString(int c)
    {
<span class="fc" id="L1435">        int N = stringBufferTop;</span>
<span class="pc bpc" id="L1436" title="1 of 2 branches missed.">        if (N == stringBuffer.length) {</span>
<span class="nc" id="L1437">            char[] tmp = new char[stringBuffer.length * 2];</span>
<span class="nc" id="L1438">            System.arraycopy(stringBuffer, 0, tmp, 0, N);</span>
<span class="nc" id="L1439">            stringBuffer = tmp;</span>
        }
<span class="fc" id="L1441">        stringBuffer[N] = (char)c;</span>
<span class="fc" id="L1442">        stringBufferTop = N + 1;</span>
<span class="fc" id="L1443">    }</span>

    private boolean canUngetChar() {
<span class="pc bpc" id="L1446" title="3 of 4 branches missed.">        return ungetCursor == 0 || ungetBuffer[ungetCursor - 1] != '\n';</span>
    }

    private void ungetChar(int c)
    {
        // can not unread past across line boundary
<span class="pc bpc" id="L1452" title="3 of 4 branches missed.">        if (ungetCursor != 0 &amp;&amp; ungetBuffer[ungetCursor - 1] == '\n')</span>
<span class="nc" id="L1453">            Kit.codeBug();</span>
<span class="fc" id="L1454">        ungetBuffer[ungetCursor++] = c;</span>
<span class="fc" id="L1455">        cursor--;</span>
<span class="fc" id="L1456">    }</span>

    private boolean matchChar(int test) throws IOException
    {
<span class="fc" id="L1460">        int c = getCharIgnoreLineEnd();</span>
<span class="fc bfc" id="L1461" title="All 2 branches covered.">        if (c == test) {</span>
<span class="fc" id="L1462">            tokenEnd = cursor;</span>
<span class="fc" id="L1463">            return true;</span>
        } else {
<span class="fc" id="L1465">            ungetCharIgnoreLineEnd(c);</span>
<span class="fc" id="L1466">            return false;</span>
        }
    }

    private int peekChar() throws IOException
    {
<span class="fc" id="L1472">        int c = getChar();</span>
<span class="fc" id="L1473">        ungetChar(c);</span>
<span class="fc" id="L1474">        return c;</span>
    }

    private int getChar() throws IOException
    {
<span class="fc" id="L1479">        return getChar(true);</span>
    }

    private int getChar(boolean skipFormattingChars) throws IOException
    {
<span class="fc bfc" id="L1484" title="All 2 branches covered.">        if (ungetCursor != 0) {</span>
<span class="fc" id="L1485">            cursor++;</span>
<span class="fc" id="L1486">            return ungetBuffer[--ungetCursor];</span>
        }

        for(;;) {
            int c;
<span class="fc bfc" id="L1491" title="All 2 branches covered.">            if (sourceString != null) {</span>
<span class="fc bfc" id="L1492" title="All 2 branches covered.">                if (sourceCursor == sourceEnd) {</span>
<span class="fc" id="L1493">                    hitEOF = true;</span>
<span class="fc" id="L1494">                    return EOF_CHAR;</span>
                }
<span class="fc" id="L1496">                cursor++;</span>
<span class="fc" id="L1497">                c = sourceString.charAt(sourceCursor++);</span>
            } else {
<span class="fc bfc" id="L1499" title="All 2 branches covered.">                if (sourceCursor == sourceEnd) {</span>
<span class="fc bfc" id="L1500" title="All 2 branches covered.">                    if (!fillSourceBuffer()) {</span>
<span class="fc" id="L1501">                        hitEOF = true;</span>
<span class="fc" id="L1502">                        return EOF_CHAR;</span>
                    }
                }
<span class="fc" id="L1505">                cursor++;</span>
<span class="fc" id="L1506">                c = sourceBuffer[sourceCursor++];</span>
            }

<span class="pc bpc" id="L1509" title="1 of 2 branches missed.">            if (lineEndChar &gt;= 0) {</span>
<span class="nc bnc" id="L1510" title="All 4 branches missed.">                if (lineEndChar == '\r' &amp;&amp; c == '\n') {</span>
<span class="nc" id="L1511">                    lineEndChar = '\n';</span>
<span class="nc" id="L1512">                    continue;</span>
                }
<span class="nc" id="L1514">                lineEndChar = -1;</span>
<span class="nc" id="L1515">                lineStart = sourceCursor - 1;</span>
<span class="nc" id="L1516">                lineno++;</span>
            }

<span class="pc bpc" id="L1519" title="1 of 2 branches missed.">            if (c &lt;= 127) {</span>
<span class="pc bpc" id="L1520" title="1 of 4 branches missed.">                if (c == '\n' || c == '\r') {</span>
<span class="fc" id="L1521">                    lineEndChar = c;</span>
<span class="fc" id="L1522">                    c = '\n';</span>
                }
            } else {
<span class="nc bnc" id="L1525" title="All 2 branches missed.">                if (c == BYTE_ORDER_MARK) return c; // BOM is considered whitespace</span>
<span class="nc bnc" id="L1526" title="All 4 branches missed.">                if (skipFormattingChars &amp;&amp; isJSFormatChar(c)) {</span>
<span class="nc" id="L1527">                    continue;</span>
                }
<span class="nc bnc" id="L1529" title="All 2 branches missed.">                if (ScriptRuntime.isJSLineTerminator(c)) {</span>
<span class="nc" id="L1530">                    lineEndChar = c;</span>
<span class="nc" id="L1531">                    c = '\n';</span>
                }
            }
<span class="fc" id="L1534">            return c;</span>
        }
    }

    private int getCharIgnoreLineEnd() throws IOException
    {
<span class="fc bfc" id="L1540" title="All 2 branches covered.">        if (ungetCursor != 0) {</span>
<span class="fc" id="L1541">            cursor++;</span>
<span class="fc" id="L1542">            return ungetBuffer[--ungetCursor];</span>
        }

        for(;;) {
            int c;
<span class="fc bfc" id="L1547" title="All 2 branches covered.">            if (sourceString != null) {</span>
<span class="fc bfc" id="L1548" title="All 2 branches covered.">                if (sourceCursor == sourceEnd) {</span>
<span class="fc" id="L1549">                    hitEOF = true;</span>
<span class="fc" id="L1550">                    return EOF_CHAR;</span>
                }
<span class="fc" id="L1552">                cursor++;</span>
<span class="fc" id="L1553">                c = sourceString.charAt(sourceCursor++);</span>
            } else {
<span class="fc bfc" id="L1555" title="All 2 branches covered.">                if (sourceCursor == sourceEnd) {</span>
<span class="pc bpc" id="L1556" title="1 of 2 branches missed.">                    if (!fillSourceBuffer()) {</span>
<span class="fc" id="L1557">                        hitEOF = true;</span>
<span class="fc" id="L1558">                        return EOF_CHAR;</span>
                    }
                }
<span class="fc" id="L1561">                cursor++;</span>
<span class="fc" id="L1562">                c = sourceBuffer[sourceCursor++];</span>
            }

<span class="pc bpc" id="L1565" title="1 of 2 branches missed.">            if (c &lt;= 127) {</span>
<span class="pc bpc" id="L1566" title="1 of 4 branches missed.">                if (c == '\n' || c == '\r') {</span>
<span class="fc" id="L1567">                    lineEndChar = c;</span>
<span class="fc" id="L1568">                    c = '\n';</span>
                }
            } else {
<span class="nc bnc" id="L1571" title="All 2 branches missed.">                if (c == BYTE_ORDER_MARK) return c; // BOM is considered whitespace</span>
<span class="nc bnc" id="L1572" title="All 2 branches missed.">                if (isJSFormatChar(c)) {</span>
<span class="nc" id="L1573">                    continue;</span>
                }
<span class="nc bnc" id="L1575" title="All 2 branches missed.">                if (ScriptRuntime.isJSLineTerminator(c)) {</span>
<span class="nc" id="L1576">                    lineEndChar = c;</span>
<span class="nc" id="L1577">                    c = '\n';</span>
                }
            }
<span class="fc" id="L1580">            return c;</span>
        }
    }

    private void ungetCharIgnoreLineEnd(int c)
    {
<span class="fc" id="L1586">        ungetBuffer[ungetCursor++] = c;</span>
<span class="fc" id="L1587">        cursor--;</span>
<span class="fc" id="L1588">    }</span>

    private void skipLine() throws IOException
    {
        // skip to end of line
        int c;
<span class="nc bnc" id="L1594" title="All 4 branches missed.">        while ((c = getChar()) != EOF_CHAR &amp;&amp; c != '\n') { }</span>
<span class="nc" id="L1595">        ungetChar(c);</span>
<span class="nc" id="L1596">        tokenEnd = cursor;</span>
<span class="nc" id="L1597">    }</span>

    /**
     * Returns the offset into the current line.
     */
    final int getOffset()
    {
<span class="fc" id="L1604">        int n = sourceCursor - lineStart;</span>
<span class="fc bfc" id="L1605" title="All 2 branches covered.">        if (lineEndChar &gt;= 0) { --n; }</span>
<span class="fc" id="L1606">        return n;</span>
    }

    private final int charAt(int index) {
<span class="pc bpc" id="L1610" title="1 of 2 branches missed.">        if (index &lt; 0) {</span>
<span class="nc" id="L1611">            return EOF_CHAR;</span>
        }
<span class="fc bfc" id="L1613" title="All 2 branches covered.">        if (sourceString != null) {</span>
<span class="fc bfc" id="L1614" title="All 2 branches covered.">            if (index &gt;= sourceEnd) {</span>
<span class="fc" id="L1615">                return EOF_CHAR;</span>
            }
<span class="fc" id="L1617">            return sourceString.charAt(index);</span>
        } else {
<span class="fc bfc" id="L1619" title="All 2 branches covered.">            if (index &gt;= sourceEnd) {</span>
<span class="fc" id="L1620">                int oldSourceCursor = sourceCursor;</span>
                try {
<span class="pc bpc" id="L1622" title="1 of 2 branches missed.">                    if (!fillSourceBuffer()) { return EOF_CHAR; }</span>
<span class="nc" id="L1623">                } catch (IOException ioe) {</span>
                    // ignore it, we're already displaying an error...
<span class="nc" id="L1625">                    return EOF_CHAR;</span>
<span class="nc" id="L1626">                }</span>
                // index recalculuation as fillSourceBuffer can move saved
                // line buffer and change sourceCursor
<span class="nc" id="L1629">                index -= (oldSourceCursor - sourceCursor);</span>
            }
<span class="fc" id="L1631">            return sourceBuffer[index];</span>
        }
    }

    private final String substring(int beginIndex, int endIndex) {
<span class="fc bfc" id="L1636" title="All 2 branches covered.">        if (sourceString != null) {</span>
<span class="fc" id="L1637">            return sourceString.substring(beginIndex, endIndex);</span>
        } else {
<span class="fc" id="L1639">            int count = endIndex - beginIndex;</span>
<span class="fc" id="L1640">            return new String(sourceBuffer, beginIndex, count);</span>
        }
    }

    final String getLine() {
<span class="fc" id="L1645">        int lineEnd = sourceCursor;</span>
<span class="fc bfc" id="L1646" title="All 2 branches covered.">        if (lineEndChar &gt;= 0) {</span>
            // move cursor before newline sequence
<span class="fc" id="L1648">            lineEnd -= 1;</span>
<span class="pc bpc" id="L1649" title="2 of 4 branches missed.">            if (lineEndChar == '\n' &amp;&amp; charAt(lineEnd - 1) == '\r') {</span>
<span class="nc" id="L1650">                lineEnd -= 1;</span>
            }
        } else {
            // Read until the end of line
<span class="fc" id="L1654">            int lineLength = lineEnd - lineStart;</span>
<span class="fc" id="L1655">            for (;; ++lineLength) {</span>
<span class="fc" id="L1656">                int c = charAt(lineStart + lineLength);</span>
<span class="fc bfc" id="L1657" title="All 4 branches covered.">                if (c == EOF_CHAR || ScriptRuntime.isJSLineTerminator(c)) {</span>
<span class="fc" id="L1658">                    break;</span>
                }
            }
<span class="fc" id="L1661">            lineEnd = lineStart + lineLength;</span>
        }
<span class="fc" id="L1663">        return substring(lineStart, lineEnd);</span>
    }

    final String getLine(int position, int[] linep) {
<span class="pc bpc" id="L1667" title="3 of 6 branches missed.">        assert position &gt;= 0 &amp;&amp; position &lt;= cursor;</span>
<span class="pc bpc" id="L1668" title="2 of 4 branches missed.">        assert linep.length == 2;</span>
<span class="fc" id="L1669">        int delta = (cursor + ungetCursor) - position;</span>
<span class="fc" id="L1670">        int cur = sourceCursor;</span>
<span class="pc bpc" id="L1671" title="1 of 2 branches missed.">        if (delta &gt; cur) {</span>
            // requested line outside of source buffer
<span class="nc" id="L1673">            return null;</span>
        }
        // read back until position
<span class="fc" id="L1676">        int end = 0, lines = 0;</span>
<span class="fc bfc" id="L1677" title="All 2 branches covered.">        for (; delta &gt; 0; --delta, --cur) {</span>
<span class="pc bpc" id="L1678" title="2 of 4 branches missed.">            assert cur &gt; 0;</span>
<span class="fc" id="L1679">            int c = charAt(cur - 1);</span>
<span class="fc bfc" id="L1680" title="All 2 branches covered.">            if (ScriptRuntime.isJSLineTerminator(c)) {</span>
<span class="pc bpc" id="L1681" title="2 of 4 branches missed.">                if (c == '\n' &amp;&amp; charAt(cur - 2) == '\r') {</span>
                    // \r\n sequence
<span class="nc" id="L1683">                    delta -= 1;</span>
<span class="nc" id="L1684">                    cur -= 1;</span>
                }
<span class="fc" id="L1686">                lines += 1;</span>
<span class="fc" id="L1687">                end = cur - 1;</span>
            }
        }
        // read back until line start
<span class="fc" id="L1691">        int start = 0, offset = 0;</span>
<span class="fc bfc" id="L1692" title="All 2 branches covered.">        for (; cur &gt; 0; --cur, ++offset) {</span>
<span class="fc" id="L1693">            int c = charAt(cur - 1);</span>
<span class="pc bpc" id="L1694" title="1 of 2 branches missed.">            if (ScriptRuntime.isJSLineTerminator(c)) {</span>
<span class="nc" id="L1695">                start = cur;</span>
<span class="nc" id="L1696">                break;</span>
            }
        }
<span class="fc bfc" id="L1699" title="All 2 branches covered.">        linep[0] = lineno - lines + (lineEndChar &gt;= 0 ? 1 : 0);</span>
<span class="fc" id="L1700">        linep[1] = offset;</span>
<span class="fc bfc" id="L1701" title="All 2 branches covered.">        if (lines == 0) {</span>
<span class="fc" id="L1702">            return getLine();</span>
        } else {
<span class="fc" id="L1704">            return substring(start, end);</span>
        }
    }

    private boolean fillSourceBuffer() throws IOException
    {
<span class="pc bpc" id="L1710" title="1 of 2 branches missed.">        if (sourceString != null) Kit.codeBug();</span>
<span class="pc bpc" id="L1711" title="1 of 2 branches missed.">        if (sourceEnd == sourceBuffer.length) {</span>
<span class="nc bnc" id="L1712" title="All 4 branches missed.">            if (lineStart != 0 &amp;&amp; !isMarkingComment()) {</span>
<span class="nc" id="L1713">                System.arraycopy(sourceBuffer, lineStart, sourceBuffer, 0,</span>
                                 sourceEnd - lineStart);
<span class="nc" id="L1715">                sourceEnd -= lineStart;</span>
<span class="nc" id="L1716">                sourceCursor -= lineStart;</span>
<span class="nc" id="L1717">                lineStart = 0;</span>
            } else {
<span class="nc" id="L1719">                char[] tmp = new char[sourceBuffer.length * 2];</span>
<span class="nc" id="L1720">                System.arraycopy(sourceBuffer, 0, tmp, 0, sourceEnd);</span>
<span class="nc" id="L1721">                sourceBuffer = tmp;</span>
            }
        }
<span class="fc" id="L1724">        int n = sourceReader.read(sourceBuffer, sourceEnd,</span>
                                  sourceBuffer.length - sourceEnd);
<span class="fc bfc" id="L1726" title="All 2 branches covered.">        if (n &lt; 0) {</span>
<span class="fc" id="L1727">            return false;</span>
        }
<span class="fc" id="L1729">        sourceEnd += n;</span>
<span class="fc" id="L1730">        return true;</span>
    }

    /**
     * Return the current position of the scanner cursor.
     */
    public int getCursor() {
<span class="fc" id="L1737">        return cursor;</span>
    }

    /**
     * Return the absolute source offset of the last scanned token.
     */
    public int getTokenBeg() {
<span class="fc" id="L1744">        return tokenBeg;</span>
    }

    /**
     * Return the absolute source end-offset of the last scanned token.
     */
    public int getTokenEnd() {
<span class="fc" id="L1751">        return tokenEnd;</span>
    }

    /**
     * Return tokenEnd - tokenBeg
     */
    public int getTokenLength() {
<span class="fc" id="L1758">        return tokenEnd - tokenBeg;</span>
    }

    /**
     * Return the type of the last scanned comment.
     * @return type of last scanned comment, or 0 if none have been scanned.
     */
    public Token.CommentType getCommentType() {
<span class="fc" id="L1766">        return commentType;</span>
    }

    private void markCommentStart() {
<span class="fc" id="L1770">        markCommentStart(&quot;&quot;);</span>
<span class="fc" id="L1771">    }</span>

    private void markCommentStart(String prefix) {
<span class="pc bpc" id="L1774" title="1 of 4 branches missed.">        if (parser.compilerEnv.isRecordingComments() &amp;&amp; sourceReader != null) {</span>
<span class="nc" id="L1775">            commentPrefix = prefix;</span>
<span class="nc" id="L1776">            commentCursor = sourceCursor - 1;</span>
        }
<span class="fc" id="L1778">    }</span>

    private boolean isMarkingComment() {
<span class="pc bpc" id="L1781" title="1 of 2 branches missed.">        return commentCursor != -1;</span>
    }

     final String getAndResetCurrentComment() {
<span class="pc bpc" id="L1785" title="1 of 2 branches missed.">        if (sourceString != null) {</span>
<span class="pc bpc" id="L1786" title="1 of 2 branches missed.">            if (isMarkingComment()) Kit.codeBug();</span>
<span class="fc" id="L1787">            return sourceString.substring(tokenBeg, tokenEnd);</span>
        } else {
<span class="nc bnc" id="L1789" title="All 2 branches missed.">            if (!isMarkingComment()) Kit.codeBug();</span>
<span class="nc" id="L1790">            StringBuilder comment = new StringBuilder(commentPrefix);</span>
<span class="nc" id="L1791">            comment.append(sourceBuffer, commentCursor,</span>
<span class="nc" id="L1792">                getTokenLength() - commentPrefix.length());</span>
<span class="nc" id="L1793">            commentCursor = -1;</span>
<span class="nc" id="L1794">            return comment.toString();</span>
        }
    }

    private String convertLastCharToHex(String str) {
<span class="nc" id="L1799">      int lastIndex = str.length()-1;</span>
<span class="nc" id="L1800">      StringBuilder buf = new StringBuilder(</span>
<span class="nc" id="L1801">          str.substring(0, lastIndex));</span>
<span class="nc" id="L1802">      buf.append(&quot;\\u&quot;);</span>
<span class="nc" id="L1803">      String hexCode = Integer.toHexString(str.charAt(lastIndex));</span>
<span class="nc bnc" id="L1804" title="All 2 branches missed.">      for (int i = 0; i &lt; 4-hexCode.length(); ++i) {</span>
<span class="nc" id="L1805">        buf.append('0');</span>
      }
<span class="nc" id="L1807">      buf.append(hexCode);</span>
<span class="nc" id="L1808">      return buf.toString();</span>
    }

    // stuff other than whitespace since start of line
    private boolean dirtyLine;

    String regExpFlags;

    // Set this to an initial non-null value so that the Parser has
    // something to retrieve even if an error has occurred and no
    // string is found.  Fosters one class of error, but saves lots of
    // code.
<span class="fc" id="L1820">    private String string = &quot;&quot;;</span>
    private double number;
    private boolean isBinary;
    private boolean isOldOctal;
    private boolean isOctal;
    private boolean isHex;

    // delimiter for last string literal scanned
    private int quoteChar;

<span class="fc" id="L1830">    private char[] stringBuffer = new char[128];</span>
    private int stringBufferTop;
<span class="fc" id="L1832">    private ObjToIntMap allStrings = new ObjToIntMap(50);</span>

    // Room to backtrace from to &lt; on failed match of the last - in &lt;!--
<span class="fc" id="L1835">    private final int[] ungetBuffer = new int[3];</span>
    private int ungetCursor;

<span class="fc" id="L1838">    private boolean hitEOF = false;</span>

<span class="fc" id="L1840">    private int lineStart = 0;</span>
<span class="fc" id="L1841">    private int lineEndChar = -1;</span>
    int lineno;

    private String sourceString;
    private Reader sourceReader;
    private char[] sourceBuffer;
    private int sourceEnd;

    // sourceCursor is an index into a small buffer that keeps a
    // sliding window of the source stream.
    int sourceCursor;

    // cursor is a monotonically increasing index into the original
    // source stream, tracking exactly how far scanning has progressed.
    // Its value is the index of the next character to be scanned.
    int cursor;

    // Record start and end positions of last scanned token.
    int tokenBeg;
    int tokenEnd;

    // Type of last comment scanned.
    Token.CommentType commentType;

    // for xml tokenizer
    private boolean xmlIsAttribute;
    private boolean xmlIsTagContent;
    private int xmlOpenTagsCount;

    private Parser parser;

<span class="fc" id="L1872">    private String commentPrefix = &quot;&quot;;</span>
<span class="fc" id="L1873">    private int commentCursor = -1;</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>