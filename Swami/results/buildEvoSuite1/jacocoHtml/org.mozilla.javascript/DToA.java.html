<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DToA.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rhino-Rhino1_7_9_Release</a> &gt; <a href="index.source.html" class="el_package">org.mozilla.javascript</a> &gt; <span class="el_source">DToA.java</span></div><h1>DToA.java</h1><pre class="source lang-java linenums">/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/****************************************************************
  *
  * The author of this software is David M. Gay.
  *
  * Copyright (c) 1991, 2000, 2001 by Lucent Technologies.
  *
  * Permission to use, copy, modify, and distribute this software for any
  * purpose without fee is hereby granted, provided that this entire notice
  * is included in all copies of any software which is or includes a copy
  * or modification of this software and in all copies of the supporting
  * documentation for such software.
  *
  * THIS SOFTWARE IS BEING PROVIDED &quot;AS IS&quot;, WITHOUT ANY EXPRESS OR IMPLIED
  * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHOR NOR LUCENT MAKES ANY
  * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
  * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
  *
  ***************************************************************/

package org.mozilla.javascript;

import java.math.BigInteger;

<span class="fc" id="L30">class DToA {</span>


    private static char BASEDIGIT(int digit) {
<span class="fc bfc" id="L34" title="All 2 branches covered.">        return (char)((digit &gt;= 10) ? 'a' - 10 + digit : '0' + digit);</span>
    }

    static final int
        DTOSTR_STANDARD = 0,              /* Either fixed or exponential format; round-trip */
        DTOSTR_STANDARD_EXPONENTIAL = 1,  /* Always exponential format; round-trip */
        DTOSTR_FIXED = 2,                 /* Round to &lt;precision&gt; digits after the decimal point; exponential if number is large */
        DTOSTR_EXPONENTIAL = 3,           /* Always exponential format; &lt;precision&gt; significant digits */
        DTOSTR_PRECISION = 4;             /* Either fixed or exponential format; &lt;precision&gt; significant digits */


    private static final int Frac_mask = 0xfffff;
    private static final int Exp_shift = 20;
    private static final int Exp_msk1 = 0x100000;

    private static final long Frac_maskL = 0xfffffffffffffL;
    private static final int Exp_shiftL = 52;
    private static final long Exp_msk1L = 0x10000000000000L;

    private static final int Bias = 1023;
    private static final int P = 53;

    private static final int Exp_shift1 = 20;
    private static final int Exp_mask  = 0x7ff00000;
    private static final int Exp_mask_shifted = 0x7ff;
    private static final int Bndry_mask  = 0xfffff;
    private static final int Log2P = 1;

    private static final int Sign_bit = 0x80000000;
    private static final int Exp_11  = 0x3ff00000;
    private static final int Ten_pmax = 22;
    private static final int Quick_max = 14;
    private static final int Bletch = 0x10;
    private static final int Frac_mask1 = 0xfffff;
    private static final int Int_max = 14;
    private static final int n_bigtens = 5;


<span class="fc" id="L72">    private static final double tens[] = {</span>
        1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,
        1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,
        1e20, 1e21, 1e22
    };

<span class="fc" id="L78">    private static final double bigtens[] = { 1e16, 1e32, 1e64, 1e128, 1e256 };</span>

    private static int lo0bits(int y)
    {
        int k;
<span class="fc" id="L83">        int x = y;</span>

<span class="fc bfc" id="L85" title="All 2 branches covered.">        if ((x &amp; 7) != 0) {</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">            if ((x &amp; 1) != 0)</span>
<span class="fc" id="L87">                return 0;</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">            if ((x &amp; 2) != 0) {</span>
<span class="fc" id="L89">                return 1;</span>
            }
<span class="fc" id="L91">            return 2;</span>
        }
<span class="fc" id="L93">        k = 0;</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">        if ((x &amp; 0xffff) == 0) {</span>
<span class="fc" id="L95">            k = 16;</span>
<span class="fc" id="L96">            x &gt;&gt;&gt;= 16;</span>
        }
<span class="fc bfc" id="L98" title="All 2 branches covered.">        if ((x &amp; 0xff) == 0) {</span>
<span class="fc" id="L99">            k += 8;</span>
<span class="fc" id="L100">            x &gt;&gt;&gt;= 8;</span>
        }
<span class="fc bfc" id="L102" title="All 2 branches covered.">        if ((x &amp; 0xf) == 0) {</span>
<span class="fc" id="L103">            k += 4;</span>
<span class="fc" id="L104">            x &gt;&gt;&gt;= 4;</span>
        }
<span class="fc bfc" id="L106" title="All 2 branches covered.">        if ((x &amp; 0x3) == 0) {</span>
<span class="fc" id="L107">            k += 2;</span>
<span class="fc" id="L108">            x &gt;&gt;&gt;= 2;</span>
        }
<span class="fc bfc" id="L110" title="All 2 branches covered.">        if ((x &amp; 1) == 0) {</span>
<span class="fc" id="L111">            k++;</span>
<span class="fc" id="L112">            x &gt;&gt;&gt;= 1;</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">            if ((x &amp; 1) == 0)</span>
<span class="nc" id="L114">                return 32;</span>
        }
<span class="fc" id="L116">        return k;</span>
    }

    /* Return the number (0 through 32) of most significant zero bits in x. */
    private static int hi0bits(int x)
    {
<span class="fc" id="L122">        int k = 0;</span>

<span class="fc bfc" id="L124" title="All 2 branches covered.">        if ((x &amp; 0xffff0000) == 0) {</span>
<span class="fc" id="L125">            k = 16;</span>
<span class="fc" id="L126">            x &lt;&lt;= 16;</span>
        }
<span class="fc bfc" id="L128" title="All 2 branches covered.">        if ((x &amp; 0xff000000) == 0) {</span>
<span class="fc" id="L129">            k += 8;</span>
<span class="fc" id="L130">            x &lt;&lt;= 8;</span>
        }
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if ((x &amp; 0xf0000000) == 0) {</span>
<span class="fc" id="L133">            k += 4;</span>
<span class="fc" id="L134">            x &lt;&lt;= 4;</span>
        }
<span class="fc bfc" id="L136" title="All 2 branches covered.">        if ((x &amp; 0xc0000000) == 0) {</span>
<span class="fc" id="L137">            k += 2;</span>
<span class="fc" id="L138">            x &lt;&lt;= 2;</span>
        }
<span class="fc bfc" id="L140" title="All 2 branches covered.">        if ((x &amp; 0x80000000) == 0) {</span>
<span class="fc" id="L141">            k++;</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">            if ((x &amp; 0x40000000) == 0)</span>
<span class="fc" id="L143">                return 32;</span>
        }
<span class="fc" id="L145">        return k;</span>
    }

    private static void stuffBits(byte bits[], int offset, int val)
    {
<span class="fc" id="L150">        bits[offset] = (byte)(val &gt;&gt; 24);</span>
<span class="fc" id="L151">        bits[offset + 1] = (byte)(val &gt;&gt; 16);</span>
<span class="fc" id="L152">        bits[offset + 2] = (byte)(val &gt;&gt; 8);</span>
<span class="fc" id="L153">        bits[offset + 3] = (byte)(val);</span>
<span class="fc" id="L154">    }</span>

    /* Convert d into the form b*2^e, where b is an odd integer.  b is the returned
     * Bigint and e is the returned binary exponent.  Return the number of significant
     * bits in b in bits.  d must be finite and nonzero. */
    private static BigInteger d2b(double d, int[] e, int[] bits)
    {
        byte dbl_bits[];
        int i, k, y, z, de;
<span class="fc" id="L163">        long dBits = Double.doubleToLongBits(d);</span>
<span class="fc" id="L164">        int d0 = (int)(dBits &gt;&gt;&gt; 32);</span>
<span class="fc" id="L165">        int d1 = (int)(dBits);</span>

<span class="fc" id="L167">        z = d0 &amp; Frac_mask;</span>
<span class="fc" id="L168">        d0 &amp;= 0x7fffffff;   /* clear sign bit, which we ignore */</span>

<span class="fc bfc" id="L170" title="All 2 branches covered.">        if ((de = (d0 &gt;&gt;&gt; Exp_shift)) != 0)</span>
<span class="fc" id="L171">            z |= Exp_msk1;</span>

<span class="fc bfc" id="L173" title="All 2 branches covered.">        if ((y = d1) != 0) {</span>
<span class="fc" id="L174">            dbl_bits = new byte[8];</span>
<span class="fc" id="L175">            k = lo0bits(y);</span>
<span class="fc" id="L176">            y &gt;&gt;&gt;= k;</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">            if (k != 0) {</span>
<span class="fc" id="L178">                stuffBits(dbl_bits, 4, y | z &lt;&lt; (32 - k));</span>
<span class="fc" id="L179">                z &gt;&gt;= k;</span>
            }
            else
<span class="fc" id="L182">                stuffBits(dbl_bits, 4, y);</span>
<span class="fc" id="L183">            stuffBits(dbl_bits, 0, z);</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">            i = (z != 0) ? 2 : 1;</span>
        }
        else {
    //        JS_ASSERT(z);
<span class="fc" id="L188">            dbl_bits = new byte[4];</span>
<span class="fc" id="L189">            k = lo0bits(z);</span>
<span class="fc" id="L190">            z &gt;&gt;&gt;= k;</span>
<span class="fc" id="L191">            stuffBits(dbl_bits, 0, z);</span>
<span class="fc" id="L192">            k += 32;</span>
<span class="fc" id="L193">            i = 1;</span>
        }
<span class="fc bfc" id="L195" title="All 2 branches covered.">        if (de != 0) {</span>
<span class="fc" id="L196">            e[0] = de - Bias - (P-1) + k;</span>
<span class="fc" id="L197">            bits[0] = P - k;</span>
        }
        else {
<span class="fc" id="L200">            e[0] = de - Bias - (P-1) + 1 + k;</span>
<span class="fc" id="L201">            bits[0] = 32*i - hi0bits(z);</span>
        }
<span class="fc" id="L203">        return new BigInteger(dbl_bits);</span>
    }

    static String JS_dtobasestr(int base, double d)
    {
<span class="pc bpc" id="L208" title="1 of 4 branches missed.">        if (!(2 &lt;= base &amp;&amp; base &lt;= 36))</span>
<span class="fc" id="L209">            throw new IllegalArgumentException(&quot;Bad base: &quot;+base);</span>

        /* Check for Infinity and NaN */
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">        if (Double.isNaN(d)) {</span>
<span class="nc" id="L213">            return &quot;NaN&quot;;</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">        } else if (Double.isInfinite(d)) {</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">            return (d &gt; 0.0) ? &quot;Infinity&quot; : &quot;-Infinity&quot;;</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">        } else if (d == 0) {</span>
            // ALERT: should it distinguish -0.0 from +0.0 ?
<span class="fc" id="L218">            return &quot;0&quot;;</span>
        }

        boolean negative;
<span class="fc bfc" id="L222" title="All 2 branches covered.">        if (d &gt;= 0.0) {</span>
<span class="fc" id="L223">            negative = false;</span>
        } else {
<span class="fc" id="L225">            negative = true;</span>
<span class="fc" id="L226">            d = -d;</span>
        }

        /* Get the integer part of d including '-' sign. */
        String intDigits;

<span class="fc" id="L232">        double dfloor = Math.floor(d);</span>
<span class="fc" id="L233">        long lfloor = (long)dfloor;</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">        if (lfloor == dfloor) {</span>
            // int part fits long
<span class="fc bfc" id="L236" title="All 2 branches covered.">            intDigits = Long.toString((negative) ? -lfloor : lfloor, base);</span>
        } else {
            // BigInteger should be used
<span class="fc" id="L239">            long floorBits = Double.doubleToLongBits(dfloor);</span>
<span class="fc" id="L240">            int exp = (int)(floorBits &gt;&gt; Exp_shiftL) &amp; Exp_mask_shifted;</span>
            long mantissa;
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">            if (exp == 0) {</span>
<span class="nc" id="L243">                mantissa = (floorBits &amp; Frac_maskL) &lt;&lt; 1;</span>
            } else {
<span class="fc" id="L245">                mantissa = (floorBits &amp; Frac_maskL) | Exp_msk1L;</span>
            }
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">            if (negative) {</span>
<span class="nc" id="L248">                mantissa = -mantissa;</span>
            }
<span class="fc" id="L250">            exp -= 1075;</span>
<span class="fc" id="L251">            BigInteger x = BigInteger.valueOf(mantissa);</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">            if (exp &gt; 0) {</span>
<span class="fc" id="L253">                x = x.shiftLeft(exp);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">            } else if (exp &lt; 0) {</span>
<span class="nc" id="L255">                x = x.shiftRight(-exp);</span>
            }
<span class="fc" id="L257">            intDigits = x.toString(base);</span>
        }

<span class="fc bfc" id="L260" title="All 2 branches covered.">        if (d == dfloor) {</span>
            // No fraction part
<span class="fc" id="L262">            return intDigits;</span>
        } else {
            /* We have a fraction. */

            StringBuilder buffer;       /* The output string */
            int digit;
            double df;           /* The fractional part of d */
            BigInteger b;

<span class="fc" id="L271">            buffer = new StringBuilder();</span>
<span class="fc" id="L272">            buffer.append(intDigits).append('.');</span>
<span class="fc" id="L273">            df = d - dfloor;</span>

<span class="fc" id="L275">            long dBits = Double.doubleToLongBits(d);</span>
<span class="fc" id="L276">            int word0 = (int)(dBits &gt;&gt; 32);</span>
<span class="fc" id="L277">            int word1 = (int)(dBits);</span>

<span class="fc" id="L279">            int[] e = new int[1];</span>
<span class="fc" id="L280">            int[] bbits = new int[1];</span>

<span class="fc" id="L282">            b = d2b(df, e, bbits);</span>
//            JS_ASSERT(e &lt; 0);
            /* At this point df = b * 2^e.  e must be less than zero because 0 &lt; df &lt; 1. */

<span class="fc" id="L286">            int s2 = -(word0 &gt;&gt;&gt; Exp_shift1 &amp; Exp_mask &gt;&gt; Exp_shift1);</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">            if (s2 == 0)</span>
<span class="fc" id="L288">                s2 = -1;</span>
<span class="fc" id="L289">            s2 += Bias + P;</span>
            /* 1/2^s2 = (nextDouble(d) - d)/2 */
//            JS_ASSERT(-s2 &lt; e);
<span class="fc" id="L292">            BigInteger mlo = BigInteger.valueOf(1);</span>
<span class="fc" id="L293">            BigInteger mhi = mlo;</span>
<span class="pc bpc" id="L294" title="2 of 6 branches missed.">            if ((word1 == 0) &amp;&amp; ((word0 &amp; Bndry_mask) == 0)</span>
                &amp;&amp; ((word0 &amp; (Exp_mask &amp; Exp_mask &lt;&lt; 1)) != 0)) {
                /* The special case.  Here we want to be within a quarter of the last input
                   significant digit instead of one half of it when the output string's value is less than d.  */
<span class="fc" id="L298">                s2 += Log2P;</span>
<span class="fc" id="L299">                mhi = BigInteger.valueOf(1&lt;&lt;Log2P);</span>
            }

<span class="fc" id="L302">            b = b.shiftLeft(e[0] + s2);</span>
<span class="fc" id="L303">            BigInteger s = BigInteger.valueOf(1);</span>
<span class="fc" id="L304">            s = s.shiftLeft(s2);</span>
            /* At this point we have the following:
             *   s = 2^s2;
             *   1 &gt; df = b/2^s2 &gt; 0;
             *   (d - prevDouble(d))/2 = mlo/2^s2;
             *   (nextDouble(d) - d)/2 = mhi/2^s2. */
<span class="fc" id="L310">            BigInteger bigBase = BigInteger.valueOf(base);</span>

<span class="fc" id="L312">            boolean done = false;</span>
            do {
<span class="fc" id="L314">                b = b.multiply(bigBase);</span>
<span class="fc" id="L315">                BigInteger[] divResult = b.divideAndRemainder(s);</span>
<span class="fc" id="L316">                b = divResult[1];</span>
<span class="fc" id="L317">                digit = (char)(divResult[0].intValue());</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">                if (mlo == mhi)</span>
<span class="fc" id="L319">                    mlo = mhi = mlo.multiply(bigBase);</span>
                else {
<span class="fc" id="L321">                    mlo = mlo.multiply(bigBase);</span>
<span class="fc" id="L322">                    mhi = mhi.multiply(bigBase);</span>
                }

                /* Do we yet have the shortest string that will round to d? */
<span class="fc" id="L326">                int j = b.compareTo(mlo);</span>
                /* j is b/2^s2 compared with mlo/2^s2. */
<span class="fc" id="L328">                BigInteger delta = s.subtract(mhi);</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">                int j1 = (delta.signum() &lt;= 0) ? 1 : b.compareTo(delta);</span>
                /* j1 is b/2^s2 compared with 1 - mhi/2^s2. */
<span class="pc bpc" id="L331" title="3 of 4 branches missed.">                if (j1 == 0 &amp;&amp; ((word1 &amp; 1) == 0)) {</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">                    if (j &gt; 0)</span>
<span class="nc" id="L333">                        digit++;</span>
<span class="nc" id="L334">                    done = true;</span>
                } else
<span class="pc bpc" id="L336" title="3 of 6 branches missed.">                if (j &lt; 0 || (j == 0 &amp;&amp; ((word1 &amp; 1) == 0))) {</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">                    if (j1 &gt; 0) {</span>
                        /* Either dig or dig+1 would work here as the least significant digit.
                           Use whichever would produce an output value closer to d. */
<span class="fc" id="L340">                        b = b.shiftLeft(1);</span>
<span class="fc" id="L341">                        j1 = b.compareTo(s);</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">                        if (j1 &gt; 0) /* The even test (|| (j1 == 0 &amp;&amp; (digit &amp; 1))) is not here because it messes up odd base output</span>
                                     * such as 3.5 in base 3.  */
<span class="fc" id="L344">                            digit++;</span>
                    }
<span class="fc" id="L346">                    done = true;</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">                } else if (j1 &gt; 0) {</span>
<span class="fc" id="L348">                    digit++;</span>
<span class="fc" id="L349">                    done = true;</span>
                }
//                JS_ASSERT(digit &lt; (uint32)base);
<span class="fc" id="L352">                buffer.append(BASEDIGIT(digit));</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">            } while (!done);</span>

<span class="fc" id="L355">            return buffer.toString();</span>
        }

    }

    /* dtoa for IEEE arithmetic (dmg): convert double to ASCII string.
     *
     * Inspired by &quot;How to Print Floating-Point Numbers Accurately&quot; by
     * Guy L. Steele, Jr. and Jon L. White [Proc. ACM SIGPLAN '90, pp. 92-101].
     *
     * Modifications:
     *  1. Rather than iterating, we use a simple numeric overestimate
     *     to determine k = floor(log10(d)).  We scale relevant
     *     quantities using O(log2(k)) rather than O(k) multiplications.
     *  2. For some modes &gt; 2 (corresponding to ecvt and fcvt), we don't
     *     try to generate digits strictly left to right.  Instead, we
     *     compute with fewer bits and propagate the carry if necessary
     *     when rounding the final digit up.  This is often faster.
     *  3. Under the assumption that input will be rounded nearest,
     *     mode 0 renders 1e23 as 1e23 rather than 9.999999999999999e22.
     *     That is, we allow equality in stopping tests when the
     *     round-nearest rule will give the same floating-point value
     *     as would satisfaction of the stopping test with strict
     *     inequality.
     *  4. We remove common factors of powers of 2 from relevant
     *     quantities.
     *  5. When converting floating-point integers less than 1e16,
     *     we use floating-point arithmetic rather than resorting
     *     to multiple-precision integers.
     *  6. When asked to produce fewer than 15 digits, we first try
     *     to get by with floating-point arithmetic; we resort to
     *     multiple-precision integer arithmetic only if we cannot
     *     guarantee that the floating-point calculation has given
     *     the correctly rounded result.  For k requested digits and
     *     &quot;uniformly&quot; distributed input, the probability is
     *     something like 10^(k-15) that we must resort to the Long
     *     calculation.
     */

    static int word0(double d)
    {
<span class="fc" id="L396">        long dBits = Double.doubleToLongBits(d);</span>
<span class="fc" id="L397">        return (int)(dBits &gt;&gt; 32);</span>
    }

    static double setWord0(double d, int i)
    {
<span class="fc" id="L402">        long dBits = Double.doubleToLongBits(d);</span>
<span class="fc" id="L403">        dBits = ((long)i &lt;&lt; 32) | (dBits &amp; 0x0FFFFFFFFL);</span>
<span class="fc" id="L404">        return Double.longBitsToDouble(dBits);</span>
    }

    static int word1(double d)
    {
<span class="fc" id="L409">        long dBits = Double.doubleToLongBits(d);</span>
<span class="fc" id="L410">        return (int)(dBits);</span>
    }

    /* Return b * 5^k.  k must be nonnegative. */
    // XXXX the C version built a cache of these
    static BigInteger pow5mult(BigInteger b, int k)
    {
<span class="fc" id="L417">        return b.multiply(BigInteger.valueOf(5).pow(k));</span>
    }

    static boolean roundOff(StringBuilder buf)
    {
<span class="fc" id="L422">        int i = buf.length();</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">        while (i != 0) {</span>
<span class="fc" id="L424">            --i;</span>
<span class="fc" id="L425">            char c = buf.charAt(i);</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">            if (c != '9') {</span>
<span class="fc" id="L427">                buf.setCharAt(i, (char)(c + 1));</span>
<span class="fc" id="L428">                buf.setLength(i + 1);</span>
<span class="fc" id="L429">                return false;</span>
            }
<span class="fc" id="L431">        }</span>
<span class="fc" id="L432">        buf.setLength(0);</span>
<span class="fc" id="L433">        return true;</span>
    }

    /* Always emits at least one digit. */
    /* If biasUp is set, then rounding in modes 2 and 3 will round away from zero
     * when the number is exactly halfway between two representable values.  For example,
     * rounding 2.5 to zero digits after the decimal point will return 3 and not 2.
     * 2.49 will still round to 2, and 2.51 will still round to 3. */
    /* bufsize should be at least 20 for modes 0 and 1.  For the other modes,
     * bufsize should be two greater than the maximum number of output characters expected. */
    static int
    JS_dtoa(double d, int mode, boolean biasUp, int ndigits,
                    boolean[] sign, StringBuilder buf)
    {
        /*  Arguments ndigits, decpt, sign are similar to those
            of ecvt and fcvt; trailing zeros are suppressed from
            the returned string.  If not null, *rve is set to point
            to the end of the return value.  If d is +-Infinity or NaN,
            then *decpt is set to 9999.

            mode:
            0 ==&gt; shortest string that yields d when read in
            and rounded to nearest.
            1 ==&gt; like 0, but with Steele &amp; White stopping rule;
            e.g. with IEEE P754 arithmetic , mode 0 gives
            1e23 whereas mode 1 gives 9.999999999999999e22.
            2 ==&gt; max(1,ndigits) significant digits.  This gives a
            return value similar to that of ecvt, except
            that trailing zeros are suppressed.
            3 ==&gt; through ndigits past the decimal point.  This
            gives a return value similar to that from fcvt,
            except that trailing zeros are suppressed, and
            ndigits can be negative.
            4-9 should give the same return values as 2-3, i.e.,
            4 &lt;= mode &lt;= 9 ==&gt; same return as mode
            2 + (mode &amp; 1).  These modes are mainly for
            debugging; often they run slower but sometimes
            faster than modes 2-3.
            4,5,8,9 ==&gt; left-to-right digit generation.
            6-9 ==&gt; don't try fast floating-point estimate
            (if applicable).

            Values of mode other than 0-9 are treated as mode 0.

            Sufficient space is allocated to the return value
            to hold the suppressed trailing zeros.
        */

        int b2, b5, i, ieps, ilim, ilim0, ilim1,
            j, j1, k, k0, m2, m5, s2, s5;
        char dig;
        long L;
        long x;
        BigInteger b, b1, delta, mlo, mhi, S;
<span class="fc" id="L487">        int[] be = new int[1];</span>
<span class="fc" id="L488">        int[] bbits = new int[1];</span>
        double d2, ds, eps;
        boolean spec_case, denorm, k_check, try_quick, leftright;

<span class="fc bfc" id="L492" title="All 2 branches covered.">        if ((word0(d) &amp; Sign_bit) != 0) {</span>
            /* set sign for everything, including 0's and NaNs */
<span class="fc" id="L494">            sign[0] = true;</span>
            // word0(d) &amp;= ~Sign_bit;  /* clear sign bit */
<span class="fc" id="L496">            d = setWord0(d, word0(d) &amp; ~Sign_bit);</span>
        }
        else
<span class="fc" id="L499">            sign[0] = false;</span>

<span class="pc bpc" id="L501" title="1 of 2 branches missed.">        if ((word0(d) &amp; Exp_mask) == Exp_mask) {</span>
            /* Infinity or NaN */
<span class="nc bnc" id="L503" title="All 4 branches missed.">            buf.append(((word1(d) == 0) &amp;&amp; ((word0(d) &amp; Frac_mask) == 0)) ? &quot;Infinity&quot; : &quot;NaN&quot;);</span>
<span class="nc" id="L504">            return 9999;</span>
        }
<span class="fc bfc" id="L506" title="All 2 branches covered.">        if (d == 0) {</span>
//          no_digits:
<span class="fc" id="L508">            buf.setLength(0);</span>
<span class="fc" id="L509">            buf.append('0');        /* copy &quot;0&quot; to buffer */</span>
<span class="fc" id="L510">            return 1;</span>
        }

<span class="fc" id="L513">        b = d2b(d, be, bbits);</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">        if ((i = (word0(d) &gt;&gt;&gt; Exp_shift1 &amp; (Exp_mask&gt;&gt;Exp_shift1))) != 0) {</span>
<span class="fc" id="L515">            d2 = setWord0(d, (word0(d) &amp; Frac_mask1) | Exp_11);</span>
            /* log(x)   ~=~ log(1.5) + (x-1.5)/1.5
             * log10(x)  =  log(x) / log(10)
             *      ~=~ log(1.5)/log(10) + (x-1.5)/(1.5*log(10))
             * log10(d) = (i-Bias)*log(2)/log(10) + log10(d2)
             *
             * This suggests computing an approximation k to log10(d) by
             *
             * k = (i - Bias)*0.301029995663981
             *  + ( (d2-1.5)*0.289529654602168 + 0.176091259055681 );
             *
             * We want k to be too large rather than too small.
             * The error in the first-order Taylor series approximation
             * is in our favor, so we just round up the constant enough
             * to compensate for any error in the multiplication of
             * (i - Bias) by 0.301029995663981; since |i - Bias| &lt;= 1077,
             * and 1077 * 0.30103 * 2^-52 ~=~ 7.2e-14,
             * adding 1e-13 to the constant term more than suffices.
             * Hence we adjust the constant term to 0.1760912590558.
             * (We could get a more accurate k by invoking log10,
             *  but this is probably not worthwhile.)
             */
<span class="fc" id="L537">            i -= Bias;</span>
<span class="fc" id="L538">            denorm = false;</span>
        }
        else {
            /* d is denormalized */
<span class="fc" id="L542">            i = bbits[0] + be[0] + (Bias + (P-1) - 1);</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">            x = (i &gt; 32)</span>
<span class="fc" id="L544">                    ? ((long) word0(d)) &lt;&lt; (64 - i) | word1(d) &gt;&gt;&gt; (i - 32)</span>
<span class="fc" id="L545">                    : ((long) word1(d)) &lt;&lt; (32 - i);</span>
//            d2 = x;
//            word0(d2) -= 31*Exp_msk1; /* adjust exponent */
<span class="fc" id="L548">            d2 = setWord0(x, word0(x) - 31*Exp_msk1);</span>
<span class="fc" id="L549">            i -= (Bias + (P-1) - 1) + 1;</span>
<span class="fc" id="L550">            denorm = true;</span>
        }
        /* At this point d = f*2^i, where 1 &lt;= f &lt; 2.  d2 is an approximation of f. */
<span class="fc" id="L553">        ds = (d2-1.5)*0.289529654602168 + 0.1760912590558 + i*0.301029995663981;</span>
<span class="fc" id="L554">        k = (int)ds;</span>
<span class="pc bpc" id="L555" title="1 of 4 branches missed.">        if (ds &lt; 0.0 &amp;&amp; ds != k)</span>
<span class="fc" id="L556">            k--;    /* want k = floor(ds) */</span>
<span class="fc" id="L557">        k_check = true;</span>
<span class="pc bpc" id="L558" title="1 of 4 branches missed.">        if (k &gt;= 0 &amp;&amp; k &lt;= Ten_pmax) {</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">            if (d &lt; tens[k])</span>
<span class="fc" id="L560">                k--;</span>
<span class="fc" id="L561">            k_check = false;</span>
        }
        /* At this point floor(log10(d)) &lt;= k &lt;= floor(log10(d))+1.
           If k_check is zero, we're guaranteed that k = floor(log10(d)). */
<span class="fc" id="L565">        j = bbits[0] - i - 1;</span>
        /* At this point d = b/2^j, where b is an odd integer. */
<span class="fc bfc" id="L567" title="All 2 branches covered.">        if (j &gt;= 0) {</span>
<span class="fc" id="L568">            b2 = 0;</span>
<span class="fc" id="L569">            s2 = j;</span>
        }
        else {
<span class="fc" id="L572">            b2 = -j;</span>
<span class="fc" id="L573">            s2 = 0;</span>
        }
<span class="fc bfc" id="L575" title="All 2 branches covered.">        if (k &gt;= 0) {</span>
<span class="fc" id="L576">            b5 = 0;</span>
<span class="fc" id="L577">            s5 = k;</span>
<span class="fc" id="L578">            s2 += k;</span>
        }
        else {
<span class="fc" id="L581">            b2 -= k;</span>
<span class="fc" id="L582">            b5 = -k;</span>
<span class="fc" id="L583">            s5 = 0;</span>
        }
        /* At this point d/10^k = (b * 2^b2 * 5^b5) / (2^s2 * 5^s5), where b is an odd integer,
           b2 &gt;= 0, b5 &gt;= 0, s2 &gt;= 0, and s5 &gt;= 0. */
<span class="fc bfc" id="L587" title="All 4 branches covered.">        if (mode &lt; 0 || mode &gt; 9)</span>
<span class="fc" id="L588">            mode = 0;</span>
<span class="fc" id="L589">        try_quick = true;</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">        if (mode &gt; 5) {</span>
<span class="fc" id="L591">            mode -= 4;</span>
<span class="fc" id="L592">            try_quick = false;</span>
        }
<span class="fc" id="L594">        leftright = true;</span>
<span class="fc" id="L595">        ilim = ilim1 = 0;</span>
<span class="pc bpc" id="L596" title="1 of 6 branches missed.">        switch(mode) {</span>
            case 0:
            case 1:
<span class="fc" id="L599">                ilim = ilim1 = -1;</span>
<span class="fc" id="L600">                i = 18;</span>
<span class="fc" id="L601">                ndigits = 0;</span>
<span class="fc" id="L602">                break;</span>
            case 2:
<span class="fc" id="L604">                leftright = false;</span>
                /* fallthru */
            case 4:
<span class="fc bfc" id="L607" title="All 2 branches covered.">                if (ndigits &lt;= 0)</span>
<span class="fc" id="L608">                    ndigits = 1;</span>
<span class="fc" id="L609">                ilim = ilim1 = i = ndigits;</span>
<span class="fc" id="L610">                break;</span>
            case 3:
<span class="fc" id="L612">                leftright = false;</span>
                /* fallthru */
            case 5:
<span class="fc" id="L615">                i = ndigits + k + 1;</span>
<span class="fc" id="L616">                ilim = i;</span>
<span class="fc" id="L617">                ilim1 = i - 1;</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">                if (i &lt;= 0)</span>
<span class="fc" id="L619">                    i = 1;</span>
        }
        /* ilim is the maximum number of significant digits we want, based on k and ndigits. */
        /* ilim1 is the maximum number of significant digits we want, based on k and ndigits,
           when it turns out that k was computed too high by one. */

<span class="fc" id="L625">        boolean fast_failed = false;</span>
<span class="fc bfc" id="L626" title="All 6 branches covered.">        if (ilim &gt;= 0 &amp;&amp; ilim &lt;= Quick_max &amp;&amp; try_quick) {</span>

            /* Try to get by with floating-point arithmetic. */

<span class="fc" id="L630">            i = 0;</span>
<span class="fc" id="L631">            d2 = d;</span>
<span class="fc" id="L632">            k0 = k;</span>
<span class="fc" id="L633">            ilim0 = ilim;</span>
<span class="fc" id="L634">            ieps = 2; /* conservative */</span>
            /* Divide d by 10^k, keeping track of the roundoff error and avoiding overflows. */
<span class="fc bfc" id="L636" title="All 2 branches covered.">            if (k &gt; 0) {</span>
<span class="fc" id="L637">                ds = tens[k&amp;0xf];</span>
<span class="fc" id="L638">                j = k &gt;&gt; 4;</span>
<span class="pc bpc" id="L639" title="1 of 2 branches missed.">                if ((j &amp; Bletch) != 0) {</span>
                    /* prevent overflows */
<span class="nc" id="L641">                    j &amp;= Bletch - 1;</span>
<span class="nc" id="L642">                    d /= bigtens[n_bigtens-1];</span>
<span class="nc" id="L643">                    ieps++;</span>
                }
<span class="fc bfc" id="L645" title="All 2 branches covered.">                for(; (j != 0); j &gt;&gt;= 1, i++)</span>
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">                    if ((j &amp; 1) != 0) {</span>
<span class="fc" id="L647">                        ieps++;</span>
<span class="fc" id="L648">                        ds *= bigtens[i];</span>
                    }
<span class="fc" id="L650">                d /= ds;</span>
            }
<span class="fc bfc" id="L652" title="All 2 branches covered.">            else if ((j1 = -k) != 0) {</span>
<span class="fc" id="L653">                d *= tens[j1 &amp; 0xf];</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">                for(j = j1 &gt;&gt; 4; (j != 0); j &gt;&gt;= 1, i++)</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">                    if ((j &amp; 1) != 0) {</span>
<span class="fc" id="L656">                        ieps++;</span>
<span class="fc" id="L657">                        d *= bigtens[i];</span>
                    }
            }
            /* Check that k was computed correctly. */
<span class="pc bpc" id="L661" title="3 of 6 branches missed.">            if (k_check &amp;&amp; d &lt; 1.0 &amp;&amp; ilim &gt; 0) {</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">                if (ilim1 &lt;= 0)</span>
<span class="nc" id="L663">                    fast_failed = true;</span>
                else {
<span class="nc" id="L665">                    ilim = ilim1;</span>
<span class="nc" id="L666">                    k--;</span>
<span class="nc" id="L667">                    d *= 10.;</span>
<span class="nc" id="L668">                    ieps++;</span>
                }
            }
            /* eps bounds the cumulative error. */
//            eps = ieps*d + 7.0;
//            word0(eps) -= (P-1)*Exp_msk1;
<span class="fc" id="L674">            eps = ieps*d + 7.0;</span>
<span class="fc" id="L675">            eps = setWord0(eps, word0(eps) - (P-1)*Exp_msk1);</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">            if (ilim == 0) {</span>
<span class="fc" id="L677">                S = mhi = null;</span>
<span class="fc" id="L678">                d -= 5.0;</span>
<span class="pc bpc" id="L679" title="1 of 2 branches missed.">                if (d &gt; eps) {</span>
<span class="nc" id="L680">                    buf.append('1');</span>
<span class="nc" id="L681">                    k++;</span>
<span class="nc" id="L682">                    return k + 1;</span>
                }
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">                if (d &lt; -eps) {</span>
<span class="fc" id="L685">                    buf.setLength(0);</span>
<span class="fc" id="L686">                    buf.append('0');        /* copy &quot;0&quot; to buffer */</span>
<span class="fc" id="L687">                    return 1;</span>
                }
<span class="nc" id="L689">                fast_failed = true;</span>
            }
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">            if (!fast_failed) {</span>
<span class="fc" id="L692">                fast_failed = true;</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">                if (leftright) {</span>
                    /* Use Steele &amp; White method of only
                     * generating digits needed.
                     */
<span class="fc" id="L697">                    eps = 0.5/tens[ilim-1] - eps;</span>
<span class="fc" id="L698">                    for(i = 0;;) {</span>
<span class="fc" id="L699">                        L = (long)d;</span>
<span class="fc" id="L700">                        d -= L;</span>
<span class="fc" id="L701">                        buf.append((char)('0' + L));</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">                        if (d &lt; eps) {</span>
<span class="fc" id="L703">                            return k + 1;</span>
                        }
<span class="fc bfc" id="L705" title="All 2 branches covered.">                        if (1.0 - d &lt; eps) {</span>
//                            goto bump_up;
                                char lastCh;
                                while (true) {
<span class="fc" id="L709">                                    lastCh = buf.charAt(buf.length() - 1);</span>
<span class="fc" id="L710">                                    buf.setLength(buf.length() - 1);</span>
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">                                    if (lastCh != '9') break;</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">                                    if (buf.length() == 0) {</span>
<span class="nc" id="L713">                                        k++;</span>
<span class="nc" id="L714">                                        lastCh = '0';</span>
<span class="nc" id="L715">                                        break;</span>
                                    }
                                }
<span class="fc" id="L718">                                buf.append((char)(lastCh + 1));</span>
<span class="fc" id="L719">                                return k + 1;</span>
                        }
<span class="pc bpc" id="L721" title="1 of 2 branches missed.">                        if (++i &gt;= ilim)</span>
<span class="nc" id="L722">                            break;</span>
<span class="fc" id="L723">                        eps *= 10.0;</span>
<span class="fc" id="L724">                        d *= 10.0;</span>
                    }
                }
                else {
                    /* Generate ilim digits, then fix them up. */
<span class="fc" id="L729">                    eps *= tens[ilim-1];</span>
<span class="fc" id="L730">                    for(i = 1;; i++, d *= 10.0) {</span>
<span class="fc" id="L731">                        L = (long)d;</span>
<span class="fc" id="L732">                        d -= L;</span>
<span class="fc" id="L733">                        buf.append((char)('0' + L));</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">                        if (i == ilim) {</span>
<span class="fc bfc" id="L735" title="All 2 branches covered.">                            if (d &gt; 0.5 + eps) {</span>
//                                goto bump_up;
                                char lastCh;
                                while (true) {
<span class="fc" id="L739">                                    lastCh = buf.charAt(buf.length() - 1);</span>
<span class="fc" id="L740">                                    buf.setLength(buf.length() - 1);</span>
<span class="fc bfc" id="L741" title="All 2 branches covered.">                                    if (lastCh != '9') break;</span>
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">                                    if (buf.length() == 0) {</span>
<span class="nc" id="L743">                                        k++;</span>
<span class="nc" id="L744">                                        lastCh = '0';</span>
<span class="nc" id="L745">                                        break;</span>
                                    }
                                }
<span class="fc" id="L748">                                buf.append((char)(lastCh + 1));</span>
<span class="fc" id="L749">                                return k + 1;</span>
                            }
                            else
<span class="fc bfc" id="L752" title="All 2 branches covered.">                                if (d &lt; 0.5 - eps) {</span>
<span class="fc" id="L753">                                    stripTrailingZeroes(buf);</span>
//                                    while(*--s == '0') ;
//                                    s++;
<span class="fc" id="L756">                                    return k + 1;</span>
                                }
                            break;
                        }
                    }
                }
            }
<span class="pc bpc" id="L763" title="1 of 2 branches missed.">            if (fast_failed) {</span>
<span class="fc" id="L764">                buf.setLength(0);</span>
<span class="fc" id="L765">                d = d2;</span>
<span class="fc" id="L766">                k = k0;</span>
<span class="fc" id="L767">                ilim = ilim0;</span>
            }
        }

        /* Do we have a &quot;small&quot; integer? */

<span class="fc bfc" id="L773" title="All 4 branches covered.">        if (be[0] &gt;= 0 &amp;&amp; k &lt;= Int_max) {</span>
            /* Yes. */
<span class="fc" id="L775">            ds = tens[k];</span>
<span class="pc bpc" id="L776" title="1 of 4 branches missed.">            if (ndigits &lt; 0 &amp;&amp; ilim &lt;= 0) {</span>
<span class="fc" id="L777">                S = mhi = null;</span>
<span class="pc bpc" id="L778" title="7 of 8 branches missed.">                if (ilim &lt; 0 || d &lt; 5*ds || (!biasUp &amp;&amp; d == 5*ds)) {</span>
<span class="fc" id="L779">                    buf.setLength(0);</span>
<span class="fc" id="L780">                    buf.append('0');        /* copy &quot;0&quot; to buffer */</span>
<span class="fc" id="L781">                    return 1;</span>
                }
<span class="nc" id="L783">                buf.append('1');</span>
<span class="nc" id="L784">                k++;</span>
<span class="nc" id="L785">                return k + 1;</span>
            }
<span class="fc" id="L787">            for(i = 1;; i++) {</span>
<span class="fc" id="L788">                L = (long) (d / ds);</span>
<span class="fc" id="L789">                d -= L*ds;</span>
<span class="fc" id="L790">                buf.append((char)('0' + L));</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">                if (i == ilim) {</span>
<span class="fc" id="L792">                    d += d;</span>
<span class="pc bpc" id="L793" title="5 of 8 branches missed.">                    if ((d &gt; ds) || (d == ds &amp;&amp; (((L &amp; 1) != 0) || biasUp))) {</span>
//                    bump_up:
//                        while(*--s == '9')
//                            if (s == buf) {
//                                k++;
//                                *s = '0';
//                                break;
//                            }
//                        ++*s++;
                        char lastCh;
                        while (true) {
<span class="fc" id="L804">                            lastCh = buf.charAt(buf.length() - 1);</span>
<span class="fc" id="L805">                            buf.setLength(buf.length() - 1);</span>
<span class="pc bpc" id="L806" title="1 of 2 branches missed.">                            if (lastCh != '9') break;</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">                            if (buf.length() == 0) {</span>
<span class="nc" id="L808">                                k++;</span>
<span class="nc" id="L809">                                lastCh = '0';</span>
<span class="nc" id="L810">                                break;</span>
                            }
                        }
<span class="fc" id="L813">                        buf.append((char)(lastCh + 1));</span>
<span class="fc" id="L814">                    }</span>
                    break;
                }
<span class="fc" id="L817">                d *= 10.0;</span>
<span class="fc bfc" id="L818" title="All 2 branches covered.">                if (d == 0)</span>
<span class="fc" id="L819">                    break;</span>
            }
<span class="fc" id="L821">            return k + 1;</span>
        }

<span class="fc" id="L824">        m2 = b2;</span>
<span class="fc" id="L825">        m5 = b5;</span>
<span class="fc" id="L826">        mhi = mlo = null;</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">        if (leftright) {</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">            if (mode &lt; 2) {</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">                i = (denorm) ? be[0] + (Bias + (P-1) - 1 + 1) : 1 + P - bbits[0];</span>
                /* i is 1 plus the number of trailing zero bits in d's significand. Thus,
                   (2^m2 * 5^m5) / (2^(s2+i) * 5^s5) = (1/2 lsb of d)/10^k. */
            }
            else {
<span class="fc" id="L834">                j = ilim - 1;</span>
<span class="fc bfc" id="L835" title="All 2 branches covered.">                if (m5 &gt;= j)</span>
<span class="fc" id="L836">                    m5 -= j;</span>
                else {
<span class="fc" id="L838">                    s5 += j -= m5;</span>
<span class="fc" id="L839">                    b5 += j;</span>
<span class="fc" id="L840">                    m5 = 0;</span>
                }
<span class="fc bfc" id="L842" title="All 2 branches covered.">                if ((i = ilim) &lt; 0) {</span>
<span class="fc" id="L843">                    m2 -= i;</span>
<span class="fc" id="L844">                    i = 0;</span>
                }
                /* (2^m2 * 5^m5) / (2^(s2+i) * 5^s5) = (1/2 * 10^(1-ilim))/10^k. */
            }
<span class="fc" id="L848">            b2 += i;</span>
<span class="fc" id="L849">            s2 += i;</span>
<span class="fc" id="L850">            mhi = BigInteger.valueOf(1);</span>
            /* (mhi * 2^m2 * 5^m5) / (2^s2 * 5^s5) = one-half of last printed (when mode &gt;= 2) or
               input (when mode &lt; 2) significant digit, divided by 10^k. */
        }
        /* We still have d/10^k = (b * 2^b2 * 5^b5) / (2^s2 * 5^s5).  Reduce common factors in
           b2, m2, and s2 without changing the equalities. */
<span class="pc bpc" id="L856" title="1 of 4 branches missed.">        if (m2 &gt; 0 &amp;&amp; s2 &gt; 0) {</span>
<span class="pc bpc" id="L857" title="1 of 2 branches missed.">            i = (m2 &lt; s2) ? m2 : s2;</span>
<span class="fc" id="L858">            b2 -= i;</span>
<span class="fc" id="L859">            m2 -= i;</span>
<span class="fc" id="L860">            s2 -= i;</span>
        }

        /* Fold b5 into b and m5 into mhi. */
<span class="fc bfc" id="L864" title="All 2 branches covered.">        if (b5 &gt; 0) {</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">            if (leftright) {</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">                if (m5 &gt; 0) {</span>
<span class="fc" id="L867">                    mhi = pow5mult(mhi, m5);</span>
<span class="fc" id="L868">                    b1 = mhi.multiply(b);</span>
<span class="fc" id="L869">                    b = b1;</span>
                }
<span class="fc bfc" id="L871" title="All 2 branches covered.">                if ((j = b5 - m5) != 0)</span>
<span class="fc" id="L872">                    b = pow5mult(b, j);</span>
            }
            else
<span class="fc" id="L875">                b = pow5mult(b, b5);</span>
        }
        /* Now we have d/10^k = (b * 2^b2) / (2^s2 * 5^s5) and
           (mhi * 2^m2) / (2^s2 * 5^s5) = one-half of last printed or input significant digit, divided by 10^k. */

<span class="fc" id="L880">        S = BigInteger.valueOf(1);</span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">        if (s5 &gt; 0)</span>
<span class="fc" id="L882">            S = pow5mult(S, s5);</span>
        /* Now we have d/10^k = (b * 2^b2) / (S * 2^s2) and
           (mhi * 2^m2) / (S * 2^s2) = one-half of last printed or input significant digit, divided by 10^k. */

        /* Check for special case that d is a normalized power of 2. */
<span class="fc" id="L887">        spec_case = false;</span>
<span class="fc bfc" id="L888" title="All 2 branches covered.">        if (mode &lt; 2) {</span>
<span class="pc bpc" id="L889" title="1 of 4 branches missed.">            if ( (word1(d) == 0) &amp;&amp; ((word0(d) &amp; Bndry_mask) == 0)</span>
<span class="pc bpc" id="L890" title="1 of 2 branches missed.">                &amp;&amp; ((word0(d) &amp; (Exp_mask &amp; Exp_mask &lt;&lt; 1)) != 0)</span>
                ) {
                /* The special case.  Here we want to be within a quarter of the last input
                   significant digit instead of one half of it when the decimal output string's value is less than d.  */
<span class="fc" id="L894">                b2 += Log2P;</span>
<span class="fc" id="L895">                s2 += Log2P;</span>
<span class="fc" id="L896">                spec_case = true;</span>
            }
        }

        /* Arrange for convenient computation of quotients:
         * shift left if necessary so divisor has 4 leading 0 bits.
         *
         * Perhaps we should just compute leading 28 bits of S once
         * and for all and pass them and a shift to quorem, so it
         * can do shifts and ors to compute the numerator for q.
         */
<span class="fc" id="L907">        byte [] S_bytes = S.toByteArray();</span>
<span class="fc" id="L908">        int S_hiWord = 0;</span>
<span class="fc bfc" id="L909" title="All 2 branches covered.">        for (int idx = 0; idx &lt; 4; idx++) {</span>
<span class="fc" id="L910">            S_hiWord = (S_hiWord &lt;&lt; 8);</span>
<span class="fc bfc" id="L911" title="All 2 branches covered.">            if (idx &lt; S_bytes.length)</span>
<span class="fc" id="L912">                S_hiWord |= (S_bytes[idx] &amp; 0xFF);</span>
        }
<span class="pc bpc" id="L914" title="1 of 4 branches missed.">        if ((i = (((s5 != 0) ? 32 - hi0bits(S_hiWord) : 1) + s2) &amp; 0x1f) != 0)</span>
<span class="fc" id="L915">            i = 32 - i;</span>
        /* i is the number of leading zero bits in the most significant word of S*2^s2. */
<span class="fc bfc" id="L917" title="All 2 branches covered.">        if (i &gt; 4) {</span>
<span class="fc" id="L918">            i -= 4;</span>
<span class="fc" id="L919">            b2 += i;</span>
<span class="fc" id="L920">            m2 += i;</span>
<span class="fc" id="L921">            s2 += i;</span>
        }
<span class="pc bpc" id="L923" title="1 of 2 branches missed.">        else if (i &lt; 4) {</span>
<span class="fc" id="L924">            i += 28;</span>
<span class="fc" id="L925">            b2 += i;</span>
<span class="fc" id="L926">            m2 += i;</span>
<span class="fc" id="L927">            s2 += i;</span>
        }
        /* Now S*2^s2 has exactly four leading zero bits in its most significant word. */
<span class="pc bpc" id="L930" title="1 of 2 branches missed.">        if (b2 &gt; 0)</span>
<span class="fc" id="L931">            b = b.shiftLeft(b2);</span>
<span class="pc bpc" id="L932" title="1 of 2 branches missed.">        if (s2 &gt; 0)</span>
<span class="fc" id="L933">            S = S.shiftLeft(s2);</span>
        /* Now we have d/10^k = b/S and
           (mhi * 2^m2) / S = maximum acceptable error, divided by 10^k. */
<span class="fc bfc" id="L936" title="All 2 branches covered.">        if (k_check) {</span>
<span class="pc bpc" id="L937" title="1 of 2 branches missed.">            if (b.compareTo(S) &lt; 0) {</span>
<span class="nc" id="L938">                k--;</span>
<span class="nc" id="L939">                b = b.multiply(BigInteger.valueOf(10));  /* we botched the k estimate */</span>
<span class="nc bnc" id="L940" title="All 2 branches missed.">                if (leftright)</span>
<span class="nc" id="L941">                    mhi = mhi.multiply(BigInteger.valueOf(10));</span>
<span class="nc" id="L942">                ilim = ilim1;</span>
            }
        }
        /* At this point 1 &lt;= d/10^k = b/S &lt; 10. */

<span class="fc bfc" id="L947" title="All 4 branches covered.">        if (ilim &lt;= 0 &amp;&amp; mode &gt; 2) {</span>
            /* We're doing fixed-mode output and d is less than the minimum nonzero output in this mode.
               Output either zero or the minimum nonzero output depending on which is closer to d. */
<span class="pc bpc" id="L950" title="1 of 2 branches missed.">            if ((ilim &lt; 0 )</span>
<span class="nc bnc" id="L951" title="All 6 branches missed.">                    || ((i = b.compareTo(S = S.multiply(BigInteger.valueOf(5)))) &lt; 0)</span>
                    || ((i == 0 &amp;&amp; !biasUp))) {
            /* Always emit at least one digit.  If the number appears to be zero
               using the current mode, then emit one '0' digit and set decpt to 1. */
            /*no_digits:
                k = -1 - ndigits;
                goto ret; */
<span class="fc" id="L958">                buf.setLength(0);</span>
<span class="fc" id="L959">                buf.append('0');        /* copy &quot;0&quot; to buffer */</span>
<span class="fc" id="L960">                return 1;</span>
//                goto no_digits;
            }
//        one_digit:
<span class="nc" id="L964">            buf.append('1');</span>
<span class="nc" id="L965">            k++;</span>
<span class="nc" id="L966">            return k + 1;</span>
        }
<span class="fc bfc" id="L968" title="All 2 branches covered.">        if (leftright) {</span>
<span class="pc bpc" id="L969" title="1 of 2 branches missed.">            if (m2 &gt; 0)</span>
<span class="fc" id="L970">                mhi = mhi.shiftLeft(m2);</span>

            /* Compute mlo -- check for special case
             * that d is a normalized power of 2.
             */

<span class="fc" id="L976">            mlo = mhi;</span>
<span class="fc bfc" id="L977" title="All 2 branches covered.">            if (spec_case) {</span>
<span class="fc" id="L978">                mhi = mlo;</span>
<span class="fc" id="L979">                mhi = mhi.shiftLeft(Log2P);</span>
            }
            /* mlo/S = maximum acceptable error, divided by 10^k, if the output is less than d. */
            /* mhi/S = maximum acceptable error, divided by 10^k, if the output is greater than d. */

<span class="fc" id="L984">            for(i = 1;;i++) {</span>
<span class="fc" id="L985">                BigInteger[] divResult = b.divideAndRemainder(S);</span>
<span class="fc" id="L986">                b = divResult[1];</span>
<span class="fc" id="L987">                dig = (char)(divResult[0].intValue() + '0');</span>
                /* Do we yet have the shortest decimal string
                 * that will round to d?
                 */
<span class="fc" id="L991">                j = b.compareTo(mlo);</span>
                /* j is b/S compared with mlo/S. */
<span class="fc" id="L993">                delta = S.subtract(mhi);</span>
<span class="fc bfc" id="L994" title="All 2 branches covered.">                j1 = (delta.signum() &lt;= 0) ? 1 : b.compareTo(delta);</span>
                /* j1 is b/S compared with 1 - mhi/S. */
<span class="pc bpc" id="L996" title="5 of 6 branches missed.">                if ((j1 == 0) &amp;&amp; (mode == 0) &amp;&amp; ((word1(d) &amp; 1) == 0)) {</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">                    if (dig == '9') {</span>
<span class="nc" id="L998">                        buf.append('9');</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">                        if (roundOff(buf)) {</span>
<span class="nc" id="L1000">                            k++;</span>
<span class="nc" id="L1001">                            buf.append('1');</span>
                        }
<span class="nc" id="L1003">                        return k + 1;</span>
//                        goto round_9_up;
                    }
<span class="nc bnc" id="L1006" title="All 2 branches missed.">                    if (j &gt; 0)</span>
<span class="nc" id="L1007">                        dig++;</span>
<span class="nc" id="L1008">                    buf.append(dig);</span>
<span class="nc" id="L1009">                    return k + 1;</span>
                }
<span class="pc bpc" id="L1011" title="3 of 6 branches missed.">                if ((j &lt; 0)</span>
                        || ((j == 0)
                            &amp;&amp; (mode == 0)
<span class="nc bnc" id="L1014" title="All 2 branches missed.">                            &amp;&amp; ((word1(d) &amp; 1) == 0)</span>
                    )) {
<span class="fc bfc" id="L1016" title="All 2 branches covered.">                    if (j1 &gt; 0) {</span>
                        /* Either dig or dig+1 would work here as the least significant decimal digit.
                           Use whichever would produce a decimal value closer to d. */
<span class="fc" id="L1019">                        b = b.shiftLeft(1);</span>
<span class="fc" id="L1020">                        j1 = b.compareTo(S);</span>
<span class="pc bpc" id="L1021" title="8 of 10 branches missed.">                        if (((j1 &gt; 0) || (j1 == 0 &amp;&amp; (((dig &amp; 1) == 1) || biasUp)))</span>
                            &amp;&amp; (dig++ == '9')) {
<span class="nc" id="L1023">                                buf.append('9');</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">                                if (roundOff(buf)) {</span>
<span class="nc" id="L1025">                                    k++;</span>
<span class="nc" id="L1026">                                    buf.append('1');</span>
                                }
<span class="nc" id="L1028">                                return k + 1;</span>
//                                goto round_9_up;
                        }
                    }
<span class="fc" id="L1032">                    buf.append(dig);</span>
<span class="fc" id="L1033">                    return k + 1;</span>
                }
<span class="fc bfc" id="L1035" title="All 2 branches covered.">                if (j1 &gt; 0) {</span>
<span class="pc bpc" id="L1036" title="1 of 2 branches missed.">                    if (dig == '9') { /* possible if i == 1 */</span>
//                    round_9_up:
//                        *s++ = '9';
//                        goto roundoff;
<span class="nc" id="L1040">                        buf.append('9');</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">                        if (roundOff(buf)) {</span>
<span class="nc" id="L1042">                            k++;</span>
<span class="nc" id="L1043">                            buf.append('1');</span>
                        }
<span class="nc" id="L1045">                        return k + 1;</span>
                    }
<span class="fc" id="L1047">                    buf.append((char)(dig + 1));</span>
<span class="fc" id="L1048">                    return k + 1;</span>
                }
<span class="fc" id="L1050">                buf.append(dig);</span>
<span class="fc bfc" id="L1051" title="All 2 branches covered.">                if (i == ilim)</span>
<span class="fc" id="L1052">                    break;</span>
<span class="fc" id="L1053">                b = b.multiply(BigInteger.valueOf(10));</span>
<span class="pc bpc" id="L1054" title="1 of 2 branches missed.">                if (mlo == mhi)</span>
<span class="fc" id="L1055">                    mlo = mhi = mhi.multiply(BigInteger.valueOf(10));</span>
                else {
<span class="nc" id="L1057">                    mlo = mlo.multiply(BigInteger.valueOf(10));</span>
<span class="nc" id="L1058">                    mhi = mhi.multiply(BigInteger.valueOf(10));</span>
                }
            }
        }
        else
<span class="fc" id="L1063">            for(i = 1;; i++) {</span>
//                (char)(dig = quorem(b,S) + '0');
<span class="fc" id="L1065">                BigInteger[] divResult = b.divideAndRemainder(S);</span>
<span class="fc" id="L1066">                b = divResult[1];</span>
<span class="fc" id="L1067">                dig = (char)(divResult[0].intValue() + '0');</span>
<span class="fc" id="L1068">                buf.append(dig);</span>
<span class="fc bfc" id="L1069" title="All 2 branches covered.">                if (i &gt;= ilim)</span>
<span class="fc" id="L1070">                    break;</span>
<span class="fc" id="L1071">                b = b.multiply(BigInteger.valueOf(10));</span>
            }

        /* Round off last digit */

<span class="fc" id="L1076">        b = b.shiftLeft(1);</span>
<span class="fc" id="L1077">        j = b.compareTo(S);</span>
<span class="pc bpc" id="L1078" title="5 of 8 branches missed.">        if ((j &gt; 0) || (j == 0 &amp;&amp; (((dig &amp; 1) == 1) || biasUp))) {</span>
//        roundoff:
//            while(*--s == '9')
//                if (s == buf) {
//                    k++;
//                    *s++ = '1';
//                    goto ret;
//                }
//            ++*s++;
<span class="pc bpc" id="L1087" title="1 of 2 branches missed.">            if (roundOff(buf)) {</span>
<span class="nc" id="L1088">                k++;</span>
<span class="nc" id="L1089">                buf.append('1');</span>
<span class="nc" id="L1090">                return k + 1;</span>
            }
        }
        else {
<span class="fc" id="L1094">            stripTrailingZeroes(buf);</span>
//            while(*--s == '0') ;
//            s++;
        }
//      ret:
//        Bfree(S);
//        if (mhi) {
//            if (mlo &amp;&amp; mlo != mhi)
//                Bfree(mlo);
//            Bfree(mhi);
//        }
//      ret1:
//        Bfree(b);
//        JS_ASSERT(s &lt; buf + bufsize);
<span class="fc" id="L1108">        return k + 1;</span>
    }

    private static void
    stripTrailingZeroes(StringBuilder buf)
    {
//      while(*--s == '0') ;
//      s++;
<span class="fc" id="L1116">        int bl = buf.length();</span>
<span class="pc bpc" id="L1117" title="1 of 4 branches missed.">        while(bl--&gt;0 &amp;&amp; buf.charAt(bl) == '0') {</span>
          // empty
        }
<span class="fc" id="L1120">        buf.setLength(bl + 1);</span>
<span class="fc" id="L1121">    }</span>

    /* Mapping of JSDToStrMode -&gt; JS_dtoa mode */
<span class="fc" id="L1124">    private static final int dtoaModes[] = {</span>
        0,   /* DTOSTR_STANDARD */
        0,   /* DTOSTR_STANDARD_EXPONENTIAL, */
        3,   /* DTOSTR_FIXED, */
        2,   /* DTOSTR_EXPONENTIAL, */
        2};  /* DTOSTR_PRECISION */

    static void
    JS_dtostr(StringBuilder buffer, int mode, int precision, double d)
    {
        int decPt;                                    /* Position of decimal point relative to first digit returned by JS_dtoa */
<span class="fc" id="L1135">        boolean[] sign = new boolean[1];            /* true if the sign bit was set in d */</span>
        int nDigits;                                /* Number of significand digits returned by JS_dtoa */

//        JS_ASSERT(bufferSize &gt;= (size_t)(mode &lt;= DTOSTR_STANDARD_EXPONENTIAL ? DTOSTR_STANDARD_BUFFER_SIZE :
//                DTOSTR_VARIABLE_BUFFER_SIZE(precision)));

<span class="pc bpc" id="L1141" title="2 of 6 branches missed.">        if (mode == DTOSTR_FIXED &amp;&amp; (d &gt;= 1e21 || d &lt;= -1e21))</span>
<span class="nc" id="L1142">            mode = DTOSTR_STANDARD; /* Change mode here rather than below because the buffer may not be large enough to hold a large integer. */</span>

<span class="fc bfc" id="L1144" title="All 2 branches covered.">        decPt = JS_dtoa(d, dtoaModes[mode], mode &gt;= DTOSTR_FIXED, precision, sign, buffer);</span>
<span class="fc" id="L1145">        nDigits = buffer.length();</span>

        /* If Infinity, -Infinity, or NaN, return the string regardless of the mode. */
<span class="pc bpc" id="L1148" title="1 of 2 branches missed.">        if (decPt != 9999) {</span>
<span class="fc" id="L1149">            boolean exponentialNotation = false;</span>
<span class="fc" id="L1150">            int minNDigits = 0;         /* Minimum number of significand digits required by mode and precision */</span>
            int p;

<span class="pc bpc" id="L1153" title="2 of 6 branches missed.">            switch (mode) {</span>
                case DTOSTR_STANDARD:
<span class="fc bfc" id="L1155" title="All 4 branches covered.">                    if (decPt &lt; -5 || decPt &gt; 21)</span>
<span class="fc" id="L1156">                        exponentialNotation = true;</span>
                    else
<span class="fc" id="L1158">                        minNDigits = decPt;</span>
<span class="fc" id="L1159">                    break;</span>

                case DTOSTR_FIXED:
<span class="fc bfc" id="L1162" title="All 2 branches covered.">                    if (precision &gt;= 0)</span>
<span class="fc" id="L1163">                        minNDigits = decPt + precision;</span>
                    else
<span class="fc" id="L1165">                        minNDigits = decPt;</span>
<span class="fc" id="L1166">                    break;</span>

                case DTOSTR_EXPONENTIAL:
//                    JS_ASSERT(precision &gt; 0);
<span class="fc" id="L1170">                    minNDigits = precision;</span>
                    /* fallthru */
                case DTOSTR_STANDARD_EXPONENTIAL:
<span class="fc" id="L1173">                    exponentialNotation = true;</span>
<span class="fc" id="L1174">                    break;</span>

                case DTOSTR_PRECISION:
//                    JS_ASSERT(precision &gt; 0);
<span class="fc" id="L1178">                    minNDigits = precision;</span>
<span class="pc bpc" id="L1179" title="2 of 4 branches missed.">                    if (decPt &lt; -5 || decPt &gt; precision)</span>
<span class="fc" id="L1180">                        exponentialNotation = true;</span>
                    break;
            }

            /* If the number has fewer than minNDigits, pad it with zeros at the end */
<span class="fc bfc" id="L1185" title="All 2 branches covered.">            if (nDigits &lt; minNDigits) {</span>
<span class="fc" id="L1186">                p = minNDigits;</span>
<span class="fc" id="L1187">                nDigits = minNDigits;</span>
                do {
<span class="fc" id="L1189">                    buffer.append('0');</span>
<span class="fc bfc" id="L1190" title="All 2 branches covered.">                } while (buffer.length() != p);</span>
            }

<span class="fc bfc" id="L1193" title="All 2 branches covered.">            if (exponentialNotation) {</span>
                /* Insert a decimal point if more than one significand digit */
<span class="fc bfc" id="L1195" title="All 2 branches covered.">                if (nDigits != 1) {</span>
<span class="fc" id="L1196">                    buffer.insert(1, '.');</span>
                }
<span class="fc" id="L1198">                buffer.append('e');</span>
<span class="fc bfc" id="L1199" title="All 2 branches covered.">                if ((decPt - 1) &gt;= 0)</span>
<span class="fc" id="L1200">                    buffer.append('+');</span>
<span class="fc" id="L1201">                buffer.append(decPt - 1);</span>
//                JS_snprintf(numEnd, bufferSize - (numEnd - buffer), &quot;e%+d&quot;, decPt-1);
<span class="fc bfc" id="L1203" title="All 2 branches covered.">            } else if (decPt != nDigits) {</span>
                /* Some kind of a fraction in fixed notation */
//                JS_ASSERT(decPt &lt;= nDigits);
<span class="fc bfc" id="L1206" title="All 2 branches covered.">                if (decPt &gt; 0) {</span>
                    /* dd...dd . dd...dd */
<span class="fc" id="L1208">                    buffer.insert(decPt, '.');</span>
                } else {
                    /* 0 . 00...00dd...dd */
<span class="fc bfc" id="L1211" title="All 2 branches covered.">                    for (int i = 0; i &lt; 1 - decPt; i++)</span>
<span class="fc" id="L1212">                        buffer.insert(0, '0');</span>
<span class="fc" id="L1213">                    buffer.insert(1, '.');</span>
                }
            }
        }

        /* If negative and neither -0.0 nor NaN, output a leading '-'. */
<span class="fc bfc" id="L1219" title="All 2 branches covered.">        if (sign[0] &amp;&amp;</span>
<span class="pc bpc" id="L1220" title="3 of 4 branches missed.">                !(word0(d) == Sign_bit &amp;&amp; word1(d) == 0) &amp;&amp;</span>
<span class="pc bpc" id="L1221" title="1 of 2 branches missed.">                !((word0(d) &amp; Exp_mask) == Exp_mask &amp;&amp;</span>
<span class="nc bnc" id="L1222" title="All 4 branches missed.">                  ((word1(d) != 0) || ((word0(d) &amp; Frac_mask) != 0)))) {</span>
<span class="fc" id="L1223">            buffer.insert(0, '-');</span>
        }
<span class="fc" id="L1225">    }</span>

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>