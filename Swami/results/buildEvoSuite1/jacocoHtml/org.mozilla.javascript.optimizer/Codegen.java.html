<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Codegen.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rhino-Rhino1_7_9_Release</a> &gt; <a href="index.source.html" class="el_package">org.mozilla.javascript.optimizer</a> &gt; <span class="el_source">Codegen.java</span></div><h1>Codegen.java</h1><pre class="source lang-java linenums">/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */


package org.mozilla.javascript.optimizer;

import org.mozilla.javascript.*;
import org.mozilla.javascript.ast.FunctionNode;
import org.mozilla.javascript.ast.Jump;
import org.mozilla.javascript.ast.Name;
import org.mozilla.javascript.ast.ScriptNode;
import org.mozilla.classfile.*;

import java.util.*;
import java.lang.reflect.Constructor;

import static org.mozilla.classfile.ClassFileWriter.ACC_FINAL;
import static org.mozilla.classfile.ClassFileWriter.ACC_PRIVATE;
import static org.mozilla.classfile.ClassFileWriter.ACC_PUBLIC;
import static org.mozilla.classfile.ClassFileWriter.ACC_STATIC;
import static org.mozilla.classfile.ClassFileWriter.ACC_VOLATILE;

/**
 * This class generates code for a given IR tree.
 *
 * @author Norris Boyd
 * @author Roger Lawrence
 */

<span class="fc" id="L33">public class Codegen implements Evaluator</span>
{
    public void captureStackInfo(RhinoException ex) {
<span class="fc" id="L36">        throw new UnsupportedOperationException();</span>
    }

    public String getSourcePositionFromStack(Context cx, int[] linep) {
<span class="fc" id="L40">        throw new UnsupportedOperationException();</span>
    }

    public String getPatchedStack(RhinoException ex, String nativeStackTrace) {
<span class="fc" id="L44">        throw new UnsupportedOperationException();</span>
    }

    public List&lt;String&gt; getScriptStack(RhinoException ex) {
<span class="fc" id="L48">        throw new UnsupportedOperationException();</span>
    }

    public void setEvalScriptFlag(Script script) {
<span class="nc" id="L52">        throw new UnsupportedOperationException();</span>
    }

    public Object compile(CompilerEnvirons compilerEnv,
                          ScriptNode tree,
                          String encodedSource,
                          boolean returnFunction)
    {
        int serial;
<span class="fc" id="L61">        synchronized (globalLock) {</span>
<span class="fc" id="L62">            serial = ++globalSerialClassCounter;</span>
<span class="pc" id="L63">        }</span>

<span class="fc" id="L65">        String baseName = &quot;c&quot;;</span>
<span class="pc bpc" id="L66" title="1 of 2 branches missed.">        if (tree.getSourceName().length() &gt; 0) {</span>
<span class="fc" id="L67">          baseName = tree.getSourceName().replaceAll(&quot;\\W&quot;, &quot;_&quot;);</span>
<span class="pc bpc" id="L68" title="1 of 2 branches missed.">          if (!Character.isJavaIdentifierStart(baseName.charAt(0))) {</span>
<span class="nc" id="L69">            baseName = &quot;_&quot; + baseName;</span>
          }
        }

<span class="fc" id="L73">        String mainClassName = &quot;org.mozilla.javascript.gen.&quot; + baseName + &quot;_&quot; + serial;</span>

<span class="fc" id="L75">        byte[] mainClassBytes = compileToClassFile(compilerEnv, mainClassName,</span>
                                                   tree, encodedSource,
                                                   returnFunction);

<span class="fc" id="L79">        return new Object[] { mainClassName, mainClassBytes };</span>
    }

    public Script createScriptObject(Object bytecode,
                                     Object staticSecurityDomain)
    {
<span class="fc" id="L85">        Class&lt;?&gt; cl = defineClass(bytecode, staticSecurityDomain);</span>

        Script script;
        try {
<span class="fc" id="L89">            script = (Script)cl.newInstance();</span>
<span class="nc" id="L90">        } catch (Exception ex) {</span>
<span class="nc" id="L91">            throw new RuntimeException</span>
<span class="nc" id="L92">                (&quot;Unable to instantiate compiled class:&quot; + ex.toString());</span>
<span class="fc" id="L93">        }</span>
<span class="fc" id="L94">        return script;</span>
    }

    public Function createFunctionObject(Context cx, Scriptable scope,
                                         Object bytecode,
                                         Object staticSecurityDomain)
    {
<span class="nc" id="L101">        Class&lt;?&gt; cl = defineClass(bytecode, staticSecurityDomain);</span>

        NativeFunction f;
        try {
<span class="nc" id="L105">            Constructor&lt;?&gt;ctor = cl.getConstructors()[0];</span>
<span class="nc" id="L106">            Object[] initArgs = { scope, cx, Integer.valueOf(0) };</span>
<span class="nc" id="L107">            f = (NativeFunction)ctor.newInstance(initArgs);</span>
<span class="nc" id="L108">        } catch (Exception ex) {</span>
<span class="nc" id="L109">            throw new RuntimeException</span>
<span class="nc" id="L110">                (&quot;Unable to instantiate compiled class:&quot;+ex.toString());</span>
<span class="nc" id="L111">        }</span>
<span class="nc" id="L112">        return f;</span>
    }

    private Class&lt;?&gt; defineClass(Object bytecode,
                                 Object staticSecurityDomain)
    {
<span class="fc" id="L118">        Object[] nameBytesPair = (Object[])bytecode;</span>
<span class="fc" id="L119">        String className = (String)nameBytesPair[0];</span>
<span class="fc" id="L120">        byte[] classBytes = (byte[])nameBytesPair[1];</span>

        // The generated classes in this case refer only to Rhino classes
        // which must be accessible through this class loader
<span class="fc" id="L124">        ClassLoader rhinoLoader = getClass().getClassLoader();</span>
        GeneratedClassLoader loader;
<span class="fc" id="L126">        loader = SecurityController.createLoader(rhinoLoader,</span>
                                                 staticSecurityDomain);
        Exception e;
        try {
<span class="fc" id="L130">            Class&lt;?&gt; cl = loader.defineClass(className, classBytes);</span>
<span class="fc" id="L131">            loader.linkClass(cl);</span>
<span class="fc" id="L132">            return cl;</span>
<span class="nc" id="L133">        } catch (SecurityException x) {</span>
<span class="nc" id="L134">            e = x;</span>
<span class="nc" id="L135">        } catch (IllegalArgumentException x) {</span>
<span class="nc" id="L136">            e = x;</span>
<span class="nc" id="L137">        }</span>
<span class="nc" id="L138">        throw new RuntimeException(&quot;Malformed optimizer package &quot; + e);</span>
    }

    public byte[] compileToClassFile(CompilerEnvirons compilerEnv,
                                     String mainClassName,
                                     ScriptNode scriptOrFn,
                                     String encodedSource,
                                     boolean returnFunction)
    {
<span class="fc" id="L147">        this.compilerEnv = compilerEnv;</span>

<span class="fc" id="L149">        transform(scriptOrFn);</span>

        if (Token.printTrees) {
            System.out.println(scriptOrFn.toStringTree(scriptOrFn));
        }

<span class="fc bfc" id="L155" title="All 2 branches covered.">        if (returnFunction) {</span>
<span class="nc" id="L156">            scriptOrFn = scriptOrFn.getFunctionNode(0);</span>
        }

<span class="fc" id="L159">        initScriptNodesData(scriptOrFn);</span>

<span class="fc" id="L161">        this.mainClassName = mainClassName;</span>
<span class="fc" id="L162">        this.mainClassSignature</span>
<span class="fc" id="L163">            = ClassFileWriter.classNameToSignature(mainClassName);</span>

        try {
<span class="fc" id="L166">            return generateCode(encodedSource);</span>
<span class="nc" id="L167">        } catch (ClassFileWriter.ClassFileFormatException e) {</span>
<span class="nc" id="L168">            throw reportClassFileFormatException(scriptOrFn, e.getMessage());</span>
        }
    }

    private RuntimeException reportClassFileFormatException(
        ScriptNode scriptOrFn,
        String message)
    {
<span class="nc bnc" id="L176" title="All 2 branches missed.">        String msg = scriptOrFn instanceof FunctionNode</span>
<span class="nc" id="L177">        ? ScriptRuntime.getMessage2(&quot;msg.while.compiling.fn&quot;,</span>
<span class="nc" id="L178">            ((FunctionNode)scriptOrFn).getFunctionName(), message)</span>
<span class="nc" id="L179">        : ScriptRuntime.getMessage1(&quot;msg.while.compiling.script&quot;, message);</span>
<span class="nc" id="L180">        return Context.reportRuntimeError(msg, scriptOrFn.getSourceName(),</span>
<span class="nc" id="L181">            scriptOrFn.getLineno(), null, 0);</span>
    }

    private void transform(ScriptNode tree)
    {
<span class="fc" id="L186">        initOptFunctions_r(tree);</span>

<span class="fc" id="L188">        int optLevel = compilerEnv.getOptimizationLevel();</span>

<span class="fc" id="L190">        Map&lt;String,OptFunctionNode&gt; possibleDirectCalls = null;</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">        if (optLevel &gt; 0) {</span>
           /*
            * Collect all of the contained functions into a hashtable
            * so that the call optimizer can access the class name &amp; parameter
            * count for any call it encounters
            */
<span class="nc bnc" id="L197" title="All 2 branches missed.">            if (tree.getType() == Token.SCRIPT) {</span>
<span class="nc" id="L198">                int functionCount = tree.getFunctionCount();</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">                for (int i = 0; i != functionCount; ++i) {</span>
<span class="nc" id="L200">                    OptFunctionNode ofn = OptFunctionNode.get(tree, i);</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">                    if (ofn.fnode.getFunctionType()</span>
                        == FunctionNode.FUNCTION_STATEMENT)
                    {
<span class="nc" id="L204">                        String name = ofn.fnode.getName();</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">                        if (name.length() != 0) {</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">                            if (possibleDirectCalls == null) {</span>
<span class="nc" id="L207">                                possibleDirectCalls = new HashMap&lt;String,OptFunctionNode&gt;();</span>
                            }
<span class="nc" id="L209">                            possibleDirectCalls.put(name, ofn);</span>
                        }
                    }
                }
            }
        }

<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        if (possibleDirectCalls != null) {</span>
<span class="nc" id="L217">            directCallTargets = new ObjArray();</span>
        }

<span class="fc" id="L220">        OptTransformer ot = new OptTransformer(possibleDirectCalls,</span>
                                               directCallTargets);
<span class="fc" id="L222">        ot.transform(tree, compilerEnv);</span>

<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        if (optLevel &gt; 0) {</span>
<span class="nc" id="L225">            (new Optimizer()).optimize(tree);</span>
        }
<span class="fc" id="L227">    }</span>

    private static void initOptFunctions_r(ScriptNode scriptOrFn)
    {
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        for (int i = 0, N = scriptOrFn.getFunctionCount(); i != N; ++i) {</span>
<span class="nc" id="L232">            FunctionNode fn = scriptOrFn.getFunctionNode(i);</span>
<span class="nc" id="L233">            new OptFunctionNode(fn);</span>
<span class="nc" id="L234">            initOptFunctions_r(fn);</span>
        }
<span class="fc" id="L236">    }</span>

    private void initScriptNodesData(ScriptNode scriptOrFn)
    {
<span class="fc" id="L240">        ObjArray x = new ObjArray();</span>
<span class="fc" id="L241">        collectScriptNodes_r(scriptOrFn, x);</span>

<span class="fc" id="L243">        int count = x.size();</span>
<span class="fc" id="L244">        scriptOrFnNodes = new ScriptNode[count];</span>
<span class="fc" id="L245">        x.toArray(scriptOrFnNodes);</span>

<span class="fc" id="L247">        scriptOrFnIndexes = new ObjToIntMap(count);</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">        for (int i = 0; i != count; ++i) {</span>
<span class="fc" id="L249">            scriptOrFnIndexes.put(scriptOrFnNodes[i], i);</span>
        }
<span class="fc" id="L251">    }</span>

    private static void collectScriptNodes_r(ScriptNode n,
                                                 ObjArray x)
    {
<span class="fc" id="L256">        x.add(n);</span>
<span class="fc" id="L257">        int nestedCount = n.getFunctionCount();</span>
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        for (int i = 0; i != nestedCount; ++i) {</span>
<span class="nc" id="L259">            collectScriptNodes_r(n.getFunctionNode(i), x);</span>
        }
<span class="fc" id="L261">    }</span>

    private byte[] generateCode(String encodedSource)
    {
<span class="fc bfc" id="L265" title="All 2 branches covered.">        boolean hasScript = (scriptOrFnNodes[0].getType() == Token.SCRIPT);</span>
<span class="pc bpc" id="L266" title="1 of 4 branches missed.">        boolean hasFunctions = (scriptOrFnNodes.length &gt; 1 || !hasScript);</span>
<span class="fc" id="L267">        boolean isStrictMode = scriptOrFnNodes[0].isInStrictMode();</span>

<span class="fc" id="L269">        String sourceFile = null;</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">        if (compilerEnv.isGenerateDebugInfo()) {</span>
<span class="fc" id="L271">            sourceFile = scriptOrFnNodes[0].getSourceName();</span>
        }

<span class="fc" id="L274">        ClassFileWriter cfw = new ClassFileWriter(mainClassName,</span>
                                                  SUPER_CLASS_NAME,
                                                  sourceFile);
<span class="fc" id="L277">        cfw.addField(ID_FIELD_NAME, &quot;I&quot;, ACC_PRIVATE);</span>

<span class="fc bfc" id="L279" title="All 2 branches covered.">        if (hasFunctions) {</span>
<span class="nc" id="L280">            generateFunctionConstructor(cfw);</span>
        }

<span class="pc bpc" id="L283" title="1 of 2 branches missed.">        if (hasScript) {</span>
<span class="fc" id="L284">            cfw.addInterface(&quot;org/mozilla/javascript/Script&quot;);</span>
<span class="fc" id="L285">            generateScriptCtor(cfw);</span>
<span class="fc" id="L286">            generateMain(cfw);</span>
<span class="fc" id="L287">            generateExecute(cfw);</span>
        }

<span class="fc" id="L290">        generateCallMethod(cfw, isStrictMode);</span>
<span class="fc" id="L291">        generateResumeGenerator(cfw);</span>

<span class="fc" id="L293">        generateNativeFunctionOverrides(cfw, encodedSource);</span>

<span class="fc" id="L295">        int count = scriptOrFnNodes.length;</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">        for (int i = 0; i != count; ++i) {</span>
<span class="fc" id="L297">            ScriptNode n = scriptOrFnNodes[i];</span>

<span class="fc" id="L299">            BodyCodegen bodygen = new BodyCodegen();</span>
<span class="fc" id="L300">            bodygen.cfw = cfw;</span>
<span class="fc" id="L301">            bodygen.codegen = this;</span>
<span class="fc" id="L302">            bodygen.compilerEnv = compilerEnv;</span>
<span class="fc" id="L303">            bodygen.scriptOrFn = n;</span>
<span class="fc" id="L304">            bodygen.scriptOrFnIndex = i;</span>

            try {
<span class="fc" id="L307">                bodygen.generateBodyCode();</span>
<span class="nc" id="L308">            } catch (ClassFileWriter.ClassFileFormatException e) {</span>
<span class="nc" id="L309">                throw reportClassFileFormatException(n, e.getMessage());</span>
<span class="fc" id="L310">            }</span>

<span class="pc bpc" id="L312" title="1 of 2 branches missed.">            if (n.getType() == Token.FUNCTION) {</span>
<span class="nc" id="L313">                OptFunctionNode ofn = OptFunctionNode.get(n);</span>
<span class="nc" id="L314">                generateFunctionInit(cfw, ofn);</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">                if (ofn.isTargetOfDirectCall()) {</span>
<span class="nc" id="L316">                    emitDirectConstructor(cfw, ofn);</span>
                }
            }
        }

<span class="fc" id="L321">        emitRegExpInit(cfw);</span>
<span class="fc" id="L322">        emitConstantDudeInitializers(cfw);</span>

<span class="fc" id="L324">        return cfw.toByteArray();</span>
    }

    private void emitDirectConstructor(ClassFileWriter cfw,
                                       OptFunctionNode ofn)
    {
/*
    we generate ..
        Scriptable directConstruct(&lt;directCallArgs&gt;) {
            Scriptable newInstance = createObject(cx, scope);
            Object val = &lt;body-name&gt;(cx, scope, newInstance, &lt;directCallArgs&gt;);
            if (val instanceof Scriptable) {
                return (Scriptable) val;
            }
            return newInstance;
        }
*/
<span class="nc" id="L341">        cfw.startMethod(getDirectCtorName(ofn.fnode),</span>
<span class="nc" id="L342">                        getBodyMethodSignature(ofn.fnode),</span>
                        (short)(ACC_STATIC | ACC_PRIVATE));

<span class="nc" id="L345">        int argCount = ofn.fnode.getParamCount();</span>
<span class="nc" id="L346">        int firstLocal = (4 + argCount * 3) + 1;</span>

<span class="nc" id="L348">        cfw.addALoad(0); // this</span>
<span class="nc" id="L349">        cfw.addALoad(1); // cx</span>
<span class="nc" id="L350">        cfw.addALoad(2); // scope</span>
<span class="nc" id="L351">        cfw.addInvoke(ByteCode.INVOKEVIRTUAL,</span>
                      &quot;org/mozilla/javascript/BaseFunction&quot;,
                      &quot;createObject&quot;,
                      &quot;(Lorg/mozilla/javascript/Context;&quot;
                      +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                      +&quot;)Lorg/mozilla/javascript/Scriptable;&quot;);
<span class="nc" id="L357">        cfw.addAStore(firstLocal);</span>

<span class="nc" id="L359">        cfw.addALoad(0);</span>
<span class="nc" id="L360">        cfw.addALoad(1);</span>
<span class="nc" id="L361">        cfw.addALoad(2);</span>
<span class="nc" id="L362">        cfw.addALoad(firstLocal);</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">        for (int i = 0; i &lt; argCount; i++) {</span>
<span class="nc" id="L364">            cfw.addALoad(4 + (i * 3));</span>
<span class="nc" id="L365">            cfw.addDLoad(5 + (i * 3));</span>
        }
<span class="nc" id="L367">        cfw.addALoad(4 + argCount * 3);</span>
<span class="nc" id="L368">        cfw.addInvoke(ByteCode.INVOKESTATIC,</span>
                      mainClassName,
<span class="nc" id="L370">                      getBodyMethodName(ofn.fnode),</span>
<span class="nc" id="L371">                      getBodyMethodSignature(ofn.fnode));</span>
<span class="nc" id="L372">        int exitLabel = cfw.acquireLabel();</span>
<span class="nc" id="L373">        cfw.add(ByteCode.DUP); // make a copy of direct call result</span>
<span class="nc" id="L374">        cfw.add(ByteCode.INSTANCEOF, &quot;org/mozilla/javascript/Scriptable&quot;);</span>
<span class="nc" id="L375">        cfw.add(ByteCode.IFEQ, exitLabel);</span>
        // cast direct call result
<span class="nc" id="L377">        cfw.add(ByteCode.CHECKCAST, &quot;org/mozilla/javascript/Scriptable&quot;);</span>
<span class="nc" id="L378">        cfw.add(ByteCode.ARETURN);</span>
<span class="nc" id="L379">        cfw.markLabel(exitLabel);</span>

<span class="nc" id="L381">        cfw.addALoad(firstLocal);</span>
<span class="nc" id="L382">        cfw.add(ByteCode.ARETURN);</span>

<span class="nc" id="L384">        cfw.stopMethod((short)(firstLocal + 1));</span>
<span class="nc" id="L385">    }</span>

    static boolean isGenerator(ScriptNode node)
    {
<span class="fc bfc" id="L389" title="All 2 branches covered.">        return (node.getType() == Token.FUNCTION ) &amp;&amp;</span>
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">                ((FunctionNode)node).isGenerator();</span>
    }

    // How dispatch to generators works:
    // Two methods are generated corresponding to a user-written generator.
    // One of these creates a generator object (NativeGenerator), which is
    // returned to the user. The other method contains all of the body code
    // of the generator.
    // When a user calls a generator, the call() method dispatches control to
    // to the method that creates the NativeGenerator object. Subsequently when
    // the user invokes .next(), .send() or any such method on the generator
    // object, the resumeGenerator() below dispatches the call to the
    // method corresponding to the generator body. As a matter of convention
    // the generator body is given the name of the generator activation function
    // appended by &quot;_gen&quot;.
    private void generateResumeGenerator(ClassFileWriter cfw)
    {
<span class="fc" id="L407">        boolean hasGenerators = false;</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">        for (int i=0; i &lt; scriptOrFnNodes.length; i++) {</span>
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">            if (isGenerator(scriptOrFnNodes[i]))</span>
<span class="nc" id="L410">                hasGenerators = true;</span>
        }

        // if there are no generators defined, we don't implement a
        // resumeGenerator(). The base class provides a default implementation.
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">        if (!hasGenerators)</span>
<span class="fc" id="L416">            return;</span>

<span class="nc" id="L418">        cfw.startMethod(&quot;resumeGenerator&quot;,</span>
                        &quot;(Lorg/mozilla/javascript/Context;&quot; +
                        &quot;Lorg/mozilla/javascript/Scriptable;&quot; +
                        &quot;ILjava/lang/Object;&quot; +
                        &quot;Ljava/lang/Object;)Ljava/lang/Object;&quot;,
                        (short)(ACC_PUBLIC | ACC_FINAL));

        // load arguments for dispatch to the corresponding *_gen method
<span class="nc" id="L426">        cfw.addALoad(0);</span>
<span class="nc" id="L427">        cfw.addALoad(1);</span>
<span class="nc" id="L428">        cfw.addALoad(2);</span>
<span class="nc" id="L429">        cfw.addALoad(4);</span>
<span class="nc" id="L430">        cfw.addALoad(5);</span>
<span class="nc" id="L431">        cfw.addILoad(3);</span>

<span class="nc" id="L433">        cfw.addLoadThis();</span>
<span class="nc" id="L434">        cfw.add(ByteCode.GETFIELD, cfw.getClassName(), ID_FIELD_NAME, &quot;I&quot;);</span>

<span class="nc" id="L436">        int startSwitch = cfw.addTableSwitch(0, scriptOrFnNodes.length - 1);</span>
<span class="nc" id="L437">        cfw.markTableSwitchDefault(startSwitch);</span>
<span class="nc" id="L438">        int endlabel = cfw.acquireLabel();</span>

<span class="nc bnc" id="L440" title="All 2 branches missed.">        for (int i = 0; i &lt; scriptOrFnNodes.length; i++) {</span>
<span class="nc" id="L441">            ScriptNode n = scriptOrFnNodes[i];</span>
<span class="nc" id="L442">            cfw.markTableSwitchCase(startSwitch, i, (short)6);</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">            if (isGenerator(n)) {</span>
<span class="nc" id="L444">                String type = &quot;(&quot; +</span>
                              mainClassSignature +
                              &quot;Lorg/mozilla/javascript/Context;&quot; +
                              &quot;Lorg/mozilla/javascript/Scriptable;&quot; +
                              &quot;Ljava/lang/Object;&quot; +
                              &quot;Ljava/lang/Object;I)Ljava/lang/Object;&quot;;
<span class="nc" id="L450">                cfw.addInvoke(ByteCode.INVOKESTATIC,</span>
                              mainClassName,
<span class="nc" id="L452">                              getBodyMethodName(n) + &quot;_gen&quot;,</span>
                              type);
<span class="nc" id="L454">                cfw.add(ByteCode.ARETURN);</span>
<span class="nc" id="L455">            } else {</span>
<span class="nc" id="L456">                cfw.add(ByteCode.GOTO, endlabel);</span>
            }
        }

<span class="nc" id="L460">        cfw.markLabel(endlabel);</span>
<span class="nc" id="L461">        pushUndefined(cfw);</span>
<span class="nc" id="L462">        cfw.add(ByteCode.ARETURN);</span>


        // this method uses as many locals as there are arguments (hence 6)
<span class="nc" id="L466">        cfw.stopMethod((short)6);</span>
<span class="nc" id="L467">    }</span>

    private void generateCallMethod(ClassFileWriter cfw, boolean isStrictMode)
    {
<span class="fc" id="L471">        cfw.startMethod(&quot;call&quot;,</span>
                        &quot;(Lorg/mozilla/javascript/Context;&quot; +
                        &quot;Lorg/mozilla/javascript/Scriptable;&quot; +
                        &quot;Lorg/mozilla/javascript/Scriptable;&quot; +
                        &quot;[Ljava/lang/Object;)Ljava/lang/Object;&quot;,
                        (short)(ACC_PUBLIC | ACC_FINAL));

        // Generate code for:
        // if (!ScriptRuntime.hasTopCall(cx)) {
        //     return ScriptRuntime.doTopCall(this, cx, scope, thisObj, args);
        // }

<span class="fc" id="L483">        int nonTopCallLabel = cfw.acquireLabel();</span>
<span class="fc" id="L484">        cfw.addALoad(1); //cx</span>
<span class="fc" id="L485">        cfw.addInvoke(ByteCode.INVOKESTATIC,</span>
                      &quot;org/mozilla/javascript/ScriptRuntime&quot;,
                      &quot;hasTopCall&quot;,
                      &quot;(Lorg/mozilla/javascript/Context;&quot;
                      +&quot;)Z&quot;);
<span class="fc" id="L490">        cfw.add(ByteCode.IFNE, nonTopCallLabel);</span>
<span class="fc" id="L491">        cfw.addALoad(0);</span>
<span class="fc" id="L492">        cfw.addALoad(1);</span>
<span class="fc" id="L493">        cfw.addALoad(2);</span>
<span class="fc" id="L494">        cfw.addALoad(3);</span>
<span class="fc" id="L495">        cfw.addALoad(4);</span>
<span class="fc" id="L496">        cfw.addPush(isStrictMode);</span>
<span class="fc" id="L497">        cfw.addInvoke(ByteCode.INVOKESTATIC,</span>
                      &quot;org/mozilla/javascript/ScriptRuntime&quot;,
                      &quot;doTopCall&quot;,
                      &quot;(Lorg/mozilla/javascript/Callable;&quot;
                      +&quot;Lorg/mozilla/javascript/Context;&quot;
                      +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                      +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                      +&quot;[Ljava/lang/Object;&quot;
                      +&quot;Z&quot;
                      +&quot;)Ljava/lang/Object;&quot;);
<span class="fc" id="L507">        cfw.add(ByteCode.ARETURN);</span>
<span class="fc" id="L508">        cfw.markLabel(nonTopCallLabel);</span>

        // Now generate switch to call the real methods
<span class="fc" id="L511">        cfw.addALoad(0);</span>
<span class="fc" id="L512">        cfw.addALoad(1);</span>
<span class="fc" id="L513">        cfw.addALoad(2);</span>
<span class="fc" id="L514">        cfw.addALoad(3);</span>
<span class="fc" id="L515">        cfw.addALoad(4);</span>

<span class="fc" id="L517">        int end = scriptOrFnNodes.length;</span>
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">        boolean generateSwitch = (2 &lt;= end);</span>

<span class="fc" id="L520">        int switchStart = 0;</span>
<span class="fc" id="L521">        int switchStackTop = 0;</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">        if (generateSwitch) {</span>
<span class="nc" id="L523">            cfw.addLoadThis();</span>
<span class="nc" id="L524">            cfw.add(ByteCode.GETFIELD, cfw.getClassName(), ID_FIELD_NAME, &quot;I&quot;);</span>
            // do switch from (1,  end - 1) mapping 0 to
            // the default case
<span class="nc" id="L527">            switchStart = cfw.addTableSwitch(1, end - 1);</span>
        }

<span class="fc bfc" id="L530" title="All 2 branches covered.">        for (int i = 0; i != end; ++i) {</span>
<span class="fc" id="L531">            ScriptNode n = scriptOrFnNodes[i];</span>
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">            if (generateSwitch) {</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">                if (i == 0) {</span>
<span class="nc" id="L534">                    cfw.markTableSwitchDefault(switchStart);</span>
<span class="nc" id="L535">                    switchStackTop = cfw.getStackTop();</span>
                } else {
<span class="nc" id="L537">                    cfw.markTableSwitchCase(switchStart, i - 1,</span>
                                            switchStackTop);
                }
            }
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">            if (n.getType() == Token.FUNCTION) {</span>
<span class="nc" id="L542">                OptFunctionNode ofn = OptFunctionNode.get(n);</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">                if (ofn.isTargetOfDirectCall()) {</span>
<span class="nc" id="L544">                    int pcount = ofn.fnode.getParamCount();</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">                    if (pcount != 0) {</span>
                        // loop invariant:
                        // stack top == arguments array from addALoad4()
<span class="nc bnc" id="L548" title="All 2 branches missed.">                        for (int p = 0; p != pcount; ++p) {</span>
<span class="nc" id="L549">                            cfw.add(ByteCode.ARRAYLENGTH);</span>
<span class="nc" id="L550">                            cfw.addPush(p);</span>
<span class="nc" id="L551">                            int undefArg = cfw.acquireLabel();</span>
<span class="nc" id="L552">                            int beyond = cfw.acquireLabel();</span>
<span class="nc" id="L553">                            cfw.add(ByteCode.IF_ICMPLE, undefArg);</span>
                            // get array[p]
<span class="nc" id="L555">                            cfw.addALoad(4);</span>
<span class="nc" id="L556">                            cfw.addPush(p);</span>
<span class="nc" id="L557">                            cfw.add(ByteCode.AALOAD);</span>
<span class="nc" id="L558">                            cfw.add(ByteCode.GOTO, beyond);</span>
<span class="nc" id="L559">                            cfw.markLabel(undefArg);</span>
<span class="nc" id="L560">                            pushUndefined(cfw);</span>
<span class="nc" id="L561">                            cfw.markLabel(beyond);</span>
                            // Only one push
<span class="nc" id="L563">                            cfw.adjustStackTop(-1);</span>
<span class="nc" id="L564">                            cfw.addPush(0.0);</span>
                            // restore invariant
<span class="nc" id="L566">                            cfw.addALoad(4);</span>
                        }
                    }
                }
            }
<span class="fc" id="L571">            cfw.addInvoke(ByteCode.INVOKESTATIC,</span>
                          mainClassName,
<span class="fc" id="L573">                          getBodyMethodName(n),</span>
<span class="fc" id="L574">                          getBodyMethodSignature(n));</span>
<span class="fc" id="L575">            cfw.add(ByteCode.ARETURN);</span>
        }
<span class="fc" id="L577">        cfw.stopMethod((short)5);</span>
        // 5: this, cx, scope, js this, args[]
<span class="fc" id="L579">    }</span>

    private void generateMain(ClassFileWriter cfw)
    {
<span class="fc" id="L583">        cfw.startMethod(&quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;,</span>
                        (short)(ACC_PUBLIC | ACC_STATIC));

        // load new ScriptImpl()
<span class="fc" id="L587">        cfw.add(ByteCode.NEW, cfw.getClassName());</span>
<span class="fc" id="L588">        cfw.add(ByteCode.DUP);</span>
<span class="fc" id="L589">        cfw.addInvoke(ByteCode.INVOKESPECIAL, cfw.getClassName(),</span>
                      &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
         // load 'args'
<span class="fc" id="L592">        cfw.add(ByteCode.ALOAD_0);</span>
        // Call mainMethodClass.main(Script script, String[] args)
<span class="fc" id="L594">        cfw.addInvoke(ByteCode.INVOKESTATIC,</span>
                      mainMethodClass,
                      &quot;main&quot;,
                      &quot;(Lorg/mozilla/javascript/Script;[Ljava/lang/String;)V&quot;);
<span class="fc" id="L598">        cfw.add(ByteCode.RETURN);</span>
        // 1 = String[] args
<span class="fc" id="L600">        cfw.stopMethod((short)1);</span>
<span class="fc" id="L601">    }</span>

    private void generateExecute(ClassFileWriter cfw)
    {
<span class="fc" id="L605">        cfw.startMethod(&quot;exec&quot;,</span>
                        &quot;(Lorg/mozilla/javascript/Context;&quot;
                        +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                        +&quot;)Ljava/lang/Object;&quot;,
                        (short)(ACC_PUBLIC | ACC_FINAL));

<span class="fc" id="L611">        final int CONTEXT_ARG = 1;</span>
<span class="fc" id="L612">        final int SCOPE_ARG = 2;</span>

<span class="fc" id="L614">        cfw.addLoadThis();</span>
<span class="fc" id="L615">        cfw.addALoad(CONTEXT_ARG);</span>
<span class="fc" id="L616">        cfw.addALoad(SCOPE_ARG);</span>
<span class="fc" id="L617">        cfw.add(ByteCode.DUP);</span>
<span class="fc" id="L618">        cfw.add(ByteCode.ACONST_NULL);</span>
<span class="fc" id="L619">        cfw.addInvoke(ByteCode.INVOKEVIRTUAL,</span>
<span class="fc" id="L620">                      cfw.getClassName(),</span>
                      &quot;call&quot;,
                      &quot;(Lorg/mozilla/javascript/Context;&quot;
                      +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                      +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                      +&quot;[Ljava/lang/Object;&quot;
                      +&quot;)Ljava/lang/Object;&quot;);

<span class="fc" id="L628">        cfw.add(ByteCode.ARETURN);</span>
        // 3 = this + context + scope
<span class="fc" id="L630">        cfw.stopMethod((short)3);</span>
<span class="fc" id="L631">    }</span>

    private void generateScriptCtor(ClassFileWriter cfw)
    {
<span class="fc" id="L635">        cfw.startMethod(&quot;&lt;init&gt;&quot;, &quot;()V&quot;, ACC_PUBLIC);</span>

<span class="fc" id="L637">        cfw.addLoadThis();</span>
<span class="fc" id="L638">        cfw.addInvoke(ByteCode.INVOKESPECIAL, SUPER_CLASS_NAME,</span>
                      &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
        // set id to 0
<span class="fc" id="L641">        cfw.addLoadThis();</span>
<span class="fc" id="L642">        cfw.addPush(0);</span>
<span class="fc" id="L643">        cfw.add(ByteCode.PUTFIELD, cfw.getClassName(), ID_FIELD_NAME, &quot;I&quot;);</span>

<span class="fc" id="L645">        cfw.add(ByteCode.RETURN);</span>
        // 1 parameter = this
<span class="fc" id="L647">        cfw.stopMethod((short)1);</span>
<span class="fc" id="L648">    }</span>

    private void generateFunctionConstructor(ClassFileWriter cfw)
    {
<span class="fc" id="L652">        final int SCOPE_ARG = 1;</span>
<span class="fc" id="L653">        final int CONTEXT_ARG = 2;</span>
<span class="fc" id="L654">        final int ID_ARG = 3;</span>

<span class="fc" id="L656">        cfw.startMethod(&quot;&lt;init&gt;&quot;, FUNCTION_CONSTRUCTOR_SIGNATURE, ACC_PUBLIC);</span>
<span class="fc" id="L657">        cfw.addALoad(0);</span>
<span class="fc" id="L658">        cfw.addInvoke(ByteCode.INVOKESPECIAL, SUPER_CLASS_NAME,</span>
                      &quot;&lt;init&gt;&quot;, &quot;()V&quot;);

<span class="fc" id="L661">        cfw.addLoadThis();</span>
<span class="fc" id="L662">        cfw.addILoad(ID_ARG);</span>
<span class="fc" id="L663">        cfw.add(ByteCode.PUTFIELD, cfw.getClassName(), ID_FIELD_NAME, &quot;I&quot;);</span>

<span class="fc" id="L665">        cfw.addLoadThis();</span>
<span class="fc" id="L666">        cfw.addALoad(CONTEXT_ARG);</span>
<span class="fc" id="L667">        cfw.addALoad(SCOPE_ARG);</span>

<span class="pc bpc" id="L669" title="1 of 2 branches missed.">        int start = (scriptOrFnNodes[0].getType() == Token.SCRIPT) ? 1 : 0;</span>
<span class="fc" id="L670">        int end = scriptOrFnNodes.length;</span>
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">        if (start == end) throw badTree();</span>
<span class="pc bpc" id="L672" title="1 of 2 branches missed.">        boolean generateSwitch = (2 &lt;= end - start);</span>

<span class="fc" id="L674">        int switchStart = 0;</span>
<span class="fc" id="L675">        int switchStackTop = 0;</span>
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">        if (generateSwitch) {</span>
<span class="nc" id="L677">            cfw.addILoad(ID_ARG);</span>
            // do switch from (start + 1,  end - 1) mapping start to
            // the default case
<span class="nc" id="L680">            switchStart = cfw.addTableSwitch(start + 1, end - 1);</span>
        }

<span class="pc bpc" id="L683" title="1 of 2 branches missed.">        for (int i = start; i != end; ++i) {</span>
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">            if (generateSwitch) {</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">                if (i == start) {</span>
<span class="nc" id="L686">                    cfw.markTableSwitchDefault(switchStart);</span>
<span class="nc" id="L687">                    switchStackTop = cfw.getStackTop();</span>
                } else {
<span class="nc" id="L689">                    cfw.markTableSwitchCase(switchStart, i - 1 - start,</span>
                                            switchStackTop);
                }
            }
<span class="fc" id="L693">            OptFunctionNode ofn = OptFunctionNode.get(scriptOrFnNodes[i]);</span>
<span class="pc" id="L694">            cfw.addInvoke(ByteCode.INVOKESPECIAL,</span>
                          mainClassName,
<span class="nc" id="L696">                          getFunctionInitMethodName(ofn),</span>
                          FUNCTION_INIT_SIGNATURE);
<span class="nc" id="L698">            cfw.add(ByteCode.RETURN);</span>
        }

        // 4 = this + scope + context + id
<span class="nc" id="L702">        cfw.stopMethod((short)4);</span>
<span class="nc" id="L703">    }</span>

    private void generateFunctionInit(ClassFileWriter cfw,
                                      OptFunctionNode ofn)
    {
<span class="nc" id="L708">        final int CONTEXT_ARG = 1;</span>
<span class="nc" id="L709">        final int SCOPE_ARG = 2;</span>
<span class="nc" id="L710">        cfw.startMethod(getFunctionInitMethodName(ofn),</span>
                        FUNCTION_INIT_SIGNATURE,
                        (short)(ACC_PRIVATE | ACC_FINAL));

        // Call NativeFunction.initScriptFunction
<span class="nc" id="L715">        cfw.addLoadThis();</span>
<span class="nc" id="L716">        cfw.addALoad(CONTEXT_ARG);</span>
<span class="nc" id="L717">        cfw.addALoad(SCOPE_ARG);</span>
<span class="nc" id="L718">        cfw.addInvoke(ByteCode.INVOKEVIRTUAL,</span>
                      &quot;org/mozilla/javascript/NativeFunction&quot;,
                      &quot;initScriptFunction&quot;,
                      &quot;(Lorg/mozilla/javascript/Context;&quot;
                      +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                      +&quot;)V&quot;);

        // precompile all regexp literals
<span class="nc bnc" id="L726" title="All 2 branches missed.">        if (ofn.fnode.getRegexpCount() != 0) {</span>
<span class="nc" id="L727">            cfw.addALoad(CONTEXT_ARG);</span>
<span class="nc" id="L728">            cfw.addInvoke(ByteCode.INVOKESTATIC, mainClassName,</span>
                          REGEXP_INIT_METHOD_NAME, REGEXP_INIT_METHOD_SIGNATURE);
        }

<span class="nc" id="L732">        cfw.add(ByteCode.RETURN);</span>
        // 3 = (scriptThis/functionRef) + scope + context
<span class="nc" id="L734">        cfw.stopMethod((short)3);</span>
<span class="nc" id="L735">    }</span>

    private void generateNativeFunctionOverrides(ClassFileWriter cfw,
                                                 String encodedSource)
    {
        // Override NativeFunction.getLanguageVersion() with
        // public int getLanguageVersion() { return &lt;version-constant&gt;; }

<span class="fc" id="L743">        cfw.startMethod(&quot;getLanguageVersion&quot;, &quot;()I&quot;, ACC_PUBLIC);</span>

<span class="fc" id="L745">        cfw.addPush(compilerEnv.getLanguageVersion());</span>
<span class="fc" id="L746">        cfw.add(ByteCode.IRETURN);</span>

        // 1: this and no argument or locals
<span class="fc" id="L749">        cfw.stopMethod((short)1);</span>

        // The rest of NativeFunction overrides require specific code for each
        // script/function id

<span class="fc" id="L754">        final int Do_getFunctionName      = 0;</span>
<span class="fc" id="L755">        final int Do_getParamCount        = 1;</span>
<span class="fc" id="L756">        final int Do_getParamAndVarCount  = 2;</span>
<span class="fc" id="L757">        final int Do_getParamOrVarName    = 3;</span>
<span class="fc" id="L758">        final int Do_getEncodedSource     = 4;</span>
<span class="fc" id="L759">        final int Do_getParamOrVarConst   = 5;</span>
<span class="fc" id="L760">        final int SWITCH_COUNT            = 6;</span>

<span class="fc bfc" id="L762" title="All 2 branches covered.">        for (int methodIndex = 0; methodIndex != SWITCH_COUNT; ++methodIndex) {</span>
<span class="pc bpc" id="L763" title="1 of 4 branches missed.">            if (methodIndex == Do_getEncodedSource &amp;&amp; encodedSource == null) {</span>
<span class="nc" id="L764">                continue;</span>
            }

            // Generate:
            //   prologue;
            //   switch over function id to implement function-specific action
            //   epilogue

            short methodLocals;
<span class="pc bpc" id="L773" title="1 of 7 branches missed.">            switch (methodIndex) {</span>
              case Do_getFunctionName:
<span class="fc" id="L775">                methodLocals = 1; // Only this</span>
<span class="fc" id="L776">                cfw.startMethod(&quot;getFunctionName&quot;, &quot;()Ljava/lang/String;&quot;,</span>
                                ACC_PUBLIC);
<span class="fc" id="L778">                break;</span>
              case Do_getParamCount:
<span class="fc" id="L780">                methodLocals = 1; // Only this</span>
<span class="fc" id="L781">                cfw.startMethod(&quot;getParamCount&quot;, &quot;()I&quot;,</span>
                                ACC_PUBLIC);
<span class="fc" id="L783">                break;</span>
              case Do_getParamAndVarCount:
<span class="fc" id="L785">                methodLocals = 1; // Only this</span>
<span class="fc" id="L786">                cfw.startMethod(&quot;getParamAndVarCount&quot;, &quot;()I&quot;,</span>
                                ACC_PUBLIC);
<span class="fc" id="L788">                break;</span>
              case Do_getParamOrVarName:
<span class="fc" id="L790">                methodLocals = 1 + 1; // this + paramOrVarIndex</span>
<span class="fc" id="L791">                cfw.startMethod(&quot;getParamOrVarName&quot;, &quot;(I)Ljava/lang/String;&quot;,</span>
                                ACC_PUBLIC);
<span class="fc" id="L793">                break;</span>
              case Do_getParamOrVarConst:
<span class="fc" id="L795">                methodLocals = 1 + 1 + 1; // this + paramOrVarName</span>
<span class="fc" id="L796">                cfw.startMethod(&quot;getParamOrVarConst&quot;, &quot;(I)Z&quot;,</span>
                                ACC_PUBLIC);
<span class="fc" id="L798">                break;</span>
              case Do_getEncodedSource:
<span class="fc" id="L800">                methodLocals = 1; // Only this</span>
<span class="fc" id="L801">                cfw.startMethod(&quot;getEncodedSource&quot;, &quot;()Ljava/lang/String;&quot;,</span>
                                ACC_PUBLIC);
<span class="fc" id="L803">                cfw.addPush(encodedSource);</span>
<span class="fc" id="L804">                break;</span>
              default:
<span class="nc" id="L806">                throw Kit.codeBug();</span>
            }

<span class="fc" id="L809">            int count = scriptOrFnNodes.length;</span>

<span class="fc" id="L811">            int switchStart = 0;</span>
<span class="fc" id="L812">            int switchStackTop = 0;</span>
<span class="pc bpc" id="L813" title="1 of 2 branches missed.">            if (count &gt; 1) {</span>
                // Generate switch but only if there is more then one
                // script/function
<span class="nc" id="L816">                cfw.addLoadThis();</span>
<span class="nc" id="L817">                cfw.add(ByteCode.GETFIELD, cfw.getClassName(),</span>
                        ID_FIELD_NAME, &quot;I&quot;);

                // do switch from 1 .. count - 1 mapping 0 to the default case
<span class="nc" id="L821">                switchStart = cfw.addTableSwitch(1, count - 1);</span>
            }

<span class="fc bfc" id="L824" title="All 2 branches covered.">            for (int i = 0; i != count; ++i) {</span>
<span class="fc" id="L825">                ScriptNode n = scriptOrFnNodes[i];</span>
<span class="pc bpc" id="L826" title="1 of 2 branches missed.">                if (i == 0) {</span>
<span class="pc bpc" id="L827" title="1 of 2 branches missed.">                    if (count &gt; 1) {</span>
<span class="nc" id="L828">                        cfw.markTableSwitchDefault(switchStart);</span>
<span class="nc" id="L829">                        switchStackTop = cfw.getStackTop();</span>
                    }
                } else {
<span class="nc" id="L832">                    cfw.markTableSwitchCase(switchStart, i - 1,</span>
                                            switchStackTop);
                }

                // Impelemnet method-specific switch code
<span class="pc bpc" id="L837" title="1 of 7 branches missed.">                switch (methodIndex) {</span>
                  case Do_getFunctionName:
                    // Push function name
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">                    if (n.getType() == Token.SCRIPT) {</span>
<span class="fc" id="L841">                        cfw.addPush(&quot;&quot;);</span>
                    } else {
<span class="nc" id="L843">                        String name = ((FunctionNode)n).getName();</span>
<span class="nc" id="L844">                        cfw.addPush(name);</span>
                    }
<span class="fc" id="L846">                    cfw.add(ByteCode.ARETURN);</span>
<span class="fc" id="L847">                    break;</span>

                  case Do_getParamCount:
                    // Push number of defined parameters
<span class="fc" id="L851">                    cfw.addPush(n.getParamCount());</span>
<span class="fc" id="L852">                    cfw.add(ByteCode.IRETURN);</span>
<span class="fc" id="L853">                    break;</span>

                  case Do_getParamAndVarCount:
                    // Push number of defined parameters and declared variables
<span class="fc" id="L857">                    cfw.addPush(n.getParamAndVarCount());</span>
<span class="fc" id="L858">                    cfw.add(ByteCode.IRETURN);</span>
<span class="fc" id="L859">                    break;</span>

                  case Do_getParamOrVarName:
                    // Push name of parameter using another switch
                    // over paramAndVarCount
<span class="fc" id="L864">                    int paramAndVarCount = n.getParamAndVarCount();</span>
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">                    if (paramAndVarCount == 0) {</span>
                        // The runtime should never call the method in this
                        // case but to make bytecode verifier happy return null
                        // as throwing execption takes more code
<span class="fc" id="L869">                        cfw.add(ByteCode.ACONST_NULL);</span>
<span class="fc" id="L870">                        cfw.add(ByteCode.ARETURN);</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">                    } else if (paramAndVarCount == 1) {</span>
                        // As above do not check for valid index but always
                        // return the name of the first param
<span class="nc" id="L874">                        cfw.addPush(n.getParamOrVarName(0));</span>
<span class="nc" id="L875">                        cfw.add(ByteCode.ARETURN);</span>
                    } else {
                        // Do switch over getParamOrVarName
<span class="nc" id="L878">                        cfw.addILoad(1); // param or var index</span>
                        // do switch from 1 .. paramAndVarCount - 1 mapping 0
                        // to the default case
<span class="nc" id="L881">                        int paramSwitchStart = cfw.addTableSwitch(</span>
                                                   1, paramAndVarCount - 1);
<span class="nc bnc" id="L883" title="All 2 branches missed.">                        for (int j = 0; j != paramAndVarCount; ++j) {</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">                            if (cfw.getStackTop() != 0) Kit.codeBug();</span>
<span class="nc" id="L885">                            String s = n.getParamOrVarName(j);</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">                            if (j == 0) {</span>
<span class="nc" id="L887">                                cfw.markTableSwitchDefault(paramSwitchStart);</span>
                            } else {
<span class="nc" id="L889">                                cfw.markTableSwitchCase(paramSwitchStart, j - 1,</span>
                                                        0);
                            }
<span class="nc" id="L892">                            cfw.addPush(s);</span>
<span class="nc" id="L893">                            cfw.add(ByteCode.ARETURN);</span>
                        }
                    }
<span class="nc" id="L896">                    break;</span>

                    case Do_getParamOrVarConst:
                        // Push name of parameter using another switch
                        // over paramAndVarCount
<span class="fc" id="L901">                        paramAndVarCount = n.getParamAndVarCount();</span>
<span class="fc" id="L902">                        boolean [] constness = n.getParamAndVarConst();</span>
<span class="pc bpc" id="L903" title="1 of 2 branches missed.">                        if (paramAndVarCount == 0) {</span>
                            // The runtime should never call the method in this
                            // case but to make bytecode verifier happy return null
                            // as throwing execption takes more code
<span class="fc" id="L907">                            cfw.add(ByteCode.ICONST_0);</span>
<span class="fc" id="L908">                            cfw.add(ByteCode.IRETURN);</span>
<span class="nc bnc" id="L909" title="All 2 branches missed.">                        } else if (paramAndVarCount == 1) {</span>
                            // As above do not check for valid index but always
                            // return the name of the first param
<span class="nc" id="L912">                            cfw.addPush(constness[0]);</span>
<span class="nc" id="L913">                            cfw.add(ByteCode.IRETURN);</span>
                        } else {
                            // Do switch over getParamOrVarName
<span class="nc" id="L916">                            cfw.addILoad(1); // param or var index</span>
                            // do switch from 1 .. paramAndVarCount - 1 mapping 0
                            // to the default case
<span class="nc" id="L919">                            int paramSwitchStart = cfw.addTableSwitch(</span>
                                                       1, paramAndVarCount - 1);
<span class="nc bnc" id="L921" title="All 2 branches missed.">                            for (int j = 0; j != paramAndVarCount; ++j) {</span>
<span class="nc bnc" id="L922" title="All 2 branches missed.">                                if (cfw.getStackTop() != 0) Kit.codeBug();</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">                                if (j == 0) {</span>
<span class="nc" id="L924">                                    cfw.markTableSwitchDefault(paramSwitchStart);</span>
                                } else {
<span class="nc" id="L926">                                    cfw.markTableSwitchCase(paramSwitchStart, j - 1,</span>
                                                            0);
                                }
<span class="nc" id="L929">                                cfw.addPush(constness[j]);</span>
<span class="nc" id="L930">                                cfw.add(ByteCode.IRETURN);</span>
                            }
                        }
<span class="nc" id="L933">                      break;</span>

                  case Do_getEncodedSource:
                    // Push number encoded source start and end
                    // to prepare for encodedSource.substring(start, end)
<span class="fc" id="L938">                    cfw.addPush(n.getEncodedSourceStart());</span>
<span class="fc" id="L939">                    cfw.addPush(n.getEncodedSourceEnd());</span>
<span class="fc" id="L940">                    cfw.addInvoke(ByteCode.INVOKEVIRTUAL,</span>
                                  &quot;java/lang/String&quot;,
                                  &quot;substring&quot;,
                                  &quot;(II)Ljava/lang/String;&quot;);
<span class="fc" id="L944">                    cfw.add(ByteCode.ARETURN);</span>
<span class="fc" id="L945">                    break;</span>

                  default:
<span class="nc" id="L948">                    throw Kit.codeBug();</span>
                }
            }

<span class="fc" id="L952">            cfw.stopMethod(methodLocals);</span>
        }
<span class="fc" id="L954">    }</span>

    private void emitRegExpInit(ClassFileWriter cfw)
    {
        // precompile all regexp literals

<span class="fc" id="L960">        int totalRegCount = 0;</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">        for (int i = 0; i != scriptOrFnNodes.length; ++i) {</span>
<span class="fc" id="L962">            totalRegCount += scriptOrFnNodes[i].getRegexpCount();</span>
        }
<span class="fc bfc" id="L964" title="All 2 branches covered.">        if (totalRegCount == 0) {</span>
<span class="fc" id="L965">            return;</span>
        }

<span class="fc" id="L968">        cfw.startMethod(REGEXP_INIT_METHOD_NAME, REGEXP_INIT_METHOD_SIGNATURE,</span>
                (short)(ACC_STATIC | ACC_PRIVATE));
<span class="fc" id="L970">        cfw.addField(&quot;_reInitDone&quot;, &quot;Z&quot;,</span>
                     (short)(ACC_STATIC | ACC_PRIVATE | ACC_VOLATILE));
<span class="fc" id="L972">        cfw.add(ByteCode.GETSTATIC, mainClassName, &quot;_reInitDone&quot;, &quot;Z&quot;);</span>
<span class="fc" id="L973">        int doInit = cfw.acquireLabel();</span>
<span class="fc" id="L974">        cfw.add(ByteCode.IFEQ, doInit);</span>
<span class="fc" id="L975">        cfw.add(ByteCode.RETURN);</span>
<span class="fc" id="L976">        cfw.markLabel(doInit);</span>

        // get regexp proxy and store it in local slot 1
<span class="fc" id="L979">        cfw.addALoad(0); // context</span>
<span class="fc" id="L980">        cfw.addInvoke(ByteCode.INVOKESTATIC,</span>
                      &quot;org/mozilla/javascript/ScriptRuntime&quot;,
                      &quot;checkRegExpProxy&quot;,
                      &quot;(Lorg/mozilla/javascript/Context;&quot;
                      +&quot;)Lorg/mozilla/javascript/RegExpProxy;&quot;);
<span class="fc" id="L985">        cfw.addAStore(1); // proxy</span>

        // We could apply double-checked locking here but concurrency
        // shouldn't be a problem in practice
<span class="pc bpc" id="L989" title="1 of 2 branches missed.">        for (int i = 0; i != scriptOrFnNodes.length; ++i) {</span>
<span class="fc" id="L990">            ScriptNode n = scriptOrFnNodes[i];</span>
<span class="fc" id="L991">            int regCount = n.getRegexpCount();</span>
<span class="pc bpc" id="L992" title="1 of 2 branches missed.">            for (int j = 0; j != regCount; ++j) {</span>
<span class="fc" id="L993">                String reFieldName = getCompiledRegexpName(n, j);</span>
<span class="fc" id="L994">                String reFieldType = &quot;Ljava/lang/Object;&quot;;</span>
<span class="fc" id="L995">                String reString = n.getRegexpString(j);</span>
<span class="fc" id="L996">                String reFlags = n.getRegexpFlags(j);</span>
<span class="fc" id="L997">                cfw.addField(reFieldName, reFieldType,</span>
                             (short)(ACC_STATIC | ACC_PRIVATE));
<span class="fc" id="L999">                cfw.addALoad(1); // proxy</span>
<span class="fc" id="L1000">                cfw.addALoad(0); // context</span>
<span class="nc" id="L1001">                cfw.addPush(reString);</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">                if (reFlags == null) {</span>
<span class="nc" id="L1003">                    cfw.add(ByteCode.ACONST_NULL);</span>
                } else {
<span class="nc" id="L1005">                    cfw.addPush(reFlags);</span>
                }
<span class="nc" id="L1007">                cfw.addInvoke(ByteCode.INVOKEINTERFACE,</span>
                              &quot;org/mozilla/javascript/RegExpProxy&quot;,
                              &quot;compileRegExp&quot;,
                              &quot;(Lorg/mozilla/javascript/Context;&quot;
                              +&quot;Ljava/lang/String;Ljava/lang/String;&quot;
                              +&quot;)Ljava/lang/Object;&quot;);
<span class="nc" id="L1013">                cfw.add(ByteCode.PUTSTATIC, mainClassName,</span>
                        reFieldName, reFieldType);
            }
        }

<span class="nc" id="L1018">        cfw.addPush(1);</span>
<span class="nc" id="L1019">        cfw.add(ByteCode.PUTSTATIC, mainClassName, &quot;_reInitDone&quot;, &quot;Z&quot;);</span>
<span class="nc" id="L1020">        cfw.add(ByteCode.RETURN);</span>
<span class="nc" id="L1021">        cfw.stopMethod((short)2);</span>
<span class="nc" id="L1022">    }</span>

    private void emitConstantDudeInitializers(ClassFileWriter cfw)
    {
<span class="fc" id="L1026">        int N = itsConstantListSize;</span>
<span class="pc bpc" id="L1027" title="1 of 2 branches missed.">        if (N == 0)</span>
<span class="fc" id="L1028">            return;</span>

<span class="nc" id="L1030">        cfw.startMethod(&quot;&lt;clinit&gt;&quot;, &quot;()V&quot;, (short)(ACC_STATIC | ACC_FINAL));</span>

<span class="nc" id="L1032">        double[] array = itsConstantList;</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">        for (int i = 0; i != N; ++i) {</span>
<span class="nc" id="L1034">            double num = array[i];</span>
<span class="nc" id="L1035">            String constantName = &quot;_k&quot; + i;</span>
<span class="nc" id="L1036">            String constantType = getStaticConstantWrapperType(num);</span>
<span class="nc" id="L1037">            cfw.addField(constantName, constantType,</span>
                        (short)(ACC_STATIC | ACC_PRIVATE));
<span class="nc" id="L1039">            int inum = (int)num;</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">            if (inum == num) {</span>
<span class="nc" id="L1041">                cfw.addPush(inum);</span>
<span class="nc" id="L1042">                cfw.addInvoke(ByteCode.INVOKESTATIC, &quot;java/lang/Integer&quot;,</span>
                              &quot;valueOf&quot;, &quot;(I)Ljava/lang/Integer;&quot;);
            } else {
<span class="nc" id="L1045">                cfw.addPush(num);</span>
<span class="nc" id="L1046">                addDoubleWrap(cfw);</span>
            }
<span class="nc" id="L1048">            cfw.add(ByteCode.PUTSTATIC, mainClassName,</span>
                    constantName, constantType);
        }

<span class="nc" id="L1052">        cfw.add(ByteCode.RETURN);</span>
<span class="nc" id="L1053">        cfw.stopMethod((short)0);</span>
<span class="nc" id="L1054">    }</span>

    void pushNumberAsObject(ClassFileWriter cfw, double num)
    {
<span class="fc bfc" id="L1058" title="All 2 branches covered.">        if (num == 0.0) {</span>
<span class="pc bpc" id="L1059" title="1 of 2 branches missed.">            if (1 / num &gt; 0) {</span>
                // +0.0
<span class="nc" id="L1061">                cfw.add(ByteCode.GETSTATIC,</span>
                        &quot;org/mozilla/javascript/optimizer/OptRuntime&quot;,
                        &quot;zeroObj&quot;, &quot;Ljava/lang/Double;&quot;);
            } else {
<span class="nc" id="L1065">                cfw.addPush(num);</span>
<span class="nc" id="L1066">                addDoubleWrap(cfw);</span>
            }

<span class="fc bfc" id="L1069" title="All 2 branches covered.">        } else if (num == 1.0) {</span>
<span class="fc" id="L1070">            cfw.add(ByteCode.GETSTATIC,</span>
                    &quot;org/mozilla/javascript/optimizer/OptRuntime&quot;,
                    &quot;oneObj&quot;, &quot;Ljava/lang/Double;&quot;);
<span class="fc" id="L1073">            return;</span>

<span class="fc bfc" id="L1075" title="All 2 branches covered.">        } else if (num == -1.0) {</span>
<span class="nc" id="L1076">            cfw.add(ByteCode.GETSTATIC,</span>
                    &quot;org/mozilla/javascript/optimizer/OptRuntime&quot;,
                    &quot;minusOneObj&quot;, &quot;Ljava/lang/Double;&quot;);

<span class="pc bpc" id="L1080" title="1 of 2 branches missed.">        } else if (num != num) {</span>
<span class="nc" id="L1081">            cfw.add(ByteCode.GETSTATIC,</span>
                    &quot;org/mozilla/javascript/ScriptRuntime&quot;,
                    &quot;NaNobj&quot;, &quot;Ljava/lang/Double;&quot;);

<span class="pc bpc" id="L1085" title="1 of 2 branches missed.">        } else if (itsConstantListSize &gt;= 2000) {</span>
            // There appears to be a limit in the JVM on either the number
            // of static fields in a class or the size of the class
            // initializer. Either way, we can't have any more than 2000
            // statically init'd constants.
<span class="nc" id="L1090">            cfw.addPush(num);</span>
<span class="nc" id="L1091">            addDoubleWrap(cfw);</span>

        } else {
<span class="fc" id="L1094">            int N = itsConstantListSize;</span>
<span class="fc" id="L1095">            int index = 0;</span>
<span class="pc bpc" id="L1096" title="1 of 2 branches missed.">            if (N == 0) {</span>
<span class="fc" id="L1097">                itsConstantList = new double[64];</span>
            } else {
<span class="nc" id="L1099">                double[] array = itsConstantList;</span>
<span class="nc bnc" id="L1100" title="All 4 branches missed.">                while (index != N &amp;&amp; array[index] != num) {</span>
<span class="nc" id="L1101">                    ++index;</span>
                }
<span class="nc bnc" id="L1103" title="All 2 branches missed.">                if (N == array.length) {</span>
<span class="nc" id="L1104">                    array = new double[N * 2];</span>
<span class="nc" id="L1105">                    System.arraycopy(itsConstantList, 0, array, 0, N);</span>
<span class="nc" id="L1106">                    itsConstantList = array;</span>
                }
            }
<span class="pc bpc" id="L1109" title="1 of 2 branches missed.">            if (index == N) {</span>
<span class="fc" id="L1110">                itsConstantList[N] = num;</span>
<span class="fc" id="L1111">                itsConstantListSize = N + 1;</span>
            }
<span class="fc" id="L1113">            String constantName = &quot;_k&quot; + index;</span>
<span class="fc" id="L1114">            String constantType = getStaticConstantWrapperType(num);</span>
<span class="nc" id="L1115">            cfw.add(ByteCode.GETSTATIC, mainClassName,</span>
                    constantName, constantType);
        }
<span class="nc" id="L1118">    }</span>

    private static void addDoubleWrap(ClassFileWriter cfw)
    {
<span class="nc" id="L1122">        cfw.addInvoke(ByteCode.INVOKESTATIC,</span>
                      &quot;org/mozilla/javascript/optimizer/OptRuntime&quot;,
                      &quot;wrapDouble&quot;, &quot;(D)Ljava/lang/Double;&quot;);
<span class="nc" id="L1125">    }</span>

    private static String getStaticConstantWrapperType(double num)
    {
<span class="fc" id="L1129">        int inum = (int)num;</span>
<span class="pc bpc" id="L1130" title="1 of 2 branches missed.">        if (inum == num) {</span>
<span class="nc" id="L1131">            return &quot;Ljava/lang/Integer;&quot;;</span>
        } else {
<span class="fc" id="L1133">            return &quot;Ljava/lang/Double;&quot;;</span>
        }
    }
    static void pushUndefined(ClassFileWriter cfw)
    {
<span class="fc" id="L1138">        cfw.add(ByteCode.GETSTATIC, &quot;org/mozilla/javascript/Undefined&quot;,</span>
                &quot;instance&quot;, &quot;Ljava/lang/Object;&quot;);
<span class="fc" id="L1140">    }</span>

    int getIndex(ScriptNode n)
    {
<span class="fc" id="L1144">        return scriptOrFnIndexes.getExisting(n);</span>
    }

    String getDirectCtorName(ScriptNode n)
    {
<span class="nc" id="L1149">        return &quot;_n&quot; + getIndex(n);</span>
    }

    String getBodyMethodName(ScriptNode n)
    {
<span class="fc" id="L1154">        return &quot;_c_&quot; + cleanName(n) + &quot;_&quot; + getIndex(n);</span>
    }

    /**
     * Gets a Java-compatible &quot;informative&quot; name for the the ScriptOrFnNode
     */
    String cleanName(final ScriptNode n)
    {
<span class="fc" id="L1162">      String result = &quot;&quot;;</span>
<span class="fc bfc" id="L1163" title="All 2 branches covered.">      if (n instanceof FunctionNode) {</span>
<span class="fc" id="L1164">        Name name = ((FunctionNode) n).getFunctionName();</span>
<span class="fc bfc" id="L1165" title="All 2 branches covered.">        if (name == null) {</span>
<span class="fc" id="L1166">          result = &quot;anonymous&quot;;</span>
        } else {
<span class="fc" id="L1168">          result = name.getIdentifier();</span>
        }
<span class="fc" id="L1170">      } else {</span>
<span class="fc" id="L1171">        result = &quot;script&quot;;</span>
      }
<span class="fc" id="L1173">      return result;</span>
    }

    String getBodyMethodSignature(ScriptNode n)
    {
<span class="fc" id="L1178">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L1179">        sb.append('(');</span>
<span class="fc" id="L1180">        sb.append(mainClassSignature);</span>
<span class="fc" id="L1181">        sb.append(&quot;Lorg/mozilla/javascript/Context;&quot;</span>
                  +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                  +&quot;Lorg/mozilla/javascript/Scriptable;&quot;);
<span class="fc bfc" id="L1184" title="All 2 branches covered.">        if (n.getType() == Token.FUNCTION) {</span>
<span class="fc" id="L1185">            OptFunctionNode ofn = OptFunctionNode.get(n);</span>
<span class="nc bnc" id="L1186" title="All 2 branches missed.">            if (ofn.isTargetOfDirectCall()) {</span>
<span class="nc" id="L1187">                int pCount = ofn.fnode.getParamCount();</span>
<span class="nc bnc" id="L1188" title="All 2 branches missed.">                for (int i = 0; i != pCount; i++) {</span>
<span class="nc" id="L1189">                    sb.append(&quot;Ljava/lang/Object;D&quot;);</span>
                }
            }
        }
<span class="fc" id="L1193">        sb.append(&quot;[Ljava/lang/Object;)Ljava/lang/Object;&quot;);</span>
<span class="fc" id="L1194">        return sb.toString();</span>
    }

    String getFunctionInitMethodName(OptFunctionNode ofn)
    {
<span class="nc" id="L1199">        return &quot;_i&quot;+getIndex(ofn.fnode);</span>
    }

    String getCompiledRegexpName(ScriptNode n, int regexpIndex)
    {
<span class="fc" id="L1204">        return &quot;_re&quot;+getIndex(n)+&quot;_&quot;+regexpIndex;</span>
    }

    static RuntimeException badTree()
    {
<span class="fc" id="L1209">        throw new RuntimeException(&quot;Bad tree in codegen&quot;);</span>
    }

     public void setMainMethodClass(String className)
     {
<span class="fc" id="L1214">         mainMethodClass = className;</span>
<span class="fc" id="L1215">     }</span>

     static final String DEFAULT_MAIN_METHOD_CLASS
        = &quot;org.mozilla.javascript.optimizer.OptRuntime&quot;;

    private static final String SUPER_CLASS_NAME
        = &quot;org.mozilla.javascript.NativeFunction&quot;;

    static final String ID_FIELD_NAME = &quot;_id&quot;;

    static final String REGEXP_INIT_METHOD_NAME = &quot;_reInit&quot;;
    static final String REGEXP_INIT_METHOD_SIGNATURE
        =  &quot;(Lorg/mozilla/javascript/Context;)V&quot;;

    static final String FUNCTION_INIT_SIGNATURE
        =  &quot;(Lorg/mozilla/javascript/Context;&quot;
           +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
           +&quot;)V&quot;;

   static final String FUNCTION_CONSTRUCTOR_SIGNATURE
        = &quot;(Lorg/mozilla/javascript/Scriptable;&quot;
          +&quot;Lorg/mozilla/javascript/Context;I)V&quot;;

<span class="fc" id="L1238">    private static final Object globalLock = new Object();</span>
    private static int globalSerialClassCounter;

    private CompilerEnvirons compilerEnv;

    private ObjArray directCallTargets;
    ScriptNode[] scriptOrFnNodes;
    private ObjToIntMap scriptOrFnIndexes;

<span class="fc" id="L1247">    private String mainMethodClass = DEFAULT_MAIN_METHOD_CLASS;</span>

    String mainClassName;
    String mainClassSignature;

    private double[] itsConstantList;
    private int itsConstantListSize;
}


<span class="pc bpc" id="L1257" title="1 of 2 branches missed.">class BodyCodegen</span>
{
    void generateBodyCode()
    {
<span class="fc" id="L1261">        isGenerator = Codegen.isGenerator(scriptOrFn);</span>

        // generate the body of the current function or script object
<span class="fc" id="L1264">        initBodyGeneration();</span>

<span class="pc bpc" id="L1266" title="1 of 2 branches missed.">        if (isGenerator) {</span>

            // All functions in the generated bytecode have a unique name. Every
            // generator has a unique prefix followed by _gen
<span class="nc" id="L1270">            String type = &quot;(&quot; +</span>
                          codegen.mainClassSignature +
                          &quot;Lorg/mozilla/javascript/Context;&quot; +
                          &quot;Lorg/mozilla/javascript/Scriptable;&quot; +
                          &quot;Ljava/lang/Object;&quot; +
                          &quot;Ljava/lang/Object;I)Ljava/lang/Object;&quot;;
<span class="nc" id="L1276">            cfw.startMethod(codegen.getBodyMethodName(scriptOrFn) + &quot;_gen&quot;,</span>
                    type,
                    (short)(ACC_STATIC | ACC_PRIVATE));
<span class="nc" id="L1279">        } else {</span>
<span class="fc" id="L1280">            cfw.startMethod(codegen.getBodyMethodName(scriptOrFn),</span>
<span class="fc" id="L1281">                    codegen.getBodyMethodSignature(scriptOrFn),</span>
                    (short)(ACC_STATIC | ACC_PRIVATE));
        }

<span class="fc" id="L1285">        generatePrologue();</span>
        Node treeTop;
<span class="pc bpc" id="L1287" title="1 of 2 branches missed.">        if (fnCurrent != null) {</span>
<span class="nc" id="L1288">            treeTop = scriptOrFn.getLastChild();</span>
        } else {
<span class="fc" id="L1290">            treeTop = scriptOrFn;</span>
        }
<span class="fc" id="L1292">        generateStatement(treeTop);</span>
<span class="fc" id="L1293">        generateEpilogue();</span>

<span class="fc" id="L1295">        cfw.stopMethod((short)(localsMax + 1));</span>

<span class="pc bpc" id="L1297" title="1 of 2 branches missed.">        if (isGenerator) {</span>
            // generate the user visible method which when invoked will
            // return a generator object
<span class="nc" id="L1300">            generateGenerator();</span>
        }

<span class="pc bpc" id="L1303" title="1 of 2 branches missed.">        if (literals != null) {</span>
            // literals list may grow while we're looping
<span class="nc bnc" id="L1305" title="All 2 branches missed.">            for (int i = 0; i &lt; literals.size(); i++) {</span>
<span class="nc" id="L1306">                Node node = literals.get(i);</span>
<span class="nc" id="L1307">                int type = node.getType();</span>
<span class="nc bnc" id="L1308" title="All 3 branches missed.">                switch (type) {</span>
                    case Token.OBJECTLIT:
<span class="nc" id="L1310">                        generateObjectLiteralFactory(node, i + 1);</span>
<span class="nc" id="L1311">                        break;</span>
                    case Token.ARRAYLIT:
<span class="nc" id="L1313">                        generateArrayLiteralFactory(node, i + 1);</span>
<span class="nc" id="L1314">                        break;</span>
                    default:
<span class="nc" id="L1316">                        Kit.codeBug(Token.typeToName(type));</span>
                }
            }
        }

<span class="fc" id="L1321">    }</span>

    // This creates a the user-facing function that returns a NativeGenerator
    // object.
    private void generateGenerator()
    {
<span class="nc" id="L1327">        cfw.startMethod(codegen.getBodyMethodName(scriptOrFn),</span>
<span class="nc" id="L1328">                        codegen.getBodyMethodSignature(scriptOrFn),</span>
                        (short)(ACC_STATIC | ACC_PRIVATE));

<span class="nc" id="L1331">        initBodyGeneration();</span>
<span class="nc" id="L1332">        argsLocal = firstFreeLocal++;</span>
<span class="nc" id="L1333">        localsMax = firstFreeLocal;</span>

        // get top level scope
<span class="nc bnc" id="L1336" title="All 2 branches missed.">        if (fnCurrent != null)</span>
        {
            // Unless we're in a direct call use the enclosing scope
            // of the function as our variable object.
<span class="nc" id="L1340">            cfw.addALoad(funObjLocal);</span>
<span class="nc" id="L1341">            cfw.addInvoke(ByteCode.INVOKEINTERFACE,</span>
                          &quot;org/mozilla/javascript/Scriptable&quot;,
                          &quot;getParentScope&quot;,
                          &quot;()Lorg/mozilla/javascript/Scriptable;&quot;);
<span class="nc" id="L1345">            cfw.addAStore(variableObjectLocal);</span>
        }

        // generators are forced to have an activation record
<span class="nc" id="L1349">        cfw.addALoad(funObjLocal);</span>
<span class="nc" id="L1350">        cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L1351">        cfw.addALoad(argsLocal);</span>
<span class="nc" id="L1352">        cfw.addPush(scriptOrFn.isInStrictMode());</span>
<span class="nc" id="L1353">        addScriptRuntimeInvoke(&quot;createFunctionActivation&quot;,</span>
                               &quot;(Lorg/mozilla/javascript/NativeFunction;&quot;
                               +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                               +&quot;[Ljava/lang/Object;&quot;
                               +&quot;Z&quot;
                               +&quot;)Lorg/mozilla/javascript/Scriptable;&quot;);
<span class="nc" id="L1359">        cfw.addAStore(variableObjectLocal);</span>

        // create a function object
<span class="nc" id="L1362">        cfw.add(ByteCode.NEW, codegen.mainClassName);</span>
        // Call function constructor
<span class="nc" id="L1364">        cfw.add(ByteCode.DUP);</span>
<span class="nc" id="L1365">        cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L1366">        cfw.addALoad(contextLocal);           // load 'cx'</span>
<span class="nc" id="L1367">        cfw.addPush(scriptOrFnIndex);</span>
<span class="nc" id="L1368">        cfw.addInvoke(ByteCode.INVOKESPECIAL, codegen.mainClassName,</span>
                      &quot;&lt;init&gt;&quot;, Codegen.FUNCTION_CONSTRUCTOR_SIGNATURE);

<span class="nc" id="L1371">        generateNestedFunctionInits();</span>

        // create the NativeGenerator object that we return
<span class="nc" id="L1374">        cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L1375">        cfw.addALoad(thisObjLocal);</span>
<span class="nc" id="L1376">        cfw.addLoadConstant(maxLocals);</span>
<span class="nc" id="L1377">        cfw.addLoadConstant(maxStack);</span>
<span class="nc" id="L1378">        addOptRuntimeInvoke(&quot;createNativeGenerator&quot;,</span>
                               &quot;(Lorg/mozilla/javascript/NativeFunction;&quot;
                               +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                               +&quot;Lorg/mozilla/javascript/Scriptable;II&quot;
                               +&quot;)Lorg/mozilla/javascript/Scriptable;&quot;);

<span class="nc" id="L1384">        cfw.add(ByteCode.ARETURN);</span>
<span class="nc" id="L1385">        cfw.stopMethod((short)(localsMax + 1));</span>
<span class="nc" id="L1386">    }</span>

    private void generateNestedFunctionInits()
    {
<span class="fc" id="L1390">        int functionCount = scriptOrFn.getFunctionCount();</span>
<span class="pc bpc" id="L1391" title="1 of 2 branches missed.">        for (int i = 0; i != functionCount; i++) {</span>
<span class="nc" id="L1392">            OptFunctionNode ofn = OptFunctionNode.get(scriptOrFn, i);</span>
<span class="nc bnc" id="L1393" title="All 2 branches missed.">            if (ofn.fnode.getFunctionType()</span>
                    == FunctionNode.FUNCTION_STATEMENT)
            {
<span class="nc" id="L1396">                visitFunction(ofn, FunctionNode.FUNCTION_STATEMENT);</span>
            }
        }
<span class="fc" id="L1399">    }</span>

    private void initBodyGeneration()
    {
<span class="fc" id="L1403">        varRegisters = null;</span>
<span class="fc bfc" id="L1404" title="All 2 branches covered.">        if (scriptOrFn.getType() == Token.FUNCTION) {</span>
<span class="fc" id="L1405">            fnCurrent = OptFunctionNode.get(scriptOrFn);</span>
<span class="nc bnc" id="L1406" title="All 2 branches missed.">            hasVarsInRegs = !fnCurrent.fnode.requiresActivation();</span>
<span class="nc bnc" id="L1407" title="All 2 branches missed.">            if (hasVarsInRegs) {</span>
<span class="nc" id="L1408">                int n = fnCurrent.fnode.getParamAndVarCount();</span>
<span class="nc bnc" id="L1409" title="All 2 branches missed.">                if (n != 0) {</span>
<span class="nc" id="L1410">                    varRegisters = new short[n];</span>
                }
            }
<span class="nc" id="L1413">            inDirectCallFunction = fnCurrent.isTargetOfDirectCall();</span>
<span class="nc bnc" id="L1414" title="All 4 branches missed.">            if (inDirectCallFunction &amp;&amp; !hasVarsInRegs) Codegen.badTree();</span>
        } else {
<span class="fc" id="L1416">            fnCurrent = null;</span>
<span class="fc" id="L1417">            hasVarsInRegs = false;</span>
<span class="fc" id="L1418">            inDirectCallFunction = false;</span>
        }

<span class="fc" id="L1421">        locals = new int[MAX_LOCALS];</span>

<span class="fc" id="L1423">        funObjLocal = 0;</span>
<span class="fc" id="L1424">        contextLocal = 1;</span>
<span class="fc" id="L1425">        variableObjectLocal = 2;</span>
<span class="fc" id="L1426">        thisObjLocal = 3;</span>
<span class="fc" id="L1427">        localsMax = (short) 4;  // number of parms + &quot;this&quot;</span>
<span class="fc" id="L1428">        firstFreeLocal = 4;</span>

<span class="fc" id="L1430">        popvLocal = -1;</span>
<span class="fc" id="L1431">        argsLocal = -1;</span>
<span class="fc" id="L1432">        itsZeroArgArray = -1;</span>
<span class="fc" id="L1433">        itsOneArgArray = -1;</span>
<span class="fc" id="L1434">        epilogueLabel = -1;</span>
<span class="fc" id="L1435">        enterAreaStartLabel = -1;</span>
<span class="fc" id="L1436">        generatorStateLocal = -1;</span>
<span class="fc" id="L1437">    }</span>

    /**
     * Generate the prologue for a function or script.
     */
    private void generatePrologue()
    {
<span class="pc bpc" id="L1444" title="1 of 2 branches missed.">        if (inDirectCallFunction) {</span>
<span class="nc" id="L1445">            int directParameterCount = scriptOrFn.getParamCount();</span>
            // 0 is reserved for function Object 'this'
            // 1 is reserved for context
            // 2 is reserved for parentScope
            // 3 is reserved for script 'this'
<span class="nc bnc" id="L1450" title="All 2 branches missed.">            if (firstFreeLocal != 4) Kit.codeBug();</span>
<span class="nc bnc" id="L1451" title="All 2 branches missed.">            for (int i = 0; i != directParameterCount; ++i) {</span>
<span class="nc" id="L1452">                varRegisters[i] = firstFreeLocal;</span>
                // 3 is 1 for Object parm and 2 for double parm
<span class="nc" id="L1454">                firstFreeLocal += 3;</span>
            }
<span class="nc bnc" id="L1456" title="All 2 branches missed.">            if (!fnCurrent.getParameterNumberContext()) {</span>
                // make sure that all parameters are objects
<span class="nc" id="L1458">                itsForcedObjectParameters = true;</span>
<span class="nc bnc" id="L1459" title="All 2 branches missed.">                for (int i = 0; i != directParameterCount; ++i) {</span>
<span class="nc" id="L1460">                    short reg = varRegisters[i];</span>
<span class="nc" id="L1461">                    cfw.addALoad(reg);</span>
<span class="nc" id="L1462">                    cfw.add(ByteCode.GETSTATIC,</span>
                            &quot;java/lang/Void&quot;,
                            &quot;TYPE&quot;,
                            &quot;Ljava/lang/Class;&quot;);
<span class="nc" id="L1466">                    int isObjectLabel = cfw.acquireLabel();</span>
<span class="nc" id="L1467">                    cfw.add(ByteCode.IF_ACMPNE, isObjectLabel);</span>
<span class="nc" id="L1468">                    cfw.addDLoad(reg + 1);</span>
<span class="nc" id="L1469">                    addDoubleWrap();</span>
<span class="nc" id="L1470">                    cfw.addAStore(reg);</span>
<span class="nc" id="L1471">                    cfw.markLabel(isObjectLabel);</span>
                }
            }
        }

<span class="pc bpc" id="L1476" title="1 of 2 branches missed.">        if (fnCurrent != null) {</span>
            // Use the enclosing scope of the function as our variable object.
<span class="nc" id="L1478">            cfw.addALoad(funObjLocal);</span>
<span class="nc" id="L1479">            cfw.addInvoke(ByteCode.INVOKEINTERFACE,</span>
                          &quot;org/mozilla/javascript/Scriptable&quot;,
                          &quot;getParentScope&quot;,
                          &quot;()Lorg/mozilla/javascript/Scriptable;&quot;);
<span class="nc" id="L1483">            cfw.addAStore(variableObjectLocal);</span>
        }

        // reserve 'args[]'
<span class="fc" id="L1487">        argsLocal = firstFreeLocal++;</span>
<span class="fc" id="L1488">        localsMax = firstFreeLocal;</span>

        // Generate Generator specific prelude
<span class="pc bpc" id="L1491" title="1 of 2 branches missed.">        if (isGenerator) {</span>

            // reserve 'args[]'
<span class="nc" id="L1494">            operationLocal = firstFreeLocal++;</span>
<span class="nc" id="L1495">            localsMax = firstFreeLocal;</span>

            // Local 3 is a reference to a GeneratorState object. The rest
            // of codegen expects local 3 to be a reference to the thisObj.
            // So move the value in local 3 to generatorStateLocal, and load
            // the saved thisObj from the GeneratorState object.
<span class="nc" id="L1501">            cfw.addALoad(thisObjLocal);</span>
<span class="nc" id="L1502">            generatorStateLocal = firstFreeLocal++;</span>
<span class="nc" id="L1503">            localsMax = firstFreeLocal;</span>
<span class="nc" id="L1504">            cfw.add(ByteCode.CHECKCAST, OptRuntime.GeneratorState.CLASS_NAME);</span>
<span class="nc" id="L1505">            cfw.add(ByteCode.DUP);</span>
<span class="nc" id="L1506">            cfw.addAStore(generatorStateLocal);</span>
<span class="nc" id="L1507">            cfw.add(ByteCode.GETFIELD,</span>
                    OptRuntime.GeneratorState.CLASS_NAME,
                    OptRuntime.GeneratorState.thisObj_NAME,
                    OptRuntime.GeneratorState.thisObj_TYPE);
<span class="nc" id="L1511">            cfw.addAStore(thisObjLocal);</span>

<span class="nc bnc" id="L1513" title="All 2 branches missed.">            if (epilogueLabel == -1) {</span>
<span class="nc" id="L1514">                epilogueLabel = cfw.acquireLabel();</span>
            }

<span class="nc" id="L1517">            List&lt;Node&gt; targets = ((FunctionNode)scriptOrFn).getResumptionPoints();</span>
<span class="nc bnc" id="L1518" title="All 2 branches missed.">            if (targets != null) {</span>
                // get resumption point
<span class="nc" id="L1520">                generateGetGeneratorResumptionPoint();</span>

                // generate dispatch table
<span class="nc" id="L1523">                generatorSwitch = cfw.addTableSwitch(0,</span>
<span class="nc" id="L1524">                    targets.size() + GENERATOR_START);</span>
<span class="nc" id="L1525">                generateCheckForThrowOrClose(-1, false, GENERATOR_START);</span>
            }
        }

        // Compile RegExp literals if this is a script. For functions
        // this is performed during instantiation in functionInit
<span class="pc bpc" id="L1531" title="1 of 4 branches missed.">        if (fnCurrent == null &amp;&amp; scriptOrFn.getRegexpCount() != 0) {</span>
<span class="fc" id="L1532">            cfw.addALoad(contextLocal);</span>
<span class="fc" id="L1533">            cfw.addInvoke(ByteCode.INVOKESTATIC, codegen.mainClassName,</span>
                          Codegen.REGEXP_INIT_METHOD_NAME,
                          Codegen.REGEXP_INIT_METHOD_SIGNATURE);
        }

<span class="fc bfc" id="L1538" title="All 2 branches covered.">        if (compilerEnv.isGenerateObserverCount())</span>
<span class="fc" id="L1539">            saveCurrentCodeOffset();</span>

<span class="pc bpc" id="L1541" title="1 of 2 branches missed.">        if (hasVarsInRegs) {</span>
            // No need to create activation. Pad arguments if need be.
<span class="nc" id="L1543">            int parmCount = scriptOrFn.getParamCount();</span>
<span class="nc bnc" id="L1544" title="All 4 branches missed.">            if (parmCount &gt; 0 &amp;&amp; !inDirectCallFunction) {</span>
                // Set up args array
                // check length of arguments, pad if need be
<span class="nc" id="L1547">                cfw.addALoad(argsLocal);</span>
<span class="nc" id="L1548">                cfw.add(ByteCode.ARRAYLENGTH);</span>
<span class="nc" id="L1549">                cfw.addPush(parmCount);</span>
<span class="nc" id="L1550">                int label = cfw.acquireLabel();</span>
<span class="nc" id="L1551">                cfw.add(ByteCode.IF_ICMPGE, label);</span>
<span class="nc" id="L1552">                cfw.addALoad(argsLocal);</span>
<span class="nc" id="L1553">                cfw.addPush(parmCount);</span>
<span class="nc" id="L1554">                addScriptRuntimeInvoke(&quot;padArguments&quot;,</span>
                                       &quot;([Ljava/lang/Object;I&quot;
                                       +&quot;)[Ljava/lang/Object;&quot;);
<span class="nc" id="L1557">                cfw.addAStore(argsLocal);</span>
<span class="nc" id="L1558">                cfw.markLabel(label);</span>
            }

<span class="nc" id="L1561">            int paramCount = fnCurrent.fnode.getParamCount();</span>
<span class="nc" id="L1562">            int varCount = fnCurrent.fnode.getParamAndVarCount();</span>
<span class="nc" id="L1563">            boolean [] constDeclarations = fnCurrent.fnode.getParamAndVarConst();</span>

            // REMIND - only need to initialize the vars that don't get a value
            // before the next call and are used in the function
<span class="nc" id="L1567">            short firstUndefVar = -1;</span>
<span class="nc bnc" id="L1568" title="All 2 branches missed.">            for (int i = 0; i != varCount; ++i) {</span>
<span class="nc" id="L1569">                short reg = -1;</span>
<span class="nc bnc" id="L1570" title="All 2 branches missed.">                if (i &lt; paramCount) {</span>
<span class="nc bnc" id="L1571" title="All 2 branches missed.">                    if (!inDirectCallFunction) {</span>
<span class="nc" id="L1572">                        reg = getNewWordLocal();</span>
<span class="nc" id="L1573">                        cfw.addALoad(argsLocal);</span>
<span class="nc" id="L1574">                        cfw.addPush(i);</span>
<span class="nc" id="L1575">                        cfw.add(ByteCode.AALOAD);</span>
<span class="nc" id="L1576">                        cfw.addAStore(reg);</span>
                    }
<span class="nc bnc" id="L1578" title="All 2 branches missed.">                } else if (fnCurrent.isNumberVar(i)) {</span>
<span class="nc" id="L1579">                    reg = getNewWordPairLocal(constDeclarations[i]);</span>
<span class="nc" id="L1580">                    cfw.addPush(0.0);</span>
<span class="nc" id="L1581">                    cfw.addDStore(reg);</span>
                } else {
<span class="nc" id="L1583">                    reg = getNewWordLocal(constDeclarations[i]);</span>
<span class="nc bnc" id="L1584" title="All 2 branches missed.">                    if (firstUndefVar == -1) {</span>
<span class="nc" id="L1585">                        Codegen.pushUndefined(cfw);</span>
<span class="nc" id="L1586">                        firstUndefVar = reg;</span>
                    } else {
<span class="nc" id="L1588">                        cfw.addALoad(firstUndefVar);</span>
                    }
<span class="nc" id="L1590">                    cfw.addAStore(reg);</span>
                }
<span class="nc bnc" id="L1592" title="All 2 branches missed.">                if (reg &gt;= 0) {</span>
<span class="nc bnc" id="L1593" title="All 2 branches missed.">                    if (constDeclarations[i]) {</span>
<span class="nc" id="L1594">                        cfw.addPush(0);</span>
<span class="nc bnc" id="L1595" title="All 2 branches missed.">                        cfw.addIStore(reg + (fnCurrent.isNumberVar(i) ? 2 : 1));</span>
                    }
<span class="nc" id="L1597">                    varRegisters[i] = reg;</span>
                }

                // Add debug table entry if we're generating debug info
<span class="nc bnc" id="L1601" title="All 2 branches missed.">                if (compilerEnv.isGenerateDebugInfo()) {</span>
<span class="nc" id="L1602">                    String name = fnCurrent.fnode.getParamOrVarName(i);</span>
<span class="nc bnc" id="L1603" title="All 2 branches missed.">                    String type = fnCurrent.isNumberVar(i)</span>
                                      ? &quot;D&quot; : &quot;Ljava/lang/Object;&quot;;
<span class="nc" id="L1605">                    int startPC = cfw.getCurrentCodeOffset();</span>
<span class="nc bnc" id="L1606" title="All 2 branches missed.">                    if (reg &lt; 0) {</span>
<span class="nc" id="L1607">                        reg = varRegisters[i];</span>
                    }
<span class="nc" id="L1609">                    cfw.addVariableDescriptor(name, type, startPC, reg);</span>
                }
            }

            // Skip creating activation object.
<span class="nc" id="L1614">            return;</span>
        }

        // skip creating activation object for the body of a generator. The
        // activation record required by a generator has already been created
        // in generateGenerator().
<span class="pc bpc" id="L1620" title="1 of 2 branches missed.">        if (isGenerator)</span>
<span class="nc" id="L1621">            return;</span>


        String debugVariableName;
<span class="fc" id="L1625">        boolean isArrow = false;</span>
<span class="pc bpc" id="L1626" title="1 of 2 branches missed.">        if (scriptOrFn instanceof FunctionNode) {</span>
<span class="nc bnc" id="L1627" title="All 2 branches missed.">            isArrow = ((FunctionNode)scriptOrFn).getFunctionType() == FunctionNode.ARROW_FUNCTION;</span>
        }
<span class="pc bpc" id="L1629" title="1 of 2 branches missed.">        if (fnCurrent != null) {</span>
<span class="nc" id="L1630">            debugVariableName = &quot;activation&quot;;</span>
<span class="nc" id="L1631">            cfw.addALoad(funObjLocal);</span>
<span class="nc" id="L1632">            cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L1633">            cfw.addALoad(argsLocal);</span>
<span class="nc bnc" id="L1634" title="All 2 branches missed.">            String methodName = isArrow ? &quot;createArrowFunctionActivation&quot; : &quot;createFunctionActivation&quot;;</span>
<span class="nc" id="L1635">            cfw.addPush(scriptOrFn.isInStrictMode());</span>
<span class="nc" id="L1636">            addScriptRuntimeInvoke(methodName,</span>
                                   &quot;(Lorg/mozilla/javascript/NativeFunction;&quot;
                                   +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                                   +&quot;[Ljava/lang/Object;&quot;
                                   +&quot;Z&quot;
                                   +&quot;)Lorg/mozilla/javascript/Scriptable;&quot;);
<span class="nc" id="L1642">            cfw.addAStore(variableObjectLocal);</span>
<span class="nc" id="L1643">            cfw.addALoad(contextLocal);</span>
<span class="nc" id="L1644">            cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L1645">            addScriptRuntimeInvoke(&quot;enterActivationFunction&quot;,</span>
                                   &quot;(Lorg/mozilla/javascript/Context;&quot;
                                   +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                                   +&quot;)V&quot;);
<span class="nc" id="L1649">        } else {</span>
<span class="fc" id="L1650">            debugVariableName = &quot;global&quot;;</span>
<span class="fc" id="L1651">            cfw.addALoad(funObjLocal);</span>
<span class="fc" id="L1652">            cfw.addALoad(thisObjLocal);</span>
<span class="fc" id="L1653">            cfw.addALoad(contextLocal);</span>
<span class="fc" id="L1654">            cfw.addALoad(variableObjectLocal);</span>
<span class="fc" id="L1655">            cfw.addPush(0); // false to indicate it is not eval script</span>
<span class="fc" id="L1656">            addScriptRuntimeInvoke(&quot;initScript&quot;,</span>
                                   &quot;(Lorg/mozilla/javascript/NativeFunction;&quot;
                                   +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                                   +&quot;Lorg/mozilla/javascript/Context;&quot;
                                   +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                                   +&quot;Z&quot;
                                   +&quot;)V&quot;);
        }

<span class="fc" id="L1665">        enterAreaStartLabel = cfw.acquireLabel();</span>
<span class="fc" id="L1666">        epilogueLabel = cfw.acquireLabel();</span>
<span class="fc" id="L1667">        cfw.markLabel(enterAreaStartLabel);</span>

<span class="fc" id="L1669">        generateNestedFunctionInits();</span>

        // default is to generate debug info
<span class="fc bfc" id="L1672" title="All 2 branches covered.">        if (compilerEnv.isGenerateDebugInfo()) {</span>
<span class="fc" id="L1673">            cfw.addVariableDescriptor(debugVariableName,</span>
                    &quot;Lorg/mozilla/javascript/Scriptable;&quot;,
<span class="fc" id="L1675">                    cfw.getCurrentCodeOffset(), variableObjectLocal);</span>
        }

<span class="pc bpc" id="L1678" title="1 of 2 branches missed.">        if (fnCurrent == null) {</span>
            // OPT: use dataflow to prove that this assignment is dead
<span class="fc" id="L1680">            popvLocal = getNewWordLocal();</span>
<span class="fc" id="L1681">            Codegen.pushUndefined(cfw);</span>
<span class="fc" id="L1682">            cfw.addAStore(popvLocal);</span>

<span class="fc" id="L1684">            int linenum = scriptOrFn.getEndLineno();</span>
<span class="fc bfc" id="L1685" title="All 2 branches covered.">            if (linenum != -1)</span>
<span class="fc" id="L1686">              cfw.addLineNumberEntry((short)linenum);</span>

<span class="fc" id="L1688">        } else {</span>
<span class="nc bnc" id="L1689" title="All 2 branches missed.">            if (fnCurrent.itsContainsCalls0) {</span>
<span class="nc" id="L1690">                itsZeroArgArray = getNewWordLocal();</span>
<span class="nc" id="L1691">                cfw.add(ByteCode.GETSTATIC,</span>
                        &quot;org/mozilla/javascript/ScriptRuntime&quot;,
                        &quot;emptyArgs&quot;, &quot;[Ljava/lang/Object;&quot;);
<span class="nc" id="L1694">                cfw.addAStore(itsZeroArgArray);</span>
            }
<span class="nc bnc" id="L1696" title="All 2 branches missed.">            if (fnCurrent.itsContainsCalls1) {</span>
<span class="nc" id="L1697">                itsOneArgArray = getNewWordLocal();</span>
<span class="nc" id="L1698">                cfw.addPush(1);</span>
<span class="nc" id="L1699">                cfw.add(ByteCode.ANEWARRAY, &quot;java/lang/Object&quot;);</span>
<span class="nc" id="L1700">                cfw.addAStore(itsOneArgArray);</span>
            }
        }
<span class="fc" id="L1703">    }</span>

    private void generateGetGeneratorResumptionPoint()
    {
<span class="nc" id="L1707">        cfw.addALoad(generatorStateLocal);</span>
<span class="nc" id="L1708">        cfw.add(ByteCode.GETFIELD,</span>
                OptRuntime.GeneratorState.CLASS_NAME,
                OptRuntime.GeneratorState.resumptionPoint_NAME,
                OptRuntime.GeneratorState.resumptionPoint_TYPE);
<span class="nc" id="L1712">    }</span>

    private void generateSetGeneratorResumptionPoint(int nextState)
    {
<span class="nc" id="L1716">        cfw.addALoad(generatorStateLocal);</span>
<span class="nc" id="L1717">        cfw.addLoadConstant(nextState);</span>
<span class="nc" id="L1718">        cfw.add(ByteCode.PUTFIELD,</span>
                OptRuntime.GeneratorState.CLASS_NAME,
                OptRuntime.GeneratorState.resumptionPoint_NAME,
                OptRuntime.GeneratorState.resumptionPoint_TYPE);
<span class="nc" id="L1722">    }</span>

    private void generateGetGeneratorStackState()
    {
<span class="nc" id="L1726">        cfw.addALoad(generatorStateLocal);</span>
<span class="nc" id="L1727">        addOptRuntimeInvoke(&quot;getGeneratorStackState&quot;,</span>
                    &quot;(Ljava/lang/Object;)[Ljava/lang/Object;&quot;);
<span class="nc" id="L1729">    }</span>

    private void generateEpilogue()
    {
<span class="fc bfc" id="L1733" title="All 2 branches covered.">        if (compilerEnv.isGenerateObserverCount())</span>
<span class="fc" id="L1734">            addInstructionCount();</span>
<span class="pc bpc" id="L1735" title="1 of 2 branches missed.">        if (isGenerator) {</span>
            // generate locals initialization
<span class="nc" id="L1737">            Map&lt;Node,int[]&gt; liveLocals = ((FunctionNode)scriptOrFn).getLiveLocals();</span>
<span class="nc bnc" id="L1738" title="All 2 branches missed.">            if (liveLocals != null) {</span>
<span class="nc" id="L1739">                List&lt;Node&gt; nodes = ((FunctionNode)scriptOrFn).getResumptionPoints();</span>
<span class="nc bnc" id="L1740" title="All 2 branches missed.">                for (int i = 0; i &lt; nodes.size(); i++) {</span>
<span class="nc" id="L1741">                    Node node = nodes.get(i);</span>
<span class="nc" id="L1742">                    int[] live = liveLocals.get(node);</span>
<span class="nc bnc" id="L1743" title="All 2 branches missed.">                    if (live != null) {</span>
<span class="nc" id="L1744">                        cfw.markTableSwitchCase(generatorSwitch,</span>
<span class="nc" id="L1745">                            getNextGeneratorState(node));</span>
<span class="nc" id="L1746">                        generateGetGeneratorLocalsState();</span>
<span class="nc bnc" id="L1747" title="All 2 branches missed.">                        for (int j = 0; j &lt; live.length; j++) {</span>
<span class="nc" id="L1748">                                cfw.add(ByteCode.DUP);</span>
<span class="nc" id="L1749">                                cfw.addLoadConstant(j);</span>
<span class="nc" id="L1750">                                cfw.add(ByteCode.AALOAD);</span>
<span class="nc" id="L1751">                                cfw.addAStore(live[j]);</span>
                        }
<span class="nc" id="L1753">                        cfw.add(ByteCode.POP);</span>
<span class="nc" id="L1754">                        cfw.add(ByteCode.GOTO, getTargetLabel(node));</span>
                    }
                }
            }

            // generate dispatch tables for finally
<span class="nc bnc" id="L1760" title="All 2 branches missed.">            if (finallys != null) {</span>
<span class="nc bnc" id="L1761" title="All 2 branches missed.">                for (Node n: finallys.keySet()) {</span>
<span class="nc bnc" id="L1762" title="All 2 branches missed.">                    if (n.getType() == Token.FINALLY) {</span>
<span class="nc" id="L1763">                        FinallyReturnPoint ret = finallys.get(n);</span>
                        // the finally will jump here
<span class="nc" id="L1765">                        cfw.markLabel(ret.tableLabel, (short)1);</span>

                        // start generating a dispatch table
<span class="nc" id="L1768">                        int startSwitch = cfw.addTableSwitch(0,</span>
<span class="nc" id="L1769">                                            ret.jsrPoints.size() - 1);</span>
<span class="nc" id="L1770">                        int c = 0;</span>
<span class="nc" id="L1771">                        cfw.markTableSwitchDefault(startSwitch);</span>
<span class="nc bnc" id="L1772" title="All 2 branches missed.">                        for (int i = 0; i &lt; ret.jsrPoints.size(); i++) {</span>
                            // generate gotos back to the JSR location
<span class="nc" id="L1774">                            cfw.markTableSwitchCase(startSwitch, c);</span>
<span class="nc" id="L1775">                            cfw.add(ByteCode.GOTO,</span>
<span class="nc" id="L1776">                                    ret.jsrPoints.get(i).intValue());</span>
<span class="nc" id="L1777">                            c++;</span>
                        }
                    }
<span class="nc" id="L1780">                }</span>
            }
        }

<span class="pc bpc" id="L1784" title="1 of 2 branches missed.">        if (epilogueLabel != -1) {</span>
<span class="fc" id="L1785">            cfw.markLabel(epilogueLabel);</span>
        }

<span class="pc bpc" id="L1788" title="1 of 2 branches missed.">        if (hasVarsInRegs) {</span>
<span class="nc" id="L1789">            cfw.add(ByteCode.ARETURN);</span>
<span class="nc" id="L1790">            return;</span>
<span class="pc bpc" id="L1791" title="1 of 2 branches missed.">        } else if (isGenerator) {</span>
<span class="nc bnc" id="L1792" title="All 2 branches missed.">            if (((FunctionNode)scriptOrFn).getResumptionPoints() != null) {</span>
<span class="nc" id="L1793">                cfw.markTableSwitchDefault(generatorSwitch);</span>
            }

            // change state for re-entry
<span class="nc" id="L1797">            generateSetGeneratorResumptionPoint(GENERATOR_TERMINATE);</span>

            // throw StopIteration
<span class="nc" id="L1800">            cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L1801">            addOptRuntimeInvoke(&quot;throwStopIteration&quot;,</span>
                    &quot;(Ljava/lang/Object;)V&quot;);

<span class="nc" id="L1804">            Codegen.pushUndefined(cfw);</span>
<span class="nc" id="L1805">            cfw.add(ByteCode.ARETURN);</span>

<span class="pc bpc" id="L1807" title="1 of 2 branches missed.">        } else if (fnCurrent == null) {</span>
<span class="fc" id="L1808">            cfw.addALoad(popvLocal);</span>
<span class="fc" id="L1809">            cfw.add(ByteCode.ARETURN);</span>
        } else {
<span class="nc" id="L1811">            generateActivationExit();</span>
<span class="nc" id="L1812">            cfw.add(ByteCode.ARETURN);</span>

            // Generate catch block to catch all and rethrow to call exit code
            // under exception propagation as well.

<span class="nc" id="L1817">            int finallyHandler = cfw.acquireLabel();</span>
<span class="nc" id="L1818">            cfw.markHandler(finallyHandler);</span>
<span class="nc" id="L1819">            short exceptionObject = getNewWordLocal();</span>
<span class="nc" id="L1820">            cfw.addAStore(exceptionObject);</span>

            // Duplicate generateActivationExit() in the catch block since it
            // takes less space then full-featured ByteCode.JSR/ByteCode.RET
<span class="nc" id="L1824">            generateActivationExit();</span>

<span class="nc" id="L1826">            cfw.addALoad(exceptionObject);</span>
<span class="nc" id="L1827">            releaseWordLocal(exceptionObject);</span>
            // rethrow
<span class="nc" id="L1829">            cfw.add(ByteCode.ATHROW);</span>

            // mark the handler
<span class="nc" id="L1832">            cfw.addExceptionHandler(enterAreaStartLabel, epilogueLabel,</span>
                                    finallyHandler, null); // catch any
        }
<span class="fc" id="L1835">    }</span>

    private void generateGetGeneratorLocalsState() {
<span class="nc" id="L1838">        cfw.addALoad(generatorStateLocal);</span>
<span class="nc" id="L1839">        addOptRuntimeInvoke(&quot;getGeneratorLocalsState&quot;,</span>
                                &quot;(Ljava/lang/Object;)[Ljava/lang/Object;&quot;);
<span class="nc" id="L1841">    }</span>

    private void generateActivationExit()
    {
<span class="nc bnc" id="L1845" title="All 4 branches missed.">        if (fnCurrent == null || hasVarsInRegs) throw Kit.codeBug();</span>
<span class="nc" id="L1846">        cfw.addALoad(contextLocal);</span>
<span class="nc" id="L1847">        addScriptRuntimeInvoke(&quot;exitActivationFunction&quot;,</span>
                               &quot;(Lorg/mozilla/javascript/Context;)V&quot;);
<span class="nc" id="L1849">    }</span>

    private void generateStatement(Node node)
    {
<span class="fc" id="L1853">        updateLineNumber(node);</span>
<span class="fc" id="L1854">        int type = node.getType();</span>
<span class="fc" id="L1855">        Node child = node.getFirstChild();</span>
<span class="pc bpc" id="L1856" title="17 of 19 branches missed.">        switch (type) {</span>
              case Token.LOOP:
              case Token.LABEL:
              case Token.WITH:
              case Token.SCRIPT:
              case Token.BLOCK:
              case Token.EMPTY:
                // no-ops.
<span class="fc bfc" id="L1864" title="All 2 branches covered.">                if (compilerEnv.isGenerateObserverCount()) {</span>
                    // Need to add instruction count even for no-ops to catch
                    // cases like while (1) {}
<span class="fc" id="L1867">                    addInstructionCount(1);</span>
                }
<span class="fc bfc" id="L1869" title="All 2 branches covered.">                while (child != null) {</span>
<span class="fc" id="L1870">                    generateStatement(child);</span>
<span class="fc" id="L1871">                    child = child.getNext();</span>
                }
                break;

              case Token.LOCAL_BLOCK: {
<span class="nc" id="L1876">                boolean prevLocal = inLocalBlock;</span>
<span class="nc" id="L1877">                inLocalBlock = true;</span>
<span class="nc" id="L1878">                int local = getNewWordLocal();</span>
<span class="nc bnc" id="L1879" title="All 2 branches missed.">                if (isGenerator) {</span>
<span class="nc" id="L1880">                    cfw.add(ByteCode.ACONST_NULL);</span>
<span class="nc" id="L1881">                    cfw.addAStore(local);</span>
                }
<span class="nc" id="L1883">                node.putIntProp(Node.LOCAL_PROP, local);</span>
<span class="nc bnc" id="L1884" title="All 2 branches missed.">                while (child != null) {</span>
<span class="nc" id="L1885">                    generateStatement(child);</span>
<span class="nc" id="L1886">                    child = child.getNext();</span>
                }
<span class="nc" id="L1888">                releaseWordLocal((short)local);</span>
<span class="nc" id="L1889">                node.removeProp(Node.LOCAL_PROP);</span>
<span class="nc" id="L1890">                inLocalBlock = prevLocal;</span>
<span class="nc" id="L1891">                break;</span>
              }

              case Token.FUNCTION: {
<span class="nc" id="L1895">                int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);</span>
<span class="nc" id="L1896">                OptFunctionNode ofn = OptFunctionNode.get(scriptOrFn, fnIndex);</span>
<span class="nc" id="L1897">                int t = ofn.fnode.getFunctionType();</span>
<span class="nc bnc" id="L1898" title="All 2 branches missed.">                if (t == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {</span>
<span class="nc" id="L1899">                    visitFunction(ofn, t);</span>
                } else {
<span class="nc bnc" id="L1901" title="All 2 branches missed.">                    if (t != FunctionNode.FUNCTION_STATEMENT) {</span>
<span class="nc" id="L1902">                        throw Codegen.badTree();</span>
                    }
                }
                break;
              }

              case Token.TRY:
<span class="nc" id="L1909">                visitTryCatchFinally((Jump)node, child);</span>
<span class="nc" id="L1910">                break;</span>

              case Token.CATCH_SCOPE:
                {
                    // nothing stays on the stack on entry into a catch scope
<span class="nc" id="L1915">                    cfw.setStackTop((short) 0);</span>

<span class="nc" id="L1917">                    int local = getLocalBlockRegister(node);</span>
<span class="nc" id="L1918">                    int scopeIndex</span>
<span class="nc" id="L1919">                        = node.getExistingIntProp(Node.CATCH_SCOPE_PROP);</span>

<span class="nc" id="L1921">                    String name = child.getString(); // name of exception</span>
<span class="nc" id="L1922">                    child = child.getNext();</span>
<span class="nc" id="L1923">                    generateExpression(child, node); // load expression object</span>
<span class="nc bnc" id="L1924" title="All 2 branches missed.">                    if (scopeIndex == 0) {</span>
<span class="nc" id="L1925">                        cfw.add(ByteCode.ACONST_NULL);</span>
                    } else {
                        // Load previous catch scope object
<span class="nc" id="L1928">                        cfw.addALoad(local);</span>
                    }
<span class="nc" id="L1930">                    cfw.addPush(name);</span>
<span class="nc" id="L1931">                    cfw.addALoad(contextLocal);</span>
<span class="nc" id="L1932">                    cfw.addALoad(variableObjectLocal);</span>

<span class="nc" id="L1934">                    addScriptRuntimeInvoke(</span>
                        &quot;newCatchScope&quot;,
                        &quot;(Ljava/lang/Throwable;&quot;
                        +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                        +&quot;Ljava/lang/String;&quot;
                        +&quot;Lorg/mozilla/javascript/Context;&quot;
                        +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                        +&quot;)Lorg/mozilla/javascript/Scriptable;&quot;);
<span class="nc" id="L1942">                    cfw.addAStore(local);</span>
                }
<span class="nc" id="L1944">                break;</span>

              case Token.THROW:
<span class="nc" id="L1947">                generateExpression(child, node);</span>
<span class="nc bnc" id="L1948" title="All 2 branches missed.">                if (compilerEnv.isGenerateObserverCount())</span>
<span class="nc" id="L1949">                    addInstructionCount();</span>
<span class="nc" id="L1950">                generateThrowJavaScriptException();</span>
<span class="nc" id="L1951">                break;</span>

              case Token.RETHROW:
<span class="nc bnc" id="L1954" title="All 2 branches missed.">                if (compilerEnv.isGenerateObserverCount())</span>
<span class="nc" id="L1955">                    addInstructionCount();</span>
<span class="nc" id="L1956">                cfw.addALoad(getLocalBlockRegister(node));</span>
<span class="nc" id="L1957">                cfw.add(ByteCode.ATHROW);</span>
<span class="nc" id="L1958">                break;</span>

              case Token.RETURN_RESULT:
              case Token.RETURN:
<span class="nc bnc" id="L1962" title="All 2 branches missed.">                if (!isGenerator) {</span>
<span class="nc bnc" id="L1963" title="All 2 branches missed.">                    if (child != null) {</span>
<span class="nc" id="L1964">                        generateExpression(child, node);</span>
<span class="nc bnc" id="L1965" title="All 2 branches missed.">                    } else if (type == Token.RETURN) {</span>
<span class="nc" id="L1966">                        Codegen.pushUndefined(cfw);</span>
                    } else {
<span class="nc bnc" id="L1968" title="All 2 branches missed.">                        if (popvLocal &lt; 0) throw Codegen.badTree();</span>
<span class="nc" id="L1969">                        cfw.addALoad(popvLocal);</span>
                    }
                }
<span class="nc bnc" id="L1972" title="All 2 branches missed.">                if (compilerEnv.isGenerateObserverCount())</span>
<span class="nc" id="L1973">                    addInstructionCount();</span>
<span class="nc bnc" id="L1974" title="All 2 branches missed.">                if (epilogueLabel == -1) {</span>
<span class="nc bnc" id="L1975" title="All 2 branches missed.">                    if (!hasVarsInRegs) throw Codegen.badTree();</span>
<span class="nc" id="L1976">                    epilogueLabel = cfw.acquireLabel();</span>
                }
<span class="nc" id="L1978">                cfw.add(ByteCode.GOTO, epilogueLabel);</span>
<span class="nc" id="L1979">                break;</span>

              case Token.SWITCH:
<span class="nc bnc" id="L1982" title="All 2 branches missed.">                if (compilerEnv.isGenerateObserverCount())</span>
<span class="nc" id="L1983">                    addInstructionCount();</span>
<span class="nc" id="L1984">                visitSwitch((Jump)node, child);</span>
<span class="nc" id="L1985">                break;</span>

              case Token.ENTERWITH:
<span class="nc" id="L1988">                generateExpression(child, node);</span>
<span class="nc" id="L1989">                cfw.addALoad(contextLocal);</span>
<span class="nc" id="L1990">                cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L1991">                addScriptRuntimeInvoke(</span>
                    &quot;enterWith&quot;,
                    &quot;(Ljava/lang/Object;&quot;
                    +&quot;Lorg/mozilla/javascript/Context;&quot;
                    +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                    +&quot;)Lorg/mozilla/javascript/Scriptable;&quot;);
<span class="nc" id="L1997">                cfw.addAStore(variableObjectLocal);</span>
<span class="nc" id="L1998">                incReferenceWordLocal(variableObjectLocal);</span>
<span class="nc" id="L1999">                break;</span>

              case Token.LEAVEWITH:
<span class="nc" id="L2002">                cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L2003">                addScriptRuntimeInvoke(</span>
                    &quot;leaveWith&quot;,
                    &quot;(Lorg/mozilla/javascript/Scriptable;&quot;
                    +&quot;)Lorg/mozilla/javascript/Scriptable;&quot;);
<span class="nc" id="L2007">                cfw.addAStore(variableObjectLocal);</span>
<span class="nc" id="L2008">                decReferenceWordLocal(variableObjectLocal);</span>
<span class="nc" id="L2009">                break;</span>

              case Token.ENUM_INIT_KEYS:
              case Token.ENUM_INIT_VALUES:
              case Token.ENUM_INIT_ARRAY:
              case Token.ENUM_INIT_VALUES_IN_ORDER:
<span class="nc" id="L2015">                generateExpression(child, node);</span>
<span class="nc" id="L2016">                cfw.addALoad(contextLocal);</span>
<span class="nc" id="L2017">                cfw.addALoad(variableObjectLocal);</span>
<span class="nc bnc" id="L2018" title="All 6 branches missed.">                int enumType = type == Token.ENUM_INIT_KEYS</span>
                                   ? ScriptRuntime.ENUMERATE_KEYS :
                               type == Token.ENUM_INIT_VALUES
                                   ? ScriptRuntime.ENUMERATE_VALUES :
                               type == Token.ENUM_INIT_VALUES_IN_ORDER
                                   ? ScriptRuntime.ENUMERATE_VALUES_IN_ORDER :
                               ScriptRuntime.ENUMERATE_ARRAY;
<span class="nc" id="L2025">                cfw.addPush(enumType);</span>
<span class="nc" id="L2026">                addScriptRuntimeInvoke(&quot;enumInit&quot;,</span>
                                       &quot;(Ljava/lang/Object;&quot;
                                       +&quot;Lorg/mozilla/javascript/Context;&quot;
                                       +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                                       +&quot;I&quot;
                                       +&quot;)Ljava/lang/Object;&quot;);
<span class="nc" id="L2032">                cfw.addAStore(getLocalBlockRegister(node));</span>
<span class="nc" id="L2033">                break;</span>

              case Token.EXPR_VOID:
<span class="nc bnc" id="L2036" title="All 2 branches missed.">                if (child.getType() == Token.SETVAR) {</span>
                    /* special case this so as to avoid unnecessary
                    load's &amp; pop's */
<span class="nc" id="L2039">                    visitSetVar(child, child.getFirstChild(), false);</span>
                }
<span class="nc bnc" id="L2041" title="All 2 branches missed.">                else if (child.getType() == Token.SETCONSTVAR) {</span>
                    /* special case this so as to avoid unnecessary
                    load's &amp; pop's */
<span class="nc" id="L2044">                    visitSetConstVar(child, child.getFirstChild(), false);</span>
                }
<span class="nc bnc" id="L2046" title="All 2 branches missed.">                else if (child.getType() == Token.YIELD) {</span>
<span class="nc" id="L2047">                    generateYieldPoint(child, false);</span>
                }
                else {
<span class="nc" id="L2050">                    generateExpression(child, node);</span>
<span class="nc bnc" id="L2051" title="All 2 branches missed.">                    if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1)</span>
<span class="nc" id="L2052">                        cfw.add(ByteCode.POP2);</span>
                    else
<span class="nc" id="L2054">                        cfw.add(ByteCode.POP);</span>
                }
<span class="nc" id="L2056">                break;</span>

              case Token.EXPR_RESULT:
<span class="fc" id="L2059">                generateExpression(child, node);</span>
<span class="pc bpc" id="L2060" title="1 of 2 branches missed.">                if (popvLocal &lt; 0) {</span>
<span class="nc" id="L2061">                    popvLocal = getNewWordLocal();</span>
                }
<span class="fc" id="L2063">                cfw.addAStore(popvLocal);</span>
<span class="fc" id="L2064">                break;</span>

              case Token.TARGET:
                {
<span class="nc bnc" id="L2068" title="All 2 branches missed.">                    if (compilerEnv.isGenerateObserverCount())</span>
<span class="nc" id="L2069">                        addInstructionCount();</span>
<span class="nc" id="L2070">                    int label = getTargetLabel(node);</span>
<span class="nc" id="L2071">                    cfw.markLabel(label);</span>
<span class="nc bnc" id="L2072" title="All 2 branches missed.">                    if (compilerEnv.isGenerateObserverCount())</span>
<span class="nc" id="L2073">                        saveCurrentCodeOffset();</span>
                }
<span class="nc" id="L2075">                break;</span>

              case Token.JSR:
              case Token.GOTO:
              case Token.IFEQ:
              case Token.IFNE:
<span class="nc bnc" id="L2081" title="All 2 branches missed.">                if (compilerEnv.isGenerateObserverCount())</span>
<span class="nc" id="L2082">                    addInstructionCount();</span>
<span class="nc" id="L2083">                visitGoto((Jump)node, type, child);</span>
<span class="nc" id="L2084">                break;</span>

              case Token.FINALLY:
                {
                    // This is the non-exception case for a finally block. In
                    // other words, since we inline finally blocks wherever
                    // jsr was previously used, and jsr is only used when the
                    // function is not a generator, we don't need to generate
                    // this case if the function isn't a generator.
<span class="nc bnc" id="L2093" title="All 2 branches missed.">                    if (!isGenerator) {</span>
<span class="nc" id="L2094">                        break;</span>
                    }

<span class="nc bnc" id="L2097" title="All 2 branches missed.">                    if (compilerEnv.isGenerateObserverCount())</span>
<span class="nc" id="L2098">                        saveCurrentCodeOffset();</span>
                    // there is exactly one value on the stack when enterring
                    // finally blocks: the return address (or its int encoding)
<span class="nc" id="L2101">                    cfw.setStackTop((short)1);</span>

                    // Save return address in a new local
<span class="nc" id="L2104">                    int finallyRegister = getNewWordLocal();</span>

<span class="nc" id="L2106">                    int finallyStart = cfw.acquireLabel();</span>
<span class="nc" id="L2107">                    int finallyEnd = cfw.acquireLabel();</span>
<span class="nc" id="L2108">                    cfw.markLabel(finallyStart);</span>

<span class="nc" id="L2110">                    generateIntegerWrap();</span>
<span class="nc" id="L2111">                    cfw.addAStore(finallyRegister);</span>

<span class="nc bnc" id="L2113" title="All 2 branches missed.">                    while (child != null) {</span>
<span class="nc" id="L2114">                        generateStatement(child);</span>
<span class="nc" id="L2115">                        child = child.getNext();</span>
                    }

<span class="nc" id="L2118">                    cfw.addALoad(finallyRegister);</span>
<span class="nc" id="L2119">                    cfw.add(ByteCode.CHECKCAST, &quot;java/lang/Integer&quot;);</span>
<span class="nc" id="L2120">                    generateIntegerUnwrap();</span>
<span class="nc" id="L2121">                    FinallyReturnPoint ret = finallys.get(node);</span>
<span class="nc" id="L2122">                    ret.tableLabel = cfw.acquireLabel();</span>
<span class="nc" id="L2123">                    cfw.add(ByteCode.GOTO, ret.tableLabel);</span>

<span class="nc" id="L2125">                    releaseWordLocal((short)finallyRegister);</span>
<span class="nc" id="L2126">                    cfw.markLabel(finallyEnd);</span>
                }
<span class="nc" id="L2128">                break;</span>

              case Token.DEBUGGER:
<span class="nc" id="L2131">                break;</span>

              default:
<span class="nc" id="L2134">                throw Codegen.badTree();</span>
        }

<span class="fc" id="L2137">    }</span>

    private void generateIntegerWrap()
    {
<span class="nc" id="L2141">        cfw.addInvoke(ByteCode.INVOKESTATIC, &quot;java/lang/Integer&quot;, &quot;valueOf&quot;,</span>
                &quot;(I)Ljava/lang/Integer;&quot;);
<span class="nc" id="L2143">    }</span>


    private void generateIntegerUnwrap()
    {
<span class="nc" id="L2148">        cfw.addInvoke(ByteCode.INVOKEVIRTUAL, &quot;java/lang/Integer&quot;,</span>
                &quot;intValue&quot;, &quot;()I&quot;);
<span class="nc" id="L2150">    }</span>


    private void generateThrowJavaScriptException()
    {
<span class="nc" id="L2155">        cfw.add(ByteCode.NEW,</span>
                        &quot;org/mozilla/javascript/JavaScriptException&quot;);
<span class="nc" id="L2157">        cfw.add(ByteCode.DUP_X1);</span>
<span class="nc" id="L2158">        cfw.add(ByteCode.SWAP);</span>
<span class="nc" id="L2159">        cfw.addPush(scriptOrFn.getSourceName());</span>
<span class="nc" id="L2160">        cfw.addPush(itsLineNumber);</span>
<span class="nc" id="L2161">        cfw.addInvoke(</span>
                    ByteCode.INVOKESPECIAL,
                    &quot;org/mozilla/javascript/JavaScriptException&quot;,
                    &quot;&lt;init&gt;&quot;,
                    &quot;(Ljava/lang/Object;Ljava/lang/String;I)V&quot;);
<span class="nc" id="L2166">        cfw.add(ByteCode.ATHROW);</span>
<span class="nc" id="L2167">    }</span>

    private int getNextGeneratorState(Node node)
    {
<span class="nc" id="L2171">        int nodeIndex = ((FunctionNode)scriptOrFn).getResumptionPoints()</span>
<span class="nc" id="L2172">                .indexOf(node);</span>
<span class="nc" id="L2173">        return nodeIndex + GENERATOR_YIELD_START;</span>
    }

    private void generateExpression(Node node, Node parent)
    {
<span class="fc" id="L2178">        int type = node.getType();</span>
<span class="fc" id="L2179">        Node child = node.getFirstChild();</span>
<span class="pc bpc" id="L2180" title="58 of 61 branches missed.">        switch (type) {</span>
              case Token.USE_STACK:
<span class="nc" id="L2182">                break;</span>

              case Token.FUNCTION:
<span class="nc bnc" id="L2185" title="All 4 branches missed.">                if (fnCurrent != null || parent.getType() != Token.SCRIPT) {</span>
<span class="nc" id="L2186">                    int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);</span>
<span class="nc" id="L2187">                    OptFunctionNode ofn = OptFunctionNode.get(scriptOrFn,</span>
                                                             fnIndex);
<span class="nc" id="L2189">                    int t = ofn.fnode.getFunctionType();</span>
<span class="nc bnc" id="L2190" title="All 4 branches missed.">                    if (t != FunctionNode.FUNCTION_EXPRESSION &amp;&amp;</span>
                        t != FunctionNode.ARROW_FUNCTION) {
<span class="nc" id="L2192">                        throw Codegen.badTree();</span>
                    }
<span class="nc" id="L2194">                    visitFunction(ofn, t);</span>
<span class="nc" id="L2195">                }</span>
                break;

              case Token.NAME:
                {
<span class="fc" id="L2200">                    cfw.addALoad(contextLocal);</span>
<span class="fc" id="L2201">                    cfw.addALoad(variableObjectLocal);</span>
<span class="fc" id="L2202">                    cfw.addPush(node.getString());</span>
<span class="fc" id="L2203">                    addScriptRuntimeInvoke(</span>
                        &quot;name&quot;,
                        &quot;(Lorg/mozilla/javascript/Context;&quot;
                        +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                        +&quot;Ljava/lang/String;&quot;
                        +&quot;)Ljava/lang/Object;&quot;);
                }
<span class="fc" id="L2210">                break;</span>

              case Token.CALL:
              case Token.NEW:
                {
<span class="nc" id="L2215">                    int specialType = node.getIntProp(Node.SPECIALCALL_PROP,</span>
                                                      Node.NON_SPECIALCALL);
<span class="nc bnc" id="L2217" title="All 2 branches missed.">                    if (specialType == Node.NON_SPECIALCALL) {</span>
                        OptFunctionNode target;
<span class="nc" id="L2219">                        target = (OptFunctionNode)node.getProp(</span>
                                     Node.DIRECTCALL_PROP);

<span class="nc bnc" id="L2222" title="All 2 branches missed.">                        if (target != null) {</span>
<span class="nc" id="L2223">                            visitOptimizedCall(node, target, type, child);</span>
<span class="nc bnc" id="L2224" title="All 2 branches missed.">                        } else if (type == Token.CALL) {</span>
<span class="nc" id="L2225">                            visitStandardCall(node, child);</span>
                        } else {
<span class="nc" id="L2227">                            visitStandardNew(node, child);</span>
                        }
<span class="nc" id="L2229">                    } else {</span>
<span class="nc" id="L2230">                        visitSpecialCall(node, type, specialType, child);</span>
                    }
                }
<span class="nc" id="L2233">                break;</span>

              case Token.REF_CALL:
<span class="nc" id="L2236">                generateFunctionAndThisObj(child, node);</span>
                // stack: ... functionObj thisObj
<span class="nc" id="L2238">                child = child.getNext();</span>
<span class="nc" id="L2239">                generateCallArgArray(node, child, false);</span>
<span class="nc" id="L2240">                cfw.addALoad(contextLocal);</span>
<span class="nc" id="L2241">                addScriptRuntimeInvoke(</span>
                    &quot;callRef&quot;,
                    &quot;(Lorg/mozilla/javascript/Callable;&quot;
                    +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                    +&quot;[Ljava/lang/Object;&quot;
                    +&quot;Lorg/mozilla/javascript/Context;&quot;
                    +&quot;)Lorg/mozilla/javascript/Ref;&quot;);
<span class="nc" id="L2248">                break;</span>

              case Token.NUMBER:
                {
<span class="nc" id="L2252">                    double num = node.getDouble();</span>
<span class="nc bnc" id="L2253" title="All 2 branches missed.">                    if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) {</span>
<span class="nc" id="L2254">                        cfw.addPush(num);</span>
                    } else {
<span class="nc" id="L2256">                        codegen.pushNumberAsObject(cfw, num);</span>
                    }
                }
<span class="nc" id="L2259">                break;</span>

              case Token.STRING:
<span class="fc" id="L2262">                cfw.addPush(node.getString());</span>
<span class="fc" id="L2263">                break;</span>

              case Token.THIS:
<span class="nc" id="L2266">                cfw.addALoad(thisObjLocal);</span>
<span class="nc" id="L2267">                break;</span>

              case Token.THISFN:
<span class="nc" id="L2270">                cfw.add(ByteCode.ALOAD_0);</span>
<span class="nc" id="L2271">                break;</span>

              case Token.NULL:
<span class="nc" id="L2274">                cfw.add(ByteCode.ACONST_NULL);</span>
<span class="nc" id="L2275">                break;</span>

              case Token.TRUE:
<span class="nc" id="L2278">                cfw.add(ByteCode.GETSTATIC, &quot;java/lang/Boolean&quot;,</span>
                        &quot;TRUE&quot;, &quot;Ljava/lang/Boolean;&quot;);
<span class="nc" id="L2280">                break;</span>

              case Token.FALSE:
<span class="nc" id="L2283">                cfw.add(ByteCode.GETSTATIC, &quot;java/lang/Boolean&quot;,</span>
                        &quot;FALSE&quot;, &quot;Ljava/lang/Boolean;&quot;);
<span class="nc" id="L2285">                break;</span>

              case Token.REGEXP:
                {
                    // Create a new wrapper around precompiled regexp
<span class="nc" id="L2290">                    cfw.addALoad(contextLocal);</span>
<span class="nc" id="L2291">                    cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L2292">                    int i = node.getExistingIntProp(Node.REGEXP_PROP);</span>
<span class="nc" id="L2293">                    cfw.add(ByteCode.GETSTATIC, codegen.mainClassName,</span>
<span class="nc" id="L2294">                            codegen.getCompiledRegexpName(scriptOrFn, i),</span>
                            &quot;Ljava/lang/Object;&quot;);
<span class="nc" id="L2296">                    cfw.addInvoke(ByteCode.INVOKESTATIC,</span>
                                  &quot;org/mozilla/javascript/ScriptRuntime&quot;,
                                  &quot;wrapRegExp&quot;,
                                  &quot;(Lorg/mozilla/javascript/Context;&quot;
                                  +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                                  +&quot;Ljava/lang/Object;&quot;
                                  +&quot;)Lorg/mozilla/javascript/Scriptable;&quot;);
                }
<span class="nc" id="L2304">                break;</span>

              case Token.COMMA: {
<span class="nc" id="L2307">                Node next = child.getNext();</span>
<span class="nc bnc" id="L2308" title="All 2 branches missed.">                while (next != null) {</span>
<span class="nc" id="L2309">                    generateExpression(child, node);</span>
<span class="nc" id="L2310">                    cfw.add(ByteCode.POP);</span>
<span class="nc" id="L2311">                    child = next;</span>
<span class="nc" id="L2312">                    next = next.getNext();</span>
                }
<span class="nc" id="L2314">                generateExpression(child, node);</span>
<span class="nc" id="L2315">                break;</span>
              }

              case Token.ENUM_NEXT:
              case Token.ENUM_ID: {
<span class="nc" id="L2320">                int local = getLocalBlockRegister(node);</span>
<span class="nc" id="L2321">                cfw.addALoad(local);</span>
<span class="nc bnc" id="L2322" title="All 2 branches missed.">                if (type == Token.ENUM_NEXT) {</span>
<span class="nc" id="L2323">                    addScriptRuntimeInvoke(</span>
                        &quot;enumNext&quot;, &quot;(Ljava/lang/Object;)Ljava/lang/Boolean;&quot;);
                } else {
<span class="nc" id="L2326">                    cfw.addALoad(contextLocal);</span>
<span class="nc" id="L2327">                    addScriptRuntimeInvoke(&quot;enumId&quot;,</span>
                                           &quot;(Ljava/lang/Object;&quot;
                                           +&quot;Lorg/mozilla/javascript/Context;&quot;
                                           +&quot;)Ljava/lang/Object;&quot;);
                }
<span class="nc" id="L2332">                break;</span>
              }

              case Token.ARRAYLIT:
<span class="nc" id="L2336">                visitArrayLiteral(node, child, false);</span>
<span class="nc" id="L2337">                break;</span>

              case Token.OBJECTLIT:
<span class="nc" id="L2340">                visitObjectLiteral(node, child, false);</span>
<span class="nc" id="L2341">                break;</span>

              case Token.NOT: {
<span class="nc" id="L2344">                int trueTarget = cfw.acquireLabel();</span>
<span class="nc" id="L2345">                int falseTarget = cfw.acquireLabel();</span>
<span class="nc" id="L2346">                int beyond = cfw.acquireLabel();</span>
<span class="nc" id="L2347">                generateIfJump(child, node, trueTarget, falseTarget);</span>

<span class="nc" id="L2349">                cfw.markLabel(trueTarget);</span>
<span class="nc" id="L2350">                cfw.add(ByteCode.GETSTATIC, &quot;java/lang/Boolean&quot;,</span>
                                        &quot;FALSE&quot;, &quot;Ljava/lang/Boolean;&quot;);
<span class="nc" id="L2352">                cfw.add(ByteCode.GOTO, beyond);</span>
<span class="nc" id="L2353">                cfw.markLabel(falseTarget);</span>
<span class="nc" id="L2354">                cfw.add(ByteCode.GETSTATIC, &quot;java/lang/Boolean&quot;,</span>
                                        &quot;TRUE&quot;, &quot;Ljava/lang/Boolean;&quot;);
<span class="nc" id="L2356">                cfw.markLabel(beyond);</span>
<span class="nc" id="L2357">                cfw.adjustStackTop(-1);</span>
<span class="nc" id="L2358">                break;</span>
              }

              case Token.BITNOT:
<span class="nc" id="L2362">                generateExpression(child, node);</span>
<span class="nc" id="L2363">                addScriptRuntimeInvoke(&quot;toInt32&quot;, &quot;(Ljava/lang/Object;)I&quot;);</span>
<span class="nc" id="L2364">                cfw.addPush(-1);         // implement ~a as (a ^ -1)</span>
<span class="nc" id="L2365">                cfw.add(ByteCode.IXOR);</span>
<span class="nc" id="L2366">                cfw.add(ByteCode.I2D);</span>
<span class="nc" id="L2367">                addDoubleWrap();</span>
<span class="nc" id="L2368">                break;</span>

              case Token.VOID:
<span class="nc" id="L2371">                generateExpression(child, node);</span>
<span class="nc" id="L2372">                cfw.add(ByteCode.POP);</span>
<span class="nc" id="L2373">                Codegen.pushUndefined(cfw);</span>
<span class="nc" id="L2374">                break;</span>

              case Token.TYPEOF:
<span class="nc" id="L2377">                generateExpression(child, node);</span>
<span class="nc" id="L2378">                addScriptRuntimeInvoke(&quot;typeof&quot;,</span>
                                       &quot;(Ljava/lang/Object;&quot;
                                       +&quot;)Ljava/lang/String;&quot;);
<span class="nc" id="L2381">                break;</span>

              case Token.TYPEOFNAME:
<span class="nc" id="L2384">                visitTypeofname(node);</span>
<span class="nc" id="L2385">                break;</span>

              case Token.INC:
              case Token.DEC:
<span class="nc" id="L2389">                visitIncDec(node);</span>
<span class="nc" id="L2390">                break;</span>

              case Token.OR:
              case Token.AND: {
<span class="nc" id="L2394">                    generateExpression(child, node);</span>
<span class="nc" id="L2395">                    cfw.add(ByteCode.DUP);</span>
<span class="nc" id="L2396">                    addScriptRuntimeInvoke(&quot;toBoolean&quot;,</span>
                                           &quot;(Ljava/lang/Object;)Z&quot;);
<span class="nc" id="L2398">                    int falseTarget = cfw.acquireLabel();</span>
<span class="nc bnc" id="L2399" title="All 2 branches missed.">                    if (type == Token.AND)</span>
<span class="nc" id="L2400">                        cfw.add(ByteCode.IFEQ, falseTarget);</span>
                    else
<span class="nc" id="L2402">                        cfw.add(ByteCode.IFNE, falseTarget);</span>
<span class="nc" id="L2403">                    cfw.add(ByteCode.POP);</span>
<span class="nc" id="L2404">                    generateExpression(child.getNext(), node);</span>
<span class="nc" id="L2405">                    cfw.markLabel(falseTarget);</span>
                }
<span class="nc" id="L2407">                break;</span>

              case Token.HOOK : {
<span class="nc" id="L2410">                    Node ifThen = child.getNext();</span>
<span class="nc" id="L2411">                    Node ifElse = ifThen.getNext();</span>
<span class="nc" id="L2412">                    generateExpression(child, node);</span>
<span class="nc" id="L2413">                    addScriptRuntimeInvoke(&quot;toBoolean&quot;,</span>
                                           &quot;(Ljava/lang/Object;)Z&quot;);
<span class="nc" id="L2415">                    int elseTarget = cfw.acquireLabel();</span>
<span class="nc" id="L2416">                    cfw.add(ByteCode.IFEQ, elseTarget);</span>
<span class="nc" id="L2417">                    short stack = cfw.getStackTop();</span>
<span class="nc" id="L2418">                    generateExpression(ifThen, node);</span>
<span class="nc" id="L2419">                    int afterHook = cfw.acquireLabel();</span>
<span class="nc" id="L2420">                    cfw.add(ByteCode.GOTO, afterHook);</span>
<span class="nc" id="L2421">                    cfw.markLabel(elseTarget, stack);</span>
<span class="nc" id="L2422">                    generateExpression(ifElse, node);</span>
<span class="nc" id="L2423">                    cfw.markLabel(afterHook);</span>
                }
<span class="nc" id="L2425">                break;</span>

              case Token.ADD: {
<span class="nc" id="L2428">                    generateExpression(child, node);</span>
<span class="nc" id="L2429">                    generateExpression(child.getNext(), node);</span>
<span class="nc bnc" id="L2430" title="All 4 branches missed.">                    switch (node.getIntProp(Node.ISNUMBER_PROP, -1)) {</span>
                      case Node.BOTH:
<span class="nc" id="L2432">                        cfw.add(ByteCode.DADD);</span>
<span class="nc" id="L2433">                        break;</span>
                      case Node.LEFT:
<span class="nc" id="L2435">                        addOptRuntimeInvoke(&quot;add&quot;,</span>
                            &quot;(DLjava/lang/Object;)Ljava/lang/Object;&quot;);
<span class="nc" id="L2437">                        break;</span>
                      case Node.RIGHT:
<span class="nc" id="L2439">                        addOptRuntimeInvoke(&quot;add&quot;,</span>
                            &quot;(Ljava/lang/Object;D)Ljava/lang/Object;&quot;);
<span class="nc" id="L2441">                        break;</span>
                      default:
<span class="nc bnc" id="L2443" title="All 2 branches missed.">                        if (child.getType() == Token.STRING) {</span>
<span class="nc" id="L2444">                            addScriptRuntimeInvoke(&quot;add&quot;,</span>
                                &quot;(Ljava/lang/CharSequence;&quot;
                                +&quot;Ljava/lang/Object;&quot;
                                +&quot;)Ljava/lang/CharSequence;&quot;);
<span class="nc bnc" id="L2448" title="All 2 branches missed.">                        } else if (child.getNext().getType() == Token.STRING) {</span>
<span class="nc" id="L2449">                            addScriptRuntimeInvoke(&quot;add&quot;,</span>
                                &quot;(Ljava/lang/Object;&quot;
                                +&quot;Ljava/lang/CharSequence;&quot;
                                +&quot;)Ljava/lang/CharSequence;&quot;);
                        } else {
<span class="nc" id="L2454">                            cfw.addALoad(contextLocal);</span>
<span class="nc" id="L2455">                            addScriptRuntimeInvoke(&quot;add&quot;,</span>
                                &quot;(Ljava/lang/Object;&quot;
                                +&quot;Ljava/lang/Object;&quot;
                                +&quot;Lorg/mozilla/javascript/Context;&quot;
                                +&quot;)Ljava/lang/Object;&quot;);
                        }
                    }
                }
<span class="nc" id="L2463">                break;</span>

              case Token.MUL:
<span class="nc" id="L2466">                visitArithmetic(node, ByteCode.DMUL, child, parent);</span>
<span class="nc" id="L2467">                break;</span>

              case Token.SUB:
<span class="nc" id="L2470">                visitArithmetic(node, ByteCode.DSUB, child, parent);</span>
<span class="nc" id="L2471">                break;</span>

              case Token.DIV:
              case Token.MOD:
<span class="nc bnc" id="L2475" title="All 2 branches missed.">                visitArithmetic(node, type == Token.DIV</span>
                                      ? ByteCode.DDIV
                                      : ByteCode.DREM, child, parent);
<span class="nc" id="L2478">                break;</span>

              case Token.BITOR:
              case Token.BITXOR:
              case Token.BITAND:
              case Token.LSH:
              case Token.RSH:
              case Token.URSH:
<span class="nc" id="L2486">                visitBitOp(node, type, child);</span>
<span class="nc" id="L2487">                break;</span>

              case Token.POS:
              case Token.NEG:
<span class="nc" id="L2491">                generateExpression(child, node);</span>
<span class="nc" id="L2492">                addObjectToDouble();</span>
<span class="nc bnc" id="L2493" title="All 2 branches missed.">                if (type == Token.NEG) {</span>
<span class="nc" id="L2494">                    cfw.add(ByteCode.DNEG);</span>
                }
<span class="nc" id="L2496">                addDoubleWrap();</span>
<span class="nc" id="L2497">                break;</span>

              case Token.TO_DOUBLE:
                // cnvt to double (not Double)
<span class="nc" id="L2501">                generateExpression(child, node);</span>
<span class="nc" id="L2502">                addObjectToDouble();</span>
<span class="nc" id="L2503">                break;</span>

              case Token.TO_OBJECT: {
                // convert from double
<span class="nc" id="L2507">                int prop = -1;</span>
<span class="nc bnc" id="L2508" title="All 2 branches missed.">                if (child.getType() == Token.NUMBER) {</span>
<span class="nc" id="L2509">                    prop = child.getIntProp(Node.ISNUMBER_PROP, -1);</span>
                }
<span class="nc bnc" id="L2511" title="All 2 branches missed.">                if (prop != -1) {</span>
<span class="nc" id="L2512">                    child.removeProp(Node.ISNUMBER_PROP);</span>
<span class="nc" id="L2513">                    generateExpression(child, node);</span>
<span class="nc" id="L2514">                    child.putIntProp(Node.ISNUMBER_PROP, prop);</span>
                } else {
<span class="nc" id="L2516">                    generateExpression(child, node);</span>
<span class="nc" id="L2517">                    addDoubleWrap();</span>
                }
<span class="nc" id="L2519">                break;</span>
              }

              case Token.IN:
              case Token.INSTANCEOF:
              case Token.LE:
              case Token.LT:
              case Token.GE:
              case Token.GT: {
<span class="nc" id="L2528">                int trueGOTO = cfw.acquireLabel();</span>
<span class="nc" id="L2529">                int falseGOTO = cfw.acquireLabel();</span>
<span class="nc" id="L2530">                visitIfJumpRelOp(node, child, trueGOTO, falseGOTO);</span>
<span class="nc" id="L2531">                addJumpedBooleanWrap(trueGOTO, falseGOTO);</span>
<span class="nc" id="L2532">                break;</span>
              }

              case Token.EQ:
              case Token.NE:
              case Token.SHEQ:
              case Token.SHNE: {
<span class="nc" id="L2539">                int trueGOTO = cfw.acquireLabel();</span>
<span class="nc" id="L2540">                int falseGOTO = cfw.acquireLabel();</span>
<span class="nc" id="L2541">                visitIfJumpEqOp(node, child, trueGOTO, falseGOTO);</span>
<span class="nc" id="L2542">                addJumpedBooleanWrap(trueGOTO, falseGOTO);</span>
<span class="nc" id="L2543">                break;</span>
              }

              case Token.GETPROP:
              case Token.GETPROPNOWARN:
<span class="fc" id="L2548">                visitGetProp(node, child);</span>
<span class="fc" id="L2549">                break;</span>

              case Token.GETELEM:
<span class="nc" id="L2552">                generateExpression(child, node); // object</span>
<span class="nc" id="L2553">                generateExpression(child.getNext(), node);  // id</span>
<span class="nc" id="L2554">                cfw.addALoad(contextLocal);</span>
<span class="nc bnc" id="L2555" title="All 2 branches missed.">                if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) {</span>
<span class="nc" id="L2556">                    addScriptRuntimeInvoke(</span>
                        &quot;getObjectIndex&quot;,
                        &quot;(Ljava/lang/Object;D&quot;
                        +&quot;Lorg/mozilla/javascript/Context;&quot;
                        +&quot;)Ljava/lang/Object;&quot;);
                }
                else {
<span class="nc" id="L2563">                    cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L2564">                    addScriptRuntimeInvoke(</span>
                        &quot;getObjectElem&quot;,
                        &quot;(Ljava/lang/Object;&quot;
                        +&quot;Ljava/lang/Object;&quot;
                        +&quot;Lorg/mozilla/javascript/Context;&quot;
                        +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                        +&quot;)Ljava/lang/Object;&quot;);
                }
<span class="nc" id="L2572">                break;</span>

              case Token.GET_REF:
<span class="nc" id="L2575">                generateExpression(child, node); // reference</span>
<span class="nc" id="L2576">                cfw.addALoad(contextLocal);</span>
<span class="nc" id="L2577">                addScriptRuntimeInvoke(</span>
                    &quot;refGet&quot;,
                    &quot;(Lorg/mozilla/javascript/Ref;&quot;
                    +&quot;Lorg/mozilla/javascript/Context;&quot;
                    +&quot;)Ljava/lang/Object;&quot;);
<span class="nc" id="L2582">                break;</span>

              case Token.GETVAR:
<span class="nc" id="L2585">                visitGetVar(node);</span>
<span class="nc" id="L2586">                break;</span>

              case Token.SETVAR:
<span class="nc" id="L2589">                visitSetVar(node, child, true);</span>
<span class="nc" id="L2590">                break;</span>

              case Token.SETNAME:
<span class="nc" id="L2593">                visitSetName(node, child);</span>
<span class="nc" id="L2594">                break;</span>

              case Token.STRICT_SETNAME:
<span class="nc" id="L2597">                  visitStrictSetName(node, child);</span>
<span class="nc" id="L2598">                  break;</span>

              case Token.SETCONST:
<span class="nc" id="L2601">                visitSetConst(node, child);</span>
<span class="nc" id="L2602">                break;</span>

              case Token.SETCONSTVAR:
<span class="nc" id="L2605">                visitSetConstVar(node, child, true);</span>
<span class="nc" id="L2606">                break;</span>

              case Token.SETPROP:
              case Token.SETPROP_OP:
<span class="nc" id="L2610">                visitSetProp(type, node, child);</span>
<span class="nc" id="L2611">                break;</span>

              case Token.SETELEM:
              case Token.SETELEM_OP:
<span class="nc" id="L2615">                visitSetElem(type, node, child);</span>
<span class="nc" id="L2616">                break;</span>

              case Token.SET_REF:
              case Token.SET_REF_OP:
                {
<span class="nc" id="L2621">                    generateExpression(child, node);</span>
<span class="nc" id="L2622">                    child = child.getNext();</span>
<span class="nc bnc" id="L2623" title="All 2 branches missed.">                    if (type == Token.SET_REF_OP) {</span>
<span class="nc" id="L2624">                        cfw.add(ByteCode.DUP);</span>
<span class="nc" id="L2625">                        cfw.addALoad(contextLocal);</span>
<span class="nc" id="L2626">                        addScriptRuntimeInvoke(</span>
                            &quot;refGet&quot;,
                            &quot;(Lorg/mozilla/javascript/Ref;&quot;
                            +&quot;Lorg/mozilla/javascript/Context;&quot;
                            +&quot;)Ljava/lang/Object;&quot;);
                    }
<span class="nc" id="L2632">                    generateExpression(child, node);</span>
<span class="nc" id="L2633">                    cfw.addALoad(contextLocal);</span>
<span class="nc" id="L2634">                    cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L2635">                    addScriptRuntimeInvoke(</span>
                        &quot;refSet&quot;,
                        &quot;(Lorg/mozilla/javascript/Ref;&quot;
                        +&quot;Ljava/lang/Object;&quot;
                        +&quot;Lorg/mozilla/javascript/Context;&quot;
                        +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                        +&quot;)Ljava/lang/Object;&quot;);
                }
<span class="nc" id="L2643">                break;</span>

              case Token.DEL_REF:
<span class="nc" id="L2646">                generateExpression(child, node);</span>
<span class="nc" id="L2647">                cfw.addALoad(contextLocal);</span>
<span class="nc" id="L2648">                addScriptRuntimeInvoke(&quot;refDel&quot;,</span>
                                       &quot;(Lorg/mozilla/javascript/Ref;&quot;
                                       +&quot;Lorg/mozilla/javascript/Context;&quot;
                                       +&quot;)Ljava/lang/Object;&quot;);
<span class="nc" id="L2652">                break;</span>

              case Token.DELPROP:
<span class="nc bnc" id="L2655" title="All 2 branches missed.">                boolean isName = child.getType() == Token.BINDNAME;</span>
<span class="nc" id="L2656">                generateExpression(child, node);</span>
<span class="nc" id="L2657">                child = child.getNext();</span>
<span class="nc" id="L2658">                generateExpression(child, node);</span>
<span class="nc" id="L2659">                cfw.addALoad(contextLocal);</span>
<span class="nc" id="L2660">                cfw.addPush(isName);</span>
<span class="nc" id="L2661">                addScriptRuntimeInvoke(&quot;delete&quot;,</span>
                                       &quot;(Ljava/lang/Object;&quot;
                                       +&quot;Ljava/lang/Object;&quot;
                                       +&quot;Lorg/mozilla/javascript/Context;&quot;
                                       +&quot;Z)Ljava/lang/Object;&quot;);
<span class="nc" id="L2666">                break;</span>

              case Token.BINDNAME:
                {
<span class="nc bnc" id="L2670" title="All 2 branches missed.">                    while (child != null) {</span>
<span class="nc" id="L2671">                        generateExpression(child, node);</span>
<span class="nc" id="L2672">                        child = child.getNext();</span>
                    }
                    // Generate code for &quot;ScriptRuntime.bind(varObj, &quot;s&quot;)&quot;
<span class="nc" id="L2675">                    cfw.addALoad(contextLocal);</span>
<span class="nc" id="L2676">                    cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L2677">                    cfw.addPush(node.getString());</span>
<span class="nc" id="L2678">                    addScriptRuntimeInvoke(</span>
                        &quot;bind&quot;,
                        &quot;(Lorg/mozilla/javascript/Context;&quot;
                        +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                        +&quot;Ljava/lang/String;&quot;
                        +&quot;)Lorg/mozilla/javascript/Scriptable;&quot;);
                }
<span class="nc" id="L2685">                break;</span>

              case Token.LOCAL_LOAD:
<span class="nc" id="L2688">                cfw.addALoad(getLocalBlockRegister(node));</span>
<span class="nc" id="L2689">                break;</span>

              case Token.REF_SPECIAL:
                {
<span class="nc" id="L2693">                    String special = (String)node.getProp(Node.NAME_PROP);</span>
<span class="nc" id="L2694">                    generateExpression(child, node);</span>
<span class="nc" id="L2695">                    cfw.addPush(special);</span>
<span class="nc" id="L2696">                    cfw.addALoad(contextLocal);</span>
<span class="nc" id="L2697">                    cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L2698">                    addScriptRuntimeInvoke(</span>
                        &quot;specialRef&quot;,
                        &quot;(Ljava/lang/Object;&quot;
                        +&quot;Ljava/lang/String;&quot;
                        +&quot;Lorg/mozilla/javascript/Context;&quot;
                        +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                        +&quot;)Lorg/mozilla/javascript/Ref;&quot;);
                }
<span class="nc" id="L2706">                break;</span>

              case Token.REF_MEMBER:
              case Token.REF_NS_MEMBER:
              case Token.REF_NAME:
              case Token.REF_NS_NAME:
                {
<span class="nc" id="L2713">                    int memberTypeFlags</span>
<span class="nc" id="L2714">                        = node.getIntProp(Node.MEMBER_TYPE_PROP, 0);</span>
                    // generate possible target, possible namespace and member
                    do {
<span class="nc" id="L2717">                        generateExpression(child, node);</span>
<span class="nc" id="L2718">                        child = child.getNext();</span>
<span class="nc bnc" id="L2719" title="All 2 branches missed.">                    } while (child != null);</span>
<span class="nc" id="L2720">                    cfw.addALoad(contextLocal);</span>
                    String methodName, signature;
<span class="nc bnc" id="L2722" title="All 5 branches missed.">                    switch (type) {</span>
                      case Token.REF_MEMBER:
<span class="nc" id="L2724">                        methodName = &quot;memberRef&quot;;</span>
<span class="nc" id="L2725">                        signature = &quot;(Ljava/lang/Object;&quot;</span>
                                    +&quot;Ljava/lang/Object;&quot;
                                    +&quot;Lorg/mozilla/javascript/Context;&quot;
                                    +&quot;I&quot;
                                    +&quot;)Lorg/mozilla/javascript/Ref;&quot;;
<span class="nc" id="L2730">                        break;</span>
                      case Token.REF_NS_MEMBER:
<span class="nc" id="L2732">                        methodName = &quot;memberRef&quot;;</span>
<span class="nc" id="L2733">                        signature = &quot;(Ljava/lang/Object;&quot;</span>
                                    +&quot;Ljava/lang/Object;&quot;
                                    +&quot;Ljava/lang/Object;&quot;
                                    +&quot;Lorg/mozilla/javascript/Context;&quot;
                                    +&quot;I&quot;
                                    +&quot;)Lorg/mozilla/javascript/Ref;&quot;;
<span class="nc" id="L2739">                        break;</span>
                      case Token.REF_NAME:
<span class="nc" id="L2741">                        methodName = &quot;nameRef&quot;;</span>
<span class="nc" id="L2742">                        signature = &quot;(Ljava/lang/Object;&quot;</span>
                                    +&quot;Lorg/mozilla/javascript/Context;&quot;
                                    +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                                    +&quot;I&quot;
                                    +&quot;)Lorg/mozilla/javascript/Ref;&quot;;
<span class="nc" id="L2747">                        cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L2748">                        break;</span>
                      case Token.REF_NS_NAME:
<span class="nc" id="L2750">                        methodName = &quot;nameRef&quot;;</span>
<span class="nc" id="L2751">                        signature = &quot;(Ljava/lang/Object;&quot;</span>
                                    +&quot;Ljava/lang/Object;&quot;
                                    +&quot;Lorg/mozilla/javascript/Context;&quot;
                                    +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                                    +&quot;I&quot;
                                    +&quot;)Lorg/mozilla/javascript/Ref;&quot;;
<span class="nc" id="L2757">                        cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L2758">                        break;</span>
                      default:
<span class="nc" id="L2760">                        throw Kit.codeBug();</span>
                    }
<span class="nc" id="L2762">                    cfw.addPush(memberTypeFlags);</span>
<span class="nc" id="L2763">                    addScriptRuntimeInvoke(methodName, signature);</span>
                }
<span class="nc" id="L2765">                break;</span>

              case Token.DOTQUERY:
<span class="nc" id="L2768">                visitDotQuery(node, child);</span>
<span class="nc" id="L2769">                break;</span>

              case Token.ESCXMLATTR:
<span class="nc" id="L2772">                generateExpression(child, node);</span>
<span class="nc" id="L2773">                cfw.addALoad(contextLocal);</span>
<span class="nc" id="L2774">                addScriptRuntimeInvoke(&quot;escapeAttributeValue&quot;,</span>
                                       &quot;(Ljava/lang/Object;&quot;
                                       +&quot;Lorg/mozilla/javascript/Context;&quot;
                                       +&quot;)Ljava/lang/String;&quot;);
<span class="nc" id="L2778">                break;</span>

              case Token.ESCXMLTEXT:
<span class="nc" id="L2781">                generateExpression(child, node);</span>
<span class="nc" id="L2782">                cfw.addALoad(contextLocal);</span>
<span class="nc" id="L2783">                addScriptRuntimeInvoke(&quot;escapeTextValue&quot;,</span>
                                       &quot;(Ljava/lang/Object;&quot;
                                       +&quot;Lorg/mozilla/javascript/Context;&quot;
                                       +&quot;)Ljava/lang/String;&quot;);
<span class="nc" id="L2787">                break;</span>

              case Token.DEFAULTNAMESPACE:
<span class="nc" id="L2790">                generateExpression(child, node);</span>
<span class="nc" id="L2791">                cfw.addALoad(contextLocal);</span>
<span class="nc" id="L2792">                addScriptRuntimeInvoke(&quot;setDefaultNamespace&quot;,</span>
                                       &quot;(Ljava/lang/Object;&quot;
                                       +&quot;Lorg/mozilla/javascript/Context;&quot;
                                       +&quot;)Ljava/lang/Object;&quot;);
<span class="nc" id="L2796">                break;</span>

              case Token.YIELD:
<span class="nc" id="L2799">                generateYieldPoint(node, true);</span>
<span class="nc" id="L2800">                break;</span>

              case Token.WITHEXPR: {
<span class="nc" id="L2803">                Node enterWith = child;</span>
<span class="nc" id="L2804">                Node with = enterWith.getNext();</span>
<span class="nc" id="L2805">                Node leaveWith = with.getNext();</span>
<span class="nc" id="L2806">                generateStatement(enterWith);</span>
<span class="nc" id="L2807">                generateExpression(with.getFirstChild(), with);</span>
<span class="nc" id="L2808">                generateStatement(leaveWith);</span>
<span class="nc" id="L2809">                break;</span>
              }

              case Token.ARRAYCOMP: {
<span class="nc" id="L2813">                Node initStmt = child;</span>
<span class="nc" id="L2814">                Node expr = child.getNext();</span>
<span class="nc" id="L2815">                generateStatement(initStmt);</span>
<span class="nc" id="L2816">                generateExpression(expr, node);</span>
<span class="nc" id="L2817">                break;</span>
              }

              default:
<span class="nc" id="L2821">                throw new RuntimeException(&quot;Unexpected node type &quot;+type);</span>
        }

<span class="fc" id="L2824">    }</span>

    private void generateYieldPoint(Node node, boolean exprContext) {
        // save stack state
<span class="nc" id="L2828">        int top = cfw.getStackTop();</span>
<span class="nc bnc" id="L2829" title="All 2 branches missed.">        maxStack = maxStack &gt; top ? maxStack : top;</span>
<span class="nc bnc" id="L2830" title="All 2 branches missed.">        if (cfw.getStackTop() != 0) {</span>
<span class="nc" id="L2831">            generateGetGeneratorStackState();</span>
<span class="nc bnc" id="L2832" title="All 2 branches missed.">            for (int i = 0; i &lt; top; i++) {</span>
<span class="nc" id="L2833">                cfw.add(ByteCode.DUP_X1);</span>
<span class="nc" id="L2834">                cfw.add(ByteCode.SWAP);</span>
<span class="nc" id="L2835">                cfw.addLoadConstant(i);</span>
<span class="nc" id="L2836">                cfw.add(ByteCode.SWAP);</span>
<span class="nc" id="L2837">                cfw.add(ByteCode.AASTORE);</span>
            }
            // pop the array object
<span class="nc" id="L2840">            cfw.add(ByteCode.POP);</span>
        }

        // generate the yield argument
<span class="nc" id="L2844">        Node child = node.getFirstChild();</span>
<span class="nc bnc" id="L2845" title="All 2 branches missed.">        if (child != null)</span>
<span class="nc" id="L2846">            generateExpression(child, node);</span>
        else
<span class="nc" id="L2848">            Codegen.pushUndefined(cfw);</span>

        // change the resumption state
<span class="nc" id="L2851">        int nextState = getNextGeneratorState(node);</span>
<span class="nc" id="L2852">        generateSetGeneratorResumptionPoint(nextState);</span>

<span class="nc" id="L2854">        boolean hasLocals = generateSaveLocals(node);</span>

<span class="nc" id="L2856">        cfw.add(ByteCode.ARETURN);</span>

<span class="nc" id="L2858">        generateCheckForThrowOrClose(getTargetLabel(node),</span>
                hasLocals, nextState);

        // reconstruct the stack
<span class="nc bnc" id="L2862" title="All 2 branches missed.">        if (top != 0) {</span>
<span class="nc" id="L2863">            generateGetGeneratorStackState();</span>
<span class="nc bnc" id="L2864" title="All 2 branches missed.">            for (int i = 0; i &lt; top; i++) {</span>
<span class="nc" id="L2865">                cfw.add(ByteCode.DUP);</span>
<span class="nc" id="L2866">                cfw.addLoadConstant(top - i - 1);</span>
<span class="nc" id="L2867">                cfw.add(ByteCode.AALOAD);</span>
<span class="nc" id="L2868">                cfw.add(ByteCode.SWAP);</span>
            }
<span class="nc" id="L2870">            cfw.add(ByteCode.POP);</span>
        }

        // load return value from yield
<span class="nc bnc" id="L2874" title="All 2 branches missed.">        if (exprContext) {</span>
<span class="nc" id="L2875">            cfw.addALoad(argsLocal);</span>
        }
<span class="nc" id="L2877">    }</span>

    private void generateCheckForThrowOrClose(int label,
                                              boolean hasLocals,
                                              int nextState) {
<span class="nc" id="L2882">        int throwLabel = cfw.acquireLabel();</span>
<span class="nc" id="L2883">        int closeLabel = cfw.acquireLabel();</span>

        // throw the user provided object, if the operation is .throw()
<span class="nc" id="L2886">        cfw.markLabel(throwLabel);</span>
<span class="nc" id="L2887">        cfw.addALoad(argsLocal);</span>
<span class="nc" id="L2888">        generateThrowJavaScriptException();</span>

        // throw our special internal exception if the generator is being closed
<span class="nc" id="L2891">        cfw.markLabel(closeLabel);</span>
<span class="nc" id="L2892">        cfw.addALoad(argsLocal);</span>
<span class="nc" id="L2893">        cfw.add(ByteCode.CHECKCAST, &quot;java/lang/Throwable&quot;);</span>
<span class="nc" id="L2894">        cfw.add(ByteCode.ATHROW);</span>

        // mark the re-entry point
        // jump here after initializing the locals
<span class="nc bnc" id="L2898" title="All 2 branches missed.">        if (label != -1)</span>
<span class="nc" id="L2899">            cfw.markLabel(label);</span>
<span class="nc bnc" id="L2900" title="All 2 branches missed.">        if (!hasLocals) {</span>
            // jump here directly if there are no locals
<span class="nc" id="L2902">            cfw.markTableSwitchCase(generatorSwitch, nextState);</span>
        }

        // see if we need to dispatch for .close() or .throw()
<span class="nc" id="L2906">        cfw.addILoad(operationLocal);</span>
<span class="nc" id="L2907">        cfw.addLoadConstant(NativeGenerator.GENERATOR_CLOSE);</span>
<span class="nc" id="L2908">        cfw.add(ByteCode.IF_ICMPEQ, closeLabel);</span>
<span class="nc" id="L2909">        cfw.addILoad(operationLocal);</span>
<span class="nc" id="L2910">        cfw.addLoadConstant(NativeGenerator.GENERATOR_THROW);</span>
<span class="nc" id="L2911">        cfw.add(ByteCode.IF_ICMPEQ, throwLabel);</span>
<span class="nc" id="L2912">    }</span>

    private void generateIfJump(Node node, Node parent,
                                int trueLabel, int falseLabel)
    {
        // System.out.println(&quot;gen code for &quot; + node.toString());

<span class="nc" id="L2919">        int type = node.getType();</span>
<span class="nc" id="L2920">        Node child = node.getFirstChild();</span>

<span class="nc bnc" id="L2922" title="All 5 branches missed.">        switch (type) {</span>
          case Token.NOT:
<span class="nc" id="L2924">            generateIfJump(child, node, falseLabel, trueLabel);</span>
<span class="nc" id="L2925">            break;</span>

          case Token.OR:
          case Token.AND: {
<span class="nc" id="L2929">            int interLabel = cfw.acquireLabel();</span>
<span class="nc bnc" id="L2930" title="All 2 branches missed.">            if (type == Token.AND) {</span>
<span class="nc" id="L2931">                generateIfJump(child, node, interLabel, falseLabel);</span>
            }
            else {
<span class="nc" id="L2934">                generateIfJump(child, node, trueLabel, interLabel);</span>
            }
<span class="nc" id="L2936">            cfw.markLabel(interLabel);</span>
<span class="nc" id="L2937">            child = child.getNext();</span>
<span class="nc" id="L2938">            generateIfJump(child, node, trueLabel, falseLabel);</span>
<span class="nc" id="L2939">            break;</span>
          }

          case Token.IN:
          case Token.INSTANCEOF:
          case Token.LE:
          case Token.LT:
          case Token.GE:
          case Token.GT:
<span class="nc" id="L2948">            visitIfJumpRelOp(node, child, trueLabel, falseLabel);</span>
<span class="nc" id="L2949">            break;</span>

          case Token.EQ:
          case Token.NE:
          case Token.SHEQ:
          case Token.SHNE:
<span class="nc" id="L2955">            visitIfJumpEqOp(node, child, trueLabel, falseLabel);</span>
<span class="nc" id="L2956">            break;</span>

          default:
            // Generate generic code for non-optimized jump
<span class="nc" id="L2960">            generateExpression(node, parent);</span>
<span class="nc" id="L2961">            addScriptRuntimeInvoke(&quot;toBoolean&quot;, &quot;(Ljava/lang/Object;)Z&quot;);</span>
<span class="nc" id="L2962">            cfw.add(ByteCode.IFNE, trueLabel);</span>
<span class="nc" id="L2963">            cfw.add(ByteCode.GOTO, falseLabel);</span>
        }
<span class="nc" id="L2965">    }</span>

    private void visitFunction(OptFunctionNode ofn, int functionType)
    {
<span class="nc" id="L2969">        int fnIndex = codegen.getIndex(ofn.fnode);</span>
<span class="nc" id="L2970">        cfw.add(ByteCode.NEW, codegen.mainClassName);</span>
        // Call function constructor
<span class="nc" id="L2972">        cfw.add(ByteCode.DUP);</span>
<span class="nc" id="L2973">        cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L2974">        cfw.addALoad(contextLocal);           // load 'cx'</span>
<span class="nc" id="L2975">        cfw.addPush(fnIndex);</span>
<span class="nc" id="L2976">        cfw.addInvoke(ByteCode.INVOKESPECIAL, codegen.mainClassName,</span>
                      &quot;&lt;init&gt;&quot;, Codegen.FUNCTION_CONSTRUCTOR_SIGNATURE);

<span class="nc bnc" id="L2979" title="All 2 branches missed.">        if (functionType == FunctionNode.ARROW_FUNCTION) {</span>
<span class="nc" id="L2980">            cfw.addALoad(contextLocal);           // load 'cx'</span>
<span class="nc" id="L2981">            cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L2982">            cfw.addALoad(thisObjLocal);</span>
<span class="nc" id="L2983">            addOptRuntimeInvoke(&quot;bindThis&quot;,</span>
                                &quot;(Lorg/mozilla/javascript/NativeFunction;&quot;
                                +&quot;Lorg/mozilla/javascript/Context;&quot;
                                +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                                +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                                +&quot;)Lorg/mozilla/javascript/Function;&quot;);
        }

<span class="nc bnc" id="L2991" title="All 4 branches missed.">        if (functionType == FunctionNode.FUNCTION_EXPRESSION ||</span>
            functionType == FunctionNode.ARROW_FUNCTION) {
            // Leave closure object on stack and do not pass it to
            // initFunction which suppose to connect statements to scope
<span class="nc" id="L2995">            return;</span>
        }
<span class="nc" id="L2997">        cfw.addPush(functionType);</span>
<span class="nc" id="L2998">        cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L2999">        cfw.addALoad(contextLocal);           // load 'cx'</span>
<span class="nc" id="L3000">        addOptRuntimeInvoke(&quot;initFunction&quot;,</span>
                            &quot;(Lorg/mozilla/javascript/NativeFunction;&quot;
                            +&quot;I&quot;
                            +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                            +&quot;Lorg/mozilla/javascript/Context;&quot;
                            +&quot;)V&quot;);
<span class="nc" id="L3006">    }</span>

    private int getTargetLabel(Node target)
    {
<span class="nc" id="L3010">        int labelId = target.labelId();</span>
<span class="nc bnc" id="L3011" title="All 2 branches missed.">        if (labelId == -1) {</span>
<span class="nc" id="L3012">            labelId = cfw.acquireLabel();</span>
<span class="nc" id="L3013">            target.labelId(labelId);</span>
        }
<span class="nc" id="L3015">        return labelId;</span>
    }

    private void visitGoto(Jump node, int type, Node child)
    {
<span class="nc" id="L3020">        Node target = node.target;</span>
<span class="nc bnc" id="L3021" title="All 4 branches missed.">        if (type == Token.IFEQ || type == Token.IFNE) {</span>
<span class="nc bnc" id="L3022" title="All 2 branches missed.">            if (child == null) throw Codegen.badTree();</span>
<span class="nc" id="L3023">            int targetLabel = getTargetLabel(target);</span>
<span class="nc" id="L3024">            int fallThruLabel = cfw.acquireLabel();</span>
<span class="nc bnc" id="L3025" title="All 2 branches missed.">            if (type == Token.IFEQ)</span>
<span class="nc" id="L3026">                generateIfJump(child, node, targetLabel, fallThruLabel);</span>
            else
<span class="nc" id="L3028">                generateIfJump(child, node, fallThruLabel, targetLabel);</span>
<span class="nc" id="L3029">            cfw.markLabel(fallThruLabel);</span>
<span class="nc" id="L3030">        } else {</span>
<span class="nc bnc" id="L3031" title="All 2 branches missed.">            if (type == Token.JSR) {</span>
<span class="nc bnc" id="L3032" title="All 2 branches missed.">                if (isGenerator) {</span>
<span class="nc" id="L3033">                    addGotoWithReturn(target);</span>
                } else {
                    // This assumes that JSR is only ever used for finally
<span class="nc" id="L3036">                    inlineFinally(target);</span>
                }
            } else {
<span class="nc" id="L3039">                addGoto(target, ByteCode.GOTO);</span>
            }
        }
<span class="nc" id="L3042">    }</span>

    private void addGotoWithReturn(Node target) {
<span class="nc" id="L3045">        FinallyReturnPoint ret = finallys.get(target);</span>
<span class="nc" id="L3046">        cfw.addLoadConstant(ret.jsrPoints.size());</span>
<span class="nc" id="L3047">        addGoto(target, ByteCode.GOTO);</span>
<span class="nc" id="L3048">        int retLabel = cfw.acquireLabel();</span>
<span class="nc" id="L3049">        cfw.markLabel(retLabel);</span>
<span class="nc" id="L3050">        ret.jsrPoints.add(Integer.valueOf(retLabel));</span>
<span class="nc" id="L3051">    }</span>

    private void generateArrayLiteralFactory(Node node, int count) {
<span class="nc" id="L3054">        String methodName = codegen.getBodyMethodName(scriptOrFn) + &quot;_literal&quot; + count;</span>
<span class="nc" id="L3055">        initBodyGeneration();</span>
<span class="nc" id="L3056">        argsLocal = firstFreeLocal++;</span>
<span class="nc" id="L3057">        localsMax = firstFreeLocal;</span>
<span class="nc" id="L3058">        cfw.startMethod(methodName, &quot;(Lorg/mozilla/javascript/Context;&quot;</span>
                +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                +&quot;[Ljava/lang/Object;&quot;
                +&quot;)Lorg/mozilla/javascript/Scriptable;&quot;,
                ACC_PRIVATE);
<span class="nc" id="L3064">        visitArrayLiteral(node, node.getFirstChild(), true);</span>
<span class="nc" id="L3065">        cfw.add(ByteCode.ARETURN);</span>
<span class="nc" id="L3066">        cfw.stopMethod((short)(localsMax + 1));</span>
<span class="nc" id="L3067">    }</span>

    private void generateObjectLiteralFactory(Node node, int count) {
<span class="nc" id="L3070">        String methodName = codegen.getBodyMethodName(scriptOrFn) + &quot;_literal&quot; + count;</span>
<span class="nc" id="L3071">        initBodyGeneration();</span>
<span class="nc" id="L3072">        argsLocal = firstFreeLocal++;</span>
<span class="nc" id="L3073">        localsMax = firstFreeLocal;</span>
<span class="nc" id="L3074">        cfw.startMethod(methodName, &quot;(Lorg/mozilla/javascript/Context;&quot;</span>
                +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                +&quot;[Ljava/lang/Object;&quot;
                +&quot;)Lorg/mozilla/javascript/Scriptable;&quot;,
                ACC_PRIVATE);
<span class="nc" id="L3080">        visitObjectLiteral(node, node.getFirstChild(), true);</span>
<span class="nc" id="L3081">        cfw.add(ByteCode.ARETURN);</span>
<span class="nc" id="L3082">        cfw.stopMethod((short)(localsMax + 1));</span>
<span class="nc" id="L3083">    }</span>


    private void visitArrayLiteral(Node node, Node child, boolean topLevel)
    {
<span class="nc" id="L3088">        int count = 0;</span>
<span class="nc bnc" id="L3089" title="All 2 branches missed.">        for (Node cursor = child; cursor != null; cursor = cursor.getNext()) {</span>
<span class="nc" id="L3090">            ++count;</span>
        }

        // If code budget is tight swap out literals into separate method
<span class="nc bnc" id="L3094" title="All 12 branches missed.">        if (!topLevel &amp;&amp; (count &gt; 10 || cfw.getCurrentCodeOffset() &gt; 30000)</span>
                &amp;&amp; !hasVarsInRegs &amp;&amp; !isGenerator &amp;&amp; !inLocalBlock) {
<span class="nc bnc" id="L3096" title="All 2 branches missed.">            if (literals == null) {</span>
<span class="nc" id="L3097">                literals = new LinkedList&lt;Node&gt;();</span>
            }
<span class="nc" id="L3099">            literals.add(node);</span>
<span class="nc" id="L3100">            String methodName = codegen.getBodyMethodName(scriptOrFn) + &quot;_literal&quot; + literals.size();</span>
<span class="nc" id="L3101">            cfw.addALoad(funObjLocal);</span>
<span class="nc" id="L3102">            cfw.addALoad(contextLocal);</span>
<span class="nc" id="L3103">            cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L3104">            cfw.addALoad(thisObjLocal);</span>
<span class="nc" id="L3105">            cfw.addALoad(argsLocal);</span>
<span class="nc" id="L3106">            cfw.addInvoke(ByteCode.INVOKEVIRTUAL, codegen.mainClassName, methodName,</span>
                    &quot;(Lorg/mozilla/javascript/Context;&quot;
                        +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                        +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                        +&quot;[Ljava/lang/Object;&quot;
                        +&quot;)Lorg/mozilla/javascript/Scriptable;&quot;);
<span class="nc" id="L3112">            return;</span>
        }

        // load array to store array literal objects
<span class="nc bnc" id="L3116" title="All 2 branches missed.">        if (isGenerator) {</span>
            // TODO: this is actually only necessary if the yield operation is
            // a child of this array or its children (bug 757410)
<span class="nc bnc" id="L3119" title="All 2 branches missed.">            for (int i = 0; i != count; ++i) {</span>
<span class="nc" id="L3120">                generateExpression(child, node);</span>
<span class="nc" id="L3121">                child = child.getNext();</span>
            }
<span class="nc" id="L3123">            addNewObjectArray(count);</span>
<span class="nc bnc" id="L3124" title="All 2 branches missed.">            for (int i = 0; i != count; ++i) {</span>
<span class="nc" id="L3125">                cfw.add(ByteCode.DUP_X1);</span>
<span class="nc" id="L3126">                cfw.add(ByteCode.SWAP);</span>
<span class="nc" id="L3127">                cfw.addPush(count - i - 1);</span>
<span class="nc" id="L3128">                cfw.add(ByteCode.SWAP);</span>
<span class="nc" id="L3129">                cfw.add(ByteCode.AASTORE);</span>
            }
        } else {
<span class="nc" id="L3132">            addNewObjectArray(count);</span>
<span class="nc bnc" id="L3133" title="All 2 branches missed.">            for (int i = 0; i != count; ++i) {</span>
<span class="nc" id="L3134">                cfw.add(ByteCode.DUP);</span>
<span class="nc" id="L3135">                cfw.addPush(i);</span>
<span class="nc" id="L3136">                generateExpression(child, node);</span>
<span class="nc" id="L3137">                cfw.add(ByteCode.AASTORE);</span>
<span class="nc" id="L3138">                child = child.getNext();</span>
            }
        }
<span class="nc" id="L3141">        int[] skipIndexes = (int[])node.getProp(Node.SKIP_INDEXES_PROP);</span>
<span class="nc bnc" id="L3142" title="All 2 branches missed.">        if (skipIndexes == null) {</span>
<span class="nc" id="L3143">            cfw.add(ByteCode.ACONST_NULL);</span>
<span class="nc" id="L3144">            cfw.add(ByteCode.ICONST_0);</span>
        } else {
<span class="nc" id="L3146">            cfw.addPush(OptRuntime.encodeIntArray(skipIndexes));</span>
<span class="nc" id="L3147">            cfw.addPush(skipIndexes.length);</span>
        }
<span class="nc" id="L3149">        cfw.addALoad(contextLocal);</span>
<span class="nc" id="L3150">        cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L3151">        addOptRuntimeInvoke(&quot;newArrayLiteral&quot;,</span>
             &quot;([Ljava/lang/Object;&quot;
             +&quot;Ljava/lang/String;&quot;
             +&quot;I&quot;
             +&quot;Lorg/mozilla/javascript/Context;&quot;
             +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
             +&quot;)Lorg/mozilla/javascript/Scriptable;&quot;);
<span class="nc" id="L3158">    }</span>

    /** load array with property ids */
    private void addLoadPropertyIds(Object[] properties, int count) {
<span class="nc" id="L3162">        addNewObjectArray(count);</span>
<span class="nc bnc" id="L3163" title="All 2 branches missed.">        for (int i = 0; i != count; ++i) {</span>
<span class="nc" id="L3164">            cfw.add(ByteCode.DUP);</span>
<span class="nc" id="L3165">            cfw.addPush(i);</span>
<span class="nc" id="L3166">            Object id = properties[i];</span>
<span class="nc bnc" id="L3167" title="All 2 branches missed.">            if (id instanceof String) {</span>
<span class="nc" id="L3168">                cfw.addPush((String)id);</span>
            } else {
<span class="nc" id="L3170">                cfw.addPush(((Integer)id).intValue());</span>
<span class="nc" id="L3171">                addScriptRuntimeInvoke(&quot;wrapInt&quot;, &quot;(I)Ljava/lang/Integer;&quot;);</span>
            }
<span class="nc" id="L3173">            cfw.add(ByteCode.AASTORE);</span>
        }
<span class="nc" id="L3175">    }</span>

    /** load array with property values */
    private void addLoadPropertyValues(Node node, Node child, int count) {
<span class="nc bnc" id="L3179" title="All 2 branches missed.">        if (isGenerator) {</span>
            // see bug 757410 for an explanation why we need to split this
<span class="nc bnc" id="L3181" title="All 2 branches missed.">            for (int i = 0; i != count; ++i) {</span>
<span class="nc" id="L3182">                int childType = child.getType();</span>
<span class="nc bnc" id="L3183" title="All 6 branches missed.">                if (childType == Token.GET || childType == Token.SET || childType == Token.METHOD) {</span>
<span class="nc" id="L3184">                    generateExpression(child.getFirstChild(), node);</span>
                } else {
<span class="nc" id="L3186">                    generateExpression(child, node);</span>
                }
<span class="nc" id="L3188">                child = child.getNext();</span>
            }
<span class="nc" id="L3190">            addNewObjectArray(count);</span>
<span class="nc bnc" id="L3191" title="All 2 branches missed.">            for (int i = 0; i != count; ++i) {</span>
<span class="nc" id="L3192">                cfw.add(ByteCode.DUP_X1);</span>
<span class="nc" id="L3193">                cfw.add(ByteCode.SWAP);</span>
<span class="nc" id="L3194">                cfw.addPush(count - i - 1);</span>
<span class="nc" id="L3195">                cfw.add(ByteCode.SWAP);</span>
<span class="nc" id="L3196">                cfw.add(ByteCode.AASTORE);</span>
            }
        } else {
<span class="nc" id="L3199">            addNewObjectArray(count);</span>
<span class="nc" id="L3200">            Node child2 = child;</span>
<span class="nc bnc" id="L3201" title="All 2 branches missed.">            for (int i = 0; i != count; ++i) {</span>
<span class="nc" id="L3202">                cfw.add(ByteCode.DUP);</span>
<span class="nc" id="L3203">                cfw.addPush(i);</span>
<span class="nc" id="L3204">                int childType = child2.getType();</span>
<span class="nc bnc" id="L3205" title="All 6 branches missed.">                if (childType == Token.GET || childType == Token.SET || childType == Token.METHOD) {</span>
<span class="nc" id="L3206">                    generateExpression(child2.getFirstChild(), node);</span>
                } else {
<span class="nc" id="L3208">                    generateExpression(child2, node);</span>
                }
<span class="nc" id="L3210">                cfw.add(ByteCode.AASTORE);</span>
<span class="nc" id="L3211">                child2 = child2.getNext();</span>
            }
        }
<span class="nc" id="L3214">    }</span>

    private void visitObjectLiteral(Node node, Node child, boolean topLevel)
    {
<span class="nc" id="L3218">        Object[] properties = (Object[])node.getProp(Node.OBJECT_IDS_PROP);</span>
<span class="nc" id="L3219">        int count = properties.length;</span>

        // If code budget is tight swap out literals into separate method
<span class="nc bnc" id="L3222" title="All 12 branches missed.">        if (!topLevel &amp;&amp; (count &gt; 10 || cfw.getCurrentCodeOffset() &gt; 30000)</span>
                &amp;&amp; !hasVarsInRegs &amp;&amp; !isGenerator &amp;&amp; !inLocalBlock) {
<span class="nc bnc" id="L3224" title="All 2 branches missed.">            if (literals == null) {</span>
<span class="nc" id="L3225">                literals = new LinkedList&lt;Node&gt;();</span>
            }
<span class="nc" id="L3227">            literals.add(node);</span>
<span class="nc" id="L3228">            String methodName = codegen.getBodyMethodName(scriptOrFn) + &quot;_literal&quot; + literals.size();</span>
<span class="nc" id="L3229">            cfw.addALoad(funObjLocal);</span>
<span class="nc" id="L3230">            cfw.addALoad(contextLocal);</span>
<span class="nc" id="L3231">            cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L3232">            cfw.addALoad(thisObjLocal);</span>
<span class="nc" id="L3233">            cfw.addALoad(argsLocal);</span>
<span class="nc" id="L3234">            cfw.addInvoke(ByteCode.INVOKEVIRTUAL, codegen.mainClassName, methodName,</span>
                    &quot;(Lorg/mozilla/javascript/Context;&quot;
                        +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                        +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                        +&quot;[Ljava/lang/Object;&quot;
                        +&quot;)Lorg/mozilla/javascript/Scriptable;&quot;);
<span class="nc" id="L3240">            return;</span>
        }

<span class="nc bnc" id="L3243" title="All 2 branches missed.">        if (isGenerator) {</span>
            // TODO: this is actually only necessary if the yield operation is
            // a child of this object or its children (bug 757410)
<span class="nc" id="L3246">            addLoadPropertyValues(node, child, count);</span>
<span class="nc" id="L3247">            addLoadPropertyIds(properties, count);</span>
            // swap property-values and property-ids arrays
<span class="nc" id="L3249">            cfw.add(ByteCode.SWAP);</span>
        } else {
<span class="nc" id="L3251">            addLoadPropertyIds(properties, count);</span>
<span class="nc" id="L3252">            addLoadPropertyValues(node, child, count);</span>
        }

        // check if object literal actually has any getters or setters
<span class="nc" id="L3256">        boolean hasGetterSetters = false;</span>
<span class="nc" id="L3257">        Node child2 = child;</span>
<span class="nc bnc" id="L3258" title="All 2 branches missed.">        for (int i = 0; i != count; ++i) {</span>
<span class="nc" id="L3259">            int childType = child2.getType();</span>
<span class="nc bnc" id="L3260" title="All 4 branches missed.">            if (childType == Token.GET || childType == Token.SET) {</span>
<span class="nc" id="L3261">                hasGetterSetters = true;</span>
<span class="nc" id="L3262">                break;</span>
            }
<span class="nc" id="L3264">            child2 = child2.getNext();</span>
        }
        // create getter/setter flag array
<span class="nc bnc" id="L3267" title="All 2 branches missed.">        if (hasGetterSetters) {</span>
<span class="nc" id="L3268">            cfw.addPush(count);</span>
<span class="nc" id="L3269">            cfw.add(ByteCode.NEWARRAY, ByteCode.T_INT);</span>
<span class="nc" id="L3270">            child2 = child;</span>
<span class="nc bnc" id="L3271" title="All 2 branches missed.">            for (int i = 0; i != count; ++i) {</span>
<span class="nc" id="L3272">                cfw.add(ByteCode.DUP);</span>
<span class="nc" id="L3273">                cfw.addPush(i);</span>
<span class="nc" id="L3274">                int childType = child2.getType();</span>
<span class="nc bnc" id="L3275" title="All 2 branches missed.">                if (childType == Token.GET) {</span>
<span class="nc" id="L3276">                    cfw.add(ByteCode.ICONST_M1);</span>
<span class="nc bnc" id="L3277" title="All 2 branches missed.">                } else if (childType == Token.SET) {</span>
<span class="nc" id="L3278">                    cfw.add(ByteCode.ICONST_1);</span>
                } else {
<span class="nc" id="L3280">                    cfw.add(ByteCode.ICONST_0);</span>
                }
<span class="nc" id="L3282">                cfw.add(ByteCode.IASTORE);</span>
<span class="nc" id="L3283">                child2 = child2.getNext();</span>
            }
        } else {
<span class="nc" id="L3286">            cfw.add(ByteCode.ACONST_NULL);</span>
        }

<span class="nc" id="L3289">        cfw.addALoad(contextLocal);</span>
<span class="nc" id="L3290">        cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L3291">        addScriptRuntimeInvoke(&quot;newObjectLiteral&quot;,</span>
             &quot;([Ljava/lang/Object;&quot;
             +&quot;[Ljava/lang/Object;&quot;
             +&quot;[I&quot;
             +&quot;Lorg/mozilla/javascript/Context;&quot;
             +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
             +&quot;)Lorg/mozilla/javascript/Scriptable;&quot;);
<span class="nc" id="L3298">    }</span>

    private void visitSpecialCall(Node node, int type, int specialType,
                                  Node child)
    {
<span class="nc" id="L3303">        cfw.addALoad(contextLocal);</span>

<span class="nc bnc" id="L3305" title="All 2 branches missed.">        if (type == Token.NEW) {</span>
<span class="nc" id="L3306">            generateExpression(child, node);</span>
            // stack: ... cx functionObj
        } else {
<span class="nc" id="L3309">            generateFunctionAndThisObj(child, node);</span>
            // stack: ... cx functionObj thisObj
        }
<span class="nc" id="L3312">        child = child.getNext();</span>

<span class="nc" id="L3314">        generateCallArgArray(node, child, false);</span>

        String methodName;
        String callSignature;

<span class="nc bnc" id="L3319" title="All 2 branches missed.">        if (type == Token.NEW) {</span>
<span class="nc" id="L3320">            methodName = &quot;newObjectSpecial&quot;;</span>
<span class="nc" id="L3321">            callSignature = &quot;(Lorg/mozilla/javascript/Context;&quot;</span>
                            +&quot;Ljava/lang/Object;&quot;
                            +&quot;[Ljava/lang/Object;&quot;
                            +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                            +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                            +&quot;I&quot; // call type
                            +&quot;)Ljava/lang/Object;&quot;;
<span class="nc" id="L3328">            cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L3329">            cfw.addALoad(thisObjLocal);</span>
<span class="nc" id="L3330">            cfw.addPush(specialType);</span>
        } else {
<span class="nc" id="L3332">            methodName = &quot;callSpecial&quot;;</span>
<span class="nc" id="L3333">            callSignature = &quot;(Lorg/mozilla/javascript/Context;&quot;</span>
                            +&quot;Lorg/mozilla/javascript/Callable;&quot;
                            +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                            +&quot;[Ljava/lang/Object;&quot;
                            +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                            +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                            +&quot;I&quot; // call type
                            +&quot;Ljava/lang/String;I&quot;  // filename, linenumber
                            +&quot;)Ljava/lang/Object;&quot;;
<span class="nc" id="L3342">            cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L3343">            cfw.addALoad(thisObjLocal);</span>
<span class="nc" id="L3344">            cfw.addPush(specialType);</span>
<span class="nc" id="L3345">            String sourceName = scriptOrFn.getSourceName();</span>
<span class="nc bnc" id="L3346" title="All 2 branches missed.">            cfw.addPush(sourceName == null ? &quot;&quot; : sourceName);</span>
<span class="nc" id="L3347">            cfw.addPush(itsLineNumber);</span>
        }

<span class="nc" id="L3350">        addOptRuntimeInvoke(methodName, callSignature);</span>
<span class="nc" id="L3351">    }</span>

    private void visitStandardCall(Node node, Node child)
    {
<span class="nc bnc" id="L3355" title="All 2 branches missed.">        if (node.getType() != Token.CALL) throw Codegen.badTree();</span>

<span class="nc" id="L3357">        Node firstArgChild = child.getNext();</span>
<span class="nc" id="L3358">        int childType = child.getType();</span>

        String methodName;
        String signature;

<span class="nc bnc" id="L3363" title="All 2 branches missed.">        if (firstArgChild == null) {</span>
<span class="nc bnc" id="L3364" title="All 2 branches missed.">            if (childType == Token.NAME) {</span>
                // name() call
<span class="nc" id="L3366">                String name = child.getString();</span>
<span class="nc" id="L3367">                cfw.addPush(name);</span>
<span class="nc" id="L3368">                methodName = &quot;callName0&quot;;</span>
<span class="nc" id="L3369">                signature = &quot;(Ljava/lang/String;&quot;</span>
                            +&quot;Lorg/mozilla/javascript/Context;&quot;
                            +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                            +&quot;)Ljava/lang/Object;&quot;;
<span class="nc bnc" id="L3373" title="All 2 branches missed.">            } else if (childType == Token.GETPROP) {</span>
                // x.name() call
<span class="nc" id="L3375">                Node propTarget = child.getFirstChild();</span>
<span class="nc" id="L3376">                generateExpression(propTarget, node);</span>
<span class="nc" id="L3377">                Node id = propTarget.getNext();</span>
<span class="nc" id="L3378">                String property = id.getString();</span>
<span class="nc" id="L3379">                cfw.addPush(property);</span>
<span class="nc" id="L3380">                methodName = &quot;callProp0&quot;;</span>
<span class="nc" id="L3381">                signature = &quot;(Ljava/lang/Object;&quot;</span>
                            +&quot;Ljava/lang/String;&quot;
                            +&quot;Lorg/mozilla/javascript/Context;&quot;
                            +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                            +&quot;)Ljava/lang/Object;&quot;;
<span class="nc bnc" id="L3386" title="All 2 branches missed.">            } else if (childType == Token.GETPROPNOWARN) {</span>
<span class="nc" id="L3387">                throw Kit.codeBug();</span>
            } else {
<span class="nc" id="L3389">                generateFunctionAndThisObj(child, node);</span>
<span class="nc" id="L3390">                methodName = &quot;call0&quot;;</span>
<span class="nc" id="L3391">                signature = &quot;(Lorg/mozilla/javascript/Callable;&quot;</span>
                            +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                            +&quot;Lorg/mozilla/javascript/Context;&quot;
                            +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                            +&quot;)Ljava/lang/Object;&quot;;
            }

<span class="nc bnc" id="L3398" title="All 2 branches missed.">        } else if (childType == Token.NAME) {</span>
            // XXX: this optimization is only possible if name
            // resolution
            // is not affected by arguments evaluation and currently
            // there are no checks for it
<span class="nc" id="L3403">            String name = child.getString();</span>
<span class="nc" id="L3404">            generateCallArgArray(node, firstArgChild, false);</span>
<span class="nc" id="L3405">            cfw.addPush(name);</span>
<span class="nc" id="L3406">            methodName = &quot;callName&quot;;</span>
<span class="nc" id="L3407">            signature = &quot;([Ljava/lang/Object;&quot;</span>
                        +&quot;Ljava/lang/String;&quot;
                        +&quot;Lorg/mozilla/javascript/Context;&quot;
                        +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                        +&quot;)Ljava/lang/Object;&quot;;
<span class="nc" id="L3412">        } else {</span>
<span class="nc" id="L3413">            int argCount = 0;</span>
<span class="nc bnc" id="L3414" title="All 2 branches missed.">            for (Node arg = firstArgChild; arg != null; arg = arg.getNext()) {</span>
<span class="nc" id="L3415">                ++argCount;</span>
            }
<span class="nc" id="L3417">            generateFunctionAndThisObj(child, node);</span>
            // stack: ... functionObj thisObj
<span class="nc bnc" id="L3419" title="All 2 branches missed.">            if (argCount == 1) {</span>
<span class="nc" id="L3420">                generateExpression(firstArgChild, node);</span>
<span class="nc" id="L3421">                methodName = &quot;call1&quot;;</span>
<span class="nc" id="L3422">                signature = &quot;(Lorg/mozilla/javascript/Callable;&quot;</span>
                            +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                            +&quot;Ljava/lang/Object;&quot;
                            +&quot;Lorg/mozilla/javascript/Context;&quot;
                            +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                            +&quot;)Ljava/lang/Object;&quot;;
<span class="nc bnc" id="L3428" title="All 2 branches missed.">            } else if (argCount == 2) {</span>
<span class="nc" id="L3429">                generateExpression(firstArgChild, node);</span>
<span class="nc" id="L3430">                generateExpression(firstArgChild.getNext(), node);</span>
<span class="nc" id="L3431">                methodName = &quot;call2&quot;;</span>
<span class="nc" id="L3432">                signature = &quot;(Lorg/mozilla/javascript/Callable;&quot;</span>
                            +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                            +&quot;Ljava/lang/Object;&quot;
                            +&quot;Ljava/lang/Object;&quot;
                            +&quot;Lorg/mozilla/javascript/Context;&quot;
                            +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                            +&quot;)Ljava/lang/Object;&quot;;
            } else {
<span class="nc" id="L3440">                generateCallArgArray(node, firstArgChild, false);</span>
<span class="nc" id="L3441">                methodName = &quot;callN&quot;;</span>
<span class="nc" id="L3442">                signature = &quot;(Lorg/mozilla/javascript/Callable;&quot;</span>
                            +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                            +&quot;[Ljava/lang/Object;&quot;
                            +&quot;Lorg/mozilla/javascript/Context;&quot;
                            +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                            +&quot;)Ljava/lang/Object;&quot;;
            }
        }

<span class="nc" id="L3451">        cfw.addALoad(contextLocal);</span>
<span class="nc" id="L3452">        cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L3453">        addOptRuntimeInvoke(methodName, signature);</span>
<span class="nc" id="L3454">    }</span>

    private void visitStandardNew(Node node, Node child)
    {
<span class="nc bnc" id="L3458" title="All 2 branches missed.">        if (node.getType() != Token.NEW) throw Codegen.badTree();</span>

<span class="nc" id="L3460">        Node firstArgChild = child.getNext();</span>

<span class="nc" id="L3462">        generateExpression(child, node);</span>
        // stack: ... functionObj
<span class="nc" id="L3464">        cfw.addALoad(contextLocal);</span>
<span class="nc" id="L3465">        cfw.addALoad(variableObjectLocal);</span>
        // stack: ... functionObj cx scope
<span class="nc" id="L3467">        generateCallArgArray(node, firstArgChild, false);</span>
<span class="nc" id="L3468">        addScriptRuntimeInvoke(</span>
            &quot;newObject&quot;,
            &quot;(Ljava/lang/Object;&quot;
            +&quot;Lorg/mozilla/javascript/Context;&quot;
            +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
            +&quot;[Ljava/lang/Object;&quot;
            +&quot;)Lorg/mozilla/javascript/Scriptable;&quot;);
<span class="nc" id="L3475">    }</span>

    private void visitOptimizedCall(Node node, OptFunctionNode target,
                                    int type, Node child)
    {
<span class="nc" id="L3480">        Node firstArgChild = child.getNext();</span>
<span class="nc" id="L3481">        String className = codegen.mainClassName;</span>

<span class="nc" id="L3483">        short thisObjLocal = 0;</span>
<span class="nc bnc" id="L3484" title="All 2 branches missed.">        if (type == Token.NEW) {</span>
<span class="nc" id="L3485">            generateExpression(child, node);</span>
        } else {
<span class="nc" id="L3487">            generateFunctionAndThisObj(child, node);</span>
<span class="nc" id="L3488">            thisObjLocal = getNewWordLocal();</span>
<span class="nc" id="L3489">            cfw.addAStore(thisObjLocal);</span>
        }
        // stack: ... functionObj

<span class="nc" id="L3493">        int beyond = cfw.acquireLabel();</span>
<span class="nc" id="L3494">        int regularCall = cfw.acquireLabel();</span>

<span class="nc" id="L3496">        cfw.add(ByteCode.DUP);</span>
<span class="nc" id="L3497">        cfw.add(ByteCode.INSTANCEOF, className);</span>
<span class="nc" id="L3498">        cfw.add(ByteCode.IFEQ, regularCall);</span>
<span class="nc" id="L3499">        cfw.add(ByteCode.CHECKCAST, className);</span>
<span class="nc" id="L3500">        cfw.add(ByteCode.DUP);</span>
<span class="nc" id="L3501">        cfw.add(ByteCode.GETFIELD, className, Codegen.ID_FIELD_NAME, &quot;I&quot;);</span>
<span class="nc" id="L3502">        cfw.addPush(codegen.getIndex(target.fnode));</span>
<span class="nc" id="L3503">        cfw.add(ByteCode.IF_ICMPNE, regularCall);</span>

        // stack: ... directFunct
<span class="nc" id="L3506">        cfw.addALoad(contextLocal);</span>
<span class="nc" id="L3507">        cfw.addALoad(variableObjectLocal);</span>
        // stack: ... directFunc cx scope

<span class="nc bnc" id="L3510" title="All 2 branches missed.">        if (type == Token.NEW) {</span>
<span class="nc" id="L3511">            cfw.add(ByteCode.ACONST_NULL);</span>
        } else {
<span class="nc" id="L3513">            cfw.addALoad(thisObjLocal);</span>
        }
        // stack: ... directFunc cx scope thisObj
/*
Remember that directCall parameters are paired in 1 aReg and 1 dReg
If the argument is an incoming arg, just pass the orginal pair thru.
Else, if the argument is known to be typed 'Number', pass Void.TYPE
in the aReg and the number is the dReg
Else pass the JS object in the aReg and 0.0 in the dReg.
*/
<span class="nc" id="L3523">        Node argChild = firstArgChild;</span>
<span class="nc bnc" id="L3524" title="All 2 branches missed.">        while (argChild != null) {</span>
<span class="nc" id="L3525">            int dcp_register = nodeIsDirectCallParameter(argChild);</span>
<span class="nc bnc" id="L3526" title="All 2 branches missed.">            if (dcp_register &gt;= 0) {</span>
<span class="nc" id="L3527">                cfw.addALoad(dcp_register);</span>
<span class="nc" id="L3528">                cfw.addDLoad(dcp_register + 1);</span>
<span class="nc bnc" id="L3529" title="All 2 branches missed.">            } else if (argChild.getIntProp(Node.ISNUMBER_PROP, -1)</span>
                       == Node.BOTH)
            {
<span class="nc" id="L3532">                cfw.add(ByteCode.GETSTATIC,</span>
                        &quot;java/lang/Void&quot;,
                        &quot;TYPE&quot;,
                        &quot;Ljava/lang/Class;&quot;);
<span class="nc" id="L3536">                generateExpression(argChild, node);</span>
            } else {
<span class="nc" id="L3538">                generateExpression(argChild, node);</span>
<span class="nc" id="L3539">                cfw.addPush(0.0);</span>
            }
<span class="nc" id="L3541">            argChild = argChild.getNext();</span>
<span class="nc" id="L3542">        }</span>

<span class="nc" id="L3544">        cfw.add(ByteCode.GETSTATIC,</span>
                &quot;org/mozilla/javascript/ScriptRuntime&quot;,
                &quot;emptyArgs&quot;, &quot;[Ljava/lang/Object;&quot;);
<span class="nc bnc" id="L3547" title="All 2 branches missed.">        cfw.addInvoke(ByteCode.INVOKESTATIC,</span>
                      codegen.mainClassName,
                      (type == Token.NEW)
<span class="nc" id="L3550">                          ? codegen.getDirectCtorName(target.fnode)</span>
<span class="nc" id="L3551">                          : codegen.getBodyMethodName(target.fnode),</span>
<span class="nc" id="L3552">                      codegen.getBodyMethodSignature(target.fnode));</span>

<span class="nc" id="L3554">        cfw.add(ByteCode.GOTO, beyond);</span>

<span class="nc" id="L3556">        cfw.markLabel(regularCall);</span>
        // stack: ... functionObj
<span class="nc" id="L3558">        cfw.addALoad(contextLocal);</span>
<span class="nc" id="L3559">        cfw.addALoad(variableObjectLocal);</span>
        // stack: ... functionObj cx scope
<span class="nc bnc" id="L3561" title="All 2 branches missed.">        if (type != Token.NEW) {</span>
<span class="nc" id="L3562">            cfw.addALoad(thisObjLocal);</span>
<span class="nc" id="L3563">            releaseWordLocal(thisObjLocal);</span>
            // stack: ... functionObj cx scope thisObj
        }
        // XXX: this will generate code for the child array the second time,
        // so expression code generation better not to alter tree structure...
<span class="nc" id="L3568">        generateCallArgArray(node, firstArgChild, true);</span>

<span class="nc bnc" id="L3570" title="All 2 branches missed.">        if (type == Token.NEW) {</span>
<span class="nc" id="L3571">            addScriptRuntimeInvoke(</span>
                &quot;newObject&quot;,
                &quot;(Ljava/lang/Object;&quot;
                +&quot;Lorg/mozilla/javascript/Context;&quot;
                +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                +&quot;[Ljava/lang/Object;&quot;
                +&quot;)Lorg/mozilla/javascript/Scriptable;&quot;);
        } else {
<span class="nc" id="L3579">            cfw.addInvoke(ByteCode.INVOKEINTERFACE,</span>
                &quot;org/mozilla/javascript/Callable&quot;,
                &quot;call&quot;,
                &quot;(Lorg/mozilla/javascript/Context;&quot;
                +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                +&quot;[Ljava/lang/Object;&quot;
                +&quot;)Ljava/lang/Object;&quot;);
        }

<span class="nc" id="L3589">        cfw.markLabel(beyond);</span>
<span class="nc" id="L3590">    }</span>

    private void generateCallArgArray(Node node, Node argChild, boolean directCall)
    {
<span class="nc" id="L3594">        int argCount = 0;</span>
<span class="nc bnc" id="L3595" title="All 2 branches missed.">        for (Node child = argChild; child != null; child = child.getNext()) {</span>
<span class="nc" id="L3596">            ++argCount;</span>
        }
        // load array object to set arguments
<span class="nc bnc" id="L3599" title="All 4 branches missed.">        if (argCount == 1 &amp;&amp; itsOneArgArray &gt;= 0) {</span>
<span class="nc" id="L3600">            cfw.addALoad(itsOneArgArray);</span>
        } else {
<span class="nc" id="L3602">            addNewObjectArray(argCount);</span>
        }
        // Copy arguments into it
<span class="nc bnc" id="L3605" title="All 2 branches missed.">        for (int i = 0; i != argCount; ++i) {</span>
            // If we are compiling a generator an argument could be the result
            // of a yield. In that case we will have an immediate on the stack
            // which we need to avoid
<span class="nc bnc" id="L3609" title="All 2 branches missed.">            if (!isGenerator) {</span>
<span class="nc" id="L3610">                cfw.add(ByteCode.DUP);</span>
<span class="nc" id="L3611">                cfw.addPush(i);</span>
            }

<span class="nc bnc" id="L3614" title="All 2 branches missed.">            if (!directCall) {</span>
<span class="nc" id="L3615">                generateExpression(argChild, node);</span>
            } else {
                // If this has also been a directCall sequence, the Number
                // flag will have remained set for any parameter so that
                // the values could be copied directly into the outgoing
                // args. Here we want to force it to be treated as not in
                // a Number context, so we set the flag off.
<span class="nc" id="L3622">                int dcp_register = nodeIsDirectCallParameter(argChild);</span>
<span class="nc bnc" id="L3623" title="All 2 branches missed.">                if (dcp_register &gt;= 0) {</span>
<span class="nc" id="L3624">                    dcpLoadAsObject(dcp_register);</span>
                } else {
<span class="nc" id="L3626">                    generateExpression(argChild, node);</span>
<span class="nc" id="L3627">                    int childNumberFlag</span>
<span class="nc" id="L3628">                            = argChild.getIntProp(Node.ISNUMBER_PROP, -1);</span>
<span class="nc bnc" id="L3629" title="All 2 branches missed.">                    if (childNumberFlag == Node.BOTH) {</span>
<span class="nc" id="L3630">                        addDoubleWrap();</span>
                    }
                }
            }

            // When compiling generators, any argument to a method may be a
            // yield expression. Hence we compile the argument first and then
            // load the argument index and assign the value to the args array.
<span class="nc bnc" id="L3638" title="All 2 branches missed.">            if (isGenerator) {</span>
<span class="nc" id="L3639">                short tempLocal = getNewWordLocal();</span>
<span class="nc" id="L3640">                cfw.addAStore(tempLocal);</span>
<span class="nc" id="L3641">                cfw.add(ByteCode.CHECKCAST, &quot;[Ljava/lang/Object;&quot;);</span>
<span class="nc" id="L3642">                cfw.add(ByteCode.DUP);</span>
<span class="nc" id="L3643">                cfw.addPush(i);</span>
<span class="nc" id="L3644">                cfw.addALoad(tempLocal);</span>
<span class="nc" id="L3645">                releaseWordLocal(tempLocal);</span>
            }

<span class="nc" id="L3648">            cfw.add(ByteCode.AASTORE);</span>

<span class="nc" id="L3650">            argChild = argChild.getNext();</span>
        }
<span class="nc" id="L3652">    }</span>

    private void generateFunctionAndThisObj(Node node, Node parent)
    {
        // Place on stack (function object, function this) pair
<span class="nc" id="L3657">        int type = node.getType();</span>
<span class="nc bnc" id="L3658" title="All 4 branches missed.">        switch (node.getType()) {</span>
          case Token.GETPROPNOWARN:
<span class="nc" id="L3660">            throw Kit.codeBug();</span>

          case Token.GETPROP:
          case Token.GETELEM: {
<span class="nc" id="L3664">            Node target = node.getFirstChild();</span>
<span class="nc" id="L3665">            generateExpression(target, node);</span>
<span class="nc" id="L3666">            Node id = target.getNext();</span>
<span class="nc bnc" id="L3667" title="All 2 branches missed.">            if (type == Token.GETPROP) {</span>
<span class="nc" id="L3668">                String property = id.getString();</span>
<span class="nc" id="L3669">                cfw.addPush(property);</span>
<span class="nc" id="L3670">                cfw.addALoad(contextLocal);</span>
<span class="nc" id="L3671">                cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L3672">                addScriptRuntimeInvoke(</span>
                    &quot;getPropFunctionAndThis&quot;,
                    &quot;(Ljava/lang/Object;&quot;
                    +&quot;Ljava/lang/String;&quot;
                    +&quot;Lorg/mozilla/javascript/Context;&quot;
                    +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                    +&quot;)Lorg/mozilla/javascript/Callable;&quot;);
<span class="nc" id="L3679">            } else {</span>
<span class="nc" id="L3680">                generateExpression(id, node);  // id</span>
<span class="nc bnc" id="L3681" title="All 2 branches missed.">                if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1)</span>
<span class="nc" id="L3682">                    addDoubleWrap();</span>
<span class="nc" id="L3683">                cfw.addALoad(contextLocal);</span>
<span class="nc" id="L3684">                cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L3685">                addScriptRuntimeInvoke(</span>
                    &quot;getElemFunctionAndThis&quot;,
                    &quot;(Ljava/lang/Object;&quot;
                    +&quot;Ljava/lang/Object;&quot;
                    +&quot;Lorg/mozilla/javascript/Context;&quot;
                    +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                    +&quot;)Lorg/mozilla/javascript/Callable;&quot;);
            }
<span class="nc" id="L3693">            break;</span>
          }

          case Token.NAME: {
<span class="nc" id="L3697">            String name = node.getString();</span>
<span class="nc" id="L3698">            cfw.addPush(name);</span>
<span class="nc" id="L3699">            cfw.addALoad(contextLocal);</span>
<span class="nc" id="L3700">            cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L3701">            addScriptRuntimeInvoke(</span>
                &quot;getNameFunctionAndThis&quot;,
                &quot;(Ljava/lang/String;&quot;
                +&quot;Lorg/mozilla/javascript/Context;&quot;
                +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                +&quot;)Lorg/mozilla/javascript/Callable;&quot;);
<span class="nc" id="L3707">            break;</span>
          }

          default: // including GETVAR
<span class="nc" id="L3711">            generateExpression(node, parent);</span>
<span class="nc" id="L3712">            cfw.addALoad(contextLocal);</span>
<span class="nc" id="L3713">            addScriptRuntimeInvoke(</span>
                &quot;getValueFunctionAndThis&quot;,
                &quot;(Ljava/lang/Object;&quot;
                +&quot;Lorg/mozilla/javascript/Context;&quot;
                +&quot;)Lorg/mozilla/javascript/Callable;&quot;);
            break;
        }
        // Get thisObj prepared by get(Name|Prop|Elem|Value)FunctionAndThis
<span class="nc" id="L3721">        cfw.addALoad(contextLocal);</span>
<span class="nc" id="L3722">        addScriptRuntimeInvoke(</span>
            &quot;lastStoredScriptable&quot;,
            &quot;(Lorg/mozilla/javascript/Context;&quot;
            +&quot;)Lorg/mozilla/javascript/Scriptable;&quot;);
<span class="nc" id="L3726">    }</span>

    private void updateLineNumber(Node node)
    {
<span class="fc" id="L3730">        itsLineNumber = node.getLineno();</span>
<span class="fc bfc" id="L3731" title="All 2 branches covered.">        if (itsLineNumber == -1)</span>
<span class="fc" id="L3732">            return;</span>
<span class="fc" id="L3733">        cfw.addLineNumberEntry((short)itsLineNumber);</span>
<span class="fc" id="L3734">    }</span>

    private void visitTryCatchFinally(Jump node, Node child)
    {
        /* Save the variable object, in case there are with statements
         * enclosed by the try block and we catch some exception.
         * We'll restore it for the catch block so that catch block
         * statements get the right scope.
         */

        // OPT we only need to do this if there are enclosed WITH
        // statements; could statically check and omit this if there aren't any.

        // XXX OPT Maybe instead do syntactic transforms to associate
        // each 'with' with a try/finally block that does the exitwith.

<span class="nc" id="L3750">        short savedVariableObject = getNewWordLocal();</span>
<span class="nc" id="L3751">        cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L3752">        cfw.addAStore(savedVariableObject);</span>

        /*
         * Generate the code for the tree; most of the work is done in IRFactory
         * and NodeTransformer;  Codegen just adds the java handlers for the
         * javascript catch and finally clauses.  */

<span class="nc" id="L3759">        int startLabel = cfw.acquireLabel();</span>
<span class="nc" id="L3760">        cfw.markLabel(startLabel, (short)0);</span>

<span class="nc" id="L3762">        Node catchTarget = node.target;</span>
<span class="nc" id="L3763">        Node finallyTarget = node.getFinally();</span>
<span class="nc" id="L3764">        int[] handlerLabels = new int[EXCEPTION_MAX];</span>

<span class="nc" id="L3766">        exceptionManager.pushExceptionInfo(node);</span>
<span class="nc bnc" id="L3767" title="All 2 branches missed.">        if (catchTarget != null) {</span>
<span class="nc" id="L3768">            handlerLabels[JAVASCRIPT_EXCEPTION] = cfw.acquireLabel();</span>
<span class="nc" id="L3769">            handlerLabels[EVALUATOR_EXCEPTION] = cfw.acquireLabel();</span>
<span class="nc" id="L3770">            handlerLabels[ECMAERROR_EXCEPTION] = cfw.acquireLabel();</span>
<span class="nc" id="L3771">            Context cx = Context.getCurrentContext();</span>
<span class="nc bnc" id="L3772" title="All 2 branches missed.">            if (cx != null &amp;&amp;</span>
<span class="nc bnc" id="L3773" title="All 2 branches missed.">                cx.hasFeature(Context.FEATURE_ENHANCED_JAVA_ACCESS)) {</span>
<span class="nc" id="L3774">                handlerLabels[THROWABLE_EXCEPTION] = cfw.acquireLabel();</span>
            }
        }
<span class="nc bnc" id="L3777" title="All 2 branches missed.">        if (finallyTarget != null) {</span>
<span class="nc" id="L3778">            handlerLabels[FINALLY_EXCEPTION] = cfw.acquireLabel();</span>
        }
<span class="nc" id="L3780">        exceptionManager.setHandlers(handlerLabels, startLabel);</span>

        // create a table for the equivalent of JSR returns
<span class="nc bnc" id="L3783" title="All 4 branches missed.">        if (isGenerator &amp;&amp; finallyTarget != null) {</span>
<span class="nc" id="L3784">            FinallyReturnPoint ret = new FinallyReturnPoint();</span>
<span class="nc bnc" id="L3785" title="All 2 branches missed.">            if (finallys == null) {</span>
<span class="nc" id="L3786">                finallys = new HashMap&lt;Node,FinallyReturnPoint&gt;();</span>
            }
            // add the finally target to hashtable
<span class="nc" id="L3789">            finallys.put(finallyTarget, ret);</span>
            // add the finally node as well to the hash table
<span class="nc" id="L3791">            finallys.put(finallyTarget.getNext(), ret);</span>
        }

<span class="nc bnc" id="L3794" title="All 2 branches missed.">        while (child != null) {</span>
<span class="nc bnc" id="L3795" title="All 2 branches missed.">            if (child == catchTarget) {</span>
<span class="nc" id="L3796">                int catchLabel = getTargetLabel(catchTarget);</span>
<span class="nc" id="L3797">                exceptionManager.removeHandler(JAVASCRIPT_EXCEPTION,</span>
                                               catchLabel);
<span class="nc" id="L3799">                exceptionManager.removeHandler(EVALUATOR_EXCEPTION,</span>
                                               catchLabel);
<span class="nc" id="L3801">                exceptionManager.removeHandler(ECMAERROR_EXCEPTION,</span>
                                               catchLabel);
<span class="nc" id="L3803">                exceptionManager.removeHandler(THROWABLE_EXCEPTION,</span>
                                               catchLabel);
            }
<span class="nc" id="L3806">            generateStatement(child);</span>
<span class="nc" id="L3807">            child = child.getNext();</span>
        }

        // control flow skips the handlers
<span class="nc" id="L3811">        int realEnd = cfw.acquireLabel();</span>
<span class="nc" id="L3812">        cfw.add(ByteCode.GOTO, realEnd);</span>

<span class="nc" id="L3814">        int exceptionLocal = getLocalBlockRegister(node);</span>
        // javascript handler; unwrap exception and GOTO to javascript
        // catch area.
<span class="nc bnc" id="L3817" title="All 2 branches missed.">        if (catchTarget != null) {</span>
            // get the label to goto
<span class="nc" id="L3819">            int catchLabel = catchTarget.labelId();</span>

            // If the function is a generator, then handlerLabels will consist
            // of zero labels. generateCatchBlock will create its own label
            // in this case. The extra parameter for the label is added for
            // the case of non-generator functions that inline finally blocks.

<span class="nc" id="L3826">            generateCatchBlock(JAVASCRIPT_EXCEPTION, savedVariableObject,</span>
                               catchLabel, exceptionLocal,
                               handlerLabels[JAVASCRIPT_EXCEPTION]);
            /*
             * catch WrappedExceptions, see if they are wrapped
             * JavaScriptExceptions. Otherwise, rethrow.
             */
<span class="nc" id="L3833">            generateCatchBlock(EVALUATOR_EXCEPTION, savedVariableObject,</span>
                               catchLabel, exceptionLocal,
                               handlerLabels[EVALUATOR_EXCEPTION]);

            /*
                we also need to catch EcmaErrors and feed the
                associated error object to the handler
            */
<span class="nc" id="L3841">            generateCatchBlock(ECMAERROR_EXCEPTION, savedVariableObject,</span>
                               catchLabel, exceptionLocal,
                               handlerLabels[ECMAERROR_EXCEPTION]);

<span class="nc" id="L3845">            Context cx = Context.getCurrentContext();</span>
<span class="nc bnc" id="L3846" title="All 2 branches missed.">            if (cx != null &amp;&amp;</span>
<span class="nc bnc" id="L3847" title="All 2 branches missed.">                cx.hasFeature(Context.FEATURE_ENHANCED_JAVA_ACCESS))</span>
            {
<span class="nc" id="L3849">                generateCatchBlock(THROWABLE_EXCEPTION, savedVariableObject,</span>
                                   catchLabel, exceptionLocal,
                                   handlerLabels[THROWABLE_EXCEPTION]);
            }
        }

        // finally handler; catch all exceptions, store to a local; JSR to
        // the finally, then re-throw.
<span class="nc bnc" id="L3857" title="All 2 branches missed.">        if (finallyTarget != null) {</span>
<span class="nc" id="L3858">            int finallyHandler = cfw.acquireLabel();</span>
<span class="nc" id="L3859">            int finallyEnd = cfw.acquireLabel();</span>
<span class="nc" id="L3860">            cfw.markHandler(finallyHandler);</span>
<span class="nc bnc" id="L3861" title="All 2 branches missed.">            if (!isGenerator) {</span>
<span class="nc" id="L3862">                cfw.markLabel(handlerLabels[FINALLY_EXCEPTION]);</span>
            }
<span class="nc" id="L3864">            cfw.addAStore(exceptionLocal);</span>

            // reset the variable object local
<span class="nc" id="L3867">            cfw.addALoad(savedVariableObject);</span>
<span class="nc" id="L3868">            cfw.addAStore(variableObjectLocal);</span>

            // get the label to JSR to
<span class="nc" id="L3871">            int finallyLabel = finallyTarget.labelId();</span>
<span class="nc bnc" id="L3872" title="All 2 branches missed.">            if (isGenerator)</span>
<span class="nc" id="L3873">                addGotoWithReturn(finallyTarget);</span>
            else {
<span class="nc" id="L3875">                inlineFinally(finallyTarget, handlerLabels[FINALLY_EXCEPTION],</span>
                              finallyEnd);
            }

            // rethrow
<span class="nc" id="L3880">            cfw.addALoad(exceptionLocal);</span>
<span class="nc bnc" id="L3881" title="All 2 branches missed.">            if (isGenerator)</span>
<span class="nc" id="L3882">                cfw.add(ByteCode.CHECKCAST, &quot;java/lang/Throwable&quot;);</span>
<span class="nc" id="L3883">            cfw.add(ByteCode.ATHROW);</span>

<span class="nc" id="L3885">            cfw.markLabel(finallyEnd);</span>
            // mark the handler
<span class="nc bnc" id="L3887" title="All 2 branches missed.">            if (isGenerator) {</span>
<span class="nc" id="L3888">                cfw.addExceptionHandler(startLabel, finallyLabel,</span>
                                        finallyHandler, null); // catch any
            }
        }
<span class="nc" id="L3892">        releaseWordLocal(savedVariableObject);</span>
<span class="nc" id="L3893">        cfw.markLabel(realEnd);</span>

<span class="nc bnc" id="L3895" title="All 2 branches missed.">        if (!isGenerator) {</span>
<span class="nc" id="L3896">            exceptionManager.popExceptionInfo();</span>
        }
<span class="nc" id="L3898">    }</span>

    private static final int JAVASCRIPT_EXCEPTION  = 0;
    private static final int EVALUATOR_EXCEPTION   = 1;
    private static final int ECMAERROR_EXCEPTION   = 2;
    private static final int THROWABLE_EXCEPTION   = 3;
    // Finally catch-alls are technically Throwable, but we want a distinction
    // for the exception manager and we want to use a null string instead of
    // an explicit Throwable string.
    private static final int FINALLY_EXCEPTION = 4;
    private static final int EXCEPTION_MAX = 5;

    private void generateCatchBlock(int exceptionType,
                                    short savedVariableObject,
                                    int catchLabel,
                                    int exceptionLocal,
                                    int handler)
    {
<span class="nc bnc" id="L3916" title="All 2 branches missed.">        if (handler == 0) {</span>
<span class="nc" id="L3917">            handler = cfw.acquireLabel();</span>
        }
<span class="nc" id="L3919">        cfw.markHandler(handler);</span>

        // MS JVM gets cranky if the exception object is left on the stack
<span class="nc" id="L3922">        cfw.addAStore(exceptionLocal);</span>

        // reset the variable object local
<span class="nc" id="L3925">        cfw.addALoad(savedVariableObject);</span>
<span class="nc" id="L3926">        cfw.addAStore(variableObjectLocal);</span>

<span class="nc" id="L3928">        String exceptionName = exceptionTypeToName(exceptionType);</span>

<span class="nc" id="L3930">        cfw.add(ByteCode.GOTO, catchLabel);</span>
<span class="nc" id="L3931">    }</span>

    private String exceptionTypeToName(int exceptionType)
    {
<span class="nc bnc" id="L3935" title="All 2 branches missed.">        if (exceptionType == JAVASCRIPT_EXCEPTION) {</span>
<span class="nc" id="L3936">            return &quot;org/mozilla/javascript/JavaScriptException&quot;;</span>
<span class="nc bnc" id="L3937" title="All 2 branches missed.">        } else if (exceptionType == EVALUATOR_EXCEPTION) {</span>
<span class="nc" id="L3938">            return &quot;org/mozilla/javascript/EvaluatorException&quot;;</span>
<span class="nc bnc" id="L3939" title="All 2 branches missed.">        } else if (exceptionType == ECMAERROR_EXCEPTION) {</span>
<span class="nc" id="L3940">            return &quot;org/mozilla/javascript/EcmaError&quot;;</span>
<span class="nc bnc" id="L3941" title="All 2 branches missed.">        } else if (exceptionType == THROWABLE_EXCEPTION) {</span>
<span class="nc" id="L3942">            return &quot;java/lang/Throwable&quot;;</span>
<span class="nc bnc" id="L3943" title="All 2 branches missed.">        } else if (exceptionType == FINALLY_EXCEPTION) {</span>
<span class="nc" id="L3944">            return null;</span>
        } else {
<span class="nc" id="L3946">            throw Kit.codeBug();</span>
        }
    }

    /**
     * Manages placement of exception handlers for non-generator functions.
     *
     * For generator functions, there are mechanisms put into place to emulate
     * jsr by using a goto with a return label. That is one mechanism for
     * implementing finally blocks. The other, which is implemented by Sun,
     * involves duplicating the finally block where jsr instructions would
     * normally be. However, inlining finally blocks causes problems with
     * translating exception handlers. Instead of having one big bytecode range
     * for each exception, we now have to skip over the inlined finally blocks.
     * This class is meant to help implement this.
     *
     * Every time a try block is encountered during translation, exception
     * information should be pushed into the manager, which is treated as a
     * stack. The addHandler() and setHandlers() methods may be used to register
     * exceptionHandlers for the try block; removeHandler() is used to reverse
     * the operation. At the end of the try/catch/finally, the exception state
     * for it should be popped.
     *
     * The important function here is markInlineFinally. This finds which
     * finally block on the exception state stack is being inlined and skips
     * the proper exception handlers until the finally block is generated.
     */
    private class ExceptionManager
    {
        ExceptionManager()
<span class="fc" id="L3976">        {</span>
<span class="fc" id="L3977">            exceptionInfo = new LinkedList&lt;ExceptionInfo&gt;();</span>
<span class="fc" id="L3978">        }</span>

        /**
         * Push a new try block onto the exception information stack.
         *
         * @param node an exception handling node (node.getType() ==
         *             Token.TRY)
         */
        void pushExceptionInfo(Jump node)
        {
<span class="nc" id="L3988">            Node fBlock = getFinallyAtTarget(node.getFinally());</span>
<span class="nc" id="L3989">            ExceptionInfo ei = new ExceptionInfo(node, fBlock);</span>
<span class="nc" id="L3990">            exceptionInfo.add(ei);</span>
<span class="nc" id="L3991">        }</span>

        /**
         * Register an exception handler for the try block at the top of the
         * exception information stack.
         *
         * @param exceptionType one of the integer constants representing an
         *                      exception type
         * @param handlerLabel the label of the exception handler
         * @param startLabel the label where the exception handling begins
         */
        void addHandler(int exceptionType, int handlerLabel, int startLabel)
        {
<span class="nc" id="L4004">            ExceptionInfo top = getTop();</span>
<span class="nc" id="L4005">            top.handlerLabels[exceptionType] = handlerLabel;</span>
<span class="nc" id="L4006">            top.exceptionStarts[exceptionType] = startLabel;</span>
<span class="nc" id="L4007">        }</span>

        /**
         * Register multiple exception handlers for the top try block. If the
         * exception type maps to a zero label, then it is ignored.
         *
         * @param handlerLabels a map from integer constants representing an
         *                      exception type to the label of the exception
         *                      handler
         * @param startLabel the label where all of the exception handling
         *                   begins
         */
        void setHandlers(int[] handlerLabels, int startLabel)
        {
<span class="nc" id="L4021">            ExceptionInfo top = getTop();</span>
<span class="nc bnc" id="L4022" title="All 2 branches missed.">            for (int i = 0; i &lt; handlerLabels.length; i++) {</span>
<span class="nc bnc" id="L4023" title="All 2 branches missed.">                if (handlerLabels[i] != 0) {</span>
<span class="nc" id="L4024">                    addHandler(i, handlerLabels[i], startLabel);</span>
                }
            }
<span class="nc" id="L4027">        }</span>

        /**
         * Remove an exception handler for the top try block.
         *
         * @param exceptionType one of the integer constants representing an
         *                      exception type
         * @param endLabel a label representing the end of the last bytecode
         *                 that should be handled by the exception
         * @returns the label of the exception handler associated with the
         *          exception type
         */
        int removeHandler(int exceptionType, int endLabel)
        {
<span class="nc" id="L4041">            ExceptionInfo top = getTop();</span>
<span class="nc bnc" id="L4042" title="All 2 branches missed.">            if (top.handlerLabels[exceptionType] != 0) {</span>
<span class="nc" id="L4043">                int handlerLabel = top.handlerLabels[exceptionType];</span>
<span class="nc" id="L4044">                endCatch(top, exceptionType, endLabel);</span>
<span class="nc" id="L4045">                top.handlerLabels[exceptionType] = 0;</span>
<span class="nc" id="L4046">                return handlerLabel;</span>
            }
<span class="nc" id="L4048">            return 0;</span>
        }

        /**
         * Remove the top try block from the exception information stack.
         */
        void popExceptionInfo()
        {
<span class="nc" id="L4056">            exceptionInfo.removeLast();</span>
<span class="nc" id="L4057">        }</span>

        /**
         * Mark the start of an inlined finally block.
         *
         * When a finally block is inlined, any exception handlers that are
         * lexically inside of its try block should not cover the range of the
         * exception block. We scan from the innermost try block outward until
         * we find the try block that matches the finally block. For any block
         * whose exception handlers that aren't currently stopped by a finally
         * block, we stop the handlers at the beginning of the finally block
         * and set it as the finally block that has stopped the handlers. This
         * prevents other inlined finally blocks from prematurely ending skip
         * ranges and creating bad exception handler ranges.
         *
         * @param finallyBlock the finally block that is being inlined
         * @param finallyStart the label of the beginning of the inlined code
         */
        void markInlineFinallyStart(Node finallyBlock, int finallyStart)
        {
            // Traverse the stack in LIFO order until the try block
            // corresponding to the finally block has been reached. We must
            // traverse backwards because the earlier exception handlers in
            // the exception handler table have priority when determining which
            // handler to use. Therefore, we start with the most nested try
            // block and move outward.
<span class="nc" id="L4083">            ListIterator&lt;ExceptionInfo&gt; iter =</span>
<span class="nc" id="L4084">                    exceptionInfo.listIterator(exceptionInfo.size());</span>
<span class="nc bnc" id="L4085" title="All 2 branches missed.">            while (iter.hasPrevious()) {</span>
<span class="nc" id="L4086">                ExceptionInfo ei = iter.previous();</span>
<span class="nc bnc" id="L4087" title="All 2 branches missed.">                for (int i = 0; i &lt; EXCEPTION_MAX; i++) {</span>
<span class="nc bnc" id="L4088" title="All 4 branches missed.">                    if (ei.handlerLabels[i] != 0 &amp;&amp; ei.currentFinally == null) {</span>
<span class="nc" id="L4089">                        endCatch(ei, i, finallyStart);</span>
<span class="nc" id="L4090">                        ei.exceptionStarts[i] = 0;</span>
<span class="nc" id="L4091">                        ei.currentFinally = finallyBlock;</span>
                    }
                }
<span class="nc bnc" id="L4094" title="All 2 branches missed.">                if (ei.finallyBlock == finallyBlock) {</span>
<span class="nc" id="L4095">                    break;</span>
                }
<span class="nc" id="L4097">            }</span>
<span class="nc" id="L4098">        }</span>

        /**
         * Mark the end of an inlined finally block.
         *
         * For any set of exception handlers that have been stopped by the
         * inlined block, resume exception handling at the end of the finally
         * block.
         *
         * @param finallyBlock the finally block that is being inlined
         * @param finallyEnd the label of the end of the inlined code
         */
        void markInlineFinallyEnd(Node finallyBlock, int finallyEnd)
        {
<span class="nc" id="L4112">            ListIterator&lt;ExceptionInfo&gt; iter =</span>
<span class="nc" id="L4113">                    exceptionInfo.listIterator(exceptionInfo.size());</span>
<span class="nc bnc" id="L4114" title="All 2 branches missed.">            while (iter.hasPrevious()) {</span>
<span class="nc" id="L4115">                ExceptionInfo ei = iter.previous();</span>
<span class="nc bnc" id="L4116" title="All 2 branches missed.">                for (int i = 0; i &lt; EXCEPTION_MAX; i++) {</span>
<span class="nc bnc" id="L4117" title="All 4 branches missed.">                    if (ei.handlerLabels[i] != 0 &amp;&amp;</span>
                        ei.currentFinally == finallyBlock) {
<span class="nc" id="L4119">                        ei.exceptionStarts[i] = finallyEnd;</span>
<span class="nc" id="L4120">                        ei.currentFinally = null;</span>
                    }
                }
<span class="nc bnc" id="L4123" title="All 2 branches missed.">                if (ei.finallyBlock == finallyBlock) {</span>
<span class="nc" id="L4124">                    break;</span>
                }
<span class="nc" id="L4126">            }</span>
<span class="nc" id="L4127">        }</span>

        /**
         * Mark off the end of a bytecode chunk that should be handled by an
         * exceptionHandler.
         *
         * The caller of this method must appropriately mark the start of the
         * next bytecode chunk or remove the handler.
         */
        private void endCatch(ExceptionInfo ei, int exceptionType, int catchEnd)
        {
<span class="nc bnc" id="L4138" title="All 2 branches missed.">            if (ei.exceptionStarts[exceptionType] == 0) {</span>
<span class="nc" id="L4139">                throw new IllegalStateException(&quot;bad exception start&quot;);</span>
            }

<span class="nc" id="L4142">            int currentStart = ei.exceptionStarts[exceptionType];</span>
<span class="nc" id="L4143">            int currentStartPC = cfw.getLabelPC(currentStart);</span>
<span class="nc" id="L4144">            int catchEndPC = cfw.getLabelPC(catchEnd);</span>
<span class="nc bnc" id="L4145" title="All 2 branches missed.">            if (currentStartPC != catchEndPC) {</span>
<span class="nc" id="L4146">                cfw.addExceptionHandler(ei.exceptionStarts[exceptionType],</span>
                                        catchEnd,
                                        ei.handlerLabels[exceptionType],
<span class="nc" id="L4149">                                        exceptionTypeToName(exceptionType));</span>
            }
<span class="nc" id="L4151">        }</span>

        private ExceptionInfo getTop()
        {
<span class="nc" id="L4155">            return exceptionInfo.getLast();</span>
        }

        private class ExceptionInfo
        {
            ExceptionInfo(Jump node, Node finallyBlock)
<span class="nc" id="L4161">            {</span>
<span class="nc" id="L4162">                this.node = node;</span>
<span class="nc" id="L4163">                this.finallyBlock = finallyBlock;</span>
<span class="nc" id="L4164">                handlerLabels = new int[EXCEPTION_MAX];</span>
<span class="nc" id="L4165">                exceptionStarts = new int[EXCEPTION_MAX];</span>
<span class="nc" id="L4166">                currentFinally = null;</span>
<span class="nc" id="L4167">            }</span>

            Jump node;
            Node finallyBlock;
            int[] handlerLabels;
            int[] exceptionStarts;
            // The current finally block that has temporarily ended the
            // exception handler ranges
            Node currentFinally;
        }

        // A stack of try/catch block information ordered by lexical scoping
        private LinkedList&lt;ExceptionInfo&gt; exceptionInfo;
    }

<span class="fc" id="L4182">    private ExceptionManager exceptionManager = new ExceptionManager();</span>

    /**
     * Inline a FINALLY node into the method bytecode.
     *
     * This method takes a label that points to the real start of the finally
     * block as implemented in the bytecode. This is because in some cases,
     * the finally block really starts before any of the code in the Node. For
     * example, the catch-all-rethrow finally block has a few instructions
     * prior to the finally block made by the user.
     *
     * In addition, an end label that should be unmarked is given as a method
     * parameter. It is the responsibility of any callers of this method to
     * mark the label.
     *
     * The start and end labels of the finally block are used to exclude the
     * inlined block from the proper exception handler. For example, an inlined
     * finally block should not be handled by a catch-all-rethrow.
     *
     * @param finallyTarget a TARGET node directly preceding a FINALLY node or
     *                      a FINALLY node itself
     * @param finallyStart a pre-marked label that indicates the actual start
     *                     of the finally block in the bytecode.
     * @param finallyEnd an unmarked label that will indicate the actual end
     *                   of the finally block in the bytecode.
     */
    private void inlineFinally(Node finallyTarget, int finallyStart,
                               int finallyEnd) {
<span class="nc" id="L4210">        Node fBlock = getFinallyAtTarget(finallyTarget);</span>
<span class="nc" id="L4211">        fBlock.resetTargets();</span>
<span class="nc" id="L4212">        Node child = fBlock.getFirstChild();</span>
<span class="nc" id="L4213">        exceptionManager.markInlineFinallyStart(fBlock, finallyStart);</span>
<span class="nc bnc" id="L4214" title="All 2 branches missed.">        while (child != null) {</span>
<span class="nc" id="L4215">            generateStatement(child);</span>
<span class="nc" id="L4216">            child = child.getNext();</span>
        }
<span class="nc" id="L4218">        exceptionManager.markInlineFinallyEnd(fBlock, finallyEnd);</span>
<span class="nc" id="L4219">    }</span>

    private void inlineFinally(Node finallyTarget) {
<span class="nc" id="L4222">        int finallyStart = cfw.acquireLabel();</span>
<span class="nc" id="L4223">        int finallyEnd = cfw.acquireLabel();</span>
<span class="nc" id="L4224">        cfw.markLabel(finallyStart);</span>
<span class="nc" id="L4225">        inlineFinally(finallyTarget, finallyStart, finallyEnd);</span>
<span class="nc" id="L4226">        cfw.markLabel(finallyEnd);</span>
<span class="nc" id="L4227">    }</span>

    /**
     * Get a FINALLY node at a point in the IR.
     *
     * This is strongly dependent on the generated IR. If the node is a TARGET,
     * it only check the next node to see if it is a FINALLY node.
     */
    private Node getFinallyAtTarget(Node node) {
<span class="nc bnc" id="L4236" title="All 2 branches missed.">        if (node == null) {</span>
<span class="nc" id="L4237">            return null;</span>
<span class="nc bnc" id="L4238" title="All 2 branches missed.">        } else if (node.getType() == Token.FINALLY) {</span>
<span class="nc" id="L4239">            return node;</span>
<span class="nc bnc" id="L4240" title="All 4 branches missed.">        } else if (node != null &amp;&amp; node.getType() == Token.TARGET) {</span>
<span class="nc" id="L4241">            Node fBlock = node.getNext();</span>
<span class="nc bnc" id="L4242" title="All 4 branches missed.">            if (fBlock != null &amp;&amp; fBlock.getType() == Token.FINALLY) {</span>
<span class="nc" id="L4243">                return fBlock;</span>
            }
        }
<span class="nc" id="L4246">        throw Kit.codeBug(&quot;bad finally target&quot;);</span>
    }

    private boolean generateSaveLocals(Node node)
    {
<span class="nc" id="L4251">        int count = 0;</span>
<span class="nc bnc" id="L4252" title="All 2 branches missed.">        for (int i = 0; i &lt; firstFreeLocal; i++) {</span>
<span class="nc bnc" id="L4253" title="All 2 branches missed.">            if (locals[i] != 0)</span>
<span class="nc" id="L4254">                count++;</span>
        }

<span class="nc bnc" id="L4257" title="All 2 branches missed.">        if (count == 0) {</span>
<span class="nc" id="L4258">            ((FunctionNode)scriptOrFn).addLiveLocals(node, null);</span>
<span class="nc" id="L4259">            return false;</span>
        }

        // calculate the max locals
<span class="nc bnc" id="L4263" title="All 2 branches missed.">        maxLocals = maxLocals &gt; count ? maxLocals : count;</span>

        // create a locals list
<span class="nc" id="L4266">        int[] ls = new int[count];</span>
<span class="nc" id="L4267">        int s = 0;</span>
<span class="nc bnc" id="L4268" title="All 2 branches missed.">        for (int i = 0; i &lt; firstFreeLocal; i++) {</span>
<span class="nc bnc" id="L4269" title="All 2 branches missed.">            if (locals[i] != 0) {</span>
<span class="nc" id="L4270">                ls[s] = i;</span>
<span class="nc" id="L4271">                s++;</span>
            }
        }

        // save the locals
<span class="nc" id="L4276">        ((FunctionNode)scriptOrFn).addLiveLocals(node, ls);</span>

        // save locals
<span class="nc" id="L4279">        generateGetGeneratorLocalsState();</span>
<span class="nc bnc" id="L4280" title="All 2 branches missed.">        for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L4281">            cfw.add(ByteCode.DUP);</span>
<span class="nc" id="L4282">            cfw.addLoadConstant(i);</span>
<span class="nc" id="L4283">            cfw.addALoad(ls[i]);</span>
<span class="nc" id="L4284">            cfw.add(ByteCode.AASTORE);</span>
        }
        // pop the array off the stack
<span class="nc" id="L4287">        cfw.add(ByteCode.POP);</span>

<span class="nc" id="L4289">        return true;</span>
    }

    private void visitSwitch(Jump switchNode, Node child)
    {
        // See comments in IRFactory.createSwitch() for description
        // of SWITCH node

<span class="nc" id="L4297">        generateExpression(child, switchNode);</span>
        // save selector value
<span class="nc" id="L4299">        short selector = getNewWordLocal();</span>
<span class="nc" id="L4300">        cfw.addAStore(selector);</span>

<span class="nc" id="L4302">        for (Jump caseNode = (Jump)child.getNext();</span>
<span class="nc bnc" id="L4303" title="All 2 branches missed.">             caseNode != null;</span>
<span class="nc" id="L4304">             caseNode = (Jump)caseNode.getNext())</span>
        {
<span class="nc bnc" id="L4306" title="All 2 branches missed.">            if (caseNode.getType() != Token.CASE)</span>
<span class="nc" id="L4307">                throw Codegen.badTree();</span>
<span class="nc" id="L4308">            Node test = caseNode.getFirstChild();</span>
<span class="nc" id="L4309">            generateExpression(test, caseNode);</span>
<span class="nc" id="L4310">            cfw.addALoad(selector);</span>
<span class="nc" id="L4311">            addScriptRuntimeInvoke(&quot;shallowEq&quot;,</span>
                                   &quot;(Ljava/lang/Object;&quot;
                                   +&quot;Ljava/lang/Object;&quot;
                                   +&quot;)Z&quot;);
<span class="nc" id="L4315">            addGoto(caseNode.target, ByteCode.IFNE);</span>
        }
<span class="nc" id="L4317">        releaseWordLocal(selector);</span>
<span class="nc" id="L4318">    }</span>

    private void visitTypeofname(Node node)
    {
<span class="nc bnc" id="L4322" title="All 2 branches missed.">        if (hasVarsInRegs) {</span>
<span class="nc" id="L4323">            int varIndex = fnCurrent.fnode.getIndexForNameNode(node);</span>
<span class="nc bnc" id="L4324" title="All 2 branches missed.">            if (varIndex &gt;= 0) {</span>
<span class="nc bnc" id="L4325" title="All 2 branches missed.">                if (fnCurrent.isNumberVar(varIndex)) {</span>
<span class="nc" id="L4326">                    cfw.addPush(&quot;number&quot;);</span>
<span class="nc bnc" id="L4327" title="All 2 branches missed.">                } else if (varIsDirectCallParameter(varIndex)) {</span>
<span class="nc" id="L4328">                    int dcp_register = varRegisters[varIndex];</span>
<span class="nc" id="L4329">                    cfw.addALoad(dcp_register);</span>
<span class="nc" id="L4330">                    cfw.add(ByteCode.GETSTATIC, &quot;java/lang/Void&quot;, &quot;TYPE&quot;,</span>
                            &quot;Ljava/lang/Class;&quot;);
<span class="nc" id="L4332">                    int isNumberLabel = cfw.acquireLabel();</span>
<span class="nc" id="L4333">                    cfw.add(ByteCode.IF_ACMPEQ, isNumberLabel);</span>
<span class="nc" id="L4334">                    short stack = cfw.getStackTop();</span>
<span class="nc" id="L4335">                    cfw.addALoad(dcp_register);</span>
<span class="nc" id="L4336">                    addScriptRuntimeInvoke(&quot;typeof&quot;,</span>
                                           &quot;(Ljava/lang/Object;&quot;
                                           +&quot;)Ljava/lang/String;&quot;);
<span class="nc" id="L4339">                    int beyond = cfw.acquireLabel();</span>
<span class="nc" id="L4340">                    cfw.add(ByteCode.GOTO, beyond);</span>
<span class="nc" id="L4341">                    cfw.markLabel(isNumberLabel, stack);</span>
<span class="nc" id="L4342">                    cfw.addPush(&quot;number&quot;);</span>
<span class="nc" id="L4343">                    cfw.markLabel(beyond);</span>
<span class="nc" id="L4344">                } else {</span>
<span class="nc" id="L4345">                    cfw.addALoad(varRegisters[varIndex]);</span>
<span class="nc" id="L4346">                    addScriptRuntimeInvoke(&quot;typeof&quot;,</span>
                                           &quot;(Ljava/lang/Object;&quot;
                                           +&quot;)Ljava/lang/String;&quot;);
                }
<span class="nc" id="L4350">                return;</span>
            }
        }
<span class="nc" id="L4353">        cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L4354">        cfw.addPush(node.getString());</span>
<span class="nc" id="L4355">        addScriptRuntimeInvoke(&quot;typeofName&quot;,</span>
                               &quot;(Lorg/mozilla/javascript/Scriptable;&quot;
                               +&quot;Ljava/lang/String;&quot;
                               +&quot;)Ljava/lang/String;&quot;);
<span class="nc" id="L4359">    }</span>

    /**
     * Save the current code offset. This saved code offset is used to
     * compute instruction counts in subsequent calls to
     * {@link #addInstructionCount()}.
     */
    private void saveCurrentCodeOffset() {
<span class="fc" id="L4367">        savedCodeOffset = cfw.getCurrentCodeOffset();</span>
<span class="fc" id="L4368">    }</span>

    /**
     * Generate calls to ScriptRuntime.addInstructionCount to keep track of
     * executed instructions and call &lt;code&gt;observeInstructionCount()&lt;/code&gt;
     * if a threshold is exceeded.&lt;br&gt;
     * Calculates the count from getCurrentCodeOffset - savedCodeOffset
     */
    private void addInstructionCount() {
<span class="fc" id="L4377">        int count = cfw.getCurrentCodeOffset() - savedCodeOffset;</span>
        // TODO we used to return for count == 0 but that broke the following:
        //    while(true) continue; (see bug 531600)
        // To be safe, we now always count at least 1 instruction when invoked.
<span class="fc" id="L4381">        addInstructionCount(Math.max(count, 1));</span>
<span class="fc" id="L4382">    }</span>

    /**
     * Generate calls to ScriptRuntime.addInstructionCount to keep track of
     * executed instructions and call &lt;code&gt;observeInstructionCount()&lt;/code&gt;
     * if a threshold is exceeded.&lt;br&gt;
     * Takes the count as a parameter - used to add monitoring to loops and
     * other blocks that don't have any ops - this allows
     * for monitoring/killing of while(true) loops and such.
     */
    private void addInstructionCount(int count) {
<span class="fc" id="L4393">        cfw.addALoad(contextLocal);</span>
<span class="fc" id="L4394">        cfw.addPush(count);</span>
<span class="fc" id="L4395">        addScriptRuntimeInvoke(&quot;addInstructionCount&quot;,</span>
                &quot;(Lorg/mozilla/javascript/Context;&quot;
                +&quot;I)V&quot;);
<span class="fc" id="L4398">    }</span>

    private void visitIncDec(Node node)
    {
<span class="nc" id="L4402">        int incrDecrMask = node.getExistingIntProp(Node.INCRDECR_PROP);</span>
<span class="nc" id="L4403">        Node child = node.getFirstChild();</span>
<span class="nc bnc" id="L4404" title="All 7 branches missed.">        switch (child.getType()) {</span>
          case Token.GETVAR:
<span class="nc bnc" id="L4406" title="All 2 branches missed.">            if (!hasVarsInRegs) Kit.codeBug();</span>
<span class="nc bnc" id="L4407" title="All 2 branches missed.">            boolean post = ((incrDecrMask &amp; Node.POST_FLAG) != 0);</span>
<span class="nc" id="L4408">            int varIndex = fnCurrent.getVarIndex(child);</span>
<span class="nc" id="L4409">            short reg = varRegisters[varIndex];</span>
<span class="nc" id="L4410">            boolean[] constDeclarations = fnCurrent.fnode.getParamAndVarConst();</span>
<span class="nc bnc" id="L4411" title="All 2 branches missed.">            if (constDeclarations[varIndex]) {</span>
<span class="nc bnc" id="L4412" title="All 2 branches missed.">                if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) {</span>
<span class="nc bnc" id="L4413" title="All 2 branches missed.">                    int offset = varIsDirectCallParameter(varIndex) ? 1 : 0;</span>
<span class="nc" id="L4414">                    cfw.addDLoad(reg + offset);</span>
<span class="nc bnc" id="L4415" title="All 2 branches missed.">                    if (!post) {</span>
<span class="nc" id="L4416">                        cfw.addPush(1.0);</span>
<span class="nc bnc" id="L4417" title="All 2 branches missed.">                        if ((incrDecrMask &amp; Node.DECR_FLAG) == 0) {</span>
<span class="nc" id="L4418">                            cfw.add(ByteCode.DADD);</span>
                        } else {
<span class="nc" id="L4420">                            cfw.add(ByteCode.DSUB);</span>
                        }
                    }
<span class="nc" id="L4423">                } else {</span>
<span class="nc bnc" id="L4424" title="All 2 branches missed.">                    if (varIsDirectCallParameter(varIndex)) {</span>
<span class="nc" id="L4425">                        dcpLoadAsObject(reg);</span>
                    } else {
<span class="nc" id="L4427">                        cfw.addALoad(reg);</span>
                    }
<span class="nc bnc" id="L4429" title="All 2 branches missed.">                    if (post) {</span>
<span class="nc" id="L4430">                        cfw.add(ByteCode.DUP);</span>
<span class="nc" id="L4431">                        addObjectToDouble();</span>
<span class="nc" id="L4432">                        cfw.add(ByteCode.POP2);</span>
                    } else {
<span class="nc" id="L4434">                        addObjectToDouble();</span>
<span class="nc" id="L4435">                        cfw.addPush(1.0);</span>
<span class="nc bnc" id="L4436" title="All 2 branches missed.">                        if ((incrDecrMask &amp; Node.DECR_FLAG) == 0) {</span>
<span class="nc" id="L4437">                            cfw.add(ByteCode.DADD);</span>
                        } else {
<span class="nc" id="L4439">                            cfw.add(ByteCode.DSUB);</span>
                        }
<span class="nc" id="L4441">                        addDoubleWrap();</span>
                    }
                }
<span class="nc" id="L4444">                break;</span>
            }
<span class="nc bnc" id="L4446" title="All 2 branches missed.">            if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) {</span>
<span class="nc bnc" id="L4447" title="All 2 branches missed.">                int offset = varIsDirectCallParameter(varIndex) ? 1 : 0;</span>
<span class="nc" id="L4448">                cfw.addDLoad(reg + offset);</span>
<span class="nc bnc" id="L4449" title="All 2 branches missed.">                if (post) {</span>
<span class="nc" id="L4450">                    cfw.add(ByteCode.DUP2);</span>
                }
<span class="nc" id="L4452">                cfw.addPush(1.0);</span>
<span class="nc bnc" id="L4453" title="All 2 branches missed.">                if ((incrDecrMask &amp; Node.DECR_FLAG) == 0) {</span>
<span class="nc" id="L4454">                    cfw.add(ByteCode.DADD);</span>
                } else {
<span class="nc" id="L4456">                    cfw.add(ByteCode.DSUB);</span>
                }
<span class="nc bnc" id="L4458" title="All 2 branches missed.">                if (!post) {</span>
<span class="nc" id="L4459">                    cfw.add(ByteCode.DUP2);</span>
                }
<span class="nc" id="L4461">                cfw.addDStore(reg + offset);</span>
<span class="nc" id="L4462">            } else {</span>
<span class="nc bnc" id="L4463" title="All 2 branches missed.">                if (varIsDirectCallParameter(varIndex)) {</span>
<span class="nc" id="L4464">                    dcpLoadAsObject(reg);</span>
                } else {
<span class="nc" id="L4466">                    cfw.addALoad(reg);</span>
                }
<span class="nc" id="L4468">                addObjectToDouble();</span>
<span class="nc bnc" id="L4469" title="All 2 branches missed.">                if (post) {</span>
<span class="nc" id="L4470">                    cfw.add(ByteCode.DUP2);</span>
                }
<span class="nc" id="L4472">                cfw.addPush(1.0);</span>
<span class="nc bnc" id="L4473" title="All 2 branches missed.">                if ((incrDecrMask &amp; Node.DECR_FLAG) == 0) {</span>
<span class="nc" id="L4474">                    cfw.add(ByteCode.DADD);</span>
                } else {
<span class="nc" id="L4476">                    cfw.add(ByteCode.DSUB);</span>
                }
<span class="nc" id="L4478">                addDoubleWrap();</span>
<span class="nc bnc" id="L4479" title="All 2 branches missed.">                if (!post) {</span>
<span class="nc" id="L4480">                    cfw.add(ByteCode.DUP);</span>
                }
<span class="nc" id="L4482">                cfw.addAStore(reg);</span>
<span class="nc bnc" id="L4483" title="All 2 branches missed.">                if (post) {</span>
<span class="nc" id="L4484">                    addDoubleWrap();</span>
                }
            }
            break;
          case Token.NAME:
<span class="nc" id="L4489">            cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L4490">            cfw.addPush(child.getString());          // push name</span>
<span class="nc" id="L4491">            cfw.addALoad(contextLocal);</span>
<span class="nc" id="L4492">            cfw.addPush(incrDecrMask);</span>
<span class="nc" id="L4493">            addScriptRuntimeInvoke(&quot;nameIncrDecr&quot;,</span>
                &quot;(Lorg/mozilla/javascript/Scriptable;&quot;
                +&quot;Ljava/lang/String;&quot;
                +&quot;Lorg/mozilla/javascript/Context;&quot;
                +&quot;I)Ljava/lang/Object;&quot;);
<span class="nc" id="L4498">            break;</span>
          case Token.GETPROPNOWARN:
<span class="nc" id="L4500">            throw Kit.codeBug();</span>
          case Token.GETPROP: {
<span class="nc" id="L4502">            Node getPropChild = child.getFirstChild();</span>
<span class="nc" id="L4503">            generateExpression(getPropChild, node);</span>
<span class="nc" id="L4504">            generateExpression(getPropChild.getNext(), node);</span>
<span class="nc" id="L4505">            cfw.addALoad(contextLocal);</span>
<span class="nc" id="L4506">            cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L4507">            cfw.addPush(incrDecrMask);</span>
<span class="nc" id="L4508">            addScriptRuntimeInvoke(&quot;propIncrDecr&quot;,</span>
                                   &quot;(Ljava/lang/Object;&quot;
                                   +&quot;Ljava/lang/String;&quot;
                                   +&quot;Lorg/mozilla/javascript/Context;&quot;
                                   +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                                   +&quot;I)Ljava/lang/Object;&quot;);
<span class="nc" id="L4514">            break;</span>
          }
          case Token.GETELEM: {
<span class="nc" id="L4517">            Node elemChild = child.getFirstChild();</span>
<span class="nc" id="L4518">            generateExpression(elemChild, node);</span>
<span class="nc" id="L4519">            generateExpression(elemChild.getNext(), node);</span>
<span class="nc" id="L4520">            cfw.addALoad(contextLocal);</span>
<span class="nc" id="L4521">            cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L4522">            cfw.addPush(incrDecrMask);</span>
<span class="nc bnc" id="L4523" title="All 2 branches missed.">            if (elemChild.getNext().getIntProp(Node.ISNUMBER_PROP, -1) != -1) {</span>
<span class="nc" id="L4524">              addOptRuntimeInvoke(&quot;elemIncrDecr&quot;,</span>
                  &quot;(Ljava/lang/Object;&quot;
                  +&quot;D&quot;
                  +&quot;Lorg/mozilla/javascript/Context;&quot;
                  +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                  +&quot;I&quot;
                  +&quot;)Ljava/lang/Object;&quot;);
            } else {
<span class="nc" id="L4532">              addScriptRuntimeInvoke(&quot;elemIncrDecr&quot;,</span>
                  &quot;(Ljava/lang/Object;&quot;
                  +&quot;Ljava/lang/Object;&quot;
                  +&quot;Lorg/mozilla/javascript/Context;&quot;
                  +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                  +&quot;I&quot;
                  +&quot;)Ljava/lang/Object;&quot;);
            }
<span class="nc" id="L4540">            break;</span>
          }
          case Token.GET_REF: {
<span class="nc" id="L4543">            Node refChild = child.getFirstChild();</span>
<span class="nc" id="L4544">            generateExpression(refChild, node);</span>
<span class="nc" id="L4545">            cfw.addALoad(contextLocal);</span>
<span class="nc" id="L4546">            cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L4547">            cfw.addPush(incrDecrMask);</span>
<span class="nc" id="L4548">            addScriptRuntimeInvoke(</span>
                &quot;refIncrDecr&quot;,
                &quot;(Lorg/mozilla/javascript/Ref;&quot;
                +&quot;Lorg/mozilla/javascript/Context;&quot;
                +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                +&quot;I)Ljava/lang/Object;&quot;);
<span class="nc" id="L4554">            break;</span>
          }
          default:
<span class="nc" id="L4557">            Codegen.badTree();</span>
        }
<span class="nc" id="L4559">    }</span>

    private static boolean isArithmeticNode(Node node)
    {
<span class="nc" id="L4563">        int type = node.getType();</span>
<span class="nc bnc" id="L4564" title="All 8 branches missed.">        return (type == Token.SUB)</span>
                  || (type == Token.MOD)
                        || (type == Token.DIV)
                              || (type == Token.MUL);
    }

    private void visitArithmetic(Node node, int opCode, Node child,
                                 Node parent)
    {
<span class="nc" id="L4573">        int childNumberFlag = node.getIntProp(Node.ISNUMBER_PROP, -1);</span>
<span class="nc bnc" id="L4574" title="All 2 branches missed.">        if (childNumberFlag != -1) {</span>
<span class="nc" id="L4575">            generateExpression(child, node);</span>
<span class="nc" id="L4576">            generateExpression(child.getNext(), node);</span>
<span class="nc" id="L4577">            cfw.add(opCode);</span>
        }
        else {
<span class="nc" id="L4580">            boolean childOfArithmetic = isArithmeticNode(parent);</span>
<span class="nc" id="L4581">            generateExpression(child, node);</span>
<span class="nc bnc" id="L4582" title="All 2 branches missed.">            if (!isArithmeticNode(child))</span>
<span class="nc" id="L4583">                addObjectToDouble();</span>
<span class="nc" id="L4584">            generateExpression(child.getNext(), node);</span>
<span class="nc bnc" id="L4585" title="All 2 branches missed.">            if (!isArithmeticNode(child.getNext()))</span>
<span class="nc" id="L4586">                  addObjectToDouble();</span>
<span class="nc" id="L4587">            cfw.add(opCode);</span>
<span class="nc bnc" id="L4588" title="All 2 branches missed.">            if (!childOfArithmetic) {</span>
<span class="nc" id="L4589">                addDoubleWrap();</span>
            }
        }
<span class="nc" id="L4592">    }</span>

    private void visitBitOp(Node node, int type, Node child)
    {
<span class="nc" id="L4596">        int childNumberFlag = node.getIntProp(Node.ISNUMBER_PROP, -1);</span>
<span class="nc" id="L4597">        generateExpression(child, node);</span>

        // special-case URSH; work with the target arg as a long, so
        // that we can return a 32-bit unsigned value, and call
        // toUint32 instead of toInt32.
<span class="nc bnc" id="L4602" title="All 2 branches missed.">        if (type == Token.URSH) {</span>
<span class="nc" id="L4603">            addScriptRuntimeInvoke(&quot;toUint32&quot;, &quot;(Ljava/lang/Object;)J&quot;);</span>
<span class="nc" id="L4604">            generateExpression(child.getNext(), node);</span>
<span class="nc" id="L4605">            addScriptRuntimeInvoke(&quot;toInt32&quot;, &quot;(Ljava/lang/Object;)I&quot;);</span>
            // Looks like we need to explicitly mask the shift to 5 bits -
            // LUSHR takes 6 bits.
<span class="nc" id="L4608">            cfw.addPush(31);</span>
<span class="nc" id="L4609">            cfw.add(ByteCode.IAND);</span>
<span class="nc" id="L4610">            cfw.add(ByteCode.LUSHR);</span>
<span class="nc" id="L4611">            cfw.add(ByteCode.L2D);</span>
<span class="nc" id="L4612">            addDoubleWrap();</span>
<span class="nc" id="L4613">            return;</span>
        }
<span class="nc bnc" id="L4615" title="All 2 branches missed.">        if (childNumberFlag == -1) {</span>
<span class="nc" id="L4616">            addScriptRuntimeInvoke(&quot;toInt32&quot;, &quot;(Ljava/lang/Object;)I&quot;);</span>
<span class="nc" id="L4617">            generateExpression(child.getNext(), node);</span>
<span class="nc" id="L4618">            addScriptRuntimeInvoke(&quot;toInt32&quot;, &quot;(Ljava/lang/Object;)I&quot;);</span>
        }
        else {
<span class="nc" id="L4621">            addScriptRuntimeInvoke(&quot;toInt32&quot;, &quot;(D)I&quot;);</span>
<span class="nc" id="L4622">            generateExpression(child.getNext(), node);</span>
<span class="nc" id="L4623">            addScriptRuntimeInvoke(&quot;toInt32&quot;, &quot;(D)I&quot;);</span>
        }
<span class="nc bnc" id="L4625" title="All 6 branches missed.">        switch (type) {</span>
          case Token.BITOR:
<span class="nc" id="L4627">            cfw.add(ByteCode.IOR);</span>
<span class="nc" id="L4628">            break;</span>
          case Token.BITXOR:
<span class="nc" id="L4630">            cfw.add(ByteCode.IXOR);</span>
<span class="nc" id="L4631">            break;</span>
          case Token.BITAND:
<span class="nc" id="L4633">            cfw.add(ByteCode.IAND);</span>
<span class="nc" id="L4634">            break;</span>
          case Token.RSH:
<span class="nc" id="L4636">            cfw.add(ByteCode.ISHR);</span>
<span class="nc" id="L4637">            break;</span>
          case Token.LSH:
<span class="nc" id="L4639">            cfw.add(ByteCode.ISHL);</span>
<span class="nc" id="L4640">            break;</span>
          default:
<span class="nc" id="L4642">            throw Codegen.badTree();</span>
        }
<span class="nc" id="L4644">        cfw.add(ByteCode.I2D);</span>
<span class="nc bnc" id="L4645" title="All 2 branches missed.">        if (childNumberFlag == -1) {</span>
<span class="nc" id="L4646">            addDoubleWrap();</span>
        }
<span class="nc" id="L4648">    }</span>

    private int nodeIsDirectCallParameter(Node node)
    {
<span class="nc bnc" id="L4652" title="All 6 branches missed.">        if (node.getType() == Token.GETVAR</span>
            &amp;&amp; inDirectCallFunction &amp;&amp; !itsForcedObjectParameters)
        {
<span class="nc" id="L4655">            int varIndex = fnCurrent.getVarIndex(node);</span>
<span class="nc bnc" id="L4656" title="All 2 branches missed.">            if (fnCurrent.isParameter(varIndex)) {</span>
<span class="nc" id="L4657">                return varRegisters[varIndex];</span>
            }
        }
<span class="nc" id="L4660">        return -1;</span>
    }

    private boolean varIsDirectCallParameter(int varIndex)
    {
<span class="nc bnc" id="L4665" title="All 6 branches missed.">        return fnCurrent.isParameter(varIndex)</span>
            &amp;&amp; inDirectCallFunction &amp;&amp; !itsForcedObjectParameters;
    }

    private void genSimpleCompare(int type, int trueGOTO, int falseGOTO)
    {
<span class="nc bnc" id="L4671" title="All 2 branches missed.">        if (trueGOTO == -1) throw Codegen.badTree();</span>
<span class="nc bnc" id="L4672" title="All 5 branches missed.">        switch (type) {</span>
            case Token.LE :
<span class="nc" id="L4674">                cfw.add(ByteCode.DCMPG);</span>
<span class="nc" id="L4675">                cfw.add(ByteCode.IFLE, trueGOTO);</span>
<span class="nc" id="L4676">                break;</span>
            case Token.GE :
<span class="nc" id="L4678">                cfw.add(ByteCode.DCMPL);</span>
<span class="nc" id="L4679">                cfw.add(ByteCode.IFGE, trueGOTO);</span>
<span class="nc" id="L4680">                break;</span>
            case Token.LT :
<span class="nc" id="L4682">                cfw.add(ByteCode.DCMPG);</span>
<span class="nc" id="L4683">                cfw.add(ByteCode.IFLT, trueGOTO);</span>
<span class="nc" id="L4684">                break;</span>
            case Token.GT :
<span class="nc" id="L4686">                cfw.add(ByteCode.DCMPL);</span>
<span class="nc" id="L4687">                cfw.add(ByteCode.IFGT, trueGOTO);</span>
<span class="nc" id="L4688">                break;</span>
            default :
<span class="nc" id="L4690">                throw Codegen.badTree();</span>

        }
<span class="nc bnc" id="L4693" title="All 2 branches missed.">        if (falseGOTO != -1)</span>
<span class="nc" id="L4694">            cfw.add(ByteCode.GOTO, falseGOTO);</span>
<span class="nc" id="L4695">    }</span>

    private void visitIfJumpRelOp(Node node, Node child,
                                  int trueGOTO, int falseGOTO)
    {
<span class="nc bnc" id="L4700" title="All 4 branches missed.">        if (trueGOTO == -1 || falseGOTO == -1) throw Codegen.badTree();</span>
<span class="nc" id="L4701">        int type = node.getType();</span>
<span class="nc" id="L4702">        Node rChild = child.getNext();</span>
<span class="nc bnc" id="L4703" title="All 4 branches missed.">        if (type == Token.INSTANCEOF || type == Token.IN) {</span>
<span class="nc" id="L4704">            generateExpression(child, node);</span>
<span class="nc" id="L4705">            generateExpression(rChild, node);</span>
<span class="nc" id="L4706">            cfw.addALoad(contextLocal);</span>
<span class="nc bnc" id="L4707" title="All 2 branches missed.">            addScriptRuntimeInvoke(</span>
                (type == Token.INSTANCEOF) ? &quot;instanceOf&quot; : &quot;in&quot;,
                &quot;(Ljava/lang/Object;&quot;
                +&quot;Ljava/lang/Object;&quot;
                +&quot;Lorg/mozilla/javascript/Context;&quot;
                +&quot;)Z&quot;);
<span class="nc" id="L4713">            cfw.add(ByteCode.IFNE, trueGOTO);</span>
<span class="nc" id="L4714">            cfw.add(ByteCode.GOTO, falseGOTO);</span>
<span class="nc" id="L4715">            return;</span>
        }
<span class="nc" id="L4717">        int childNumberFlag = node.getIntProp(Node.ISNUMBER_PROP, -1);</span>
<span class="nc" id="L4718">        int left_dcp_register = nodeIsDirectCallParameter(child);</span>
<span class="nc" id="L4719">        int right_dcp_register = nodeIsDirectCallParameter(rChild);</span>
<span class="nc bnc" id="L4720" title="All 2 branches missed.">        if (childNumberFlag != -1) {</span>
            // Force numeric context on both parameters and optimize
            // direct call case as Optimizer currently does not handle it

<span class="nc bnc" id="L4724" title="All 2 branches missed.">            if (childNumberFlag != Node.RIGHT) {</span>
                // Left already has number content
<span class="nc" id="L4726">                generateExpression(child, node);</span>
<span class="nc bnc" id="L4727" title="All 2 branches missed.">            } else if (left_dcp_register != -1) {</span>
<span class="nc" id="L4728">                dcpLoadAsNumber(left_dcp_register);</span>
            } else {
<span class="nc" id="L4730">                generateExpression(child, node);</span>
<span class="nc" id="L4731">                addObjectToDouble();</span>
            }

<span class="nc bnc" id="L4734" title="All 2 branches missed.">            if (childNumberFlag != Node.LEFT) {</span>
                // Right already has number content
<span class="nc" id="L4736">                generateExpression(rChild, node);</span>
<span class="nc bnc" id="L4737" title="All 2 branches missed.">            } else if (right_dcp_register != -1) {</span>
<span class="nc" id="L4738">                dcpLoadAsNumber(right_dcp_register);</span>
            } else {
<span class="nc" id="L4740">                generateExpression(rChild, node);</span>
<span class="nc" id="L4741">                addObjectToDouble();</span>
            }

<span class="nc" id="L4744">            genSimpleCompare(type, trueGOTO, falseGOTO);</span>

        } else {
<span class="nc bnc" id="L4747" title="All 4 branches missed.">            if (left_dcp_register != -1 &amp;&amp; right_dcp_register != -1) {</span>
                // Generate code to dynamically check for number content
                // if both operands are dcp
<span class="nc" id="L4750">                short stack = cfw.getStackTop();</span>
<span class="nc" id="L4751">                int leftIsNotNumber = cfw.acquireLabel();</span>
<span class="nc" id="L4752">                cfw.addALoad(left_dcp_register);</span>
<span class="nc" id="L4753">                cfw.add(ByteCode.GETSTATIC,</span>
                        &quot;java/lang/Void&quot;,
                        &quot;TYPE&quot;,
                        &quot;Ljava/lang/Class;&quot;);
<span class="nc" id="L4757">                cfw.add(ByteCode.IF_ACMPNE, leftIsNotNumber);</span>
<span class="nc" id="L4758">                cfw.addDLoad(left_dcp_register + 1);</span>
<span class="nc" id="L4759">                dcpLoadAsNumber(right_dcp_register);</span>
<span class="nc" id="L4760">                genSimpleCompare(type, trueGOTO, falseGOTO);</span>
<span class="nc bnc" id="L4761" title="All 2 branches missed.">                if (stack != cfw.getStackTop()) throw Codegen.badTree();</span>

<span class="nc" id="L4763">                cfw.markLabel(leftIsNotNumber);</span>
<span class="nc" id="L4764">                int rightIsNotNumber = cfw.acquireLabel();</span>
<span class="nc" id="L4765">                cfw.addALoad(right_dcp_register);</span>
<span class="nc" id="L4766">                cfw.add(ByteCode.GETSTATIC,</span>
                        &quot;java/lang/Void&quot;,
                        &quot;TYPE&quot;,
                        &quot;Ljava/lang/Class;&quot;);
<span class="nc" id="L4770">                cfw.add(ByteCode.IF_ACMPNE, rightIsNotNumber);</span>
<span class="nc" id="L4771">                cfw.addALoad(left_dcp_register);</span>
<span class="nc" id="L4772">                addObjectToDouble();</span>
<span class="nc" id="L4773">                cfw.addDLoad(right_dcp_register + 1);</span>
<span class="nc" id="L4774">                genSimpleCompare(type, trueGOTO, falseGOTO);</span>
<span class="nc bnc" id="L4775" title="All 2 branches missed.">                if (stack != cfw.getStackTop()) throw Codegen.badTree();</span>

<span class="nc" id="L4777">                cfw.markLabel(rightIsNotNumber);</span>
                // Load both register as objects to call generic cmp_*
<span class="nc" id="L4779">                cfw.addALoad(left_dcp_register);</span>
<span class="nc" id="L4780">                cfw.addALoad(right_dcp_register);</span>

<span class="nc" id="L4782">            } else {</span>
<span class="nc" id="L4783">                generateExpression(child, node);</span>
<span class="nc" id="L4784">                generateExpression(rChild, node);</span>
            }

<span class="nc bnc" id="L4787" title="All 4 branches missed.">            if (type == Token.GE || type == Token.GT) {</span>
<span class="nc" id="L4788">                cfw.add(ByteCode.SWAP);</span>
            }
<span class="nc bnc" id="L4790" title="All 4 branches missed.">            String routine = ((type == Token.LT)</span>
                      || (type == Token.GT)) ? &quot;cmp_LT&quot; : &quot;cmp_LE&quot;;
<span class="nc" id="L4792">            addScriptRuntimeInvoke(routine,</span>
                                   &quot;(Ljava/lang/Object;&quot;
                                   +&quot;Ljava/lang/Object;&quot;
                                   +&quot;)Z&quot;);
<span class="nc" id="L4796">            cfw.add(ByteCode.IFNE, trueGOTO);</span>
<span class="nc" id="L4797">            cfw.add(ByteCode.GOTO, falseGOTO);</span>
        }
<span class="nc" id="L4799">    }</span>

    private void visitIfJumpEqOp(Node node, Node child,
                                 int trueGOTO, int falseGOTO)
    {
<span class="nc bnc" id="L4804" title="All 4 branches missed.">        if (trueGOTO == -1 || falseGOTO == -1) throw Codegen.badTree();</span>

<span class="nc" id="L4806">        short stackInitial = cfw.getStackTop();</span>
<span class="nc" id="L4807">        int type = node.getType();</span>
<span class="nc" id="L4808">        Node rChild = child.getNext();</span>

        // Optimize if one of operands is null
<span class="nc bnc" id="L4811" title="All 4 branches missed.">        if (child.getType() == Token.NULL || rChild.getType() == Token.NULL) {</span>
            // eq is symmetric in this case
<span class="nc bnc" id="L4813" title="All 2 branches missed.">            if (child.getType() == Token.NULL) {</span>
<span class="nc" id="L4814">                child = rChild;</span>
            }
<span class="nc" id="L4816">            generateExpression(child, node);</span>
<span class="nc bnc" id="L4817" title="All 4 branches missed.">            if (type == Token.SHEQ || type == Token.SHNE) {</span>
<span class="nc bnc" id="L4818" title="All 2 branches missed.">                int testCode = (type == Token.SHEQ)</span>
                                ? ByteCode.IFNULL : ByteCode.IFNONNULL;
<span class="nc" id="L4820">                cfw.add(testCode, trueGOTO);</span>
<span class="nc" id="L4821">            } else {</span>
<span class="nc bnc" id="L4822" title="All 2 branches missed.">                if (type != Token.EQ) {</span>
                    // swap false/true targets for !=
<span class="nc bnc" id="L4824" title="All 2 branches missed.">                    if (type != Token.NE) throw Codegen.badTree();</span>
<span class="nc" id="L4825">                    int tmp = trueGOTO;</span>
<span class="nc" id="L4826">                    trueGOTO = falseGOTO;</span>
<span class="nc" id="L4827">                    falseGOTO = tmp;</span>
                }
<span class="nc" id="L4829">                cfw.add(ByteCode.DUP);</span>
<span class="nc" id="L4830">                int undefCheckLabel = cfw.acquireLabel();</span>
<span class="nc" id="L4831">                cfw.add(ByteCode.IFNONNULL, undefCheckLabel);</span>
<span class="nc" id="L4832">                short stack = cfw.getStackTop();</span>
<span class="nc" id="L4833">                cfw.add(ByteCode.POP);</span>
<span class="nc" id="L4834">                cfw.add(ByteCode.GOTO, trueGOTO);</span>
<span class="nc" id="L4835">                cfw.markLabel(undefCheckLabel, stack);</span>
<span class="nc" id="L4836">                Codegen.pushUndefined(cfw);</span>
<span class="nc" id="L4837">                cfw.add(ByteCode.IF_ACMPEQ, trueGOTO);</span>
            }
<span class="nc" id="L4839">            cfw.add(ByteCode.GOTO, falseGOTO);</span>
        } else {
<span class="nc" id="L4841">            int child_dcp_register = nodeIsDirectCallParameter(child);</span>
<span class="nc bnc" id="L4842" title="All 2 branches missed.">            if (child_dcp_register != -1</span>
<span class="nc bnc" id="L4843" title="All 2 branches missed.">                &amp;&amp; rChild.getType() == Token.TO_OBJECT)</span>
            {
<span class="nc" id="L4845">                Node convertChild = rChild.getFirstChild();</span>
<span class="nc bnc" id="L4846" title="All 2 branches missed.">                if (convertChild.getType() == Token.NUMBER) {</span>
<span class="nc" id="L4847">                    cfw.addALoad(child_dcp_register);</span>
<span class="nc" id="L4848">                    cfw.add(ByteCode.GETSTATIC,</span>
                            &quot;java/lang/Void&quot;,
                            &quot;TYPE&quot;,
                            &quot;Ljava/lang/Class;&quot;);
<span class="nc" id="L4852">                    int notNumbersLabel = cfw.acquireLabel();</span>
<span class="nc" id="L4853">                    cfw.add(ByteCode.IF_ACMPNE, notNumbersLabel);</span>
<span class="nc" id="L4854">                    cfw.addDLoad(child_dcp_register + 1);</span>
<span class="nc" id="L4855">                    cfw.addPush(convertChild.getDouble());</span>
<span class="nc" id="L4856">                    cfw.add(ByteCode.DCMPL);</span>
<span class="nc bnc" id="L4857" title="All 2 branches missed.">                    if (type == Token.EQ)</span>
<span class="nc" id="L4858">                        cfw.add(ByteCode.IFEQ, trueGOTO);</span>
                    else
<span class="nc" id="L4860">                        cfw.add(ByteCode.IFNE, trueGOTO);</span>
<span class="nc" id="L4861">                    cfw.add(ByteCode.GOTO, falseGOTO);</span>
<span class="nc" id="L4862">                    cfw.markLabel(notNumbersLabel);</span>
                    // fall thru into generic handling
                }
            }

<span class="nc" id="L4867">            generateExpression(child, node);</span>
<span class="nc" id="L4868">            generateExpression(rChild, node);</span>

            String name;
            int testCode;
<span class="nc bnc" id="L4872" title="All 5 branches missed.">            switch (type) {</span>
              case Token.EQ:
<span class="nc" id="L4874">                name = &quot;eq&quot;;</span>
<span class="nc" id="L4875">                testCode = ByteCode.IFNE;</span>
<span class="nc" id="L4876">                break;</span>
              case Token.NE:
<span class="nc" id="L4878">                name = &quot;eq&quot;;</span>
<span class="nc" id="L4879">                testCode = ByteCode.IFEQ;</span>
<span class="nc" id="L4880">                break;</span>
              case Token.SHEQ:
<span class="nc" id="L4882">                name = &quot;shallowEq&quot;;</span>
<span class="nc" id="L4883">                testCode = ByteCode.IFNE;</span>
<span class="nc" id="L4884">                break;</span>
              case Token.SHNE:
<span class="nc" id="L4886">                name = &quot;shallowEq&quot;;</span>
<span class="nc" id="L4887">                testCode = ByteCode.IFEQ;</span>
<span class="nc" id="L4888">                break;</span>
              default:
<span class="nc" id="L4890">                throw Codegen.badTree();</span>
            }
<span class="nc" id="L4892">            addScriptRuntimeInvoke(name,</span>
                                   &quot;(Ljava/lang/Object;&quot;
                                   +&quot;Ljava/lang/Object;&quot;
                                   +&quot;)Z&quot;);
<span class="nc" id="L4896">            cfw.add(testCode, trueGOTO);</span>
<span class="nc" id="L4897">            cfw.add(ByteCode.GOTO, falseGOTO);</span>
        }
<span class="nc bnc" id="L4899" title="All 2 branches missed.">        if (stackInitial != cfw.getStackTop()) throw Codegen.badTree();</span>
<span class="nc" id="L4900">    }</span>

    private void visitSetName(Node node, Node child)
    {
<span class="nc" id="L4904">        String name = node.getFirstChild().getString();</span>
<span class="nc bnc" id="L4905" title="All 2 branches missed.">        while (child != null) {</span>
<span class="nc" id="L4906">            generateExpression(child, node);</span>
<span class="nc" id="L4907">            child = child.getNext();</span>
        }
<span class="nc" id="L4909">        cfw.addALoad(contextLocal);</span>
<span class="nc" id="L4910">        cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L4911">        cfw.addPush(name);</span>
<span class="nc" id="L4912">        addScriptRuntimeInvoke(</span>
            &quot;setName&quot;,
            &quot;(Lorg/mozilla/javascript/Scriptable;&quot;
            +&quot;Ljava/lang/Object;&quot;
            +&quot;Lorg/mozilla/javascript/Context;&quot;
            +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
            +&quot;Ljava/lang/String;&quot;
            +&quot;)Ljava/lang/Object;&quot;);
<span class="nc" id="L4920">    }</span>

    private void visitStrictSetName(Node node, Node child)
    {
<span class="nc" id="L4924">        String name = node.getFirstChild().getString();</span>
<span class="nc bnc" id="L4925" title="All 2 branches missed.">        while (child != null) {</span>
<span class="nc" id="L4926">            generateExpression(child, node);</span>
<span class="nc" id="L4927">            child = child.getNext();</span>
        }
<span class="nc" id="L4929">        cfw.addALoad(contextLocal);</span>
<span class="nc" id="L4930">        cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L4931">        cfw.addPush(name);</span>
<span class="nc" id="L4932">        addScriptRuntimeInvoke(</span>
            &quot;strictSetName&quot;,
            &quot;(Lorg/mozilla/javascript/Scriptable;&quot;
            +&quot;Ljava/lang/Object;&quot;
            +&quot;Lorg/mozilla/javascript/Context;&quot;
            +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
            +&quot;Ljava/lang/String;&quot;
            +&quot;)Ljava/lang/Object;&quot;);
<span class="nc" id="L4940">    }</span>

    private void visitSetConst(Node node, Node child)
    {
<span class="nc" id="L4944">        String name = node.getFirstChild().getString();</span>
<span class="nc bnc" id="L4945" title="All 2 branches missed.">        while (child != null) {</span>
<span class="nc" id="L4946">            generateExpression(child, node);</span>
<span class="nc" id="L4947">            child = child.getNext();</span>
        }
<span class="nc" id="L4949">        cfw.addALoad(contextLocal);</span>
<span class="nc" id="L4950">        cfw.addPush(name);</span>
<span class="nc" id="L4951">        addScriptRuntimeInvoke(</span>
            &quot;setConst&quot;,
            &quot;(Lorg/mozilla/javascript/Scriptable;&quot;
            +&quot;Ljava/lang/Object;&quot;
            +&quot;Lorg/mozilla/javascript/Context;&quot;
            +&quot;Ljava/lang/String;&quot;
            +&quot;)Ljava/lang/Object;&quot;);
<span class="nc" id="L4958">    }</span>

    private void visitGetVar(Node node)
    {
<span class="nc bnc" id="L4962" title="All 2 branches missed.">        if (!hasVarsInRegs) Kit.codeBug();</span>
<span class="nc" id="L4963">        int varIndex = fnCurrent.getVarIndex(node);</span>
<span class="nc" id="L4964">        short reg = varRegisters[varIndex];</span>
<span class="nc bnc" id="L4965" title="All 2 branches missed.">        if (varIsDirectCallParameter(varIndex)) {</span>
            // Remember that here the isNumber flag means that we
            // want to use the incoming parameter in a Number
            // context, so test the object type and convert the
            //  value as necessary.
<span class="nc bnc" id="L4970" title="All 2 branches missed.">            if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) {</span>
<span class="nc" id="L4971">                dcpLoadAsNumber(reg);</span>
            } else {
<span class="nc" id="L4973">                dcpLoadAsObject(reg);</span>
            }
<span class="nc bnc" id="L4975" title="All 2 branches missed.">        } else if (fnCurrent.isNumberVar(varIndex)) {</span>
<span class="nc" id="L4976">            cfw.addDLoad(reg);</span>
        } else {
<span class="nc" id="L4978">            cfw.addALoad(reg);</span>
        }
<span class="nc" id="L4980">    }</span>

    private void visitSetVar(Node node, Node child, boolean needValue)
    {
<span class="nc bnc" id="L4984" title="All 2 branches missed.">        if (!hasVarsInRegs) Kit.codeBug();</span>
<span class="nc" id="L4985">        int varIndex = fnCurrent.getVarIndex(node);</span>
<span class="nc" id="L4986">        generateExpression(child.getNext(), node);</span>
<span class="nc bnc" id="L4987" title="All 2 branches missed.">        boolean isNumber = (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1);</span>
<span class="nc" id="L4988">        short reg = varRegisters[varIndex];</span>
<span class="nc" id="L4989">        boolean [] constDeclarations = fnCurrent.fnode.getParamAndVarConst();</span>
<span class="nc bnc" id="L4990" title="All 2 branches missed.">        if (constDeclarations[varIndex]) {</span>
<span class="nc bnc" id="L4991" title="All 2 branches missed.">            if (!needValue) {</span>
<span class="nc bnc" id="L4992" title="All 2 branches missed.">                if (isNumber)</span>
<span class="nc" id="L4993">                    cfw.add(ByteCode.POP2);</span>
                else
<span class="nc" id="L4995">                    cfw.add(ByteCode.POP);</span>
            }
        }
<span class="nc bnc" id="L4998" title="All 2 branches missed.">        else if (varIsDirectCallParameter(varIndex)) {</span>
<span class="nc bnc" id="L4999" title="All 2 branches missed.">            if (isNumber) {</span>
<span class="nc bnc" id="L5000" title="All 2 branches missed.">                if (needValue) cfw.add(ByteCode.DUP2);</span>
<span class="nc" id="L5001">                cfw.addALoad(reg);</span>
<span class="nc" id="L5002">                cfw.add(ByteCode.GETSTATIC,</span>
                        &quot;java/lang/Void&quot;,
                        &quot;TYPE&quot;,
                        &quot;Ljava/lang/Class;&quot;);
<span class="nc" id="L5006">                int isNumberLabel = cfw.acquireLabel();</span>
<span class="nc" id="L5007">                int beyond = cfw.acquireLabel();</span>
<span class="nc" id="L5008">                cfw.add(ByteCode.IF_ACMPEQ, isNumberLabel);</span>
<span class="nc" id="L5009">                short stack = cfw.getStackTop();</span>
<span class="nc" id="L5010">                addDoubleWrap();</span>
<span class="nc" id="L5011">                cfw.addAStore(reg);</span>
<span class="nc" id="L5012">                cfw.add(ByteCode.GOTO, beyond);</span>
<span class="nc" id="L5013">                cfw.markLabel(isNumberLabel, stack);</span>
<span class="nc" id="L5014">                cfw.addDStore(reg + 1);</span>
<span class="nc" id="L5015">                cfw.markLabel(beyond);</span>
<span class="nc" id="L5016">            }</span>
            else {
<span class="nc bnc" id="L5018" title="All 2 branches missed.">                if (needValue) cfw.add(ByteCode.DUP);</span>
<span class="nc" id="L5019">                cfw.addAStore(reg);</span>
            }
        } else {
<span class="nc" id="L5022">            boolean isNumberVar = fnCurrent.isNumberVar(varIndex);</span>
<span class="nc bnc" id="L5023" title="All 2 branches missed.">            if (isNumber) {</span>
<span class="nc bnc" id="L5024" title="All 2 branches missed.">                if (isNumberVar) {</span>
<span class="nc" id="L5025">                    cfw.addDStore(reg);</span>
<span class="nc bnc" id="L5026" title="All 2 branches missed.">                    if (needValue) cfw.addDLoad(reg);</span>
                } else {
<span class="nc bnc" id="L5028" title="All 2 branches missed.">                    if (needValue) cfw.add(ByteCode.DUP2);</span>
                    // Cannot save number in variable since !isNumberVar,
                    // so convert to object
<span class="nc" id="L5031">                    addDoubleWrap();</span>
<span class="nc" id="L5032">                    cfw.addAStore(reg);</span>
                }
            } else {
<span class="nc bnc" id="L5035" title="All 2 branches missed.">                if (isNumberVar) Kit.codeBug();</span>
<span class="nc" id="L5036">                cfw.addAStore(reg);</span>
<span class="nc bnc" id="L5037" title="All 2 branches missed.">                if (needValue) cfw.addALoad(reg);</span>
            }
        }
<span class="nc" id="L5040">    }</span>

    private void visitSetConstVar(Node node, Node child, boolean needValue)
    {
<span class="nc bnc" id="L5044" title="All 2 branches missed.">        if (!hasVarsInRegs) Kit.codeBug();</span>
<span class="nc" id="L5045">        int varIndex = fnCurrent.getVarIndex(node);</span>
<span class="nc" id="L5046">        generateExpression(child.getNext(), node);</span>
<span class="nc bnc" id="L5047" title="All 2 branches missed.">        boolean isNumber = (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1);</span>
<span class="nc" id="L5048">        short reg = varRegisters[varIndex];</span>
<span class="nc" id="L5049">        int beyond = cfw.acquireLabel();</span>
<span class="nc" id="L5050">        int noAssign = cfw.acquireLabel();</span>
<span class="nc bnc" id="L5051" title="All 2 branches missed.">        if (isNumber) {</span>
<span class="nc" id="L5052">            cfw.addILoad(reg + 2);</span>
<span class="nc" id="L5053">            cfw.add(ByteCode.IFNE, noAssign);</span>
<span class="nc" id="L5054">            short stack = cfw.getStackTop();</span>
<span class="nc" id="L5055">            cfw.addPush(1);</span>
<span class="nc" id="L5056">            cfw.addIStore(reg + 2);</span>
<span class="nc" id="L5057">            cfw.addDStore(reg);</span>
<span class="nc bnc" id="L5058" title="All 2 branches missed.">            if (needValue) {</span>
<span class="nc" id="L5059">                cfw.addDLoad(reg);</span>
<span class="nc" id="L5060">                cfw.markLabel(noAssign, stack);</span>
            } else {
<span class="nc" id="L5062">                cfw.add(ByteCode.GOTO, beyond);</span>
<span class="nc" id="L5063">                cfw.markLabel(noAssign, stack);</span>
<span class="nc" id="L5064">                cfw.add(ByteCode.POP2);</span>
            }
<span class="nc" id="L5066">        }</span>
        else {
<span class="nc" id="L5068">            cfw.addILoad(reg + 1);</span>
<span class="nc" id="L5069">            cfw.add(ByteCode.IFNE, noAssign);</span>
<span class="nc" id="L5070">            short stack = cfw.getStackTop();</span>
<span class="nc" id="L5071">            cfw.addPush(1);</span>
<span class="nc" id="L5072">            cfw.addIStore(reg + 1);</span>
<span class="nc" id="L5073">            cfw.addAStore(reg);</span>
<span class="nc bnc" id="L5074" title="All 2 branches missed.">            if (needValue) {</span>
<span class="nc" id="L5075">                cfw.addALoad(reg);</span>
<span class="nc" id="L5076">                cfw.markLabel(noAssign, stack);</span>
            } else {
<span class="nc" id="L5078">                cfw.add(ByteCode.GOTO, beyond);</span>
<span class="nc" id="L5079">                cfw.markLabel(noAssign, stack);</span>
<span class="nc" id="L5080">                cfw.add(ByteCode.POP);</span>
            }
        }
<span class="nc" id="L5083">        cfw.markLabel(beyond);</span>
<span class="nc" id="L5084">    }</span>

    private void visitGetProp(Node node, Node child)
    {
<span class="fc" id="L5088">        generateExpression(child, node); // object</span>
<span class="fc" id="L5089">        Node nameChild = child.getNext();</span>
<span class="fc" id="L5090">        generateExpression(nameChild, node);  // the name</span>
<span class="pc bpc" id="L5091" title="1 of 2 branches missed.">        if (node.getType() == Token.GETPROPNOWARN) {</span>
<span class="nc" id="L5092">            cfw.addALoad(contextLocal);</span>
<span class="nc" id="L5093">            cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L5094">            addScriptRuntimeInvoke(</span>
                &quot;getObjectPropNoWarn&quot;,
                &quot;(Ljava/lang/Object;&quot;
                +&quot;Ljava/lang/String;&quot;
                +&quot;Lorg/mozilla/javascript/Context;&quot;
                +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                +&quot;)Ljava/lang/Object;&quot;);
<span class="nc" id="L5101">            return;</span>
        }
        /*
            for 'this.foo' we call getObjectProp(Scriptable...) which can
            skip some casting overhead.
        */
<span class="fc" id="L5107">        int childType = child.getType();</span>
<span class="pc bpc" id="L5108" title="3 of 4 branches missed.">        if (childType == Token.THIS &amp;&amp; nameChild.getType() == Token.STRING) {</span>
<span class="nc" id="L5109">            cfw.addALoad(contextLocal);</span>
<span class="nc" id="L5110">            addScriptRuntimeInvoke(</span>
                &quot;getObjectProp&quot;,
                &quot;(Lorg/mozilla/javascript/Scriptable;&quot;
                +&quot;Ljava/lang/String;&quot;
                +&quot;Lorg/mozilla/javascript/Context;&quot;
                +&quot;)Ljava/lang/Object;&quot;);
        } else {
<span class="fc" id="L5117">            cfw.addALoad(contextLocal);</span>
<span class="fc" id="L5118">            cfw.addALoad(variableObjectLocal);</span>
<span class="fc" id="L5119">            addScriptRuntimeInvoke(</span>
                &quot;getObjectProp&quot;,
                &quot;(Ljava/lang/Object;&quot;
                +&quot;Ljava/lang/String;&quot;
                +&quot;Lorg/mozilla/javascript/Context;&quot;
                +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                +&quot;)Ljava/lang/Object;&quot;);
        }
<span class="fc" id="L5127">    }</span>

    private void visitSetProp(int type, Node node, Node child)
    {
<span class="nc" id="L5131">        Node objectChild = child;</span>
<span class="nc" id="L5132">        generateExpression(child, node);</span>
<span class="nc" id="L5133">        child = child.getNext();</span>
<span class="nc bnc" id="L5134" title="All 2 branches missed.">        if (type == Token.SETPROP_OP) {</span>
<span class="nc" id="L5135">            cfw.add(ByteCode.DUP);</span>
        }
<span class="nc" id="L5137">        Node nameChild = child;</span>
<span class="nc" id="L5138">        generateExpression(child, node);</span>
<span class="nc" id="L5139">        child = child.getNext();</span>
<span class="nc bnc" id="L5140" title="All 2 branches missed.">        if (type == Token.SETPROP_OP) {</span>
            // stack: ... object object name -&gt; ... object name object name
<span class="nc" id="L5142">            cfw.add(ByteCode.DUP_X1);</span>
            //for 'this.foo += ...' we call thisGet which can skip some
            //casting overhead.
<span class="nc bnc" id="L5145" title="All 2 branches missed.">            if (objectChild.getType() == Token.THIS</span>
<span class="nc bnc" id="L5146" title="All 2 branches missed.">                &amp;&amp; nameChild.getType() == Token.STRING)</span>
            {
<span class="nc" id="L5148">                cfw.addALoad(contextLocal);</span>
<span class="nc" id="L5149">                addScriptRuntimeInvoke(</span>
                    &quot;getObjectProp&quot;,
                    &quot;(Lorg/mozilla/javascript/Scriptable;&quot;
                    +&quot;Ljava/lang/String;&quot;
                    +&quot;Lorg/mozilla/javascript/Context;&quot;
                    +&quot;)Ljava/lang/Object;&quot;);
            } else {
<span class="nc" id="L5156">                cfw.addALoad(contextLocal);</span>
<span class="nc" id="L5157">                cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L5158">                addScriptRuntimeInvoke(</span>
                    &quot;getObjectProp&quot;,
                    &quot;(Ljava/lang/Object;&quot;
                    +&quot;Ljava/lang/String;&quot;
                    +&quot;Lorg/mozilla/javascript/Context;&quot;
                    +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                    +&quot;)Ljava/lang/Object;&quot;);
            }
        }
<span class="nc" id="L5167">        generateExpression(child, node);</span>
<span class="nc" id="L5168">        cfw.addALoad(contextLocal);</span>
<span class="nc" id="L5169">        cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L5170">        addScriptRuntimeInvoke(</span>
            &quot;setObjectProp&quot;,
            &quot;(Ljava/lang/Object;&quot;
            +&quot;Ljava/lang/String;&quot;
            +&quot;Ljava/lang/Object;&quot;
            +&quot;Lorg/mozilla/javascript/Context;&quot;
            +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
            +&quot;)Ljava/lang/Object;&quot;);
<span class="nc" id="L5178">    }</span>

    private void visitSetElem(int type, Node node, Node child)
    {
<span class="nc" id="L5182">        generateExpression(child, node);</span>
<span class="nc" id="L5183">        child = child.getNext();</span>
<span class="nc bnc" id="L5184" title="All 2 branches missed.">        if (type == Token.SETELEM_OP) {</span>
<span class="nc" id="L5185">            cfw.add(ByteCode.DUP);</span>
        }
<span class="nc" id="L5187">        generateExpression(child, node);</span>
<span class="nc" id="L5188">        child = child.getNext();</span>
<span class="nc bnc" id="L5189" title="All 2 branches missed.">        boolean indexIsNumber = (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1);</span>
<span class="nc bnc" id="L5190" title="All 2 branches missed.">        if (type == Token.SETELEM_OP) {</span>
<span class="nc bnc" id="L5191" title="All 2 branches missed.">            if (indexIsNumber) {</span>
                // stack: ... object object number
                //        -&gt; ... object number object number
<span class="nc" id="L5194">                cfw.add(ByteCode.DUP2_X1);</span>
<span class="nc" id="L5195">                cfw.addALoad(contextLocal);</span>
<span class="nc" id="L5196">                cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L5197">                addScriptRuntimeInvoke(</span>
                    &quot;getObjectIndex&quot;,
                    &quot;(Ljava/lang/Object;D&quot;
                    +&quot;Lorg/mozilla/javascript/Context;&quot;
                    +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                    +&quot;)Ljava/lang/Object;&quot;);
            } else {
                // stack: ... object object indexObject
                //        -&gt; ... object indexObject object indexObject
<span class="nc" id="L5206">                cfw.add(ByteCode.DUP_X1);</span>
<span class="nc" id="L5207">                cfw.addALoad(contextLocal);</span>
<span class="nc" id="L5208">                cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L5209">                addScriptRuntimeInvoke(</span>
                    &quot;getObjectElem&quot;,
                    &quot;(Ljava/lang/Object;&quot;
                    +&quot;Ljava/lang/Object;&quot;
                    +&quot;Lorg/mozilla/javascript/Context;&quot;
                    +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                    +&quot;)Ljava/lang/Object;&quot;);
            }
        }
<span class="nc" id="L5218">        generateExpression(child, node);</span>
<span class="nc" id="L5219">        cfw.addALoad(contextLocal);</span>
<span class="nc" id="L5220">        cfw.addALoad(variableObjectLocal);</span>
<span class="nc bnc" id="L5221" title="All 2 branches missed.">        if (indexIsNumber) {</span>
<span class="nc" id="L5222">            addScriptRuntimeInvoke(</span>
                &quot;setObjectIndex&quot;,
                &quot;(Ljava/lang/Object;&quot;
                +&quot;D&quot;
                +&quot;Ljava/lang/Object;&quot;
                +&quot;Lorg/mozilla/javascript/Context;&quot;
                +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                +&quot;)Ljava/lang/Object;&quot;);
        } else {
<span class="nc" id="L5231">            addScriptRuntimeInvoke(</span>
                &quot;setObjectElem&quot;,
                &quot;(Ljava/lang/Object;&quot;
                +&quot;Ljava/lang/Object;&quot;
                +&quot;Ljava/lang/Object;&quot;
                +&quot;Lorg/mozilla/javascript/Context;&quot;
                +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                +&quot;)Ljava/lang/Object;&quot;);
        }
<span class="nc" id="L5240">    }</span>

    private void visitDotQuery(Node node, Node child)
    {
<span class="nc" id="L5244">        updateLineNumber(node);</span>
<span class="nc" id="L5245">        generateExpression(child, node);</span>
<span class="nc" id="L5246">        cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L5247">        addScriptRuntimeInvoke(&quot;enterDotQuery&quot;,</span>
                               &quot;(Ljava/lang/Object;&quot;
                               +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                               +&quot;)Lorg/mozilla/javascript/Scriptable;&quot;);
<span class="nc" id="L5251">        cfw.addAStore(variableObjectLocal);</span>

        // add push null/pop with label in between to simplify code for loop
        // continue when it is necessary to pop the null result from
        // updateDotQuery
<span class="nc" id="L5256">        cfw.add(ByteCode.ACONST_NULL);</span>
<span class="nc" id="L5257">        int queryLoopStart = cfw.acquireLabel();</span>
<span class="nc" id="L5258">        cfw.markLabel(queryLoopStart); // loop continue jumps here</span>
<span class="nc" id="L5259">        cfw.add(ByteCode.POP);</span>

<span class="nc" id="L5261">        generateExpression(child.getNext(), node);</span>
<span class="nc" id="L5262">        addScriptRuntimeInvoke(&quot;toBoolean&quot;, &quot;(Ljava/lang/Object;)Z&quot;);</span>
<span class="nc" id="L5263">        cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L5264">        addScriptRuntimeInvoke(&quot;updateDotQuery&quot;,</span>
                               &quot;(Z&quot;
                               +&quot;Lorg/mozilla/javascript/Scriptable;&quot;
                               +&quot;)Ljava/lang/Object;&quot;);
<span class="nc" id="L5268">        cfw.add(ByteCode.DUP);</span>
<span class="nc" id="L5269">        cfw.add(ByteCode.IFNULL, queryLoopStart);</span>
        // stack: ... non_null_result_of_updateDotQuery
<span class="nc" id="L5271">        cfw.addALoad(variableObjectLocal);</span>
<span class="nc" id="L5272">        addScriptRuntimeInvoke(&quot;leaveDotQuery&quot;,</span>
                               &quot;(Lorg/mozilla/javascript/Scriptable;&quot;
                               +&quot;)Lorg/mozilla/javascript/Scriptable;&quot;);
<span class="nc" id="L5275">        cfw.addAStore(variableObjectLocal);</span>
<span class="nc" id="L5276">    }</span>

    private int getLocalBlockRegister(Node node)
    {
<span class="nc" id="L5280">        Node localBlock = (Node)node.getProp(Node.LOCAL_BLOCK_PROP);</span>
<span class="nc" id="L5281">        int localSlot = localBlock.getExistingIntProp(Node.LOCAL_PROP);</span>
<span class="nc" id="L5282">        return localSlot;</span>
    }

    private void dcpLoadAsNumber(int dcp_register)
    {
<span class="nc" id="L5287">        cfw.addALoad(dcp_register);</span>
<span class="nc" id="L5288">        cfw.add(ByteCode.GETSTATIC,</span>
                &quot;java/lang/Void&quot;,
                &quot;TYPE&quot;,
                &quot;Ljava/lang/Class;&quot;);
<span class="nc" id="L5292">        int isNumberLabel = cfw.acquireLabel();</span>
<span class="nc" id="L5293">        cfw.add(ByteCode.IF_ACMPEQ, isNumberLabel);</span>
<span class="nc" id="L5294">        short stack = cfw.getStackTop();</span>
<span class="nc" id="L5295">        cfw.addALoad(dcp_register);</span>
<span class="nc" id="L5296">        addObjectToDouble();</span>
<span class="nc" id="L5297">        int beyond = cfw.acquireLabel();</span>
<span class="nc" id="L5298">        cfw.add(ByteCode.GOTO, beyond);</span>
<span class="nc" id="L5299">        cfw.markLabel(isNumberLabel, stack);</span>
<span class="nc" id="L5300">        cfw.addDLoad(dcp_register + 1);</span>
<span class="nc" id="L5301">        cfw.markLabel(beyond);</span>
<span class="nc" id="L5302">    }</span>

    private void dcpLoadAsObject(int dcp_register)
    {
<span class="nc" id="L5306">        cfw.addALoad(dcp_register);</span>
<span class="nc" id="L5307">        cfw.add(ByteCode.GETSTATIC,</span>
                &quot;java/lang/Void&quot;,
                &quot;TYPE&quot;,
                &quot;Ljava/lang/Class;&quot;);
<span class="nc" id="L5311">        int isNumberLabel = cfw.acquireLabel();</span>
<span class="nc" id="L5312">        cfw.add(ByteCode.IF_ACMPEQ, isNumberLabel);</span>
<span class="nc" id="L5313">        short stack = cfw.getStackTop();</span>
<span class="nc" id="L5314">        cfw.addALoad(dcp_register);</span>
<span class="nc" id="L5315">        int beyond = cfw.acquireLabel();</span>
<span class="nc" id="L5316">        cfw.add(ByteCode.GOTO, beyond);</span>
<span class="nc" id="L5317">        cfw.markLabel(isNumberLabel, stack);</span>
<span class="nc" id="L5318">        cfw.addDLoad(dcp_register + 1);</span>
<span class="nc" id="L5319">        addDoubleWrap();</span>
<span class="nc" id="L5320">        cfw.markLabel(beyond);</span>
<span class="nc" id="L5321">    }</span>

    private void addGoto(Node target, int jumpcode)
    {
<span class="nc" id="L5325">        int targetLabel = getTargetLabel(target);</span>
<span class="nc" id="L5326">        cfw.add(jumpcode, targetLabel);</span>
<span class="nc" id="L5327">    }</span>

    private void addObjectToDouble()
    {
<span class="nc" id="L5331">        addScriptRuntimeInvoke(&quot;toNumber&quot;, &quot;(Ljava/lang/Object;)D&quot;);</span>
<span class="nc" id="L5332">    }</span>

    private void addNewObjectArray(int size)
    {
<span class="nc bnc" id="L5336" title="All 2 branches missed.">        if (size == 0) {</span>
<span class="nc bnc" id="L5337" title="All 2 branches missed.">            if (itsZeroArgArray &gt;= 0) {</span>
<span class="nc" id="L5338">                cfw.addALoad(itsZeroArgArray);</span>
            } else {
<span class="nc" id="L5340">                cfw.add(ByteCode.GETSTATIC,</span>
                        &quot;org/mozilla/javascript/ScriptRuntime&quot;,
                        &quot;emptyArgs&quot;, &quot;[Ljava/lang/Object;&quot;);
            }
        } else {
<span class="nc" id="L5345">            cfw.addPush(size);</span>
<span class="nc" id="L5346">            cfw.add(ByteCode.ANEWARRAY, &quot;java/lang/Object&quot;);</span>
        }
<span class="nc" id="L5348">    }</span>

    private void addScriptRuntimeInvoke(String methodName,
                                        String methodSignature)
    {
<span class="fc" id="L5353">        cfw.addInvoke(ByteCode.INVOKESTATIC,</span>
                      &quot;org.mozilla.javascript.ScriptRuntime&quot;,
                      methodName,
                      methodSignature);
<span class="fc" id="L5357">    }</span>

    private void addOptRuntimeInvoke(String methodName,
                                     String methodSignature)
    {
<span class="nc" id="L5362">        cfw.addInvoke(ByteCode.INVOKESTATIC,</span>
                      &quot;org/mozilla/javascript/optimizer/OptRuntime&quot;,
                      methodName,
                      methodSignature);
<span class="nc" id="L5366">    }</span>

    private void addJumpedBooleanWrap(int trueLabel, int falseLabel)
    {
<span class="nc" id="L5370">        cfw.markLabel(falseLabel);</span>
<span class="nc" id="L5371">        int skip = cfw.acquireLabel();</span>
<span class="nc" id="L5372">        cfw.add(ByteCode.GETSTATIC, &quot;java/lang/Boolean&quot;,</span>
                                &quot;FALSE&quot;, &quot;Ljava/lang/Boolean;&quot;);
<span class="nc" id="L5374">        cfw.add(ByteCode.GOTO, skip);</span>
<span class="nc" id="L5375">        cfw.markLabel(trueLabel);</span>
<span class="nc" id="L5376">        cfw.add(ByteCode.GETSTATIC, &quot;java/lang/Boolean&quot;,</span>
                                &quot;TRUE&quot;, &quot;Ljava/lang/Boolean;&quot;);
<span class="nc" id="L5378">        cfw.markLabel(skip);</span>
<span class="nc" id="L5379">        cfw.adjustStackTop(-1);   // only have 1 of true/false</span>
<span class="nc" id="L5380">    }</span>

    private void addDoubleWrap()
    {
<span class="nc" id="L5384">        addOptRuntimeInvoke(&quot;wrapDouble&quot;, &quot;(D)Ljava/lang/Double;&quot;);</span>
<span class="nc" id="L5385">    }</span>

    /**
     * Const locals use an extra slot to hold the has-been-assigned-once flag at
     * runtime.
     * @param isConst true iff the variable is const
     * @return the register for the word pair (double/long)
     */
    private short getNewWordPairLocal(boolean isConst)
    {
<span class="nc bnc" id="L5395" title="All 2 branches missed.">        return getNewWordIntern(isConst ? 3 : 2);</span>
    }

    private short getNewWordLocal(boolean isConst)
    {
<span class="nc bnc" id="L5400" title="All 2 branches missed.">        return getNewWordIntern(isConst ? 2 : 1);</span>
    }

    private short getNewWordLocal()
    {
<span class="fc" id="L5405">        return getNewWordIntern(1);</span>
    }

    private short getNewWordIntern(int count)
    {
<span class="pc bpc" id="L5410" title="3 of 6 branches missed.">        assert count &gt;= 1 &amp;&amp; count &lt;= 3;</span>

<span class="fc" id="L5412">        int[] locals = this.locals;</span>
<span class="fc" id="L5413">        int result = -1;</span>
<span class="pc bpc" id="L5414" title="1 of 2 branches missed.">        if (count &gt; 1) {</span>
            // we need 'count' consecutive free slots
<span class="nc bnc" id="L5416" title="All 2 branches missed.">            OUTER: for (int i = firstFreeLocal; i + count &lt;= MAX_LOCALS;) {</span>
<span class="nc bnc" id="L5417" title="All 2 branches missed.">                for (int j = 0; j &lt; count; ++j) {</span>
<span class="nc bnc" id="L5418" title="All 2 branches missed.">                    if (locals[i + j] != 0) {</span>
<span class="nc" id="L5419">                        i += j + 1;</span>
<span class="nc" id="L5420">                        continue OUTER;</span>
                    }
                }
<span class="nc" id="L5423">                result = i;</span>
<span class="nc" id="L5424">                break;</span>
            }
        } else {
<span class="fc" id="L5427">            result = firstFreeLocal;</span>
        }

<span class="pc bpc" id="L5430" title="1 of 2 branches missed.">        if (result != -1) {</span>
<span class="fc" id="L5431">            locals[result] = 1;</span>
<span class="pc bpc" id="L5432" title="1 of 2 branches missed.">            if (count &gt; 1)</span>
<span class="nc" id="L5433">                locals[result + 1] = 1;</span>
<span class="pc bpc" id="L5434" title="1 of 2 branches missed.">            if (count &gt; 2)</span>
<span class="nc" id="L5435">                locals[result + 2] = 1;</span>

<span class="pc bpc" id="L5437" title="1 of 2 branches missed.">            if (result == firstFreeLocal) {</span>
<span class="pc bpc" id="L5438" title="1 of 2 branches missed.">                for (int i = result + count; i &lt; MAX_LOCALS; i++) {</span>
<span class="pc bpc" id="L5439" title="1 of 2 branches missed.">                    if (locals[i] == 0) {</span>
<span class="fc" id="L5440">                        firstFreeLocal = (short) i;</span>
<span class="pc bpc" id="L5441" title="1 of 2 branches missed.">                        if (localsMax &lt; firstFreeLocal)</span>
<span class="fc" id="L5442">                            localsMax = firstFreeLocal;</span>
<span class="fc" id="L5443">                        return (short) result;</span>
                    }
                }
            } else {
<span class="nc" id="L5447">                return (short) result;</span>
            }
        }

<span class="nc" id="L5451">        throw Context.reportRuntimeError(&quot;Program too complex (out of locals)&quot;);</span>
    }

    // This is a valid call only for a local that is allocated by default.
    private void incReferenceWordLocal(short local)
    {
<span class="nc" id="L5457">        locals[local]++;</span>
<span class="nc" id="L5458">    }</span>

    // This is a valid call only for a local that is allocated by default.
    private void decReferenceWordLocal(short local)
    {
<span class="nc" id="L5463">        locals[local]--;</span>
<span class="nc" id="L5464">    }</span>

    private void releaseWordLocal(short local)
    {
<span class="nc bnc" id="L5468" title="All 2 branches missed.">        if (local &lt; firstFreeLocal)</span>
<span class="nc" id="L5469">            firstFreeLocal = local;</span>
<span class="nc" id="L5470">        locals[local] = 0;</span>
<span class="nc" id="L5471">    }</span>


    static final int GENERATOR_TERMINATE = -1;
    static final int GENERATOR_START = 0;
    static final int GENERATOR_YIELD_START = 1;

    ClassFileWriter cfw;
    Codegen codegen;
    CompilerEnvirons compilerEnv;
    ScriptNode scriptOrFn;
    public int scriptOrFnIndex;
    private int savedCodeOffset;

    private OptFunctionNode fnCurrent;

    private static final int MAX_LOCALS = 1024;
    private int[] locals;
    private short firstFreeLocal;
    private short localsMax;

    private int itsLineNumber;

    private boolean hasVarsInRegs;
    private short[] varRegisters;
    private boolean inDirectCallFunction;
    private boolean itsForcedObjectParameters;
    private int enterAreaStartLabel;
    private int epilogueLabel;
    private boolean inLocalBlock;

    // special known locals. If you add a new local here, be sure
    // to initialize it to -1 in initBodyGeneration
    private short variableObjectLocal;
    private short popvLocal;
    private short contextLocal;
    private short argsLocal;
    private short operationLocal;
    private short thisObjLocal;
    private short funObjLocal;
    private short itsZeroArgArray;
    private short itsOneArgArray;
    private short generatorStateLocal;

    private boolean isGenerator;
    private int generatorSwitch;
<span class="fc" id="L5517">    private int maxLocals = 0;</span>
<span class="fc" id="L5518">    private int maxStack = 0;</span>

    private Map&lt;Node,FinallyReturnPoint&gt; finallys;
    private List&lt;Node&gt; literals;

<span class="fc" id="L5523">    static class FinallyReturnPoint {</span>
<span class="fc" id="L5524">        public List&lt;Integer&gt; jsrPoints  = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L5525">        public int tableLabel = 0;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>