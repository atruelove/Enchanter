<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ScriptRuntime.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rhino</a> &gt; <a href="index.source.html" class="el_package">org.mozilla.javascript</a> &gt; <span class="el_source">ScriptRuntime.java</span></div><h1>ScriptRuntime.java</h1><pre class="source lang-java linenums">/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.javascript;

import java.io.Serializable;
import java.lang.reflect.Constructor;
import java.text.MessageFormat;
import java.util.Locale;
import java.util.ResourceBundle;

import org.mozilla.javascript.ast.FunctionNode;
import org.mozilla.javascript.v8dtoa.DoubleConversion;
import org.mozilla.javascript.v8dtoa.FastDtoa;
import org.mozilla.javascript.xml.XMLObject;
import org.mozilla.javascript.xml.XMLLib;

/**
 * This is the class that implements the runtime.
 *
 * @author Norris Boyd
 */

public class ScriptRuntime {

    /**
     * No instances should be created.
     */
<span class="fc" id="L32">    protected ScriptRuntime() {</span>
<span class="fc" id="L33">    }</span>


    /**
     * Returns representation of the [[ThrowTypeError]] object.
     * See ECMA 5 spec, 13.2.3
     *
     * @deprecated {@link #typeErrorThrower(Context)}
     */
    @Deprecated
    public static BaseFunction typeErrorThrower() {
<span class="nc" id="L44">      return typeErrorThrower(Context.getCurrentContext());</span>
    }

    /**
     * Returns representation of the [[ThrowTypeError]] object.
     * See ECMA 5 spec, 13.2.3
     */
    public static BaseFunction typeErrorThrower(Context cx) {
<span class="nc bnc" id="L52" title="All 2 branches missed.">      if (cx.typeErrorThrower == null) {</span>
<span class="nc" id="L53">        BaseFunction thrower = new BaseFunction() {</span>
          static final long serialVersionUID = -5891740962154902286L;

          @Override
          public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
<span class="nc" id="L58">            throw typeError0(&quot;msg.op.not.allowed&quot;);</span>
          }
          @Override
          public int getLength() {
<span class="nc" id="L62">            return 0;</span>
          }
        };
<span class="nc" id="L65">        ScriptRuntime.setFunctionProtoAndParent(thrower, cx.topCallScope);</span>
<span class="nc" id="L66">        thrower.preventExtensions();</span>
<span class="nc" id="L67">        cx.typeErrorThrower = thrower;</span>
      }
<span class="nc" id="L69">      return cx.typeErrorThrower;</span>
    }

    static class NoSuchMethodShim implements Callable {
        String methodName;
        Callable noSuchMethodMethod;

        NoSuchMethodShim(Callable noSuchMethodMethod, String methodName)
<span class="nc" id="L77">        {</span>
<span class="nc" id="L78">            this.noSuchMethodMethod = noSuchMethodMethod;</span>
<span class="nc" id="L79">            this.methodName = methodName;</span>
<span class="nc" id="L80">        }</span>
        /**
         * Perform the call.
         *
         * @param cx the current Context for this thread
         * @param scope the scope to use to resolve properties.
         * @param thisObj the JavaScript &lt;code&gt;this&lt;/code&gt; object
         * @param args the array of arguments
         * @return the result of the call
         */
        public Object call(Context cx, Scriptable scope, Scriptable thisObj,
                           Object[] args)
        {
<span class="nc" id="L93">            Object[] nestedArgs = new Object[2];</span>

<span class="nc" id="L95">            nestedArgs[0] = methodName;</span>
<span class="nc" id="L96">            nestedArgs[1] = newArrayLiteral(args, null, cx, scope);</span>
<span class="nc" id="L97">            return noSuchMethodMethod.call(cx, scope, thisObj, nestedArgs);</span>
        }

    }
    /*
     * There's such a huge space (and some time) waste for the Foo.class
     * syntax: the compiler sticks in a test of a static field in the
     * enclosing class for null and the code for creating the class value.
     * It has to do this since the reference has to get pushed off until
     * execution time (i.e. can't force an early load), but for the
     * 'standard' classes - especially those in java.lang, we can trust
     * that they won't cause problems by being loaded early.
     */

    public final static Class&lt;?&gt;
<span class="fc" id="L112">        BooleanClass      = Kit.classOrNull(&quot;java.lang.Boolean&quot;),</span>
<span class="fc" id="L113">        ByteClass         = Kit.classOrNull(&quot;java.lang.Byte&quot;),</span>
<span class="fc" id="L114">        CharacterClass    = Kit.classOrNull(&quot;java.lang.Character&quot;),</span>
<span class="fc" id="L115">        ClassClass        = Kit.classOrNull(&quot;java.lang.Class&quot;),</span>
<span class="fc" id="L116">        DoubleClass       = Kit.classOrNull(&quot;java.lang.Double&quot;),</span>
<span class="fc" id="L117">        FloatClass        = Kit.classOrNull(&quot;java.lang.Float&quot;),</span>
<span class="fc" id="L118">        IntegerClass      = Kit.classOrNull(&quot;java.lang.Integer&quot;),</span>
<span class="fc" id="L119">        LongClass         = Kit.classOrNull(&quot;java.lang.Long&quot;),</span>
<span class="fc" id="L120">        NumberClass       = Kit.classOrNull(&quot;java.lang.Number&quot;),</span>
<span class="fc" id="L121">        ObjectClass       = Kit.classOrNull(&quot;java.lang.Object&quot;),</span>
<span class="fc" id="L122">        ShortClass        = Kit.classOrNull(&quot;java.lang.Short&quot;),</span>
<span class="fc" id="L123">        StringClass       = Kit.classOrNull(&quot;java.lang.String&quot;),</span>
<span class="fc" id="L124">        DateClass         = Kit.classOrNull(&quot;java.util.Date&quot;);</span>

    public final static Class&lt;?&gt;
<span class="fc" id="L127">        ContextClass</span>
<span class="fc" id="L128">            = Kit.classOrNull(&quot;org.mozilla.javascript.Context&quot;),</span>
<span class="fc" id="L129">        ContextFactoryClass</span>
<span class="fc" id="L130">            = Kit.classOrNull(&quot;org.mozilla.javascript.ContextFactory&quot;),</span>
<span class="fc" id="L131">        FunctionClass</span>
<span class="fc" id="L132">            = Kit.classOrNull(&quot;org.mozilla.javascript.Function&quot;),</span>
<span class="fc" id="L133">        ScriptableObjectClass</span>
<span class="fc" id="L134">            = Kit.classOrNull(&quot;org.mozilla.javascript.ScriptableObject&quot;);</span>
<span class="fc" id="L135">    public static final Class&lt;Scriptable&gt; ScriptableClass =</span>
        Scriptable.class;

    // Locale object used to request locale-neutral operations.
<span class="fc" id="L139">    public static Locale ROOT_LOCALE = new Locale(&quot;&quot;);</span>

<span class="fc" id="L141">    private static final Object LIBRARY_SCOPE_KEY = &quot;LIBRARY_SCOPE&quot;;</span>

    public static boolean isRhinoRuntimeType(Class&lt;?&gt; cl)
    {
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (cl.isPrimitive()) {</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">            return (cl != Character.TYPE);</span>
        } else {
<span class="nc bnc" id="L148" title="All 4 branches missed.">            return (cl == StringClass || cl == BooleanClass</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">                    || NumberClass.isAssignableFrom(cl)</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">                    || ScriptableClass.isAssignableFrom(cl));</span>
        }
    }

    public static ScriptableObject initSafeStandardObjects(Context cx,
                                                           ScriptableObject scope,
                                                           boolean sealed)
    {
<span class="fc bfc" id="L158" title="All 2 branches covered.">        if (scope == null) {</span>
<span class="fc" id="L159">            scope = new NativeObject();</span>
        }
<span class="fc" id="L161">        scope.associateValue(LIBRARY_SCOPE_KEY, scope);</span>
<span class="fc" id="L162">        (new ClassCache()).associate(scope);</span>

<span class="fc" id="L164">        BaseFunction.init(scope, sealed);</span>
<span class="fc" id="L165">        NativeObject.init(scope, sealed);</span>

<span class="fc" id="L167">        Scriptable objectProto = ScriptableObject.getObjectPrototype(scope);</span>

        // Function.prototype.__proto__ should be Object.prototype
<span class="fc" id="L170">        Scriptable functionProto = ScriptableObject.getClassPrototype(scope, &quot;Function&quot;);</span>
<span class="fc" id="L171">        functionProto.setPrototype(objectProto);</span>

        // Set the prototype of the object passed in if need be
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">        if (scope.getPrototype() == null)</span>
<span class="fc" id="L175">            scope.setPrototype(objectProto);</span>

        // must precede NativeGlobal since it's needed therein
<span class="fc" id="L178">        NativeError.init(scope, sealed);</span>
<span class="fc" id="L179">        NativeGlobal.init(cx, scope, sealed);</span>

<span class="fc" id="L181">        NativeArray.init(scope, sealed);</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">        if (cx.getOptimizationLevel() &gt; 0) {</span>
            // When optimizing, attempt to fulfill all requests for new Array(N)
            // with a higher threshold before switching to a sparse
            // representation
<span class="nc" id="L186">            NativeArray.setMaximumInitialCapacity(200000);</span>
        }
<span class="fc" id="L188">        NativeString.init(scope, sealed);</span>
<span class="fc" id="L189">        NativeBoolean.init(scope, sealed);</span>
<span class="fc" id="L190">        NativeNumber.init(scope, sealed);</span>
<span class="fc" id="L191">        NativeDate.init(scope, sealed);</span>
<span class="fc" id="L192">        NativeMath.init(scope, sealed);</span>
<span class="fc" id="L193">        NativeJSON.init(scope, sealed);</span>

<span class="fc" id="L195">        NativeWith.init(scope, sealed);</span>
<span class="fc" id="L196">        NativeCall.init(scope, sealed);</span>
<span class="fc" id="L197">        NativeScript.init(scope, sealed);</span>

<span class="fc" id="L199">        NativeIterator.init(scope, sealed); // Also initializes NativeGenerator</span>

<span class="fc" id="L201">        NativeArrayIterator.init(scope, sealed);</span>
<span class="fc" id="L202">        NativeStringIterator.init(scope, sealed);</span>

<span class="pc bpc" id="L204" title="1 of 2 branches missed.">        boolean withXml = cx.hasFeature(Context.FEATURE_E4X) &amp;&amp;</span>
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">                          cx.getE4xImplementationFactory() != null;</span>

        // define lazy-loaded properties using their class name
<span class="fc" id="L208">        new LazilyLoadedCtor(scope, &quot;RegExp&quot;,</span>
                &quot;org.mozilla.javascript.regexp.NativeRegExp&quot;, sealed, true);
<span class="fc" id="L210">        new LazilyLoadedCtor(scope, &quot;Continuation&quot;,</span>
                &quot;org.mozilla.javascript.NativeContinuation&quot;, sealed, true);

<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        if (withXml) {</span>
<span class="fc" id="L214">            String xmlImpl = cx.getE4xImplementationFactory().getImplementationClassName();</span>
<span class="fc" id="L215">            new LazilyLoadedCtor(scope, &quot;XML&quot;, xmlImpl, sealed, true);</span>
<span class="fc" id="L216">            new LazilyLoadedCtor(scope, &quot;XMLList&quot;, xmlImpl, sealed, true);</span>
<span class="fc" id="L217">            new LazilyLoadedCtor(scope, &quot;Namespace&quot;, xmlImpl, sealed, true);</span>
<span class="fc" id="L218">            new LazilyLoadedCtor(scope, &quot;QName&quot;, xmlImpl, sealed, true);</span>
        }

<span class="fc bfc" id="L221" title="All 2 branches covered.">        if (((cx.getLanguageVersion() &gt;= Context.VERSION_1_8) &amp;&amp;</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">             cx.hasFeature(Context.FEATURE_V8_EXTENSIONS)) ||</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">            (cx.getLanguageVersion() &gt;= Context.VERSION_ES6))</span>
        {
<span class="fc" id="L225">            new LazilyLoadedCtor(scope, &quot;ArrayBuffer&quot;,</span>
                                 &quot;org.mozilla.javascript.typedarrays.NativeArrayBuffer&quot;,
                                 sealed, true);
<span class="fc" id="L228">            new LazilyLoadedCtor(scope, &quot;Int8Array&quot;,</span>
                                 &quot;org.mozilla.javascript.typedarrays.NativeInt8Array&quot;,
                                 sealed, true);
<span class="fc" id="L231">            new LazilyLoadedCtor(scope, &quot;Uint8Array&quot;,</span>
                                 &quot;org.mozilla.javascript.typedarrays.NativeUint8Array&quot;,
                                 sealed, true);
<span class="fc" id="L234">            new LazilyLoadedCtor(scope, &quot;Uint8ClampedArray&quot;,</span>
                                 &quot;org.mozilla.javascript.typedarrays.NativeUint8ClampedArray&quot;,
                                 sealed, true);
<span class="fc" id="L237">            new LazilyLoadedCtor(scope, &quot;Int16Array&quot;,</span>
                                 &quot;org.mozilla.javascript.typedarrays.NativeInt16Array&quot;,
                                 sealed, true);
<span class="fc" id="L240">            new LazilyLoadedCtor(scope, &quot;Uint16Array&quot;,</span>
                                 &quot;org.mozilla.javascript.typedarrays.NativeUint16Array&quot;,
                                 sealed, true);
<span class="fc" id="L243">            new LazilyLoadedCtor(scope, &quot;Int32Array&quot;,</span>
                                 &quot;org.mozilla.javascript.typedarrays.NativeInt32Array&quot;,
                                 sealed, true);
<span class="fc" id="L246">            new LazilyLoadedCtor(scope, &quot;Uint32Array&quot;,</span>
                                 &quot;org.mozilla.javascript.typedarrays.NativeUint32Array&quot;,
                                 sealed, true);
<span class="fc" id="L249">            new LazilyLoadedCtor(scope, &quot;Float32Array&quot;,</span>
                                 &quot;org.mozilla.javascript.typedarrays.NativeFloat32Array&quot;,
                                 sealed, true);
<span class="fc" id="L252">            new LazilyLoadedCtor(scope, &quot;Float64Array&quot;,</span>
                                 &quot;org.mozilla.javascript.typedarrays.NativeFloat64Array&quot;,
                                 sealed, true);
<span class="fc" id="L255">            new LazilyLoadedCtor(scope, &quot;DataView&quot;,</span>
                                 &quot;org.mozilla.javascript.typedarrays.NativeDataView&quot;,
                                 sealed, true);
        }

<span class="pc bpc" id="L260" title="1 of 2 branches missed.">        if (cx.getLanguageVersion() &gt;= Context.VERSION_ES6) {</span>
<span class="nc" id="L261">            NativeSymbol.init(cx, scope, sealed);</span>
        }

<span class="fc bfc" id="L264" title="All 2 branches covered.">        if (scope instanceof TopLevel) {</span>
<span class="fc" id="L265">            ((TopLevel)scope).cacheBuiltins();</span>
        }

<span class="fc" id="L268">        return scope;</span>
    }

    public static ScriptableObject initStandardObjects(Context cx,
                                                       ScriptableObject scope,
                                                       boolean sealed)
    {
<span class="fc" id="L275">        ScriptableObject s = initSafeStandardObjects(cx, scope, sealed);</span>

<span class="fc" id="L277">        new LazilyLoadedCtor(s, &quot;Packages&quot;,</span>
                &quot;org.mozilla.javascript.NativeJavaTopPackage&quot;, sealed, true);
<span class="fc" id="L279">        new LazilyLoadedCtor(s, &quot;getClass&quot;,</span>
                &quot;org.mozilla.javascript.NativeJavaTopPackage&quot;, sealed, true);
<span class="fc" id="L281">        new LazilyLoadedCtor(s, &quot;JavaAdapter&quot;,</span>
                &quot;org.mozilla.javascript.JavaAdapter&quot;, sealed, true);
<span class="fc" id="L283">        new LazilyLoadedCtor(s, &quot;JavaImporter&quot;,</span>
                &quot;org.mozilla.javascript.ImporterTopLevel&quot;, sealed, true);

<span class="fc bfc" id="L286" title="All 2 branches covered.">        for (String packageName : getTopPackageNames()) {</span>
<span class="fc" id="L287">            new LazilyLoadedCtor(s, packageName,</span>
                    &quot;org.mozilla.javascript.NativeJavaTopPackage&quot;, sealed, true);
        }

<span class="fc" id="L291">        return s;</span>
    }

    static String[] getTopPackageNames() {
        // Include &quot;android&quot; top package if running on Android
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">        return &quot;Dalvik&quot;.equals(System.getProperty(&quot;java.vm.name&quot;)) ?</span>
            new String[] { &quot;java&quot;, &quot;javax&quot;, &quot;org&quot;, &quot;com&quot;, &quot;edu&quot;, &quot;net&quot;, &quot;android&quot; } :
            new String[] { &quot;java&quot;, &quot;javax&quot;, &quot;org&quot;, &quot;com&quot;, &quot;edu&quot;, &quot;net&quot; };
    }

    public static ScriptableObject getLibraryScopeOrNull(Scriptable scope)
    {
        ScriptableObject libScope;
<span class="fc" id="L304">        libScope = (ScriptableObject)ScriptableObject.</span>
<span class="fc" id="L305">                       getTopScopeValue(scope, LIBRARY_SCOPE_KEY);</span>
<span class="fc" id="L306">        return libScope;</span>
    }

    // It is public so NativeRegExp can access it.
    public static boolean isJSLineTerminator(int c)
    {
        // Optimization for faster check for eol character:
        // they do not have 0xDFD0 bits set
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if ((c &amp; 0xDFD0) != 0) {</span>
<span class="fc" id="L315">            return false;</span>
        }
<span class="pc bpc" id="L317" title="3 of 8 branches missed.">        return c == '\n' || c == '\r' || c == 0x2028 || c == 0x2029;</span>
    }

    public static boolean isJSWhitespaceOrLineTerminator(int c) {
<span class="pc bpc" id="L321" title="2 of 4 branches missed.">      return (isStrWhiteSpaceChar(c) || isJSLineTerminator(c));</span>
    }

    /**
     * Indicates if the character is a Str whitespace char according to ECMA spec:
     * StrWhiteSpaceChar :::
      &lt;TAB&gt;
      &lt;SP&gt;
      &lt;NBSP&gt;
      &lt;FF&gt;
      &lt;VT&gt;
      &lt;CR&gt;
      &lt;LF&gt;
      &lt;LS&gt;
      &lt;PS&gt;
      &lt;USP&gt;
      &lt;BOM&gt;
     */
    static boolean isStrWhiteSpaceChar(int c)
    {
<span class="fc bfc" id="L341" title="All 2 branches covered.">        switch (c) {</span>
            case ' ': // &lt;SP&gt;
            case '\n': // &lt;LF&gt;
            case '\r': // &lt;CR&gt;
            case '\t': // &lt;TAB&gt;
            case '\u00A0': // &lt;NBSP&gt;
            case '\u000C': // &lt;FF&gt;
            case '\u000B': // &lt;VT&gt;
            case '\u2028': // &lt;LS&gt;
            case '\u2029': // &lt;PS&gt;
            case '\uFEFF': // &lt;BOM&gt;
<span class="fc" id="L352">                return true;</span>
            default:
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">                return Character.getType(c) == Character.SPACE_SEPARATOR;</span>
        }
    }

    public static Boolean wrapBoolean(boolean b)
    {
<span class="fc bfc" id="L360" title="All 2 branches covered.">        return b ? Boolean.TRUE : Boolean.FALSE;</span>
    }

    public static Integer wrapInt(int i)
    {
<span class="fc" id="L365">        return Integer.valueOf(i);</span>
    }

    public static Number wrapNumber(double x)
    {
<span class="fc bfc" id="L370" title="All 2 branches covered.">        if (x != x) {</span>
<span class="fc" id="L371">            return ScriptRuntime.NaNobj;</span>
        }
<span class="fc" id="L373">        return new Double(x);</span>
    }

    /**
     * Convert the value to a boolean.
     *
     * See ECMA 9.2.
     */
    public static boolean toBoolean(Object val)
    {
        for (;;) {
<span class="fc bfc" id="L384" title="All 2 branches covered.">            if (val instanceof Boolean)</span>
<span class="fc" id="L385">                return ((Boolean) val).booleanValue();</span>
<span class="pc bpc" id="L386" title="1 of 4 branches missed.">            if (val == null || val == Undefined.instance)</span>
<span class="fc" id="L387">                return false;</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">            if (val instanceof CharSequence)</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">                return ((CharSequence) val).length() != 0;</span>
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">            if (val instanceof Number) {</span>
<span class="nc" id="L391">                double d = ((Number) val).doubleValue();</span>
<span class="nc bnc" id="L392" title="All 4 branches missed.">                return (d == d &amp;&amp; d != 0.0);</span>
            }
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">            if (val instanceof Scriptable) {</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">                if (val instanceof ScriptableObject &amp;&amp;</span>
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">                    ((ScriptableObject) val).avoidObjectDetection())</span>
                {
<span class="nc" id="L398">                    return false;</span>
                }
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">                if (Context.getContext().isVersionECMA1()) {</span>
                    // pure ECMA
<span class="fc" id="L402">                    return true;</span>
                }
                // ECMA extension
<span class="nc" id="L405">                val = ((Scriptable) val).getDefaultValue(BooleanClass);</span>
<span class="nc bnc" id="L406" title="All 4 branches missed.">                if ((val instanceof Scriptable) &amp;&amp; !isSymbol(val))</span>
<span class="nc" id="L407">                    throw errorWithClassName(&quot;msg.primitive.expected&quot;, val);</span>
                continue;
            }
<span class="nc" id="L410">            warnAboutNonJSObject(val);</span>
<span class="nc" id="L411">            return true;</span>
        }
    }

    /**
     * Convert the value to a number.
     *
     * See ECMA 9.3.
     */
    public static double toNumber(Object val)
    {
        for (;;) {
<span class="fc bfc" id="L423" title="All 2 branches covered.">            if (val instanceof Number)</span>
<span class="fc" id="L424">                return ((Number) val).doubleValue();</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">            if (val == null)</span>
<span class="fc" id="L426">                return +0.0;</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">            if (val == Undefined.instance)</span>
<span class="fc" id="L428">                return NaN;</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">            if (val instanceof String)</span>
<span class="fc" id="L430">                return toNumber((String) val);</span>
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">            if (val instanceof CharSequence)</span>
<span class="nc" id="L432">                return toNumber(val.toString());</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">            if (val instanceof Boolean)</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">                return ((Boolean) val).booleanValue() ? 1 : +0.0;</span>
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">            if (val instanceof Symbol)</span>
<span class="nc" id="L436">                throw typeError0(&quot;msg.not.a.number&quot;);</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">            if (val instanceof Scriptable) {</span>
<span class="fc" id="L438">                val = ((Scriptable) val).getDefaultValue(NumberClass);</span>
<span class="pc bpc" id="L439" title="3 of 4 branches missed.">                if ((val instanceof Scriptable) &amp;&amp; !isSymbol(val))</span>
<span class="nc" id="L440">                    throw errorWithClassName(&quot;msg.primitive.expected&quot;, val);</span>
                continue;
            }
<span class="fc" id="L443">            warnAboutNonJSObject(val);</span>
<span class="fc" id="L444">            return NaN;</span>
        }
    }

    public static double toNumber(Object[] args, int index) {
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">        return (index &lt; args.length) ? toNumber(args[index]) : NaN;</span>
    }

    // Can not use Double.NaN defined as 0.0d / 0.0 as under the Microsoft VM,
    // versions 2.01 and 3.0P1, that causes some uses (returns at least) of
    // Double.NaN to be converted to 1.0.
    // So we use ScriptRuntime.NaN instead of Double.NaN.
    public static final double
<span class="fc" id="L457">        NaN = Double.longBitsToDouble(0x7ff8000000000000L);</span>

    // A similar problem exists for negative zero.
    public static final double
<span class="fc" id="L461">        negativeZero = Double.longBitsToDouble(0x8000000000000000L);</span>

<span class="fc" id="L463">    public static final Double NaNobj = new Double(NaN);</span>

    static double stringPrefixToNumber(String s, int start, int radix) {
<span class="fc" id="L466">        return stringToNumber(s, start, s.length() - 1, radix, true);</span>
    }

    static double stringToNumber(String s, int start, int end, int radix) {
<span class="nc" id="L470">        return stringToNumber(s, start, end, radix, false);</span>
    }

    /*
     * Helper function for toNumber, parseInt, and TokenStream.getToken.
     */
    private static double stringToNumber(String source, int sourceStart, int sourceEnd, int radix, boolean isPrefix) {
<span class="fc" id="L477">        char digitMax = '9';</span>
<span class="fc" id="L478">        char lowerCaseBound = 'a';</span>
<span class="fc" id="L479">        char upperCaseBound = 'A';</span>
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">        if (radix &lt; 10) {</span>
<span class="nc" id="L481">            digitMax = (char) ('0' + radix - 1);</span>
        }
<span class="fc bfc" id="L483" title="All 2 branches covered.">        if (radix &gt; 10) {</span>
<span class="fc" id="L484">            lowerCaseBound = (char) ('a' + radix - 10);</span>
<span class="fc" id="L485">            upperCaseBound = (char) ('A' + radix - 10);</span>
        }
        int end;
<span class="fc" id="L488">        double sum = 0.0;</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">        for (end = sourceStart; end &lt;= sourceEnd; end++) {</span>
<span class="fc" id="L490">            char c = source.charAt(end);</span>
            int newDigit;
<span class="fc bfc" id="L492" title="All 4 branches covered.">            if ('0' &lt;= c &amp;&amp; c &lt;= digitMax)</span>
<span class="fc" id="L493">                newDigit = c - '0';</span>
<span class="fc bfc" id="L494" title="All 4 branches covered.">            else if ('a' &lt;= c &amp;&amp; c &lt; lowerCaseBound)</span>
<span class="fc" id="L495">                newDigit = c - 'a' + 10;</span>
<span class="fc bfc" id="L496" title="All 4 branches covered.">            else if ('A' &lt;= c &amp;&amp; c &lt; upperCaseBound)</span>
<span class="fc" id="L497">                newDigit = c - 'A' + 10;</span>
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">            else if (!isPrefix)</span>
<span class="nc" id="L499">                return NaN; // isn't a prefix but found unexpected char</span>
            else
                break; // unexpected char
<span class="fc" id="L502">            sum = sum*radix + newDigit;</span>
        }
<span class="fc bfc" id="L504" title="All 2 branches covered.">        if (sourceStart == end) { // stopped right at the beginning</span>
<span class="fc" id="L505">            return NaN;</span>
        }
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">        if (sum &gt;= 9007199254740992.0) {</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">            if (radix == 10) {</span>
                /* If we're accumulating a decimal number and the number
                 * is &gt;= 2^53, then the result from the repeated multiply-add
                 * above may be inaccurate.  Call Java to get the correct
                 * answer.
                 */
                try {
<span class="nc" id="L515">                    return Double.parseDouble(source.substring(sourceStart, end));</span>
<span class="nc" id="L516">                } catch (NumberFormatException nfe) {</span>
<span class="nc" id="L517">                    return NaN;</span>
                }
<span class="nc bnc" id="L519" title="All 10 branches missed.">            } else if (radix == 2 || radix == 4 || radix == 8 ||</span>
                       radix == 16 || radix == 32)
            {
                /* The number may also be inaccurate for one of these bases.
                 * This happens if the addition in value*radix + digit causes
                 * a round-down to an even least significant mantissa bit
                 * when the first dropped bit is a one.  If any of the
                 * following digits in the number (which haven't been added
                 * in yet) are nonzero then the correct action would have
                 * been to round up instead of down.  An example of this
                 * occurs when reading the number 0x1000000000000081, which
                 * rounds to 0x1000000000000000 instead of 0x1000000000000100.
                 */
<span class="nc" id="L532">                int bitShiftInChar = 1;</span>
<span class="nc" id="L533">                int digit = 0;</span>

<span class="nc" id="L535">                final int SKIP_LEADING_ZEROS = 0;</span>
<span class="nc" id="L536">                final int FIRST_EXACT_53_BITS = 1;</span>
<span class="nc" id="L537">                final int AFTER_BIT_53         = 2;</span>
<span class="nc" id="L538">                final int ZEROS_AFTER_54 = 3;</span>
<span class="nc" id="L539">                final int MIXED_AFTER_54 = 4;</span>

<span class="nc" id="L541">                int state = SKIP_LEADING_ZEROS;</span>
<span class="nc" id="L542">                int exactBitsLimit = 53;</span>
<span class="nc" id="L543">                double factor = 0.0;</span>
<span class="nc" id="L544">                boolean bit53 = false;</span>
                // bit54 is the 54th bit (the first dropped from the mantissa)
<span class="nc" id="L546">                boolean bit54 = false;</span>
<span class="nc" id="L547">                int pos = sourceStart;</span>

                for (;;) {
<span class="nc bnc" id="L550" title="All 2 branches missed.">                    if (bitShiftInChar == 1) {</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">                        if (pos == end)</span>
<span class="nc" id="L552">                            break;</span>
<span class="nc" id="L553">                        digit = source.charAt(pos++);</span>
<span class="nc bnc" id="L554" title="All 4 branches missed.">                        if ('0' &lt;= digit &amp;&amp; digit &lt;= '9')</span>
<span class="nc" id="L555">                            digit -= '0';</span>
<span class="nc bnc" id="L556" title="All 4 branches missed.">                        else if ('a' &lt;= digit &amp;&amp; digit &lt;= 'z')</span>
<span class="nc" id="L557">                            digit -= 'a' - 10;</span>
                        else
<span class="nc" id="L559">                            digit -= 'A' - 10;</span>
<span class="nc" id="L560">                        bitShiftInChar = radix;</span>
                    }
<span class="nc" id="L562">                    bitShiftInChar &gt;&gt;= 1;</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">                    boolean bit = (digit &amp; bitShiftInChar) != 0;</span>

<span class="nc bnc" id="L565" title="All 6 branches missed.">                    switch (state) {</span>
                      case SKIP_LEADING_ZEROS:
<span class="nc bnc" id="L567" title="All 2 branches missed.">                          if (bit) {</span>
<span class="nc" id="L568">                            --exactBitsLimit;</span>
<span class="nc" id="L569">                            sum = 1.0;</span>
<span class="nc" id="L570">                            state = FIRST_EXACT_53_BITS;</span>
                        }
                        break;
                      case FIRST_EXACT_53_BITS:
<span class="nc" id="L574">                           sum *= 2.0;</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">                        if (bit)</span>
<span class="nc" id="L576">                            sum += 1.0;</span>
<span class="nc" id="L577">                        --exactBitsLimit;</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">                        if (exactBitsLimit == 0) {</span>
<span class="nc" id="L579">                            bit53 = bit;</span>
<span class="nc" id="L580">                            state = AFTER_BIT_53;</span>
                        }
                        break;
                      case AFTER_BIT_53:
<span class="nc" id="L584">                        bit54 = bit;</span>
<span class="nc" id="L585">                        factor = 2.0;</span>
<span class="nc" id="L586">                        state = ZEROS_AFTER_54;</span>
<span class="nc" id="L587">                        break;</span>
                      case ZEROS_AFTER_54:
<span class="nc bnc" id="L589" title="All 2 branches missed.">                        if (bit) {</span>
<span class="nc" id="L590">                            state = MIXED_AFTER_54;</span>
                        }
                        // fallthrough
                      case MIXED_AFTER_54:
<span class="nc" id="L594">                        factor *= 2;</span>
                        break;
                    }
<span class="nc" id="L597">                }</span>
<span class="nc bnc" id="L598" title="All 5 branches missed.">                switch (state) {</span>
                  case SKIP_LEADING_ZEROS:
<span class="nc" id="L600">                    sum = 0.0;</span>
<span class="nc" id="L601">                    break;</span>
                  case FIRST_EXACT_53_BITS:
                  case AFTER_BIT_53:
                    // do nothing
<span class="nc" id="L605">                    break;</span>
                  case ZEROS_AFTER_54:
                    // x1.1 -&gt; x1 + 1 (round up)
                    // x0.1 -&gt; x0 (round down)
<span class="nc bnc" id="L609" title="All 2 branches missed.">                    if (bit54 &amp; bit53)</span>
<span class="nc" id="L610">                        sum += 1.0;</span>
<span class="nc" id="L611">                    sum *= factor;</span>
<span class="nc" id="L612">                    break;</span>
                  case MIXED_AFTER_54:
                    // x.100...1.. -&gt; x + 1 (round up)
                    // x.0anything -&gt; x (round down)
<span class="nc bnc" id="L616" title="All 2 branches missed.">                    if (bit54)</span>
<span class="nc" id="L617">                        sum += 1.0;</span>
<span class="nc" id="L618">                    sum *= factor;</span>
                    break;
                }
            }
            /* We don't worry about inaccurate numbers for any other base. */
        }
<span class="fc" id="L624">        return sum;</span>
    }

    /**
     * ToNumber applied to the String type
     *
     * See the #sec-tonumber-applied-to-the-string-type section of ECMA
     */
    public static double toNumber(String s) {
<span class="fc" id="L633">        final int len = s.length();</span>

        // Skip whitespace at the start
<span class="fc" id="L636">        int start = 0;</span>
        char startChar;
        for (;;) {
<span class="fc bfc" id="L639" title="All 2 branches covered.">            if (start == len) {</span>
                // empty or contains only whitespace
<span class="fc" id="L641">                return +0.0;</span>
            }
<span class="fc" id="L643">            startChar = s.charAt(start);</span>
<span class="pc bpc" id="L644" title="1 of 2 branches missed.">            if (!ScriptRuntime.isStrWhiteSpaceChar(startChar)) {</span>
                // found first non-whitespace character
<span class="fc" id="L646">                break;</span>
            }
<span class="nc" id="L648">            start++;</span>
        }

        // Skip whitespace at the end
<span class="fc" id="L652">        int end = len - 1;</span>
        char endChar;
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">        while (ScriptRuntime.isStrWhiteSpaceChar(endChar = s.charAt(end))) {</span>
<span class="nc" id="L655">            end--;</span>
        }

        // Do not break scripts relying on old non-compliant conversion
        // (see bug #368)
        // 1. makes ToNumber parse only a valid prefix in hex literals (similar to 'parseInt()')
        //    ToNumber('0x10 something') =&gt; 16
        // 2. allows plus and minus signs for hexadecimal numbers
        //    ToNumber('-0x10') =&gt; -16
        // 3. disables support for binary ('0b10') and octal ('0o13') literals
        //    ToNumber('0b1') =&gt; NaN
        //    ToNumber('0o5') =&gt; NaN
<span class="fc" id="L667">        final Context cx = Context.getCurrentContext();</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">        final boolean oldParsingMode =</span>
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">                cx == null || cx.getLanguageVersion() &lt; Context.VERSION_ES6;</span>

        // Handle non-base10 numbers
<span class="fc bfc" id="L672" title="All 2 branches covered.">        if (startChar == '0') {</span>
<span class="pc bpc" id="L673" title="1 of 2 branches missed.">            if (start + 2 &lt;= end) {</span>
<span class="fc" id="L674">                final char radixC = s.charAt(start + 1);</span>
<span class="fc" id="L675">                int radix = -1;</span>
<span class="pc bpc" id="L676" title="1 of 4 branches missed.">                if (radixC == 'x' || radixC == 'X') {</span>
<span class="fc" id="L677">                    radix = 16;</span>
<span class="pc bpc" id="L678" title="5 of 6 branches missed.">                } else if (!oldParsingMode &amp;&amp; (radixC == 'o' || radixC == 'O')) {</span>
<span class="nc" id="L679">                    radix = 8;</span>
<span class="pc bpc" id="L680" title="5 of 6 branches missed.">                } else if (!oldParsingMode &amp;&amp; (radixC == 'b' || radixC == 'B')) {</span>
<span class="nc" id="L681">                    radix = 2;</span>
                }
<span class="fc bfc" id="L683" title="All 2 branches covered.">                if (radix != -1) {</span>
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">                    if (oldParsingMode) {</span>
<span class="fc" id="L685">                        return stringPrefixToNumber(s, start + 2, radix);</span>
                    }
<span class="nc" id="L687">                    return stringToNumber(s, start + 2, end, radix);</span>
                }
<span class="fc" id="L689">            }</span>
<span class="pc bpc" id="L690" title="3 of 6 branches missed.">        } else if (oldParsingMode &amp;&amp; (startChar == '+' || startChar == '-')) {</span>
            // If in old parsing mode, check for a signed hexadecimal number
<span class="nc bnc" id="L692" title="All 4 branches missed.">            if (start + 3 &lt;= end &amp;&amp; s.charAt(start + 1) == '0') {</span>
<span class="nc" id="L693">                final char radixC = s.charAt(start + 2);</span>
<span class="nc bnc" id="L694" title="All 4 branches missed.">                if (radixC == 'x' || radixC == 'X') {</span>
<span class="nc" id="L695">                    double val = stringPrefixToNumber(s, start + 3, 16);</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">                    return startChar == '-' ? -val : val;</span>
                }
            }
        }

<span class="pc bpc" id="L701" title="1 of 2 branches missed.">        if (endChar == 'y') {</span>
            // check for &quot;Infinity&quot;
<span class="nc bnc" id="L703" title="All 4 branches missed.">            if (startChar == '+' || startChar == '-') {</span>
<span class="nc" id="L704">                start++;</span>
            }
<span class="nc bnc" id="L706" title="All 4 branches missed.">            if (start + 7 == end &amp;&amp; s.regionMatches(start, &quot;Infinity&quot;, 0, 8)) {</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">                return startChar == '-'</span>
                        ? Double.NEGATIVE_INFINITY
                        : Double.POSITIVE_INFINITY;
            }
<span class="nc" id="L711">            return NaN;</span>
        }
        // A base10, non-infinity number:
        // just try a normal floating point conversion
<span class="fc" id="L715">        String sub = s.substring(start, end+1);</span>
        // Quick test to check string contains only valid characters because
        // Double.parseDouble() can be slow and accept input we want to reject
<span class="fc bfc" id="L718" title="All 2 branches covered.">        for (int i = sub.length() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L719">            char c = sub.charAt(i);</span>
<span class="pc bpc" id="L720" title="3 of 14 branches missed.">            if (('0' &lt;= c &amp;&amp; c &lt;= '9') || c == '.' ||</span>
                    c == 'e' || c == 'E'  ||
                    c == '+' || c == '-')
<span class="nc" id="L723">                continue;</span>
<span class="fc" id="L724">            return NaN;</span>
        }
        try {
<span class="fc" id="L727">            return Double.parseDouble(sub);</span>
<span class="nc" id="L728">        } catch (NumberFormatException ex) {</span>
<span class="nc" id="L729">            return NaN;</span>
        }
    }

    /**
     * Helper function for builtin objects that use the varargs form.
     * ECMA function formal arguments are undefined if not supplied;
     * this function pads the argument array out to the expected
     * length, if necessary.
     */
    public static Object[] padArguments(Object[] args, int count) {
<span class="nc bnc" id="L740" title="All 2 branches missed.">        if (count &lt; args.length)</span>
<span class="nc" id="L741">            return args;</span>

        int i;
<span class="nc" id="L744">        Object[] result = new Object[count];</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">        for (i = 0; i &lt; args.length; i++) {</span>
<span class="nc" id="L746">            result[i] = args[i];</span>
        }

<span class="nc bnc" id="L749" title="All 2 branches missed.">        for (; i &lt; count; i++) {</span>
<span class="nc" id="L750">            result[i] = Undefined.instance;</span>
        }

<span class="nc" id="L753">        return result;</span>
    }

    public static String escapeString(String s)
    {
<span class="fc" id="L758">        return escapeString(s, '&quot;');</span>
    }

    /**
     * For escaping strings printed by object and array literals; not quite
     * the same as 'escape.'
     */
    public static String escapeString(String s, char escapeQuote)
    {
<span class="pc bpc" id="L767" title="1 of 4 branches missed.">        if (!(escapeQuote == '&quot;' || escapeQuote == '\'')) Kit.codeBug();</span>
<span class="fc" id="L768">        StringBuilder sb = null;</span>

<span class="fc bfc" id="L770" title="All 2 branches covered.">        for(int i = 0, L = s.length(); i != L; ++i) {</span>
<span class="fc" id="L771">            int c = s.charAt(i);</span>

<span class="pc bpc" id="L773" title="3 of 8 branches missed.">            if (' ' &lt;= c &amp;&amp; c &lt;= '~' &amp;&amp; c != escapeQuote &amp;&amp; c != '\\') {</span>
                // an ordinary print character (like C isprint()) and not &quot;
                // or \ .
<span class="pc bpc" id="L776" title="1 of 2 branches missed.">                if (sb != null) {</span>
<span class="nc" id="L777">                    sb.append((char)c);</span>
                }
                continue;
            }
<span class="fc bfc" id="L781" title="All 2 branches covered.">            if (sb == null) {</span>
<span class="fc" id="L782">                sb = new StringBuilder(L + 3);</span>
<span class="fc" id="L783">                sb.append(s);</span>
<span class="fc" id="L784">                sb.setLength(i);</span>
            }

<span class="fc" id="L787">            int escape = -1;</span>
<span class="pc bpc" id="L788" title="8 of 9 branches missed.">            switch (c) {</span>
<span class="nc" id="L789">                case '\b':  escape = 'b';  break;</span>
<span class="nc" id="L790">                case '\f':  escape = 'f';  break;</span>
<span class="nc" id="L791">                case '\n':  escape = 'n';  break;</span>
<span class="nc" id="L792">                case '\r':  escape = 'r';  break;</span>
<span class="nc" id="L793">                case '\t':  escape = 't';  break;</span>
<span class="nc" id="L794">                case 0xb:   escape = 'v';  break; // Java lacks \v.</span>
<span class="nc" id="L795">                case ' ':   escape = ' ';  break;</span>
<span class="nc" id="L796">                case '\\':  escape = '\\'; break;</span>
            }
<span class="pc bpc" id="L798" title="1 of 2 branches missed.">            if (escape &gt;= 0) {</span>
                // an \escaped sort of character
<span class="nc" id="L800">                sb.append('\\');</span>
<span class="nc" id="L801">                sb.append((char)escape);</span>
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">            } else if (c == escapeQuote) {</span>
<span class="nc" id="L803">                sb.append('\\');</span>
<span class="nc" id="L804">                sb.append(escapeQuote);</span>
            } else {
                int hexSize;
<span class="pc bpc" id="L807" title="1 of 2 branches missed.">                if (c &lt; 256) {</span>
                    // 2-digit hex
<span class="nc" id="L809">                    sb.append(&quot;\\x&quot;);</span>
<span class="nc" id="L810">                    hexSize = 2;</span>
                } else {
                    // Unicode.
<span class="fc" id="L813">                    sb.append(&quot;\\u&quot;);</span>
<span class="fc" id="L814">                    hexSize = 4;</span>
                }
                // append hexadecimal form of c left-padded with 0
<span class="fc bfc" id="L817" title="All 2 branches covered.">                for (int shift = (hexSize - 1) * 4; shift &gt;= 0; shift -= 4) {</span>
<span class="fc" id="L818">                    int digit = 0xf &amp; (c &gt;&gt; shift);</span>
<span class="fc bfc" id="L819" title="All 2 branches covered.">                    int hc = (digit &lt; 10) ? '0' + digit : 'a' - 10 + digit;</span>
<span class="fc" id="L820">                    sb.append((char)hc);</span>
                }
            }
        }
<span class="fc bfc" id="L824" title="All 2 branches covered.">        return (sb == null) ? s : sb.toString();</span>
    }

    static boolean isValidIdentifierName(String s, Context cx, boolean isStrict)
    {
<span class="nc" id="L829">        int L = s.length();</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">        if (L == 0)</span>
<span class="nc" id="L831">            return false;</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">        if (!Character.isJavaIdentifierStart(s.charAt(0)))</span>
<span class="nc" id="L833">            return false;</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">        for (int i = 1; i != L; ++i) {</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">            if (!Character.isJavaIdentifierPart(s.charAt(i)))</span>
<span class="nc" id="L836">                return false;</span>
        }
<span class="nc bnc" id="L838" title="All 2 branches missed.">        return !TokenStream.isKeyword(s, cx.getLanguageVersion(), isStrict);</span>
    }

    public static CharSequence toCharSequence(Object val) {
<span class="fc bfc" id="L842" title="All 2 branches covered.">        if (val instanceof NativeString) {</span>
<span class="fc" id="L843">            return ((NativeString)val).toCharSequence();</span>
        }
<span class="fc bfc" id="L845" title="All 2 branches covered.">        return val instanceof CharSequence ? (CharSequence) val : toString(val);</span>
    }

    /**
     * Convert the value to a string.
     *
     * See ECMA 9.8.
     */
    public static String toString(Object val) {
        for (;;) {
<span class="fc bfc" id="L855" title="All 2 branches covered.">            if (val == null) {</span>
<span class="fc" id="L856">                return &quot;null&quot;;</span>
            }
<span class="pc bpc" id="L858" title="1 of 4 branches missed.">            if (val == Undefined.instance || val == Undefined.SCRIPTABLE_UNDEFINED) {</span>
<span class="fc" id="L859">                return &quot;undefined&quot;;</span>
            }
<span class="fc bfc" id="L861" title="All 2 branches covered.">            if (val instanceof String) {</span>
<span class="fc" id="L862">                return (String)val;</span>
            }
<span class="pc bpc" id="L864" title="1 of 2 branches missed.">            if (val instanceof CharSequence) {</span>
<span class="nc" id="L865">                return val.toString();</span>
            }
<span class="fc bfc" id="L867" title="All 2 branches covered.">            if (val instanceof Number) {</span>
                // XXX should we just teach NativeNumber.stringValue()
                // about Numbers?
<span class="fc" id="L870">                return numberToString(((Number)val).doubleValue(), 10);</span>
            }
<span class="pc bpc" id="L872" title="1 of 2 branches missed.">            if (val instanceof Symbol) {</span>
<span class="nc" id="L873">                throw typeError0(&quot;msg.not.a.string&quot;);</span>
            }
<span class="fc bfc" id="L875" title="All 2 branches covered.">            if (val instanceof Scriptable) {</span>
<span class="fc" id="L876">                val = ((Scriptable) val).getDefaultValue(StringClass);</span>
<span class="pc bpc" id="L877" title="3 of 4 branches missed.">                if ((val instanceof Scriptable) &amp;&amp; !isSymbol(val)) {</span>
<span class="nc" id="L878">                    throw errorWithClassName(&quot;msg.primitive.expected&quot;, val);</span>
                }
                continue;
            }
<span class="fc" id="L882">            return val.toString();</span>
        }
    }

    static String defaultObjectToString(Scriptable obj)
    {
<span class="pc bpc" id="L888" title="1 of 2 branches missed.">        if (obj == null)</span>
<span class="nc" id="L889">            return &quot;[object Null]&quot;;</span>
<span class="pc bpc" id="L890" title="1 of 2 branches missed.">        if (Undefined.isUndefined(obj))</span>
<span class="nc" id="L891">            return &quot;[object Undefined]&quot;;</span>
<span class="fc" id="L892">        return &quot;[object &quot; + obj.getClassName() + ']';</span>
    }

    public static String toString(Object[] args, int index)
    {
<span class="pc bpc" id="L897" title="1 of 2 branches missed.">        return (index &lt; args.length) ? toString(args[index]) : &quot;undefined&quot;;</span>
    }

    /**
     * Optimized version of toString(Object) for numbers.
     */
    public static String toString(double val) {
<span class="fc" id="L904">        return numberToString(val, 10);</span>
    }

    public static String numberToString(double d, int base) {
<span class="pc bpc" id="L908" title="2 of 4 branches missed.">        if ((base &lt; 2) || (base &gt; 36)) {</span>
<span class="nc" id="L909">            throw Context.reportRuntimeError1(</span>
<span class="nc" id="L910">                &quot;msg.bad.radix&quot;, Integer.toString(base));</span>
        }

<span class="fc bfc" id="L913" title="All 2 branches covered.">        if (d != d)</span>
<span class="fc" id="L914">            return &quot;NaN&quot;;</span>
<span class="fc bfc" id="L915" title="All 2 branches covered.">        if (d == Double.POSITIVE_INFINITY)</span>
<span class="fc" id="L916">            return &quot;Infinity&quot;;</span>
<span class="fc bfc" id="L917" title="All 2 branches covered.">        if (d == Double.NEGATIVE_INFINITY)</span>
<span class="fc" id="L918">            return &quot;-Infinity&quot;;</span>
<span class="fc bfc" id="L919" title="All 2 branches covered.">        if (d == 0.0)</span>
<span class="fc" id="L920">            return &quot;0&quot;;</span>

<span class="pc bpc" id="L922" title="1 of 2 branches missed.">        if (base != 10) {</span>
<span class="nc" id="L923">            return DToA.JS_dtobasestr(base, d);</span>
        } else {
            // V8 FastDtoa can't convert all numbers, so try it first but
            // fall back to old DToA in case it fails
<span class="fc" id="L927">            String result = FastDtoa.numberToString(d);</span>
<span class="fc bfc" id="L928" title="All 2 branches covered.">            if (result != null) {</span>
<span class="fc" id="L929">                return result;</span>
            }
<span class="fc" id="L931">            StringBuilder buffer = new StringBuilder();</span>
<span class="fc" id="L932">            DToA.JS_dtostr(buffer, DToA.DTOSTR_STANDARD, 0, d);</span>
<span class="fc" id="L933">            return buffer.toString();</span>
        }

    }

    static String uneval(Context cx, Scriptable scope, Object value)
    {
<span class="nc bnc" id="L940" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L941">            return &quot;null&quot;;</span>
        }
<span class="nc bnc" id="L943" title="All 2 branches missed.">        if (value == Undefined.instance) {</span>
<span class="nc" id="L944">            return &quot;undefined&quot;;</span>
        }
<span class="nc bnc" id="L946" title="All 2 branches missed.">        if (value instanceof CharSequence) {</span>
<span class="nc" id="L947">            String escaped = escapeString(value.toString());</span>
<span class="nc" id="L948">            StringBuilder sb = new StringBuilder(escaped.length() + 2);</span>
<span class="nc" id="L949">            sb.append('\&quot;');</span>
<span class="nc" id="L950">            sb.append(escaped);</span>
<span class="nc" id="L951">            sb.append('\&quot;');</span>
<span class="nc" id="L952">            return sb.toString();</span>
        }
<span class="nc bnc" id="L954" title="All 2 branches missed.">        if (value instanceof Number) {</span>
<span class="nc" id="L955">            double d = ((Number)value).doubleValue();</span>
<span class="nc bnc" id="L956" title="All 4 branches missed.">            if (d == 0 &amp;&amp; 1 / d &lt; 0) {</span>
<span class="nc" id="L957">                return &quot;-0&quot;;</span>
            }
<span class="nc" id="L959">            return toString(d);</span>
        }
<span class="nc bnc" id="L961" title="All 2 branches missed.">        if (value instanceof Boolean) {</span>
<span class="nc" id="L962">            return toString(value);</span>
        }
<span class="nc bnc" id="L964" title="All 2 branches missed.">        if (value instanceof Scriptable) {</span>
<span class="nc" id="L965">            Scriptable obj = (Scriptable)value;</span>
            // Wrapped Java objects won't have &quot;toSource&quot; and will report
            // errors for get()s of nonexistent name, so use has() first
<span class="nc bnc" id="L968" title="All 2 branches missed.">            if (ScriptableObject.hasProperty(obj, &quot;toSource&quot;)) {</span>
<span class="nc" id="L969">                Object v = ScriptableObject.getProperty(obj, &quot;toSource&quot;);</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">                if (v instanceof Function) {</span>
<span class="nc" id="L971">                    Function f = (Function)v;</span>
<span class="nc" id="L972">                    return toString(f.call(cx, scope, obj, emptyArgs));</span>
                }
            }
<span class="nc" id="L975">            return toString(value);</span>
        }
<span class="nc" id="L977">        warnAboutNonJSObject(value);</span>
<span class="nc" id="L978">        return value.toString();</span>
    }

    static String defaultObjectToSource(Context cx, Scriptable scope,
                                        Scriptable thisObj, Object[] args)
    {
        boolean toplevel, iterating;
<span class="nc bnc" id="L985" title="All 2 branches missed.">        if (cx.iterating == null) {</span>
<span class="nc" id="L986">            toplevel = true;</span>
<span class="nc" id="L987">            iterating = false;</span>
<span class="nc" id="L988">            cx.iterating = new ObjToIntMap(31);</span>
        } else {
<span class="nc" id="L990">            toplevel = false;</span>
<span class="nc" id="L991">            iterating = cx.iterating.has(thisObj);</span>
        }

<span class="nc" id="L994">        StringBuilder result = new StringBuilder(128);</span>
<span class="nc bnc" id="L995" title="All 2 branches missed.">        if (toplevel) {</span>
<span class="nc" id="L996">            result.append(&quot;(&quot;);</span>
        }
<span class="nc" id="L998">        result.append('{');</span>

        // Make sure cx.iterating is set to null when done
        // so we don't leak memory
        try {
<span class="nc bnc" id="L1003" title="All 2 branches missed.">            if (!iterating) {</span>
<span class="nc" id="L1004">                cx.iterating.intern(thisObj); // stop recursion.</span>
<span class="nc" id="L1005">                Object[] ids = thisObj.getIds();</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">                for (int i=0; i &lt; ids.length; i++) {</span>
<span class="nc" id="L1007">                    Object id = ids[i];</span>
                    Object value;
<span class="nc bnc" id="L1009" title="All 2 branches missed.">                    if (id instanceof Integer) {</span>
<span class="nc" id="L1010">                        int intId = ((Integer)id).intValue();</span>
<span class="nc" id="L1011">                        value = thisObj.get(intId, thisObj);</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">                        if (value == Scriptable.NOT_FOUND)</span>
<span class="nc" id="L1013">                            continue;   // a property has been removed</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">                        if (i &gt; 0)</span>
<span class="nc" id="L1015">                            result.append(&quot;, &quot;);</span>
<span class="nc" id="L1016">                        result.append(intId);</span>
<span class="nc" id="L1017">                    } else {</span>
<span class="nc" id="L1018">                        String strId = (String)id;</span>
<span class="nc" id="L1019">                        value = thisObj.get(strId, thisObj);</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">                        if (value == Scriptable.NOT_FOUND)</span>
<span class="nc" id="L1021">                            continue;   // a property has been removed</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">                        if (i &gt; 0)</span>
<span class="nc" id="L1023">                            result.append(&quot;, &quot;);</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">                        if (ScriptRuntime.isValidIdentifierName(strId, cx, cx.isStrictMode())) {</span>
<span class="nc" id="L1025">                            result.append(strId);</span>
                        } else {
<span class="nc" id="L1027">                            result.append('\'');</span>
<span class="nc" id="L1028">                            result.append(</span>
<span class="nc" id="L1029">                                ScriptRuntime.escapeString(strId, '\''));</span>
<span class="nc" id="L1030">                            result.append('\'');</span>
                        }
                    }
<span class="nc" id="L1033">                    result.append(':');</span>
<span class="nc" id="L1034">                    result.append(ScriptRuntime.uneval(cx, scope, value));</span>
                }
            }
        } finally {
<span class="nc bnc" id="L1038" title="All 4 branches missed.">            if (toplevel) {</span>
<span class="nc" id="L1039">                cx.iterating = null;</span>
            }
<span class="nc" id="L1041">        }</span>

<span class="nc" id="L1043">        result.append('}');</span>
<span class="nc bnc" id="L1044" title="All 2 branches missed.">        if (toplevel) {</span>
<span class="nc" id="L1045">            result.append(')');</span>
        }
<span class="nc" id="L1047">        return result.toString();</span>
    }

    public static Scriptable toObject(Scriptable scope, Object val)
    {
<span class="nc bnc" id="L1052" title="All 2 branches missed.">        if (val instanceof Scriptable) {</span>
<span class="nc" id="L1053">            return (Scriptable)val;</span>
        }
<span class="nc" id="L1055">        return toObject(Context.getContext(), scope, val);</span>
    }

    /**
     * &lt;strong&gt;Warning&lt;/strong&gt;: This doesn't allow to resolve primitive
     * prototype properly when many top scopes are involved
     *
     * @deprecated Use {@link #toObjectOrNull(Context, Object, Scriptable)} instead
     */
    @Deprecated
    public static Scriptable toObjectOrNull(Context cx, Object obj)
    {
<span class="nc bnc" id="L1067" title="All 2 branches missed.">        if (obj instanceof Scriptable) {</span>
<span class="nc" id="L1068">            return (Scriptable)obj;</span>
<span class="nc bnc" id="L1069" title="All 4 branches missed.">        } else if (obj != null &amp;&amp; obj != Undefined.instance) {</span>
<span class="nc" id="L1070">            return toObject(cx, getTopCallScope(cx), obj);</span>
        }
<span class="nc" id="L1072">        return null;</span>
    }

    /**
     * @param scope the scope that should be used to resolve primitive prototype
     */
    public static Scriptable toObjectOrNull(Context cx, Object obj,
                                            Scriptable scope)
    {
<span class="fc bfc" id="L1081" title="All 2 branches covered.">        if (obj instanceof Scriptable) {</span>
<span class="fc" id="L1082">            return (Scriptable)obj;</span>
<span class="fc bfc" id="L1083" title="All 4 branches covered.">        } else if (obj != null &amp;&amp; obj != Undefined.instance) {</span>
<span class="fc" id="L1084">            return toObject(cx, scope, obj);</span>
        }
<span class="fc" id="L1086">        return null;</span>
    }

    /**
     * @deprecated Use {@link #toObject(Scriptable, Object)} instead.
     */
    @Deprecated
    public static Scriptable toObject(Scriptable scope, Object val,
                                      Class&lt;?&gt; staticClass)
    {
<span class="nc bnc" id="L1096" title="All 2 branches missed.">        if (val instanceof Scriptable) {</span>
<span class="nc" id="L1097">            return (Scriptable)val;</span>
        }
<span class="nc" id="L1099">        return toObject(Context.getContext(), scope, val);</span>
    }

    /**
     * Convert the value to an object.
     *
     * See ECMA 9.9.
     */
    public static Scriptable toObject(Context cx, Scriptable scope, Object val)
    {
<span class="pc bpc" id="L1109" title="1 of 2 branches missed.">        if (isSymbol(val)) {</span>
<span class="nc" id="L1110">            NativeSymbol result = new NativeSymbol((NativeSymbol)val);</span>
<span class="nc" id="L1111">            setBuiltinProtoAndParent(result, scope, TopLevel.Builtins.Symbol);</span>
<span class="nc" id="L1112">            return result;</span>
        }
<span class="fc bfc" id="L1114" title="All 2 branches covered.">        if (val instanceof Scriptable) {</span>
<span class="fc" id="L1115">            return (Scriptable) val;</span>
        }
<span class="fc bfc" id="L1117" title="All 2 branches covered.">        if (val instanceof CharSequence) {</span>
            // FIXME we want to avoid toString() here, especially for concat()
<span class="fc" id="L1119">            NativeString result = new NativeString((CharSequence)val);</span>
<span class="fc" id="L1120">            setBuiltinProtoAndParent(result, scope, TopLevel.Builtins.String);</span>
<span class="fc" id="L1121">            return result;</span>
        }
<span class="fc bfc" id="L1123" title="All 2 branches covered.">        if (val instanceof Number) {</span>
<span class="fc" id="L1124">            NativeNumber result = new NativeNumber(((Number)val).doubleValue());</span>
<span class="fc" id="L1125">            setBuiltinProtoAndParent(result, scope, TopLevel.Builtins.Number);</span>
<span class="fc" id="L1126">            return result;</span>
        }
<span class="fc bfc" id="L1128" title="All 2 branches covered.">        if (val instanceof Boolean) {</span>
<span class="fc" id="L1129">            NativeBoolean result = new NativeBoolean(((Boolean)val).booleanValue());</span>
<span class="fc" id="L1130">            setBuiltinProtoAndParent(result, scope, TopLevel.Builtins.Boolean);</span>
<span class="fc" id="L1131">            return result;</span>
        }
<span class="pc bpc" id="L1133" title="1 of 2 branches missed.">        if (val == null) {</span>
<span class="fc" id="L1134">            throw typeError0(&quot;msg.null.to.object&quot;);</span>
        }
<span class="nc bnc" id="L1136" title="All 2 branches missed.">        if (val == Undefined.instance) {</span>
<span class="nc" id="L1137">            throw typeError0(&quot;msg.undef.to.object&quot;);</span>
        }

        // Extension: Wrap as a LiveConnect object.
<span class="nc" id="L1141">        Object wrapped = cx.getWrapFactory().wrap(cx, scope, val, null);</span>
<span class="nc bnc" id="L1142" title="All 2 branches missed.">        if (wrapped instanceof Scriptable)</span>
<span class="nc" id="L1143">            return (Scriptable) wrapped;</span>
<span class="nc" id="L1144">        throw errorWithClassName(&quot;msg.invalid.type&quot;, val);</span>
    }

    /**
     * @deprecated Use {@link #toObject(Context, Scriptable, Object)} instead.
     */
    @Deprecated
    public static Scriptable toObject(Context cx, Scriptable scope, Object val,
                                      Class&lt;?&gt; staticClass)
    {
<span class="nc" id="L1154">        return toObject(cx, scope, val);</span>
    }

    /**
     * @deprecated The method is only present for compatibility.
     */
    @Deprecated
    public static Object call(Context cx, Object fun, Object thisArg,
                              Object[] args, Scriptable scope)
    {
<span class="nc bnc" id="L1164" title="All 2 branches missed.">        if (!(fun instanceof Function)) {</span>
<span class="nc" id="L1165">            throw notFunctionError(toString(fun));</span>
        }
<span class="nc" id="L1167">        Function function = (Function)fun;</span>
<span class="nc" id="L1168">        Scriptable thisObj = toObjectOrNull(cx, thisArg, scope);</span>
<span class="nc bnc" id="L1169" title="All 2 branches missed.">        if (thisObj == null) {</span>
<span class="nc" id="L1170">            throw undefCallError(thisObj, &quot;function&quot;);</span>
        }
<span class="nc" id="L1172">        return function.call(cx, scope, thisObj, args);</span>
    }

    public static Scriptable newObject(Context cx, Scriptable scope,
                                       String constructorName, Object[] args)
    {
<span class="fc" id="L1178">        scope = ScriptableObject.getTopLevelScope(scope);</span>
<span class="fc" id="L1179">        Function ctor = getExistingCtor(cx, scope, constructorName);</span>
<span class="pc bpc" id="L1180" title="1 of 2 branches missed.">        if (args == null) { args = ScriptRuntime.emptyArgs; }</span>
<span class="fc" id="L1181">        return ctor.construct(cx, scope, args);</span>
    }

    public static Scriptable newBuiltinObject(Context cx, Scriptable scope,
                                              TopLevel.Builtins type,
                                              Object[] args)
    {
<span class="fc" id="L1188">        scope = ScriptableObject.getTopLevelScope(scope);</span>
<span class="fc" id="L1189">        Function ctor = TopLevel.getBuiltinCtor(cx, scope, type);</span>
<span class="pc bpc" id="L1190" title="1 of 2 branches missed.">        if (args == null) { args = ScriptRuntime.emptyArgs; }</span>
<span class="fc" id="L1191">        return ctor.construct(cx, scope, args);</span>
    }

    static Scriptable newNativeError(Context cx, Scriptable scope,
                                     TopLevel.NativeErrors type, Object[] args)
    {
<span class="fc" id="L1197">        scope = ScriptableObject.getTopLevelScope(scope);</span>
<span class="fc" id="L1198">        Function ctor = TopLevel.getNativeErrorCtor(cx, scope, type);</span>
<span class="pc bpc" id="L1199" title="1 of 2 branches missed.">        if (args == null) { args = ScriptRuntime.emptyArgs; }</span>
<span class="fc" id="L1200">        return ctor.construct(cx, scope, args);</span>
    }

    /**
     *
     * See ECMA 9.4.
     */
    public static double toInteger(Object val) {
<span class="fc" id="L1208">        return toInteger(toNumber(val));</span>
    }

    // convenience method
    public static double toInteger(double d) {
        // if it's NaN
<span class="fc bfc" id="L1214" title="All 2 branches covered.">        if (d != d)</span>
<span class="fc" id="L1215">            return +0.0;</span>

<span class="pc bpc" id="L1217" title="1 of 6 branches missed.">        if (d == 0.0 ||</span>
            d == Double.POSITIVE_INFINITY ||
            d == Double.NEGATIVE_INFINITY)
<span class="fc" id="L1220">            return d;</span>

<span class="fc bfc" id="L1222" title="All 2 branches covered.">        if (d &gt; 0.0)</span>
<span class="fc" id="L1223">            return Math.floor(d);</span>
        else
<span class="fc" id="L1225">            return Math.ceil(d);</span>
    }

    public static double toInteger(Object[] args, int index) {
<span class="pc bpc" id="L1229" title="1 of 2 branches missed.">        return (index &lt; args.length) ? toInteger(args[index]) : +0.0;</span>
    }

    /**
     *
     * See ECMA 9.5.
     */
    public static int toInt32(Object val)
    {
        // short circuit for common integer values
<span class="fc bfc" id="L1239" title="All 2 branches covered.">        if (val instanceof Integer)</span>
<span class="fc" id="L1240">            return ((Integer)val).intValue();</span>

<span class="fc" id="L1242">        return toInt32(toNumber(val));</span>
    }

    public static int toInt32(Object[] args, int index) {
<span class="fc bfc" id="L1246" title="All 2 branches covered.">        return (index &lt; args.length) ? toInt32(args[index]) : 0;</span>
    }

    public static int toInt32(double d) {
<span class="fc" id="L1250">        return DoubleConversion.doubleToInt32(d);</span>
    }

    /**
     * See ECMA 9.6.
     * @return long value representing 32 bits unsigned integer
     */
    public static long toUint32(double d) {
<span class="fc" id="L1258">        return DoubleConversion.doubleToInt32(d) &amp; 0xffffffffL;</span>
    }

    public static long toUint32(Object val) {
<span class="fc" id="L1262">        return toUint32(toNumber(val));</span>
    }

    /**
     *
     * See ECMA 9.7.
     */
    public static char toUint16(Object val) {
<span class="nc" id="L1270">        double d = toNumber(val);</span>
<span class="nc" id="L1271">        return (char)DoubleConversion.doubleToInt32(d);</span>
    }

    // XXX: this is until setDefaultNamespace will learn how to store NS
    // properly and separates namespace form Scriptable.get etc.
    private static final String DEFAULT_NS_TAG = &quot;__default_namespace__&quot;;

    public static Object setDefaultNamespace(Object namespace, Context cx)
    {
<span class="nc" id="L1280">        Scriptable scope = cx.currentActivationCall;</span>
<span class="nc bnc" id="L1281" title="All 2 branches missed.">        if (scope == null) {</span>
<span class="nc" id="L1282">            scope = getTopCallScope(cx);</span>
        }

<span class="nc" id="L1285">        XMLLib xmlLib = currentXMLLib(cx);</span>
<span class="nc" id="L1286">        Object ns = xmlLib.toDefaultXmlNamespace(cx, namespace);</span>

        // XXX : this should be in separated namesapce from Scriptable.get/put
<span class="nc bnc" id="L1289" title="All 2 branches missed.">        if (!scope.has(DEFAULT_NS_TAG, scope)) {</span>
            // XXX: this is racy of cause
<span class="nc" id="L1291">            ScriptableObject.defineProperty(scope, DEFAULT_NS_TAG, ns,</span>
                                            ScriptableObject.PERMANENT
                                            | ScriptableObject.DONTENUM);
        } else {
<span class="nc" id="L1295">            scope.put(DEFAULT_NS_TAG, scope, ns);</span>
        }

<span class="nc" id="L1298">        return Undefined.instance;</span>
    }

    public static Object searchDefaultNamespace(Context cx)
    {
<span class="nc" id="L1303">        Scriptable scope = cx.currentActivationCall;</span>
<span class="nc bnc" id="L1304" title="All 2 branches missed.">        if (scope == null) {</span>
<span class="nc" id="L1305">            scope = getTopCallScope(cx);</span>
        }
        Object nsObject;
        for (;;) {
<span class="nc" id="L1309">            Scriptable parent = scope.getParentScope();</span>
<span class="nc bnc" id="L1310" title="All 2 branches missed.">            if (parent == null) {</span>
<span class="nc" id="L1311">                nsObject = ScriptableObject.getProperty(scope, DEFAULT_NS_TAG);</span>
<span class="nc bnc" id="L1312" title="All 2 branches missed.">                if (nsObject == Scriptable.NOT_FOUND) {</span>
<span class="nc" id="L1313">                    return null;</span>
                }
                break;
            }
<span class="nc" id="L1317">            nsObject = scope.get(DEFAULT_NS_TAG, scope);</span>
<span class="nc bnc" id="L1318" title="All 2 branches missed.">            if (nsObject != Scriptable.NOT_FOUND) {</span>
<span class="nc" id="L1319">                break;</span>
            }
<span class="nc" id="L1321">            scope = parent;</span>
<span class="nc" id="L1322">        }</span>
<span class="nc" id="L1323">        return nsObject;</span>
    }

    public static Object getTopLevelProp(Scriptable scope, String id) {
<span class="fc" id="L1327">        scope = ScriptableObject.getTopLevelScope(scope);</span>
<span class="fc" id="L1328">        return ScriptableObject.getProperty(scope, id);</span>
    }

    static Function getExistingCtor(Context cx, Scriptable scope,
                                    String constructorName)
    {
<span class="fc" id="L1334">        Object ctorVal = ScriptableObject.getProperty(scope, constructorName);</span>
<span class="fc bfc" id="L1335" title="All 2 branches covered.">        if (ctorVal instanceof Function) {</span>
<span class="fc" id="L1336">            return (Function)ctorVal;</span>
        }
<span class="pc bpc" id="L1338" title="1 of 2 branches missed.">        if (ctorVal == Scriptable.NOT_FOUND) {</span>
<span class="fc" id="L1339">            throw Context.reportRuntimeError1(</span>
                &quot;msg.ctor.not.found&quot;, constructorName);
        } else {
<span class="nc" id="L1342">            throw Context.reportRuntimeError1(</span>
                &quot;msg.not.ctor&quot;, constructorName);
        }
    }

    /**
     * Return -1L if str is not an index, or the index value as lower 32
     * bits of the result. Note that the result needs to be cast to an int
     * in order to produce the actual index, which may be negative.
     */
    public static long indexFromString(String str)
    {
        // The length of the decimal string representation of
        //  Integer.MAX_VALUE, 2147483647
<span class="fc" id="L1356">        final int MAX_VALUE_LENGTH = 10;</span>

<span class="fc" id="L1358">        int len = str.length();</span>
<span class="pc bpc" id="L1359" title="1 of 2 branches missed.">        if (len &gt; 0) {</span>
<span class="fc" id="L1360">            int i = 0;</span>
<span class="fc" id="L1361">            boolean negate = false;</span>
<span class="fc" id="L1362">            int c = str.charAt(0);</span>
<span class="pc bpc" id="L1363" title="1 of 2 branches missed.">            if (c == '-') {</span>
<span class="nc bnc" id="L1364" title="All 2 branches missed.">                if (len &gt; 1) {</span>
<span class="nc" id="L1365">                    c = str.charAt(1);</span>
<span class="nc bnc" id="L1366" title="All 2 branches missed.">                    if (c == '0') return -1L; // &quot;-0&quot; is not an index</span>
<span class="nc" id="L1367">                    i = 1;</span>
<span class="nc" id="L1368">                    negate = true;</span>
                }
            }
<span class="fc" id="L1371">            c -= '0';</span>
<span class="pc bpc" id="L1372" title="6 of 8 branches missed.">            if (0 &lt;= c &amp;&amp; c &lt;= 9</span>
                &amp;&amp; len &lt;= (negate ? MAX_VALUE_LENGTH + 1 : MAX_VALUE_LENGTH))
            {
                // Use negative numbers to accumulate index to handle
                // Integer.MIN_VALUE that is greater by 1 in absolute value
                // then Integer.MAX_VALUE
<span class="nc" id="L1378">                int index = -c;</span>
<span class="nc" id="L1379">                int oldIndex = 0;</span>
<span class="nc" id="L1380">                i++;</span>
<span class="nc bnc" id="L1381" title="All 2 branches missed.">                if (index != 0) {</span>
                    // Note that 00, 01, 000 etc. are not indexes
<span class="nc bnc" id="L1383" title="All 6 branches missed.">                    while (i != len &amp;&amp; 0 &lt;= (c = str.charAt(i) - '0') &amp;&amp; c &lt;= 9)</span>
                    {
<span class="nc" id="L1385">                        oldIndex = index;</span>
<span class="nc" id="L1386">                        index = 10 * index - c;</span>
<span class="nc" id="L1387">                        i++;</span>
                    }
                }
                // Make sure all characters were consumed and that it couldn't
                // have overflowed.
<span class="nc bnc" id="L1392" title="All 10 branches missed.">                if (i == len &amp;&amp;</span>
                    (oldIndex &gt; (Integer.MIN_VALUE / 10) ||
                     (oldIndex == (Integer.MIN_VALUE / 10) &amp;&amp;
                      c &lt;= (negate ? -(Integer.MIN_VALUE % 10)
                                   : (Integer.MAX_VALUE % 10)))))
                {
<span class="nc bnc" id="L1398" title="All 2 branches missed.">                    return 0xFFFFFFFFL &amp; (negate ? index : -index);</span>
                }
            }
        }
<span class="fc" id="L1402">        return -1L;</span>
    }

    /**
     * If str is a decimal presentation of Uint32 value, return it as long.
     * Othewise return -1L;
     */
    public static long testUint32String(String str)
    {
        // The length of the decimal string representation of
        //  UINT32_MAX_VALUE, 4294967296
<span class="nc" id="L1413">        final int MAX_VALUE_LENGTH = 10;</span>

<span class="nc" id="L1415">        int len = str.length();</span>
<span class="nc bnc" id="L1416" title="All 4 branches missed.">        if (1 &lt;= len &amp;&amp; len &lt;= MAX_VALUE_LENGTH) {</span>
<span class="nc" id="L1417">            int c = str.charAt(0);</span>
<span class="nc" id="L1418">            c -= '0';</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">            if (c == 0) {</span>
                // Note that 00,01 etc. are not valid Uint32 presentations
<span class="nc bnc" id="L1421" title="All 2 branches missed.">                return (len == 1) ? 0L : -1L;</span>
            }
<span class="nc bnc" id="L1423" title="All 4 branches missed.">            if (1 &lt;= c &amp;&amp; c &lt;= 9) {</span>
<span class="nc" id="L1424">                long v = c;</span>
<span class="nc bnc" id="L1425" title="All 2 branches missed.">                for (int i = 1; i != len; ++i) {</span>
<span class="nc" id="L1426">                    c = str.charAt(i) - '0';</span>
<span class="nc bnc" id="L1427" title="All 4 branches missed.">                    if (!(0 &lt;= c &amp;&amp; c &lt;= 9)) {</span>
<span class="nc" id="L1428">                        return -1;</span>
                    }
<span class="nc" id="L1430">                    v = 10 * v + c;</span>
                }
                // Check for overflow
<span class="nc bnc" id="L1433" title="All 2 branches missed.">                if ((v &gt;&gt;&gt; 32) == 0) {</span>
<span class="nc" id="L1434">                    return v;</span>
                }
            }
        }
<span class="nc" id="L1438">        return -1;</span>
    }

    /**
     * If s represents index, then return index value wrapped as Integer
     * and othewise return s.
     */
    static Object getIndexObject(String s)
    {
<span class="fc" id="L1447">        long indexTest = indexFromString(s);</span>
<span class="pc bpc" id="L1448" title="1 of 2 branches missed.">        if (indexTest &gt;= 0) {</span>
<span class="nc" id="L1449">            return Integer.valueOf((int)indexTest);</span>
        }
<span class="fc" id="L1451">        return s;</span>
    }

    /**
     * If d is exact int value, return its value wrapped as Integer
     * and othewise return d converted to String.
     */
    static Object getIndexObject(double d)
    {
<span class="nc" id="L1460">        int i = (int)d;</span>
<span class="nc bnc" id="L1461" title="All 2 branches missed.">        if (i == d) {</span>
<span class="nc" id="L1462">            return Integer.valueOf(i);</span>
        }
<span class="nc" id="L1464">        return toString(d);</span>
    }

    /**
     * If toString(id) is a decimal presentation of int32 value, then id
     * is index. In this case return null and make the index available
     * as ScriptRuntime.lastIndexResult(cx). Otherwise return toString(id).
     */
    static String toStringIdOrIndex(Context cx, Object id)
    {
<span class="fc bfc" id="L1474" title="All 2 branches covered.">        if (id instanceof Number) {</span>
<span class="fc" id="L1475">            double d = ((Number)id).doubleValue();</span>
<span class="fc" id="L1476">            int index = (int)d;</span>
<span class="pc bpc" id="L1477" title="1 of 2 branches missed.">            if (index == d) {</span>
<span class="fc" id="L1478">                storeIndexResult(cx, index);</span>
<span class="fc" id="L1479">                return null;</span>
            }
<span class="nc" id="L1481">            return toString(id);</span>
        } else {
            String s;
<span class="fc bfc" id="L1484" title="All 2 branches covered.">            if (id instanceof String) {</span>
<span class="fc" id="L1485">                s = (String)id;</span>
            } else {
<span class="fc" id="L1487">                s = toString(id);</span>
            }
<span class="fc" id="L1489">            long indexTest = indexFromString(s);</span>
<span class="pc bpc" id="L1490" title="1 of 2 branches missed.">            if (indexTest &gt;= 0) {</span>
<span class="nc" id="L1491">                storeIndexResult(cx, (int)indexTest);</span>
<span class="nc" id="L1492">                return null;</span>
            }
<span class="fc" id="L1494">            return s;</span>
        }
    }

    /**
     * Call obj.[[Get]](id)
     *
     * @deprecated Use {@link #getObjectElem(Object, Object, Context, Scriptable)} instead
     */
    @Deprecated
    public static Object getObjectElem(Object obj, Object elem, Context cx)
    {
<span class="nc" id="L1506">        return getObjectElem(obj, elem, cx, getTopCallScope(cx));</span>
    }

    /**
     * Call obj.[[Get]](id)
     */
    public static Object getObjectElem(Object obj, Object elem, Context cx, Scriptable scope)
    {
<span class="fc" id="L1514">        Scriptable sobj = toObjectOrNull(cx, obj, scope);</span>
<span class="pc bpc" id="L1515" title="1 of 2 branches missed.">        if (sobj == null) {</span>
<span class="nc" id="L1516">            throw undefReadError(obj, elem);</span>
        }
<span class="fc" id="L1518">        return getObjectElem(sobj, elem, cx);</span>
    }

    public static Object getObjectElem(Scriptable obj, Object elem,
                                       Context cx)
    {

        Object result;

<span class="pc bpc" id="L1527" title="1 of 2 branches missed.">        if (obj instanceof XMLObject) {</span>
<span class="nc" id="L1528">            result = ((XMLObject)obj).get(cx, elem);</span>
<span class="pc bpc" id="L1529" title="1 of 2 branches missed.">        } else if (isSymbol(elem)) {</span>
<span class="nc" id="L1530">            result = ScriptableObject.getProperty(obj, (Symbol)elem);</span>
        } else {
<span class="fc" id="L1532">            String s = toStringIdOrIndex(cx, elem);</span>
<span class="fc bfc" id="L1533" title="All 2 branches covered.">            if (s == null) {</span>
<span class="fc" id="L1534">                int index = lastIndexResult(cx);</span>
<span class="fc" id="L1535">                result = ScriptableObject.getProperty(obj, index);</span>
<span class="fc" id="L1536">            } else {</span>
<span class="fc" id="L1537">                result = ScriptableObject.getProperty(obj, s);</span>
            }
        }

<span class="pc bpc" id="L1541" title="1 of 2 branches missed.">        if (result == Scriptable.NOT_FOUND) {</span>
<span class="nc" id="L1542">            result = Undefined.instance;</span>
        }

<span class="fc" id="L1545">        return result;</span>
    }

    /**
     * Version of getObjectElem when elem is a valid JS identifier name.
     *
     * @deprecated Use {@link #getObjectProp(Object, String, Context, Scriptable)} instead
     */
    @Deprecated
    public static Object getObjectProp(Object obj, String property,
                                       Context cx)
    {
<span class="nc" id="L1557">        return getObjectProp(obj, property, cx, getTopCallScope(cx));</span>
    }

    /**
     * Version of getObjectElem when elem is a valid JS identifier name.
     *
     * @param scope the scope that should be used to resolve primitive prototype
     */
    public static Object getObjectProp(Object obj, String property,
                                       Context cx, Scriptable scope)
    {
<span class="fc" id="L1568">        Scriptable sobj = toObjectOrNull(cx, obj, scope);</span>
<span class="fc bfc" id="L1569" title="All 2 branches covered.">        if (sobj == null) {</span>
<span class="fc" id="L1570">            throw undefReadError(obj, property);</span>
        }
<span class="fc" id="L1572">        return getObjectProp(sobj, property, cx);</span>
    }

    public static Object getObjectProp(Scriptable obj, String property,
                                       Context cx)
    {

<span class="fc" id="L1579">        Object result = ScriptableObject.getProperty(obj, property);</span>
<span class="fc bfc" id="L1580" title="All 2 branches covered.">        if (result == Scriptable.NOT_FOUND) {</span>
<span class="pc bpc" id="L1581" title="1 of 2 branches missed.">            if (cx.hasFeature(Context.FEATURE_STRICT_MODE)) {</span>
<span class="nc" id="L1582">                Context.reportWarning(ScriptRuntime.getMessage1(</span>
                    &quot;msg.ref.undefined.prop&quot;, property));
            }
<span class="fc" id="L1585">            result = Undefined.instance;</span>
        }

<span class="fc" id="L1588">        return result;</span>
    }

    /**
     * @deprecated Use {@link #getObjectPropNoWarn(Object, String, Context, Scriptable)} instead
     */
    @Deprecated
    public static Object getObjectPropNoWarn(Object obj, String property,
                                             Context cx)
    {
<span class="nc" id="L1598">        return getObjectPropNoWarn(obj, property, cx, getTopCallScope(cx));</span>
    }

    public static Object getObjectPropNoWarn(Object obj, String property,
                                             Context cx, Scriptable scope)
    {
<span class="nc" id="L1604">        Scriptable sobj = toObjectOrNull(cx, obj, scope);</span>
<span class="nc bnc" id="L1605" title="All 2 branches missed.">        if (sobj == null) {</span>
<span class="nc" id="L1606">            throw undefReadError(obj, property);</span>
        }
<span class="nc" id="L1608">        Object result = ScriptableObject.getProperty(sobj, property);</span>
<span class="nc bnc" id="L1609" title="All 2 branches missed.">        if (result == Scriptable.NOT_FOUND) {</span>
<span class="nc" id="L1610">          return Undefined.instance;</span>
        }
<span class="nc" id="L1612">        return result;</span>
    }

    /**
     * A cheaper and less general version of the above for well-known argument
     * types.
     *
     * @deprecated Use {@link #getObjectIndex(Object, double, Context, Scriptable)} instead
     */
    @Deprecated
    public static Object getObjectIndex(Object obj, double dblIndex,
                                        Context cx)
    {
<span class="nc" id="L1625">        return getObjectIndex(obj, dblIndex, cx, getTopCallScope(cx));</span>
    }

    /**
     * A cheaper and less general version of the above for well-known argument
     * types.
     */
    public static Object getObjectIndex(Object obj, double dblIndex,
                                        Context cx, Scriptable scope)
    {
<span class="fc" id="L1635">        Scriptable sobj = toObjectOrNull(cx, obj, scope);</span>
<span class="pc bpc" id="L1636" title="1 of 2 branches missed.">        if (sobj == null) {</span>
<span class="nc" id="L1637">            throw undefReadError(obj, toString(dblIndex));</span>
        }

<span class="fc" id="L1640">        int index = (int)dblIndex;</span>
<span class="pc bpc" id="L1641" title="1 of 2 branches missed.">        if (index == dblIndex) {</span>
<span class="fc" id="L1642">            return getObjectIndex(sobj, index, cx);</span>
        } else {
<span class="nc" id="L1644">            String s = toString(dblIndex);</span>
<span class="nc" id="L1645">            return getObjectProp(sobj, s, cx);</span>
        }
    }

    public static Object getObjectIndex(Scriptable obj, int index,
                                        Context cx)
    {
<span class="fc" id="L1652">        Object result = ScriptableObject.getProperty(obj, index);</span>
<span class="pc bpc" id="L1653" title="1 of 2 branches missed.">        if (result == Scriptable.NOT_FOUND) {</span>
<span class="nc" id="L1654">            result = Undefined.instance;</span>
        }

<span class="fc" id="L1657">        return result;</span>
    }

    /**
     * Call obj.[[Put]](id, value)
     *
     * @deprecated Use {@link #setObjectElem(Object, Object, Object, Context, Scriptable)} instead
     */
    @Deprecated
    public static Object setObjectElem(Object obj, Object elem, Object value,
                                       Context cx)
    {
<span class="nc" id="L1669">        return setObjectElem(obj, elem, value, cx, getTopCallScope(cx));</span>
    }

    /**
     * Call obj.[[Put]](id, value)
     */
    public static Object setObjectElem(Object obj, Object elem, Object value,
                                       Context cx, Scriptable scope)
    {
<span class="fc" id="L1678">        Scriptable sobj = toObjectOrNull(cx, obj, scope);</span>
<span class="pc bpc" id="L1679" title="1 of 2 branches missed.">        if (sobj == null) {</span>
<span class="nc" id="L1680">            throw undefWriteError(obj, elem, value);</span>
        }
<span class="fc" id="L1682">        return setObjectElem(sobj, elem, value, cx);</span>
    }

    public static Object setObjectElem(Scriptable obj, Object elem,
                                       Object value, Context cx)
    {
<span class="pc bpc" id="L1688" title="1 of 2 branches missed.">        if (obj instanceof XMLObject) {</span>
<span class="nc" id="L1689">            ((XMLObject)obj).put(cx, elem, value);</span>
<span class="pc bpc" id="L1690" title="1 of 2 branches missed.">        } else if (isSymbol(elem)) {</span>
<span class="nc" id="L1691">            ScriptableObject.putProperty(obj, (Symbol)elem, value);</span>
        } else {
<span class="fc" id="L1693">            String s = toStringIdOrIndex(cx, elem);</span>
<span class="pc bpc" id="L1694" title="1 of 2 branches missed.">            if (s == null) {</span>
<span class="fc" id="L1695">                int index = lastIndexResult(cx);</span>
<span class="fc" id="L1696">                ScriptableObject.putProperty(obj, index, value);</span>
<span class="fc" id="L1697">            } else {</span>
<span class="nc" id="L1698">                ScriptableObject.putProperty(obj, s, value);</span>
            }
        }

<span class="fc" id="L1702">        return value;</span>
    }

    /**
     * Version of setObjectElem when elem is a valid JS identifier name.
     *
     * @deprecated Use {@link #setObjectProp(Object, String, Object, Context, Scriptable)} instead
     */
    @Deprecated
    public static Object setObjectProp(Object obj, String property,
                                       Object value, Context cx)
    {
<span class="nc" id="L1714">        return setObjectProp(obj, property, value, cx, getTopCallScope(cx));</span>
    }

    /**
     * Version of setObjectElem when elem is a valid JS identifier name.
     */
    public static Object setObjectProp(Object obj, String property,
                                       Object value, Context cx,
                                       Scriptable scope)
    {
<span class="fc" id="L1724">        Scriptable sobj = toObjectOrNull(cx, obj, scope);</span>
<span class="pc bpc" id="L1725" title="1 of 2 branches missed.">        if (sobj == null) {</span>
<span class="nc" id="L1726">            throw undefWriteError(obj, property, value);</span>
        }
<span class="fc" id="L1728">        return setObjectProp(sobj, property, value, cx);</span>
    }

    public static Object setObjectProp(Scriptable obj, String property,
                                       Object value, Context cx)
    {
<span class="fc" id="L1734">        ScriptableObject.putProperty(obj, property, value);</span>
<span class="fc" id="L1735">        return value;</span>
    }

    /**
     * A cheaper and less general version of the above for well-known argument
     * types.
     *
     * @deprecated Use {@link #setObjectIndex(Object, double, Object, Context, Scriptable)} instead
     */
    @Deprecated
    public static Object setObjectIndex(Object obj, double dblIndex,
                                        Object value, Context cx)
    {
<span class="nc" id="L1748">        return setObjectIndex(obj, dblIndex, value, cx, getTopCallScope(cx));</span>
    }

    /**
     * A cheaper and less general version of the above for well-known argument
     * types.
     */
    public static Object setObjectIndex(Object obj, double dblIndex,
                                        Object value, Context cx,
                                        Scriptable scope)
    {
<span class="nc" id="L1759">        Scriptable sobj = toObjectOrNull(cx, obj, scope);</span>
<span class="nc bnc" id="L1760" title="All 2 branches missed.">        if (sobj == null) {</span>
<span class="nc" id="L1761">            throw undefWriteError(obj, String.valueOf(dblIndex), value);</span>
        }

<span class="nc" id="L1764">        int index = (int)dblIndex;</span>
<span class="nc bnc" id="L1765" title="All 2 branches missed.">        if (index == dblIndex) {</span>
<span class="nc" id="L1766">            return setObjectIndex(sobj, index, value, cx);</span>
        } else {
<span class="nc" id="L1768">            String s = toString(dblIndex);</span>
<span class="nc" id="L1769">            return setObjectProp(sobj, s, value, cx);</span>
        }
    }

    public static Object setObjectIndex(Scriptable obj, int index, Object value,
                                        Context cx)
    {
<span class="nc" id="L1776">        ScriptableObject.putProperty(obj, index, value);</span>
<span class="nc" id="L1777">        return value;</span>
    }

    public static boolean deleteObjectElem(Scriptable target, Object elem,
                                           Context cx)
    {
<span class="nc bnc" id="L1783" title="All 2 branches missed.">        if (isSymbol(elem)) {</span>
<span class="nc" id="L1784">            SymbolScriptable so = ScriptableObject.ensureSymbolScriptable(target);</span>
<span class="nc" id="L1785">            Symbol s = (Symbol)elem;</span>
<span class="nc" id="L1786">            so.delete(s);</span>
<span class="nc bnc" id="L1787" title="All 2 branches missed.">            return !so.has(s, target);</span>
        }
<span class="nc" id="L1789">        String s = toStringIdOrIndex(cx, elem);</span>
<span class="nc bnc" id="L1790" title="All 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L1791">            int index = lastIndexResult(cx);</span>
<span class="nc" id="L1792">            target.delete(index);</span>
<span class="nc bnc" id="L1793" title="All 2 branches missed.">            return !target.has(index, target);</span>
        } else {
<span class="nc" id="L1795">            target.delete(s);</span>
<span class="nc bnc" id="L1796" title="All 2 branches missed.">            return !target.has(s, target);</span>
        }
    }

    public static boolean hasObjectElem(Scriptable target, Object elem,
                                        Context cx)
    {
        boolean result;

<span class="nc bnc" id="L1805" title="All 2 branches missed.">        if (isSymbol(elem)) {</span>
<span class="nc" id="L1806">            result = ScriptableObject.hasProperty(target, (Symbol)elem);</span>
        } else {
<span class="nc" id="L1808">            String s = toStringIdOrIndex(cx, elem);</span>
<span class="nc bnc" id="L1809" title="All 2 branches missed.">            if (s == null) {</span>
<span class="nc" id="L1810">                int index = lastIndexResult(cx);</span>
<span class="nc" id="L1811">                result = ScriptableObject.hasProperty(target, index);</span>
<span class="nc" id="L1812">            } else {</span>
<span class="nc" id="L1813">                result = ScriptableObject.hasProperty(target, s);</span>
            }
        }

<span class="nc" id="L1817">        return result;</span>
    }

    public static Object refGet(Ref ref, Context cx)
    {
<span class="nc" id="L1822">        return ref.get(cx);</span>
    }

    /**
     * @deprecated Use {@link #refSet(Ref, Object, Context, Scriptable)} instead
     */
    @Deprecated
    public static Object refSet(Ref ref, Object value, Context cx)
    {
<span class="nc" id="L1831">        return refSet(ref, value, cx, getTopCallScope(cx));</span>
    }

    public static Object refSet(Ref ref, Object value, Context cx,
                                Scriptable scope)
    {
<span class="nc" id="L1837">        return ref.set(cx, scope, value);</span>
    }

    public static Object refDel(Ref ref, Context cx)
    {
<span class="nc" id="L1842">        return wrapBoolean(ref.delete(cx));</span>
    }

    static boolean isSpecialProperty(String s)
    {
<span class="pc bpc" id="L1847" title="2 of 4 branches missed.">        return s.equals(&quot;__proto__&quot;) || s.equals(&quot;__parent__&quot;);</span>
    }

    /**
     * @deprecated Use {@link #specialRef(Object, String, Context, Scriptable)} instead
     */
    @Deprecated
    public static Ref specialRef(Object obj, String specialProperty,
                                 Context cx)
    {
<span class="nc" id="L1857">        return specialRef(obj, specialProperty, cx, getTopCallScope(cx));</span>
    }

    public static Ref specialRef(Object obj, String specialProperty,
                                 Context cx, Scriptable scope)
    {
<span class="nc" id="L1863">        return SpecialRef.createSpecial(cx, scope, obj, specialProperty);</span>
    }

    /**
     * @deprecated Use {@link #delete(Object, Object, Context, Scriptable, boolean)} instead
     */
    @Deprecated
    public static Object delete(Object obj, Object id, Context cx)
    {
<span class="nc" id="L1872">        return delete(obj, id, cx, false);</span>
    }

    /**
     * The delete operator
     *
     * See ECMA 11.4.1
     *
     * In ECMA 0.19, the description of the delete operator (11.4.1)
     * assumes that the [[Delete]] method returns a value. However,
     * the definition of the [[Delete]] operator (8.6.2.5) does not
     * define a return value. Here we assume that the [[Delete]]
     * method doesn't return a value.
     *
     * @deprecated Use {@link #delete(Object, Object, Context, Scriptable, boolean)} instead
     */
    @Deprecated
    public static Object delete(Object obj, Object id, Context cx, boolean isName)
    {
<span class="nc" id="L1891">        return delete(obj, id, cx, getTopCallScope(cx), isName);</span>
    }

    /**
     * The delete operator
     *
     * See ECMA 11.4.1
     *
     * In ECMA 0.19, the description of the delete operator (11.4.1)
     * assumes that the [[Delete]] method returns a value. However,
     * the definition of the [[Delete]] operator (8.6.2.5) does not
     * define a return value. Here we assume that the [[Delete]]
     * method doesn't return a value.
     */
    public static Object delete(Object obj, Object id, Context cx,
                                Scriptable scope, boolean isName)
    {
<span class="nc" id="L1908">        Scriptable sobj = toObjectOrNull(cx, obj, scope);</span>
<span class="nc bnc" id="L1909" title="All 2 branches missed.">        if (sobj == null) {</span>
<span class="nc bnc" id="L1910" title="All 2 branches missed.">            if (isName) {</span>
<span class="nc" id="L1911">                return Boolean.TRUE;</span>
            }
<span class="nc" id="L1913">            throw undefDeleteError(obj, id);</span>
        }
<span class="nc" id="L1915">        boolean result = deleteObjectElem(sobj, id, cx);</span>
<span class="nc" id="L1916">        return wrapBoolean(result);</span>
    }

    /**
     * Looks up a name in the scope chain and returns its value.
     */
    public static Object name(Context cx, Scriptable scope, String name)
    {
<span class="fc" id="L1924">        Scriptable parent = scope.getParentScope();</span>
<span class="fc bfc" id="L1925" title="All 2 branches covered.">        if (parent == null) {</span>
<span class="fc" id="L1926">            Object result = topScopeName(cx, scope, name);</span>
<span class="fc bfc" id="L1927" title="All 2 branches covered.">            if (result == Scriptable.NOT_FOUND) {</span>
<span class="nc" id="L1928">                throw notFoundError(scope, name);</span>
            }
<span class="fc" id="L1930">            return result;</span>
        }

<span class="fc" id="L1933">        return nameOrFunction(cx, scope, parent, name, false);</span>
    }

    private static Object nameOrFunction(Context cx, Scriptable scope,
                                         Scriptable parentScope, String name,
                                         boolean asFunctionCall)
    {
        Object result;
<span class="fc" id="L1941">        Scriptable thisObj = scope; // It is used only if asFunctionCall==true.</span>

<span class="fc" id="L1943">        XMLObject firstXMLObject = null;</span>
        for (;;) {
<span class="fc bfc" id="L1945" title="All 2 branches covered.">            if (scope instanceof NativeWith) {</span>
<span class="fc" id="L1946">                Scriptable withObj = scope.getPrototype();</span>
<span class="pc bpc" id="L1947" title="1 of 2 branches missed.">                if (withObj instanceof XMLObject) {</span>
<span class="nc" id="L1948">                    XMLObject xmlObj = (XMLObject)withObj;</span>
<span class="nc bnc" id="L1949" title="All 2 branches missed.">                    if (xmlObj.has(name, xmlObj)) {</span>
                        // function this should be the target object of with
<span class="nc" id="L1951">                        thisObj = xmlObj;</span>
<span class="nc" id="L1952">                        result = xmlObj.get(name, xmlObj);</span>
<span class="nc" id="L1953">                        break;</span>
                    }
<span class="nc bnc" id="L1955" title="All 2 branches missed.">                    if (firstXMLObject == null) {</span>
<span class="nc" id="L1956">                        firstXMLObject = xmlObj;</span>
                    }
<span class="nc" id="L1958">                } else {</span>
<span class="fc" id="L1959">                    result = ScriptableObject.getProperty(withObj, name);</span>
<span class="fc bfc" id="L1960" title="All 2 branches covered.">                    if (result != Scriptable.NOT_FOUND) {</span>
                        // function this should be the target object of with
<span class="fc" id="L1962">                        thisObj = withObj;</span>
<span class="fc" id="L1963">                        break;</span>
                    }
                }
<span class="pc bpc" id="L1966" title="1 of 2 branches missed.">            } else if (scope instanceof NativeCall) {</span>
                // NativeCall does not prototype chain and Scriptable.get
                // can be called directly.
<span class="fc" id="L1969">                result = scope.get(name, scope);</span>
<span class="fc bfc" id="L1970" title="All 2 branches covered.">                if (result != Scriptable.NOT_FOUND) {</span>
<span class="pc bpc" id="L1971" title="1 of 2 branches missed.">                    if (asFunctionCall) {</span>
                        // ECMA 262 requires that this for nested funtions
                        // should be top scope
<span class="nc" id="L1974">                        thisObj = ScriptableObject.</span>
<span class="nc" id="L1975">                                      getTopLevelScope(parentScope);</span>
                    }
                    break;
                }
            } else {
                // Can happen if Rhino embedding decided that nested
                // scopes are useful for what ever reasons.
<span class="nc" id="L1982">                result = ScriptableObject.getProperty(scope, name);</span>
<span class="nc bnc" id="L1983" title="All 2 branches missed.">                if (result != Scriptable.NOT_FOUND) {</span>
<span class="nc" id="L1984">                    thisObj = scope;</span>
<span class="nc" id="L1985">                    break;</span>
                }
            }
<span class="fc" id="L1988">            scope = parentScope;</span>
<span class="fc" id="L1989">            parentScope = parentScope.getParentScope();</span>
<span class="fc bfc" id="L1990" title="All 2 branches covered.">            if (parentScope == null) {</span>
<span class="fc" id="L1991">                result = topScopeName(cx, scope, name);</span>
<span class="fc bfc" id="L1992" title="All 2 branches covered.">                if (result == Scriptable.NOT_FOUND) {</span>
<span class="pc bpc" id="L1993" title="3 of 4 branches missed.">                    if (firstXMLObject == null || asFunctionCall) {</span>
<span class="nc" id="L1994">                        throw notFoundError(scope, name);</span>
                    }
                    // The name was not found, but we did find an XML
                    // object in the scope chain and we are looking for name,
                    // not function. The result should be an empty XMLList
                    // in name context.
<span class="nc" id="L2000">                    result = firstXMLObject.get(name, firstXMLObject);</span>
                }
                // For top scope thisObj for functions is always scope itself.
<span class="fc" id="L2003">                thisObj = scope;</span>
<span class="fc" id="L2004">                break;</span>
            }
        }

<span class="fc bfc" id="L2008" title="All 2 branches covered.">        if (asFunctionCall) {</span>
<span class="pc bpc" id="L2009" title="1 of 2 branches missed.">            if (!(result instanceof Callable)) {</span>
<span class="nc" id="L2010">                throw notFunctionError(result, name);</span>
            }
<span class="fc" id="L2012">            storeScriptable(cx, thisObj);</span>
        }

<span class="fc" id="L2015">        return result;</span>
    }

    private static Object topScopeName(Context cx, Scriptable scope,
                                       String name)
    {
<span class="pc bpc" id="L2021" title="1 of 2 branches missed.">        if (cx.useDynamicScope) {</span>
<span class="nc" id="L2022">            scope = checkDynamicScope(cx.topCallScope, scope);</span>
        }
<span class="fc" id="L2024">        return ScriptableObject.getProperty(scope, name);</span>
    }


    /**
     * Returns the object in the scope chain that has a given property.
     *
     * The order of evaluation of an assignment expression involves
     * evaluating the lhs to a reference, evaluating the rhs, and then
     * modifying the reference with the rhs value. This method is used
     * to 'bind' the given name to an object containing that property
     * so that the side effects of evaluating the rhs do not affect
     * which property is modified.
     * Typically used in conjunction with setName.
     *
     * See ECMA 10.1.4
     */
    public static Scriptable bind(Context cx, Scriptable scope, String id)
    {
<span class="fc" id="L2043">        Scriptable firstXMLObject = null;</span>
<span class="fc" id="L2044">        Scriptable parent = scope.getParentScope();</span>
<span class="fc bfc" id="L2045" title="All 2 branches covered.">        childScopesChecks: if (parent != null) {</span>
            // Check for possibly nested &quot;with&quot; scopes first
<span class="pc bpc" id="L2047" title="1 of 2 branches missed.">            while (scope instanceof NativeWith) {</span>
<span class="nc" id="L2048">                Scriptable withObj = scope.getPrototype();</span>
<span class="nc bnc" id="L2049" title="All 2 branches missed.">                if (withObj instanceof XMLObject) {</span>
<span class="nc" id="L2050">                    XMLObject xmlObject = (XMLObject)withObj;</span>
<span class="nc bnc" id="L2051" title="All 2 branches missed.">                    if (xmlObject.has(cx, id)) {</span>
<span class="nc" id="L2052">                        return xmlObject;</span>
                    }
<span class="nc bnc" id="L2054" title="All 2 branches missed.">                    if (firstXMLObject == null) {</span>
<span class="nc" id="L2055">                        firstXMLObject = xmlObject;</span>
                    }
<span class="nc" id="L2057">                } else {</span>
<span class="nc bnc" id="L2058" title="All 2 branches missed.">                    if (ScriptableObject.hasProperty(withObj, id)) {</span>
<span class="nc" id="L2059">                        return withObj;</span>
                    }
                }
<span class="nc" id="L2062">                scope = parent;</span>
<span class="nc" id="L2063">                parent = parent.getParentScope();</span>
<span class="nc bnc" id="L2064" title="All 2 branches missed.">                if (parent == null) {</span>
<span class="nc" id="L2065">                    break childScopesChecks;</span>
                }
<span class="nc" id="L2067">            }</span>
            for (;;) {
<span class="fc bfc" id="L2069" title="All 2 branches covered.">                if (ScriptableObject.hasProperty(scope, id)) {</span>
<span class="fc" id="L2070">                    return scope;</span>
                }
<span class="fc" id="L2072">                scope = parent;</span>
<span class="fc" id="L2073">                parent = parent.getParentScope();</span>
<span class="pc bpc" id="L2074" title="1 of 2 branches missed.">                if (parent == null) {</span>
<span class="fc" id="L2075">                    break childScopesChecks;</span>
                }
            }
        }
        // scope here is top scope
<span class="pc bpc" id="L2080" title="1 of 2 branches missed.">        if (cx.useDynamicScope) {</span>
<span class="nc" id="L2081">            scope = checkDynamicScope(cx.topCallScope, scope);</span>
        }
<span class="fc bfc" id="L2083" title="All 2 branches covered.">        if (ScriptableObject.hasProperty(scope, id)) {</span>
<span class="fc" id="L2084">            return scope;</span>
        }
        // Nothing was found, but since XML objects always bind
        // return one if found
<span class="fc" id="L2088">        return firstXMLObject;</span>
    }

    public static Object setName(Scriptable bound, Object value,
                                 Context cx, Scriptable scope, String id)
    {
<span class="fc bfc" id="L2094" title="All 2 branches covered.">        if (bound != null) {</span>
            // TODO: we used to special-case XMLObject here, but putProperty
            // seems to work for E4X and it's better to optimize  the common case
<span class="fc" id="L2097">            ScriptableObject.putProperty(bound, id, value);</span>
        } else {
            // &quot;newname = 7;&quot;, where 'newname' has not yet
            // been defined, creates a new property in the
            // top scope unless strict mode is specified.
<span class="pc bpc" id="L2102" title="1 of 2 branches missed.">            if (cx.hasFeature(Context.FEATURE_STRICT_MODE) ||</span>
<span class="pc bpc" id="L2103" title="1 of 2 branches missed.">                cx.hasFeature(Context.FEATURE_STRICT_VARS))</span>
            {
<span class="nc" id="L2105">                Context.reportWarning(</span>
<span class="nc" id="L2106">                    ScriptRuntime.getMessage1(&quot;msg.assn.create.strict&quot;, id));</span>
            }
            // Find the top scope by walking up the scope chain.
<span class="fc" id="L2109">            bound = ScriptableObject.getTopLevelScope(scope);</span>
<span class="pc bpc" id="L2110" title="1 of 2 branches missed.">            if (cx.useDynamicScope) {</span>
<span class="nc" id="L2111">                bound = checkDynamicScope(cx.topCallScope, bound);</span>
            }
<span class="fc" id="L2113">            bound.put(id, bound, value);</span>
        }
<span class="fc" id="L2115">        return value;</span>
    }

    public static Object strictSetName(Scriptable bound, Object value,
            Context cx, Scriptable scope, String id) {
<span class="nc bnc" id="L2120" title="All 2 branches missed.">        if (bound != null) {</span>
            // TODO: The LeftHandSide also may not be a reference to a
            // data property with the attribute value {[[Writable]]:false},
            // to an accessor property with the attribute value
            // {[[Put]]:undefined}, nor to a non-existent property of an
            // object whose [[Extensible]] internal property has the value
            // false. In these cases a TypeError exception is thrown (11.13.1).
            // TODO: we used to special-case XMLObject here, but putProperty
            // seems to work for E4X and we should optimize  the common case
<span class="nc" id="L2129">            ScriptableObject.putProperty(bound, id, value);</span>
<span class="nc" id="L2130">            return value;</span>
        } else {
            // See ES5 8.7.2
<span class="nc" id="L2133">            String msg = &quot;Assignment to undefined \&quot;&quot; + id + &quot;\&quot; in strict mode&quot;;</span>
<span class="nc" id="L2134">            throw constructError(&quot;ReferenceError&quot;, msg);</span>
        }
    }

    public static Object setConst(Scriptable bound, Object value,
                                 Context cx, String id)
    {
<span class="nc bnc" id="L2141" title="All 2 branches missed.">        if (bound instanceof XMLObject) {</span>
<span class="nc" id="L2142">            bound.put(id, bound, value);</span>
        } else {
<span class="nc" id="L2144">            ScriptableObject.putConstProperty(bound, id, value);</span>
        }
<span class="nc" id="L2146">        return value;</span>
    }

    /**
     * This is the enumeration needed by the for..in statement.
     *
     * See ECMA 12.6.3.
     *
     * IdEnumeration maintains a ObjToIntMap to make sure a given
     * id is enumerated only once across multiple objects in a
     * prototype chain.
     *
     * XXX - ECMA delete doesn't hide properties in the prototype,
     * but js/ref does. This means that the js/ref for..in can
     * avoid maintaining a hash table and instead perform lookups
     * to see if a given property has already been enumerated.
     *
     */
<span class="nc" id="L2164">    private static class IdEnumeration implements Serializable</span>
    {
        private static final long serialVersionUID = 1L;
        Scriptable obj;
        Object[] ids;
        int index;
        ObjToIntMap used;
        Object currentId;
        int enumType; /* one of ENUM_INIT_KEYS, ENUM_INIT_VALUES,
                         ENUM_INIT_ARRAY, ENUMERATE_VALUES_IN_ORDER */

        // if true, integer ids will be returned as numbers rather than strings
        boolean enumNumbers;

        Scriptable iterator;
    }

    public static Scriptable toIterator(Context cx, Scriptable scope,
                                        Scriptable obj, boolean keyOnly)
    {
<span class="nc bnc" id="L2184" title="All 2 branches missed.">        if (ScriptableObject.hasProperty(obj,</span>
            NativeIterator.ITERATOR_PROPERTY_NAME))
        {
<span class="nc" id="L2187">            Object v = ScriptableObject.getProperty(obj,</span>
                NativeIterator.ITERATOR_PROPERTY_NAME);
<span class="nc bnc" id="L2189" title="All 2 branches missed.">            if (!(v instanceof Callable)) {</span>
<span class="nc" id="L2190">               throw typeError0(&quot;msg.invalid.iterator&quot;);</span>
            }
<span class="nc" id="L2192">            Callable f = (Callable) v;</span>
<span class="nc bnc" id="L2193" title="All 2 branches missed.">            Object[] args = new Object[] { keyOnly ? Boolean.TRUE</span>
                                                   : Boolean.FALSE };
<span class="nc" id="L2195">            v = f.call(cx, scope, obj, args);</span>
<span class="nc bnc" id="L2196" title="All 2 branches missed.">            if (!(v instanceof Scriptable)) {</span>
<span class="nc" id="L2197">                throw typeError0(&quot;msg.iterator.primitive&quot;);</span>
            }
<span class="nc" id="L2199">            return (Scriptable) v;</span>
        }
<span class="nc" id="L2201">        return null;</span>
    }

    /**
     * For backwards compatibility with generated class files
     *
     * @deprecated Use {@link #enumInit(Object, Context, Scriptable, int)} instead
     */
    @Deprecated
    public static Object enumInit(Object value, Context cx, boolean enumValues)
    {
<span class="nc bnc" id="L2212" title="All 2 branches missed.">        return enumInit(value, cx, enumValues ? ENUMERATE_VALUES</span>
                                              : ENUMERATE_KEYS);
    }

    public static final int ENUMERATE_KEYS = 0;
    public static final int ENUMERATE_VALUES = 1;
    public static final int ENUMERATE_ARRAY = 2;
    public static final int ENUMERATE_KEYS_NO_ITERATOR = 3;
    public static final int ENUMERATE_VALUES_NO_ITERATOR = 4;
    public static final int ENUMERATE_ARRAY_NO_ITERATOR = 5;
    public static final int ENUMERATE_VALUES_IN_ORDER = 6;

    /**
     * @deprecated Use {@link #enumInit(Object, Context, Scriptable, int)} instead
     */
    @Deprecated
    public static Object enumInit(Object value, Context cx, int enumType)
    {
<span class="nc" id="L2230">        return enumInit(value, cx, getTopCallScope(cx), enumType);</span>
    }

    public static Object enumInit(Object value, Context cx, Scriptable scope,
                                  int enumType)
    {
<span class="nc" id="L2236">        IdEnumeration x = new IdEnumeration();</span>
<span class="nc" id="L2237">        x.obj = toObjectOrNull(cx, value, scope);</span>
        // &quot;for of&quot; loop
<span class="nc bnc" id="L2239" title="All 2 branches missed.">        if (enumType == ENUMERATE_VALUES_IN_ORDER) {</span>
<span class="nc" id="L2240">            x.enumType = enumType;</span>
<span class="nc" id="L2241">            x.iterator = null;</span>
<span class="nc" id="L2242">            return enumInitInOrder(cx, x);</span>
        }
<span class="nc bnc" id="L2244" title="All 2 branches missed.">        if (x.obj == null) {</span>
            // null or undefined do not cause errors but rather lead to empty
            // &quot;for in&quot; loop
<span class="nc" id="L2247">            return x;</span>
        }
<span class="nc" id="L2249">        x.enumType = enumType;</span>
<span class="nc" id="L2250">        x.iterator = null;</span>
<span class="nc bnc" id="L2251" title="All 6 branches missed.">        if (enumType != ENUMERATE_KEYS_NO_ITERATOR &amp;&amp;</span>
            enumType != ENUMERATE_VALUES_NO_ITERATOR &amp;&amp;
            enumType != ENUMERATE_ARRAY_NO_ITERATOR)
        {
<span class="nc bnc" id="L2255" title="All 2 branches missed.">            x.iterator = toIterator(cx, x.obj.getParentScope(), x.obj,</span>
                                    enumType == ScriptRuntime.ENUMERATE_KEYS);
        }
<span class="nc bnc" id="L2258" title="All 2 branches missed.">        if (x.iterator == null) {</span>
            // enumInit should read all initial ids before returning
            // or &quot;for (a.i in a)&quot; would wrongly enumerate i in a as well
<span class="nc" id="L2261">            enumChangeObject(x);</span>
        }

<span class="nc" id="L2264">        return x;</span>
    }

    private static Object enumInitInOrder(Context cx, IdEnumeration x) {
<span class="nc bnc" id="L2268" title="All 2 branches missed.">        if (!(x.obj instanceof ScriptableObject)) {</span>
<span class="nc" id="L2269">            throw typeError1(&quot;msg.not.iterable&quot;, toString(x.obj));</span>
        }

<span class="nc" id="L2272">        ScriptableObject xo = (ScriptableObject)x.obj;</span>
<span class="nc bnc" id="L2273" title="All 2 branches missed.">        if (!ScriptableObject.hasProperty(xo, SymbolKey.ITERATOR)) {</span>
<span class="nc" id="L2274">            throw typeError1(&quot;msg.not.iterable&quot;, toString(x.obj));</span>
        }
<span class="nc" id="L2276">        Object iterator = ScriptableObject.getProperty(xo, SymbolKey.ITERATOR);</span>
<span class="nc bnc" id="L2277" title="All 2 branches missed.">        if (!(iterator instanceof Callable)) {</span>
<span class="nc" id="L2278">            throw typeError1(&quot;msg.not.iterable&quot;, toString(x.obj));</span>
        }
<span class="nc" id="L2280">        Callable f = (Callable) iterator;</span>
<span class="nc" id="L2281">        Scriptable scope = x.obj.getParentScope();</span>
<span class="nc" id="L2282">        Object[] args = new Object[] {};</span>
<span class="nc" id="L2283">        Object v = f.call(cx, scope, x.obj, args);</span>
<span class="nc bnc" id="L2284" title="All 2 branches missed.">        if (!(v instanceof Scriptable)) {</span>
<span class="nc" id="L2285">            throw typeError1(&quot;msg.not.iterable&quot;, toString(x.obj));</span>
        }
<span class="nc" id="L2287">        x.iterator = (Scriptable) v;</span>
<span class="nc" id="L2288">        return x;</span>
    }

    public static void setEnumNumbers(Object enumObj, boolean enumNumbers) {
<span class="nc" id="L2292">        ((IdEnumeration)enumObj).enumNumbers = enumNumbers;</span>
<span class="nc" id="L2293">    }</span>

    public static Boolean enumNext(Object enumObj)
    {
<span class="nc" id="L2297">        IdEnumeration x = (IdEnumeration)enumObj;</span>
<span class="nc bnc" id="L2298" title="All 2 branches missed.">        if (x.iterator != null) {</span>
<span class="nc bnc" id="L2299" title="All 2 branches missed.">            if (x.enumType == ENUMERATE_VALUES_IN_ORDER) {</span>
<span class="nc" id="L2300">                return enumNextInOrder(x);</span>
            }
<span class="nc" id="L2302">            Object v = ScriptableObject.getProperty(x.iterator, &quot;next&quot;);</span>
<span class="nc bnc" id="L2303" title="All 2 branches missed.">            if (!(v instanceof Callable))</span>
<span class="nc" id="L2304">                return Boolean.FALSE;</span>
<span class="nc" id="L2305">            Callable f = (Callable) v;</span>
<span class="nc" id="L2306">            Context cx = Context.getContext();</span>
            try {
<span class="nc" id="L2308">                x.currentId = f.call(cx, x.iterator.getParentScope(),</span>
                                     x.iterator, emptyArgs);
<span class="nc" id="L2310">                return Boolean.TRUE;</span>
<span class="nc" id="L2311">            } catch (JavaScriptException e) {</span>
<span class="nc bnc" id="L2312" title="All 2 branches missed.">                if (e.getValue() instanceof NativeIterator.StopIteration) {</span>
<span class="nc" id="L2313">                    return Boolean.FALSE;</span>
                }
<span class="nc" id="L2315">                throw e;</span>
            }
        }
        for (;;) {
<span class="nc bnc" id="L2319" title="All 2 branches missed.">            if (x.obj == null) {</span>
<span class="nc" id="L2320">                return Boolean.FALSE;</span>
            }
<span class="nc bnc" id="L2322" title="All 2 branches missed.">            if (x.index == x.ids.length) {</span>
<span class="nc" id="L2323">                x.obj = x.obj.getPrototype();</span>
<span class="nc" id="L2324">                enumChangeObject(x);</span>
<span class="nc" id="L2325">                continue;</span>
            }
<span class="nc" id="L2327">            Object id = x.ids[x.index++];</span>
<span class="nc bnc" id="L2328" title="All 4 branches missed.">            if (x.used != null &amp;&amp; x.used.has(id)) {</span>
<span class="nc" id="L2329">                continue;</span>
            }
<span class="nc bnc" id="L2331" title="All 2 branches missed.">            if (id instanceof Symbol) {</span>
<span class="nc" id="L2332">                continue;</span>
<span class="nc bnc" id="L2333" title="All 2 branches missed.">            } else if (id instanceof String) {</span>
<span class="nc" id="L2334">                String strId = (String) id;</span>
<span class="nc bnc" id="L2335" title="All 2 branches missed.">                if (!x.obj.has(strId, x.obj))</span>
<span class="nc" id="L2336">                    continue;   // must have been deleted</span>
<span class="nc" id="L2337">                x.currentId = strId;</span>
<span class="nc" id="L2338">            } else {</span>
<span class="nc" id="L2339">                int intId = ((Number)id).intValue();</span>
<span class="nc bnc" id="L2340" title="All 2 branches missed.">                if (!x.obj.has(intId, x.obj))</span>
<span class="nc" id="L2341">                    continue;   // must have been deleted</span>
<span class="nc bnc" id="L2342" title="All 2 branches missed.">                x.currentId = x.enumNumbers ? (Object) (Integer.valueOf(intId))</span>
<span class="nc" id="L2343">                                            : String.valueOf(intId);</span>
            }
<span class="nc" id="L2345">            return Boolean.TRUE;</span>
        }
    }

    private static Boolean enumNextInOrder(IdEnumeration enumObj)
    {
<span class="nc" id="L2351">        Object v = ScriptableObject.getProperty(enumObj.iterator, ES6Iterator.NEXT_METHOD);</span>
<span class="nc bnc" id="L2352" title="All 2 branches missed.">        if (!(v instanceof Callable)) {</span>
<span class="nc" id="L2353">            throw notFunctionError(enumObj.iterator, ES6Iterator.NEXT_METHOD);</span>
        }
<span class="nc" id="L2355">        Callable f = (Callable) v;</span>
<span class="nc" id="L2356">        Context cx = Context.getContext();</span>
<span class="nc" id="L2357">        Scriptable scope = enumObj.iterator.getParentScope();</span>
<span class="nc" id="L2358">        Object r = f.call(cx, scope, enumObj.iterator, emptyArgs);</span>
<span class="nc" id="L2359">        Scriptable iteratorResult = toObject(cx, scope, r);</span>
<span class="nc" id="L2360">        Object done = ScriptableObject.getProperty(iteratorResult, ES6Iterator.DONE_PROPERTY);</span>
<span class="nc bnc" id="L2361" title="All 4 branches missed.">        if (done != ScriptableObject.NOT_FOUND &amp;&amp; toBoolean(done)) {</span>
<span class="nc" id="L2362">            return Boolean.FALSE;</span>
        }
<span class="nc" id="L2364">        enumObj.currentId = ScriptableObject.getProperty(iteratorResult, ES6Iterator.VALUE_PROPERTY);</span>
<span class="nc" id="L2365">        return Boolean.TRUE;</span>
    }

    public static Object enumId(Object enumObj, Context cx)
    {
<span class="nc" id="L2370">        IdEnumeration x = (IdEnumeration)enumObj;</span>
<span class="nc bnc" id="L2371" title="All 2 branches missed.">        if (x.iterator != null) {</span>
<span class="nc" id="L2372">            return x.currentId;</span>
        }
<span class="nc bnc" id="L2374" title="All 4 branches missed.">        switch (x.enumType) {</span>
          case ENUMERATE_KEYS:
          case ENUMERATE_KEYS_NO_ITERATOR:
<span class="nc" id="L2377">            return x.currentId;</span>
          case ENUMERATE_VALUES:
          case ENUMERATE_VALUES_NO_ITERATOR:
<span class="nc" id="L2380">            return enumValue(enumObj, cx);</span>
          case ENUMERATE_ARRAY:
          case ENUMERATE_ARRAY_NO_ITERATOR:
<span class="nc" id="L2383">            Object[] elements = { x.currentId, enumValue(enumObj, cx) };</span>
<span class="nc" id="L2384">            return cx.newArray(ScriptableObject.getTopLevelScope(x.obj), elements);</span>
          default:
<span class="nc" id="L2386">            throw Kit.codeBug();</span>
        }
    }

    public static Object enumValue(Object enumObj, Context cx) {
<span class="nc" id="L2391">        IdEnumeration x = (IdEnumeration)enumObj;</span>

        Object result;

<span class="nc bnc" id="L2395" title="All 2 branches missed.">        if (isSymbol(x.currentId)) {</span>
<span class="nc" id="L2396">            SymbolScriptable so = ScriptableObject.ensureSymbolScriptable(x.obj);</span>
<span class="nc" id="L2397">            result = so.get((Symbol)x.currentId, x.obj);</span>
<span class="nc" id="L2398">        } else {</span>
<span class="nc" id="L2399">            String s = toStringIdOrIndex(cx, x.currentId);</span>
<span class="nc bnc" id="L2400" title="All 2 branches missed.">            if (s == null) {</span>
<span class="nc" id="L2401">                int index = lastIndexResult(cx);</span>
<span class="nc" id="L2402">                result = x.obj.get(index, x.obj);</span>
<span class="nc" id="L2403">            } else {</span>
<span class="nc" id="L2404">                result = x.obj.get(s, x.obj);</span>
            }
        }

<span class="nc" id="L2408">        return result;</span>
    }

    private static void enumChangeObject(IdEnumeration x)
    {
<span class="nc" id="L2413">        Object[] ids = null;</span>
<span class="nc bnc" id="L2414" title="All 2 branches missed.">        while (x.obj != null) {</span>
<span class="nc" id="L2415">            ids = x.obj.getIds();</span>
<span class="nc bnc" id="L2416" title="All 2 branches missed.">            if (ids.length != 0) {</span>
<span class="nc" id="L2417">                break;</span>
            }
<span class="nc" id="L2419">            x.obj = x.obj.getPrototype();</span>
        }
<span class="nc bnc" id="L2421" title="All 4 branches missed.">        if (x.obj != null &amp;&amp; x.ids != null) {</span>
<span class="nc" id="L2422">            Object[] previous = x.ids;</span>
<span class="nc" id="L2423">            int L = previous.length;</span>
<span class="nc bnc" id="L2424" title="All 2 branches missed.">            if (x.used == null) {</span>
<span class="nc" id="L2425">                x.used = new ObjToIntMap(L);</span>
            }
<span class="nc bnc" id="L2427" title="All 2 branches missed.">            for (int i = 0; i != L; ++i) {</span>
<span class="nc" id="L2428">                x.used.intern(previous[i]);</span>
            }
        }
<span class="nc" id="L2431">        x.ids = ids;</span>
<span class="nc" id="L2432">        x.index = 0;</span>
<span class="nc" id="L2433">    }</span>

    /**
     * Prepare for calling name(...): return function corresponding to
     * name and make current top scope available
     * as ScriptRuntime.lastStoredScriptable() for consumption as thisObj.
     * The caller must call ScriptRuntime.lastStoredScriptable() immediately
     * after calling this method.
     */
    public static Callable getNameFunctionAndThis(String name,
                                                  Context cx,
                                                  Scriptable scope)
    {
<span class="fc" id="L2446">        Scriptable parent = scope.getParentScope();</span>
<span class="fc bfc" id="L2447" title="All 2 branches covered.">        if (parent == null) {</span>
<span class="fc" id="L2448">            Object result = topScopeName(cx, scope, name);</span>
<span class="pc bpc" id="L2449" title="1 of 2 branches missed.">            if (!(result instanceof Callable)) {</span>
<span class="nc bnc" id="L2450" title="All 2 branches missed.">                if (result == Scriptable.NOT_FOUND) {</span>
<span class="nc" id="L2451">                    throw notFoundError(scope, name);</span>
                } else {
<span class="nc" id="L2453">                    throw notFunctionError(result, name);</span>
                }
            }
            // Top scope is not NativeWith or NativeCall =&gt; thisObj == scope
<span class="fc" id="L2457">            Scriptable thisObj = scope;</span>
<span class="fc" id="L2458">            storeScriptable(cx, thisObj);</span>
<span class="fc" id="L2459">            return (Callable)result;</span>
        }

        // name will call storeScriptable(cx, thisObj);
<span class="fc" id="L2463">        return (Callable)nameOrFunction(cx, scope, parent, name, true);</span>
    }

    /**
     * Prepare for calling obj[id](...): return function corresponding to
     * obj[id] and make obj properly converted to Scriptable available
     * as ScriptRuntime.lastStoredScriptable() for consumption as thisObj.
     * The caller must call ScriptRuntime.lastStoredScriptable() immediately
     * after calling this method.
     *
     * @deprecated Use {@link #getElemFunctionAndThis(Object, Object, Context, Scriptable)} instead
     */
    @Deprecated
    public static Callable getElemFunctionAndThis(Object obj,
                                                  Object elem,
                                                  Context cx)
    {
<span class="nc" id="L2480">        return getElemFunctionAndThis(obj, elem, cx, getTopCallScope(cx));</span>
    }

    /**
     * Prepare for calling obj[id](...): return function corresponding to
     * obj[id] and make obj properly converted to Scriptable available
     * as ScriptRuntime.lastStoredScriptable() for consumption as thisObj.
     * The caller must call ScriptRuntime.lastStoredScriptable() immediately
     * after calling this method.
     */
    public static Callable getElemFunctionAndThis(Object obj, Object elem,
                                                  Context cx, Scriptable scope)
    {
        Scriptable thisObj;
        Object value;

<span class="nc bnc" id="L2496" title="All 2 branches missed.">        if (isSymbol(elem)) {</span>
<span class="nc" id="L2497">            thisObj = toObjectOrNull(cx, obj, scope);</span>
<span class="nc bnc" id="L2498" title="All 2 branches missed.">            if (thisObj == null) {</span>
<span class="nc" id="L2499">                throw undefCallError(obj, String.valueOf(elem));</span>
            }
<span class="nc" id="L2501">            value = ScriptableObject.getProperty(thisObj, (Symbol)elem);</span>

        } else {
<span class="nc" id="L2504">            String str = toStringIdOrIndex(cx, elem);</span>
<span class="nc bnc" id="L2505" title="All 2 branches missed.">            if (str != null) {</span>
<span class="nc" id="L2506">                return getPropFunctionAndThis(obj, str, cx, scope);</span>
            }
<span class="nc" id="L2508">            int index = lastIndexResult(cx);</span>

<span class="nc" id="L2510">            thisObj = toObjectOrNull(cx, obj, scope);</span>
<span class="nc bnc" id="L2511" title="All 2 branches missed.">            if (thisObj == null) {</span>
<span class="nc" id="L2512">                throw undefCallError(obj, String.valueOf(elem));</span>
            }

<span class="nc" id="L2515">            value = ScriptableObject.getProperty(thisObj, index);</span>
        }

<span class="nc bnc" id="L2518" title="All 2 branches missed.">        if (!(value instanceof Callable)) {</span>
<span class="nc" id="L2519">            throw notFunctionError(value, elem);</span>
        }

<span class="nc" id="L2522">        storeScriptable(cx, thisObj);</span>
<span class="nc" id="L2523">        return (Callable)value;</span>
    }

    /**
     * Prepare for calling obj.property(...): return function corresponding to
     * obj.property and make obj properly converted to Scriptable available
     * as ScriptRuntime.lastStoredScriptable() for consumption as thisObj.
     * The caller must call ScriptRuntime.lastStoredScriptable() immediately
     * after calling this method.
     * Warning: this doesn't allow to resolve primitive prototype properly when
     * many top scopes are involved.
     *
     * @deprecated Use {@link #getPropFunctionAndThis(Object, String, Context, Scriptable)} instead
     */
    @Deprecated
    public static Callable getPropFunctionAndThis(Object obj,
                                                  String property,
                                                  Context cx)
    {
<span class="nc" id="L2542">        return getPropFunctionAndThis(obj, property, cx, getTopCallScope(cx));</span>
    }

    /**
     * Prepare for calling obj.property(...): return function corresponding to
     * obj.property and make obj properly converted to Scriptable available
     * as ScriptRuntime.lastStoredScriptable() for consumption as thisObj.
     * The caller must call ScriptRuntime.lastStoredScriptable() immediately
     * after calling this method.
     */
    public static Callable getPropFunctionAndThis(Object obj,
                                                  String property,
                                                  Context cx, Scriptable scope)
    {
<span class="fc" id="L2556">        Scriptable thisObj = toObjectOrNull(cx, obj, scope);</span>
<span class="fc" id="L2557">        return getPropFunctionAndThisHelper(obj, property, cx, thisObj);</span>
    }

    private static Callable getPropFunctionAndThisHelper(Object obj,
          String property, Context cx, Scriptable thisObj)
    {
<span class="fc bfc" id="L2563" title="All 2 branches covered.">        if (thisObj == null) {</span>
<span class="fc" id="L2564">            throw undefCallError(obj, property);</span>
        }

<span class="fc" id="L2567">        Object value = ScriptableObject.getProperty(thisObj, property);</span>
<span class="fc bfc" id="L2568" title="All 2 branches covered.">        if (!(value instanceof Callable)) {</span>
<span class="fc" id="L2569">            Object noSuchMethod = ScriptableObject.getProperty(thisObj, &quot;__noSuchMethod__&quot;);</span>
<span class="pc bpc" id="L2570" title="1 of 2 branches missed.">            if (noSuchMethod instanceof Callable)</span>
<span class="nc" id="L2571">                value = new NoSuchMethodShim((Callable)noSuchMethod, property);</span>
        }

<span class="fc bfc" id="L2574" title="All 2 branches covered.">        if (!(value instanceof Callable)) {</span>
<span class="fc" id="L2575">            throw notFunctionError(thisObj, value, property);</span>
        }

<span class="fc" id="L2578">        storeScriptable(cx, thisObj);</span>
<span class="fc" id="L2579">        return (Callable)value;</span>
    }

    /**
     * Prepare for calling &lt;expression&gt;(...): return function corresponding to
     * &lt;expression&gt; and make parent scope of the function available
     * as ScriptRuntime.lastStoredScriptable() for consumption as thisObj.
     * The caller must call ScriptRuntime.lastStoredScriptable() immediately
     * after calling this method.
     */
    public static Callable getValueFunctionAndThis(Object value, Context cx)
    {
<span class="nc bnc" id="L2591" title="All 2 branches missed.">        if (!(value instanceof Callable)) {</span>
<span class="nc" id="L2592">            throw notFunctionError(value);</span>
        }

<span class="nc" id="L2595">        Callable f = (Callable)value;</span>
<span class="nc" id="L2596">        Scriptable thisObj = null;</span>
<span class="nc bnc" id="L2597" title="All 2 branches missed.">        if (f instanceof Scriptable) {</span>
<span class="nc" id="L2598">            thisObj = ((Scriptable)f).getParentScope();</span>
        }
<span class="nc bnc" id="L2600" title="All 2 branches missed.">        if (thisObj == null) {</span>
<span class="nc bnc" id="L2601" title="All 2 branches missed.">            if (cx.topCallScope == null) throw new IllegalStateException();</span>
<span class="nc" id="L2602">            thisObj = cx.topCallScope;</span>
        }
<span class="nc bnc" id="L2604" title="All 2 branches missed.">        if (thisObj.getParentScope() != null) {</span>
<span class="nc bnc" id="L2605" title="All 2 branches missed.">            if (thisObj instanceof NativeWith) {</span>
                // functions defined inside with should have with target
                // as their thisObj
<span class="nc bnc" id="L2608" title="All 2 branches missed.">            } else if (thisObj instanceof NativeCall) {</span>
                // nested functions should have top scope as their thisObj
<span class="nc" id="L2610">                thisObj = ScriptableObject.getTopLevelScope(thisObj);</span>
            }
        }
<span class="nc" id="L2613">        storeScriptable(cx, thisObj);</span>
<span class="nc" id="L2614">        return f;</span>
    }

    /**
     * Perform function call in reference context. Should always
     * return value that can be passed to
     * {@link #refGet(Ref, Context)} or {@link #refSet(Ref, Object, Context)}
     * arbitrary number of times.
     * The args array reference should not be stored in any object that is
     * can be GC-reachable after this method returns. If this is necessary,
     * store args.clone(), not args array itself.
     */
    public static Ref callRef(Callable function, Scriptable thisObj,
                              Object[] args, Context cx)
    {
<span class="nc bnc" id="L2629" title="All 2 branches missed.">        if (function instanceof RefCallable) {</span>
<span class="nc" id="L2630">            RefCallable rfunction = (RefCallable)function;</span>
<span class="nc" id="L2631">            Ref ref = rfunction.refCall(cx, thisObj, args);</span>
<span class="nc bnc" id="L2632" title="All 2 branches missed.">            if (ref == null) {</span>
<span class="nc" id="L2633">                throw new IllegalStateException(rfunction.getClass().getName()+&quot;.refCall() returned null&quot;);</span>
            }
<span class="nc" id="L2635">            return ref;</span>
        }
        // No runtime support for now
<span class="nc" id="L2638">        String msg = getMessage1(&quot;msg.no.ref.from.function&quot;,</span>
<span class="nc" id="L2639">                                 toString(function));</span>
<span class="nc" id="L2640">        throw constructError(&quot;ReferenceError&quot;, msg);</span>
    }

    /**
     * Operator new.
     *
     * See ECMA 11.2.2
     */
    public static Scriptable newObject(Object fun, Context cx,
                                       Scriptable scope, Object[] args)
    {
<span class="nc bnc" id="L2651" title="All 2 branches missed.">        if (!(fun instanceof Function)) {</span>
<span class="nc" id="L2652">            throw notFunctionError(fun);</span>
        }
<span class="nc" id="L2654">        Function function = (Function)fun;</span>
<span class="nc" id="L2655">        return function.construct(cx, scope, args);</span>
    }

    public static Object callSpecial(Context cx, Callable fun,
                                     Scriptable thisObj,
                                     Object[] args, Scriptable scope,
                                     Scriptable callerThis, int callType,
                                     String filename, int lineNumber)
    {
<span class="pc bpc" id="L2664" title="1 of 2 branches missed.">        if (callType == Node.SPECIALCALL_EVAL) {</span>
<span class="pc bpc" id="L2665" title="2 of 4 branches missed.">            if (thisObj.getParentScope() == null &amp;&amp; NativeGlobal.isEvalFunction(fun)) {</span>
<span class="fc" id="L2666">                return evalSpecial(cx, scope, callerThis, args,</span>
                                   filename, lineNumber);
            }
<span class="nc bnc" id="L2669" title="All 2 branches missed.">        } else if (callType == Node.SPECIALCALL_WITH) {</span>
<span class="nc bnc" id="L2670" title="All 2 branches missed.">            if (NativeWith.isWithFunction(fun)) {</span>
<span class="nc" id="L2671">                throw Context.reportRuntimeError1(&quot;msg.only.from.new&quot;,</span>
                                                  &quot;With&quot;);
            }
        } else {
<span class="nc" id="L2675">            throw Kit.codeBug();</span>
        }

<span class="nc" id="L2678">        return fun.call(cx, scope, thisObj, args);</span>
    }

    public static Object newSpecial(Context cx, Object fun,
                                    Object[] args, Scriptable scope,
                                    int callType)
    {
<span class="nc bnc" id="L2685" title="All 2 branches missed.">        if (callType == Node.SPECIALCALL_EVAL) {</span>
<span class="nc bnc" id="L2686" title="All 2 branches missed.">            if (NativeGlobal.isEvalFunction(fun)) {</span>
<span class="nc" id="L2687">                throw typeError1(&quot;msg.not.ctor&quot;, &quot;eval&quot;);</span>
            }
<span class="nc bnc" id="L2689" title="All 2 branches missed.">        } else if (callType == Node.SPECIALCALL_WITH) {</span>
<span class="nc bnc" id="L2690" title="All 2 branches missed.">            if (NativeWith.isWithFunction(fun)) {</span>
<span class="nc" id="L2691">                return NativeWith.newWithSpecial(cx, scope, args);</span>
            }
        } else {
<span class="nc" id="L2694">            throw Kit.codeBug();</span>
        }

<span class="nc" id="L2697">        return newObject(fun, cx, scope, args);</span>
    }

    /**
     * Function.prototype.apply and Function.prototype.call
     *
     * See Ecma 15.3.4.[34]
     */
    public static Object applyOrCall(boolean isApply,
                                     Context cx, Scriptable scope,
                                     Scriptable thisObj, Object[] args)
    {
<span class="nc" id="L2709">        int L = args.length;</span>
<span class="nc" id="L2710">        Callable function = getCallable(thisObj);</span>

<span class="nc" id="L2712">        Scriptable callThis = null;</span>
<span class="nc bnc" id="L2713" title="All 2 branches missed.">        if (L != 0) {</span>
<span class="nc bnc" id="L2714" title="All 2 branches missed.">            if  (cx.hasFeature(Context.FEATURE_OLD_UNDEF_NULL_THIS)) {</span>
<span class="nc" id="L2715">                callThis = toObjectOrNull(cx, args[0], scope);</span>
            } else {
<span class="nc bnc" id="L2717" title="All 2 branches missed.">                callThis = args[0] == Undefined.instance ? Undefined.SCRIPTABLE_UNDEFINED : toObjectOrNull(cx, args[0], scope);</span>
            }
        }
<span class="nc bnc" id="L2720" title="All 4 branches missed.">        if (callThis == null &amp;&amp; cx.hasFeature(Context.FEATURE_OLD_UNDEF_NULL_THIS)) {</span>
<span class="nc" id="L2721">            callThis = getTopCallScope(cx); // This covers the case of args[0] == (null|undefined) as well.</span>
        }

        Object[] callArgs;
<span class="nc bnc" id="L2725" title="All 2 branches missed.">        if (isApply) {</span>
            // Follow Ecma 15.3.4.3
<span class="nc bnc" id="L2727" title="All 2 branches missed.">            callArgs = L &lt;= 1 ? ScriptRuntime.emptyArgs :</span>
<span class="nc" id="L2728">                getApplyArguments(cx, args[1]);</span>
        } else {
            // Follow Ecma 15.3.4.4
<span class="nc bnc" id="L2731" title="All 2 branches missed.">            if (L &lt;= 1) {</span>
<span class="nc" id="L2732">                callArgs = ScriptRuntime.emptyArgs;</span>
            } else {
<span class="nc" id="L2734">                callArgs = new Object[L - 1];</span>
<span class="nc" id="L2735">                System.arraycopy(args, 1, callArgs, 0, L - 1);</span>
            }
        }

<span class="nc" id="L2739">        return function.call(cx, scope, callThis, callArgs);</span>
    }
    
    /**
      * @return true if the passed in Scriptable looks like an array
      */
    private static boolean isArrayLike(Scriptable obj)
    {
<span class="nc bnc" id="L2747" title="All 6 branches missed.">        return obj != null &amp;&amp; (</span>
            obj instanceof NativeArray ||
            obj instanceof Arguments ||
<span class="nc bnc" id="L2750" title="All 2 branches missed.">            ScriptableObject.hasProperty(obj, &quot;length&quot;)</span>
        );
    }

    static Object[] getApplyArguments(Context cx, Object arg1)
    {
<span class="nc bnc" id="L2756" title="All 4 branches missed.">        if (arg1 == null || arg1 == Undefined.instance) {</span>
<span class="nc" id="L2757">            return ScriptRuntime.emptyArgs;</span>
<span class="nc bnc" id="L2758" title="All 4 branches missed.">        } else if ( arg1 instanceof Scriptable &amp;&amp; isArrayLike((Scriptable) arg1) ) {</span>
<span class="nc" id="L2759">            return cx.getElements((Scriptable) arg1);</span>
<span class="nc bnc" id="L2760" title="All 2 branches missed.">        } else if( arg1 instanceof ScriptableObject ) {</span>
<span class="nc" id="L2761">            return ScriptRuntime.emptyArgs;</span>
        } else {
<span class="nc" id="L2763">            throw ScriptRuntime.typeError0(&quot;msg.arg.isnt.array&quot;);</span>
        }
    }

    static Callable getCallable(Scriptable thisObj)
    {
        Callable function;
<span class="nc bnc" id="L2770" title="All 2 branches missed.">        if (thisObj instanceof Callable) {</span>
<span class="nc" id="L2771">            function = (Callable)thisObj;</span>
        } else {
<span class="nc" id="L2773">            Object value = thisObj.getDefaultValue(ScriptRuntime.FunctionClass);</span>
<span class="nc bnc" id="L2774" title="All 2 branches missed.">            if (!(value instanceof Callable)) {</span>
<span class="nc" id="L2775">                throw ScriptRuntime.notFunctionError(value, thisObj);</span>
            }
<span class="nc" id="L2777">            function = (Callable)value;</span>
        }
<span class="nc" id="L2779">        return function;</span>
    }

    /**
     * The eval function property of the global object.
     *
     * See ECMA 15.1.2.1
     */
    public static Object evalSpecial(Context cx, Scriptable scope,
                                     Object thisArg, Object[] args,
                                     String filename, int lineNumber)
    {
<span class="pc bpc" id="L2791" title="1 of 2 branches missed.">        if (args.length &lt; 1)</span>
<span class="nc" id="L2792">            return Undefined.instance;</span>
<span class="fc" id="L2793">        Object x = args[0];</span>
<span class="pc bpc" id="L2794" title="1 of 2 branches missed.">        if (!(x instanceof CharSequence)) {</span>
<span class="pc bpc" id="L2795" title="1 of 2 branches missed.">            if (cx.hasFeature(Context.FEATURE_STRICT_MODE) ||</span>
<span class="pc bpc" id="L2796" title="1 of 2 branches missed.">                cx.hasFeature(Context.FEATURE_STRICT_EVAL))</span>
            {
<span class="nc" id="L2798">                throw Context.reportRuntimeError0(&quot;msg.eval.nonstring.strict&quot;);</span>
            }
<span class="fc" id="L2800">            String message = ScriptRuntime.getMessage0(&quot;msg.eval.nonstring&quot;);</span>
<span class="fc" id="L2801">            Context.reportWarning(message);</span>
<span class="fc" id="L2802">            return x;</span>
        }
<span class="nc bnc" id="L2804" title="All 2 branches missed.">        if (filename == null) {</span>
<span class="nc" id="L2805">            int[] linep = new int[1];</span>
<span class="nc" id="L2806">            filename = Context.getSourcePositionFromStack(linep);</span>
<span class="nc bnc" id="L2807" title="All 2 branches missed.">            if (filename != null) {</span>
<span class="nc" id="L2808">                lineNumber = linep[0];</span>
            } else {
<span class="nc" id="L2810">                filename = &quot;&quot;;</span>
            }
        }
<span class="nc" id="L2813">        String sourceName = ScriptRuntime.</span>
<span class="nc" id="L2814">            makeUrlForGeneratedScript(true, filename, lineNumber);</span>

        ErrorReporter reporter;
<span class="nc" id="L2817">        reporter = DefaultErrorReporter.forEval(cx.getErrorReporter());</span>

<span class="nc" id="L2819">        Evaluator evaluator = Context.createInterpreter();</span>
<span class="nc bnc" id="L2820" title="All 2 branches missed.">        if (evaluator == null) {</span>
<span class="nc" id="L2821">            throw new JavaScriptException(&quot;Interpreter not present&quot;,</span>
                    filename, lineNumber);
        }

        // Compile with explicit interpreter instance to force interpreter
        // mode.
<span class="nc" id="L2827">        Script script = cx.compileString(x.toString(), evaluator,</span>
                                         reporter, sourceName, 1, null);
<span class="nc" id="L2829">        evaluator.setEvalScriptFlag(script);</span>
<span class="nc" id="L2830">        Callable c = (Callable)script;</span>
<span class="nc" id="L2831">        return c.call(cx, scope, (Scriptable)thisArg, ScriptRuntime.emptyArgs);</span>
    }

    /**
     * The typeof operator
     */
    public static String typeof(Object value)
    {
<span class="fc bfc" id="L2839" title="All 2 branches covered.">        if (value == null)</span>
<span class="fc" id="L2840">            return &quot;object&quot;;</span>
<span class="fc bfc" id="L2841" title="All 2 branches covered.">        if (value == Undefined.instance)</span>
<span class="fc" id="L2842">            return &quot;undefined&quot;;</span>
<span class="fc bfc" id="L2843" title="All 2 branches covered.">        if (value instanceof ScriptableObject)</span>
<span class="fc" id="L2844">            return ((ScriptableObject) value).getTypeOf();</span>
<span class="pc bpc" id="L2845" title="1 of 2 branches missed.">        if (value instanceof Scriptable)</span>
<span class="nc bnc" id="L2846" title="All 2 branches missed.">            return (value instanceof Callable) ? &quot;function&quot; : &quot;object&quot;;</span>
<span class="fc bfc" id="L2847" title="All 2 branches covered.">        if (value instanceof CharSequence)</span>
<span class="fc" id="L2848">            return &quot;string&quot;;</span>
<span class="fc bfc" id="L2849" title="All 2 branches covered.">        if (value instanceof Number)</span>
<span class="fc" id="L2850">            return &quot;number&quot;;</span>
<span class="pc bpc" id="L2851" title="1 of 2 branches missed.">        if (value instanceof Boolean)</span>
<span class="fc" id="L2852">            return &quot;boolean&quot;;</span>
<span class="nc" id="L2853">        throw errorWithClassName(&quot;msg.invalid.type&quot;, value);</span>
    }

    /**
     * The typeof operator that correctly handles the undefined case
     */
    public static String typeofName(Scriptable scope, String id)
    {
<span class="fc" id="L2861">        Context cx = Context.getContext();</span>
<span class="fc" id="L2862">        Scriptable val = bind(cx, scope, id);</span>
<span class="fc bfc" id="L2863" title="All 2 branches covered.">        if (val == null)</span>
<span class="fc" id="L2864">            return &quot;undefined&quot;;</span>
<span class="fc" id="L2865">        return typeof(getObjectProp(val, id, cx));</span>
    }

    // neg:
    // implement the '-' operator inline in the caller
    // as &quot;-toNumber(val)&quot;

    // not:
    // implement the '!' operator inline in the caller
    // as &quot;!toBoolean(val)&quot;

    // bitnot:
    // implement the '~' operator inline in the caller
    // as &quot;~toInt32(val)&quot;

    public static Object add(Object val1, Object val2, Context cx)
    {
<span class="pc bpc" id="L2882" title="3 of 4 branches missed.">        if(val1 instanceof Number &amp;&amp; val2 instanceof Number) {</span>
<span class="nc" id="L2883">            return wrapNumber(((Number)val1).doubleValue() +</span>
<span class="nc" id="L2884">                              ((Number)val2).doubleValue());</span>
        }
<span class="pc bpc" id="L2886" title="1 of 2 branches missed.">        if (val1 instanceof XMLObject) {</span>
<span class="nc" id="L2887">            Object test = ((XMLObject)val1).addValues(cx, true, val2);</span>
<span class="nc bnc" id="L2888" title="All 2 branches missed.">            if (test != Scriptable.NOT_FOUND) {</span>
<span class="nc" id="L2889">                return test;</span>
            }
        }
<span class="pc bpc" id="L2892" title="1 of 2 branches missed.">        if (val2 instanceof XMLObject) {</span>
<span class="nc" id="L2893">            Object test = ((XMLObject)val2).addValues(cx, false, val1);</span>
<span class="nc bnc" id="L2894" title="All 2 branches missed.">            if (test != Scriptable.NOT_FOUND) {</span>
<span class="nc" id="L2895">                return test;</span>
            }
        }
<span class="pc bpc" id="L2898" title="2 of 4 branches missed.">        if ((val1 instanceof Symbol) || (val2 instanceof Symbol)) {</span>
<span class="nc" id="L2899">            throw typeError0(&quot;msg.not.a.number&quot;);</span>
        }
<span class="pc bpc" id="L2901" title="1 of 2 branches missed.">        if (val1 instanceof Scriptable)</span>
<span class="fc" id="L2902">            val1 = ((Scriptable) val1).getDefaultValue(null);</span>
<span class="pc bpc" id="L2903" title="1 of 2 branches missed.">        if (val2 instanceof Scriptable)</span>
<span class="nc" id="L2904">            val2 = ((Scriptable) val2).getDefaultValue(null);</span>
<span class="pc bpc" id="L2905" title="3 of 4 branches missed.">        if (!(val1 instanceof CharSequence) &amp;&amp; !(val2 instanceof CharSequence))</span>
<span class="nc bnc" id="L2906" title="All 4 branches missed.">            if ((val1 instanceof Number) &amp;&amp; (val2 instanceof Number))</span>
<span class="nc" id="L2907">                return wrapNumber(((Number)val1).doubleValue() +</span>
<span class="nc" id="L2908">                                  ((Number)val2).doubleValue());</span>
            else
<span class="nc" id="L2910">                return wrapNumber(toNumber(val1) + toNumber(val2));</span>
<span class="fc" id="L2911">        return new ConsString(toCharSequence(val1), toCharSequence(val2));</span>
    }

    public static CharSequence add(CharSequence val1, Object val2) {
<span class="nc" id="L2915">        return new ConsString(val1, toCharSequence(val2));</span>
    }

    public static CharSequence add(Object val1, CharSequence val2) {
<span class="nc" id="L2919">        return new ConsString(toCharSequence(val1), val2);</span>
    }

    /**
     * The method is only present for compatibility.
     *
     * @deprecated Use {@link #nameIncrDecr(Scriptable, String, Context, int)} instead
     */
    @Deprecated
    public static Object nameIncrDecr(Scriptable scopeChain, String id,
                                      int incrDecrMask)
    {
<span class="nc" id="L2931">        return nameIncrDecr(scopeChain, id, Context.getContext(), incrDecrMask);</span>
    }

    public static Object nameIncrDecr(Scriptable scopeChain, String id,
                                      Context cx, int incrDecrMask)
    {
        Scriptable target;
        Object value;
      search: {
            do {
<span class="pc bpc" id="L2941" title="3 of 4 branches missed.">                if (cx.useDynamicScope &amp;&amp; scopeChain.getParentScope() == null) {</span>
<span class="nc" id="L2942">                    scopeChain = checkDynamicScope(cx.topCallScope, scopeChain);</span>
                }
<span class="fc" id="L2944">                target = scopeChain;</span>
                do {
<span class="pc bpc" id="L2946" title="1 of 2 branches missed.">                    if (target instanceof NativeWith &amp;&amp;</span>
<span class="nc bnc" id="L2947" title="All 2 branches missed.">                            target.getPrototype() instanceof XMLObject) {</span>
<span class="nc" id="L2948">                        break;</span>
                    }
<span class="fc" id="L2950">                    value = target.get(id, scopeChain);</span>
<span class="fc bfc" id="L2951" title="All 2 branches covered.">                    if (value != Scriptable.NOT_FOUND) {</span>
<span class="fc" id="L2952">                        break search;</span>
                    }
<span class="fc" id="L2954">                    target = target.getPrototype();</span>
<span class="pc bpc" id="L2955" title="1 of 2 branches missed.">                } while (target != null);</span>
<span class="fc" id="L2956">                scopeChain = scopeChain.getParentScope();</span>
<span class="pc bpc" id="L2957" title="1 of 2 branches missed.">            } while (scopeChain != null);</span>
<span class="nc" id="L2958">            throw notFoundError(scopeChain, id);</span>
        }
<span class="fc" id="L2960">        return doScriptableIncrDecr(target, id, scopeChain, value,</span>
                                    incrDecrMask);
    }

    /**
     * @deprecated Use {@link #propIncrDecr(Object, String, Context, Scriptable, int)} instead
     */
    @Deprecated
    public static Object propIncrDecr(Object obj, String id,
                                      Context cx, int incrDecrMask)
    {
<span class="nc" id="L2971">        return propIncrDecr(obj, id, cx, getTopCallScope(cx), incrDecrMask);</span>
    }

    public static Object propIncrDecr(Object obj, String id,
                                      Context cx, Scriptable scope,
                                      int incrDecrMask)
    {
<span class="nc" id="L2978">        Scriptable start = toObjectOrNull(cx, obj, scope);</span>
<span class="nc bnc" id="L2979" title="All 2 branches missed.">        if (start == null) {</span>
<span class="nc" id="L2980">            throw undefReadError(obj, id);</span>
        }

<span class="nc" id="L2983">        Scriptable target = start;</span>
        Object value;
      search: {
            do {
<span class="nc" id="L2987">                value = target.get(id, start);</span>
<span class="nc bnc" id="L2988" title="All 2 branches missed.">                if (value != Scriptable.NOT_FOUND) {</span>
<span class="nc" id="L2989">                    break search;</span>
                }
<span class="nc" id="L2991">                target = target.getPrototype();</span>
<span class="nc bnc" id="L2992" title="All 2 branches missed.">            } while (target != null);</span>
<span class="nc" id="L2993">            start.put(id, start, NaNobj);</span>
<span class="nc" id="L2994">            return NaNobj;</span>
        }
<span class="nc" id="L2996">        return doScriptableIncrDecr(target, id, start, value,</span>
                                    incrDecrMask);
    }

    private static Object doScriptableIncrDecr(Scriptable target,
                                               String id,
                                               Scriptable protoChainStart,
                                               Object value,
                                               int incrDecrMask)
    {
<span class="pc bpc" id="L3006" title="1 of 2 branches missed.">        boolean post = ((incrDecrMask &amp; Node.POST_FLAG) != 0);</span>
        double number;
<span class="pc bpc" id="L3008" title="1 of 2 branches missed.">        if (value instanceof Number) {</span>
<span class="fc" id="L3009">            number = ((Number)value).doubleValue();</span>
        } else {
<span class="nc" id="L3011">            number = toNumber(value);</span>
<span class="nc bnc" id="L3012" title="All 2 branches missed.">            if (post) {</span>
                // convert result to number
<span class="nc" id="L3014">                value = wrapNumber(number);</span>
            }
        }
<span class="pc bpc" id="L3017" title="1 of 2 branches missed.">        if ((incrDecrMask &amp; Node.DECR_FLAG) == 0) {</span>
<span class="fc" id="L3018">            ++number;</span>
        } else {
<span class="nc" id="L3020">            --number;</span>
        }
<span class="fc" id="L3022">        Number result = wrapNumber(number);</span>
<span class="fc" id="L3023">        target.put(id, protoChainStart, result);</span>
<span class="pc bpc" id="L3024" title="1 of 2 branches missed.">        if (post) {</span>
<span class="fc" id="L3025">            return value;</span>
        } else {
<span class="nc" id="L3027">            return result;</span>
        }
    }

    /**
     * @deprecated Use {@link #elemIncrDecr(Object, Object, Context, Scriptable, int)} instead
     */
    @Deprecated
    public static Object elemIncrDecr(Object obj, Object index,
                                      Context cx, int incrDecrMask)
    {
<span class="nc" id="L3038">        return elemIncrDecr(obj, index, cx, getTopCallScope(cx), incrDecrMask);</span>
    }

    public static Object elemIncrDecr(Object obj, Object index,
                                      Context cx, Scriptable scope,
                                      int incrDecrMask)
    {
<span class="nc" id="L3045">        Object value = getObjectElem(obj, index, cx, scope);</span>
<span class="nc bnc" id="L3046" title="All 2 branches missed.">        boolean post = ((incrDecrMask &amp; Node.POST_FLAG) != 0);</span>
        double number;
<span class="nc bnc" id="L3048" title="All 2 branches missed.">        if (value instanceof Number) {</span>
<span class="nc" id="L3049">            number = ((Number)value).doubleValue();</span>
        } else {
<span class="nc" id="L3051">            number = toNumber(value);</span>
<span class="nc bnc" id="L3052" title="All 2 branches missed.">            if (post) {</span>
                // convert result to number
<span class="nc" id="L3054">                value = wrapNumber(number);</span>
            }
        }
<span class="nc bnc" id="L3057" title="All 2 branches missed.">        if ((incrDecrMask &amp; Node.DECR_FLAG) == 0) {</span>
<span class="nc" id="L3058">            ++number;</span>
        } else {
<span class="nc" id="L3060">            --number;</span>
        }
<span class="nc" id="L3062">        Number result = wrapNumber(number);</span>
<span class="nc" id="L3063">        setObjectElem(obj, index, result, cx, scope);</span>
<span class="nc bnc" id="L3064" title="All 2 branches missed.">        if (post) {</span>
<span class="nc" id="L3065">            return value;</span>
        } else {
<span class="nc" id="L3067">            return result;</span>
        }
    }

    /**
     * @deprecated Use {@link #refIncrDecr(Ref, Context, Scriptable, int)} instead
     */
    @Deprecated
    public static Object refIncrDecr(Ref ref, Context cx, int incrDecrMask)
    {
<span class="nc" id="L3077">        return refIncrDecr(ref, cx, getTopCallScope(cx), incrDecrMask);</span>
    }

    public static Object refIncrDecr(Ref ref, Context cx, Scriptable scope,
                                     int incrDecrMask)
    {
<span class="nc" id="L3083">        Object value = ref.get(cx);</span>
<span class="nc bnc" id="L3084" title="All 2 branches missed.">        boolean post = ((incrDecrMask &amp; Node.POST_FLAG) != 0);</span>
        double number;
<span class="nc bnc" id="L3086" title="All 2 branches missed.">        if (value instanceof Number) {</span>
<span class="nc" id="L3087">            number = ((Number)value).doubleValue();</span>
        } else {
<span class="nc" id="L3089">            number = toNumber(value);</span>
<span class="nc bnc" id="L3090" title="All 2 branches missed.">            if (post) {</span>
                // convert result to number
<span class="nc" id="L3092">                value = wrapNumber(number);</span>
            }
        }
<span class="nc bnc" id="L3095" title="All 2 branches missed.">        if ((incrDecrMask &amp; Node.DECR_FLAG) == 0) {</span>
<span class="nc" id="L3096">            ++number;</span>
        } else {
<span class="nc" id="L3098">            --number;</span>
        }
<span class="nc" id="L3100">        Number result = wrapNumber(number);</span>
<span class="nc" id="L3101">        ref.set(cx, scope, result);</span>
<span class="nc bnc" id="L3102" title="All 2 branches missed.">        if (post) {</span>
<span class="nc" id="L3103">            return value;</span>
        } else {
<span class="nc" id="L3105">            return result;</span>
        }
    }

    public static Object toPrimitive(Object val) {
<span class="nc" id="L3110">        return toPrimitive(val, null);</span>
    }

    public static Object toPrimitive(Object val, Class&lt;?&gt; typeHint)
    {
<span class="nc bnc" id="L3115" title="All 2 branches missed.">        if (!(val instanceof Scriptable)) {</span>
<span class="nc" id="L3116">            return val;</span>
        }
<span class="nc" id="L3118">        Scriptable s = (Scriptable)val;</span>
<span class="nc" id="L3119">        Object result = s.getDefaultValue(typeHint);</span>
<span class="nc bnc" id="L3120" title="All 4 branches missed.">        if ((result instanceof Scriptable) &amp;&amp; !isSymbol(result))</span>
<span class="nc" id="L3121">            throw typeError0(&quot;msg.bad.default.value&quot;);</span>
<span class="nc" id="L3122">        return result;</span>
    }

    /**
     * Equality
     *
     * See ECMA 11.9
     */
    public static boolean eq(Object x, Object y)
    {
<span class="fc bfc" id="L3132" title="All 4 branches covered.">        if (x == null || x == Undefined.instance) {</span>
<span class="pc bpc" id="L3133" title="1 of 4 branches missed.">            if (y == null || y == Undefined.instance) {</span>
<span class="fc" id="L3134">                return true;</span>
            }
<span class="pc bpc" id="L3136" title="1 of 2 branches missed.">            if (y instanceof ScriptableObject) {</span>
<span class="nc" id="L3137">                Object test = ((ScriptableObject)y).equivalentValues(x);</span>
<span class="nc bnc" id="L3138" title="All 2 branches missed.">                if (test != Scriptable.NOT_FOUND) {</span>
<span class="nc" id="L3139">                    return ((Boolean)test).booleanValue();</span>
                }
            }
<span class="fc" id="L3142">            return false;</span>
<span class="fc bfc" id="L3143" title="All 2 branches covered.">        } else if (x instanceof Number) {</span>
<span class="fc" id="L3144">            return eqNumber(((Number)x).doubleValue(), y);</span>
<span class="fc bfc" id="L3145" title="All 2 branches covered.">        } else if (x == y) {</span>
<span class="fc" id="L3146">            return true;</span>
<span class="fc bfc" id="L3147" title="All 2 branches covered.">        } else if (x instanceof CharSequence) {</span>
<span class="fc" id="L3148">            return eqString((CharSequence)x, y);</span>
<span class="fc bfc" id="L3149" title="All 2 branches covered.">        } else if (x instanceof Boolean) {</span>
<span class="fc" id="L3150">            boolean b = ((Boolean)x).booleanValue();</span>
<span class="fc bfc" id="L3151" title="All 2 branches covered.">            if (y instanceof Boolean) {</span>
<span class="pc bpc" id="L3152" title="1 of 2 branches missed.">                return b == ((Boolean)y).booleanValue();</span>
            }
<span class="pc bpc" id="L3154" title="1 of 2 branches missed.">            if (y instanceof ScriptableObject) {</span>
<span class="nc" id="L3155">                Object test = ((ScriptableObject)y).equivalentValues(x);</span>
<span class="nc bnc" id="L3156" title="All 2 branches missed.">                if (test != Scriptable.NOT_FOUND) {</span>
<span class="nc" id="L3157">                    return ((Boolean)test).booleanValue();</span>
                }
            }
<span class="fc bfc" id="L3160" title="All 2 branches covered.">            return eqNumber(b ? 1.0 : 0.0, y);</span>
<span class="pc bpc" id="L3161" title="1 of 2 branches missed.">        } else if (x instanceof Scriptable) {</span>
<span class="pc bpc" id="L3162" title="1 of 2 branches missed.">            if (y instanceof Scriptable) {</span>
<span class="nc bnc" id="L3163" title="All 2 branches missed.">                if (x instanceof ScriptableObject) {</span>
<span class="nc" id="L3164">                    Object test = ((ScriptableObject)x).equivalentValues(y);</span>
<span class="nc bnc" id="L3165" title="All 2 branches missed.">                    if (test != Scriptable.NOT_FOUND) {</span>
<span class="nc" id="L3166">                        return ((Boolean)test).booleanValue();</span>
                    }
                }
<span class="nc bnc" id="L3169" title="All 2 branches missed.">                if (y instanceof ScriptableObject) {</span>
<span class="nc" id="L3170">                    Object test = ((ScriptableObject)y).equivalentValues(x);</span>
<span class="nc bnc" id="L3171" title="All 2 branches missed.">                    if (test != Scriptable.NOT_FOUND) {</span>
<span class="nc" id="L3172">                        return ((Boolean)test).booleanValue();</span>
                    }
                }
<span class="nc bnc" id="L3175" title="All 4 branches missed.">                if (x instanceof Wrapper &amp;&amp; y instanceof Wrapper) {</span>
                    // See bug 413838. Effectively an extension to ECMA for
                    // the LiveConnect case.
<span class="nc" id="L3178">                    Object unwrappedX = ((Wrapper)x).unwrap();</span>
<span class="nc" id="L3179">                    Object unwrappedY = ((Wrapper)y).unwrap();</span>
<span class="nc bnc" id="L3180" title="All 2 branches missed.">                    return unwrappedX == unwrappedY ||</span>
<span class="nc bnc" id="L3181" title="All 2 branches missed.">                           (isPrimitive(unwrappedX) &amp;&amp;</span>
<span class="nc bnc" id="L3182" title="All 2 branches missed.">                            isPrimitive(unwrappedY) &amp;&amp;</span>
<span class="nc bnc" id="L3183" title="All 2 branches missed.">                            eq(unwrappedX, unwrappedY));</span>
                }
<span class="nc" id="L3185">                return false;</span>
<span class="pc bpc" id="L3186" title="1 of 2 branches missed.">            } else if (y instanceof Boolean) {</span>
<span class="nc bnc" id="L3187" title="All 2 branches missed.">                if (x instanceof ScriptableObject) {</span>
<span class="nc" id="L3188">                    Object test = ((ScriptableObject)x).equivalentValues(y);</span>
<span class="nc bnc" id="L3189" title="All 2 branches missed.">                    if (test != Scriptable.NOT_FOUND) {</span>
<span class="nc" id="L3190">                        return ((Boolean)test).booleanValue();</span>
                    }
                }
<span class="nc bnc" id="L3193" title="All 2 branches missed.">                double d = ((Boolean)y).booleanValue() ? 1.0 : 0.0;</span>
<span class="nc" id="L3194">                return eqNumber(d, x);</span>
<span class="pc bpc" id="L3195" title="1 of 2 branches missed.">            } else if (y instanceof Number) {</span>
<span class="nc" id="L3196">                return eqNumber(((Number)y).doubleValue(), x);</span>
<span class="pc bpc" id="L3197" title="1 of 2 branches missed.">            } else if (y instanceof CharSequence) {</span>
<span class="nc" id="L3198">                return eqString((CharSequence)y, x);</span>
            }
            // covers the case when y == Undefined.instance as well
<span class="fc" id="L3201">            return false;</span>
        } else {
<span class="nc" id="L3203">            warnAboutNonJSObject(x);</span>
<span class="nc bnc" id="L3204" title="All 2 branches missed.">            return x == y;</span>
        }
    }

    /*
     * Implement &quot;SameValue&quot; as in ECMA 7.2.9. This is not the same as &quot;eq&quot; because it handles
     * signed zeroes and NaNs differently.
     */
    public static boolean same(Object x, Object y) {
<span class="fc bfc" id="L3213" title="All 2 branches covered.">        if (!typeof(x).equals(typeof(y))) {</span>
<span class="fc" id="L3214">            return false;</span>
        }
<span class="pc bpc" id="L3216" title="1 of 2 branches missed.">        if (x instanceof Number) {</span>
<span class="pc bpc" id="L3217" title="1 of 4 branches missed.">            if (isNaN(x) &amp;&amp; isNaN(y)) {</span>
<span class="fc" id="L3218">                return true;</span>
            }
<span class="fc" id="L3220">            return x.equals(y);</span>
        }
<span class="nc" id="L3222">        return eq(x, y);</span>
    }

    public static boolean isNaN(Object n) {
<span class="fc bfc" id="L3226" title="All 2 branches covered.">        if (n == NaNobj) {</span>
<span class="fc" id="L3227">            return true;</span>
        }
<span class="pc bpc" id="L3229" title="1 of 2 branches missed.">        if (n instanceof Double) {</span>
<span class="fc" id="L3230">            Double d = (Double)n;</span>
<span class="pc bpc" id="L3231" title="2 of 4 branches missed.">            return ((d == NaN) || Double.isNaN(d));</span>
        }
<span class="nc bnc" id="L3233" title="All 2 branches missed.">        if (n instanceof Float) {</span>
<span class="nc" id="L3234">            Float f = (Float)n;</span>
<span class="nc bnc" id="L3235" title="All 4 branches missed.">            return ((f == NaN) || Float.isNaN(f));</span>
        }
<span class="nc" id="L3237">        return false;</span>
    }

    public static boolean isPrimitive(Object obj) {
<span class="nc bnc" id="L3241" title="All 10 branches missed.">        return obj == null || obj == Undefined.instance ||</span>
                (obj instanceof Number) || (obj instanceof String) ||
                (obj instanceof Boolean);
    }

    static boolean eqNumber(double x, Object y)
    {
        for (;;) {
<span class="fc bfc" id="L3249" title="All 4 branches covered.">            if (y == null || y == Undefined.instance) {</span>
<span class="fc" id="L3250">                return false;</span>
<span class="pc bpc" id="L3251" title="1 of 2 branches missed.">            } else if (y instanceof Number) {</span>
<span class="fc bfc" id="L3252" title="All 2 branches covered.">                return x == ((Number)y).doubleValue();</span>
<span class="nc bnc" id="L3253" title="All 2 branches missed.">            } else if (y instanceof CharSequence) {</span>
<span class="nc bnc" id="L3254" title="All 2 branches missed.">                return x == toNumber(y);</span>
<span class="nc bnc" id="L3255" title="All 2 branches missed.">            } else if (y instanceof Boolean) {</span>
<span class="nc bnc" id="L3256" title="All 4 branches missed.">                return x == (((Boolean) y).booleanValue() ? 1.0 : +0.0);</span>
<span class="nc bnc" id="L3257" title="All 2 branches missed.">            } else if (isSymbol(y)) {</span>
<span class="nc" id="L3258">                return false;</span>
<span class="nc bnc" id="L3259" title="All 2 branches missed.">            } else if (y instanceof Scriptable) {</span>
<span class="nc bnc" id="L3260" title="All 2 branches missed.">                if (y instanceof ScriptableObject) {</span>
<span class="nc" id="L3261">                    Object xval = wrapNumber(x);</span>
<span class="nc" id="L3262">                    Object test = ((ScriptableObject)y).equivalentValues(xval);</span>
<span class="nc bnc" id="L3263" title="All 2 branches missed.">                    if (test != Scriptable.NOT_FOUND) {</span>
<span class="nc" id="L3264">                        return ((Boolean)test).booleanValue();</span>
                    }
                }
<span class="nc" id="L3267">                y = toPrimitive(y);</span>
            } else {
<span class="nc" id="L3269">                warnAboutNonJSObject(y);</span>
<span class="nc" id="L3270">                return false;</span>
            }
        }
    }

    private static boolean eqString(CharSequence x, Object y)
    {
        for (;;) {
<span class="fc bfc" id="L3278" title="All 4 branches covered.">            if (y == null || y == Undefined.instance) {</span>
<span class="fc" id="L3279">                return false;</span>
<span class="pc bpc" id="L3280" title="1 of 2 branches missed.">            } else if (y instanceof CharSequence) {</span>
<span class="fc" id="L3281">                CharSequence c = (CharSequence)y;</span>
<span class="fc bfc" id="L3282" title="All 4 branches covered.">                return x.length() == c.length() &amp;&amp; x.toString().equals(c.toString());</span>
<span class="nc bnc" id="L3283" title="All 2 branches missed.">            } else if (y instanceof Number) {</span>
<span class="nc bnc" id="L3284" title="All 2 branches missed.">                return toNumber(x.toString()) == ((Number)y).doubleValue();</span>
<span class="nc bnc" id="L3285" title="All 2 branches missed.">            } else if (y instanceof Boolean) {</span>
<span class="nc bnc" id="L3286" title="All 4 branches missed.">                return toNumber(x.toString()) == (((Boolean) y).booleanValue() ? 1.0 : 0.0);</span>
<span class="nc bnc" id="L3287" title="All 2 branches missed.">            } else if (isSymbol(y)) {</span>
<span class="nc" id="L3288">                return false;</span>
<span class="nc bnc" id="L3289" title="All 2 branches missed.">            } else if (y instanceof Scriptable) {</span>
<span class="nc bnc" id="L3290" title="All 2 branches missed.">                if (y instanceof ScriptableObject) {</span>
<span class="nc" id="L3291">                    Object test = ((ScriptableObject)y).equivalentValues(x.toString());</span>
<span class="nc bnc" id="L3292" title="All 2 branches missed.">                    if (test != Scriptable.NOT_FOUND) {</span>
<span class="nc" id="L3293">                        return ((Boolean)test).booleanValue();</span>
                    }
                }
<span class="nc" id="L3296">                y = toPrimitive(y);</span>
<span class="nc" id="L3297">                continue;</span>
            } else {
<span class="nc" id="L3299">                warnAboutNonJSObject(y);</span>
<span class="nc" id="L3300">                return false;</span>
            }
        }
    }
    public static boolean shallowEq(Object x, Object y)
    {
<span class="fc bfc" id="L3306" title="All 2 branches covered.">        if (x == y) {</span>
<span class="fc bfc" id="L3307" title="All 2 branches covered.">            if (!(x instanceof Number)) {</span>
<span class="fc" id="L3308">                return true;</span>
            }
            // NaN check
<span class="fc" id="L3311">            double d = ((Number)x).doubleValue();</span>
<span class="pc bpc" id="L3312" title="1 of 2 branches missed.">            return d == d;</span>
        }
<span class="pc bpc" id="L3314" title="1 of 6 branches missed.">        if (x == null || x == Undefined.instance || x == Undefined.SCRIPTABLE_UNDEFINED) {</span>
<span class="pc bpc" id="L3315" title="4 of 8 branches missed.">            if ((x == Undefined.instance &amp;&amp; y == Undefined.SCRIPTABLE_UNDEFINED)</span>
<span class="nc" id="L3316">                || (x == Undefined.SCRIPTABLE_UNDEFINED &amp;&amp; y == Undefined.instance)) return true;</span>
<span class="fc" id="L3317">            return false;</span>
<span class="fc bfc" id="L3318" title="All 2 branches covered.">        } else if (x instanceof Number) {</span>
<span class="fc bfc" id="L3319" title="All 2 branches covered.">            if (y instanceof Number) {</span>
<span class="fc bfc" id="L3320" title="All 2 branches covered.">                return ((Number)x).doubleValue() == ((Number)y).doubleValue();</span>
            }
<span class="fc bfc" id="L3322" title="All 2 branches covered.">        } else if (x instanceof CharSequence) {</span>
<span class="fc bfc" id="L3323" title="All 2 branches covered.">            if (y instanceof CharSequence) {</span>
<span class="fc" id="L3324">                return x.toString().equals(y.toString());</span>
            }
<span class="fc bfc" id="L3326" title="All 2 branches covered.">        } else if (x instanceof Boolean) {</span>
<span class="fc bfc" id="L3327" title="All 2 branches covered.">            if (y instanceof Boolean) {</span>
<span class="fc" id="L3328">                return x.equals(y);</span>
            }
<span class="pc bpc" id="L3330" title="1 of 2 branches missed.">        } else if (x instanceof Scriptable) {</span>
<span class="pc bpc" id="L3331" title="3 of 4 branches missed.">            if (x instanceof Wrapper &amp;&amp; y instanceof Wrapper) {</span>
<span class="nc bnc" id="L3332" title="All 2 branches missed.">                return ((Wrapper)x).unwrap() == ((Wrapper)y).unwrap();</span>
            }
        } else {
<span class="nc" id="L3335">            warnAboutNonJSObject(x);</span>
<span class="nc bnc" id="L3336" title="All 2 branches missed.">            return x == y;</span>
        }
<span class="fc" id="L3338">        return false;</span>
    }

    /**
     * The instanceof operator.
     *
     * @return a instanceof b
     */
    public static boolean instanceOf(Object a, Object b, Context cx)
    {
        // Check RHS is an object
<span class="pc bpc" id="L3349" title="1 of 2 branches missed.">        if (! (b instanceof Scriptable)) {</span>
<span class="nc" id="L3350">            throw typeError0(&quot;msg.instanceof.not.object&quot;);</span>
        }

        // for primitive values on LHS, return false
<span class="fc bfc" id="L3354" title="All 2 branches covered.">        if (! (a instanceof Scriptable))</span>
<span class="fc" id="L3355">            return false;</span>

<span class="fc" id="L3357">        return ((Scriptable)b).hasInstance((Scriptable)a);</span>
    }

    /**
     * Delegates to
     *
     * @return true iff rhs appears in lhs' proto chain
     */
    public static boolean jsDelegatesTo(Scriptable lhs, Scriptable rhs) {
<span class="fc" id="L3366">        Scriptable proto = lhs.getPrototype();</span>

<span class="fc bfc" id="L3368" title="All 2 branches covered.">        while (proto != null) {</span>
<span class="fc bfc" id="L3369" title="All 2 branches covered.">            if (proto.equals(rhs)) return true;</span>
<span class="fc" id="L3370">            proto = proto.getPrototype();</span>
        }

<span class="fc" id="L3373">        return false;</span>
    }

    /**
     * The in operator.
     *
     * This is a new JS 1.3 language feature.  The in operator mirrors
     * the operation of the for .. in construct, and tests whether the
     * rhs has the property given by the lhs.  It is different from the
     * for .. in construct in that:
     * &lt;BR&gt; - it doesn't perform ToObject on the right hand side
     * &lt;BR&gt; - it returns true for DontEnum properties.
     * @param a the left hand operand
     * @param b the right hand operand
     *
     * @return true if property name or element number a is a property of b
     */
    public static boolean in(Object a, Object b, Context cx)
    {
<span class="nc bnc" id="L3392" title="All 2 branches missed.">        if (!(b instanceof Scriptable)) {</span>
<span class="nc" id="L3393">            throw typeError0(&quot;msg.in.not.object&quot;);</span>
        }

<span class="nc" id="L3396">        return hasObjectElem((Scriptable)b, a, cx);</span>
    }

    public static boolean cmp_LT(Object val1, Object val2)
    {
        double d1, d2;
<span class="pc bpc" id="L3402" title="2 of 4 branches missed.">        if (val1 instanceof Number &amp;&amp; val2 instanceof Number) {</span>
<span class="fc" id="L3403">            d1 = ((Number)val1).doubleValue();</span>
<span class="fc" id="L3404">            d2 = ((Number)val2).doubleValue();</span>
        } else {
<span class="nc bnc" id="L3406" title="All 4 branches missed.">            if ((val1 instanceof Symbol) || (val2 instanceof Symbol)) {</span>
<span class="nc" id="L3407">                throw typeError0(&quot;msg.compare.symbol&quot;);</span>
            }
<span class="nc bnc" id="L3409" title="All 2 branches missed.">            if (val1 instanceof Scriptable)</span>
<span class="nc" id="L3410">                val1 = ((Scriptable) val1).getDefaultValue(NumberClass);</span>
<span class="nc bnc" id="L3411" title="All 2 branches missed.">            if (val2 instanceof Scriptable)</span>
<span class="nc" id="L3412">                val2 = ((Scriptable) val2).getDefaultValue(NumberClass);</span>
<span class="nc bnc" id="L3413" title="All 4 branches missed.">            if (val1 instanceof CharSequence &amp;&amp; val2 instanceof CharSequence) {</span>
<span class="nc bnc" id="L3414" title="All 2 branches missed.">                return val1.toString().compareTo(val2.toString()) &lt; 0;</span>
            }
<span class="nc" id="L3416">            d1 = toNumber(val1);</span>
<span class="nc" id="L3417">            d2 = toNumber(val2);</span>
        }
<span class="fc bfc" id="L3419" title="All 2 branches covered.">        return d1 &lt; d2;</span>
    }

    public static boolean cmp_LE(Object val1, Object val2)
    {
        double d1, d2;
<span class="pc bpc" id="L3425" title="2 of 4 branches missed.">        if (val1 instanceof Number &amp;&amp; val2 instanceof Number) {</span>
<span class="fc" id="L3426">            d1 = ((Number)val1).doubleValue();</span>
<span class="fc" id="L3427">            d2 = ((Number)val2).doubleValue();</span>
        } else {
<span class="nc bnc" id="L3429" title="All 4 branches missed.">            if ((val1 instanceof Symbol) || (val2 instanceof Symbol)) {</span>
<span class="nc" id="L3430">                throw typeError0(&quot;msg.compare.symbol&quot;);</span>
            }
<span class="nc bnc" id="L3432" title="All 2 branches missed.">            if (val1 instanceof Scriptable)</span>
<span class="nc" id="L3433">                val1 = ((Scriptable) val1).getDefaultValue(NumberClass);</span>
<span class="nc bnc" id="L3434" title="All 2 branches missed.">            if (val2 instanceof Scriptable)</span>
<span class="nc" id="L3435">                val2 = ((Scriptable) val2).getDefaultValue(NumberClass);</span>
<span class="nc bnc" id="L3436" title="All 4 branches missed.">            if (val1 instanceof CharSequence &amp;&amp; val2 instanceof CharSequence) {</span>
<span class="nc bnc" id="L3437" title="All 2 branches missed.">                return val1.toString().compareTo(val2.toString()) &lt;= 0;</span>
            }
<span class="nc" id="L3439">            d1 = toNumber(val1);</span>
<span class="nc" id="L3440">            d2 = toNumber(val2);</span>
        }
<span class="fc bfc" id="L3442" title="All 2 branches covered.">        return d1 &lt;= d2;</span>
    }

    // ------------------
    // Statements
    // ------------------

    public static ScriptableObject getGlobal(Context cx) {
<span class="nc" id="L3450">        final String GLOBAL_CLASS = &quot;org.mozilla.javascript.tools.shell.Global&quot;;</span>
<span class="nc" id="L3451">        Class&lt;?&gt; globalClass = Kit.classOrNull(GLOBAL_CLASS);</span>
<span class="nc bnc" id="L3452" title="All 2 branches missed.">        if (globalClass != null) {</span>
            try {
<span class="nc" id="L3454">                Class&lt;?&gt;[] parm = { ScriptRuntime.ContextClass };</span>
<span class="nc" id="L3455">                Constructor&lt;?&gt; globalClassCtor = globalClass.getConstructor(parm);</span>
<span class="nc" id="L3456">                Object[] arg = { cx };</span>
<span class="nc" id="L3457">                return (ScriptableObject) globalClassCtor.newInstance(arg);</span>
            }
<span class="nc" id="L3459">            catch (RuntimeException e) {</span>
<span class="nc" id="L3460">                throw e;</span>
            }
<span class="nc" id="L3462">            catch (Exception e) {</span>
                // fall through...
            }
        }
<span class="nc" id="L3466">        return new ImporterTopLevel(cx);</span>
    }

    public static boolean hasTopCall(Context cx)
    {
<span class="fc bfc" id="L3471" title="All 2 branches covered.">        return (cx.topCallScope != null);</span>
    }

    public static Scriptable getTopCallScope(Context cx)
    {
<span class="fc" id="L3476">        Scriptable scope = cx.topCallScope;</span>
<span class="pc bpc" id="L3477" title="1 of 2 branches missed.">        if (scope == null) {</span>
<span class="fc" id="L3478">            throw new IllegalStateException();</span>
        }
<span class="nc" id="L3480">        return scope;</span>
    }

    /**
     * @deprecated Use {@link #doTopCall(Callable, Context, Scriptable, Scriptable, Object[], boolean)} instead
     */
    public static Object doTopCall(Callable callable,
                                   Context cx, Scriptable scope,
                                   Scriptable thisObj, Object[] args)
    {
<span class="nc" id="L3490">        return doTopCall(callable, cx, scope, thisObj, args, cx.isTopLevelStrict);</span>
    }

    public static Object doTopCall(Callable callable,
                                   Context cx, Scriptable scope,
                                   Scriptable thisObj, Object[] args, boolean isTopLevelStrict)
    {
<span class="pc bpc" id="L3497" title="1 of 2 branches missed.">        if (scope == null)</span>
<span class="nc" id="L3498">            throw new IllegalArgumentException();</span>
<span class="pc bpc" id="L3499" title="1 of 2 branches missed.">        if (cx.topCallScope != null) throw new IllegalStateException();</span>

        Object result;
<span class="fc" id="L3502">        cx.topCallScope = ScriptableObject.getTopLevelScope(scope);</span>
<span class="fc" id="L3503">        cx.useDynamicScope = cx.hasFeature(Context.FEATURE_DYNAMIC_SCOPE);</span>
<span class="fc" id="L3504">        boolean previousTopLevelStrict = cx.isTopLevelStrict;</span>
<span class="fc" id="L3505">        cx.isTopLevelStrict = isTopLevelStrict;</span>
<span class="fc" id="L3506">        ContextFactory f = cx.getFactory();</span>
        try {
<span class="fc" id="L3508">            result = f.doTopCall(callable, cx, scope, thisObj, args);</span>
        } finally {
<span class="fc" id="L3510">            cx.topCallScope = null;</span>
            // Cleanup cached references
<span class="fc" id="L3512">            cx.cachedXMLLib = null;</span>
<span class="fc" id="L3513">            cx.isTopLevelStrict = previousTopLevelStrict;</span>

<span class="pc bpc" id="L3515" title="2 of 4 branches missed.">            if (cx.currentActivationCall != null) {</span>
                // Function should always call exitActivationFunction
                // if it creates activation record
<span class="nc" id="L3518">                throw new IllegalStateException();</span>
            }
<span class="fc" id="L3520">        }</span>
<span class="fc" id="L3521">        return result;</span>
    }

    /**
     * Return &lt;tt&gt;possibleDynamicScope&lt;/tt&gt; if &lt;tt&gt;staticTopScope&lt;/tt&gt;
     * is present on its prototype chain and return &lt;tt&gt;staticTopScope&lt;/tt&gt;
     * otherwise.
     * Should only be called when &lt;tt&gt;staticTopScope&lt;/tt&gt; is top scope.
     */
    static Scriptable checkDynamicScope(Scriptable possibleDynamicScope,
                                        Scriptable staticTopScope)
    {
        // Return cx.topCallScope if scope
<span class="nc bnc" id="L3534" title="All 2 branches missed.">        if (possibleDynamicScope == staticTopScope) {</span>
<span class="nc" id="L3535">            return possibleDynamicScope;</span>
        }
<span class="nc" id="L3537">        Scriptable proto = possibleDynamicScope;</span>
        for (;;) {
<span class="nc" id="L3539">            proto = proto.getPrototype();</span>
<span class="nc bnc" id="L3540" title="All 2 branches missed.">            if (proto == staticTopScope) {</span>
<span class="nc" id="L3541">                return possibleDynamicScope;</span>
            }
<span class="nc bnc" id="L3543" title="All 2 branches missed.">            if (proto == null) {</span>
<span class="nc" id="L3544">                return staticTopScope;</span>
            }
        }
    }

    public static void addInstructionCount(Context cx, int instructionsToAdd)
    {
<span class="nc" id="L3551">        cx.instructionCount += instructionsToAdd;</span>
<span class="nc bnc" id="L3552" title="All 2 branches missed.">        if (cx.instructionCount &gt; cx.instructionThreshold)</span>
        {
<span class="nc" id="L3554">            cx.observeInstructionCount(cx.instructionCount);</span>
<span class="nc" id="L3555">            cx.instructionCount = 0;</span>
        }
<span class="nc" id="L3557">    }</span>

    public static void initScript(NativeFunction funObj, Scriptable thisObj,
                                  Context cx, Scriptable scope,
                                  boolean evalScript)
    {
<span class="pc bpc" id="L3563" title="1 of 2 branches missed.">        if (cx.topCallScope == null)</span>
<span class="nc" id="L3564">            throw new IllegalStateException();</span>

<span class="fc" id="L3566">        int varCount = funObj.getParamAndVarCount();</span>
<span class="fc bfc" id="L3567" title="All 2 branches covered.">        if (varCount != 0) {</span>

<span class="fc" id="L3569">            Scriptable varScope = scope;</span>
            // Never define any variables from var statements inside with
            // object. See bug 38590.
<span class="pc bpc" id="L3572" title="1 of 2 branches missed.">            while (varScope instanceof NativeWith) {</span>
<span class="nc" id="L3573">                varScope = varScope.getParentScope();</span>
            }

<span class="fc bfc" id="L3576" title="All 2 branches covered.">            for (int i = varCount; i-- != 0;) {</span>
<span class="fc" id="L3577">                String name = funObj.getParamOrVarName(i);</span>
<span class="fc" id="L3578">                boolean isConst = funObj.getParamOrVarConst(i);</span>
                // Don't overwrite existing def if already defined in object
                // or prototypes of object.
<span class="pc bpc" id="L3581" title="1 of 2 branches missed.">                if (!ScriptableObject.hasProperty(scope, name)) {</span>
<span class="pc bpc" id="L3582" title="1 of 2 branches missed.">                    if (isConst) {</span>
<span class="nc" id="L3583">                        ScriptableObject.defineConstProperty(varScope, name);</span>
<span class="pc bpc" id="L3584" title="1 of 2 branches missed.">                    } else if (!evalScript) {</span>
                        // Global var definitions are supposed to be DONTDELETE
<span class="fc" id="L3586">                        ScriptableObject.defineProperty(</span>
                            varScope, name, Undefined.instance,
                            ScriptableObject.PERMANENT);
                    } else {
<span class="nc" id="L3590">                        varScope.put(name, varScope, Undefined.instance);</span>
                    }
                } else {
<span class="nc" id="L3593">                    ScriptableObject.redefineProperty(scope, name, isConst);</span>
                }
<span class="fc" id="L3595">            }</span>
        }
<span class="fc" id="L3597">    }</span>

    /**
     * @deprecated Use {@link #createFunctionActivation(NativeFunction, Scriptable, Object[], boolean)} instead
     */
    @Deprecated
    public static Scriptable createFunctionActivation(NativeFunction funObj,
                                                      Scriptable scope,
                                                      Object[] args)
    {
<span class="nc" id="L3607">        return createFunctionActivation(funObj, scope, args, false);</span>
    }

    public static Scriptable createFunctionActivation(NativeFunction funObj,
                                                      Scriptable scope,
                                                      Object[] args,
                                                      boolean isStrict)
    {
<span class="fc" id="L3615">        return new NativeCall(funObj, scope, args, false, isStrict);</span>
    }

    public static Scriptable createArrowFunctionActivation(NativeFunction funObj,
                                                           Scriptable scope,
                                                           Object[] args,
                                                           boolean isStrict)
    {
<span class="nc" id="L3623">        return new NativeCall(funObj, scope, args, true, isStrict);</span>
    }

    public static void enterActivationFunction(Context cx,
                                               Scriptable scope)
    {
<span class="pc bpc" id="L3629" title="1 of 2 branches missed.">        if (cx.topCallScope == null)</span>
<span class="nc" id="L3630">            throw new IllegalStateException();</span>
<span class="fc" id="L3631">        NativeCall call = (NativeCall)scope;</span>
<span class="fc" id="L3632">        call.parentActivationCall = cx.currentActivationCall;</span>
<span class="fc" id="L3633">        cx.currentActivationCall = call;</span>
<span class="fc" id="L3634">        call.defineAttributesForArguments();</span>
<span class="fc" id="L3635">    }</span>

    public static void exitActivationFunction(Context cx)
    {
<span class="fc" id="L3639">        NativeCall call = cx.currentActivationCall;</span>
<span class="fc" id="L3640">        cx.currentActivationCall = call.parentActivationCall;</span>
<span class="fc" id="L3641">        call.parentActivationCall = null;</span>
<span class="fc" id="L3642">    }</span>

    static NativeCall findFunctionActivation(Context cx, Function f)
    {
<span class="nc" id="L3646">        NativeCall call = cx.currentActivationCall;</span>
<span class="nc bnc" id="L3647" title="All 2 branches missed.">        while (call != null) {</span>
<span class="nc bnc" id="L3648" title="All 2 branches missed.">            if (call.function == f)</span>
<span class="nc" id="L3649">                return call;</span>
<span class="nc" id="L3650">            call = call.parentActivationCall;</span>
        }
<span class="nc" id="L3652">        return null;</span>
    }

    public static Scriptable newCatchScope(Throwable t,
                                           Scriptable lastCatchScope,
                                           String exceptionName,
                                           Context cx, Scriptable scope)
    {
        Object obj;
        boolean cacheObj;

    getObj:
<span class="pc bpc" id="L3664" title="1 of 2 branches missed.">        if (t instanceof JavaScriptException) {</span>
<span class="nc" id="L3665">            cacheObj = false;</span>
<span class="nc" id="L3666">            obj = ((JavaScriptException)t).getValue();</span>
        } else {
<span class="fc" id="L3668">            cacheObj = true;</span>

            // Create wrapper object unless it was associated with
            // the previous scope object

<span class="pc bpc" id="L3673" title="1 of 2 branches missed.">            if (lastCatchScope != null) {</span>
<span class="nc" id="L3674">                NativeObject last = (NativeObject)lastCatchScope;</span>
<span class="nc" id="L3675">                obj = last.getAssociatedValue(t);</span>
<span class="nc bnc" id="L3676" title="All 2 branches missed.">                if (obj == null) Kit.codeBug();</span>
                break getObj;
            }

            RhinoException re;
            TopLevel.NativeErrors type;
            String errorMsg;
<span class="fc" id="L3683">            Throwable javaException = null;</span>

<span class="pc bpc" id="L3685" title="1 of 2 branches missed.">            if (t instanceof EcmaError) {</span>
<span class="fc" id="L3686">                EcmaError ee = (EcmaError)t;</span>
<span class="fc" id="L3687">                re = ee;</span>
<span class="fc" id="L3688">                type = TopLevel.NativeErrors.valueOf(ee.getName());</span>
<span class="fc" id="L3689">                errorMsg = ee.getErrorMessage();</span>
<span class="pc bnc" id="L3690" title="All 2 branches missed.">            } else if (t instanceof WrappedException) {</span>
<span class="nc" id="L3691">                WrappedException we = (WrappedException)t;</span>
<span class="nc" id="L3692">                re = we;</span>
<span class="nc" id="L3693">                javaException = we.getWrappedException();</span>
<span class="nc" id="L3694">                type = TopLevel.NativeErrors.JavaException;</span>
<span class="nc" id="L3695">                errorMsg = javaException.getClass().getName()</span>
<span class="nc" id="L3696">                           +&quot;: &quot;+javaException.getMessage();</span>
<span class="nc bnc" id="L3697" title="All 2 branches missed.">            } else if (t instanceof EvaluatorException) {</span>
                // Pure evaluator exception, nor WrappedException instance
<span class="nc" id="L3699">                EvaluatorException ee = (EvaluatorException)t;</span>
<span class="nc" id="L3700">                re = ee;</span>
<span class="nc" id="L3701">                type = TopLevel.NativeErrors.InternalError;</span>
<span class="nc" id="L3702">                errorMsg = ee.getMessage();</span>
<span class="nc bnc" id="L3703" title="All 2 branches missed.">            } else if (cx.hasFeature(Context.FEATURE_ENHANCED_JAVA_ACCESS)) {</span>
                // With FEATURE_ENHANCED_JAVA_ACCESS, scripts can catch
                // all exception types
<span class="nc" id="L3706">                re = new WrappedException(t);</span>
<span class="nc" id="L3707">                type = TopLevel.NativeErrors.JavaException;</span>
<span class="nc" id="L3708">                errorMsg = t.toString();</span>
            } else {
                // Script can catch only instances of JavaScriptException,
                // EcmaError and EvaluatorException
<span class="nc" id="L3712">                throw Kit.codeBug();</span>
            }

<span class="fc" id="L3715">            String sourceUri = re.sourceName();</span>
<span class="pc bpc" id="L3716" title="1 of 2 branches missed.">            if (sourceUri == null) {</span>
<span class="nc" id="L3717">                sourceUri = &quot;&quot;;</span>
            }
<span class="fc" id="L3719">            int line = re.lineNumber();</span>
            Object args[];
<span class="pc bpc" id="L3721" title="1 of 2 branches missed.">            if (line &gt; 0) {</span>
<span class="fc" id="L3722">                args = new Object[] { errorMsg, sourceUri, Integer.valueOf(line) };</span>
            } else {
<span class="nc" id="L3724">                args = new Object[] { errorMsg, sourceUri };</span>
            }

<span class="fc" id="L3727">            Scriptable errorObject = newNativeError(cx, scope, type, args);</span>
            // set exception in Error objects to enable non-ECMA &quot;stack&quot; property
<span class="pc bpc" id="L3729" title="1 of 2 branches missed.">            if (errorObject instanceof NativeError) {</span>
<span class="fc" id="L3730">                ((NativeError) errorObject).setStackProvider(re);</span>
            }

<span class="pc bpc" id="L3733" title="3 of 4 branches missed.">            if (javaException != null &amp;&amp; isVisible(cx, javaException)) {</span>
<span class="nc" id="L3734">                Object wrap = cx.getWrapFactory().wrap(cx, scope, javaException,</span>
                                                       null);
<span class="nc" id="L3736">                ScriptableObject.defineProperty(</span>
                    errorObject, &quot;javaException&quot;, wrap,
                    ScriptableObject.PERMANENT | ScriptableObject.READONLY | ScriptableObject.DONTENUM);
            }
<span class="pc bpc" id="L3740" title="1 of 2 branches missed.">            if (isVisible(cx, re)) {</span>
<span class="fc" id="L3741">                Object wrap = cx.getWrapFactory().wrap(cx, scope, re, null);</span>
<span class="fc" id="L3742">                ScriptableObject.defineProperty(</span>
                        errorObject, &quot;rhinoException&quot;, wrap,
                        ScriptableObject.PERMANENT | ScriptableObject.READONLY | ScriptableObject.DONTENUM);
            }
<span class="fc" id="L3746">            obj = errorObject;</span>
        }

<span class="fc" id="L3749">        NativeObject catchScopeObject = new NativeObject();</span>
        // See ECMA 12.4
<span class="fc" id="L3751">        catchScopeObject.defineProperty(</span>
            exceptionName, obj, ScriptableObject.PERMANENT);

<span class="pc bpc" id="L3754" title="1 of 2 branches missed.">        if (isVisible(cx, t)) {</span>
            // Add special Rhino object __exception__ defined in the catch
            // scope that can be used to retrieve the Java exception associated
            // with the JavaScript exception (to get stack trace info, etc.)
<span class="fc" id="L3758">            catchScopeObject.defineProperty(</span>
<span class="fc" id="L3759">                &quot;__exception__&quot;, Context.javaToJS(t, scope),</span>
                ScriptableObject.PERMANENT|ScriptableObject.DONTENUM);
        }

<span class="pc bpc" id="L3763" title="1 of 2 branches missed.">        if (cacheObj) {</span>
<span class="fc" id="L3764">            catchScopeObject.associateValue(t, obj);</span>
        }
<span class="fc" id="L3766">        return catchScopeObject;</span>
    }

    public static Scriptable wrapException(Throwable t,
                                           Scriptable scope,
                                           Context cx) {
        RhinoException re;
        String errorName;
        String errorMsg;
<span class="nc" id="L3775">        Throwable javaException = null;</span>

<span class="nc bnc" id="L3777" title="All 2 branches missed.">        if (t instanceof EcmaError) {</span>
<span class="nc" id="L3778">            EcmaError ee = (EcmaError)t;</span>
<span class="nc" id="L3779">            re = ee;</span>
<span class="nc" id="L3780">            errorName = ee.getName();</span>
<span class="nc" id="L3781">            errorMsg = ee.getErrorMessage();</span>
<span class="nc bnc" id="L3782" title="All 2 branches missed.">        } else if (t instanceof WrappedException) {</span>
<span class="nc" id="L3783">            WrappedException we = (WrappedException)t;</span>
<span class="nc" id="L3784">            re = we;</span>
<span class="nc" id="L3785">            javaException = we.getWrappedException();</span>
<span class="nc" id="L3786">            errorName = &quot;JavaException&quot;;</span>
<span class="nc" id="L3787">            errorMsg = javaException.getClass().getName()</span>
<span class="nc" id="L3788">                       +&quot;: &quot;+javaException.getMessage();</span>
<span class="nc bnc" id="L3789" title="All 2 branches missed.">        } else if (t instanceof EvaluatorException) {</span>
            // Pure evaluator exception, nor WrappedException instance
<span class="nc" id="L3791">            EvaluatorException ee = (EvaluatorException)t;</span>
<span class="nc" id="L3792">            re = ee;</span>
<span class="nc" id="L3793">            errorName = &quot;InternalError&quot;;</span>
<span class="nc" id="L3794">            errorMsg = ee.getMessage();</span>
<span class="nc bnc" id="L3795" title="All 2 branches missed.">        } else if (cx.hasFeature(Context.FEATURE_ENHANCED_JAVA_ACCESS)) {</span>
            // With FEATURE_ENHANCED_JAVA_ACCESS, scripts can catch
            // all exception types
<span class="nc" id="L3798">            re = new WrappedException(t);</span>
<span class="nc" id="L3799">            errorName = &quot;JavaException&quot;;</span>
<span class="nc" id="L3800">            errorMsg = t.toString();</span>
        } else {
            // Script can catch only instances of JavaScriptException,
            // EcmaError and EvaluatorException
<span class="nc" id="L3804">            throw Kit.codeBug();</span>
        }

<span class="nc" id="L3807">        String sourceUri = re.sourceName();</span>
<span class="nc bnc" id="L3808" title="All 2 branches missed.">        if (sourceUri == null) {</span>
<span class="nc" id="L3809">            sourceUri = &quot;&quot;;</span>
        }
<span class="nc" id="L3811">        int line = re.lineNumber();</span>
        Object args[];
<span class="nc bnc" id="L3813" title="All 2 branches missed.">        if (line &gt; 0) {</span>
<span class="nc" id="L3814">            args = new Object[] { errorMsg, sourceUri, Integer.valueOf(line) };</span>
        } else {
<span class="nc" id="L3816">            args = new Object[] { errorMsg, sourceUri };</span>
        }

<span class="nc" id="L3819">        Scriptable errorObject = cx.newObject(scope, errorName, args);</span>
<span class="nc" id="L3820">        ScriptableObject.putProperty(errorObject, &quot;name&quot;, errorName);</span>
        // set exception in Error objects to enable non-ECMA &quot;stack&quot; property
<span class="nc bnc" id="L3822" title="All 2 branches missed.">        if (errorObject instanceof NativeError) {</span>
<span class="nc" id="L3823">            ((NativeError) errorObject).setStackProvider(re);</span>
        }

<span class="nc bnc" id="L3826" title="All 4 branches missed.">        if (javaException != null &amp;&amp; isVisible(cx, javaException)) {</span>
<span class="nc" id="L3827">            Object wrap = cx.getWrapFactory().wrap(cx, scope, javaException,</span>
                                                   null);
<span class="nc" id="L3829">            ScriptableObject.defineProperty(</span>
                errorObject, &quot;javaException&quot;, wrap,
                ScriptableObject.PERMANENT | ScriptableObject.READONLY | ScriptableObject.DONTENUM);
        }
<span class="nc bnc" id="L3833" title="All 2 branches missed.">        if (isVisible(cx, re)) {</span>
<span class="nc" id="L3834">            Object wrap = cx.getWrapFactory().wrap(cx, scope, re, null);</span>
<span class="nc" id="L3835">            ScriptableObject.defineProperty(</span>
                    errorObject, &quot;rhinoException&quot;, wrap,
                    ScriptableObject.PERMANENT | ScriptableObject.READONLY | ScriptableObject.DONTENUM);
        }
<span class="nc" id="L3839">        return errorObject;</span>
    }

    private static boolean isVisible(Context cx, Object obj) {
<span class="fc" id="L3843">        ClassShutter shutter = cx.getClassShutter();</span>
<span class="pc bpc" id="L3844" title="1 of 2 branches missed.">        return shutter == null ||</span>
<span class="pc bnc" id="L3845" title="All 2 branches missed.">            shutter.visibleToScripts(obj.getClass().getName());</span>
    }

    public static Scriptable enterWith(Object obj, Context cx,
                                       Scriptable scope)
    {
<span class="fc" id="L3851">        Scriptable sobj = toObjectOrNull(cx, obj, scope);</span>
<span class="pc bpc" id="L3852" title="1 of 2 branches missed.">        if (sobj == null) {</span>
<span class="nc" id="L3853">            throw typeError1(&quot;msg.undef.with&quot;, toString(obj));</span>
        }
<span class="pc bpc" id="L3855" title="1 of 2 branches missed.">        if (sobj instanceof XMLObject) {</span>
<span class="nc" id="L3856">            XMLObject xmlObject = (XMLObject)sobj;</span>
<span class="nc" id="L3857">            return xmlObject.enterWith(scope);</span>
        }
<span class="fc" id="L3859">        return new NativeWith(scope, sobj);</span>
    }

    public static Scriptable leaveWith(Scriptable scope)
    {
<span class="nc" id="L3864">        NativeWith nw = (NativeWith)scope;</span>
<span class="nc" id="L3865">        return nw.getParentScope();</span>
    }

    public static Scriptable enterDotQuery(Object value, Scriptable scope)
    {
<span class="nc bnc" id="L3870" title="All 2 branches missed.">        if (!(value instanceof XMLObject)) {</span>
<span class="nc" id="L3871">            throw notXmlError(value);</span>
        }
<span class="nc" id="L3873">        XMLObject object = (XMLObject)value;</span>
<span class="nc" id="L3874">        return object.enterDotQuery(scope);</span>
    }

    public static Object updateDotQuery(boolean value, Scriptable scope)
    {
        // Return null to continue looping
<span class="nc" id="L3880">        NativeWith nw = (NativeWith)scope;</span>
<span class="nc" id="L3881">        return nw.updateDotQuery(value);</span>
    }

    public static Scriptable leaveDotQuery(Scriptable scope)
    {
<span class="nc" id="L3886">        NativeWith nw = (NativeWith)scope;</span>
<span class="nc" id="L3887">        return nw.getParentScope();</span>
    }

    public static void setFunctionProtoAndParent(BaseFunction fn,
                                                 Scriptable scope)
    {
<span class="fc" id="L3893">        fn.setParentScope(scope);</span>
<span class="fc" id="L3894">        fn.setPrototype(ScriptableObject.getFunctionPrototype(scope));</span>
<span class="fc" id="L3895">    }</span>

    public static void setObjectProtoAndParent(ScriptableObject object,
                                               Scriptable scope)
    {
        // Compared with function it always sets the scope to top scope
<span class="fc" id="L3901">        scope = ScriptableObject.getTopLevelScope(scope);</span>
<span class="fc" id="L3902">        object.setParentScope(scope);</span>
<span class="fc" id="L3903">        Scriptable proto</span>
<span class="fc" id="L3904">            = ScriptableObject.getClassPrototype(scope, object.getClassName());</span>
<span class="fc" id="L3905">        object.setPrototype(proto);</span>
<span class="fc" id="L3906">    }</span>

    public static void setBuiltinProtoAndParent(ScriptableObject object,
                                                Scriptable scope,
                                                TopLevel.Builtins type)
    {
<span class="fc" id="L3912">        scope = ScriptableObject.getTopLevelScope(scope);</span>
<span class="fc" id="L3913">        object.setParentScope(scope);</span>
<span class="fc" id="L3914">        object.setPrototype(TopLevel.getBuiltinPrototype(scope, type));</span>
<span class="fc" id="L3915">    }</span>


    public static void initFunction(Context cx, Scriptable scope,
                                    NativeFunction function, int type,
                                    boolean fromEvalCode)
    {
<span class="pc bpc" id="L3922" title="1 of 2 branches missed.">        if (type == FunctionNode.FUNCTION_STATEMENT) {</span>
<span class="fc" id="L3923">            String name = function.getFunctionName();</span>
<span class="pc bpc" id="L3924" title="1 of 4 branches missed.">            if (name != null &amp;&amp; name.length() != 0) {</span>
<span class="pc bpc" id="L3925" title="1 of 2 branches missed.">                if (!fromEvalCode) {</span>
                    // ECMA specifies that functions defined in global and
                    // function scope outside eval should have DONTDELETE set.
<span class="fc" id="L3928">                    ScriptableObject.defineProperty</span>
<span class="fc" id="L3929">                        (scope, name, function, ScriptableObject.PERMANENT);</span>
                } else {
<span class="nc" id="L3931">                    scope.put(name, scope, function);</span>
                }
            }
<span class="pc bnc" id="L3934" title="All 2 branches missed.">        } else if (type == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {</span>
<span class="nc" id="L3935">            String name = function.getFunctionName();</span>
<span class="nc bnc" id="L3936" title="All 4 branches missed.">            if (name != null &amp;&amp; name.length() != 0) {</span>
                // Always put function expression statements into initial
                // activation object ignoring the with statement to follow
                // SpiderMonkey
<span class="nc bnc" id="L3940" title="All 2 branches missed.">                while (scope instanceof NativeWith) {</span>
<span class="nc" id="L3941">                    scope = scope.getParentScope();</span>
                }
<span class="nc" id="L3943">                scope.put(name, scope, function);</span>
            }
<span class="nc" id="L3945">        } else {</span>
<span class="nc" id="L3946">            throw Kit.codeBug();</span>
        }
<span class="fc" id="L3948">    }</span>

    public static Scriptable newArrayLiteral(Object[] objects,
                                             int[] skipIndices,
                                             Context cx, Scriptable scope)
    {
<span class="fc" id="L3954">        final int SKIP_DENSITY = 2;</span>
<span class="fc" id="L3955">        int count = objects.length;</span>
<span class="fc" id="L3956">        int skipCount = 0;</span>
<span class="fc bfc" id="L3957" title="All 2 branches covered.">        if (skipIndices != null) {</span>
<span class="fc" id="L3958">            skipCount = skipIndices.length;</span>
        }
<span class="fc" id="L3960">        int length = count + skipCount;</span>
<span class="pc bpc" id="L3961" title="1 of 4 branches missed.">        if (length &gt; 1 &amp;&amp; skipCount * SKIP_DENSITY &lt; length) {</span>
            // If not too sparse, create whole array for constructor
            Object[] sparse;
<span class="nc bnc" id="L3964" title="All 2 branches missed.">            if (skipCount == 0) {</span>
<span class="nc" id="L3965">                sparse = objects;</span>
            } else {
<span class="nc" id="L3967">                sparse = new Object[length];</span>
<span class="nc" id="L3968">                int skip = 0;</span>
<span class="nc bnc" id="L3969" title="All 2 branches missed.">                for (int i = 0, j = 0; i != length; ++i) {</span>
<span class="nc bnc" id="L3970" title="All 4 branches missed.">                    if (skip != skipCount &amp;&amp; skipIndices[skip] == i) {</span>
<span class="nc" id="L3971">                        sparse[i] = Scriptable.NOT_FOUND;</span>
<span class="nc" id="L3972">                        ++skip;</span>
<span class="nc" id="L3973">                        continue;</span>
                    }
<span class="nc" id="L3975">                    sparse[i] = objects[j];</span>
<span class="nc" id="L3976">                    ++j;</span>
                }
            }
<span class="nc" id="L3979">            return cx.newArray(scope, sparse);</span>
        }

<span class="fc" id="L3982">        Scriptable array = cx.newArray(scope, length);</span>

<span class="fc" id="L3984">        int skip = 0;</span>
<span class="pc bpc" id="L3985" title="1 of 2 branches missed.">        for (int i = 0, j = 0; i != length; ++i) {</span>
<span class="nc bnc" id="L3986" title="All 4 branches missed.">            if (skip != skipCount &amp;&amp; skipIndices[skip] == i) {</span>
<span class="nc" id="L3987">                ++skip;</span>
<span class="nc" id="L3988">                continue;</span>
            }
<span class="nc" id="L3990">            array.put(i, array, objects[j]);</span>
<span class="nc" id="L3991">            ++j;</span>
        }
<span class="fc" id="L3993">        return array;</span>
    }

    /**
     * This method is here for backward compat with existing compiled code.  It
     * is called when an object literal is compiled.  The next instance will be
     * the version called from new code.
     * &lt;strong&gt;This method only present for compatibility.&lt;/strong&gt;
     * @deprecated Use {@link #newObjectLiteral(Object[], Object[], int[], Context, Scriptable)} instead
     */
    @Deprecated
    public static Scriptable newObjectLiteral(Object[] propertyIds,
                                              Object[] propertyValues,
                                              Context cx, Scriptable scope)
    {
        // Passing null for getterSetters means no getters or setters
<span class="nc" id="L4009">        return newObjectLiteral(propertyIds, propertyValues, null, cx, scope);</span>
    }

    public static Scriptable newObjectLiteral(Object[] propertyIds,
                                              Object[] propertyValues,
                                              int [] getterSetters,
                                              Context cx, Scriptable scope)
    {
<span class="fc" id="L4017">        Scriptable object = cx.newObject(scope);</span>
<span class="pc bpc" id="L4018" title="1 of 2 branches missed.">        for (int i = 0, end = propertyIds.length; i != end; ++i) {</span>
<span class="nc" id="L4019">            Object id = propertyIds[i];</span>
<span class="nc bnc" id="L4020" title="All 2 branches missed.">            int getterSetter = getterSetters == null ? 0 : getterSetters[i];</span>
<span class="nc" id="L4021">            Object value = propertyValues[i];</span>
<span class="nc bnc" id="L4022" title="All 2 branches missed.">            if (id instanceof String) {</span>
<span class="nc bnc" id="L4023" title="All 2 branches missed.">                if (getterSetter == 0) {</span>
<span class="nc bnc" id="L4024" title="All 2 branches missed.">                    if (isSpecialProperty((String)id)) {</span>
<span class="nc" id="L4025">                        Ref ref = specialRef(object, (String)id, cx, scope);</span>
<span class="nc" id="L4026">                        ref.set(cx, scope, value);</span>
<span class="nc" id="L4027">                    } else {</span>
<span class="nc" id="L4028">                        object.put((String)id, object, value);</span>
                    }
                } else {
<span class="nc" id="L4031">                    ScriptableObject so = (ScriptableObject)object;</span>
<span class="nc" id="L4032">                    Callable getterOrSetter = (Callable)value;</span>
<span class="nc bnc" id="L4033" title="All 2 branches missed.">                    boolean isSetter = getterSetter == 1;</span>
<span class="nc" id="L4034">                    so.setGetterOrSetter((String)id, 0, getterOrSetter, isSetter);</span>
<span class="nc" id="L4035">                }</span>
            } else {
<span class="nc" id="L4037">                int index = ((Integer)id).intValue();</span>
<span class="nc" id="L4038">                object.put(index, object, value);</span>
            }
        }
<span class="fc" id="L4041">        return object;</span>
    }

    public static boolean isArrayObject(Object obj)
    {
<span class="nc bnc" id="L4046" title="All 4 branches missed.">        return obj instanceof NativeArray || obj instanceof Arguments;</span>
    }

    public static Object[] getArrayElements(Scriptable object)
    {
<span class="nc" id="L4051">        Context cx = Context.getContext();</span>
<span class="nc" id="L4052">        long longLen = NativeArray.getLengthProperty(cx, object);</span>
<span class="nc bnc" id="L4053" title="All 2 branches missed.">        if (longLen &gt; Integer.MAX_VALUE) {</span>
            // arrays beyond  MAX_INT is not in Java in any case
<span class="nc" id="L4055">            throw new IllegalArgumentException();</span>
        }
<span class="nc" id="L4057">        int len = (int) longLen;</span>
<span class="nc bnc" id="L4058" title="All 2 branches missed.">        if (len == 0) {</span>
<span class="nc" id="L4059">            return ScriptRuntime.emptyArgs;</span>
        } else {
<span class="nc" id="L4061">            Object[] result = new Object[len];</span>
<span class="nc bnc" id="L4062" title="All 2 branches missed.">            for (int i=0; i &lt; len; i++) {</span>
<span class="nc" id="L4063">                Object elem = ScriptableObject.getProperty(object, i);</span>
<span class="nc bnc" id="L4064" title="All 2 branches missed.">                result[i] = (elem == Scriptable.NOT_FOUND) ? Undefined.instance</span>
                                                           : elem;
            }
<span class="nc" id="L4067">            return result;</span>
        }
    }

    static void checkDeprecated(Context cx, String name) {
<span class="nc" id="L4072">        int version = cx.getLanguageVersion();</span>
<span class="nc bnc" id="L4073" title="All 4 branches missed.">        if (version &gt;= Context.VERSION_1_4 || version == Context.VERSION_DEFAULT) {</span>
<span class="nc" id="L4074">            String msg = getMessage1(&quot;msg.deprec.ctor&quot;, name);</span>
<span class="nc bnc" id="L4075" title="All 2 branches missed.">            if (version == Context.VERSION_DEFAULT)</span>
<span class="nc" id="L4076">                Context.reportWarning(msg);</span>
            else
<span class="nc" id="L4078">                throw Context.reportRuntimeError(msg);</span>
        }
<span class="nc" id="L4080">    }</span>

    public static String getMessage0(String messageId)
    {
<span class="fc" id="L4084">        return getMessage(messageId, null);</span>
    }

    public static String getMessage1(String messageId, Object arg1)
    {
<span class="fc" id="L4089">        Object[] arguments = {arg1};</span>
<span class="fc" id="L4090">        return getMessage(messageId, arguments);</span>
    }

    public static String getMessage2(
        String messageId, Object arg1, Object arg2)
    {
<span class="fc" id="L4096">        Object[] arguments = {arg1, arg2};</span>
<span class="fc" id="L4097">        return getMessage(messageId, arguments);</span>
    }

    public static String getMessage3(
        String messageId, Object arg1, Object arg2, Object arg3)
    {
<span class="nc" id="L4103">        Object[] arguments = {arg1, arg2, arg3};</span>
<span class="nc" id="L4104">        return getMessage(messageId, arguments);</span>
    }

    public static String getMessage4(
        String messageId, Object arg1, Object arg2, Object arg3, Object arg4)
    {
<span class="nc" id="L4110">        Object[] arguments = {arg1, arg2, arg3, arg4};</span>
<span class="nc" id="L4111">        return getMessage(messageId, arguments);</span>
    }

    /**
     * This is an interface defining a message provider. Create your
     * own implementation to override the default error message provider.
     *
     * @author Mike Harm
     */
    public interface MessageProvider {

        /**
         * Returns a textual message identified by the given messageId,
         * parameterized by the given arguments.
         *
         * @param messageId the identifier of the message
         * @param arguments the arguments to fill into the message
         */
        String getMessage(String messageId, Object[] arguments);
    }

<span class="fc" id="L4132">    public static MessageProvider messageProvider = new DefaultMessageProvider();</span>

    public static String getMessage(String messageId, Object[] arguments)
    {
<span class="fc" id="L4136">        return messageProvider.getMessage(messageId, arguments);</span>
    }

    /* OPT there's a noticable delay for the first error!  Maybe it'd
     * make sense to use a ListResourceBundle instead of a properties
     * file to avoid (synchronized) text parsing.
     */
<span class="fc" id="L4143">    private static class DefaultMessageProvider implements MessageProvider {</span>
        public String getMessage(String messageId, Object[] arguments) {
<span class="fc" id="L4145">            final String defaultResource</span>
                = &quot;org.mozilla.javascript.resources.Messages&quot;;

<span class="fc" id="L4148">            Context cx = Context.getCurrentContext();</span>
<span class="fc bfc" id="L4149" title="All 2 branches covered.">            Locale locale = cx != null ? cx.getLocale() : Locale.getDefault();</span>

            // ResourceBundle does caching.
<span class="fc" id="L4152">            ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);</span>

            String formatString;
            try {
<span class="fc" id="L4156">                formatString = rb.getString(messageId);</span>
<span class="fc" id="L4157">            } catch (java.util.MissingResourceException mre) {</span>
<span class="fc" id="L4158">                throw new RuntimeException</span>
                    (&quot;no message resource found for message property &quot;+ messageId);
<span class="fc" id="L4160">            }</span>

            /*
             * It's OK to format the string, even if 'arguments' is null;
             * we need to format it anyway, to make double ''s collapse to
             * single 's.
             */
<span class="fc" id="L4167">            MessageFormat formatter = new MessageFormat(formatString);</span>
<span class="fc" id="L4168">            return formatter.format(arguments);</span>
        }
    }

    public static EcmaError constructError(String error, String message)
    {
<span class="fc" id="L4174">        int[] linep = new int[1];</span>
<span class="fc" id="L4175">        String filename = Context.getSourcePositionFromStack(linep);</span>
<span class="fc" id="L4176">        return constructError(error, message, filename, linep[0], null, 0);</span>
    }

    public static EcmaError constructError(String error,
                                           String message,
                                           int lineNumberDelta)
    {
<span class="fc" id="L4183">        int[] linep = new int[1];</span>
<span class="fc" id="L4184">        String filename = Context.getSourcePositionFromStack(linep);</span>
<span class="pc bpc" id="L4185" title="1 of 2 branches missed.">        if (linep[0] != 0) {</span>
<span class="nc" id="L4186">            linep[0] += lineNumberDelta;</span>
        }
<span class="fc" id="L4188">        return constructError(error, message, filename, linep[0], null, 0);</span>
    }

    public static EcmaError constructError(String error,
                                           String message,
                                           String sourceName,
                                           int lineNumber,
                                           String lineSource,
                                           int columnNumber)
    {
<span class="fc" id="L4198">        return new EcmaError(error, message, sourceName,</span>
                             lineNumber, lineSource, columnNumber);
    }

    public static EcmaError rangeError(String message)
    {
<span class="fc" id="L4204">        return constructError(&quot;RangeError&quot;, message);</span>
    }

    public static EcmaError typeError(String message)
    {
<span class="fc" id="L4209">        return constructError(&quot;TypeError&quot;, message);</span>
    }

    public static EcmaError typeError0(String messageId)
    {
<span class="fc" id="L4214">        String msg = getMessage0(messageId);</span>
<span class="fc" id="L4215">        return typeError(msg);</span>
    }

    public static EcmaError typeError1(String messageId, Object arg1)
    {
<span class="fc" id="L4220">        String msg = getMessage1(messageId, arg1);</span>
<span class="fc" id="L4221">        return typeError(msg);</span>
    }

    public static EcmaError typeError2(String messageId, Object arg1,
                                       Object arg2)
    {
<span class="fc" id="L4227">        String msg = getMessage2(messageId, arg1, arg2);</span>
<span class="fc" id="L4228">        return typeError(msg);</span>
    }

    public static EcmaError typeError3(String messageId, String arg1,
                                       String arg2, String arg3)
    {
<span class="nc" id="L4234">        String msg = getMessage3(messageId, arg1, arg2, arg3);</span>
<span class="nc" id="L4235">        return typeError(msg);</span>
    }

    public static RuntimeException undefReadError(Object object, Object id)
    {
<span class="fc" id="L4240">        return typeError2(&quot;msg.undef.prop.read&quot;, toString(object), toString(id));</span>
    }

    public static RuntimeException undefCallError(Object object, Object id)
    {
<span class="fc" id="L4245">        return typeError2(&quot;msg.undef.method.call&quot;, toString(object), toString(id));</span>
    }

    public static RuntimeException undefWriteError(Object object,
                                                   Object id,
                                                   Object value)
    {
<span class="nc" id="L4252">        return typeError3(&quot;msg.undef.prop.write&quot;, toString(object), toString(id),</span>
<span class="nc" id="L4253">                          toString(value));</span>
    }

    private static RuntimeException undefDeleteError(Object object, Object id)
    {
<span class="nc" id="L4258">        throw typeError2(&quot;msg.undef.prop.delete&quot;, toString(object), toString(id));</span>
    }

    public static RuntimeException notFoundError(Scriptable object,
                                                 String property)
    {
        // XXX: use object to improve the error message
<span class="fc" id="L4265">        String msg = getMessage1(&quot;msg.is.not.defined&quot;, property);</span>
<span class="fc" id="L4266">        throw constructError(&quot;ReferenceError&quot;, msg);</span>
    }

    public static RuntimeException notFunctionError(Object value)
    {
<span class="fc" id="L4271">        return notFunctionError(value, value);</span>
    }

    public static RuntimeException notFunctionError(Object value,
                                                    Object messageHelper)
    {
        // Use value for better error reporting
<span class="fc bfc" id="L4278" title="All 2 branches covered.">        String msg = (messageHelper == null)</span>
<span class="fc" id="L4279">                     ? &quot;null&quot; : messageHelper.toString();</span>
<span class="pc bpc" id="L4280" title="1 of 2 branches missed.">        if (value == Scriptable.NOT_FOUND) {</span>
<span class="nc" id="L4281">            return typeError1(&quot;msg.function.not.found&quot;, msg);</span>
        }
<span class="fc" id="L4283">        return typeError2(&quot;msg.isnt.function&quot;, msg, typeof(value));</span>
    }

    public static RuntimeException notFunctionError(Object obj, Object value,
            String propertyName)
    {
        // Use obj and value for better error reporting
<span class="fc" id="L4290">        String objString = toString(obj);</span>
<span class="pc bpc" id="L4291" title="1 of 2 branches missed.">        if (obj instanceof NativeFunction) {</span>
            // Omit function body in string representations of functions
<span class="nc" id="L4293">            int paren = objString.indexOf(')');</span>
<span class="nc" id="L4294">            int curly = objString.indexOf('{', paren);</span>
<span class="nc bnc" id="L4295" title="All 2 branches missed.">            if (curly &gt; -1) {</span>
<span class="nc" id="L4296">                objString = objString.substring(0, curly + 1) + &quot;...}&quot;;</span>
            }
        }
<span class="pc bpc" id="L4299" title="1 of 2 branches missed.">        if (value == Scriptable.NOT_FOUND) {</span>
<span class="fc" id="L4300">            return typeError2(&quot;msg.function.not.found.in&quot;, propertyName,</span>
                    objString);
        }
<span class="nc" id="L4303">        return typeError3(&quot;msg.isnt.function.in&quot;, propertyName, objString,</span>
<span class="nc" id="L4304">                          typeof(value));</span>
    }

    private static RuntimeException notXmlError(Object value)
    {
<span class="nc" id="L4309">        throw typeError1(&quot;msg.isnt.xml.object&quot;, toString(value));</span>
    }

    private static void warnAboutNonJSObject(Object nonJSObject)
    {
<span class="fc" id="L4314">        final String omitParam = ScriptRuntime.getMessage0(&quot;params.omit.non.js.object.warning&quot;);</span>
<span class="pc bpc" id="L4315" title="1 of 2 branches missed.">        if (!&quot;true&quot;.equals(omitParam)) {</span>
<span class="nc" id="L4316">            String message = ScriptRuntime.getMessage2(&quot;msg.non.js.object.warning&quot;,nonJSObject,nonJSObject.getClass().getName());</span>
<span class="nc" id="L4317">            Context.reportWarning(message);</span>
            // Just to be sure that it would be noticed
<span class="nc" id="L4319">            System.err.println(message);</span>
        }
<span class="fc" id="L4321">    }</span>

    public static RegExpProxy getRegExpProxy(Context cx)
    {
<span class="fc" id="L4325">        return cx.getRegExpProxy();</span>
    }

    public static void setRegExpProxy(Context cx, RegExpProxy proxy)
    {
<span class="nc bnc" id="L4330" title="All 2 branches missed.">        if (proxy == null) throw new IllegalArgumentException();</span>
<span class="nc" id="L4331">        cx.regExpProxy = proxy;</span>
<span class="nc" id="L4332">    }</span>

    public static RegExpProxy checkRegExpProxy(Context cx)
    {
<span class="fc" id="L4336">        RegExpProxy result = getRegExpProxy(cx);</span>
<span class="pc bpc" id="L4337" title="1 of 2 branches missed.">        if (result == null) {</span>
<span class="nc" id="L4338">            throw Context.reportRuntimeError0(&quot;msg.no.regexp&quot;);</span>
        }
<span class="fc" id="L4340">        return result;</span>
    }

    public static Scriptable wrapRegExp(Context cx, Scriptable scope,
                                        Object compiled) {
<span class="fc" id="L4345">        return cx.getRegExpProxy().wrapRegExp(cx, scope, compiled);</span>
    }

    private static XMLLib currentXMLLib(Context cx)
    {
        // Scripts should be running to access this
<span class="nc bnc" id="L4351" title="All 2 branches missed.">        if (cx.topCallScope == null)</span>
<span class="nc" id="L4352">            throw new IllegalStateException();</span>

<span class="nc" id="L4354">        XMLLib xmlLib = cx.cachedXMLLib;</span>
<span class="nc bnc" id="L4355" title="All 2 branches missed.">        if (xmlLib == null) {</span>
<span class="nc" id="L4356">            xmlLib = XMLLib.extractFromScope(cx.topCallScope);</span>
<span class="nc bnc" id="L4357" title="All 2 branches missed.">            if (xmlLib == null)</span>
<span class="nc" id="L4358">                throw new IllegalStateException();</span>
<span class="nc" id="L4359">            cx.cachedXMLLib = xmlLib;</span>
        }

<span class="nc" id="L4362">        return xmlLib;</span>
    }

    /**
     * Escapes the reserved characters in a value of an attribute
     *
     * @param value Unescaped text
     * @return The escaped text
     */
    public static String escapeAttributeValue(Object value, Context cx)
    {
<span class="nc" id="L4373">        XMLLib xmlLib = currentXMLLib(cx);</span>
<span class="nc" id="L4374">        return xmlLib.escapeAttributeValue(value);</span>
    }

    /**
     * Escapes the reserved characters in a value of a text node
     *
     * @param value Unescaped text
     * @return The escaped text
     */
    public static String escapeTextValue(Object value, Context cx)
    {
<span class="nc" id="L4385">        XMLLib xmlLib = currentXMLLib(cx);</span>
<span class="nc" id="L4386">        return xmlLib.escapeTextValue(value);</span>
    }

    public static Ref memberRef(Object obj, Object elem,
                                Context cx, int memberTypeFlags)
    {
<span class="nc bnc" id="L4392" title="All 2 branches missed.">        if (!(obj instanceof XMLObject)) {</span>
<span class="nc" id="L4393">            throw notXmlError(obj);</span>
        }
<span class="nc" id="L4395">        XMLObject xmlObject = (XMLObject)obj;</span>
<span class="nc" id="L4396">        return xmlObject.memberRef(cx, elem, memberTypeFlags);</span>
    }

    public static Ref memberRef(Object obj, Object namespace, Object elem,
                                Context cx, int memberTypeFlags)
    {
<span class="nc bnc" id="L4402" title="All 2 branches missed.">        if (!(obj instanceof XMLObject)) {</span>
<span class="nc" id="L4403">            throw notXmlError(obj);</span>
        }
<span class="nc" id="L4405">        XMLObject xmlObject = (XMLObject)obj;</span>
<span class="nc" id="L4406">        return xmlObject.memberRef(cx, namespace, elem, memberTypeFlags);</span>
    }

    public static Ref nameRef(Object name, Context cx,
                              Scriptable scope, int memberTypeFlags)
    {
<span class="nc" id="L4412">        XMLLib xmlLib = currentXMLLib(cx);</span>
<span class="nc" id="L4413">        return xmlLib.nameRef(cx, name, scope, memberTypeFlags);</span>
    }

    public static Ref nameRef(Object namespace, Object name, Context cx,
                              Scriptable scope, int memberTypeFlags)
    {
<span class="nc" id="L4419">        XMLLib xmlLib = currentXMLLib(cx);</span>
<span class="nc" id="L4420">        return xmlLib.nameRef(cx, namespace, name, scope, memberTypeFlags);</span>
    }

    private static void storeIndexResult(Context cx, int index)
    {
<span class="fc" id="L4425">        cx.scratchIndex = index;</span>
<span class="fc" id="L4426">    }</span>

    static int lastIndexResult(Context cx)
    {
<span class="fc" id="L4430">        return cx.scratchIndex;</span>
    }

    public static void storeUint32Result(Context cx, long value)
    {
<span class="nc bnc" id="L4435" title="All 2 branches missed.">        if ((value &gt;&gt;&gt; 32) != 0)</span>
<span class="nc" id="L4436">            throw new IllegalArgumentException();</span>
<span class="nc" id="L4437">        cx.scratchUint32 = value;</span>
<span class="nc" id="L4438">    }</span>

    public static long lastUint32Result(Context cx)
    {
<span class="nc" id="L4442">        long value = cx.scratchUint32;</span>
<span class="nc bnc" id="L4443" title="All 2 branches missed.">        if ((value &gt;&gt;&gt; 32) != 0)</span>
<span class="nc" id="L4444">            throw new IllegalStateException();</span>
<span class="nc" id="L4445">        return value;</span>
    }

    private static void storeScriptable(Context cx, Scriptable value)
    {
        // The previously stored scratchScriptable should be consumed
<span class="pc bpc" id="L4451" title="1 of 2 branches missed.">        if (cx.scratchScriptable != null)</span>
<span class="nc" id="L4452">            throw new IllegalStateException();</span>
<span class="fc" id="L4453">        cx.scratchScriptable = value;</span>
<span class="fc" id="L4454">    }</span>

    public static Scriptable lastStoredScriptable(Context cx)
    {
<span class="fc" id="L4458">        Scriptable result = cx.scratchScriptable;</span>
<span class="fc" id="L4459">        cx.scratchScriptable = null;</span>
<span class="fc" id="L4460">        return result;</span>
    }

    static String makeUrlForGeneratedScript
        (boolean isEval, String masterScriptUrl, int masterScriptLine)
    {
<span class="nc bnc" id="L4466" title="All 2 branches missed.">        if (isEval) {</span>
<span class="nc" id="L4467">            return masterScriptUrl+'#'+masterScriptLine+&quot;(eval)&quot;;</span>
        } else {
<span class="nc" id="L4469">            return masterScriptUrl+'#'+masterScriptLine+&quot;(Function)&quot;;</span>
        }
    }

    static boolean isGeneratedScript(String sourceUrl) {
        // ALERT: this may clash with a valid URL containing (eval) or
        // (Function)
<span class="pc bpc" id="L4476" title="1 of 2 branches missed.">        return sourceUrl.indexOf(&quot;(eval)&quot;) &gt;= 0</span>
<span class="pc bpc" id="L4477" title="1 of 2 branches missed.">               || sourceUrl.indexOf(&quot;(Function)&quot;) &gt;= 0;</span>
    }

    /**
     * Not all &quot;NativeSymbol&quot; instances are actually symbols. So account for that here rather than just
     * by using an &quot;instanceof&quot; check.
     */
    static boolean isSymbol(Object obj) {
<span class="pc bpc" id="L4485" title="1 of 2 branches missed.">        return (((obj instanceof NativeSymbol) &amp;&amp;</span>
<span class="pc bpc" id="L4486" title="3 of 4 branches missed.">                ((NativeSymbol)obj).isSymbol())) || (obj instanceof SymbolKey);</span>
    }

    private static RuntimeException errorWithClassName(String msg, Object val)
    {
<span class="nc" id="L4491">        return Context.reportRuntimeError1(msg, val.getClass().getName());</span>
    }

    /**
     * Equivalent to executing &quot;new Error(message, sourceFileName, sourceLineNo)&quot; from JavaScript.
     * @param cx the current context
     * @param scope the current scope
     * @param message the message
     * @return a JavaScriptException you should throw
     */
    public static JavaScriptException throwError(Context cx, Scriptable scope,
            String message) {
<span class="fc" id="L4503">      int[] linep = { 0 };</span>
<span class="fc" id="L4504">      String filename = Context.getSourcePositionFromStack(linep);</span>
<span class="fc" id="L4505">        final Scriptable error = newBuiltinObject(cx, scope,</span>
<span class="fc" id="L4506">                TopLevel.Builtins.Error, new Object[] { message, filename, Integer.valueOf(linep[0]) });</span>
<span class="fc" id="L4507">        return new JavaScriptException(error, filename, linep[0]);</span>
    }


    /**
     * Equivalent to executing &quot;new $constructorName(message, sourceFileName, sourceLineNo)&quot; from JavaScript.
     * @param cx the current context
     * @param scope the current scope
     * @param message the message
     * @return a JavaScriptException you should throw
     */
    public static JavaScriptException throwCustomError(Context cx, Scriptable scope, String constructorName,
            String message) {
<span class="nc" id="L4520">      int[] linep = { 0 };</span>
<span class="nc" id="L4521">      String filename = Context.getSourcePositionFromStack(linep);</span>
<span class="nc" id="L4522">      final Scriptable error =  cx.newObject(scope, constructorName,</span>
<span class="nc" id="L4523">        new Object[] { message, filename, Integer.valueOf(linep[0]) });</span>
<span class="nc" id="L4524">      return new JavaScriptException(error, filename, linep[0]);</span>
    }

<span class="fc" id="L4527">    public static final Object[] emptyArgs = new Object[0];</span>
<span class="fc" id="L4528">    public static final String[] emptyStrings = new String[0];</span>


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>