<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RegExpImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rhino-Rhino1_7_9_Release</a> &gt; <a href="index.source.html" class="el_package">org.mozilla.javascript.regexp</a> &gt; <span class="el_source">RegExpImpl.java</span></div><h1>RegExpImpl.java</h1><pre class="source lang-java linenums">/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.javascript.regexp;

import org.mozilla.javascript.*;

/**
 *
 */
<span class="fc" id="L14">public class RegExpImpl implements RegExpProxy {</span>

    public boolean isRegExp(Scriptable obj) {
<span class="fc" id="L17">        return obj instanceof NativeRegExp;</span>
    }

    public Object compileRegExp(Context cx, String source, String flags)
    {
<span class="fc" id="L22">        return NativeRegExp.compileRE(cx, source, flags, false);</span>
    }

    public Scriptable wrapRegExp(Context cx, Scriptable scope,
                                 Object compiled)
    {
<span class="fc" id="L28">        return new NativeRegExp(scope, (RECompiled) compiled);</span>
    }

    public Object action(Context cx, Scriptable scope,
                         Scriptable thisObj, Object[] args,
                         int actionType)
    {
<span class="fc" id="L35">        GlobData data = new GlobData();</span>
<span class="fc" id="L36">        data.mode = actionType;</span>
<span class="fc" id="L37">        data.str = ScriptRuntime.toString(thisObj);</span>

<span class="pc bpc" id="L39" title="1 of 4 branches missed.">        switch (actionType) {</span>
          case RA_MATCH:
            {
<span class="fc" id="L42">                NativeRegExp re = createRegExp(cx, scope, args, 1, false);</span>
<span class="fc" id="L43">                Object rval = matchOrReplace(cx, scope, thisObj, args,</span>
                                             this, data, re);
<span class="fc bfc" id="L45" title="All 2 branches covered.">                return data.arrayobj == null ? rval : data.arrayobj;</span>
            }

          case RA_SEARCH:
            {
<span class="fc" id="L50">                NativeRegExp re = createRegExp(cx, scope, args, 1, false);</span>
<span class="fc" id="L51">                return matchOrReplace(cx, scope, thisObj, args,</span>
                                      this, data, re);
            }

          case RA_REPLACE:
            {
<span class="pc bpc" id="L57" title="1 of 6 branches missed.">                boolean useRE = (args.length &gt; 0 &amp;&amp; args[0] instanceof NativeRegExp)</span>
                                || args.length &gt; 2;
<span class="fc" id="L59">                NativeRegExp re = null;</span>
<span class="fc" id="L60">                String search = null;</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">                if (useRE) {</span>
<span class="fc" id="L62">                    re = createRegExp(cx, scope, args, 2, true);</span>
                } else {
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">                    Object arg0 = args.length &lt; 1 ? Undefined.instance : args[0];</span>
<span class="fc" id="L65">                    search = ScriptRuntime.toString(arg0);</span>
                }

<span class="pc bpc" id="L68" title="1 of 2 branches missed.">                Object arg1 = args.length &lt; 2 ? Undefined.instance : args[1];</span>
<span class="fc" id="L69">                String repstr = null;</span>
<span class="fc" id="L70">                Function lambda = null;</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">                if (arg1 instanceof Function) {</span>
<span class="fc" id="L72">                    lambda = (Function) arg1;</span>
                } else {
<span class="fc" id="L74">                    repstr = ScriptRuntime.toString(arg1);</span>
                }

<span class="fc" id="L77">                data.lambda = lambda;</span>
<span class="fc" id="L78">                data.repstr = repstr;</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">                data.dollar = repstr == null ? -1 : repstr.indexOf('$');</span>
<span class="fc" id="L80">                data.charBuf = null;</span>
<span class="fc" id="L81">                data.leftIndex = 0;</span>

                Object val;
<span class="fc bfc" id="L84" title="All 2 branches covered.">                if (useRE) {</span>
<span class="fc" id="L85">                    val = matchOrReplace(cx, scope, thisObj, args,</span>
                                         this, data, re);
                } else {
<span class="fc" id="L88">                    String str = data.str;</span>
<span class="fc" id="L89">                    int index = str.indexOf(search);</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">                    if (index &gt;= 0) {</span>
<span class="fc" id="L91">                        int slen = search.length();</span>
<span class="fc" id="L92">                        this.lastParen = null;</span>
<span class="fc" id="L93">                        this.leftContext = new SubString(str, 0, index);</span>
<span class="fc" id="L94">                        this.lastMatch = new SubString(str, index, slen);</span>
<span class="fc" id="L95">                        this.rightContext = new SubString(str, index + slen, str.length() - index - slen);</span>
<span class="fc" id="L96">                        val = Boolean.TRUE;</span>
<span class="fc" id="L97">                    } else {</span>
<span class="fc" id="L98">                        val = Boolean.FALSE;</span>
                    }
                }

<span class="fc bfc" id="L102" title="All 2 branches covered.">                if (data.charBuf == null) {</span>
<span class="fc bfc" id="L103" title="All 4 branches covered.">                    if (data.global || val == null</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">                        || !val.equals(Boolean.TRUE))</span>
                    {
                        /* Didn't match even once. */
<span class="fc" id="L107">                        return data.str;</span>
                    }
<span class="fc" id="L109">                    SubString lc = this.leftContext;</span>
<span class="fc" id="L110">                    replace_glob(data, cx, scope, this, lc.index, lc.length);</span>
                }
<span class="fc" id="L112">                SubString rc = this.rightContext;</span>
<span class="fc" id="L113">                data.charBuf.append(rc.str, rc.index, rc.index + rc.length);</span>
<span class="fc" id="L114">                return data.charBuf.toString();</span>
            }

          default:
<span class="nc" id="L118">            throw Kit.codeBug();</span>
        }
    }

    private static NativeRegExp createRegExp(Context cx, Scriptable scope,
                                             Object[] args, int optarg,
                                             boolean forceFlat)
    {
        NativeRegExp re;
<span class="fc" id="L127">        Scriptable topScope = ScriptableObject.getTopLevelScope(scope);</span>
<span class="pc bpc" id="L128" title="1 of 4 branches missed.">        if (args.length == 0 || args[0] == Undefined.instance) {</span>
<span class="fc" id="L129">            RECompiled compiled = NativeRegExp.compileRE(cx, &quot;&quot;, &quot;&quot;, false);</span>
<span class="fc" id="L130">            re = new NativeRegExp(topScope, compiled);</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">        } else if (args[0] instanceof NativeRegExp) {</span>
<span class="fc" id="L132">            re = (NativeRegExp) args[0];</span>
        } else {
<span class="fc" id="L134">            String src = ScriptRuntime.toString(args[0]);</span>
            String opt;
<span class="fc bfc" id="L136" title="All 2 branches covered.">            if (optarg &lt; args.length) {</span>
<span class="fc" id="L137">                args[0] = src;</span>
<span class="fc" id="L138">                opt = ScriptRuntime.toString(args[optarg]);</span>
            } else {
<span class="fc" id="L140">                opt = null;</span>
            }
<span class="fc" id="L142">            RECompiled compiled = NativeRegExp.compileRE(cx, src, opt, forceFlat);</span>
<span class="fc" id="L143">            re = new NativeRegExp(topScope, compiled);</span>
        }
<span class="fc" id="L145">        return re;</span>
    }

    /**
     * Analog of C match_or_replace.
     */
    private static Object matchOrReplace(Context cx, Scriptable scope,
                                         Scriptable thisObj, Object[] args,
                                         RegExpImpl reImpl,
                                         GlobData data, NativeRegExp re)
    {
<span class="fc" id="L156">        String str = data.str;</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">        data.global = (re.getFlags() &amp; NativeRegExp.JSREG_GLOB) != 0;</span>
<span class="fc" id="L158">        int[] indexp = { 0 };</span>
<span class="fc" id="L159">        Object result = null;</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">        if (data.mode == RA_SEARCH) {</span>
<span class="fc" id="L161">            result = re.executeRegExp(cx, scope, reImpl,</span>
                                      str, indexp, NativeRegExp.TEST);
<span class="pc bpc" id="L163" title="1 of 4 branches missed.">            if (result != null &amp;&amp; result.equals(Boolean.TRUE))</span>
<span class="fc" id="L164">                result = Integer.valueOf(reImpl.leftContext.length);</span>
            else
<span class="fc" id="L166">                result = Integer.valueOf(-1);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">        } else if (data.global) {</span>
<span class="fc" id="L168">            re.lastIndex = 0d;</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">            for (int count = 0; indexp[0] &lt;= str.length(); count++) {</span>
<span class="fc" id="L170">                result = re.executeRegExp(cx, scope, reImpl,</span>
                                          str, indexp, NativeRegExp.TEST);
<span class="pc bpc" id="L172" title="1 of 4 branches missed.">                if (result == null || !result.equals(Boolean.TRUE))</span>
<span class="nc" id="L173">                    break;</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">                if (data.mode == RA_MATCH) {</span>
<span class="fc" id="L175">                    match_glob(data, cx, scope, count, reImpl);</span>
                } else {
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">                    if (data.mode != RA_REPLACE) Kit.codeBug();</span>
<span class="fc" id="L178">                    SubString lastMatch = reImpl.lastMatch;</span>
<span class="fc" id="L179">                    int leftIndex = data.leftIndex;</span>
<span class="fc" id="L180">                    int leftlen = lastMatch.index - leftIndex;</span>
<span class="fc" id="L181">                    data.leftIndex = lastMatch.index + lastMatch.length;</span>
<span class="fc" id="L182">                    replace_glob(data, cx, scope, reImpl, leftIndex, leftlen);</span>
                }
<span class="fc bfc" id="L184" title="All 2 branches covered.">                if (reImpl.lastMatch.length == 0) {</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">                    if (indexp[0] == str.length())</span>
<span class="fc" id="L186">                        break;</span>
<span class="nc" id="L187">                    indexp[0]++;</span>
                }
            }
        } else {
<span class="fc bfc" id="L191" title="All 2 branches covered.">            result = re.executeRegExp(cx, scope, reImpl, str, indexp,</span>
                                      ((data.mode == RA_REPLACE)
                                       ? NativeRegExp.TEST
                                       : NativeRegExp.MATCH));
        }

<span class="fc" id="L197">        return result;</span>
    }



    public int find_split(Context cx, Scriptable scope, String target,
                          String separator, Scriptable reObj,
                          int[] ip, int[] matchlen,
                          boolean[] matched, String[][] parensp)
    {
<span class="fc" id="L207">        int i = ip[0];</span>
<span class="fc" id="L208">        int length = target.length();</span>
        int result;

<span class="fc" id="L211">        int version = cx.getLanguageVersion();</span>
<span class="fc" id="L212">        NativeRegExp re = (NativeRegExp) reObj;</span>
        again:
        while (true) {  // imitating C label
            /* JS1.2 deviated from Perl by never matching at end of string. */
<span class="fc" id="L216">            int ipsave = ip[0]; // reuse ip to save object creation</span>
<span class="fc" id="L217">            ip[0] = i;</span>
<span class="fc" id="L218">            Object ret = re.executeRegExp(cx, scope, this, target, ip,</span>
                                          NativeRegExp.TEST);
<span class="fc bfc" id="L220" title="All 2 branches covered.">            if (ret != Boolean.TRUE) {</span>
                // Mismatch: ensure our caller advances i past end of string.
<span class="fc" id="L222">                ip[0] = ipsave;</span>
<span class="fc" id="L223">                matchlen[0] = 1;</span>
<span class="fc" id="L224">                matched[0] = false;</span>
<span class="fc" id="L225">                return length;</span>
            }
<span class="fc" id="L227">            i = ip[0];</span>
<span class="fc" id="L228">            ip[0] = ipsave;</span>
<span class="fc" id="L229">            matched[0] = true;</span>

<span class="fc" id="L231">            SubString sep = this.lastMatch;</span>
<span class="fc" id="L232">            matchlen[0] = sep.length;</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">            if (matchlen[0] == 0) {</span>
                /*
                 * Empty string match: never split on an empty
                 * match at the start of a find_split cycle.  Same
                 * rule as for an empty global match in
                 * match_or_replace.
                 */
<span class="fc bfc" id="L240" title="All 2 branches covered.">                if (i == ip[0]) {</span>
                    /*
                     * &quot;Bump-along&quot; to avoid sticking at an empty
                     * match, but don't bump past end of string --
                     * our caller must do that by adding
                     * sep-&gt;length to our return value.
                     */
<span class="fc bfc" id="L247" title="All 2 branches covered.">                    if (i == length) {</span>
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">                        if (version == Context.VERSION_1_2) {</span>
<span class="nc" id="L249">                            matchlen[0] = 1;</span>
<span class="nc" id="L250">                            result = i;</span>
                        }
                        else
<span class="fc" id="L253">                            result = -1;</span>
<span class="fc" id="L254">                        break;</span>
                    }
<span class="fc" id="L256">                    i++;</span>
<span class="fc" id="L257">                    continue again; // imitating C goto</span>
                }
            }
            // PR_ASSERT((size_t)i &gt;= sep-&gt;length);
<span class="fc" id="L261">            result = i - matchlen[0];</span>
<span class="fc" id="L262">            break;</span>
        }
<span class="fc bfc" id="L264" title="All 2 branches covered.">        int size = (parens == null) ? 0 : parens.length;</span>
<span class="fc" id="L265">        parensp[0] = new String[size];</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">        for (int num = 0; num &lt; size; num++) {</span>
<span class="fc" id="L267">            SubString parsub = getParenSubString(num);</span>
<span class="fc" id="L268">            parensp[0][num] = parsub.toString();</span>
        }
<span class="fc" id="L270">        return result;</span>
    }

    /**
     * Analog of REGEXP_PAREN_SUBSTRING in C jsregexp.h.
     * Assumes zero-based; i.e., for $3, i==2
     */
    SubString getParenSubString(int i)
    {
<span class="fc bfc" id="L279" title="All 4 branches covered.">        if (parens != null &amp;&amp; i &lt; parens.length) {</span>
<span class="fc" id="L280">            SubString parsub = parens[i];</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">            if (parsub != null) {</span>
<span class="fc" id="L282">                return parsub;</span>
            }
        }
<span class="fc" id="L285">        return new SubString();</span>
    }

    /*
     * Analog of match_glob() in jsstr.c
     */
    private static void match_glob(GlobData mdata, Context cx,
                                   Scriptable scope, int count,
                                   RegExpImpl reImpl)
    {
<span class="fc bfc" id="L295" title="All 2 branches covered.">        if (mdata.arrayobj == null) {</span>
<span class="fc" id="L296">            mdata.arrayobj = cx.newArray(scope, 0);</span>
        }
<span class="fc" id="L298">        SubString matchsub = reImpl.lastMatch;</span>
<span class="fc" id="L299">        String matchstr = matchsub.toString();</span>
<span class="fc" id="L300">        mdata.arrayobj.put(count, mdata.arrayobj, matchstr);</span>
<span class="fc" id="L301">    }</span>

    /*
     * Analog of replace_glob() in jsstr.c
     */
    private static void replace_glob(GlobData rdata, Context cx,
                                     Scriptable scope, RegExpImpl reImpl,
                                     int leftIndex, int leftlen)
    {
        int replen;
        String lambdaStr;
<span class="fc bfc" id="L312" title="All 2 branches covered.">        if (rdata.lambda != null) {</span>
            // invoke lambda function with args lastMatch, $1, $2, ... $n,
            // leftContext.length, whole string.
<span class="fc" id="L315">            SubString[] parens = reImpl.parens;</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">            int parenCount = (parens == null) ? 0 : parens.length;</span>
<span class="fc" id="L317">            Object[] args = new Object[parenCount + 3];</span>
<span class="fc" id="L318">            args[0] = reImpl.lastMatch.toString();</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">            for (int i=0; i &lt; parenCount; i++) {</span>
<span class="fc" id="L320">                SubString sub = parens[i];</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">                if (sub != null) {</span>
<span class="fc" id="L322">                    args[i+1] = sub.toString();</span>
                } else {
<span class="fc" id="L324">                    args[i+1] = Undefined.instance;</span>
                }
            }
<span class="fc" id="L327">            args[parenCount+1] = Integer.valueOf(reImpl.leftContext.length);</span>
<span class="fc" id="L328">            args[parenCount+2] = rdata.str;</span>
            // This is a hack to prevent expose of reImpl data to
            // JS function which can run new regexps modifing
            // regexp that are used later by the engine.
            // TODO: redesign is necessary
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">            if (reImpl != ScriptRuntime.getRegExpProxy(cx)) Kit.codeBug();</span>
<span class="fc" id="L334">            RegExpImpl re2 = new RegExpImpl();</span>
<span class="fc" id="L335">            re2.multiline = reImpl.multiline;</span>
<span class="fc" id="L336">            re2.input = reImpl.input;</span>
<span class="fc" id="L337">            ScriptRuntime.setRegExpProxy(cx, re2);</span>
            try {
<span class="fc" id="L339">                Scriptable parent = ScriptableObject.getTopLevelScope(scope);</span>
<span class="fc" id="L340">                Object result = rdata.lambda.call(cx, parent, parent, args);</span>
<span class="fc" id="L341">                lambdaStr = ScriptRuntime.toString(result);</span>
            } finally {
<span class="fc" id="L343">                ScriptRuntime.setRegExpProxy(cx, reImpl);</span>
<span class="fc" id="L344">            }</span>
<span class="fc" id="L345">            replen = lambdaStr.length();</span>
<span class="fc" id="L346">        } else {</span>
<span class="fc" id="L347">            lambdaStr = null;</span>
<span class="fc" id="L348">            replen = rdata.repstr.length();</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">            if (rdata.dollar &gt;= 0) {</span>
<span class="fc" id="L350">                int[] skip = new int[1];</span>
<span class="fc" id="L351">                int dp = rdata.dollar;</span>
                do {
<span class="fc" id="L353">                    SubString sub = interpretDollar(cx, reImpl, rdata.repstr,</span>
                                                    dp, skip);
<span class="fc bfc" id="L355" title="All 2 branches covered.">                    if (sub != null) {</span>
<span class="fc" id="L356">                        replen += sub.length - skip[0];</span>
<span class="fc" id="L357">                        dp += skip[0];</span>
                    } else {
<span class="fc" id="L359">                        ++dp;</span>
                    }
<span class="fc" id="L361">                    dp = rdata.repstr.indexOf('$', dp);</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">                } while (dp &gt;= 0);</span>
            }
        }

<span class="fc" id="L366">        int growth = leftlen + replen + reImpl.rightContext.length;</span>
<span class="fc" id="L367">        StringBuilder charBuf = rdata.charBuf;</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">        if (charBuf == null) {</span>
<span class="fc" id="L369">            charBuf = new StringBuilder(growth);</span>
<span class="fc" id="L370">            rdata.charBuf = charBuf;</span>
        } else {
<span class="fc" id="L372">            charBuf.ensureCapacity(rdata.charBuf.length() + growth);</span>
        }

<span class="fc" id="L375">        charBuf.append(reImpl.leftContext.str, leftIndex, leftIndex + leftlen);</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">        if (rdata.lambda != null) {</span>
<span class="fc" id="L377">            charBuf.append(lambdaStr);</span>
        } else {
<span class="fc" id="L379">            do_replace(rdata, cx, reImpl);</span>
        }
<span class="fc" id="L381">    }</span>

    private static SubString interpretDollar(Context cx, RegExpImpl res,
                                             String da, int dp, int[] skip)
    {
        char dc;
        int num, tmp;

<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        if (da.charAt(dp) != '$') Kit.codeBug();</span>

        /* Allow a real backslash (literal &quot;\\&quot;) to escape &quot;$1&quot; etc. */
<span class="fc" id="L392">        int version = cx.getLanguageVersion();</span>
<span class="pc bpc" id="L393" title="2 of 4 branches missed.">        if (version != Context.VERSION_DEFAULT</span>
            &amp;&amp; version &lt;= Context.VERSION_1_4)
        {
<span class="nc bnc" id="L396" title="All 4 branches missed.">            if (dp &gt; 0 &amp;&amp; da.charAt(dp - 1) == '\\')</span>
<span class="nc" id="L397">                return null;</span>
        }
<span class="fc" id="L399">        int daL = da.length();</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">        if (dp + 1 &gt;= daL)</span>
<span class="fc" id="L401">            return null;</span>
        /* Interpret all Perl match-induced dollar variables. */
<span class="fc" id="L403">        dc = da.charAt(dp + 1);</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">        if (NativeRegExp.isDigit(dc)) {</span>
            int cp;
<span class="pc bpc" id="L406" title="2 of 4 branches missed.">            if (version != Context.VERSION_DEFAULT</span>
                &amp;&amp; version &lt;= Context.VERSION_1_4)
            {
<span class="nc bnc" id="L409" title="All 2 branches missed.">                if (dc == '0')</span>
<span class="nc" id="L410">                    return null;</span>
                /* Check for overflow to avoid gobbling arbitrary decimal digits. */
<span class="nc" id="L412">                num = 0;</span>
<span class="nc" id="L413">                cp = dp;</span>
<span class="nc bnc" id="L414" title="All 4 branches missed.">                while (++cp &lt; daL &amp;&amp; NativeRegExp.isDigit(dc = da.charAt(cp)))</span>
                {
<span class="nc" id="L416">                    tmp = 10 * num + (dc - '0');</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">                    if (tmp &lt; num)</span>
<span class="nc" id="L418">                        break;</span>
<span class="nc" id="L419">                    num = tmp;</span>
                }
            }
            else {  /* ECMA 3, 1-9 or 01-99 */
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">                int parenCount = (res.parens == null) ? 0 : res.parens.length;</span>
<span class="fc" id="L424">                num = dc - '0';</span>
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">                if (num &gt; parenCount)</span>
<span class="nc" id="L426">                    return null;</span>
<span class="fc" id="L427">                cp = dp + 2;</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">                if ((dp + 2) &lt; daL) {</span>
<span class="fc" id="L429">                    dc = da.charAt(dp + 2);</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">                    if (NativeRegExp.isDigit(dc)) {</span>
<span class="fc" id="L431">                        tmp = 10 * num + (dc - '0');</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">                        if (tmp &lt;= parenCount) {</span>
<span class="nc" id="L433">                            cp++;</span>
<span class="nc" id="L434">                            num = tmp;</span>
                        }
                    }
                }
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">                if (num == 0) return null;  /* $0 or $00 is not valid */</span>
            }
            /* Adjust num from 1 $n-origin to 0 array-index-origin. */
<span class="fc" id="L441">            num--;</span>
<span class="fc" id="L442">            skip[0] = cp - dp;</span>
<span class="fc" id="L443">            return res.getParenSubString(num);</span>
        }

<span class="nc" id="L446">        skip[0] = 2;</span>
<span class="nc bnc" id="L447" title="All 6 branches missed.">        switch (dc) {</span>
          case '$':
<span class="nc" id="L449">            return new SubString(&quot;$&quot;);</span>
          case '&amp;':
<span class="nc" id="L451">            return res.lastMatch;</span>
          case '+':
<span class="nc" id="L453">            return res.lastParen;</span>
          case '`':
<span class="nc bnc" id="L455" title="All 2 branches missed.">            if (version == Context.VERSION_1_2) {</span>
                /*
                 * JS1.2 imitated the Perl4 bug where left context at each step
                 * in an iterative use of a global regexp started from last match,
                 * not from the start of the target string.  But Perl4 does start
                 * $` at the beginning of the target string when it is used in a
                 * substitution, so we emulate that special case here.
                 */
<span class="nc" id="L463">                res.leftContext.index = 0;</span>
<span class="nc" id="L464">                res.leftContext.length = res.lastMatch.index;</span>
            }
<span class="nc" id="L466">            return res.leftContext;</span>
          case '\'':
<span class="nc" id="L468">            return res.rightContext;</span>
        }
<span class="nc" id="L470">        return null;</span>
    }

    /**
     * Analog of do_replace in jsstr.c
     */
    private static void do_replace(GlobData rdata, Context cx,
                                   RegExpImpl regExpImpl)
    {
<span class="fc" id="L479">        StringBuilder charBuf = rdata.charBuf;</span>
<span class="fc" id="L480">        int cp = 0;</span>
<span class="fc" id="L481">        String da = rdata.repstr;</span>
<span class="fc" id="L482">        int dp = rdata.dollar;</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">        if (dp != -1) {</span>
<span class="fc" id="L484">            int[] skip = new int[1];</span>
            do {
<span class="fc" id="L486">                int len = dp - cp;</span>
<span class="fc" id="L487">                charBuf.append(da.substring(cp, dp));</span>
<span class="fc" id="L488">                cp = dp;</span>
<span class="fc" id="L489">                SubString sub = interpretDollar(cx, regExpImpl, da,</span>
                                                dp, skip);
<span class="fc bfc" id="L491" title="All 2 branches covered.">                if (sub != null) {</span>
<span class="fc" id="L492">                    len = sub.length;</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">                    if (len &gt; 0) {</span>
<span class="fc" id="L494">                        charBuf.append(sub.str, sub.index, sub.index + len);</span>
                    }
<span class="fc" id="L496">                    cp += skip[0];</span>
<span class="fc" id="L497">                    dp += skip[0];</span>
                } else {
<span class="fc" id="L499">                    ++dp;</span>
                }
<span class="fc" id="L501">                dp = da.indexOf('$', dp);</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">            } while (dp &gt;= 0);</span>
        }
<span class="fc" id="L504">        int daL = da.length();</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">        if (daL &gt; cp) {</span>
<span class="fc" id="L506">            charBuf.append(da.substring(cp, daL));</span>
        }
<span class="fc" id="L508">    }</span>

    /*
     * See ECMA 15.5.4.8.  Modified to match JS 1.2 - optionally takes
     * a limit argument and accepts a regular expression as the split
     * argument.
     */
    public Object js_split(Context cx, Scriptable scope,
                                   String target, Object[] args)
    {
        // create an empty Array to return;
<span class="fc" id="L519">        Scriptable result = cx.newArray(scope, 0);</span>

        // Use the second argument as the split limit, if given.
<span class="fc bfc" id="L522" title="All 4 branches covered.">        boolean limited = (args.length &gt; 1) &amp;&amp; (args[1] != Undefined.instance);</span>
<span class="fc" id="L523">        long limit = 0;  // Initialize to avoid warning.</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">        if (limited) {</span>
            /* Clamp limit between 0 and 1 + string length. */
<span class="fc" id="L526">            limit = ScriptRuntime.toUint32(args[1]);</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">            if (limit &gt; target.length())</span>
<span class="fc" id="L528">                limit = 1 + target.length();</span>
        }

        // return an array consisting of the target if no separator given
<span class="fc bfc" id="L532" title="All 4 branches covered.">        if (args.length &lt; 1 || args[0] == Undefined.instance) {</span>
<span class="fc" id="L533">            result.put(0, result, target);</span>
<span class="fc" id="L534">            return result;</span>
        }

<span class="fc" id="L537">        String separator = null;</span>
<span class="fc" id="L538">        int[] matchlen = new int[1];</span>
<span class="fc" id="L539">        Scriptable re = null;</span>
<span class="fc" id="L540">        RegExpProxy reProxy = null;</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">        if (args[0] instanceof Scriptable) {</span>
<span class="fc" id="L542">            reProxy = ScriptRuntime.getRegExpProxy(cx);</span>
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">            if (reProxy != null) {</span>
<span class="fc" id="L544">                Scriptable test = (Scriptable)args[0];</span>
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">                if (reProxy.isRegExp(test)) {</span>
<span class="fc" id="L546">                    re = test;</span>
                }
            }
        }
<span class="fc bfc" id="L550" title="All 2 branches covered.">        if (re == null) {</span>
<span class="fc" id="L551">            separator = ScriptRuntime.toString(args[0]);</span>
<span class="fc" id="L552">            matchlen[0] = separator.length();</span>
        }

        // split target with separator or re
<span class="fc" id="L556">        int[] ip = { 0 };</span>
        int match;
<span class="fc" id="L558">        int len = 0;</span>
<span class="fc" id="L559">        boolean[] matched = { false };</span>
<span class="fc" id="L560">        String[][] parens = { null };</span>
<span class="fc" id="L561">        int version = cx.getLanguageVersion();</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">        while ((match = find_split(cx, scope, target, separator, version,</span>
                                   reProxy, re, ip, matchlen, matched, parens))
               &gt;= 0)
        {
<span class="pc bpc" id="L566" title="1 of 6 branches missed.">            if ((limited &amp;&amp; len &gt;= limit) || (match &gt; target.length()))</span>
<span class="nc" id="L567">                break;</span>

            String substr;
<span class="fc bfc" id="L570" title="All 2 branches covered.">            if (target.length() == 0)</span>
<span class="fc" id="L571">                substr = target;</span>
            else
<span class="fc" id="L573">                substr = target.substring(ip[0], match);</span>

<span class="fc" id="L575">            result.put(len, result, substr);</span>
<span class="fc" id="L576">            len++;</span>
        /*
         * Imitate perl's feature of including parenthesized substrings
         * that matched part of the delimiter in the new array, after the
         * split substring that was delimited.
         */
<span class="fc bfc" id="L582" title="All 4 branches covered.">            if (re != null &amp;&amp; matched[0]) {</span>
<span class="fc" id="L583">                int size = parens[0].length;</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">                for (int num = 0; num &lt; size; num++) {</span>
<span class="pc bpc" id="L585" title="3 of 4 branches missed.">                    if (limited &amp;&amp; len &gt;= limit)</span>
<span class="nc" id="L586">                        break;</span>
<span class="fc" id="L587">                    result.put(len, result, parens[0][num]);</span>
<span class="fc" id="L588">                    len++;</span>
                }
<span class="fc" id="L590">                matched[0] = false;</span>
            }
<span class="fc" id="L592">            ip[0] = match + matchlen[0];</span>

<span class="fc bfc" id="L594" title="All 4 branches covered.">            if (version &lt; Context.VERSION_1_3</span>
                &amp;&amp; version != Context.VERSION_DEFAULT)
            {
        /*
         * Deviate from ECMA to imitate Perl, which omits a final
         * split unless a limit argument is given and big enough.
         */
<span class="fc bfc" id="L601" title="All 4 branches covered.">                if (!limited &amp;&amp; ip[0] == target.length())</span>
<span class="fc" id="L602">                    break;</span>
            }
<span class="fc" id="L604">        }</span>
<span class="fc" id="L605">        return result;</span>
    }

    /*
     * Used by js_split to find the next split point in target,
     * starting at offset ip and looking either for the given
     * separator substring, or for the next re match.  ip and
     * matchlen must be reference variables (assumed to be arrays of
     * length 1) so they can be updated in the leading whitespace or
     * re case.
     *
     * Return -1 on end of string, &gt;= 0 for a valid index of the next
     * separator occurrence if found, or the string length if no
     * separator is found.
     */
    private static int find_split(Context cx, Scriptable scope, String target,
                                  String separator, int version,
                                  RegExpProxy reProxy, Scriptable re,
                                  int[] ip, int[] matchlen, boolean[] matched,
                                  String[][] parensp)
    {
<span class="fc" id="L626">        int i = ip[0];</span>
<span class="fc" id="L627">        int length = target.length();</span>

        /*
         * Perl4 special case for str.split(' '), only if the user has selected
         * JavaScript1.2 explicitly.  Split on whitespace, and skip leading w/s.
         * Strange but true, apparently modeled after awk.
         */
<span class="fc bfc" id="L634" title="All 4 branches covered.">        if (version == Context.VERSION_1_2 &amp;&amp;</span>
<span class="pc bpc" id="L635" title="1 of 4 branches missed.">            re == null &amp;&amp; separator.length() == 1 &amp;&amp; separator.charAt(0) == ' ')</span>
        {
            /* Skip leading whitespace if at front of str. */
<span class="nc bnc" id="L638" title="All 2 branches missed.">            if (i == 0) {</span>
<span class="nc bnc" id="L639" title="All 4 branches missed.">                while (i &lt; length &amp;&amp; Character.isWhitespace(target.charAt(i)))</span>
<span class="nc" id="L640">                    i++;</span>
<span class="nc" id="L641">                ip[0] = i;</span>
            }

            /* Don't delimit whitespace at end of string. */
<span class="nc bnc" id="L645" title="All 2 branches missed.">            if (i == length)</span>
<span class="nc" id="L646">                return -1;</span>

            /* Skip over the non-whitespace chars. */
<span class="nc bnc" id="L649" title="All 2 branches missed.">            while (i &lt; length</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">                   &amp;&amp; !Character.isWhitespace(target.charAt(i)))</span>
<span class="nc" id="L651">                i++;</span>

            /* Now skip the next run of whitespace. */
<span class="nc" id="L654">            int j = i;</span>
<span class="nc bnc" id="L655" title="All 4 branches missed.">            while (j &lt; length &amp;&amp; Character.isWhitespace(target.charAt(j)))</span>
<span class="nc" id="L656">                j++;</span>

            /* Update matchlen to count delimiter chars. */
<span class="nc" id="L659">            matchlen[0] = j - i;</span>
<span class="nc" id="L660">            return i;</span>
        }

        /*
         * Stop if past end of string.  If at end of string, we will
         * return target length, so that
         *
         *  &quot;ab,&quot;.split(',') =&gt; new Array(&quot;ab&quot;, &quot;&quot;)
         *
         * and the resulting array converts back to the string &quot;ab,&quot;
         * for symmetry.  NB: This differs from perl, which drops the
         * trailing empty substring if the LIMIT argument is omitted.
         */
<span class="fc bfc" id="L673" title="All 2 branches covered.">        if (i &gt; length)</span>
<span class="fc" id="L674">            return -1;</span>

        /*
         * Match a regular expression against the separator at or
         * above index i.  Return -1 at end of string instead of
         * trying for a match, so we don't get stuck in a loop.
         */
<span class="fc bfc" id="L681" title="All 2 branches covered.">        if (re != null) {</span>
<span class="fc" id="L682">            return reProxy.find_split(cx, scope, target, separator, re,</span>
                                      ip, matchlen, matched, parensp);
        }

        /*
         * Deviate from ECMA by never splitting an empty string by any separator
         * string into a non-empty array (an array of length 1 that contains the
         * empty string).
         */
<span class="pc bpc" id="L691" title="1 of 6 branches missed.">        if (version != Context.VERSION_DEFAULT &amp;&amp; version &lt; Context.VERSION_1_3</span>
            &amp;&amp; length == 0)
<span class="fc" id="L693">            return -1;</span>

        /*
         * Special case: if sep is the empty string, split str into
         * one character substrings.  Let our caller worry about
         * whether to split once at end of string into an empty
         * substring.
         *
         * For 1.2 compatibility, at the end of the string, we return the length as
         * the result, and set the separator length to 1 -- this allows the caller
         * to include an additional null string at the end of the substring list.
         */
<span class="fc bfc" id="L705" title="All 2 branches covered.">        if (separator.length() == 0) {</span>
<span class="pc bpc" id="L706" title="1 of 2 branches missed.">            if (version == Context.VERSION_1_2) {</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">                if (i == length) {</span>
<span class="nc" id="L708">                    matchlen[0] = 1;</span>
<span class="nc" id="L709">                    return i;</span>
                }
<span class="nc" id="L711">                return i + 1;</span>
            }
<span class="fc bfc" id="L713" title="All 2 branches covered.">            return (i == length) ? -1 : i + 1;</span>
        }

        /* Punt to j.l.s.indexOf; return target length if separator is
         * not found.
         */
<span class="fc bfc" id="L719" title="All 2 branches covered.">        if (ip[0] &gt;= length)</span>
<span class="fc" id="L720">            return length;</span>

<span class="fc" id="L722">        i = target.indexOf(separator, ip[0]);</span>

<span class="fc bfc" id="L724" title="All 2 branches covered.">        return (i != -1) ? i : length;</span>
    }

    protected String          input;         /* input string to match (perl $_, GC root) */
    protected boolean         multiline;     /* whether input contains newlines (perl $*) */
    protected SubString[]     parens;        /* Vector of SubString; last set of parens
                                      matched (perl $1, $2) */
    protected SubString       lastMatch;     /* last string matched (perl $&amp;) */
    protected SubString       lastParen;     /* last paren matched (perl $+) */
    protected SubString       leftContext;   /* input to left of last match (perl $`) */
    protected SubString       rightContext;  /* input to right of last match (perl $') */
}


<span class="fc" id="L738">final class GlobData</span>
{
    int      mode;      /* input: return index, match object, or void */
    boolean  global;    /* output: whether regexp was global */
    String   str;       /* output: 'this' parameter object as string */

    // match-specific data

    Scriptable arrayobj;

    // replace-specific data

    Function      lambda;        /* replacement function object or null */
    String        repstr;        /* replacement string */
<span class="fc" id="L752">    int           dollar = -1;   /* -1 or index of first $ in repstr */</span>
    StringBuilder charBuf;       /* result characters, null initially */
    int           leftIndex;     /* leftContext index, always 0 for JS1.2 */
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>