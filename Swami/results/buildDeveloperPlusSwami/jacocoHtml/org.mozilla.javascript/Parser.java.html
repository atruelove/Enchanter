<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Parser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rhino-Rhino1_7_9_Release</a> &gt; <a href="index.source.html" class="el_package">org.mozilla.javascript</a> &gt; <span class="el_source">Parser.java</span></div><h1>Parser.java</h1><pre class="source lang-java linenums">/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.javascript;

import org.mozilla.javascript.ast.ArrayComprehension;
import org.mozilla.javascript.ast.ArrayComprehensionLoop;
import org.mozilla.javascript.ast.ArrayLiteral;
import org.mozilla.javascript.ast.Assignment;
import org.mozilla.javascript.ast.AstNode;
import org.mozilla.javascript.ast.AstRoot;
import org.mozilla.javascript.ast.Block;
import org.mozilla.javascript.ast.BreakStatement;
import org.mozilla.javascript.ast.CatchClause;
import org.mozilla.javascript.ast.Comment;
import org.mozilla.javascript.ast.ConditionalExpression;
import org.mozilla.javascript.ast.ContinueStatement;
import org.mozilla.javascript.ast.DestructuringForm;
import org.mozilla.javascript.ast.DoLoop;
import org.mozilla.javascript.ast.ElementGet;
import org.mozilla.javascript.ast.EmptyExpression;
import org.mozilla.javascript.ast.EmptyStatement;
import org.mozilla.javascript.ast.ErrorNode;
import org.mozilla.javascript.ast.ExpressionStatement;
import org.mozilla.javascript.ast.ForInLoop;
import org.mozilla.javascript.ast.ForLoop;
import org.mozilla.javascript.ast.FunctionCall;
import org.mozilla.javascript.ast.FunctionNode;
import org.mozilla.javascript.ast.GeneratorExpression;
import org.mozilla.javascript.ast.GeneratorExpressionLoop;
import org.mozilla.javascript.ast.IdeErrorReporter;
import org.mozilla.javascript.ast.IfStatement;
import org.mozilla.javascript.ast.InfixExpression;
import org.mozilla.javascript.ast.Jump;
import org.mozilla.javascript.ast.KeywordLiteral;
import org.mozilla.javascript.ast.Label;
import org.mozilla.javascript.ast.LabeledStatement;
import org.mozilla.javascript.ast.LetNode;
import org.mozilla.javascript.ast.Loop;
import org.mozilla.javascript.ast.Name;
import org.mozilla.javascript.ast.NewExpression;
import org.mozilla.javascript.ast.NumberLiteral;
import org.mozilla.javascript.ast.ObjectLiteral;
import org.mozilla.javascript.ast.ObjectProperty;
import org.mozilla.javascript.ast.ParenthesizedExpression;
import org.mozilla.javascript.ast.PropertyGet;
import org.mozilla.javascript.ast.RegExpLiteral;
import org.mozilla.javascript.ast.ReturnStatement;
import org.mozilla.javascript.ast.Scope;
import org.mozilla.javascript.ast.ScriptNode;
import org.mozilla.javascript.ast.StringLiteral;
import org.mozilla.javascript.ast.SwitchCase;
import org.mozilla.javascript.ast.SwitchStatement;
import org.mozilla.javascript.ast.Symbol;
import org.mozilla.javascript.ast.ThrowStatement;
import org.mozilla.javascript.ast.TryStatement;
import org.mozilla.javascript.ast.UnaryExpression;
import org.mozilla.javascript.ast.VariableDeclaration;
import org.mozilla.javascript.ast.VariableInitializer;
import org.mozilla.javascript.ast.WhileLoop;
import org.mozilla.javascript.ast.WithStatement;
import org.mozilla.javascript.ast.XmlDotQuery;
import org.mozilla.javascript.ast.XmlElemRef;
import org.mozilla.javascript.ast.XmlExpression;
import org.mozilla.javascript.ast.XmlLiteral;
import org.mozilla.javascript.ast.XmlMemberGet;
import org.mozilla.javascript.ast.XmlPropRef;
import org.mozilla.javascript.ast.XmlRef;
import org.mozilla.javascript.ast.XmlString;
import org.mozilla.javascript.ast.Yield;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;

/**
 * This class implements the JavaScript parser.&lt;p&gt;
 *
 * It is based on the SpiderMonkey C source files jsparse.c and jsparse.h in the
 * jsref package.&lt;p&gt;
 *
 * The parser generates an {@link AstRoot} parse tree representing the source
 * code.  No tree rewriting is permitted at this stage, so that the parse tree
 * is a faithful representation of the source for frontend processing tools and
 * IDEs.&lt;p&gt;
 *
 * This parser implementation is not intended to be reused after a parse
 * finishes, and will throw an IllegalStateException() if invoked again.&lt;p&gt;
 *
 * @see TokenStream
 *
 * @author Mike McCabe
 * @author Brendan Eich
 */
public class Parser
{
    /**
     * Maximum number of allowed function or constructor arguments,
     * to follow SpiderMonkey.
     */
    public static final int ARGC_LIMIT = 1 &lt;&lt; 16;

    // TokenInformation flags : currentFlaggedToken stores them together
    // with token type
    final static int
        CLEAR_TI_MASK    = 0xFFFF,  // mask to clear token information bits
        TI_AFTER_EOL     = 1 &lt;&lt; 16, // first token of the source line
        TI_CHECK_LABEL   = 1 &lt;&lt; 17; // indicates to check for label

    CompilerEnvirons compilerEnv;
    private ErrorReporter errorReporter;
    private IdeErrorReporter errorCollector;
    private String sourceURI;
    private char[] sourceChars;

    boolean calledByCompileFunction;  // ugly - set directly by Context
    private boolean parseFinished;  // set when finished to prevent reuse

    private TokenStream ts;
<span class="fc" id="L130">    private int currentFlaggedToken = Token.EOF;</span>
    private int currentToken;
    private int syntaxErrorCount;

    private List&lt;Comment&gt; scannedComments;
    private Comment currentJsDocComment;

    protected int nestingOfFunction;
    private LabeledStatement currentLabel;
    private boolean inDestructuringAssignment;
    protected boolean inUseStrictDirective;

    // The following are per function variables and should be saved/restored
    // during function parsing.  See PerFunctionVariables class below.
    ScriptNode currentScriptOrFn;
    Scope currentScope;
    private int endFlags;
    private boolean inForInit;  // bound temporarily during forStatement()
    private Map&lt;String,LabeledStatement&gt; labelSet;
    private List&lt;Loop&gt; loopSet;
    private List&lt;Jump&gt; loopAndSwitchSet;
    // end of per function variables

    // Lacking 2-token lookahead, labels become a problem.
    // These vars store the token info of the last matched name,
    // iff it wasn't the last matched token.
    private int prevNameTokenStart;
<span class="fc" id="L157">    private String prevNameTokenString = &quot;&quot;;</span>
    private int prevNameTokenLineno;

    private boolean defaultUseStrictDirective;

    // Exception to unwind
<span class="fc" id="L163">    private static class ParserException extends RuntimeException</span>
    {
        static final long serialVersionUID = 5882582646773765630L;
    }

    public Parser() {
<span class="fc" id="L169">        this(new CompilerEnvirons());</span>
<span class="fc" id="L170">    }</span>

    public Parser(CompilerEnvirons compilerEnv) {
<span class="fc" id="L173">        this(compilerEnv, compilerEnv.getErrorReporter());</span>
<span class="fc" id="L174">    }</span>

<span class="fc" id="L176">    public Parser(CompilerEnvirons compilerEnv, ErrorReporter errorReporter) {</span>
<span class="fc" id="L177">        this.compilerEnv = compilerEnv;</span>
<span class="fc" id="L178">        this.errorReporter = errorReporter;</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (errorReporter instanceof IdeErrorReporter) {</span>
<span class="fc" id="L180">            errorCollector = (IdeErrorReporter)errorReporter;</span>
        }
<span class="fc" id="L182">    }</span>

    // Add a strict warning on the last matched token.
    void addStrictWarning(String messageId, String messageArg) {
<span class="fc" id="L186">        int beg = -1, end = -1;</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">        if (ts != null) {</span>
<span class="fc" id="L188">            beg = ts.tokenBeg;</span>
<span class="fc" id="L189">            end = ts.tokenEnd - ts.tokenBeg;</span>
        }
<span class="fc" id="L191">        addStrictWarning(messageId, messageArg, beg, end);</span>
<span class="fc" id="L192">    }</span>

    void addStrictWarning(String messageId, String messageArg,
                          int position, int length) {
<span class="fc bfc" id="L196" title="All 2 branches covered.">        if (compilerEnv.isStrictMode())</span>
<span class="fc" id="L197">            addWarning(messageId, messageArg, position, length);</span>
<span class="fc" id="L198">    }</span>

    void addWarning(String messageId, String messageArg) {
<span class="fc" id="L201">        int beg = -1, end = -1;</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">        if (ts != null) {</span>
<span class="fc" id="L203">            beg = ts.tokenBeg;</span>
<span class="fc" id="L204">            end = ts.tokenEnd - ts.tokenBeg;</span>
        }
<span class="fc" id="L206">        addWarning(messageId, messageArg, beg, end);</span>
<span class="fc" id="L207">    }</span>

    void addWarning(String messageId, int position, int length) {
<span class="nc" id="L210">        addWarning(messageId, null, position, length);</span>
<span class="nc" id="L211">    }</span>

    void addWarning(String messageId, String messageArg,
                    int position, int length)
    {
<span class="fc" id="L216">        String message = lookupMessage(messageId, messageArg);</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">        if (compilerEnv.reportWarningAsError()) {</span>
<span class="nc" id="L218">            addError(messageId, messageArg, position, length);</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">        } else if (errorCollector != null) {</span>
<span class="fc" id="L220">            errorCollector.warning(message, sourceURI, position, length);</span>
        } else {
<span class="fc" id="L222">            errorReporter.warning(message, sourceURI, ts.getLineno(),</span>
<span class="fc" id="L223">                                  ts.getLine(), ts.getOffset());</span>
        }
<span class="fc" id="L225">    }</span>

    void addError(String messageId) {
<span class="nc" id="L228">        addError(messageId, ts.tokenBeg, ts.tokenEnd - ts.tokenBeg);</span>
<span class="nc" id="L229">    }</span>

    void addError(String messageId, int position, int length) {
<span class="nc" id="L232">        addError(messageId, null, position, length);</span>
<span class="nc" id="L233">    }</span>

    void addError(String messageId, String messageArg) {
<span class="nc" id="L236">        addError(messageId, messageArg, ts.tokenBeg,</span>
                 ts.tokenEnd - ts.tokenBeg);
<span class="nc" id="L238">    }</span>

    void addError(String messageId, int c) {
<span class="fc" id="L241">        String messageArg = Character.toString ((char) c);</span>
<span class="nc" id="L242">        addError(messageId, messageArg, ts.tokenBeg,</span>
                 ts.tokenEnd - ts.tokenBeg);
<span class="nc" id="L244">    }</span>

    void addError(String messageId, String messageArg, int position, int length)
    {
<span class="fc" id="L248">        ++syntaxErrorCount;</span>
<span class="fc" id="L249">        String message = lookupMessage(messageId, messageArg);</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        if (errorCollector != null) {</span>
<span class="nc" id="L251">            errorCollector.error(message, sourceURI, position, length);</span>
        } else {
<span class="fc" id="L253">            int lineno = 1, offset = 1;</span>
<span class="fc" id="L254">            String line = &quot;&quot;;</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">            if (ts != null) {  // happens in some regression tests</span>
<span class="fc" id="L256">                lineno = ts.getLineno();</span>
<span class="fc" id="L257">                line = ts.getLine();</span>
<span class="fc" id="L258">                offset = ts.getOffset();</span>
            }
<span class="fc" id="L260">            errorReporter.error(message, sourceURI, lineno, line, offset);</span>
        }
<span class="fc" id="L262">    }</span>

    private void addStrictWarning(String messageId, String messageArg,
                                  int position, int length,
                                  int line, String lineSource, int lineOffset) {
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">        if (compilerEnv.isStrictMode()) {</span>
<span class="fc" id="L268">            addWarning(messageId, messageArg, position, length, line, lineSource, lineOffset);</span>
        }
<span class="fc" id="L270">    }</span>

    private void addWarning(String messageId, String messageArg,
                            int position, int length,
                            int line, String lineSource, int lineOffset) {
<span class="fc" id="L275">        String message = lookupMessage(messageId, messageArg);</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">        if (compilerEnv.reportWarningAsError()) {</span>
<span class="nc" id="L277">            addError(messageId, messageArg, position, length, line, lineSource, lineOffset);</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">        } else if (errorCollector != null) {</span>
<span class="fc" id="L279">            errorCollector.warning(message, sourceURI, position, length);</span>
        } else {
<span class="fc" id="L281">            errorReporter.warning(message, sourceURI, line, lineSource, lineOffset);</span>
        }
<span class="fc" id="L283">    }</span>

    private void addError(String messageId, String messageArg,
                          int position, int length,
                          int line, String lineSource, int lineOffset) {
<span class="nc" id="L288">        ++syntaxErrorCount;</span>
<span class="nc" id="L289">        String message = lookupMessage(messageId, messageArg);</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">        if (errorCollector != null) {</span>
<span class="nc" id="L291">            errorCollector.error(message, sourceURI, position, length);</span>
        } else {
<span class="nc" id="L293">            errorReporter.error(message, sourceURI, line, lineSource, lineOffset);</span>
        }
<span class="nc" id="L295">    }</span>

    String lookupMessage(String messageId) {
<span class="fc" id="L298">        return lookupMessage(messageId, null);</span>
    }

    String lookupMessage(String messageId, String messageArg) {
<span class="fc bfc" id="L302" title="All 2 branches covered.">        return messageArg == null</span>
<span class="fc" id="L303">            ? ScriptRuntime.getMessage0(messageId)</span>
<span class="fc" id="L304">            : ScriptRuntime.getMessage1(messageId, messageArg);</span>
    }

    void reportError(String messageId) {
<span class="fc" id="L308">        reportError(messageId, null);</span>
<span class="fc" id="L309">    }</span>

    void reportError(String messageId, String messageArg) {
<span class="fc bfc" id="L312" title="All 2 branches covered.">        if (ts == null) {  // happens in some regression tests</span>
<span class="nc" id="L313">            reportError(messageId, messageArg, 1, 1);</span>
        } else {
<span class="fc" id="L315">            reportError(messageId, messageArg, ts.tokenBeg,</span>
                        ts.tokenEnd - ts.tokenBeg);
        }
<span class="fc" id="L318">    }</span>

    void reportError(String messageId, int position, int length)
    {
<span class="nc" id="L322">        reportError(messageId, null, position, length);</span>
<span class="nc" id="L323">    }</span>

    void reportError(String messageId, String messageArg, int position,
                     int length)
    {
<span class="fc" id="L328">        addError(messageId, messageArg, position, length);</span>

<span class="fc bfc" id="L330" title="All 2 branches covered.">        if (!compilerEnv.recoverFromErrors()) {</span>
<span class="fc" id="L331">            throw new ParserException();</span>
        }
<span class="fc" id="L333">    }</span>

    // Computes the absolute end offset of node N.
    // Use with caution!  Assumes n.getPosition() is -absolute-, which
    // is only true before the node is added to its parent.
    private int getNodeEnd(AstNode n) {
<span class="fc" id="L339">        return n.getPosition() + n.getLength();</span>
    }

    private void recordComment(int lineno, String comment) {
<span class="fc bfc" id="L343" title="All 2 branches covered.">        if (scannedComments == null) {</span>
<span class="fc" id="L344">            scannedComments = new ArrayList&lt;Comment&gt;();</span>
        }
<span class="fc" id="L346">        Comment commentNode = new Comment(ts.tokenBeg,</span>
<span class="fc" id="L347">                                          ts.getTokenLength(),</span>
                                          ts.commentType,
                                          comment);
<span class="fc bfc" id="L350" title="All 2 branches covered.">        if (ts.commentType == Token.CommentType.JSDOC &amp;&amp;</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">            compilerEnv.isRecordingLocalJsDocComments()) {</span>
<span class="fc" id="L352">            currentJsDocComment = commentNode;</span>
        }
<span class="fc" id="L354">        commentNode.setLineno(lineno);</span>
<span class="fc" id="L355">        scannedComments.add(commentNode);</span>
<span class="fc" id="L356">    }</span>

    private Comment getAndResetJsDoc() {
<span class="fc" id="L359">        Comment saved = currentJsDocComment;</span>
<span class="fc" id="L360">        currentJsDocComment = null;</span>
<span class="fc" id="L361">        return saved;</span>
    }


    private int getNumberOfEols(String comment) {
<span class="fc" id="L366">      int lines = 0;</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">      for (int i = comment.length()-1; i &gt;= 0; i--) {</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">        if (comment.charAt(i) == '\n') {</span>
<span class="fc" id="L369">          lines++;</span>
        }
      }
<span class="fc" id="L372">      return lines;</span>
    }


    // Returns the next token without consuming it.
    // If previous token was consumed, calls scanner to get new token.
    // If previous token was -not- consumed, returns it (idempotent).
    //
    // This function will not return a newline (Token.EOL - instead, it
    // gobbles newlines until it finds a non-newline token, and flags
    // that token as appearing just after a newline.
    //
    // This function will also not return a Token.COMMENT.  Instead, it
    // records comments in the scannedComments list.  If the token
    // returned by this function immediately follows a jsdoc comment,
    // the token is flagged as such.
    //
    // Note that this function always returned the un-flagged token!
    // The flags, if any, are saved in currentFlaggedToken.
    private int peekToken()
        throws IOException
    {
        // By far the most common case:  last token hasn't been consumed,
        // so return already-peeked token.
<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (currentFlaggedToken != Token.EOF) {</span>
<span class="fc" id="L397">            return currentToken;</span>
        }

<span class="fc" id="L400">        int lineno = ts.getLineno();</span>
<span class="fc" id="L401">        int tt = ts.getToken();</span>
<span class="fc" id="L402">        boolean sawEOL = false;</span>

        // process comments and whitespace
<span class="fc bfc" id="L405" title="All 4 branches covered.">        while (tt == Token.EOL || tt == Token.COMMENT) {</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">            if (tt == Token.EOL) {</span>
<span class="fc" id="L407">                lineno++;</span>
<span class="fc" id="L408">                sawEOL = true;</span>
            } else {
<span class="fc bfc" id="L410" title="All 2 branches covered.">                if (compilerEnv.isRecordingComments()) {</span>
<span class="fc" id="L411">                    String comment = ts.getAndResetCurrentComment();</span>
<span class="fc" id="L412">                    recordComment(lineno, comment);</span>
                    // Comments may contain multiple lines, get the number
                    // of EoLs and increase the lineno
<span class="fc" id="L415">                    lineno += getNumberOfEols(comment);</span>
                }
            }
<span class="fc" id="L418">            tt = ts.getToken();</span>
        }

<span class="fc" id="L421">        currentToken = tt;</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">        currentFlaggedToken = tt | (sawEOL ? TI_AFTER_EOL : 0);</span>
<span class="fc" id="L423">        return currentToken;  // return unflagged token</span>
    }

    private int peekFlaggedToken()
        throws IOException
    {
<span class="fc" id="L429">        peekToken();</span>
<span class="fc" id="L430">        return currentFlaggedToken;</span>
    }

    private void consumeToken() {
<span class="fc" id="L434">        currentFlaggedToken = Token.EOF;</span>
<span class="fc" id="L435">    }</span>

    private int nextToken()
        throws IOException
    {
<span class="fc" id="L440">        int tt = peekToken();</span>
<span class="fc" id="L441">        consumeToken();</span>
<span class="fc" id="L442">        return tt;</span>
    }

    private int nextFlaggedToken()
        throws IOException
    {
<span class="nc" id="L448">        peekToken();</span>
<span class="nc" id="L449">        int ttFlagged = currentFlaggedToken;</span>
<span class="nc" id="L450">        consumeToken();</span>
<span class="nc" id="L451">        return ttFlagged;</span>
    }

    private boolean matchToken(int toMatch)
        throws IOException
    {
<span class="fc bfc" id="L457" title="All 2 branches covered.">        if (peekToken() != toMatch) {</span>
<span class="fc" id="L458">            return false;</span>
        }
<span class="fc" id="L460">        consumeToken();</span>
<span class="fc" id="L461">        return true;</span>
    }

    // Returns Token.EOL if the current token follows a newline, else returns
    // the current token.  Used in situations where we don't consider certain
    // token types valid if they are preceded by a newline.  One example is the
    // postfix ++ or -- operator, which has to be on the same line as its
    // operand.
    private int peekTokenOrEOL()
        throws IOException
    {
<span class="fc" id="L472">        int tt = peekToken();</span>
        // Check for last peeked token flags
<span class="fc bfc" id="L474" title="All 2 branches covered.">        if ((currentFlaggedToken &amp; TI_AFTER_EOL) != 0) {</span>
<span class="fc" id="L475">            tt = Token.EOL;</span>
        }
<span class="fc" id="L477">        return tt;</span>
    }

    private boolean mustMatchToken(int toMatch, String messageId)
        throws IOException
    {
<span class="fc" id="L483">        return mustMatchToken(toMatch, messageId, ts.tokenBeg,</span>
                              ts.tokenEnd - ts.tokenBeg);
    }

    private boolean mustMatchToken(int toMatch, String msgId, int pos, int len)
        throws IOException
    {
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">        if (matchToken(toMatch)) {</span>
<span class="fc" id="L491">            return true;</span>
        }
<span class="nc" id="L493">        reportError(msgId, pos, len);</span>
<span class="nc" id="L494">        return false;</span>
    }

    private void mustHaveXML() {
<span class="fc bfc" id="L498" title="All 2 branches covered.">        if (!compilerEnv.isXmlAvailable()) {</span>
<span class="nc" id="L499">            reportError(&quot;msg.XML.not.available&quot;);</span>
        }
<span class="fc" id="L501">    }</span>

    public boolean eof() {
<span class="nc" id="L504">        return ts.eof();</span>
    }

    boolean insideFunction() {
<span class="fc bfc" id="L508" title="All 2 branches covered.">        return nestingOfFunction != 0;</span>
    }

    void pushScope(Scope scope) {
<span class="fc" id="L512">        Scope parent = scope.getParentScope();</span>
        // During codegen, parent scope chain may already be initialized,
        // in which case we just need to set currentScope variable.
<span class="fc bfc" id="L515" title="All 2 branches covered.">        if (parent != null) {</span>
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">            if (parent != currentScope)</span>
<span class="nc" id="L517">                codeBug();</span>
        } else {
<span class="fc" id="L519">            currentScope.addChildScope(scope);</span>
        }
<span class="fc" id="L521">        currentScope = scope;</span>
<span class="fc" id="L522">    }</span>

    void popScope() {
<span class="fc" id="L525">        currentScope = currentScope.getParentScope();</span>
<span class="fc" id="L526">    }</span>

    private void enterLoop(Loop loop) {
<span class="fc bfc" id="L529" title="All 2 branches covered.">        if (loopSet == null)</span>
<span class="fc" id="L530">            loopSet = new ArrayList&lt;Loop&gt;();</span>
<span class="fc" id="L531">        loopSet.add(loop);</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">        if (loopAndSwitchSet == null)</span>
<span class="fc" id="L533">            loopAndSwitchSet = new ArrayList&lt;Jump&gt;();</span>
<span class="fc" id="L534">        loopAndSwitchSet.add(loop);</span>
<span class="fc" id="L535">        pushScope(loop);</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">        if (currentLabel != null) {</span>
<span class="fc" id="L537">            currentLabel.setStatement(loop);</span>
<span class="fc" id="L538">            currentLabel.getFirstLabel().setLoop(loop);</span>
            // This is the only time during parsing that we set a node's parent
            // before parsing the children.  In order for the child node offsets
            // to be correct, we adjust the loop's reported position back to an
            // absolute source offset, and restore it when we call exitLoop().
<span class="fc" id="L543">            loop.setRelative(-currentLabel.getPosition());</span>
        }
<span class="fc" id="L545">    }</span>

    private void exitLoop() {
<span class="fc" id="L548">        Loop loop = loopSet.remove(loopSet.size() - 1);</span>
<span class="fc" id="L549">        loopAndSwitchSet.remove(loopAndSwitchSet.size() - 1);</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">        if (loop.getParent() != null) {  // see comment in enterLoop</span>
<span class="fc" id="L551">            loop.setRelative(loop.getParent().getPosition());</span>
        }
<span class="fc" id="L553">        popScope();</span>
<span class="fc" id="L554">    }</span>

    private void enterSwitch(SwitchStatement node) {
<span class="fc bfc" id="L557" title="All 2 branches covered.">        if (loopAndSwitchSet == null)</span>
<span class="fc" id="L558">            loopAndSwitchSet = new ArrayList&lt;Jump&gt;();</span>
<span class="fc" id="L559">        loopAndSwitchSet.add(node);</span>
<span class="fc" id="L560">    }</span>

    private void exitSwitch() {
<span class="fc" id="L563">        loopAndSwitchSet.remove(loopAndSwitchSet.size() - 1);</span>
<span class="fc" id="L564">    }</span>

    /**
     * Builds a parse tree from the given source string.
     *
     * @return an {@link AstRoot} object representing the parsed program.  If
     * the parse fails, {@code null} will be returned.  (The parse failure will
     * result in a call to the {@link ErrorReporter} from
     * {@link CompilerEnvirons}.)
     */
    public AstRoot parse(String sourceString, String sourceURI, int lineno)
    {
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">        if (parseFinished) throw new IllegalStateException(&quot;parser reused&quot;);</span>
<span class="fc" id="L577">        this.sourceURI = sourceURI;</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">        if (compilerEnv.isIdeMode()) {</span>
<span class="fc" id="L579">            this.sourceChars = sourceString.toCharArray();</span>
        }
<span class="fc" id="L581">        this.ts = new TokenStream(this, null, sourceString, lineno);</span>
        try {
<span class="fc" id="L583">            return parse();</span>
<span class="nc" id="L584">        } catch (IOException iox) {</span>
            // Should never happen
<span class="nc" id="L586">            throw new IllegalStateException();</span>
        } finally {
<span class="fc" id="L588">            parseFinished = true;</span>
<span class="fc" id="L589">        }</span>
    }

    /**
     * Builds a parse tree from the given sourcereader.
     * @see #parse(String,String,int)
     * @throws IOException if the {@link Reader} encounters an error
     */
    public AstRoot parse(Reader sourceReader, String sourceURI, int lineno)
        throws IOException
    {
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">        if (parseFinished) throw new IllegalStateException(&quot;parser reused&quot;);</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">        if (compilerEnv.isIdeMode()) {</span>
<span class="fc" id="L602">            return parse(readFully(sourceReader), sourceURI, lineno);</span>
        }
        try {
<span class="fc" id="L605">            this.sourceURI = sourceURI;</span>
<span class="fc" id="L606">            ts = new TokenStream(this, sourceReader, null, lineno);</span>
<span class="fc" id="L607">            return parse();</span>
        } finally {
<span class="pc" id="L609">            parseFinished = true;</span>
<span class="nc" id="L610">        }</span>
    }

    private AstRoot parse() throws IOException
    {
<span class="fc" id="L615">        int pos = 0;</span>
<span class="fc" id="L616">        AstRoot root = new AstRoot(pos);</span>
<span class="fc" id="L617">        currentScope = currentScriptOrFn = root;</span>

<span class="fc" id="L619">        int baseLineno = ts.lineno;  // line number where source starts</span>
<span class="fc" id="L620">        int end = pos;  // in case source is empty</span>

<span class="fc" id="L622">        boolean inDirectivePrologue = true;</span>
<span class="fc" id="L623">        boolean savedStrictMode = inUseStrictDirective;</span>

<span class="fc" id="L625">        inUseStrictDirective = defaultUseStrictDirective;</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">        if (inUseStrictDirective) {</span>
<span class="fc" id="L627">            root.setInStrictMode(true);</span>
        }

        try {
            for (;;) {
<span class="fc" id="L632">                int tt = peekToken();</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">                if (tt &lt;= Token.EOF) {</span>
<span class="fc" id="L634">                    break;</span>
                }

                AstNode n;
<span class="fc bfc" id="L638" title="All 2 branches covered.">                if (tt == Token.FUNCTION) {</span>
<span class="fc" id="L639">                    consumeToken();</span>
                    try {
<span class="fc bfc" id="L641" title="All 2 branches covered.">                        n = function(calledByCompileFunction</span>
                                     ? FunctionNode.FUNCTION_EXPRESSION
                                     : FunctionNode.FUNCTION_STATEMENT);
<span class="nc" id="L644">                    } catch (ParserException e) {</span>
<span class="nc" id="L645">                        break;</span>
<span class="fc" id="L646">                    }</span>
                } else {
<span class="fc" id="L648">                    n = statement();</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">                    if (inDirectivePrologue) {</span>
<span class="fc" id="L650">                        String directive = getDirective(n);</span>
<span class="fc bfc" id="L651" title="All 2 branches covered.">                        if (directive == null) {</span>
<span class="fc" id="L652">                            inDirectivePrologue = false;</span>
<span class="fc bfc" id="L653" title="All 2 branches covered.">                        } else if (directive.equals(&quot;use strict&quot;)) {</span>
<span class="fc" id="L654">                            inUseStrictDirective = true;</span>
<span class="fc" id="L655">                            root.setInStrictMode(true);</span>
                        }
                    }

                }
<span class="fc" id="L660">                end = getNodeEnd(n);</span>
<span class="fc" id="L661">                root.addChildToBack(n);</span>
<span class="fc" id="L662">                n.setParent(root);</span>
<span class="fc" id="L663">            }</span>
<span class="fc" id="L664">        } catch (StackOverflowError ex) {</span>
<span class="fc" id="L665">            String msg = lookupMessage(&quot;msg.too.deep.parser.recursion&quot;);</span>
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">            if (!compilerEnv.isIdeMode())</span>
<span class="fc" id="L667">                throw Context.reportRuntimeError(msg, sourceURI,</span>
                                                 ts.lineno, null, 0);
        } finally {
<span class="pc" id="L670">            inUseStrictDirective = savedStrictMode;</span>
<span class="pc" id="L671">        }</span>

<span class="fc bfc" id="L673" title="All 2 branches covered.">        if (this.syntaxErrorCount != 0) {</span>
<span class="fc" id="L674">            String msg = String.valueOf(this.syntaxErrorCount);</span>
<span class="fc" id="L675">            msg = lookupMessage(&quot;msg.got.syntax.errors&quot;, msg);</span>
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">            if (!compilerEnv.isIdeMode())</span>
<span class="fc" id="L677">                throw errorReporter.runtimeError(msg, sourceURI, baseLineno,</span>
                                                 null, 0);
        }

        // add comments to root in lexical order
<span class="fc bfc" id="L682" title="All 2 branches covered.">        if (scannedComments != null) {</span>
            // If we find a comment beyond end of our last statement or
            // function, extend the root bounds to the end of that comment.
<span class="fc" id="L685">            int last = scannedComments.size() - 1;</span>
<span class="fc" id="L686">            end = Math.max(end, getNodeEnd(scannedComments.get(last)));</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">            for (Comment c : scannedComments) {</span>
<span class="fc" id="L688">                root.addComment(c);</span>
<span class="fc" id="L689">            }</span>
        }

<span class="fc" id="L692">        root.setLength(end - pos);</span>
<span class="fc" id="L693">        root.setSourceName(sourceURI);</span>
<span class="fc" id="L694">        root.setBaseLineno(baseLineno);</span>
<span class="fc" id="L695">        root.setEndLineno(ts.lineno);</span>
<span class="fc" id="L696">        return root;</span>
    }

    private AstNode parseFunctionBody(int type, FunctionNode fnNode)
        throws IOException
    {
<span class="fc" id="L702">        boolean isExpressionClosure = false;</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">        if (!matchToken(Token.LC)) {</span>
<span class="pc bpc" id="L704" title="1 of 4 branches missed.">            if (compilerEnv.getLanguageVersion() &lt; Context.VERSION_1_8 &amp;&amp; type != FunctionNode.ARROW_FUNCTION) {</span>
<span class="nc" id="L705">                reportError(&quot;msg.no.brace.body&quot;);</span>
            } else {
<span class="fc" id="L707">                isExpressionClosure = true;</span>
            }
        }
<span class="fc bfc" id="L710" title="All 2 branches covered.">        boolean isArrow = type == FunctionNode.ARROW_FUNCTION;</span>
<span class="fc" id="L711">        ++nestingOfFunction;</span>
<span class="fc" id="L712">        int pos = ts.tokenBeg;</span>
<span class="fc" id="L713">        Block pn = new Block(pos);  // starts at LC position</span>

<span class="fc" id="L715">        boolean inDirectivePrologue = true;</span>
<span class="fc" id="L716">        boolean savedStrictMode = inUseStrictDirective;</span>
        // Don't set 'inUseStrictDirective' to false: inherit strict mode.

<span class="fc" id="L719">        pn.setLineno(ts.lineno);</span>
        try {
<span class="fc bfc" id="L721" title="All 2 branches covered.">            if (isExpressionClosure) {</span>
<span class="fc" id="L722">                AstNode returnValue = assignExpr();</span>
<span class="fc" id="L723">                ReturnStatement n = new ReturnStatement(returnValue.getPosition(), returnValue.getLength(), returnValue);</span>
                // expression closure flag is required on both nodes
<span class="fc" id="L725">                n.putProp(Node.EXPRESSION_CLOSURE_PROP, Boolean.TRUE);</span>
<span class="fc" id="L726">                pn.putProp(Node.EXPRESSION_CLOSURE_PROP, Boolean.TRUE);</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">                if (isArrow) {</span>
<span class="fc" id="L728">                    n.putProp(Node.ARROW_FUNCTION_PROP, Boolean.TRUE);</span>
                }
<span class="fc" id="L730">                pn.addStatement(n);</span>
<span class="fc" id="L731">            } else {</span>
                bodyLoop: for (;;) {
                    AstNode n;
<span class="fc" id="L734">                    int tt = peekToken();</span>
<span class="fc bfc" id="L735" title="All 3 branches covered.">                    switch (tt) {</span>
                        case Token.ERROR:
                        case Token.EOF:
                        case Token.RC:
<span class="fc" id="L739">                            break bodyLoop;</span>

                        case Token.FUNCTION:
<span class="fc" id="L742">                            consumeToken();</span>
<span class="fc" id="L743">                            n = function(FunctionNode.FUNCTION_STATEMENT);</span>
<span class="fc" id="L744">                            break;</span>
                        default:
<span class="fc" id="L746">                            n = statement();</span>
<span class="fc bfc" id="L747" title="All 2 branches covered.">                            if (inDirectivePrologue) {</span>
<span class="fc" id="L748">                                String directive = getDirective(n);</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">                                if (directive == null) {</span>
<span class="fc" id="L750">                                    inDirectivePrologue = false;</span>
<span class="fc bfc" id="L751" title="All 2 branches covered.">                                } else if (directive.equals(&quot;use strict&quot;)) {</span>
<span class="fc" id="L752">                                    inUseStrictDirective = true;</span>
<span class="fc" id="L753">                                    fnNode.setInStrictMode(true);</span>
<span class="pc bpc" id="L754" title="1 of 2 branches missed.">                                    if (!savedStrictMode) {</span>
<span class="fc" id="L755">                                        setRequiresActivation();</span>
                                    }
                                }
                            }
                            break;
                    }
<span class="fc" id="L761">                    pn.addStatement(n);</span>
<span class="fc" id="L762">                }</span>
            }
<span class="nc" id="L764">        } catch (ParserException e) {</span>
            // Ignore it
        } finally {
<span class="pc" id="L767">            --nestingOfFunction;</span>
<span class="pc" id="L768">            inUseStrictDirective = savedStrictMode;</span>
<span class="pc" id="L769">        }</span>

<span class="fc" id="L771">        int end = ts.tokenEnd;</span>
<span class="fc" id="L772">        getAndResetJsDoc();</span>
<span class="pc bpc" id="L773" title="1 of 4 branches missed.">        if (!isExpressionClosure &amp;&amp; mustMatchToken(Token.RC, &quot;msg.no.brace.after.body&quot;))</span>
<span class="fc" id="L774">            end = ts.tokenEnd;</span>
<span class="fc" id="L775">        pn.setLength(end - pos);</span>
<span class="fc" id="L776">        return pn;</span>
    }

    private String getDirective(AstNode n) {
<span class="fc bfc" id="L780" title="All 2 branches covered.">        if (n instanceof ExpressionStatement) {</span>
<span class="fc" id="L781">            AstNode e = ((ExpressionStatement) n).getExpression();</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">            if (e instanceof StringLiteral) {</span>
<span class="fc" id="L783">                return ((StringLiteral) e).getValue();</span>
            }
        }
<span class="fc" id="L786">        return null;</span>
    }

    private void  parseFunctionParams(FunctionNode fnNode)
        throws IOException
    {
<span class="fc bfc" id="L792" title="All 2 branches covered.">        if (matchToken(Token.RP)) {</span>
<span class="fc" id="L793">            fnNode.setRp(ts.tokenBeg - fnNode.getPosition());</span>
<span class="fc" id="L794">            return;</span>
        }
        // Would prefer not to call createDestructuringAssignment until codegen,
        // but the symbol definitions have to happen now, before body is parsed.
<span class="fc" id="L798">        Map&lt;String, Node&gt; destructuring = null;</span>
<span class="fc" id="L799">        Set&lt;String&gt; paramNames = new HashSet&lt;String&gt;();</span>
        do {
<span class="fc" id="L801">            int tt = peekToken();</span>
<span class="fc bfc" id="L802" title="All 4 branches covered.">            if (tt == Token.LB || tt == Token.LC) {</span>
<span class="fc" id="L803">                AstNode expr = destructuringPrimaryExpr();</span>
<span class="fc" id="L804">                markDestructuring(expr);</span>
<span class="fc" id="L805">                fnNode.addParam(expr);</span>
                // Destructuring assignment for parameters: add a dummy
                // parameter name, and add a statement to the body to initialize
                // variables from the destructuring assignment
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">                if (destructuring == null) {</span>
<span class="fc" id="L810">                    destructuring = new HashMap&lt;String, Node&gt;();</span>
                }
<span class="fc" id="L812">                String pname = currentScriptOrFn.getNextTempName();</span>
<span class="fc" id="L813">                defineSymbol(Token.LP, pname, false);</span>
<span class="fc" id="L814">                destructuring.put(pname, expr);</span>
<span class="fc" id="L815">            } else {</span>
<span class="pc bpc" id="L816" title="1 of 2 branches missed.">                if (mustMatchToken(Token.NAME, &quot;msg.no.parm&quot;)) {</span>
<span class="fc" id="L817">                    Name paramNameNode = createNameNode();</span>
<span class="fc" id="L818">                    Comment jsdocNodeForName = getAndResetJsDoc();</span>
<span class="fc bfc" id="L819" title="All 2 branches covered.">                    if (jsdocNodeForName != null) {</span>
<span class="fc" id="L820">                      paramNameNode.setJsDocNode(jsdocNodeForName);</span>
                    }
<span class="fc" id="L822">                    fnNode.addParam(paramNameNode);</span>
<span class="fc" id="L823">                    String paramName = ts.getString();</span>
<span class="fc" id="L824">                    defineSymbol(Token.LP, paramName);</span>
<span class="fc bfc" id="L825" title="All 2 branches covered.">                    if (this.inUseStrictDirective) {</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">                        if (&quot;eval&quot;.equals(paramName) ||</span>
<span class="pc bpc" id="L827" title="1 of 2 branches missed.">                            &quot;arguments&quot;.equals(paramName))</span>
                        {
<span class="nc" id="L829">                            reportError(&quot;msg.bad.id.strict&quot;, paramName);</span>
                        }
<span class="pc bpc" id="L831" title="1 of 2 branches missed.">                        if (paramNames.contains(paramName))</span>
<span class="nc" id="L832">                            addError(&quot;msg.dup.param.strict&quot;, paramName);</span>
<span class="fc" id="L833">                        paramNames.add(paramName);</span>
                    }
<span class="fc" id="L835">                } else {</span>
<span class="nc" id="L836">                    fnNode.addParam(makeErrorNode());</span>
                }
            }
<span class="fc bfc" id="L839" title="All 2 branches covered.">        } while (matchToken(Token.COMMA));</span>

<span class="fc bfc" id="L841" title="All 2 branches covered.">        if (destructuring != null) {</span>
<span class="fc" id="L842">            Node destructuringNode = new Node(Token.COMMA);</span>
            // Add assignment helper for each destructuring parameter
<span class="fc bfc" id="L844" title="All 2 branches covered.">            for (Map.Entry&lt;String, Node&gt; param: destructuring.entrySet()) {</span>
<span class="fc" id="L845">                Node assign = createDestructuringAssignment(Token.VAR,</span>
<span class="fc" id="L846">                        param.getValue(), createName(param.getKey()));</span>
<span class="fc" id="L847">                destructuringNode.addChildToBack(assign);</span>

<span class="fc" id="L849">            }</span>
<span class="fc" id="L850">            fnNode.putProp(Node.DESTRUCTURING_PARAMS, destructuringNode);</span>
        }

<span class="pc bpc" id="L853" title="1 of 2 branches missed.">        if (mustMatchToken(Token.RP, &quot;msg.no.paren.after.parms&quot;)) {</span>
<span class="fc" id="L854">            fnNode.setRp(ts.tokenBeg - fnNode.getPosition());</span>
        }
<span class="fc" id="L856">    }</span>

    private FunctionNode function(int type)
        throws IOException
    {
<span class="fc" id="L861">        int syntheticType = type;</span>
<span class="fc" id="L862">        int baseLineno = ts.lineno;  // line number where source starts</span>
<span class="fc" id="L863">        int functionSourceStart = ts.tokenBeg;  // start of &quot;function&quot; kwd</span>
<span class="fc" id="L864">        Name name = null;</span>
<span class="fc" id="L865">        AstNode memberExprNode = null;</span>

<span class="fc bfc" id="L867" title="All 2 branches covered.">        if (matchToken(Token.NAME)) {</span>
<span class="fc" id="L868">            name = createNameNode(true, Token.NAME);</span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">            if (inUseStrictDirective) {</span>
<span class="fc" id="L870">                String id = name.getIdentifier();</span>
<span class="pc bpc" id="L871" title="2 of 4 branches missed.">                if (&quot;eval&quot;.equals(id)|| &quot;arguments&quot;.equals(id)) {</span>
<span class="nc" id="L872">                    reportError(&quot;msg.bad.id.strict&quot;, id);</span>
                }
            }
<span class="pc bpc" id="L875" title="1 of 2 branches missed.">            if (!matchToken(Token.LP)) {</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">                if (compilerEnv.isAllowMemberExprAsFunctionName()) {</span>
<span class="nc" id="L877">                    AstNode memberExprHead = name;</span>
<span class="nc" id="L878">                    name = null;</span>
<span class="nc" id="L879">                    memberExprNode = memberExprTail(false, memberExprHead);</span>
                }
<span class="nc" id="L881">                mustMatchToken(Token.LP, &quot;msg.no.paren.parms&quot;);</span>
            }
<span class="fc bfc" id="L883" title="All 2 branches covered.">        } else if (matchToken(Token.LP)) {</span>
            // Anonymous function:  leave name as null
        } else {
<span class="pc bpc" id="L886" title="1 of 2 branches missed.">            if (compilerEnv.isAllowMemberExprAsFunctionName()) {</span>
                // Note that memberExpr can not start with '(' like
                // in function (1+2).toString(), because 'function (' already
                // processed as anonymous function
<span class="nc" id="L890">                memberExprNode = memberExpr(false);</span>
            }
<span class="nc" id="L892">            mustMatchToken(Token.LP, &quot;msg.no.paren.parms&quot;);</span>
        }
<span class="pc bpc" id="L894" title="1 of 2 branches missed.">        int lpPos = currentToken == Token.LP ? ts.tokenBeg : -1;</span>

<span class="pc bpc" id="L896" title="1 of 2 branches missed.">        if (memberExprNode != null) {</span>
<span class="nc" id="L897">            syntheticType = FunctionNode.FUNCTION_EXPRESSION;</span>
        }

<span class="fc bfc" id="L900" title="All 4 branches covered.">        if (syntheticType != FunctionNode.FUNCTION_EXPRESSION</span>
<span class="pc bpc" id="L901" title="1 of 2 branches missed.">            &amp;&amp; name != null &amp;&amp; name.length() &gt; 0) {</span>
            // Function statements define a symbol in the enclosing scope
<span class="fc" id="L903">            defineSymbol(Token.FUNCTION, name.getIdentifier());</span>
        }

<span class="fc" id="L906">        FunctionNode fnNode = new FunctionNode(functionSourceStart, name);</span>
<span class="fc" id="L907">        fnNode.setFunctionType(type);</span>
<span class="pc bpc" id="L908" title="1 of 2 branches missed.">        if (lpPos != -1)</span>
<span class="fc" id="L909">            fnNode.setLp(lpPos - functionSourceStart);</span>

<span class="fc" id="L911">        fnNode.setJsDocNode(getAndResetJsDoc());</span>

<span class="fc" id="L913">        PerFunctionVariables savedVars = new PerFunctionVariables(fnNode);</span>
        try {
<span class="fc" id="L915">            parseFunctionParams(fnNode);</span>
<span class="fc" id="L916">            fnNode.setBody(parseFunctionBody(type, fnNode));</span>
<span class="fc" id="L917">            fnNode.setEncodedSourceBounds(functionSourceStart, ts.tokenEnd);</span>
<span class="fc" id="L918">            fnNode.setLength(ts.tokenEnd - functionSourceStart);</span>

<span class="pc bpc" id="L920" title="1 of 2 branches missed.">            if (compilerEnv.isStrictMode()</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">                &amp;&amp; !fnNode.getBody().hasConsistentReturnUsage()) {</span>
<span class="nc bnc" id="L922" title="All 4 branches missed.">                String msg = (name != null &amp;&amp; name.length() &gt; 0)</span>
                           ? &quot;msg.no.return.value&quot;
                           : &quot;msg.anon.no.return.value&quot;;
<span class="nc bnc" id="L925" title="All 2 branches missed.">                addStrictWarning(msg, name == null ? &quot;&quot; : name.getIdentifier());</span>
            }
        } finally {
<span class="fc" id="L928">            savedVars.restore();</span>
<span class="fc" id="L929">        }</span>

<span class="pc bpc" id="L931" title="1 of 2 branches missed.">        if (memberExprNode != null) {</span>
            // TODO(stevey): fix missing functionality
<span class="nc" id="L933">            Kit.codeBug();</span>
<span class="nc" id="L934">            fnNode.setMemberExprNode(memberExprNode);  // rewrite later</span>
            /* old code:
            if (memberExprNode != null) {
                pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);
                if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
                    // XXX check JScript behavior: should it be createExprStatement?
                    pn = nf.createExprStatementNoReturn(pn, baseLineno);
                }
            }
            */
        }

<span class="fc" id="L946">        fnNode.setSourceName(sourceURI);</span>
<span class="fc" id="L947">        fnNode.setBaseLineno(baseLineno);</span>
<span class="fc" id="L948">        fnNode.setEndLineno(ts.lineno);</span>

        // Set the parent scope.  Needed for finding undeclared vars.
        // Have to wait until after parsing the function to set its parent
        // scope, since defineSymbol needs the defining-scope check to stop
        // at the function boundary when checking for redeclarations.
<span class="pc bpc" id="L954" title="1 of 2 branches missed.">        if (compilerEnv.isIdeMode()) {</span>
<span class="nc" id="L955">            fnNode.setParentScope(currentScope);</span>
        }
<span class="fc" id="L957">        return fnNode;</span>
    }

    private AstNode arrowFunction(AstNode params) throws IOException {
<span class="fc" id="L961">        int baseLineno = ts.lineno;  // line number where source starts</span>
<span class="pc bpc" id="L962" title="1 of 2 branches missed.">        int functionSourceStart = params != null ? params.getPosition() : -1;  // start of &quot;function&quot; kwd</span>

<span class="fc" id="L964">        FunctionNode fnNode = new FunctionNode(functionSourceStart);</span>
<span class="fc" id="L965">        fnNode.setFunctionType(FunctionNode.ARROW_FUNCTION);</span>
<span class="fc" id="L966">        fnNode.setJsDocNode(getAndResetJsDoc());</span>

        // Would prefer not to call createDestructuringAssignment until codegen,
        // but the symbol definitions have to happen now, before body is parsed.
<span class="fc" id="L970">        Map&lt;String, Node&gt; destructuring = new HashMap&lt;String, Node&gt;();</span>
<span class="fc" id="L971">        Set&lt;String&gt; paramNames = new HashSet&lt;String&gt;();</span>

<span class="fc" id="L973">        PerFunctionVariables savedVars = new PerFunctionVariables(fnNode);</span>
        try {
<span class="fc bfc" id="L975" title="All 2 branches covered.">            if (params instanceof ParenthesizedExpression) {</span>
<span class="fc" id="L976">                fnNode.setParens(0, params.getLength());</span>
<span class="fc" id="L977">                AstNode p = ((ParenthesizedExpression)params).getExpression();</span>
<span class="fc bfc" id="L978" title="All 2 branches covered.">                if (!(p instanceof EmptyExpression)) {</span>
<span class="fc" id="L979">                    arrowFunctionParams(fnNode, p, destructuring, paramNames);</span>
                }
<span class="fc" id="L981">            } else {</span>
<span class="fc" id="L982">                arrowFunctionParams(fnNode, params, destructuring, paramNames);</span>
            }

<span class="fc bfc" id="L985" title="All 2 branches covered.">            if (!destructuring.isEmpty()) {</span>
<span class="fc" id="L986">                Node destructuringNode = new Node(Token.COMMA);</span>
                // Add assignment helper for each destructuring parameter
<span class="fc bfc" id="L988" title="All 2 branches covered.">                for (Map.Entry&lt;String, Node&gt; param: destructuring.entrySet()) {</span>
<span class="fc" id="L989">                    Node assign = createDestructuringAssignment(Token.VAR,</span>
<span class="fc" id="L990">                                                                param.getValue(), createName(param.getKey()));</span>
<span class="fc" id="L991">                    destructuringNode.addChildToBack(assign);</span>

<span class="fc" id="L993">                }</span>
<span class="fc" id="L994">                fnNode.putProp(Node.DESTRUCTURING_PARAMS, destructuringNode);</span>
            }
                
<span class="fc" id="L997">            fnNode.setBody(parseFunctionBody(FunctionNode.ARROW_FUNCTION, fnNode));</span>
<span class="fc" id="L998">            fnNode.setEncodedSourceBounds(functionSourceStart, ts.tokenEnd);</span>
<span class="fc" id="L999">            fnNode.setLength(ts.tokenEnd - functionSourceStart);</span>
        } finally {
<span class="fc" id="L1001">            savedVars.restore();</span>
<span class="fc" id="L1002">        }</span>

<span class="pc bpc" id="L1004" title="1 of 2 branches missed.">        if (fnNode.isGenerator()) {</span>
<span class="nc" id="L1005">            reportError(&quot;msg.arrowfunction.generator&quot;);</span>
<span class="nc" id="L1006">            return makeErrorNode();</span>
        }

<span class="fc" id="L1009">        fnNode.setSourceName(sourceURI);</span>
<span class="fc" id="L1010">        fnNode.setBaseLineno(baseLineno);</span>
<span class="fc" id="L1011">        fnNode.setEndLineno(ts.lineno);</span>

<span class="fc" id="L1013">        return fnNode;</span>
    }

    private void arrowFunctionParams(FunctionNode fnNode, AstNode params, Map&lt;String, Node&gt; destructuring, Set&lt;String&gt; paramNames) {
<span class="fc bfc" id="L1017" title="All 4 branches covered.">        if (params instanceof ArrayLiteral || params instanceof ObjectLiteral) {</span>
<span class="fc" id="L1018">            markDestructuring(params);</span>
<span class="fc" id="L1019">            fnNode.addParam(params);</span>
<span class="fc" id="L1020">            String pname = currentScriptOrFn.getNextTempName();</span>
<span class="fc" id="L1021">            defineSymbol(Token.LP, pname, false);</span>
<span class="fc" id="L1022">            destructuring.put(pname, params);</span>
<span class="pc bpc" id="L1023" title="1 of 4 branches missed.">        } else if (params instanceof InfixExpression &amp;&amp; params.getType() == Token.COMMA) {</span>
<span class="fc" id="L1024">            arrowFunctionParams(fnNode, ((InfixExpression)params).getLeft(), destructuring, paramNames);</span>
<span class="fc" id="L1025">            arrowFunctionParams(fnNode, ((InfixExpression)params).getRight(), destructuring, paramNames);</span>
<span class="pc bpc" id="L1026" title="1 of 2 branches missed.">        } else if (params instanceof Name) {</span>
<span class="fc" id="L1027">            fnNode.addParam(params);</span>
<span class="fc" id="L1028">            String paramName = ((Name)params).getIdentifier();</span>
<span class="fc" id="L1029">            defineSymbol(Token.LP, paramName);</span>

<span class="fc bfc" id="L1031" title="All 2 branches covered.">            if (this.inUseStrictDirective) {</span>
<span class="fc bfc" id="L1032" title="All 2 branches covered.">                if (&quot;eval&quot;.equals(paramName) ||</span>
<span class="fc bfc" id="L1033" title="All 2 branches covered.">                    &quot;arguments&quot;.equals(paramName))</span>
                    {
<span class="nc" id="L1035">                        reportError(&quot;msg.bad.id.strict&quot;, paramName);</span>
                    }
<span class="fc bfc" id="L1037" title="All 2 branches covered.">                if (paramNames.contains(paramName))</span>
<span class="nc" id="L1038">                    addError(&quot;msg.dup.param.strict&quot;, paramName);</span>
<span class="fc" id="L1039">                paramNames.add(paramName);</span>
            }
<span class="fc" id="L1041">        } else {</span>
<span class="nc" id="L1042">            reportError(&quot;msg.no.parm&quot;, params.getPosition(), params.getLength());</span>
<span class="nc" id="L1043">            fnNode.addParam(makeErrorNode());</span>
        }
<span class="fc" id="L1045">    }</span>

    // This function does not match the closing RC: the caller matches
    // the RC so it can provide a suitable error message if not matched.
    // This means it's up to the caller to set the length of the node to
    // include the closing RC.  The node start pos is set to the
    // absolute buffer start position, and the caller should fix it up
    // to be relative to the parent node.  All children of this block
    // node are given relative start positions and correct lengths.

    private AstNode statements(AstNode parent) throws IOException {
<span class="pc bpc" id="L1056" title="1 of 2 branches missed.">        if (currentToken != Token.LC  // assertion can be invalid in bad code</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">            &amp;&amp; !compilerEnv.isIdeMode()) codeBug();</span>
<span class="fc" id="L1058">        int pos = ts.tokenBeg;</span>
<span class="fc bfc" id="L1059" title="All 2 branches covered.">        AstNode block = parent != null ? parent : new Block(pos);</span>
<span class="fc" id="L1060">        block.setLineno(ts.lineno);</span>

        int tt;
<span class="pc bpc" id="L1063" title="1 of 4 branches missed.">        while ((tt = peekToken()) &gt; Token.EOF &amp;&amp; tt != Token.RC) {</span>
<span class="fc" id="L1064">            block.addChild(statement());</span>
        }
<span class="fc" id="L1066">        block.setLength(ts.tokenBeg - pos);</span>
<span class="fc" id="L1067">        return block;</span>
    }

    private AstNode statements() throws IOException {
<span class="fc" id="L1071">        return statements(null);</span>
    }

<span class="fc" id="L1074">    private static class ConditionData {</span>
        AstNode condition;
<span class="fc" id="L1076">        int lp = -1;</span>
<span class="fc" id="L1077">        int rp = -1;</span>
    }

    // parse and return a parenthesized expression
    private ConditionData condition()
        throws IOException
    {
<span class="fc" id="L1084">        ConditionData data = new ConditionData();</span>

<span class="pc bpc" id="L1086" title="1 of 2 branches missed.">        if (mustMatchToken(Token.LP, &quot;msg.no.paren.cond&quot;))</span>
<span class="fc" id="L1087">            data.lp = ts.tokenBeg;</span>

<span class="fc" id="L1089">        data.condition = expr();</span>

<span class="pc bpc" id="L1091" title="1 of 2 branches missed.">        if (mustMatchToken(Token.RP, &quot;msg.no.paren.after.cond&quot;))</span>
<span class="fc" id="L1092">            data.rp = ts.tokenBeg;</span>

        // Report strict warning on code like &quot;if (a = 7) ...&quot;. Suppress the
        // warning if the condition is parenthesized, like &quot;if ((a = 7)) ...&quot;.
<span class="fc bfc" id="L1096" title="All 2 branches covered.">        if (data.condition instanceof Assignment) {</span>
<span class="fc" id="L1097">            addStrictWarning(&quot;msg.equal.as.assign&quot;, &quot;&quot;,</span>
<span class="fc" id="L1098">                             data.condition.getPosition(),</span>
<span class="fc" id="L1099">                             data.condition.getLength());</span>
        }
<span class="fc" id="L1101">        return data;</span>
    }

    private AstNode statement()
        throws IOException
    {
<span class="fc" id="L1107">        int pos = ts.tokenBeg;</span>
        try {
<span class="fc" id="L1109">            AstNode pn = statementHelper();</span>
<span class="pc bpc" id="L1110" title="1 of 2 branches missed.">            if (pn != null) {</span>
<span class="pc bpc" id="L1111" title="1 of 4 branches missed.">                if (compilerEnv.isStrictMode() &amp;&amp; !pn.hasSideEffects()) {</span>
<span class="nc" id="L1112">                    int beg = pn.getPosition();</span>
<span class="nc" id="L1113">                    beg = Math.max(beg, lineBeginningFor(beg));</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">                    addStrictWarning(pn instanceof EmptyStatement</span>
                                     ? &quot;msg.extra.trailing.semi&quot;
                                     : &quot;msg.no.side.effects&quot;,
<span class="nc" id="L1117">                                     &quot;&quot;, beg, nodeEnd(pn) - beg);</span>
                }
<span class="fc" id="L1119">                return pn;</span>
            }
<span class="fc" id="L1121">        } catch (ParserException e) {</span>
            // an ErrorNode was added to the ErrorReporter
<span class="nc" id="L1123">        }</span>

        // error:  skip ahead to a probable statement boundary
        guessingStatementEnd: for (;;) {
<span class="fc" id="L1127">            int tt = peekTokenOrEOL();</span>
<span class="fc" id="L1128">            consumeToken();</span>
<span class="fc bfc" id="L1129" title="All 2 branches covered.">            switch (tt) {</span>
              case Token.ERROR:
              case Token.EOF:
              case Token.EOL:
              case Token.SEMI:
<span class="fc" id="L1134">                break guessingStatementEnd;</span>
            }
<span class="fc" id="L1136">        }</span>
        // We don't make error nodes explicitly part of the tree;
        // they get added to the ErrorReporter.  May need to do
        // something different here.
<span class="fc" id="L1140">        return new EmptyStatement(pos, ts.tokenBeg - pos);</span>
    }

    private AstNode statementHelper()
        throws IOException
    {
        // If the statement is set, then it's been told its label by now.
<span class="fc bfc" id="L1147" title="All 4 branches covered.">        if (currentLabel != null &amp;&amp; currentLabel.getStatement() != null)</span>
<span class="fc" id="L1148">            currentLabel = null;</span>

<span class="fc" id="L1150">        AstNode pn = null;</span>
<span class="fc" id="L1151">        int tt = peekToken(), pos = ts.tokenBeg;</span>

<span class="pc bpc" id="L1153" title="1 of 21 branches missed.">        switch (tt) {</span>
          case Token.IF:
<span class="fc" id="L1155">              return ifStatement();</span>

          case Token.SWITCH:
<span class="fc" id="L1158">              return switchStatement();</span>

          case Token.WHILE:
<span class="fc" id="L1161">              return whileLoop();</span>

          case Token.DO:
<span class="fc" id="L1164">              return doLoop();</span>

          case Token.FOR:
<span class="fc" id="L1167">              return forLoop();</span>

          case Token.TRY:
<span class="fc" id="L1170">              return tryStatement();</span>

          case Token.THROW:
<span class="fc" id="L1173">              pn = throwStatement();</span>
<span class="fc" id="L1174">              break;</span>

          case Token.BREAK:
<span class="fc" id="L1177">              pn = breakStatement();</span>
<span class="fc" id="L1178">              break;</span>

          case Token.CONTINUE:
<span class="fc" id="L1181">              pn = continueStatement();</span>
<span class="fc" id="L1182">              break;</span>

          case Token.WITH:
<span class="pc bpc" id="L1185" title="1 of 2 branches missed.">              if (this.inUseStrictDirective) {</span>
<span class="nc" id="L1186">                  reportError(&quot;msg.no.with.strict&quot;);</span>
              }
<span class="fc" id="L1188">              return withStatement();</span>

          case Token.CONST:
          case Token.VAR:
<span class="fc" id="L1192">              consumeToken();</span>
<span class="fc" id="L1193">              int lineno = ts.lineno;</span>
<span class="fc" id="L1194">              pn = variables(currentToken, ts.tokenBeg, true);</span>
<span class="fc" id="L1195">              pn.setLineno(lineno);</span>
<span class="fc" id="L1196">              break;</span>

          case Token.LET:
<span class="fc" id="L1199">              pn = letStatement();</span>
<span class="fc bfc" id="L1200" title="All 2 branches covered.">              if (pn instanceof VariableDeclaration</span>
<span class="fc bfc" id="L1201" title="All 2 branches covered.">                  &amp;&amp; peekToken() == Token.SEMI)</span>
<span class="fc" id="L1202">                  break;</span>
<span class="fc" id="L1203">              return pn;</span>

          case Token.RETURN:
          case Token.YIELD:
<span class="fc" id="L1207">              pn = returnOrYield(tt, false);</span>
<span class="fc" id="L1208">              break;</span>

          case Token.DEBUGGER:
<span class="fc" id="L1211">              consumeToken();</span>
<span class="fc" id="L1212">              pn = new KeywordLiteral(ts.tokenBeg,</span>
                                      ts.tokenEnd - ts.tokenBeg, tt);
<span class="fc" id="L1214">              pn.setLineno(ts.lineno);</span>
<span class="fc" id="L1215">              break;</span>

          case Token.LC:
<span class="fc" id="L1218">              return block();</span>

          case Token.ERROR:
<span class="nc" id="L1221">              consumeToken();</span>
<span class="nc" id="L1222">              return makeErrorNode();</span>

          case Token.SEMI:
<span class="fc" id="L1225">              consumeToken();</span>
<span class="fc" id="L1226">              pos = ts.tokenBeg;</span>
<span class="fc" id="L1227">              pn = new EmptyStatement(pos, ts.tokenEnd - pos);</span>
<span class="fc" id="L1228">              pn.setLineno(ts.lineno);</span>
<span class="fc" id="L1229">              return pn;</span>

          case Token.FUNCTION:
<span class="fc" id="L1232">              consumeToken();</span>
<span class="fc" id="L1233">              return function(FunctionNode.FUNCTION_EXPRESSION_STATEMENT);</span>

          case Token.DEFAULT :
<span class="fc" id="L1236">              pn = defaultXmlNamespace();</span>
<span class="fc" id="L1237">              break;</span>

          case Token.NAME:
<span class="fc" id="L1240">              pn = nameOrLabel();</span>
<span class="fc bfc" id="L1241" title="All 2 branches covered.">              if (pn instanceof ExpressionStatement)</span>
<span class="fc" id="L1242">                  break;</span>
<span class="fc" id="L1243">              return pn;  // LabeledStatement</span>

          default:
<span class="fc" id="L1246">              lineno = ts.lineno;</span>
<span class="fc bfc" id="L1247" title="All 2 branches covered.">              pn = new ExpressionStatement(expr(), !insideFunction());</span>
<span class="fc" id="L1248">              pn.setLineno(lineno);</span>
              break;
        }

<span class="fc" id="L1252">        autoInsertSemicolon(pn);</span>
<span class="fc" id="L1253">        return pn;</span>
    }

    private void autoInsertSemicolon(AstNode pn) throws IOException {
<span class="fc" id="L1257">        int ttFlagged = peekFlaggedToken();</span>
<span class="fc" id="L1258">        int pos = pn.getPosition();</span>
<span class="fc bfc" id="L1259" title="All 3 branches covered.">        switch (ttFlagged &amp; CLEAR_TI_MASK) {</span>
          case Token.SEMI:
              // Consume ';' as a part of expression
<span class="fc" id="L1262">              consumeToken();</span>
              // extend the node bounds to include the semicolon.
<span class="fc" id="L1264">              pn.setLength(ts.tokenEnd - pos);</span>
<span class="fc" id="L1265">              break;</span>
          case Token.ERROR:
          case Token.EOF:
          case Token.RC:
              // Autoinsert ;
<span class="fc" id="L1270">              warnMissingSemi(pos, nodeEnd(pn));</span>
<span class="fc" id="L1271">              break;</span>
          default:
<span class="fc bfc" id="L1273" title="All 2 branches covered.">              if ((ttFlagged &amp; TI_AFTER_EOL) == 0) {</span>
                  // Report error if no EOL or autoinsert ; otherwise
<span class="fc" id="L1275">                  reportError(&quot;msg.no.semi.stmt&quot;);</span>
              } else {
<span class="fc" id="L1277">                  warnMissingSemi(pos, nodeEnd(pn));</span>
              }
              break;
        }
<span class="fc" id="L1281">    }</span>

    private IfStatement ifStatement()
        throws IOException
    {
<span class="pc bpc" id="L1286" title="1 of 2 branches missed.">        if (currentToken != Token.IF) codeBug();</span>
<span class="fc" id="L1287">        consumeToken();</span>
<span class="fc" id="L1288">        int pos = ts.tokenBeg, lineno = ts.lineno, elsePos = -1;</span>
<span class="fc" id="L1289">        ConditionData data = condition();</span>
<span class="fc" id="L1290">        AstNode ifTrue = statement(), ifFalse = null;</span>
<span class="fc bfc" id="L1291" title="All 2 branches covered.">        if (matchToken(Token.ELSE)) {</span>
<span class="fc" id="L1292">            elsePos = ts.tokenBeg - pos;</span>
<span class="fc" id="L1293">            ifFalse = statement();</span>
        }
<span class="fc bfc" id="L1295" title="All 2 branches covered.">        int end = getNodeEnd(ifFalse != null ? ifFalse : ifTrue);</span>
<span class="fc" id="L1296">        IfStatement pn = new IfStatement(pos, end - pos);</span>
<span class="fc" id="L1297">        pn.setCondition(data.condition);</span>
<span class="fc" id="L1298">        pn.setParens(data.lp - pos, data.rp - pos);</span>
<span class="fc" id="L1299">        pn.setThenPart(ifTrue);</span>
<span class="fc" id="L1300">        pn.setElsePart(ifFalse);</span>
<span class="fc" id="L1301">        pn.setElsePosition(elsePos);</span>
<span class="fc" id="L1302">        pn.setLineno(lineno);</span>
<span class="fc" id="L1303">        return pn;</span>
    }

    private SwitchStatement switchStatement()
        throws IOException
    {
<span class="pc bpc" id="L1309" title="1 of 2 branches missed.">        if (currentToken != Token.SWITCH) codeBug();</span>
<span class="fc" id="L1310">        consumeToken();</span>
<span class="fc" id="L1311">        int pos = ts.tokenBeg;</span>

<span class="fc" id="L1313">        SwitchStatement pn = new SwitchStatement(pos);</span>
<span class="pc bpc" id="L1314" title="1 of 2 branches missed.">        if (mustMatchToken(Token.LP, &quot;msg.no.paren.switch&quot;))</span>
<span class="fc" id="L1315">            pn.setLp(ts.tokenBeg - pos);</span>
<span class="fc" id="L1316">        pn.setLineno(ts.lineno);</span>

<span class="fc" id="L1318">        AstNode discriminant = expr();</span>
<span class="fc" id="L1319">        pn.setExpression(discriminant);</span>
<span class="fc" id="L1320">        enterSwitch(pn);</span>

        try {
<span class="pc bpc" id="L1323" title="1 of 2 branches missed.">            if (mustMatchToken(Token.RP, &quot;msg.no.paren.after.switch&quot;))</span>
<span class="fc" id="L1324">                pn.setRp(ts.tokenBeg - pos);</span>

<span class="fc" id="L1326">            mustMatchToken(Token.LC, &quot;msg.no.brace.switch&quot;);</span>

<span class="fc" id="L1328">            boolean hasDefault = false;</span>
            int tt;
            switchLoop: for (;;) {
<span class="fc" id="L1331">                tt = nextToken();</span>
<span class="fc" id="L1332">                int casePos = ts.tokenBeg;</span>
<span class="fc" id="L1333">                int caseLineno = ts.lineno;</span>
<span class="fc" id="L1334">                AstNode caseExpression = null;</span>
<span class="pc bpc" id="L1335" title="1 of 4 branches missed.">                switch (tt) {</span>
                    case Token.RC:
<span class="fc" id="L1337">                        pn.setLength(ts.tokenEnd - pos);</span>
<span class="fc" id="L1338">                        break switchLoop;</span>

                    case Token.CASE:
<span class="fc" id="L1341">                        caseExpression = expr();</span>
<span class="fc" id="L1342">                        mustMatchToken(Token.COLON, &quot;msg.no.colon.case&quot;);</span>
<span class="fc" id="L1343">                        break;</span>

                    case Token.DEFAULT:
<span class="pc bpc" id="L1346" title="1 of 2 branches missed.">                        if (hasDefault) {</span>
<span class="nc" id="L1347">                            reportError(&quot;msg.double.switch.default&quot;);</span>
                        }
<span class="fc" id="L1349">                        hasDefault = true;</span>
<span class="fc" id="L1350">                        caseExpression = null;</span>
<span class="fc" id="L1351">                        mustMatchToken(Token.COLON, &quot;msg.no.colon.case&quot;);</span>
<span class="fc" id="L1352">                        break;</span>

                    default:
<span class="nc" id="L1355">                        reportError(&quot;msg.bad.switch&quot;);</span>
<span class="nc" id="L1356">                        break switchLoop;</span>
                }

<span class="fc" id="L1359">                SwitchCase caseNode = new SwitchCase(casePos);</span>
<span class="fc" id="L1360">                caseNode.setExpression(caseExpression);</span>
<span class="fc" id="L1361">                caseNode.setLength(ts.tokenEnd - pos);  // include colon</span>
<span class="fc" id="L1362">                caseNode.setLineno(caseLineno);</span>

<span class="pc bpc" id="L1364" title="1 of 8 branches missed.">                while ((tt = peekToken()) != Token.RC</span>
                       &amp;&amp; tt != Token.CASE
                       &amp;&amp; tt != Token.DEFAULT
                       &amp;&amp; tt != Token.EOF)
                {
<span class="fc" id="L1369">                    caseNode.addStatement(statement());  // updates length</span>
                }
<span class="fc" id="L1371">                pn.addCase(caseNode);</span>
<span class="fc" id="L1372">            }</span>
        } finally {
<span class="fc" id="L1374">            exitSwitch();</span>
<span class="fc" id="L1375">        }</span>
<span class="fc" id="L1376">        return pn;</span>
    }

    private WhileLoop whileLoop()
        throws IOException
    {
<span class="pc bpc" id="L1382" title="1 of 2 branches missed.">        if (currentToken != Token.WHILE) codeBug();</span>
<span class="fc" id="L1383">        consumeToken();</span>
<span class="fc" id="L1384">        int pos = ts.tokenBeg;</span>
<span class="fc" id="L1385">        WhileLoop pn = new WhileLoop(pos);</span>
<span class="fc" id="L1386">        pn.setLineno(ts.lineno);</span>
<span class="fc" id="L1387">        enterLoop(pn);</span>
        try {
<span class="fc" id="L1389">            ConditionData data = condition();</span>
<span class="fc" id="L1390">            pn.setCondition(data.condition);</span>
<span class="fc" id="L1391">            pn.setParens(data.lp - pos, data.rp - pos);</span>
<span class="fc" id="L1392">            AstNode body = statement();</span>
<span class="fc" id="L1393">            pn.setLength(getNodeEnd(body) - pos);</span>
<span class="fc" id="L1394">            pn.setBody(body);</span>
        } finally {
<span class="fc" id="L1396">            exitLoop();</span>
<span class="fc" id="L1397">        }</span>
<span class="fc" id="L1398">        return pn;</span>
    }

    private DoLoop doLoop()
        throws IOException
    {
<span class="pc bpc" id="L1404" title="1 of 2 branches missed.">        if (currentToken != Token.DO) codeBug();</span>
<span class="fc" id="L1405">        consumeToken();</span>
<span class="fc" id="L1406">        int pos = ts.tokenBeg, end;</span>
<span class="fc" id="L1407">        DoLoop pn = new DoLoop(pos);</span>
<span class="fc" id="L1408">        pn.setLineno(ts.lineno);</span>
<span class="fc" id="L1409">        enterLoop(pn);</span>
        try {
<span class="fc" id="L1411">            AstNode body = statement();</span>
<span class="fc" id="L1412">            mustMatchToken(Token.WHILE, &quot;msg.no.while.do&quot;);</span>
<span class="fc" id="L1413">            pn.setWhilePosition(ts.tokenBeg - pos);</span>
<span class="fc" id="L1414">            ConditionData data = condition();</span>
<span class="fc" id="L1415">            pn.setCondition(data.condition);</span>
<span class="fc" id="L1416">            pn.setParens(data.lp - pos, data.rp - pos);</span>
<span class="fc" id="L1417">            end = getNodeEnd(body);</span>
<span class="fc" id="L1418">            pn.setBody(body);</span>
        } finally {
<span class="fc" id="L1420">            exitLoop();</span>
<span class="fc" id="L1421">        }</span>
        // Always auto-insert semicolon to follow SpiderMonkey:
        // It is required by ECMAScript but is ignored by the rest of
        // world, see bug 238945
<span class="fc bfc" id="L1425" title="All 2 branches covered.">        if (matchToken(Token.SEMI)) {</span>
<span class="fc" id="L1426">            end = ts.tokenEnd;</span>
        }
<span class="fc" id="L1428">        pn.setLength(end - pos);</span>
<span class="fc" id="L1429">        return pn;</span>
    }

    private Loop forLoop()
        throws IOException
    {
<span class="pc bpc" id="L1435" title="1 of 2 branches missed.">        if (currentToken != Token.FOR) codeBug();</span>
<span class="fc" id="L1436">        consumeToken();</span>
<span class="fc" id="L1437">        int forPos = ts.tokenBeg, lineno = ts.lineno;</span>
<span class="fc" id="L1438">        boolean isForEach = false, isForIn = false, isForOf = false;</span>
<span class="fc" id="L1439">        int eachPos = -1, inPos = -1, lp = -1, rp = -1;</span>
<span class="fc" id="L1440">        AstNode init = null;  // init is also foo in 'foo in object'</span>
<span class="fc" id="L1441">        AstNode cond = null;  // cond is also object in 'foo in object'</span>
<span class="fc" id="L1442">        AstNode incr = null;</span>
<span class="fc" id="L1443">        Loop pn = null;</span>

<span class="fc" id="L1445">        Scope tempScope = new Scope();</span>
<span class="fc" id="L1446">        pushScope(tempScope);  // decide below what AST class to use</span>
        try {
            // See if this is a for each () instead of just a for ()
<span class="fc bfc" id="L1449" title="All 2 branches covered.">            if (matchToken(Token.NAME)) {</span>
<span class="pc bpc" id="L1450" title="1 of 2 branches missed.">                if (&quot;each&quot;.equals(ts.getString())) {</span>
<span class="fc" id="L1451">                    isForEach = true;</span>
<span class="fc" id="L1452">                    eachPos = ts.tokenBeg - forPos;</span>
                } else {
<span class="nc" id="L1454">                    reportError(&quot;msg.no.paren.for&quot;);</span>
                }
            }

<span class="pc bpc" id="L1458" title="1 of 2 branches missed.">            if (mustMatchToken(Token.LP, &quot;msg.no.paren.for&quot;))</span>
<span class="fc" id="L1459">                lp = ts.tokenBeg - forPos;</span>
<span class="fc" id="L1460">            int tt = peekToken();</span>

<span class="fc" id="L1462">            init = forLoopInit(tt);</span>
<span class="fc bfc" id="L1463" title="All 2 branches covered.">            if (matchToken(Token.IN)) {</span>
<span class="fc" id="L1464">                isForIn = true;</span>
<span class="fc" id="L1465">                inPos = ts.tokenBeg - forPos;</span>
<span class="fc" id="L1466">                cond = expr();  // object over which we're iterating</span>
<span class="fc bfc" id="L1467" title="All 2 branches covered.">            } else if (compilerEnv.getLanguageVersion() &gt;= Context.VERSION_ES6 &amp;&amp;</span>
<span class="pc bpc" id="L1468" title="1 of 4 branches missed.">                       matchToken(Token.NAME) &amp;&amp; &quot;of&quot;.equals(ts.getString())) {</span>
<span class="fc" id="L1469">                isForOf = true;</span>
<span class="fc" id="L1470">                inPos = ts.tokenBeg - forPos;</span>
<span class="fc" id="L1471">                cond = expr();  // object over which we're iterating</span>
            } else {  // ordinary for-loop
<span class="fc" id="L1473">                mustMatchToken(Token.SEMI, &quot;msg.no.semi.for&quot;);</span>
<span class="fc bfc" id="L1474" title="All 2 branches covered.">                if (peekToken() == Token.SEMI) {</span>
                    // no loop condition
<span class="fc" id="L1476">                    cond = new EmptyExpression(ts.tokenBeg, 1);</span>
<span class="fc" id="L1477">                    cond.setLineno(ts.lineno);</span>
                } else {
<span class="fc" id="L1479">                    cond = expr();</span>
                }

<span class="fc" id="L1482">                mustMatchToken(Token.SEMI, &quot;msg.no.semi.for.cond&quot;);</span>
<span class="fc" id="L1483">                int tmpPos = ts.tokenEnd;</span>
<span class="fc bfc" id="L1484" title="All 2 branches covered.">                if (peekToken() == Token.RP) {</span>
<span class="fc" id="L1485">                    incr = new EmptyExpression(tmpPos, 1);</span>
<span class="fc" id="L1486">                    incr.setLineno(ts.lineno);</span>
                } else {
<span class="fc" id="L1488">                    incr = expr();</span>
                }
            }

<span class="pc bpc" id="L1492" title="1 of 2 branches missed.">            if (mustMatchToken(Token.RP, &quot;msg.no.paren.for.ctrl&quot;))</span>
<span class="fc" id="L1493">                rp = ts.tokenBeg - forPos;</span>

<span class="fc bfc" id="L1495" title="All 4 branches covered.">            if (isForIn || isForOf) {</span>
<span class="fc" id="L1496">                ForInLoop fis = new ForInLoop(forPos);</span>
<span class="fc bfc" id="L1497" title="All 2 branches covered.">                if (init instanceof VariableDeclaration) {</span>
                    // check that there was only one variable given
<span class="fc bfc" id="L1499" title="All 2 branches covered.">                    if (((VariableDeclaration)init).getVariables().size() &gt; 1) {</span>
<span class="nc" id="L1500">                        reportError(&quot;msg.mult.index&quot;);</span>
                    }
                }
<span class="fc bfc" id="L1503" title="All 4 branches covered.">                if (isForOf &amp;&amp; isForEach) {</span>
<span class="nc" id="L1504">                    reportError(&quot;msg.invalid.for.each&quot;);</span>
                }
<span class="fc" id="L1506">                fis.setIterator(init);</span>
<span class="fc" id="L1507">                fis.setIteratedObject(cond);</span>
<span class="fc" id="L1508">                fis.setInPosition(inPos);</span>
<span class="fc" id="L1509">                fis.setIsForEach(isForEach);</span>
<span class="fc" id="L1510">                fis.setEachPosition(eachPos);</span>
<span class="fc" id="L1511">                fis.setIsForOf(isForOf);</span>
<span class="fc" id="L1512">                pn = fis;</span>
<span class="fc" id="L1513">            } else {</span>
<span class="fc" id="L1514">                ForLoop fl = new ForLoop(forPos);</span>
<span class="fc" id="L1515">                fl.setInitializer(init);</span>
<span class="fc" id="L1516">                fl.setCondition(cond);</span>
<span class="fc" id="L1517">                fl.setIncrement(incr);</span>
<span class="fc" id="L1518">                pn = fl;</span>
            }

            // replace temp scope with the new loop object
<span class="fc" id="L1522">            currentScope.replaceWith(pn);</span>
<span class="fc" id="L1523">            popScope();</span>

            // We have to parse the body -after- creating the loop node,
            // so that the loop node appears in the loopSet, allowing
            // break/continue statements to find the enclosing loop.
<span class="fc" id="L1528">            enterLoop(pn);</span>
            try {
<span class="fc" id="L1530">                AstNode body = statement();</span>
<span class="fc" id="L1531">                pn.setLength(getNodeEnd(body) - forPos);</span>
<span class="fc" id="L1532">                pn.setBody(body);</span>
            } finally {
<span class="fc" id="L1534">                exitLoop();</span>
<span class="fc" id="L1535">            }</span>

        } finally {
<span class="pc bpc" id="L1538" title="1 of 4 branches missed.">            if (currentScope == tempScope) {</span>
<span class="pc" id="L1539">                popScope();</span>
            }
<span class="fc" id="L1541">        }</span>
<span class="fc" id="L1542">        pn.setParens(lp, rp);</span>
<span class="fc" id="L1543">        pn.setLineno(lineno);</span>
<span class="fc" id="L1544">        return pn;</span>
    }

    private AstNode forLoopInit(int tt) throws IOException {
        try {
<span class="fc" id="L1549">            inForInit = true;  // checked by variables() and relExpr()</span>
<span class="fc" id="L1550">            AstNode init = null;</span>
<span class="fc bfc" id="L1551" title="All 2 branches covered.">            if (tt == Token.SEMI) {</span>
<span class="fc" id="L1552">                init = new EmptyExpression(ts.tokenBeg, 1);</span>
<span class="fc" id="L1553">                init.setLineno(ts.lineno);</span>
<span class="fc bfc" id="L1554" title="All 4 branches covered.">            } else if (tt == Token.VAR || tt == Token.LET) {</span>
<span class="fc" id="L1555">                consumeToken();</span>
<span class="fc" id="L1556">                init = variables(tt, ts.tokenBeg, false);</span>
            } else {
<span class="fc" id="L1558">                init = expr();</span>
<span class="fc" id="L1559">                markDestructuring(init);</span>
            }
<span class="fc" id="L1561">            return init;</span>
        } finally {
<span class="fc" id="L1563">            inForInit = false;</span>
<span class="fc" id="L1564">        }</span>
    }

    private TryStatement tryStatement()
        throws IOException
    {
<span class="pc bpc" id="L1570" title="1 of 2 branches missed.">        if (currentToken != Token.TRY) codeBug();</span>
<span class="fc" id="L1571">        consumeToken();</span>

        // Pull out JSDoc info and reset it before recursing.
<span class="fc" id="L1574">        Comment jsdocNode = getAndResetJsDoc();</span>

<span class="fc" id="L1576">        int tryPos = ts.tokenBeg, lineno = ts.lineno, finallyPos = -1;</span>
<span class="fc bfc" id="L1577" title="All 2 branches covered.">        if (peekToken() != Token.LC) {</span>
<span class="nc" id="L1578">            reportError(&quot;msg.no.brace.try&quot;);</span>
        }
<span class="fc" id="L1580">        AstNode tryBlock = statement();</span>
<span class="fc" id="L1581">        int tryEnd = getNodeEnd(tryBlock);</span>

<span class="fc" id="L1583">        List&lt;CatchClause&gt; clauses = null;</span>

<span class="fc" id="L1585">        boolean sawDefaultCatch = false;</span>
<span class="fc" id="L1586">        int peek = peekToken();</span>
<span class="fc bfc" id="L1587" title="All 2 branches covered.">        if (peek == Token.CATCH) {</span>
<span class="fc bfc" id="L1588" title="All 2 branches covered.">            while (matchToken(Token.CATCH)) {</span>
<span class="fc" id="L1589">                int catchLineNum = ts.lineno;</span>
<span class="fc bfc" id="L1590" title="All 2 branches covered.">                if (sawDefaultCatch) {</span>
<span class="nc" id="L1591">                    reportError(&quot;msg.catch.unreachable&quot;);</span>
                }
<span class="fc" id="L1593">                int catchPos = ts.tokenBeg, lp = -1, rp = -1, guardPos = -1;</span>
<span class="pc bpc" id="L1594" title="1 of 2 branches missed.">                if (mustMatchToken(Token.LP, &quot;msg.no.paren.catch&quot;))</span>
<span class="fc" id="L1595">                    lp = ts.tokenBeg;</span>

<span class="fc" id="L1597">                mustMatchToken(Token.NAME, &quot;msg.bad.catchcond&quot;);</span>

<span class="fc" id="L1599">                Name varName = createNameNode();</span>
<span class="fc" id="L1600">                Comment jsdocNodeForName = getAndResetJsDoc();</span>
<span class="fc bfc" id="L1601" title="All 2 branches covered.">                if (jsdocNodeForName != null) {</span>
<span class="fc" id="L1602">                  varName.setJsDocNode(jsdocNodeForName);</span>
                }
<span class="fc" id="L1604">                String varNameString = varName.getIdentifier();</span>
<span class="fc bfc" id="L1605" title="All 2 branches covered.">                if (inUseStrictDirective) {</span>
<span class="pc bpc" id="L1606" title="1 of 2 branches missed.">                    if (&quot;eval&quot;.equals(varNameString) ||</span>
<span class="pc bpc" id="L1607" title="1 of 2 branches missed.">                        &quot;arguments&quot;.equals(varNameString))</span>
                    {
<span class="nc" id="L1609">                        reportError(&quot;msg.bad.id.strict&quot;, varNameString);</span>
                    }
                }

<span class="fc" id="L1613">                AstNode catchCond = null;</span>
<span class="fc bfc" id="L1614" title="All 2 branches covered.">                if (matchToken(Token.IF)) {</span>
<span class="fc" id="L1615">                    guardPos = ts.tokenBeg;</span>
<span class="fc" id="L1616">                    catchCond = expr();</span>
                } else {
<span class="fc" id="L1618">                    sawDefaultCatch = true;</span>
                }

<span class="pc bpc" id="L1621" title="1 of 2 branches missed.">                if (mustMatchToken(Token.RP, &quot;msg.bad.catchcond&quot;))</span>
<span class="fc" id="L1622">                    rp = ts.tokenBeg;</span>
<span class="fc" id="L1623">                mustMatchToken(Token.LC, &quot;msg.no.brace.catchblock&quot;);</span>

<span class="fc" id="L1625">                Block catchBlock = (Block)statements();</span>
<span class="fc" id="L1626">                tryEnd = getNodeEnd(catchBlock);</span>
<span class="fc" id="L1627">                CatchClause catchNode = new CatchClause(catchPos);</span>
<span class="fc" id="L1628">                catchNode.setVarName(varName);</span>
<span class="fc" id="L1629">                catchNode.setCatchCondition(catchCond);</span>
<span class="fc" id="L1630">                catchNode.setBody(catchBlock);</span>
<span class="fc bfc" id="L1631" title="All 2 branches covered.">                if (guardPos != -1) {</span>
<span class="fc" id="L1632">                    catchNode.setIfPosition(guardPos - catchPos);</span>
                }
<span class="fc" id="L1634">                catchNode.setParens(lp, rp);</span>
<span class="fc" id="L1635">                catchNode.setLineno(catchLineNum);</span>

<span class="pc bpc" id="L1637" title="1 of 2 branches missed.">                if (mustMatchToken(Token.RC, &quot;msg.no.brace.after.body&quot;))</span>
<span class="fc" id="L1638">                    tryEnd = ts.tokenEnd;</span>
<span class="fc" id="L1639">                catchNode.setLength(tryEnd - catchPos);</span>
<span class="fc bfc" id="L1640" title="All 2 branches covered.">                if (clauses == null)</span>
<span class="fc" id="L1641">                    clauses = new ArrayList&lt;CatchClause&gt;();</span>
<span class="fc" id="L1642">                clauses.add(catchNode);</span>
<span class="fc" id="L1643">            }</span>
<span class="pc bpc" id="L1644" title="1 of 2 branches missed.">        } else if (peek != Token.FINALLY) {</span>
<span class="nc" id="L1645">            mustMatchToken(Token.FINALLY, &quot;msg.try.no.catchfinally&quot;);</span>
        }

<span class="fc" id="L1648">        AstNode finallyBlock = null;</span>
<span class="fc bfc" id="L1649" title="All 2 branches covered.">        if (matchToken(Token.FINALLY)) {</span>
<span class="fc" id="L1650">            finallyPos = ts.tokenBeg;</span>
<span class="fc" id="L1651">            finallyBlock = statement();</span>
<span class="fc" id="L1652">            tryEnd = getNodeEnd(finallyBlock);</span>
        }

<span class="fc" id="L1655">        TryStatement pn = new TryStatement(tryPos, tryEnd - tryPos);</span>
<span class="fc" id="L1656">        pn.setTryBlock(tryBlock);</span>
<span class="fc" id="L1657">        pn.setCatchClauses(clauses);</span>
<span class="fc" id="L1658">        pn.setFinallyBlock(finallyBlock);</span>
<span class="fc bfc" id="L1659" title="All 2 branches covered.">        if (finallyPos != -1) {</span>
<span class="fc" id="L1660">            pn.setFinallyPosition(finallyPos - tryPos);</span>
        }
<span class="fc" id="L1662">        pn.setLineno(lineno);</span>

<span class="pc bpc" id="L1664" title="1 of 2 branches missed.">        if (jsdocNode != null) {</span>
<span class="nc" id="L1665">            pn.setJsDocNode(jsdocNode);</span>
        }

<span class="fc" id="L1668">        return pn;</span>
    }

    private ThrowStatement throwStatement()
        throws IOException
    {
<span class="pc bpc" id="L1674" title="1 of 2 branches missed.">        if (currentToken != Token.THROW) codeBug();</span>
<span class="fc" id="L1675">        consumeToken();</span>
<span class="fc" id="L1676">        int pos = ts.tokenBeg, lineno = ts.lineno;</span>
<span class="fc bfc" id="L1677" title="All 2 branches covered.">        if (peekTokenOrEOL() == Token.EOL) {</span>
            // ECMAScript does not allow new lines before throw expression,
            // see bug 256617
<span class="nc" id="L1680">            reportError(&quot;msg.bad.throw.eol&quot;);</span>
        }
<span class="fc" id="L1682">        AstNode expr = expr();</span>
<span class="fc" id="L1683">        ThrowStatement pn = new ThrowStatement(pos, getNodeEnd(expr), expr);</span>
<span class="fc" id="L1684">        pn.setLineno(lineno);</span>
<span class="fc" id="L1685">        return pn;</span>
    }

    // If we match a NAME, consume the token and return the statement
    // with that label.  If the name does not match an existing label,
    // reports an error.  Returns the labeled statement node, or null if
    // the peeked token was not a name.  Side effect:  sets scanner token
    // information for the label identifier (tokenBeg, tokenEnd, etc.)

    private LabeledStatement matchJumpLabelName()
        throws IOException
    {
<span class="fc" id="L1697">        LabeledStatement label = null;</span>

<span class="fc bfc" id="L1699" title="All 2 branches covered.">        if (peekTokenOrEOL() == Token.NAME) {</span>
<span class="fc" id="L1700">            consumeToken();</span>
<span class="pc bpc" id="L1701" title="1 of 2 branches missed.">            if (labelSet != null) {</span>
<span class="fc" id="L1702">                label = labelSet.get(ts.getString());</span>
            }
<span class="pc bpc" id="L1704" title="1 of 2 branches missed.">            if (label == null) {</span>
<span class="nc" id="L1705">                reportError(&quot;msg.undef.label&quot;);</span>
            }
        }

<span class="fc" id="L1709">        return label;</span>
    }

    private BreakStatement breakStatement()
        throws IOException
    {
<span class="pc bpc" id="L1715" title="1 of 2 branches missed.">        if (currentToken != Token.BREAK) codeBug();</span>
<span class="fc" id="L1716">        consumeToken();</span>
<span class="fc" id="L1717">        int lineno = ts.lineno, pos = ts.tokenBeg, end = ts.tokenEnd;</span>
<span class="fc" id="L1718">        Name breakLabel = null;</span>
<span class="fc bfc" id="L1719" title="All 2 branches covered.">        if (peekTokenOrEOL() == Token.NAME) {</span>
<span class="fc" id="L1720">            breakLabel = createNameNode();</span>
<span class="fc" id="L1721">            end = getNodeEnd(breakLabel);</span>
        }

        // matchJumpLabelName only matches if there is one
<span class="fc" id="L1725">        LabeledStatement labels = matchJumpLabelName();</span>
        // always use first label as target
<span class="fc bfc" id="L1727" title="All 2 branches covered.">        Jump breakTarget = labels == null ? null : labels.getFirstLabel();</span>

<span class="pc bpc" id="L1729" title="1 of 4 branches missed.">        if (breakTarget == null &amp;&amp; breakLabel == null) {</span>
<span class="pc bpc" id="L1730" title="1 of 4 branches missed.">            if (loopAndSwitchSet == null || loopAndSwitchSet.size() == 0) {</span>
<span class="pc bpc" id="L1731" title="1 of 2 branches missed.">                if (breakLabel == null) {</span>
<span class="nc" id="L1732">                    reportError(&quot;msg.bad.break&quot;, pos, end - pos);</span>
                }
            } else {
<span class="fc" id="L1735">                breakTarget = loopAndSwitchSet.get(loopAndSwitchSet.size() - 1);</span>
            }
        }

<span class="fc" id="L1739">        BreakStatement pn = new BreakStatement(pos, end - pos);</span>
<span class="fc" id="L1740">        pn.setBreakLabel(breakLabel);</span>
        // can be null if it's a bad break in error-recovery mode
<span class="pc bpc" id="L1742" title="1 of 2 branches missed.">        if (breakTarget != null)</span>
<span class="fc" id="L1743">            pn.setBreakTarget(breakTarget);</span>
<span class="fc" id="L1744">        pn.setLineno(lineno);</span>
<span class="fc" id="L1745">        return pn;</span>
    }

    private ContinueStatement continueStatement()
        throws IOException
    {
<span class="pc bpc" id="L1751" title="1 of 2 branches missed.">        if (currentToken != Token.CONTINUE) codeBug();</span>
<span class="fc" id="L1752">        consumeToken();</span>
<span class="fc" id="L1753">        int lineno = ts.lineno, pos = ts.tokenBeg, end = ts.tokenEnd;</span>
<span class="fc" id="L1754">        Name label = null;</span>
<span class="fc bfc" id="L1755" title="All 2 branches covered.">        if (peekTokenOrEOL() == Token.NAME) {</span>
<span class="fc" id="L1756">            label = createNameNode();</span>
<span class="fc" id="L1757">            end = getNodeEnd(label);</span>
        }

        // matchJumpLabelName only matches if there is one
<span class="fc" id="L1761">        LabeledStatement labels = matchJumpLabelName();</span>
<span class="fc" id="L1762">        Loop target = null;</span>
<span class="pc bpc" id="L1763" title="1 of 4 branches missed.">        if (labels == null &amp;&amp; label == null) {</span>
<span class="pc bpc" id="L1764" title="1 of 4 branches missed.">            if (loopSet == null || loopSet.size() == 0) {</span>
<span class="nc" id="L1765">                reportError(&quot;msg.continue.outside&quot;);</span>
            } else {
<span class="fc" id="L1767">                target = loopSet.get(loopSet.size() - 1);</span>
            }
        } else {
<span class="pc bpc" id="L1770" title="2 of 4 branches missed.">            if (labels == null || !(labels.getStatement() instanceof Loop)) {</span>
<span class="nc" id="L1771">                reportError(&quot;msg.continue.nonloop&quot;, pos, end - pos);</span>
            }
<span class="pc bpc" id="L1773" title="1 of 2 branches missed.">            target = labels == null ? null : (Loop)labels.getStatement();</span>
        }

<span class="fc" id="L1776">        ContinueStatement pn = new ContinueStatement(pos, end - pos);</span>
<span class="pc bpc" id="L1777" title="1 of 2 branches missed.">        if (target != null)  // can be null in error-recovery mode</span>
<span class="fc" id="L1778">            pn.setTarget(target);</span>
<span class="fc" id="L1779">        pn.setLabel(label);</span>
<span class="fc" id="L1780">        pn.setLineno(lineno);</span>
<span class="fc" id="L1781">        return pn;</span>
    }

    private WithStatement withStatement()
        throws IOException
    {
<span class="pc bpc" id="L1787" title="1 of 2 branches missed.">        if (currentToken != Token.WITH) codeBug();</span>
<span class="fc" id="L1788">        consumeToken();</span>

<span class="fc" id="L1790">        Comment withComment = getAndResetJsDoc();</span>

<span class="fc" id="L1792">        int lineno = ts.lineno, pos = ts.tokenBeg, lp = -1, rp = -1;</span>
<span class="pc bpc" id="L1793" title="1 of 2 branches missed.">        if (mustMatchToken(Token.LP, &quot;msg.no.paren.with&quot;))</span>
<span class="fc" id="L1794">            lp = ts.tokenBeg;</span>

<span class="fc" id="L1796">        AstNode obj = expr();</span>

<span class="pc bpc" id="L1798" title="1 of 2 branches missed.">        if (mustMatchToken(Token.RP, &quot;msg.no.paren.after.with&quot;))</span>
<span class="fc" id="L1799">            rp = ts.tokenBeg;</span>

<span class="fc" id="L1801">        AstNode body = statement();</span>

<span class="fc" id="L1803">        WithStatement pn = new WithStatement(pos, getNodeEnd(body) - pos);</span>
<span class="fc" id="L1804">        pn.setJsDocNode(withComment);</span>
<span class="fc" id="L1805">        pn.setExpression(obj);</span>
<span class="fc" id="L1806">        pn.setStatement(body);</span>
<span class="fc" id="L1807">        pn.setParens(lp, rp);</span>
<span class="fc" id="L1808">        pn.setLineno(lineno);</span>
<span class="fc" id="L1809">        return pn;</span>
    }

    private AstNode letStatement()
        throws IOException
    {
<span class="pc bpc" id="L1815" title="1 of 2 branches missed.">        if (currentToken != Token.LET) codeBug();</span>
<span class="fc" id="L1816">        consumeToken();</span>
<span class="fc" id="L1817">        int lineno = ts.lineno, pos = ts.tokenBeg;</span>
        AstNode pn;
<span class="fc bfc" id="L1819" title="All 2 branches covered.">        if (peekToken() == Token.LP) {</span>
<span class="fc" id="L1820">            pn = let(true, pos);</span>
        } else {
<span class="fc" id="L1822">            pn = variables(Token.LET, pos, true);  // else, e.g.: let x=6, y=7;</span>
        }
<span class="fc" id="L1824">        pn.setLineno(lineno);</span>
<span class="fc" id="L1825">        return pn;</span>
    }

    /**
     * Returns whether or not the bits in the mask have changed to all set.
     * @param before bits before change
     * @param after bits after change
     * @param mask mask for bits
     * @return {@code true} if all the bits in the mask are set in &quot;after&quot;
     *          but not in &quot;before&quot;
     */
    private static final boolean nowAllSet(int before, int after, int mask) {
<span class="pc bpc" id="L1837" title="1 of 4 branches missed.">        return ((before &amp; mask) != mask) &amp;&amp; ((after &amp; mask) == mask);</span>
    }

    private AstNode returnOrYield(int tt, boolean exprContext)
        throws IOException
    {
<span class="fc bfc" id="L1843" title="All 2 branches covered.">        if (!insideFunction()) {</span>
<span class="pc bpc" id="L1844" title="1 of 2 branches missed.">            reportError(tt == Token.RETURN ? &quot;msg.bad.return&quot;</span>
                                           : &quot;msg.bad.yield&quot;);
        }
<span class="fc" id="L1847">        consumeToken();</span>
<span class="fc" id="L1848">        int lineno = ts.lineno, pos = ts.tokenBeg, end = ts.tokenEnd;</span>

<span class="fc" id="L1850">        AstNode e = null;</span>
        // This is ugly, but we don't want to require a semicolon.
<span class="fc bfc" id="L1852" title="All 2 branches covered.">        switch (peekTokenOrEOL()) {</span>
          case Token.SEMI: case Token.RC:  case Token.RB:    case Token.RP:
          case Token.EOF:  case Token.EOL: case Token.ERROR: case Token.YIELD:
<span class="fc" id="L1855">            break;</span>
          default:
<span class="fc" id="L1857">            e = expr();</span>
<span class="fc" id="L1858">            end = getNodeEnd(e);</span>
        }

<span class="fc" id="L1861">        int before = endFlags;</span>
        AstNode ret;

<span class="fc bfc" id="L1864" title="All 2 branches covered.">        if (tt == Token.RETURN) {</span>
<span class="fc bfc" id="L1865" title="All 2 branches covered.">            endFlags |= e == null ? Node.END_RETURNS : Node.END_RETURNS_VALUE;</span>
<span class="fc" id="L1866">            ret = new ReturnStatement(pos, end - pos, e);</span>

            // see if we need a strict mode warning
<span class="fc bfc" id="L1869" title="All 2 branches covered.">            if (nowAllSet(before, endFlags,</span>
                    Node.END_RETURNS|Node.END_RETURNS_VALUE))
<span class="fc" id="L1871">                addStrictWarning(&quot;msg.return.inconsistent&quot;, &quot;&quot;, pos, end - pos);</span>
        } else {
<span class="pc bpc" id="L1873" title="1 of 2 branches missed.">            if (!insideFunction())</span>
<span class="nc" id="L1874">                reportError(&quot;msg.bad.yield&quot;);</span>
<span class="fc" id="L1875">            endFlags |= Node.END_YIELDS;</span>
<span class="fc" id="L1876">            ret = new Yield(pos, end - pos, e);</span>
<span class="fc" id="L1877">            setRequiresActivation();</span>
<span class="fc" id="L1878">            setIsGenerator();</span>
<span class="fc bfc" id="L1879" title="All 2 branches covered.">            if (!exprContext) {</span>
<span class="fc" id="L1880">                ret = new ExpressionStatement(ret);</span>
            }
        }

        // see if we are mixing yields and value returns.
<span class="pc bpc" id="L1885" title="1 of 2 branches missed.">        if (insideFunction()</span>
<span class="fc bfc" id="L1886" title="All 2 branches covered.">            &amp;&amp; nowAllSet(before, endFlags,</span>
                    Node.END_YIELDS|Node.END_RETURNS_VALUE)) {
<span class="fc" id="L1888">            Name name = ((FunctionNode)currentScriptOrFn).getFunctionName();</span>
<span class="pc bpc" id="L1889" title="3 of 4 branches missed.">            if (name == null || name.length() == 0)</span>
<span class="nc" id="L1890">                addError(&quot;msg.anon.generator.returns&quot;, &quot;&quot;);</span>
            else
<span class="nc" id="L1892">                addError(&quot;msg.generator.returns&quot;, name.getIdentifier());</span>
        }

<span class="fc" id="L1895">        ret.setLineno(lineno);</span>
<span class="fc" id="L1896">        return ret;</span>
    }

    private AstNode block()
        throws IOException
    {
<span class="pc bpc" id="L1902" title="1 of 2 branches missed.">        if (currentToken != Token.LC) codeBug();</span>
<span class="fc" id="L1903">        consumeToken();</span>
<span class="fc" id="L1904">        int pos = ts.tokenBeg;</span>
<span class="fc" id="L1905">        Scope block = new Scope(pos);</span>
<span class="fc" id="L1906">        block.setLineno(ts.lineno);</span>
<span class="fc" id="L1907">        pushScope(block);</span>
        try {
<span class="fc" id="L1909">            statements(block);</span>
<span class="fc" id="L1910">            mustMatchToken(Token.RC, &quot;msg.no.brace.block&quot;);</span>
<span class="fc" id="L1911">            block.setLength(ts.tokenEnd - pos);</span>
<span class="fc" id="L1912">            return block;</span>
        } finally {
<span class="fc" id="L1914">            popScope();</span>
<span class="fc" id="L1915">        }</span>
    }

    private AstNode defaultXmlNamespace()
        throws IOException
    {
<span class="pc bpc" id="L1921" title="1 of 2 branches missed.">        if (currentToken != Token.DEFAULT) codeBug();</span>
<span class="fc" id="L1922">        consumeToken();</span>
<span class="fc" id="L1923">        mustHaveXML();</span>
<span class="fc" id="L1924">        setRequiresActivation();</span>
<span class="fc" id="L1925">        int lineno = ts.lineno, pos = ts.tokenBeg;</span>

<span class="pc bpc" id="L1927" title="2 of 4 branches missed.">        if (!(matchToken(Token.NAME) &amp;&amp; &quot;xml&quot;.equals(ts.getString()))) {</span>
<span class="nc" id="L1928">            reportError(&quot;msg.bad.namespace&quot;);</span>
        }
<span class="pc bpc" id="L1930" title="2 of 4 branches missed.">        if (!(matchToken(Token.NAME) &amp;&amp; &quot;namespace&quot;.equals(ts.getString()))) {</span>
<span class="nc" id="L1931">            reportError(&quot;msg.bad.namespace&quot;);</span>
        }
<span class="pc bpc" id="L1933" title="1 of 2 branches missed.">        if (!matchToken(Token.ASSIGN)) {</span>
<span class="nc" id="L1934">            reportError(&quot;msg.bad.namespace&quot;);</span>
        }

<span class="fc" id="L1937">        AstNode e = expr();</span>
<span class="fc" id="L1938">        UnaryExpression dxmln = new UnaryExpression(pos, getNodeEnd(e) - pos);</span>
<span class="fc" id="L1939">        dxmln.setOperator(Token.DEFAULTNAMESPACE);</span>
<span class="fc" id="L1940">        dxmln.setOperand(e);</span>
<span class="fc" id="L1941">        dxmln.setLineno(lineno);</span>

<span class="fc" id="L1943">        ExpressionStatement es = new ExpressionStatement(dxmln, true);</span>
<span class="fc" id="L1944">        return es;</span>
    }

    private void recordLabel(Label label, LabeledStatement bundle)
        throws IOException
    {
        // current token should be colon that primaryExpr left untouched
<span class="pc bpc" id="L1951" title="1 of 2 branches missed.">        if (peekToken() != Token.COLON) codeBug();</span>
<span class="fc" id="L1952">        consumeToken();</span>
<span class="fc" id="L1953">        String name = label.getName();</span>
<span class="fc bfc" id="L1954" title="All 2 branches covered.">        if (labelSet == null) {</span>
<span class="fc" id="L1955">            labelSet = new HashMap&lt;String,LabeledStatement&gt;();</span>
        } else {
<span class="fc" id="L1957">            LabeledStatement ls = labelSet.get(name);</span>
<span class="pc bpc" id="L1958" title="1 of 2 branches missed.">            if (ls != null) {</span>
<span class="nc bnc" id="L1959" title="All 2 branches missed.">                if (compilerEnv.isIdeMode()) {</span>
<span class="nc" id="L1960">                    Label dup = ls.getLabelByName(name);</span>
<span class="nc" id="L1961">                    reportError(&quot;msg.dup.label&quot;,</span>
<span class="nc" id="L1962">                                dup.getAbsolutePosition(), dup.getLength());</span>
                }
<span class="nc" id="L1964">                reportError(&quot;msg.dup.label&quot;,</span>
<span class="nc" id="L1965">                            label.getPosition(), label.getLength());</span>
            }
        }
<span class="fc" id="L1968">        bundle.addLabel(label);</span>
<span class="fc" id="L1969">        labelSet.put(name, bundle);</span>
<span class="fc" id="L1970">    }</span>

    /**
     * Found a name in a statement context.  If it's a label, we gather
     * up any following labels and the next non-label statement into a
     * {@link LabeledStatement} &quot;bundle&quot; and return that.  Otherwise we parse
     * an expression and return it wrapped in an {@link ExpressionStatement}.
     */
    private AstNode nameOrLabel()
        throws IOException
    {
<span class="pc bpc" id="L1981" title="1 of 2 branches missed.">        if (currentToken != Token.NAME) throw codeBug();</span>
<span class="fc" id="L1982">        int pos = ts.tokenBeg;</span>

        // set check for label and call down to primaryExpr
<span class="fc" id="L1985">        currentFlaggedToken |= TI_CHECK_LABEL;</span>
<span class="fc" id="L1986">        AstNode expr = expr();</span>

<span class="fc bfc" id="L1988" title="All 2 branches covered.">        if (expr.getType() != Token.LABEL) {</span>
<span class="fc bfc" id="L1989" title="All 2 branches covered.">            AstNode n = new ExpressionStatement(expr, !insideFunction());</span>
<span class="fc" id="L1990">            n.lineno = expr.lineno;</span>
<span class="fc" id="L1991">            return n;</span>
        }

<span class="fc" id="L1994">        LabeledStatement bundle = new LabeledStatement(pos);</span>
<span class="fc" id="L1995">        recordLabel((Label)expr, bundle);</span>
<span class="fc" id="L1996">        bundle.setLineno(ts.lineno);</span>
        // look for more labels
<span class="fc" id="L1998">        AstNode stmt = null;</span>
<span class="fc bfc" id="L1999" title="All 2 branches covered.">        while (peekToken() == Token.NAME) {</span>
<span class="fc" id="L2000">            currentFlaggedToken |= TI_CHECK_LABEL;</span>
<span class="fc" id="L2001">            expr = expr();</span>
<span class="fc bfc" id="L2002" title="All 2 branches covered.">            if (expr.getType() != Token.LABEL) {</span>
<span class="pc bpc" id="L2003" title="1 of 2 branches missed.">                stmt = new ExpressionStatement(expr, !insideFunction());</span>
<span class="fc" id="L2004">                autoInsertSemicolon(stmt);</span>
<span class="fc" id="L2005">                break;</span>
            }
<span class="fc" id="L2007">            recordLabel((Label)expr, bundle);</span>
        }

        // no more labels; now parse the labeled statement
        try {
<span class="fc" id="L2012">            currentLabel = bundle;</span>
<span class="fc bfc" id="L2013" title="All 2 branches covered.">            if (stmt == null) {</span>
<span class="fc" id="L2014">                stmt = statementHelper();</span>
            }
        } finally {
<span class="fc" id="L2017">            currentLabel = null;</span>
            // remove the labels for this statement from the global set
<span class="fc bfc" id="L2019" title="All 4 branches covered.">            for (Label lb : bundle.getLabels()) {</span>
<span class="fc" id="L2020">                labelSet.remove(lb.getName());</span>
<span class="fc" id="L2021">            }</span>
<span class="fc" id="L2022">        }</span>

        // If stmt has parent assigned its position already is relative
        // (See bug #710225)
<span class="fc bfc" id="L2026" title="All 2 branches covered.">        bundle.setLength(stmt.getParent() == null</span>
<span class="fc" id="L2027">                     ? getNodeEnd(stmt) - pos</span>
<span class="fc" id="L2028">                     : getNodeEnd(stmt));</span>
<span class="fc" id="L2029">        bundle.setStatement(stmt);</span>
<span class="fc" id="L2030">        return bundle;</span>
    }

    /**
     * Parse a 'var' or 'const' statement, or a 'var' init list in a for
     * statement.
     * @param declType A token value: either VAR, CONST, or LET depending on
     * context.
     * @param pos the position where the node should start.  It's sometimes
     * the var/const/let keyword, and other times the beginning of the first
     * token in the first variable declaration.
     * @return the parsed variable list
     */
    private VariableDeclaration variables(int declType, int pos, boolean isStatement)
        throws IOException
    {
        int end;
<span class="fc" id="L2047">        VariableDeclaration pn = new VariableDeclaration(pos);</span>
<span class="fc" id="L2048">        pn.setType(declType);</span>
<span class="fc" id="L2049">        pn.setLineno(ts.lineno);</span>
<span class="fc" id="L2050">        Comment varjsdocNode = getAndResetJsDoc();</span>
<span class="fc bfc" id="L2051" title="All 2 branches covered.">        if (varjsdocNode != null) {</span>
<span class="fc" id="L2052">            pn.setJsDocNode(varjsdocNode);</span>
        }
        // Example:
        // var foo = {a: 1, b: 2}, bar = [3, 4];
        // var {b: s2, a: s1} = foo, x = 6, y, [s3, s4] = bar;
        for (;;) {
<span class="fc" id="L2058">            AstNode destructuring = null;</span>
<span class="fc" id="L2059">            Name name = null;</span>
<span class="fc" id="L2060">            int tt = peekToken(), kidPos = ts.tokenBeg;</span>
<span class="fc" id="L2061">            end = ts.tokenEnd;</span>

<span class="fc bfc" id="L2063" title="All 4 branches covered.">            if (tt == Token.LB || tt == Token.LC) {</span>
                // Destructuring assignment, e.g., var [a,b] = ...
<span class="fc" id="L2065">                destructuring = destructuringPrimaryExpr();</span>
<span class="fc" id="L2066">                end = getNodeEnd(destructuring);</span>
<span class="fc bfc" id="L2067" title="All 2 branches covered.">                if (!(destructuring instanceof DestructuringForm))</span>
<span class="nc" id="L2068">                    reportError(&quot;msg.bad.assign.left&quot;, kidPos, end - kidPos);</span>
<span class="fc" id="L2069">                markDestructuring(destructuring);</span>
            } else {
                // Simple variable name
<span class="fc" id="L2072">                mustMatchToken(Token.NAME, &quot;msg.bad.var&quot;);</span>
<span class="fc" id="L2073">                name = createNameNode();</span>
<span class="fc" id="L2074">                name.setLineno(ts.getLineno());</span>
<span class="fc bfc" id="L2075" title="All 2 branches covered.">                if (inUseStrictDirective) {</span>
<span class="fc" id="L2076">                    String id = ts.getString();</span>
<span class="pc bpc" id="L2077" title="2 of 4 branches missed.">                    if (&quot;eval&quot;.equals(id) || &quot;arguments&quot;.equals(ts.getString()))</span>
                    {
<span class="nc" id="L2079">                        reportError(&quot;msg.bad.id.strict&quot;, id);</span>
                    }
                }
<span class="fc" id="L2082">                defineSymbol(declType, ts.getString(), inForInit);</span>
            }

<span class="fc" id="L2085">            int lineno = ts.lineno;</span>

<span class="fc" id="L2087">            Comment jsdocNode = getAndResetJsDoc();</span>

<span class="fc" id="L2089">            AstNode init = null;</span>
<span class="fc bfc" id="L2090" title="All 2 branches covered.">            if (matchToken(Token.ASSIGN)) {</span>
<span class="fc" id="L2091">                init = assignExpr();</span>
<span class="fc" id="L2092">                end = getNodeEnd(init);</span>
            }

<span class="fc" id="L2095">            VariableInitializer vi = new VariableInitializer(kidPos, end - kidPos);</span>
<span class="fc bfc" id="L2096" title="All 2 branches covered.">            if (destructuring != null) {</span>
<span class="pc bpc" id="L2097" title="1 of 4 branches missed.">                if (init == null &amp;&amp; !inForInit) {</span>
<span class="nc" id="L2098">                    reportError(&quot;msg.destruct.assign.no.init&quot;);</span>
                }
<span class="fc" id="L2100">                vi.setTarget(destructuring);</span>
            } else {
<span class="fc" id="L2102">                vi.setTarget(name);</span>
            }
<span class="fc" id="L2104">            vi.setInitializer(init);</span>
<span class="fc" id="L2105">            vi.setType(declType);</span>
<span class="fc" id="L2106">            vi.setJsDocNode(jsdocNode);</span>
<span class="fc" id="L2107">            vi.setLineno(lineno);</span>
<span class="fc" id="L2108">            pn.addVariable(vi);</span>

<span class="fc bfc" id="L2110" title="All 2 branches covered.">            if (!matchToken(Token.COMMA))</span>
<span class="fc" id="L2111">                break;</span>
<span class="fc" id="L2112">        }</span>
<span class="fc" id="L2113">        pn.setLength(end - pos);</span>
<span class="fc" id="L2114">        pn.setIsStatement(isStatement);</span>
<span class="fc" id="L2115">        return pn;</span>
    }

    // have to pass in 'let' kwd position to compute kid offsets properly
    private AstNode let(boolean isStatement, int pos)
        throws IOException
    {
<span class="fc" id="L2122">        LetNode pn = new LetNode(pos);</span>
<span class="fc" id="L2123">        pn.setLineno(ts.lineno);</span>
<span class="pc bpc" id="L2124" title="1 of 2 branches missed.">        if (mustMatchToken(Token.LP, &quot;msg.no.paren.after.let&quot;))</span>
<span class="fc" id="L2125">            pn.setLp(ts.tokenBeg - pos);</span>
<span class="fc" id="L2126">        pushScope(pn);</span>
        try {
<span class="fc" id="L2128">            VariableDeclaration vars = variables(Token.LET, ts.tokenBeg, isStatement);</span>
<span class="fc" id="L2129">            pn.setVariables(vars);</span>
<span class="pc bpc" id="L2130" title="1 of 2 branches missed.">            if (mustMatchToken(Token.RP, &quot;msg.no.paren.let&quot;)) {</span>
<span class="fc" id="L2131">                pn.setRp(ts.tokenBeg - pos);</span>
            }
<span class="fc bfc" id="L2133" title="All 4 branches covered.">            if (isStatement &amp;&amp; peekToken() == Token.LC) {</span>
                // let statement
<span class="fc" id="L2135">                consumeToken();</span>
<span class="fc" id="L2136">                int beg = ts.tokenBeg;  // position stmt at LC</span>
<span class="fc" id="L2137">                AstNode stmt = statements();</span>
<span class="fc" id="L2138">                mustMatchToken(Token.RC, &quot;msg.no.curly.let&quot;);</span>
<span class="fc" id="L2139">                stmt.setLength(ts.tokenEnd - beg);</span>
<span class="fc" id="L2140">                pn.setLength(ts.tokenEnd - pos);</span>
<span class="fc" id="L2141">                pn.setBody(stmt);</span>
<span class="fc" id="L2142">                pn.setType(Token.LET);</span>
<span class="fc" id="L2143">            } else {</span>
                // let expression
<span class="fc" id="L2145">                AstNode expr = expr();</span>
<span class="fc" id="L2146">                pn.setLength(getNodeEnd(expr) - pos);</span>
<span class="fc" id="L2147">                pn.setBody(expr);</span>
<span class="fc bfc" id="L2148" title="All 2 branches covered.">                if (isStatement) {</span>
                    // let expression in statement context
<span class="fc" id="L2150">                    ExpressionStatement es =</span>
<span class="fc bfc" id="L2151" title="All 2 branches covered.">                            new ExpressionStatement(pn, !insideFunction());</span>
<span class="fc" id="L2152">                    es.setLineno(pn.getLineno());</span>
<span class="fc" id="L2153">                    return es;</span>
                }
            }
        } finally {
<span class="fc" id="L2157">            popScope();</span>
<span class="fc" id="L2158">        }</span>
<span class="fc" id="L2159">        return pn;</span>
    }

    void defineSymbol(int declType, String name) {
<span class="fc" id="L2163">        defineSymbol(declType, name, false);</span>
<span class="fc" id="L2164">    }</span>

    void defineSymbol(int declType, String name, boolean ignoreNotInBlock) {
<span class="pc bpc" id="L2167" title="1 of 2 branches missed.">        if (name == null) {</span>
<span class="nc bnc" id="L2168" title="All 2 branches missed.">            if (compilerEnv.isIdeMode()) {  // be robust in IDE-mode</span>
<span class="nc" id="L2169">                return;</span>
            } else {
<span class="nc" id="L2171">                codeBug();</span>
            }
        }
<span class="fc" id="L2174">        Scope definingScope = currentScope.getDefiningScope(name);</span>
<span class="fc bfc" id="L2175" title="All 2 branches covered.">        Symbol symbol = definingScope != null</span>
<span class="fc" id="L2176">                        ? definingScope.getSymbol(name)</span>
                        : null;
<span class="fc bfc" id="L2178" title="All 2 branches covered.">        int symDeclType = symbol != null ? symbol.getDeclType() : -1;</span>
<span class="pc bpc" id="L2179" title="1 of 10 branches missed.">        if (symbol != null</span>
            &amp;&amp; (symDeclType == Token.CONST
                || declType == Token.CONST
                || (definingScope == currentScope &amp;&amp; symDeclType == Token.LET)))
        {
<span class="pc bpc" id="L2184" title="5 of 8 branches missed.">            addError(symDeclType == Token.CONST ? &quot;msg.const.redecl&quot; :</span>
                     symDeclType == Token.LET ? &quot;msg.let.redecl&quot; :
                     symDeclType == Token.VAR ? &quot;msg.var.redecl&quot; :
                     symDeclType == Token.FUNCTION ? &quot;msg.fn.redecl&quot; :
                     &quot;msg.parm.redecl&quot;, name);
<span class="nc" id="L2189">            return;</span>
        }
<span class="pc bpc" id="L2191" title="1 of 4 branches missed.">        switch (declType) {</span>
          case Token.LET:
<span class="fc bfc" id="L2193" title="All 2 branches covered.">              if (!ignoreNotInBlock &amp;&amp;</span>
<span class="pc bpc" id="L2194" title="1 of 4 branches missed.">                  ((currentScope.getType() == Token.IF) ||</span>
                   currentScope instanceof Loop)) {
<span class="nc" id="L2196">                  addError(&quot;msg.let.decl.not.in.block&quot;);</span>
<span class="nc" id="L2197">                  return;</span>
              }
<span class="fc" id="L2199">              currentScope.putSymbol(new Symbol(declType, name));</span>
<span class="fc" id="L2200">              return;</span>

          case Token.VAR:
          case Token.CONST:
          case Token.FUNCTION:
<span class="fc bfc" id="L2205" title="All 2 branches covered.">              if (symbol != null) {</span>
<span class="fc bfc" id="L2206" title="All 2 branches covered.">                  if (symDeclType == Token.VAR)</span>
<span class="fc" id="L2207">                      addStrictWarning(&quot;msg.var.redecl&quot;, name);</span>
<span class="fc bfc" id="L2208" title="All 2 branches covered.">                  else if (symDeclType == Token.LP) {</span>
<span class="fc" id="L2209">                      addStrictWarning(&quot;msg.var.hides.arg&quot;, name);</span>
                  }
              } else {
<span class="fc" id="L2212">                  currentScriptOrFn.putSymbol(new Symbol(declType, name));</span>
              }
<span class="fc" id="L2214">              return;</span>

          case Token.LP:
<span class="fc bfc" id="L2217" title="All 2 branches covered.">              if (symbol != null) {</span>
                  // must be duplicate parameter. Second parameter hides the
                  // first, so go ahead and add the second parameter
<span class="fc" id="L2220">                  addWarning(&quot;msg.dup.parms&quot;, name);</span>
              }
<span class="fc" id="L2222">              currentScriptOrFn.putSymbol(new Symbol(declType, name));</span>
<span class="fc" id="L2223">              return;</span>

          default:
<span class="nc" id="L2226">              throw codeBug();</span>
        }
    }

    private AstNode expr()
        throws IOException
    {
<span class="fc" id="L2233">        AstNode pn = assignExpr();</span>
<span class="fc" id="L2234">        int pos = pn.getPosition();</span>
<span class="fc bfc" id="L2235" title="All 2 branches covered.">        while (matchToken(Token.COMMA)) {</span>
<span class="fc" id="L2236">            int opPos = ts.tokenBeg;</span>
<span class="pc bpc" id="L2237" title="3 of 4 branches missed.">            if (compilerEnv.isStrictMode() &amp;&amp; !pn.hasSideEffects())</span>
<span class="nc" id="L2238">                addStrictWarning(&quot;msg.no.side.effects&quot;, &quot;&quot;,</span>
<span class="nc" id="L2239">                                 pos, nodeEnd(pn) - pos);</span>
<span class="pc bpc" id="L2240" title="1 of 2 branches missed.">            if (peekToken() == Token.YIELD)</span>
<span class="nc" id="L2241">                reportError(&quot;msg.yield.parenthesized&quot;);</span>
<span class="fc" id="L2242">            pn = new InfixExpression(Token.COMMA, pn, assignExpr(), opPos);</span>
<span class="fc" id="L2243">        }</span>
<span class="fc" id="L2244">        return pn;</span>
    }

    private AstNode assignExpr()
        throws IOException
    {
<span class="fc" id="L2250">        int tt = peekToken();</span>
<span class="fc bfc" id="L2251" title="All 2 branches covered.">        if (tt == Token.YIELD) {</span>
<span class="fc" id="L2252">            return returnOrYield(tt, true);</span>
        }
<span class="fc" id="L2254">        AstNode pn = condExpr();</span>
<span class="fc" id="L2255">        boolean hasEOL = false;</span>
<span class="fc" id="L2256">        tt = peekTokenOrEOL();</span>
<span class="fc bfc" id="L2257" title="All 2 branches covered.">        if (tt == Token.EOL) {</span>
<span class="fc" id="L2258">            hasEOL = true;</span>
<span class="fc" id="L2259">            tt = peekToken();</span>
        }
<span class="fc bfc" id="L2261" title="All 4 branches covered.">        if (Token.FIRST_ASSIGN &lt;= tt &amp;&amp; tt &lt;= Token.LAST_ASSIGN) {</span>
<span class="fc bfc" id="L2262" title="All 2 branches covered.">            if (inDestructuringAssignment) {</span>
                // default values inside destructuring assignments,
                // like 'var [a = 10] = b' or 'var {a: b = 10} = c',
                // are not supported
<span class="nc" id="L2266">                reportError(&quot;msg.destruct.default.vals&quot;);</span>
            }

<span class="fc" id="L2269">            consumeToken();</span>

            // Pull out JSDoc info and reset it before recursing.
<span class="fc" id="L2272">            Comment jsdocNode = getAndResetJsDoc();</span>

<span class="fc" id="L2274">            markDestructuring(pn);</span>
<span class="fc" id="L2275">            int opPos = ts.tokenBeg;</span>

<span class="fc" id="L2277">            pn = new Assignment(tt, pn, assignExpr(), opPos);</span>

<span class="pc bpc" id="L2279" title="1 of 2 branches missed.">            if (jsdocNode != null) {</span>
<span class="nc" id="L2280">                pn.setJsDocNode(jsdocNode);</span>
            }
<span class="fc bfc" id="L2282" title="All 2 branches covered.">        } else if (tt == Token.SEMI) {</span>
            // This may be dead code added intentionally, for JSDoc purposes.
            // For example: /** @type Number */ C.prototype.x;
<span class="fc bfc" id="L2285" title="All 2 branches covered.">            if (currentJsDocComment != null) {</span>
<span class="fc" id="L2286">                pn.setJsDocNode(getAndResetJsDoc());</span>
            }
<span class="fc bfc" id="L2288" title="All 4 branches covered.">        } else if (!hasEOL &amp;&amp; tt == Token.ARROW) {</span>
<span class="fc" id="L2289">            consumeToken();</span>
<span class="fc" id="L2290">            pn = arrowFunction(pn);</span>
        }
<span class="fc" id="L2292">        return pn;</span>
    }

    private AstNode condExpr()
        throws IOException
    {
<span class="fc" id="L2298">        AstNode pn = orExpr();</span>
<span class="fc bfc" id="L2299" title="All 2 branches covered.">        if (matchToken(Token.HOOK)) {</span>
<span class="fc" id="L2300">            int line = ts.lineno;</span>
<span class="fc" id="L2301">            int qmarkPos = ts.tokenBeg, colonPos = -1;</span>
            /*
             * Always accept the 'in' operator in the middle clause of a ternary,
             * where it's unambiguous, even if we might be parsing the init of a
             * for statement.
             */
<span class="fc" id="L2307">            boolean wasInForInit = inForInit;</span>
<span class="fc" id="L2308">            inForInit = false;</span>
            AstNode ifTrue;
            try {
<span class="fc" id="L2311">                ifTrue = assignExpr();</span>
            } finally {
<span class="pc" id="L2313">                inForInit = wasInForInit;</span>
<span class="pc" id="L2314">            }</span>
<span class="pc bpc" id="L2315" title="1 of 2 branches missed.">            if (mustMatchToken(Token.COLON, &quot;msg.no.colon.cond&quot;))</span>
<span class="fc" id="L2316">                colonPos = ts.tokenBeg;</span>
<span class="fc" id="L2317">            AstNode ifFalse = assignExpr();</span>
<span class="fc" id="L2318">            int beg = pn.getPosition(), len = getNodeEnd(ifFalse) - beg;</span>
<span class="fc" id="L2319">            ConditionalExpression ce = new ConditionalExpression(beg, len);</span>
<span class="fc" id="L2320">            ce.setLineno(line);</span>
<span class="fc" id="L2321">            ce.setTestExpression(pn);</span>
<span class="fc" id="L2322">            ce.setTrueExpression(ifTrue);</span>
<span class="fc" id="L2323">            ce.setFalseExpression(ifFalse);</span>
<span class="fc" id="L2324">            ce.setQuestionMarkPosition(qmarkPos - beg);</span>
<span class="fc" id="L2325">            ce.setColonPosition(colonPos - beg);</span>
<span class="fc" id="L2326">            pn = ce;</span>
        }
<span class="fc" id="L2328">        return pn;</span>
    }

    private AstNode orExpr()
        throws IOException
    {
<span class="fc" id="L2334">        AstNode pn = andExpr();</span>
<span class="fc bfc" id="L2335" title="All 2 branches covered.">        if (matchToken(Token.OR)) {</span>
<span class="fc" id="L2336">            int opPos = ts.tokenBeg;</span>
<span class="fc" id="L2337">            pn = new InfixExpression(Token.OR, pn, orExpr(), opPos);</span>
        }
<span class="fc" id="L2339">        return pn;</span>
    }

    private AstNode andExpr()
        throws IOException
    {
<span class="fc" id="L2345">        AstNode pn = bitOrExpr();</span>
<span class="fc bfc" id="L2346" title="All 2 branches covered.">        if (matchToken(Token.AND)) {</span>
<span class="fc" id="L2347">            int opPos = ts.tokenBeg;</span>
<span class="fc" id="L2348">            pn = new InfixExpression(Token.AND, pn, andExpr(), opPos);</span>
        }
<span class="fc" id="L2350">        return pn;</span>
    }

    private AstNode bitOrExpr()
        throws IOException
    {
<span class="fc" id="L2356">        AstNode pn = bitXorExpr();</span>
<span class="fc bfc" id="L2357" title="All 2 branches covered.">        while (matchToken(Token.BITOR)) {</span>
<span class="fc" id="L2358">            int opPos = ts.tokenBeg;</span>
<span class="fc" id="L2359">            pn = new InfixExpression(Token.BITOR, pn, bitXorExpr(), opPos);</span>
<span class="fc" id="L2360">        }</span>
<span class="fc" id="L2361">        return pn;</span>
    }

    private AstNode bitXorExpr()
        throws IOException
    {
<span class="fc" id="L2367">        AstNode pn = bitAndExpr();</span>
<span class="fc bfc" id="L2368" title="All 2 branches covered.">        while (matchToken(Token.BITXOR)) {</span>
<span class="fc" id="L2369">            int opPos = ts.tokenBeg;</span>
<span class="fc" id="L2370">            pn = new InfixExpression(Token.BITXOR, pn, bitAndExpr(), opPos);</span>
<span class="fc" id="L2371">        }</span>
<span class="fc" id="L2372">        return pn;</span>
    }

    private AstNode bitAndExpr()
        throws IOException
    {
<span class="fc" id="L2378">        AstNode pn = eqExpr();</span>
<span class="fc bfc" id="L2379" title="All 2 branches covered.">        while (matchToken(Token.BITAND)) {</span>
<span class="fc" id="L2380">            int opPos = ts.tokenBeg;</span>
<span class="fc" id="L2381">            pn = new InfixExpression(Token.BITAND, pn, eqExpr(), opPos);</span>
<span class="fc" id="L2382">        }</span>
<span class="fc" id="L2383">        return pn;</span>
    }

    private AstNode eqExpr()
        throws IOException
    {
<span class="fc" id="L2389">        AstNode pn = relExpr();</span>
        for (;;) {
<span class="fc" id="L2391">            int tt = peekToken(), opPos = ts.tokenBeg;</span>
<span class="fc bfc" id="L2392" title="All 2 branches covered.">            switch (tt) {</span>
              case Token.EQ:
              case Token.NE:
              case Token.SHEQ:
              case Token.SHNE:
<span class="fc" id="L2397">                consumeToken();</span>
<span class="fc" id="L2398">                int parseToken = tt;</span>
<span class="pc bpc" id="L2399" title="1 of 2 branches missed.">                if (compilerEnv.getLanguageVersion() == Context.VERSION_1_2) {</span>
                    // JavaScript 1.2 uses shallow equality for == and != .
<span class="nc bnc" id="L2401" title="All 2 branches missed.">                    if (tt == Token.EQ)</span>
<span class="nc" id="L2402">                        parseToken = Token.SHEQ;</span>
<span class="nc bnc" id="L2403" title="All 2 branches missed.">                    else if (tt == Token.NE)</span>
<span class="nc" id="L2404">                        parseToken = Token.SHNE;</span>
                }
<span class="fc" id="L2406">                pn = new InfixExpression(parseToken, pn, relExpr(), opPos);</span>
<span class="fc" id="L2407">                continue;</span>
            }
<span class="fc" id="L2409">            break;</span>
        }
<span class="fc" id="L2411">        return pn;</span>
    }

    private AstNode relExpr()
        throws IOException
    {
<span class="fc" id="L2417">        AstNode pn = shiftExpr();</span>
        for (;;) {
<span class="fc" id="L2419">            int tt = peekToken(), opPos = ts.tokenBeg;</span>
<span class="fc bfc" id="L2420" title="All 3 branches covered.">            switch (tt) {</span>
              case Token.IN:
<span class="fc bfc" id="L2422" title="All 2 branches covered.">                if (inForInit)</span>
<span class="fc" id="L2423">                    break;</span>
                // fall through
              case Token.INSTANCEOF:
              case Token.LE:
              case Token.LT:
              case Token.GE:
              case Token.GT:
<span class="fc" id="L2430">                consumeToken();</span>
<span class="fc" id="L2431">                pn = new InfixExpression(tt, pn, shiftExpr(), opPos);</span>
<span class="fc" id="L2432">                continue;</span>
            }
<span class="fc" id="L2434">            break;</span>
        }
<span class="fc" id="L2436">        return pn;</span>
    }

    private AstNode shiftExpr()
        throws IOException
    {
<span class="fc" id="L2442">        AstNode pn = addExpr();</span>
        for (;;) {
<span class="fc" id="L2444">            int tt = peekToken(), opPos = ts.tokenBeg;</span>
<span class="fc bfc" id="L2445" title="All 2 branches covered.">            switch (tt) {</span>
              case Token.LSH:
              case Token.URSH:
              case Token.RSH:
<span class="fc" id="L2449">                consumeToken();</span>
<span class="fc" id="L2450">                pn = new InfixExpression(tt, pn, addExpr(), opPos);</span>
<span class="fc" id="L2451">                continue;</span>
            }
<span class="fc" id="L2453">            break;</span>
        }
<span class="fc" id="L2455">        return pn;</span>
    }

    private AstNode addExpr()
        throws IOException
    {
<span class="fc" id="L2461">        AstNode pn = mulExpr();</span>
        for (;;) {
<span class="fc" id="L2463">            int tt = peekToken(), opPos = ts.tokenBeg;</span>
<span class="fc bfc" id="L2464" title="All 4 branches covered.">            if (tt == Token.ADD || tt == Token.SUB) {</span>
<span class="fc" id="L2465">                consumeToken();</span>
<span class="fc" id="L2466">                pn = new InfixExpression(tt, pn, mulExpr(), opPos);</span>
<span class="fc" id="L2467">                continue;</span>
            }
            break;
        }
<span class="fc" id="L2471">        return pn;</span>
    }

    private AstNode mulExpr()
        throws IOException
    {
<span class="fc" id="L2477">        AstNode pn = unaryExpr();</span>
        for (;;) {
<span class="fc" id="L2479">            int tt = peekToken(), opPos = ts.tokenBeg;</span>
<span class="fc bfc" id="L2480" title="All 2 branches covered.">            switch (tt) {</span>
              case Token.MUL:
              case Token.DIV:
              case Token.MOD:
<span class="fc" id="L2484">                consumeToken();</span>
<span class="fc" id="L2485">                pn = new InfixExpression(tt, pn, unaryExpr(), opPos);</span>
<span class="fc" id="L2486">                continue;</span>
            }
<span class="fc" id="L2488">            break;</span>
        }
<span class="fc" id="L2490">        return pn;</span>
    }

    private AstNode unaryExpr()
        throws IOException
    {
        AstNode node;
<span class="fc" id="L2497">        int tt = peekToken();</span>
<span class="fc" id="L2498">        int line = ts.lineno;</span>

<span class="pc bpc" id="L2500" title="1 of 8 branches missed.">        switch(tt) {</span>
          case Token.VOID:
          case Token.NOT:
          case Token.BITNOT:
          case Token.TYPEOF:
<span class="fc" id="L2505">              consumeToken();</span>
<span class="fc" id="L2506">              node = new UnaryExpression(tt, ts.tokenBeg, unaryExpr());</span>
<span class="fc" id="L2507">              node.setLineno(line);</span>
<span class="fc" id="L2508">              return node;</span>

          case Token.ADD:
<span class="fc" id="L2511">              consumeToken();</span>
              // Convert to special POS token in parse tree
<span class="fc" id="L2513">              node = new UnaryExpression(Token.POS, ts.tokenBeg, unaryExpr());</span>
<span class="fc" id="L2514">              node.setLineno(line);</span>
<span class="fc" id="L2515">              return node;</span>

          case Token.SUB:
<span class="fc" id="L2518">              consumeToken();</span>
              // Convert to special NEG token in parse tree
<span class="fc" id="L2520">              node = new UnaryExpression(Token.NEG, ts.tokenBeg, unaryExpr());</span>
<span class="fc" id="L2521">              node.setLineno(line);</span>
<span class="fc" id="L2522">              return node;</span>

          case Token.INC:
          case Token.DEC:
<span class="fc" id="L2526">              consumeToken();</span>
<span class="fc" id="L2527">              UnaryExpression expr = new UnaryExpression(tt, ts.tokenBeg,</span>
<span class="fc" id="L2528">                                                         memberExpr(true));</span>
<span class="fc" id="L2529">              expr.setLineno(line);</span>
<span class="fc" id="L2530">              checkBadIncDec(expr);</span>
<span class="fc" id="L2531">              return expr;</span>

          case Token.DELPROP:
<span class="fc" id="L2534">              consumeToken();</span>
<span class="fc" id="L2535">              node = new UnaryExpression(tt, ts.tokenBeg, unaryExpr());</span>
<span class="fc" id="L2536">              node.setLineno(line);</span>
<span class="fc" id="L2537">              return node;</span>

          case Token.ERROR:
<span class="nc" id="L2540">              consumeToken();</span>
<span class="nc" id="L2541">              return makeErrorNode();</span>

          case Token.LT:
              // XML stream encountered in expression.
<span class="pc bpc" id="L2545" title="1 of 2 branches missed.">              if (compilerEnv.isXmlAvailable()) {</span>
<span class="fc" id="L2546">                  consumeToken();</span>
<span class="fc" id="L2547">                  return memberExprTail(true, xmlInitializer());</span>
              }
              // Fall thru to the default handling of RELOP
              // fallthru

          default:
<span class="fc" id="L2553">              AstNode pn = memberExpr(true);</span>
              // Don't look across a newline boundary for a postfix incop.
<span class="fc" id="L2555">              tt = peekTokenOrEOL();</span>
<span class="fc bfc" id="L2556" title="All 4 branches covered.">              if (!(tt == Token.INC || tt == Token.DEC)) {</span>
<span class="fc" id="L2557">                  return pn;</span>
              }
<span class="fc" id="L2559">              consumeToken();</span>
<span class="fc" id="L2560">              UnaryExpression uexpr =</span>
                      new UnaryExpression(tt, ts.tokenBeg, pn, true);
<span class="fc" id="L2562">              uexpr.setLineno(line);</span>
<span class="fc" id="L2563">              checkBadIncDec(uexpr);</span>
<span class="fc" id="L2564">              return uexpr;</span>
        }
    }

    private AstNode xmlInitializer()
        throws IOException
    {
<span class="pc bpc" id="L2571" title="1 of 2 branches missed.">        if (currentToken != Token.LT) codeBug();</span>
<span class="fc" id="L2572">        int pos = ts.tokenBeg, tt = ts.getFirstXMLToken();</span>
<span class="pc bpc" id="L2573" title="1 of 4 branches missed.">        if (tt != Token.XML &amp;&amp; tt != Token.XMLEND) {</span>
<span class="nc" id="L2574">            reportError(&quot;msg.syntax&quot;);</span>
<span class="nc" id="L2575">            return makeErrorNode();</span>
        }

<span class="fc" id="L2578">        XmlLiteral pn = new XmlLiteral(pos);</span>
<span class="fc" id="L2579">        pn.setLineno(ts.lineno);</span>

<span class="fc" id="L2581">        for (;;tt = ts.getNextXMLToken()) {</span>
<span class="pc bpc" id="L2582" title="1 of 3 branches missed.">            switch (tt) {</span>
              case Token.XML:
<span class="fc" id="L2584">                  pn.addFragment(new XmlString(ts.tokenBeg, ts.getString()));</span>
<span class="fc" id="L2585">                  mustMatchToken(Token.LC, &quot;msg.syntax&quot;);</span>
<span class="fc" id="L2586">                  int beg = ts.tokenBeg;</span>
<span class="pc bpc" id="L2587" title="1 of 2 branches missed.">                  AstNode expr = (peekToken() == Token.RC)</span>
                                 ? new EmptyExpression(beg, ts.tokenEnd - beg)
<span class="fc" id="L2589">                                 : expr();</span>
<span class="fc" id="L2590">                  mustMatchToken(Token.RC, &quot;msg.syntax&quot;);</span>
<span class="fc" id="L2591">                  XmlExpression xexpr = new XmlExpression(beg, expr);</span>
<span class="fc" id="L2592">                  xexpr.setIsXmlAttribute(ts.isXMLAttribute());</span>
<span class="fc" id="L2593">                  xexpr.setLength(ts.tokenEnd - beg);</span>
<span class="fc" id="L2594">                  pn.addFragment(xexpr);</span>
<span class="fc" id="L2595">                  break;</span>

              case Token.XMLEND:
<span class="fc" id="L2598">                  pn.addFragment(new XmlString(ts.tokenBeg, ts.getString()));</span>
<span class="fc" id="L2599">                  return pn;</span>

              default:
<span class="nc" id="L2602">                  reportError(&quot;msg.syntax&quot;);</span>
<span class="nc" id="L2603">                  return makeErrorNode();</span>
            }
        }
    }

    private List&lt;AstNode&gt; argumentList()
        throws IOException
    {
<span class="fc bfc" id="L2611" title="All 2 branches covered.">        if (matchToken(Token.RP))</span>
<span class="fc" id="L2612">            return null;</span>

<span class="fc" id="L2614">        List&lt;AstNode&gt; result = new ArrayList&lt;AstNode&gt;();</span>
<span class="fc" id="L2615">        boolean wasInForInit = inForInit;</span>
<span class="fc" id="L2616">        inForInit = false;</span>
        try {
            do {
<span class="fc bfc" id="L2619" title="All 2 branches covered.">                if (peekToken() == Token.YIELD) {</span>
<span class="nc" id="L2620">                    reportError(&quot;msg.yield.parenthesized&quot;);</span>
                }
<span class="fc" id="L2622">                AstNode en = assignExpr();</span>
<span class="fc bfc" id="L2623" title="All 2 branches covered.">                if (peekToken() == Token.FOR) {</span>
                    try {
<span class="fc" id="L2625">                        result.add(generatorExpression(en, 0, true));</span>
                    }
<span class="nc" id="L2627">                    catch(IOException ex) {</span>
                        // #TODO
<span class="pc" id="L2629">                    }</span>
                }
                else {                           
<span class="fc" id="L2632">                    result.add(en);</span>
                }
<span class="fc bfc" id="L2634" title="All 2 branches covered.">            } while (matchToken(Token.COMMA));</span>
        } finally {
<span class="fc" id="L2636">            inForInit = wasInForInit;</span>
<span class="fc" id="L2637">        }</span>

<span class="fc" id="L2639">        mustMatchToken(Token.RP, &quot;msg.no.paren.arg&quot;);</span>
<span class="fc" id="L2640">        return result;</span>
    }

    /**
     * Parse a new-expression, or if next token isn't {@link Token#NEW},
     * a primary expression.
     * @param allowCallSyntax passed down to {@link #memberExprTail}
     */
    private AstNode memberExpr(boolean allowCallSyntax)
        throws IOException
    {
<span class="fc" id="L2651">        int tt = peekToken(), lineno = ts.lineno;</span>
        AstNode pn;

<span class="fc bfc" id="L2654" title="All 2 branches covered.">        if (tt != Token.NEW) {</span>
<span class="fc" id="L2655">            pn = primaryExpr();</span>
        } else {
<span class="fc" id="L2657">            consumeToken();</span>
<span class="fc" id="L2658">            int pos = ts.tokenBeg;</span>
<span class="fc" id="L2659">            NewExpression nx = new NewExpression(pos);</span>

<span class="fc" id="L2661">            AstNode target = memberExpr(false);</span>
<span class="fc" id="L2662">            int end = getNodeEnd(target);</span>
<span class="fc" id="L2663">            nx.setTarget(target);</span>

<span class="fc" id="L2665">            int lp = -1;</span>
<span class="fc bfc" id="L2666" title="All 2 branches covered.">            if (matchToken(Token.LP)) {</span>
<span class="fc" id="L2667">                lp = ts.tokenBeg;</span>
<span class="fc" id="L2668">                List&lt;AstNode&gt; args = argumentList();</span>
<span class="pc bpc" id="L2669" title="1 of 4 branches missed.">                if (args != null &amp;&amp; args.size() &gt; ARGC_LIMIT)</span>
<span class="nc" id="L2670">                    reportError(&quot;msg.too.many.constructor.args&quot;);</span>
<span class="fc" id="L2671">                int rp = ts.tokenBeg;</span>
<span class="fc" id="L2672">                end = ts.tokenEnd;</span>
<span class="fc bfc" id="L2673" title="All 2 branches covered.">                if (args != null)</span>
<span class="fc" id="L2674">                    nx.setArguments(args);</span>
<span class="fc" id="L2675">                nx.setParens(lp - pos, rp - pos);</span>
            }

            // Experimental syntax: allow an object literal to follow a new
            // expression, which will mean a kind of anonymous class built with
            // the JavaAdapter.  the object literal will be passed as an
            // additional argument to the constructor.
<span class="fc bfc" id="L2682" title="All 2 branches covered.">            if (matchToken(Token.LC)) {</span>
<span class="fc" id="L2683">                ObjectLiteral initializer = objectLiteral();</span>
<span class="fc" id="L2684">                end = getNodeEnd(initializer);</span>
<span class="fc" id="L2685">                nx.setInitializer(initializer);</span>
            }
<span class="fc" id="L2687">            nx.setLength(end - pos);</span>
<span class="fc" id="L2688">            pn = nx;</span>
        }
<span class="fc" id="L2690">        pn.setLineno(lineno);</span>
<span class="fc" id="L2691">        AstNode tail = memberExprTail(allowCallSyntax, pn);</span>
<span class="fc" id="L2692">        return tail;</span>
    }

    /**
     * Parse any number of &quot;(expr)&quot;, &quot;[expr]&quot; &quot;.expr&quot;, &quot;..expr&quot;,
     * or &quot;.(expr)&quot; constructs trailing the passed expression.
     * @param pn the non-null parent node
     * @return the outermost (lexically last occurring) expression,
     * which will have the passed parent node as a descendant
     */
    private AstNode memberExprTail(boolean allowCallSyntax, AstNode pn)
        throws IOException
    {
        // we no longer return null for errors, so this won't be null
<span class="pc bpc" id="L2706" title="1 of 2 branches missed.">        if (pn == null) codeBug();</span>
<span class="fc" id="L2707">        int pos = pn.getPosition();</span>
        int lineno;
      tailLoop:
        for (;;) {
<span class="fc" id="L2711">            int tt = peekToken();</span>
<span class="fc bfc" id="L2712" title="All 5 branches covered.">            switch (tt) {</span>
              case Token.DOT:
              case Token.DOTDOT:
<span class="fc" id="L2715">                  lineno = ts.lineno;</span>
<span class="fc" id="L2716">                  pn = propertyAccess(tt, pn);</span>
<span class="fc" id="L2717">                  pn.setLineno(lineno);</span>
<span class="fc" id="L2718">                  break;</span>

              case Token.DOTQUERY:
<span class="fc" id="L2721">                  consumeToken();</span>
<span class="fc" id="L2722">                  int opPos = ts.tokenBeg, rp = -1;</span>
<span class="fc" id="L2723">                  lineno = ts.lineno;</span>
<span class="fc" id="L2724">                  mustHaveXML();</span>
<span class="fc" id="L2725">                  setRequiresActivation();</span>
<span class="fc" id="L2726">                  AstNode filter = expr();</span>
<span class="fc" id="L2727">                  int end = getNodeEnd(filter);</span>
<span class="pc bpc" id="L2728" title="1 of 2 branches missed.">                  if (mustMatchToken(Token.RP, &quot;msg.no.paren&quot;)) {</span>
<span class="fc" id="L2729">                      rp = ts.tokenBeg;</span>
<span class="fc" id="L2730">                      end = ts.tokenEnd;</span>
                  }
<span class="fc" id="L2732">                  XmlDotQuery q = new XmlDotQuery(pos, end - pos);</span>
<span class="fc" id="L2733">                  q.setLeft(pn);</span>
<span class="fc" id="L2734">                  q.setRight(filter);</span>
<span class="fc" id="L2735">                  q.setOperatorPosition(opPos);</span>
<span class="fc" id="L2736">                  q.setRp(rp - pos);</span>
<span class="fc" id="L2737">                  q.setLineno(lineno);</span>
<span class="fc" id="L2738">                  pn = q;</span>
<span class="fc" id="L2739">                  break;</span>

              case Token.LB:
<span class="fc" id="L2742">                  consumeToken();</span>
<span class="fc" id="L2743">                  int lb = ts.tokenBeg, rb = -1;</span>
<span class="fc" id="L2744">                  lineno = ts.lineno;</span>
<span class="fc" id="L2745">                  AstNode expr = expr();</span>
<span class="fc" id="L2746">                  end = getNodeEnd(expr);</span>
<span class="pc bpc" id="L2747" title="1 of 2 branches missed.">                  if (mustMatchToken(Token.RB, &quot;msg.no.bracket.index&quot;)) {</span>
<span class="fc" id="L2748">                      rb = ts.tokenBeg;</span>
<span class="fc" id="L2749">                      end = ts.tokenEnd;</span>
                  }
<span class="fc" id="L2751">                  ElementGet g = new ElementGet(pos, end - pos);</span>
<span class="fc" id="L2752">                  g.setTarget(pn);</span>
<span class="fc" id="L2753">                  g.setElement(expr);</span>
<span class="fc" id="L2754">                  g.setParens(lb, rb);</span>
<span class="fc" id="L2755">                  g.setLineno(lineno);</span>
<span class="fc" id="L2756">                  pn = g;</span>
<span class="fc" id="L2757">                  break;</span>

              case Token.LP:
<span class="fc bfc" id="L2760" title="All 2 branches covered.">                  if (!allowCallSyntax) {</span>
<span class="fc" id="L2761">                      break tailLoop;</span>
                  }
<span class="fc" id="L2763">                  lineno = ts.lineno;</span>
<span class="fc" id="L2764">                  consumeToken();</span>
<span class="fc" id="L2765">                  checkCallRequiresActivation(pn);</span>
<span class="fc" id="L2766">                  FunctionCall f = new FunctionCall(pos);</span>
<span class="fc" id="L2767">                  f.setTarget(pn);</span>
                  // Assign the line number for the function call to where
                  // the paren appeared, not where the name expression started.
<span class="fc" id="L2770">                  f.setLineno(lineno);</span>
<span class="fc" id="L2771">                  f.setLp(ts.tokenBeg - pos);</span>
<span class="fc" id="L2772">                  List&lt;AstNode&gt; args = argumentList();</span>
<span class="pc bpc" id="L2773" title="1 of 4 branches missed.">                  if (args != null &amp;&amp; args.size() &gt; ARGC_LIMIT)</span>
<span class="nc" id="L2774">                      reportError(&quot;msg.too.many.function.args&quot;);</span>
<span class="fc" id="L2775">                  f.setArguments(args);</span>
<span class="fc" id="L2776">                  f.setRp(ts.tokenBeg - pos);</span>
<span class="fc" id="L2777">                  f.setLength(ts.tokenEnd - pos);</span>
<span class="fc" id="L2778">                  pn = f;</span>
<span class="fc" id="L2779">                  break;</span>

              default:
<span class="fc" id="L2782">                  break tailLoop;</span>
            }
<span class="fc" id="L2784">        }</span>
<span class="fc" id="L2785">        return pn;</span>
    }

    /**
     * Handles any construct following a &quot;.&quot; or &quot;..&quot; operator.
     * @param pn the left-hand side (target) of the operator.  Never null.
     * @return a PropertyGet, XmlMemberGet, or ErrorNode
     */
    private AstNode propertyAccess(int tt, AstNode pn)
            throws IOException
    {
<span class="pc bpc" id="L2796" title="1 of 2 branches missed.">        if (pn == null) codeBug();</span>
<span class="fc" id="L2797">        int memberTypeFlags = 0, lineno = ts.lineno, dotPos = ts.tokenBeg;</span>
<span class="fc" id="L2798">        consumeToken();</span>

<span class="fc bfc" id="L2800" title="All 2 branches covered.">        if (tt == Token.DOTDOT) {</span>
<span class="fc" id="L2801">            mustHaveXML();</span>
<span class="fc" id="L2802">            memberTypeFlags = Node.DESCENDANTS_FLAG;</span>
        }

<span class="fc bfc" id="L2805" title="All 2 branches covered.">        if (!compilerEnv.isXmlAvailable()) {</span>
<span class="fc" id="L2806">            int maybeName = nextToken();</span>
<span class="fc bfc" id="L2807" title="All 2 branches covered.">            if (maybeName != Token.NAME</span>
<span class="pc bpc" id="L2808" title="1 of 2 branches missed.">                    &amp;&amp; !(compilerEnv.isReservedKeywordAsIdentifier()</span>
<span class="nc bnc" id="L2809" title="All 2 branches missed.">                    &amp;&amp; TokenStream.isKeyword(ts.getString(), compilerEnv.getLanguageVersion(), inUseStrictDirective))) {</span>
<span class="nc" id="L2810">              reportError(&quot;msg.no.name.after.dot&quot;);</span>
            }

<span class="fc" id="L2813">            Name name = createNameNode(true, Token.GETPROP);</span>
<span class="fc" id="L2814">            PropertyGet pg = new PropertyGet(pn, name, dotPos);</span>
<span class="fc" id="L2815">            pg.setLineno(lineno);</span>
<span class="fc" id="L2816">            return pg;</span>
        }

<span class="fc" id="L2819">        AstNode ref = null;  // right side of . or .. operator</span>

<span class="fc" id="L2821">        int token = nextToken();</span>
<span class="pc bpc" id="L2822" title="1 of 6 branches missed.">        switch (token) {</span>
          case Token.THROW:
              // needed for generator.throw();
<span class="fc" id="L2825">              saveNameTokenData(ts.tokenBeg, &quot;throw&quot;, ts.lineno);</span>
<span class="fc" id="L2826">              ref = propertyName(-1, &quot;throw&quot;, memberTypeFlags);</span>
<span class="fc" id="L2827">              break;</span>

          case Token.NAME:
              // handles: name, ns::name, ns::*, ns::[expr]
<span class="fc" id="L2831">              ref = propertyName(-1, ts.getString(), memberTypeFlags);</span>
<span class="fc" id="L2832">              break;</span>

          case Token.MUL:
              // handles: *, *::name, *::*, *::[expr]
<span class="fc" id="L2836">              saveNameTokenData(ts.tokenBeg, &quot;*&quot;, ts.lineno);</span>
<span class="fc" id="L2837">              ref = propertyName(-1, &quot;*&quot;, memberTypeFlags);</span>
<span class="fc" id="L2838">              break;</span>

          case Token.XMLATTR:
              // handles: '@attr', '@ns::attr', '@ns::*', '@ns::*',
              //          '@::attr', '@::*', '@*', '@*::attr', '@*::*'
<span class="fc" id="L2843">              ref = attributeAccess();</span>
<span class="fc" id="L2844">              break;</span>

          case Token.RESERVED: {
<span class="nc" id="L2847">              String name = ts.getString();</span>
<span class="nc" id="L2848">              saveNameTokenData(ts.tokenBeg, name, ts.lineno);</span>
<span class="nc" id="L2849">              ref = propertyName(-1, name, memberTypeFlags);</span>
<span class="nc" id="L2850">              break;</span>
          }

          default:
<span class="pc bpc" id="L2854" title="1 of 2 branches missed.">              if (compilerEnv.isReservedKeywordAsIdentifier()) {</span>
                  // allow keywords as property names, e.g. ({if: 1})
<span class="fc" id="L2856">                  String name = Token.keywordToName(token);</span>
<span class="pc bpc" id="L2857" title="1 of 2 branches missed.">                  if (name != null) {</span>
<span class="fc" id="L2858">                      saveNameTokenData(ts.tokenBeg, name, ts.lineno);</span>
<span class="fc" id="L2859">                      ref = propertyName(-1, name, memberTypeFlags);</span>
<span class="fc" id="L2860">                      break;</span>
                  }
              }
<span class="nc" id="L2863">              reportError(&quot;msg.no.name.after.dot&quot;);</span>
<span class="nc" id="L2864">              return makeErrorNode();</span>
        }

<span class="fc" id="L2867">        boolean xml = ref instanceof XmlRef;</span>
<span class="fc bfc" id="L2868" title="All 2 branches covered.">        InfixExpression result = xml ? new XmlMemberGet() : new PropertyGet();</span>
<span class="fc bfc" id="L2869" title="All 4 branches covered.">        if (xml &amp;&amp; tt == Token.DOT)</span>
<span class="fc" id="L2870">            result.setType(Token.DOT);</span>
<span class="fc" id="L2871">        int pos = pn.getPosition();</span>
<span class="fc" id="L2872">        result.setPosition(pos);</span>
<span class="fc" id="L2873">        result.setLength(getNodeEnd(ref) - pos);</span>
<span class="fc" id="L2874">        result.setOperatorPosition(dotPos - pos);</span>
<span class="fc" id="L2875">        result.setLineno(pn.getLineno());</span>
<span class="fc" id="L2876">        result.setLeft(pn);  // do this after setting position</span>
<span class="fc" id="L2877">        result.setRight(ref);</span>
<span class="fc" id="L2878">        return result;</span>
    }

    /**
     * Xml attribute expression:&lt;p&gt;
     *   {@code @attr}, {@code @ns::attr}, {@code @ns::*}, {@code @ns::*},
     *   {@code @*}, {@code @*::attr}, {@code @*::*}, {@code @ns::[expr]},
     *   {@code @*::[expr]}, {@code @[expr]} &lt;p&gt;
     * Called if we peeked an '@' token.
     */
    private AstNode attributeAccess()
        throws IOException
    {
<span class="fc" id="L2891">        int tt = nextToken(), atPos = ts.tokenBeg;</span>

<span class="pc bpc" id="L2893" title="1 of 4 branches missed.">        switch (tt) {</span>
          // handles: @name, @ns::name, @ns::*, @ns::[expr]
          case Token.NAME:
<span class="fc" id="L2896">              return propertyName(atPos, ts.getString(), 0);</span>

          // handles: @*, @*::name, @*::*, @*::[expr]
          case Token.MUL:
<span class="fc" id="L2900">              saveNameTokenData(ts.tokenBeg, &quot;*&quot;, ts.lineno);</span>
<span class="fc" id="L2901">              return propertyName(atPos, &quot;*&quot;, 0);</span>

          // handles @[expr]
          case Token.LB:
<span class="fc" id="L2905">              return xmlElemRef(atPos, null, -1);</span>

          default:
<span class="nc" id="L2908">              reportError(&quot;msg.no.name.after.xmlAttr&quot;);</span>
<span class="nc" id="L2909">              return makeErrorNode();</span>
        }
    }

    /**
     * Check if :: follows name in which case it becomes a qualified name.
     *
     * @param atPos a natural number if we just read an '@' token, else -1
     *
     * @param s the name or string that was matched (an identifier, &quot;throw&quot; or
     * &quot;*&quot;).
     *
     * @param memberTypeFlags flags tracking whether we're a '.' or '..' child
     *
     * @return an XmlRef node if it's an attribute access, a child of a
     * '..' operator, or the name is followed by ::.  For a plain name,
     * returns a Name node.  Returns an ErrorNode for malformed XML
     * expressions.  (For now - might change to return a partial XmlRef.)
     */
    private AstNode propertyName(int atPos, String s, int memberTypeFlags)
        throws IOException
    {
<span class="fc bfc" id="L2931" title="All 2 branches covered.">        int pos = atPos != -1 ? atPos : ts.tokenBeg, lineno = ts.lineno;</span>
<span class="fc" id="L2932">        int colonPos = -1;</span>
<span class="fc" id="L2933">        Name name = createNameNode(true, currentToken);</span>
<span class="fc" id="L2934">        Name ns = null;</span>

<span class="fc bfc" id="L2936" title="All 2 branches covered.">        if (matchToken(Token.COLONCOLON)) {</span>
<span class="fc" id="L2937">            ns = name;</span>
<span class="fc" id="L2938">            colonPos = ts.tokenBeg;</span>

<span class="pc bpc" id="L2940" title="1 of 4 branches missed.">            switch (nextToken()) {</span>
              // handles name::name
              case Token.NAME:
<span class="fc" id="L2943">                  name = createNameNode();</span>
<span class="fc" id="L2944">                  break;</span>

              // handles name::*
              case Token.MUL:
<span class="fc" id="L2948">                  saveNameTokenData(ts.tokenBeg, &quot;*&quot;, ts.lineno);</span>
<span class="fc" id="L2949">                  name = createNameNode(false, -1);</span>
<span class="fc" id="L2950">                  break;</span>

              // handles name::[expr] or *::[expr]
              case Token.LB:
<span class="fc" id="L2954">                  return xmlElemRef(atPos, ns, colonPos);</span>

              default:
<span class="nc" id="L2957">                  reportError(&quot;msg.no.name.after.coloncolon&quot;);</span>
<span class="nc" id="L2958">                  return makeErrorNode();</span>
            }
        }

<span class="fc bfc" id="L2962" title="All 6 branches covered.">        if (ns == null &amp;&amp; memberTypeFlags == 0 &amp;&amp; atPos == -1) {</span>
<span class="fc" id="L2963">            return name;</span>
        }

<span class="fc" id="L2966">        XmlPropRef ref = new XmlPropRef(pos, getNodeEnd(name) - pos);</span>
<span class="fc" id="L2967">        ref.setAtPos(atPos);</span>
<span class="fc" id="L2968">        ref.setNamespace(ns);</span>
<span class="fc" id="L2969">        ref.setColonPos(colonPos);</span>
<span class="fc" id="L2970">        ref.setPropName(name);</span>
<span class="fc" id="L2971">        ref.setLineno(lineno);</span>
<span class="fc" id="L2972">        return ref;</span>
    }

    /**
     * Parse the [expr] portion of an xml element reference, e.g.
     * @[expr], @*::[expr], or ns::[expr].
     */
    private XmlElemRef xmlElemRef(int atPos, Name namespace, int colonPos)
        throws IOException
    {
<span class="fc bfc" id="L2982" title="All 2 branches covered.">        int lb = ts.tokenBeg, rb = -1, pos = atPos != -1 ? atPos : lb;</span>
<span class="fc" id="L2983">        AstNode expr = expr();</span>
<span class="fc" id="L2984">        int end = getNodeEnd(expr);</span>
<span class="pc bpc" id="L2985" title="1 of 2 branches missed.">        if (mustMatchToken(Token.RB, &quot;msg.no.bracket.index&quot;)) {</span>
<span class="fc" id="L2986">            rb = ts.tokenBeg;</span>
<span class="fc" id="L2987">            end = ts.tokenEnd;</span>
        }
<span class="fc" id="L2989">        XmlElemRef ref = new XmlElemRef(pos, end - pos);</span>
<span class="fc" id="L2990">        ref.setNamespace(namespace);</span>
<span class="fc" id="L2991">        ref.setColonPos(colonPos);</span>
<span class="fc" id="L2992">        ref.setAtPos(atPos);</span>
<span class="fc" id="L2993">        ref.setExpression(expr);</span>
<span class="fc" id="L2994">        ref.setBrackets(lb, rb);</span>
<span class="fc" id="L2995">        return ref;</span>
    }

    private AstNode destructuringPrimaryExpr()
        throws IOException, ParserException
    {
        try {
<span class="fc" id="L3002">            inDestructuringAssignment = true;</span>
<span class="fc" id="L3003">            return primaryExpr();</span>
        } finally {
<span class="fc" id="L3005">            inDestructuringAssignment = false;</span>
<span class="fc" id="L3006">        }</span>
    }

    private AstNode primaryExpr()
        throws IOException
    {
<span class="fc" id="L3012">        int ttFlagged = peekFlaggedToken();</span>
<span class="fc" id="L3013">        int tt = ttFlagged &amp; CLEAR_TI_MASK;</span>

<span class="pc bpc" id="L3015" title="2 of 15 branches missed.">        switch(tt) {</span>
          case Token.FUNCTION:
<span class="fc" id="L3017">              consumeToken();</span>
<span class="fc" id="L3018">              return function(FunctionNode.FUNCTION_EXPRESSION);</span>

          case Token.LB:
<span class="fc" id="L3021">              consumeToken();</span>
<span class="fc" id="L3022">              return arrayLiteral();</span>

          case Token.LC:
<span class="fc" id="L3025">              consumeToken();</span>
<span class="fc" id="L3026">              return objectLiteral();</span>

          case Token.LET:
<span class="fc" id="L3029">              consumeToken();</span>
<span class="fc" id="L3030">              return let(false, ts.tokenBeg);</span>

          case Token.LP:
<span class="fc" id="L3033">              consumeToken();</span>
<span class="fc" id="L3034">              return parenExpr();</span>

          case Token.XMLATTR:
<span class="fc" id="L3037">              consumeToken();</span>
<span class="fc" id="L3038">              mustHaveXML();</span>
<span class="fc" id="L3039">              return attributeAccess();</span>

          case Token.NAME:
<span class="fc" id="L3042">              consumeToken();</span>
<span class="fc" id="L3043">              return name(ttFlagged, tt);</span>

          case Token.NUMBER: {
<span class="fc" id="L3046">              consumeToken();</span>
<span class="fc" id="L3047">              String s = ts.getString();</span>
<span class="pc bpc" id="L3048" title="1 of 4 branches missed.">              if (this.inUseStrictDirective &amp;&amp; ts.isNumberOldOctal()) {</span>
<span class="nc" id="L3049">                  reportError(&quot;msg.no.old.octal.strict&quot;);</span>
              }
<span class="pc bpc" id="L3051" title="1 of 2 branches missed.">              if (ts.isNumberBinary()) {</span>
<span class="nc" id="L3052">                  s = &quot;0b&quot;+s;</span>
              }
<span class="fc bfc" id="L3054" title="All 2 branches covered.">              if (ts.isNumberOldOctal()) {</span>
<span class="fc" id="L3055">                  s = &quot;0&quot;+s;</span>
              }
<span class="pc bpc" id="L3057" title="1 of 2 branches missed.">              if (ts.isNumberOctal()) {</span>
<span class="nc" id="L3058">                  s = &quot;0o&quot;+s;</span>
              }
<span class="fc bfc" id="L3060" title="All 2 branches covered.">              if (ts.isNumberHex()) {</span>
<span class="fc" id="L3061">                  s = &quot;0x&quot;+s;</span>
              }
<span class="fc" id="L3063">              return new NumberLiteral(ts.tokenBeg,</span>
                                       s,
<span class="fc" id="L3065">                                       ts.getNumber());</span>
          }

          case Token.STRING:
<span class="fc" id="L3069">              consumeToken();</span>
<span class="fc" id="L3070">              return createStringLiteral();</span>

          case Token.DIV:
          case Token.ASSIGN_DIV:
<span class="fc" id="L3074">              consumeToken();</span>
              // Got / or /= which in this context means a regexp
<span class="fc" id="L3076">              ts.readRegExp(tt);</span>
<span class="fc" id="L3077">              int pos = ts.tokenBeg, end = ts.tokenEnd;</span>
<span class="fc" id="L3078">              RegExpLiteral re = new RegExpLiteral(pos, end - pos);</span>
<span class="fc" id="L3079">              re.setValue(ts.getString());</span>
<span class="fc" id="L3080">              re.setFlags(ts.readAndClearRegExpFlags());</span>
<span class="fc" id="L3081">              return re;</span>

          case Token.NULL:
          case Token.THIS:
          case Token.FALSE:
          case Token.TRUE:
<span class="fc" id="L3087">              consumeToken();</span>
<span class="fc" id="L3088">              pos = ts.tokenBeg; end = ts.tokenEnd;</span>
<span class="fc" id="L3089">              return new KeywordLiteral(pos, end - pos, tt);</span>

          case Token.RESERVED:
<span class="fc" id="L3092">              consumeToken();</span>
<span class="nc" id="L3093">              reportError(&quot;msg.reserved.id&quot;, ts.getString());</span>
<span class="nc" id="L3094">              break;</span>

          case Token.ERROR:
<span class="nc" id="L3097">              consumeToken();</span>
              // the scanner or one of its subroutines reported the error.
<span class="nc" id="L3099">              break;</span>

          case Token.EOF:
<span class="nc" id="L3102">              consumeToken();</span>
<span class="nc" id="L3103">              reportError(&quot;msg.unexpected.eof&quot;);</span>
<span class="nc" id="L3104">              break;</span>

          default:
<span class="fc" id="L3107">              consumeToken();</span>
<span class="fc" id="L3108">              reportError(&quot;msg.syntax&quot;);</span>
              break;
        }
        // should only be reachable in IDE/error-recovery mode
<span class="fc" id="L3112">        consumeToken();</span>
<span class="fc" id="L3113">        return makeErrorNode();</span>
    }

    private AstNode parenExpr() throws IOException {
<span class="fc" id="L3117">        boolean wasInForInit = inForInit;</span>
<span class="fc" id="L3118">        inForInit = false;</span>
        try {
<span class="fc" id="L3120">            Comment jsdocNode = getAndResetJsDoc();</span>
<span class="fc" id="L3121">            int lineno = ts.lineno;</span>
<span class="fc" id="L3122">            int begin = ts.tokenBeg;</span>
<span class="fc bfc" id="L3123" title="All 2 branches covered.">            AstNode e = (peekToken() == Token.RP ? new EmptyExpression(begin) : expr());</span>
<span class="fc bfc" id="L3124" title="All 2 branches covered.">            if (peekToken() == Token.FOR) {</span>
<span class="fc" id="L3125">                return generatorExpression(e, begin);</span>
            }
<span class="fc" id="L3127">            ParenthesizedExpression pn = new ParenthesizedExpression(e);</span>
<span class="fc bfc" id="L3128" title="All 2 branches covered.">            if (jsdocNode == null) {</span>
<span class="fc" id="L3129">                jsdocNode = getAndResetJsDoc();</span>
            }
<span class="fc bfc" id="L3131" title="All 2 branches covered.">            if (jsdocNode != null) {</span>
<span class="fc" id="L3132">                pn.setJsDocNode(jsdocNode);</span>
            }
<span class="fc" id="L3134">            mustMatchToken(Token.RP, &quot;msg.no.paren&quot;);</span>
<span class="fc bfc" id="L3135" title="All 4 branches covered.">            if (e.getType() == Token.EMPTY &amp;&amp; peekToken() != Token.ARROW) {</span>
<span class="nc" id="L3136">              reportError(&quot;msg.syntax&quot;);</span>
<span class="nc" id="L3137">              return makeErrorNode();</span>
            }
<span class="fc" id="L3139">            pn.setLength(ts.tokenEnd - pn.getPosition());</span>
<span class="fc" id="L3140">            pn.setLineno(lineno);</span>
<span class="fc" id="L3141">            return pn;</span>
        } finally {
<span class="pc" id="L3143">            inForInit = wasInForInit;</span>
<span class="fc" id="L3144">        }</span>
    }

    private AstNode name(int ttFlagged, int tt) throws IOException {
<span class="fc" id="L3148">        String nameString = ts.getString();</span>
<span class="fc" id="L3149">        int namePos = ts.tokenBeg, nameLineno = ts.lineno;</span>
<span class="fc bfc" id="L3150" title="All 4 branches covered.">        if (0 != (ttFlagged &amp; TI_CHECK_LABEL) &amp;&amp; peekToken() == Token.COLON) {</span>
            // Do not consume colon.  It is used as an unwind indicator
            // to return to statementHelper.
<span class="fc" id="L3153">            Label label = new Label(namePos, ts.tokenEnd - namePos);</span>
<span class="fc" id="L3154">            label.setName(nameString);</span>
<span class="fc" id="L3155">            label.setLineno(ts.lineno);</span>
<span class="fc" id="L3156">            return label;</span>
        }
        // Not a label.  Unfortunately peeking the next token to check for
        // a colon has biffed ts.tokenBeg, ts.tokenEnd.  We store the name's
        // bounds in instance vars and createNameNode uses them.
<span class="fc" id="L3161">        saveNameTokenData(namePos, nameString, nameLineno);</span>

<span class="fc bfc" id="L3163" title="All 2 branches covered.">        if (compilerEnv.isXmlAvailable()) {</span>
<span class="fc" id="L3164">            return propertyName(-1, nameString, 0);</span>
        } else {
<span class="fc" id="L3166">            return createNameNode(true, Token.NAME);</span>
        }
    }

    /**
     * May return an {@link ArrayLiteral} or {@link ArrayComprehension}.
     */
    private AstNode arrayLiteral()
        throws IOException
    {
<span class="pc bpc" id="L3176" title="1 of 2 branches missed.">        if (currentToken != Token.LB) codeBug();</span>
<span class="fc" id="L3177">        int pos = ts.tokenBeg, end = ts.tokenEnd;</span>
<span class="fc" id="L3178">        List&lt;AstNode&gt; elements = new ArrayList&lt;AstNode&gt;();</span>
<span class="fc" id="L3179">        ArrayLiteral pn = new ArrayLiteral(pos);</span>
<span class="fc" id="L3180">        boolean after_lb_or_comma = true;</span>
<span class="fc" id="L3181">        int afterComma = -1;</span>
<span class="fc" id="L3182">        int skipCount = 0;</span>
        for (;;) {
<span class="fc" id="L3184">            int tt = peekToken();</span>
<span class="fc bfc" id="L3185" title="All 2 branches covered.">            if (tt == Token.COMMA) {</span>
<span class="fc" id="L3186">                consumeToken();</span>
<span class="fc" id="L3187">                afterComma = ts.tokenEnd;</span>
<span class="fc bfc" id="L3188" title="All 2 branches covered.">                if (!after_lb_or_comma) {</span>
<span class="fc" id="L3189">                    after_lb_or_comma = true;</span>
                } else {
<span class="fc" id="L3191">                    elements.add(new EmptyExpression(ts.tokenBeg, 1));</span>
<span class="fc" id="L3192">                    skipCount++;</span>
                }
<span class="fc bfc" id="L3194" title="All 2 branches covered.">            } else if (tt == Token.RB) {</span>
<span class="fc" id="L3195">                consumeToken();</span>
                // for ([a,] in obj) is legal, but for ([a] in obj) is
                // not since we have both key and value supplied. The
                // trick is that [a,] and [a] are equivalent in other
                // array literal contexts. So we calculate a special
                // length value just for destructuring assignment.
<span class="fc" id="L3201">                end = ts.tokenEnd;</span>
<span class="fc bfc" id="L3202" title="All 2 branches covered.">                pn.setDestructuringLength(elements.size() +</span>
                                          (after_lb_or_comma ? 1 : 0));
<span class="fc" id="L3204">                pn.setSkipCount(skipCount);</span>
<span class="fc bfc" id="L3205" title="All 2 branches covered.">                if (afterComma != -1)</span>
<span class="fc" id="L3206">                    warnTrailingComma(pos, elements, afterComma);</span>
                break;
<span class="pc bpc" id="L3208" title="1 of 4 branches missed.">            } else if (tt == Token.FOR &amp;&amp; !after_lb_or_comma</span>
<span class="pc bpc" id="L3209" title="1 of 2 branches missed.">                       &amp;&amp; elements.size() == 1) {</span>
<span class="fc" id="L3210">                return arrayComprehension(elements.get(0), pos);</span>
<span class="pc bpc" id="L3211" title="1 of 2 branches missed.">            } else if (tt == Token.EOF) {</span>
<span class="nc" id="L3212">                reportError(&quot;msg.no.bracket.arg&quot;);</span>
<span class="nc" id="L3213">                break;</span>
            } else {
<span class="fc bfc" id="L3215" title="All 2 branches covered.">                if (!after_lb_or_comma) {</span>
<span class="nc" id="L3216">                    reportError(&quot;msg.no.bracket.arg&quot;);</span>
                }
<span class="fc" id="L3218">                elements.add(assignExpr());</span>
<span class="fc" id="L3219">                after_lb_or_comma = false;</span>
<span class="fc" id="L3220">                afterComma = -1;</span>
            }
<span class="fc" id="L3222">        }</span>
<span class="fc bfc" id="L3223" title="All 2 branches covered.">        for (AstNode e : elements) {</span>
<span class="fc" id="L3224">            pn.addElement(e);</span>
<span class="fc" id="L3225">        }</span>
<span class="fc" id="L3226">        pn.setLength(end - pos);</span>
<span class="fc" id="L3227">        return pn;</span>
    }

    /**
     * Parse a JavaScript 1.7 Array comprehension.
     * @param result the first expression after the opening left-bracket
     * @param pos start of LB token that begins the array comprehension
     * @return the array comprehension or an error node
     */
    private AstNode arrayComprehension(AstNode result, int pos)
        throws IOException
    {
<span class="fc" id="L3239">        List&lt;ArrayComprehensionLoop&gt; loops =</span>
                new ArrayList&lt;ArrayComprehensionLoop&gt;();
<span class="fc bfc" id="L3241" title="All 2 branches covered.">        while (peekToken() == Token.FOR) {</span>
<span class="fc" id="L3242">            loops.add(arrayComprehensionLoop());</span>
        }
<span class="fc" id="L3244">        int ifPos = -1;</span>
<span class="fc" id="L3245">        ConditionData data = null;</span>
<span class="fc bfc" id="L3246" title="All 2 branches covered.">        if (peekToken() == Token.IF) {</span>
<span class="fc" id="L3247">            consumeToken();</span>
<span class="fc" id="L3248">            ifPos = ts.tokenBeg - pos;</span>
<span class="fc" id="L3249">            data = condition();</span>
        }
<span class="fc" id="L3251">        mustMatchToken(Token.RB, &quot;msg.no.bracket.arg&quot;);</span>
<span class="fc" id="L3252">        ArrayComprehension pn = new ArrayComprehension(pos, ts.tokenEnd - pos);</span>
<span class="fc" id="L3253">        pn.setResult(result);</span>
<span class="fc" id="L3254">        pn.setLoops(loops);</span>
<span class="fc bfc" id="L3255" title="All 2 branches covered.">        if (data != null) {</span>
<span class="fc" id="L3256">            pn.setIfPosition(ifPos);</span>
<span class="fc" id="L3257">            pn.setFilter(data.condition);</span>
<span class="fc" id="L3258">            pn.setFilterLp(data.lp - pos);</span>
<span class="fc" id="L3259">            pn.setFilterRp(data.rp - pos);</span>
        }
<span class="fc" id="L3261">        return pn;</span>
    }

    private ArrayComprehensionLoop arrayComprehensionLoop()
        throws IOException
    {
<span class="pc bpc" id="L3267" title="1 of 2 branches missed.">        if (nextToken() != Token.FOR) codeBug();</span>
<span class="fc" id="L3268">        int pos = ts.tokenBeg;</span>
<span class="fc" id="L3269">        int eachPos = -1, lp = -1, rp = -1, inPos = -1;</span>
<span class="fc" id="L3270">        boolean isForIn = false, isForOf = false;</span>
<span class="fc" id="L3271">        ArrayComprehensionLoop pn = new ArrayComprehensionLoop(pos);</span>

<span class="fc" id="L3273">        pushScope(pn);</span>
        try {
<span class="fc bfc" id="L3275" title="All 2 branches covered.">            if (matchToken(Token.NAME)) {</span>
<span class="pc bpc" id="L3276" title="1 of 2 branches missed.">                if (ts.getString().equals(&quot;each&quot;)) {</span>
<span class="fc" id="L3277">                    eachPos = ts.tokenBeg - pos;</span>
                } else {
<span class="nc" id="L3279">                    reportError(&quot;msg.no.paren.for&quot;);</span>
                }
            }
<span class="pc bpc" id="L3282" title="1 of 2 branches missed.">            if (mustMatchToken(Token.LP, &quot;msg.no.paren.for&quot;)) {</span>
<span class="fc" id="L3283">                lp = ts.tokenBeg - pos;</span>
            }

<span class="fc" id="L3286">            AstNode iter = null;</span>
<span class="pc bpc" id="L3287" title="1 of 3 branches missed.">            switch (peekToken()) {</span>
              case Token.LB:
              case Token.LC:
                  // handle destructuring assignment
<span class="fc" id="L3291">                  iter = destructuringPrimaryExpr();</span>
<span class="fc" id="L3292">                  markDestructuring(iter);</span>
<span class="fc" id="L3293">                  break;</span>
              case Token.NAME:
<span class="fc" id="L3295">                  consumeToken();</span>
<span class="fc" id="L3296">                  iter = createNameNode();</span>
<span class="fc" id="L3297">                  break;</span>
              default:
<span class="nc" id="L3299">                  reportError(&quot;msg.bad.var&quot;);</span>
            }

            // Define as a let since we want the scope of the variable to
            // be restricted to the array comprehension
<span class="fc bfc" id="L3304" title="All 2 branches covered.">            if (iter.getType() == Token.NAME) {</span>
<span class="fc" id="L3305">                defineSymbol(Token.LET, ts.getString(), true);</span>
            }

<span class="pc bpc" id="L3308" title="1 of 3 branches missed.">            switch (nextToken()) {</span>
            case Token.IN:
<span class="fc" id="L3310">                inPos = ts.tokenBeg - pos;</span>
<span class="fc" id="L3311">                isForIn = true;</span>
<span class="fc" id="L3312">                break;</span>
            case Token.NAME:
<span class="pc bpc" id="L3314" title="1 of 2 branches missed.">                if (&quot;of&quot;.equals(ts.getString())) {</span>
<span class="fc bfc" id="L3315" title="All 2 branches covered.">                    if (eachPos != -1) {</span>
<span class="nc" id="L3316">                        reportError(&quot;msg.invalid.for.each&quot;);</span>
                    }
<span class="fc" id="L3318">                    inPos = ts.tokenBeg - pos;</span>
<span class="fc" id="L3319">                    isForOf = true;</span>
<span class="fc" id="L3320">                    break;</span>
                }
                // fallthru
            default:
<span class="nc" id="L3324">                reportError(&quot;msg.in.after.for.name&quot;);</span>
            }
<span class="fc" id="L3326">            AstNode obj = expr();</span>
<span class="pc bpc" id="L3327" title="1 of 2 branches missed.">            if (mustMatchToken(Token.RP, &quot;msg.no.paren.for.ctrl&quot;))</span>
<span class="fc" id="L3328">                rp = ts.tokenBeg - pos;</span>

<span class="fc" id="L3330">            pn.setLength(ts.tokenEnd - pos);</span>
<span class="fc" id="L3331">            pn.setIterator(iter);</span>
<span class="fc" id="L3332">            pn.setIteratedObject(obj);</span>
<span class="fc" id="L3333">            pn.setInPosition(inPos);</span>
<span class="fc" id="L3334">            pn.setEachPosition(eachPos);</span>
<span class="fc bfc" id="L3335" title="All 2 branches covered.">            pn.setIsForEach(eachPos != -1);</span>
<span class="fc" id="L3336">            pn.setParens(lp, rp);</span>
<span class="fc" id="L3337">            pn.setIsForOf(isForOf);</span>
<span class="fc" id="L3338">            return pn;</span>
        } finally {
<span class="fc" id="L3340">            popScope();</span>
<span class="fc" id="L3341">        }</span>
    }

    private AstNode generatorExpression(AstNode result, int pos)
        throws IOException
    {
<span class="fc" id="L3347">        return generatorExpression(result, pos, false);</span>
    }
    
    private AstNode generatorExpression(AstNode result, int pos, boolean inFunctionParams)
        throws IOException
    {
        
<span class="fc" id="L3354">        List&lt;GeneratorExpressionLoop&gt; loops =</span>
                new ArrayList&lt;GeneratorExpressionLoop&gt;();
<span class="fc bfc" id="L3356" title="All 2 branches covered.">        while (peekToken() == Token.FOR) {</span>
<span class="fc" id="L3357">            loops.add(generatorExpressionLoop());</span>
        }
<span class="fc" id="L3359">        int ifPos = -1;</span>
<span class="fc" id="L3360">        ConditionData data = null;</span>
<span class="fc bfc" id="L3361" title="All 2 branches covered.">        if (peekToken() == Token.IF) {</span>
<span class="fc" id="L3362">            consumeToken();</span>
<span class="fc" id="L3363">            ifPos = ts.tokenBeg - pos;</span>
<span class="fc" id="L3364">            data = condition();</span>
        }
<span class="fc bfc" id="L3366" title="All 2 branches covered.">        if(!inFunctionParams) {</span>
<span class="fc" id="L3367">            mustMatchToken(Token.RP, &quot;msg.no.paren.let&quot;);</span>
        }
<span class="fc" id="L3369">        GeneratorExpression pn = new GeneratorExpression(pos, ts.tokenEnd - pos);</span>
<span class="fc" id="L3370">        pn.setResult(result);</span>
<span class="fc" id="L3371">        pn.setLoops(loops);</span>
<span class="fc bfc" id="L3372" title="All 2 branches covered.">        if (data != null) {</span>
<span class="fc" id="L3373">            pn.setIfPosition(ifPos);</span>
<span class="fc" id="L3374">            pn.setFilter(data.condition);</span>
<span class="fc" id="L3375">            pn.setFilterLp(data.lp - pos);</span>
<span class="fc" id="L3376">            pn.setFilterRp(data.rp - pos);</span>
        }
<span class="fc" id="L3378">        return pn;</span>
    }
        
    private GeneratorExpressionLoop generatorExpressionLoop()
        throws IOException
    {
<span class="pc bpc" id="L3384" title="1 of 2 branches missed.">        if (nextToken() != Token.FOR) codeBug();</span>
<span class="fc" id="L3385">        int pos = ts.tokenBeg;</span>
<span class="fc" id="L3386">        int lp = -1, rp = -1, inPos = -1;</span>
<span class="fc" id="L3387">        GeneratorExpressionLoop pn = new GeneratorExpressionLoop(pos);</span>

<span class="fc" id="L3389">        pushScope(pn);</span>
        try {
<span class="pc bpc" id="L3391" title="1 of 2 branches missed.">            if (mustMatchToken(Token.LP, &quot;msg.no.paren.for&quot;)) {</span>
<span class="fc" id="L3392">                lp = ts.tokenBeg - pos;</span>
            }

<span class="fc" id="L3395">            AstNode iter = null;</span>
<span class="pc bpc" id="L3396" title="2 of 3 branches missed.">            switch (peekToken()) {</span>
              case Token.LB:
              case Token.LC:
                  // handle destructuring assignment
<span class="nc" id="L3400">                  iter = destructuringPrimaryExpr();</span>
<span class="nc" id="L3401">                  markDestructuring(iter);</span>
<span class="nc" id="L3402">                  break;</span>
              case Token.NAME:
<span class="fc" id="L3404">                  consumeToken();</span>
<span class="fc" id="L3405">                  iter = createNameNode();</span>
<span class="fc" id="L3406">                  break;</span>
              default:
<span class="nc" id="L3408">                  reportError(&quot;msg.bad.var&quot;);</span>
            }

            // Define as a let since we want the scope of the variable to
            // be restricted to the array comprehension
<span class="pc bpc" id="L3413" title="1 of 2 branches missed.">            if (iter.getType() == Token.NAME) {</span>
<span class="fc" id="L3414">                defineSymbol(Token.LET, ts.getString(), true);</span>
            }

<span class="pc bpc" id="L3417" title="1 of 2 branches missed.">            if (mustMatchToken(Token.IN, &quot;msg.in.after.for.name&quot;))</span>
<span class="fc" id="L3418">                inPos = ts.tokenBeg - pos;</span>
<span class="fc" id="L3419">            AstNode obj = expr();</span>
<span class="pc bpc" id="L3420" title="1 of 2 branches missed.">            if (mustMatchToken(Token.RP, &quot;msg.no.paren.for.ctrl&quot;))</span>
<span class="fc" id="L3421">                rp = ts.tokenBeg - pos;</span>

<span class="fc" id="L3423">            pn.setLength(ts.tokenEnd - pos);</span>
<span class="fc" id="L3424">            pn.setIterator(iter);</span>
<span class="fc" id="L3425">            pn.setIteratedObject(obj);</span>
<span class="fc" id="L3426">            pn.setInPosition(inPos);</span>
<span class="fc" id="L3427">            pn.setParens(lp, rp);</span>
<span class="fc" id="L3428">            return pn;</span>
        } finally {
<span class="fc" id="L3430">            popScope();</span>
<span class="fc" id="L3431">        }</span>
    }

    private static final int PROP_ENTRY   = 1;
    private static final int GET_ENTRY    = 2;
    private static final int SET_ENTRY    = 4;
    private static final int METHOD_ENTRY = 8;

    private ObjectLiteral objectLiteral()
        throws IOException
    {
<span class="fc" id="L3442">        int pos = ts.tokenBeg, lineno = ts.lineno;</span>
<span class="fc" id="L3443">        int afterComma = -1;</span>
<span class="fc" id="L3444">        List&lt;ObjectProperty&gt; elems = new ArrayList&lt;ObjectProperty&gt;();</span>
<span class="fc" id="L3445">        Set&lt;String&gt; getterNames = null;</span>
<span class="fc" id="L3446">        Set&lt;String&gt; setterNames = null;</span>
<span class="fc bfc" id="L3447" title="All 2 branches covered.">        if (this.inUseStrictDirective) {</span>
<span class="fc" id="L3448">            getterNames = new HashSet&lt;String&gt;();</span>
<span class="fc" id="L3449">            setterNames = new HashSet&lt;String&gt;();</span>
        }
<span class="fc" id="L3451">        Comment objJsdocNode = getAndResetJsDoc();</span>

      commaLoop:
        for (;;) {
<span class="fc" id="L3455">            String propertyName = null;</span>
<span class="fc" id="L3456">            int entryKind = PROP_ENTRY;</span>
<span class="fc" id="L3457">            int tt = peekToken();</span>
<span class="fc" id="L3458">            Comment jsdocNode = getAndResetJsDoc();</span>

<span class="fc bfc" id="L3460" title="All 2 branches covered.">            if (tt == Token.RC) {</span>
<span class="fc bfc" id="L3461" title="All 2 branches covered.">                if (afterComma != -1)</span>
<span class="fc" id="L3462">                    warnTrailingComma(pos, elems, afterComma);</span>
                break commaLoop;
            } else {
<span class="fc" id="L3465">                AstNode pname = objliteralProperty();</span>
<span class="fc bfc" id="L3466" title="All 2 branches covered.">                if (pname == null) {</span>
<span class="fc" id="L3467">                    propertyName = null;</span>
<span class="nc" id="L3468">                    reportError(&quot;msg.bad.prop&quot;);</span>
                } else {
<span class="fc" id="L3470">                    propertyName = ts.getString();</span>
<span class="fc" id="L3471">                    int ppos = ts.tokenBeg;</span>
<span class="fc" id="L3472">                    consumeToken();</span>

                    // This code path needs to handle both destructuring object
                    // literals like:
                    // var {get, b} = {get: 1, b: 2};
                    // and getters like:
                    // var x = {get 1() { return 2; };
                    // So we check a whitelist of tokens to check if we're at the
                    // first case. (Because of keywords, the second case may be
                    // many tokens.)
<span class="fc" id="L3482">                    int peeked = peekToken();</span>
<span class="fc bfc" id="L3483" title="All 6 branches covered.">                    if (peeked != Token.COMMA</span>
                            &amp;&amp; peeked != Token.COLON
                            &amp;&amp; peeked != Token.RC)
                    {
<span class="fc bfc" id="L3487" title="All 2 branches covered.">                        if (peeked == Token.LP) {</span>
<span class="fc" id="L3488">                            entryKind = METHOD_ENTRY;</span>
<span class="pc bpc" id="L3489" title="1 of 2 branches missed.">                        } else if (pname.getType() == Token.NAME) {</span>
<span class="fc bfc" id="L3490" title="All 2 branches covered.">                            if (&quot;get&quot;.equals(propertyName)) {</span>
<span class="fc" id="L3491">                                entryKind = GET_ENTRY;</span>
<span class="fc bfc" id="L3492" title="All 2 branches covered.">                            } else if (&quot;set&quot;.equals(propertyName)) {</span>
<span class="fc" id="L3493">                                entryKind = SET_ENTRY;</span>
                            }
                        }
<span class="fc bfc" id="L3496" title="All 4 branches covered.">                        if (entryKind == GET_ENTRY || entryKind == SET_ENTRY) {</span>
<span class="fc" id="L3497">                            pname = objliteralProperty();</span>
<span class="pc bpc" id="L3498" title="1 of 2 branches missed.">                            if (pname == null) {</span>
<span class="nc" id="L3499">                                reportError(&quot;msg.bad.prop&quot;);</span>
                            }
<span class="fc" id="L3501">                            consumeToken();</span>
                        }
<span class="pc bpc" id="L3503" title="1 of 2 branches missed.">                        if (pname == null) {</span>
<span class="nc" id="L3504">                            propertyName = null;</span>
                        } else {
<span class="fc" id="L3506">                            propertyName = ts.getString();</span>
<span class="fc" id="L3507">                            ObjectProperty objectProp = methodDefinition(</span>
                                    ppos, pname, entryKind);
<span class="fc" id="L3509">                            pname.setJsDocNode(jsdocNode);</span>
<span class="fc" id="L3510">                            elems.add(objectProp);</span>
<span class="fc" id="L3511">                        }</span>
                    } else {
<span class="fc" id="L3513">                        pname.setJsDocNode(jsdocNode);</span>
<span class="fc" id="L3514">                        elems.add(plainProperty(pname, tt));</span>
                    }
                }
            }

<span class="pc bpc" id="L3519" title="1 of 4 branches missed.">            if (this.inUseStrictDirective &amp;&amp; propertyName != null) {</span>
<span class="pc bpc" id="L3520" title="2 of 4 branches missed.">                switch (entryKind) {</span>
                case PROP_ENTRY:
                case METHOD_ENTRY:
<span class="nc bnc" id="L3523" title="All 2 branches missed.">                    if (getterNames.contains(propertyName)</span>
<span class="nc bnc" id="L3524" title="All 2 branches missed.">                            || setterNames.contains(propertyName)) {</span>
<span class="nc" id="L3525">                        addError(&quot;msg.dup.obj.lit.prop.strict&quot;, propertyName);</span>
                    }
<span class="nc" id="L3527">                    getterNames.add(propertyName);</span>
<span class="nc" id="L3528">                    setterNames.add(propertyName);</span>
<span class="nc" id="L3529">                    break;</span>
                case GET_ENTRY:
<span class="pc bpc" id="L3531" title="1 of 2 branches missed.">                    if (getterNames.contains(propertyName)) {</span>
<span class="nc" id="L3532">                        addError(&quot;msg.dup.obj.lit.prop.strict&quot;, propertyName);</span>
                    }
<span class="fc" id="L3534">                    getterNames.add(propertyName);</span>
<span class="fc" id="L3535">                    break;</span>
                case SET_ENTRY:
<span class="pc bpc" id="L3537" title="1 of 2 branches missed.">                    if (setterNames.contains(propertyName)) {</span>
<span class="nc" id="L3538">                        addError(&quot;msg.dup.obj.lit.prop.strict&quot;, propertyName);</span>
                    }
<span class="fc" id="L3540">                    setterNames.add(propertyName);</span>
                    break;
                }
            }

            // Eat any dangling jsdoc in the property.
<span class="fc" id="L3546">            getAndResetJsDoc();</span>

<span class="fc bfc" id="L3548" title="All 2 branches covered.">            if (matchToken(Token.COMMA)) {</span>
<span class="fc" id="L3549">                afterComma = ts.tokenEnd;</span>
            } else {
                break commaLoop;
            }
<span class="fc" id="L3553">        }</span>

<span class="fc" id="L3555">        mustMatchToken(Token.RC, &quot;msg.no.brace.prop&quot;);</span>
<span class="fc" id="L3556">        ObjectLiteral pn = new ObjectLiteral(pos, ts.tokenEnd - pos);</span>
<span class="fc bfc" id="L3557" title="All 2 branches covered.">        if (objJsdocNode != null) {</span>
<span class="fc" id="L3558">            pn.setJsDocNode(objJsdocNode);</span>
        }
<span class="fc" id="L3560">        pn.setElements(elems);</span>
<span class="fc" id="L3561">        pn.setLineno(lineno);</span>
<span class="fc" id="L3562">        return pn;</span>
    }

    private AstNode objliteralProperty() throws IOException {
        AstNode pname;
<span class="fc" id="L3567">        int tt = peekToken();</span>
<span class="fc bfc" id="L3568" title="All 4 branches covered.">        switch(tt) {</span>
          case Token.NAME:
<span class="fc" id="L3570">              pname = createNameNode();</span>
<span class="fc" id="L3571">              break;</span>

          case Token.STRING:
<span class="fc" id="L3574">              pname = createStringLiteral();</span>
<span class="fc" id="L3575">              break;</span>

          case Token.NUMBER:
<span class="fc" id="L3578">              pname = new NumberLiteral(</span>
<span class="fc" id="L3579">                      ts.tokenBeg, ts.getString(), ts.getNumber());</span>
<span class="fc" id="L3580">              break;</span>

          default:
<span class="fc bfc" id="L3583" title="All 2 branches covered.">              if (compilerEnv.isReservedKeywordAsIdentifier()</span>
<span class="pc bpc" id="L3584" title="1 of 2 branches missed.">                      &amp;&amp; TokenStream.isKeyword(ts.getString(), compilerEnv.getLanguageVersion(), inUseStrictDirective)) {</span>
                  // convert keyword to property name, e.g. ({if: 1})
<span class="fc" id="L3586">                  pname = createNameNode();</span>
<span class="fc" id="L3587">                  break;</span>
              }
<span class="fc" id="L3589">              return null;</span>
        }

<span class="fc" id="L3592">        return pname;</span>
    }

    private ObjectProperty plainProperty(AstNode property, int ptt)
        throws IOException
    {
        // Support, e.g., |var {x, y} = o| as destructuring shorthand
        // for |var {x: x, y: y} = o|, as implemented in spidermonkey JS 1.8.
<span class="fc" id="L3600">        int tt = peekToken();</span>
<span class="pc bpc" id="L3601" title="1 of 6 branches missed.">        if ((tt == Token.COMMA || tt == Token.RC) &amp;&amp; ptt == Token.NAME</span>
<span class="fc bfc" id="L3602" title="All 2 branches covered.">                &amp;&amp; compilerEnv.getLanguageVersion() &gt;= Context.VERSION_1_8) {</span>
<span class="fc bfc" id="L3603" title="All 2 branches covered.">            if (!inDestructuringAssignment) {</span>
<span class="nc" id="L3604">                reportError(&quot;msg.bad.object.init&quot;);</span>
            }
<span class="fc" id="L3606">            AstNode nn = new Name(property.getPosition(), property.getString());</span>
<span class="fc" id="L3607">            ObjectProperty pn = new ObjectProperty();</span>
<span class="fc" id="L3608">            pn.putProp(Node.DESTRUCTURING_SHORTHAND, Boolean.TRUE);</span>
<span class="fc" id="L3609">            pn.setLeftAndRight(property, nn);</span>
<span class="fc" id="L3610">            return pn;</span>
        }
<span class="fc" id="L3612">        mustMatchToken(Token.COLON, &quot;msg.no.colon.prop&quot;);</span>
<span class="fc" id="L3613">        ObjectProperty pn = new ObjectProperty();</span>
<span class="fc" id="L3614">        pn.setOperatorPosition(ts.tokenBeg);</span>
<span class="fc" id="L3615">        pn.setLeftAndRight(property, assignExpr());</span>
<span class="fc" id="L3616">        return pn;</span>
    }

    private ObjectProperty methodDefinition(int pos, AstNode propName, int entryKind)
        throws IOException
    {
<span class="fc" id="L3622">        FunctionNode fn = function(FunctionNode.FUNCTION_EXPRESSION);</span>
        // We've already parsed the function name, so fn should be anonymous.
<span class="fc" id="L3624">        Name name = fn.getFunctionName();</span>
<span class="pc bpc" id="L3625" title="1 of 4 branches missed.">        if (name != null &amp;&amp; name.length() != 0) {</span>
<span class="nc" id="L3626">            reportError(&quot;msg.bad.prop&quot;);</span>
        }
<span class="fc" id="L3628">        ObjectProperty pn = new ObjectProperty(pos);</span>
<span class="pc bpc" id="L3629" title="1 of 4 branches missed.">        switch (entryKind) {</span>
        case GET_ENTRY:
<span class="fc" id="L3631">            pn.setIsGetterMethod();</span>
<span class="fc" id="L3632">            fn.setFunctionIsGetterMethod();</span>
<span class="fc" id="L3633">            break;</span>
        case SET_ENTRY:
<span class="fc" id="L3635">            pn.setIsSetterMethod();</span>
<span class="fc" id="L3636">            fn.setFunctionIsSetterMethod();</span>
<span class="fc" id="L3637">            break;</span>
        case METHOD_ENTRY:
<span class="fc" id="L3639">            pn.setIsNormalMethod();</span>
<span class="fc" id="L3640">            fn.setFunctionIsNormalMethod();</span>
            break;
        }
<span class="fc" id="L3643">        int end = getNodeEnd(fn);</span>
<span class="fc" id="L3644">        pn.setLeft(propName);</span>
<span class="fc" id="L3645">        pn.setRight(fn);</span>
<span class="fc" id="L3646">        pn.setLength(end - pos);</span>
<span class="fc" id="L3647">        return pn;</span>
    }

    private Name createNameNode() {
<span class="fc" id="L3651">        return createNameNode(false, Token.NAME);</span>
    }

    /**
     * Create a {@code Name} node using the token info from the
     * last scanned name.  In some cases we need to either synthesize
     * a name node, or we lost the name token information by peeking.
     * If the {@code token} parameter is not {@link Token#NAME}, then
     * we use token info saved in instance vars.
     */
    private Name createNameNode(boolean checkActivation, int token) {
<span class="fc" id="L3662">        int beg = ts.tokenBeg;</span>
<span class="fc" id="L3663">        String s = ts.getString();</span>
<span class="fc" id="L3664">        int lineno = ts.lineno;</span>
<span class="fc bfc" id="L3665" title="All 2 branches covered.">        if (!&quot;&quot;.equals(prevNameTokenString)) {</span>
<span class="fc" id="L3666">            beg = prevNameTokenStart;</span>
<span class="fc" id="L3667">            s = prevNameTokenString;</span>
<span class="fc" id="L3668">            lineno = prevNameTokenLineno;</span>
<span class="fc" id="L3669">            prevNameTokenStart = 0;</span>
<span class="fc" id="L3670">            prevNameTokenString = &quot;&quot;;</span>
<span class="fc" id="L3671">            prevNameTokenLineno = 0;</span>
        }
<span class="pc bpc" id="L3673" title="1 of 2 branches missed.">        if (s == null) {</span>
<span class="nc bnc" id="L3674" title="All 2 branches missed.">            if (compilerEnv.isIdeMode()) {</span>
<span class="nc" id="L3675">                s = &quot;&quot;;</span>
            } else {
<span class="nc" id="L3677">                codeBug();</span>
            }
        }
<span class="fc" id="L3680">        Name name = new Name(beg, s);</span>
<span class="fc" id="L3681">        name.setLineno(lineno);</span>
<span class="fc bfc" id="L3682" title="All 2 branches covered.">        if (checkActivation) {</span>
<span class="fc" id="L3683">            checkActivationName(s, token);</span>
        }
<span class="fc" id="L3685">        return name;</span>
    }

    private StringLiteral createStringLiteral() {
<span class="fc" id="L3689">        int pos = ts.tokenBeg, end = ts.tokenEnd;</span>
<span class="fc" id="L3690">        StringLiteral s = new StringLiteral(pos, end - pos);</span>
<span class="fc" id="L3691">        s.setLineno(ts.lineno);</span>
<span class="fc" id="L3692">        s.setValue(ts.getString());</span>
<span class="fc" id="L3693">        s.setQuoteCharacter(ts.getQuoteChar());</span>
<span class="fc" id="L3694">        return s;</span>
    }

    protected void checkActivationName(String name, int token) {
<span class="fc bfc" id="L3698" title="All 2 branches covered.">        if (!insideFunction()) {</span>
<span class="fc" id="L3699">            return;</span>
        }
<span class="fc" id="L3701">        boolean activation = false;</span>
<span class="fc bfc" id="L3702" title="All 2 branches covered.">        if (&quot;arguments&quot;.equals(name) &amp;&amp;</span>
            // An arrow function not generate arguments. So it not need activation.
<span class="fc bfc" id="L3704" title="All 2 branches covered.">            ((FunctionNode)currentScriptOrFn).getFunctionType() != FunctionNode.ARROW_FUNCTION) {</span>
<span class="fc" id="L3705">            activation = true;</span>
<span class="pc bpc" id="L3706" title="1 of 2 branches missed.">        } else if (compilerEnv.getActivationNames() != null</span>
<span class="nc bnc" id="L3707" title="All 2 branches missed.">                &amp;&amp; compilerEnv.getActivationNames().contains(name)) {</span>
<span class="nc" id="L3708">            activation = true;</span>
<span class="fc bfc" id="L3709" title="All 2 branches covered.">        } else if (&quot;length&quot;.equals(name)) {</span>
<span class="fc bfc" id="L3710" title="All 2 branches covered.">            if (token == Token.GETPROP</span>
<span class="pc bpc" id="L3711" title="1 of 2 branches missed.">                &amp;&amp; compilerEnv.getLanguageVersion() == Context.VERSION_1_2)</span>
            {
                // Use of &quot;length&quot; in 1.2 requires an activation object.
<span class="nc" id="L3714">                activation = true;</span>
            }
        }
<span class="fc bfc" id="L3717" title="All 2 branches covered.">        if (activation) {</span>
<span class="fc" id="L3718">            setRequiresActivation();</span>
        }
<span class="fc" id="L3720">    }</span>

    protected void setRequiresActivation() {
<span class="fc bfc" id="L3723" title="All 2 branches covered.">        if (insideFunction()) {</span>
<span class="fc" id="L3724">            ((FunctionNode)currentScriptOrFn).setRequiresActivation();</span>
        }
<span class="fc" id="L3726">    }</span>

    private void checkCallRequiresActivation(AstNode pn) {
<span class="fc bfc" id="L3729" title="All 2 branches covered.">        if ((pn.getType() == Token.NAME</span>
<span class="fc bfc" id="L3730" title="All 2 branches covered.">             &amp;&amp; &quot;eval&quot;.equals(((Name)pn).getIdentifier()))</span>
<span class="fc bfc" id="L3731" title="All 2 branches covered.">            || (pn.getType() == Token.GETPROP &amp;&amp;</span>
<span class="fc bfc" id="L3732" title="All 2 branches covered.">                &quot;eval&quot;.equals(((PropertyGet)pn).getProperty().getIdentifier())))</span>
<span class="fc" id="L3733">            setRequiresActivation();</span>
<span class="fc" id="L3734">    }</span>

    protected void setIsGenerator() {
<span class="pc bpc" id="L3737" title="1 of 2 branches missed.">        if (insideFunction()) {</span>
<span class="fc" id="L3738">            ((FunctionNode)currentScriptOrFn).setIsGenerator();</span>
        }
<span class="fc" id="L3740">    }</span>

    private void checkBadIncDec(UnaryExpression expr) {
<span class="fc" id="L3743">        AstNode op = removeParens(expr.getOperand());</span>
<span class="fc" id="L3744">        int tt = op.getType();</span>
<span class="pc bpc" id="L3745" title="2 of 10 branches missed.">        if (!(tt == Token.NAME</span>
              || tt == Token.GETPROP
              || tt == Token.GETELEM
              || tt == Token.GET_REF
              || tt == Token.CALL))
<span class="nc bnc" id="L3750" title="All 2 branches missed.">            reportError(expr.getType() == Token.INC</span>
                        ? &quot;msg.bad.incr&quot;
                        : &quot;msg.bad.decr&quot;);
<span class="fc" id="L3753">    }</span>

    private ErrorNode makeErrorNode() {
<span class="fc" id="L3756">        ErrorNode pn = new ErrorNode(ts.tokenBeg, ts.tokenEnd - ts.tokenBeg);</span>
<span class="fc" id="L3757">        pn.setLineno(ts.lineno);</span>
<span class="fc" id="L3758">        return pn;</span>
    }

    // Return end of node.  Assumes node does NOT have a parent yet.
    private int nodeEnd(AstNode node) {
<span class="fc" id="L3763">        return node.getPosition() + node.getLength();</span>
    }

    private void saveNameTokenData(int pos, String name, int lineno) {
<span class="fc" id="L3767">        prevNameTokenStart = pos;</span>
<span class="fc" id="L3768">        prevNameTokenString = name;</span>
<span class="fc" id="L3769">        prevNameTokenLineno = lineno;</span>
<span class="fc" id="L3770">    }</span>

    /**
     * Return the file offset of the beginning of the input source line
     * containing the passed position.
     *
     * @param pos an offset into the input source stream.  If the offset
     * is negative, it's converted to 0, and if it's beyond the end of
     * the source buffer, the last source position is used.
     *
     * @return the offset of the beginning of the line containing pos
     * (i.e. 1+ the offset of the first preceding newline).  Returns -1
     * if the {@link CompilerEnvirons} is not set to ide-mode,
     * and {@link #parse(java.io.Reader,String,int)} was used.
     */
    private int lineBeginningFor(int pos) {
<span class="nc bnc" id="L3786" title="All 2 branches missed.">        if (sourceChars == null) {</span>
<span class="nc" id="L3787">            return -1;</span>
        }
<span class="nc bnc" id="L3789" title="All 2 branches missed.">        if (pos &lt;= 0) {</span>
<span class="nc" id="L3790">            return 0;</span>
        }
<span class="nc" id="L3792">        char[] buf = sourceChars;</span>
<span class="nc bnc" id="L3793" title="All 2 branches missed.">        if (pos &gt;= buf.length) {</span>
<span class="nc" id="L3794">            pos = buf.length - 1;</span>
        }
<span class="nc bnc" id="L3796" title="All 2 branches missed.">        while (--pos &gt;= 0) {</span>
<span class="nc" id="L3797">            char c = buf[pos];</span>
<span class="nc bnc" id="L3798" title="All 2 branches missed.">            if (ScriptRuntime.isJSLineTerminator(c)) {</span>
<span class="nc" id="L3799">                return pos + 1; // want position after the newline</span>
            }
<span class="nc" id="L3801">        }</span>
<span class="nc" id="L3802">        return 0;</span>
    }

    private void warnMissingSemi(int pos, int end) {
        // Should probably change this to be a CompilerEnvirons setting,
        // with an enum Never, Always, Permissive, where Permissive means
        // don't warn for 1-line functions like function (s) {return x+2}
<span class="fc bfc" id="L3809" title="All 2 branches covered.">        if (compilerEnv.isStrictMode()) {</span>
<span class="fc" id="L3810">            int[] linep = new int[2];</span>
<span class="fc" id="L3811">            String line = ts.getLine(end, linep);</span>
            // this code originally called lineBeginningFor() and in order to
            // preserve its different line-offset handling, we need to special
            // case ide-mode here
<span class="fc bfc" id="L3815" title="All 2 branches covered.">            int beg = compilerEnv.isIdeMode()</span>
<span class="fc" id="L3816">                      ? Math.max(pos, end - linep[1])</span>
                      : pos;
<span class="fc bfc" id="L3818" title="All 2 branches covered.">            if (line != null) {</span>
<span class="fc" id="L3819">                addStrictWarning(&quot;msg.missing.semi&quot;, &quot;&quot;, beg, end - beg,</span>
                                 linep[0], line, linep[1]);
            } else {
                // no line information available, report warning at current line
<span class="fc" id="L3823">                addStrictWarning(&quot;msg.missing.semi&quot;, &quot;&quot;, beg, end - beg);</span>
            }
        }
<span class="fc" id="L3826">    }</span>

    private void warnTrailingComma(int pos, List&lt;?&gt; elems, int commaPos) {
<span class="pc bpc" id="L3829" title="1 of 2 branches missed.">        if (compilerEnv.getWarnTrailingComma()) {</span>
            // back up from comma to beginning of line or array/objlit
<span class="nc bnc" id="L3831" title="All 2 branches missed.">            if (!elems.isEmpty()) {</span>
<span class="nc" id="L3832">                pos = ((AstNode)elems.get(0)).getPosition();</span>
            }
<span class="nc" id="L3834">            pos = Math.max(pos, lineBeginningFor(commaPos));</span>
<span class="nc" id="L3835">            addWarning(&quot;msg.extra.trailing.comma&quot;, pos, commaPos - pos);</span>
        }
<span class="fc" id="L3837">    }</span>


    private String readFully(Reader reader) throws IOException {
<span class="fc" id="L3841">        BufferedReader in = new BufferedReader(reader);</span>
        try {
<span class="fc" id="L3843">            char[] cbuf = new char[1024];</span>
<span class="fc" id="L3844">            StringBuilder sb = new StringBuilder(1024);</span>
            int bytes_read;
<span class="fc bfc" id="L3846" title="All 2 branches covered.">            while ((bytes_read = in.read(cbuf, 0, 1024)) != -1) {</span>
<span class="fc" id="L3847">                sb.append(cbuf, 0, bytes_read);</span>
            }
<span class="fc" id="L3849">            return sb.toString();</span>
        } finally {
<span class="pc" id="L3851">            in.close();</span>
<span class="nc" id="L3852">        }</span>
    }

    // helps reduce clutter in the already-large function() method
    protected class PerFunctionVariables
    {
        private ScriptNode savedCurrentScriptOrFn;
        private Scope savedCurrentScope;
        private int savedEndFlags;
        private boolean savedInForInit;
        private Map&lt;String,LabeledStatement&gt; savedLabelSet;
        private List&lt;Loop&gt; savedLoopSet;
        private List&lt;Jump&gt; savedLoopAndSwitchSet;

<span class="fc" id="L3866">        PerFunctionVariables(FunctionNode fnNode) {</span>
<span class="fc" id="L3867">            savedCurrentScriptOrFn = Parser.this.currentScriptOrFn;</span>
<span class="fc" id="L3868">            Parser.this.currentScriptOrFn = fnNode;</span>

<span class="fc" id="L3870">            savedCurrentScope = Parser.this.currentScope;</span>
<span class="fc" id="L3871">            Parser.this.currentScope = fnNode;</span>

<span class="fc" id="L3873">            savedLabelSet = Parser.this.labelSet;</span>
<span class="fc" id="L3874">            Parser.this.labelSet = null;</span>

<span class="fc" id="L3876">            savedLoopSet = Parser.this.loopSet;</span>
<span class="fc" id="L3877">            Parser.this.loopSet = null;</span>

<span class="fc" id="L3879">            savedLoopAndSwitchSet = Parser.this.loopAndSwitchSet;</span>
<span class="fc" id="L3880">            Parser.this.loopAndSwitchSet = null;</span>

<span class="fc" id="L3882">            savedEndFlags = Parser.this.endFlags;</span>
<span class="fc" id="L3883">            Parser.this.endFlags = 0;</span>

<span class="fc" id="L3885">            savedInForInit = Parser.this.inForInit;</span>
<span class="fc" id="L3886">            Parser.this.inForInit = false;</span>
<span class="fc" id="L3887">        }</span>

        void restore() {
<span class="fc" id="L3890">            Parser.this.currentScriptOrFn = savedCurrentScriptOrFn;</span>
<span class="fc" id="L3891">            Parser.this.currentScope = savedCurrentScope;</span>
<span class="fc" id="L3892">            Parser.this.labelSet = savedLabelSet;</span>
<span class="fc" id="L3893">            Parser.this.loopSet = savedLoopSet;</span>
<span class="fc" id="L3894">            Parser.this.loopAndSwitchSet = savedLoopAndSwitchSet;</span>
<span class="fc" id="L3895">            Parser.this.endFlags = savedEndFlags;</span>
<span class="fc" id="L3896">            Parser.this.inForInit = savedInForInit;</span>
<span class="fc" id="L3897">        }</span>
    }

    /**
     * Given a destructuring assignment with a left hand side parsed
     * as an array or object literal and a right hand side expression,
     * rewrite as a series of assignments to the variables defined in
     * left from property accesses to the expression on the right.
     * @param type declaration type: Token.VAR or Token.LET or -1
     * @param left array or object literal containing NAME nodes for
     *        variables to assign
     * @param right expression to assign from
     * @return expression that performs a series of assignments to
     *         the variables defined in left
     */
    Node createDestructuringAssignment(int type, Node left, Node right)
    {
<span class="fc" id="L3914">        String tempName = currentScriptOrFn.getNextTempName();</span>
<span class="fc" id="L3915">        Node result = destructuringAssignmentHelper(type, left, right,</span>
            tempName);
<span class="fc" id="L3917">        Node comma = result.getLastChild();</span>
<span class="fc" id="L3918">        comma.addChildToBack(createName(tempName));</span>
<span class="fc" id="L3919">        return result;</span>
    }

    Node destructuringAssignmentHelper(int variableType, Node left,
                                       Node right, String tempName)
    {
<span class="fc" id="L3925">        Scope result = createScopeNode(Token.LETEXPR, left.getLineno());</span>
<span class="fc" id="L3926">        result.addChildToFront(new Node(Token.LET,</span>
<span class="fc" id="L3927">            createName(Token.NAME, tempName, right)));</span>
        try {
<span class="fc" id="L3929">            pushScope(result);</span>
<span class="fc" id="L3930">            defineSymbol(Token.LET, tempName, true);</span>
        } finally {
<span class="pc" id="L3932">            popScope();</span>
<span class="pc" id="L3933">        }</span>
<span class="fc" id="L3934">        Node comma = new Node(Token.COMMA);</span>
<span class="fc" id="L3935">        result.addChildToBack(comma);</span>
<span class="fc" id="L3936">        List&lt;String&gt; destructuringNames = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L3937">        boolean empty = true;</span>
<span class="pc bpc" id="L3938" title="1 of 4 branches missed.">        switch (left.getType()) {</span>
          case Token.ARRAYLIT:
<span class="fc" id="L3940">              empty = destructuringArray((ArrayLiteral)left,</span>
                                         variableType, tempName, comma,
                                         destructuringNames);
<span class="fc" id="L3943">              break;</span>
          case Token.OBJECTLIT:
<span class="fc" id="L3945">              empty = destructuringObject((ObjectLiteral)left,</span>
                                          variableType, tempName, comma,
                                          destructuringNames);
<span class="fc" id="L3948">              break;</span>
          case Token.GETPROP:
          case Token.GETELEM:
<span class="pc bpc" id="L3951" title="1 of 2 branches missed.">              switch (variableType) {</span>
                  case Token.CONST:
                  case Token.LET:
                  case Token.VAR:
<span class="nc" id="L3955">                      reportError(&quot;msg.bad.assign.left&quot;);</span>
              }
<span class="fc" id="L3957">              comma.addChildToBack(simpleAssignment(left, createName(tempName)));</span>
<span class="fc" id="L3958">              break;</span>
          default:
<span class="nc" id="L3960">              reportError(&quot;msg.bad.assign.left&quot;);</span>
        }
<span class="fc bfc" id="L3962" title="All 2 branches covered.">        if (empty) {</span>
            // Don't want a COMMA node with no children. Just add a zero.
<span class="fc" id="L3964">            comma.addChildToBack(createNumber(0));</span>
        }
<span class="fc" id="L3966">        result.putProp(Node.DESTRUCTURING_NAMES, destructuringNames);</span>
<span class="fc" id="L3967">        return result;</span>
    }

    boolean destructuringArray(ArrayLiteral array,
                               int variableType,
                               String tempName,
                               Node parent,
                               List&lt;String&gt; destructuringNames)
    {
<span class="fc" id="L3976">        boolean empty = true;</span>
<span class="fc bfc" id="L3977" title="All 2 branches covered.">        int setOp = variableType == Token.CONST</span>
            ? Token.SETCONST : Token.SETNAME;
<span class="fc" id="L3979">        int index = 0;</span>
<span class="fc bfc" id="L3980" title="All 2 branches covered.">        for (AstNode n : array.getElements()) {</span>
<span class="fc bfc" id="L3981" title="All 2 branches covered.">            if (n.getType() == Token.EMPTY) {</span>
<span class="fc" id="L3982">                index++;</span>
<span class="fc" id="L3983">                continue;</span>
            }
<span class="fc" id="L3985">            Node rightElem = new Node(Token.GETELEM,</span>
<span class="fc" id="L3986">                                      createName(tempName),</span>
<span class="fc" id="L3987">                                      createNumber(index));</span>
<span class="fc bfc" id="L3988" title="All 2 branches covered.">            if (n.getType() == Token.NAME) {</span>
<span class="fc" id="L3989">                String name = n.getString();</span>
<span class="fc" id="L3990">                parent.addChildToBack(new Node(setOp,</span>
<span class="fc" id="L3991">                                              createName(Token.BINDNAME,</span>
                                                         name, null),
                                              rightElem));
<span class="fc bfc" id="L3994" title="All 2 branches covered.">                if (variableType != -1) {</span>
<span class="fc" id="L3995">                    defineSymbol(variableType, name, true);</span>
<span class="fc" id="L3996">                    destructuringNames.add(name);</span>
                }
<span class="fc" id="L3998">            } else {</span>
<span class="fc" id="L3999">                parent.addChildToBack</span>
<span class="fc" id="L4000">                    (destructuringAssignmentHelper</span>
<span class="fc" id="L4001">                     (variableType, n,</span>
                      rightElem,
<span class="fc" id="L4003">                      currentScriptOrFn.getNextTempName()));</span>
            }
<span class="fc" id="L4005">            index++;</span>
<span class="fc" id="L4006">            empty = false;</span>
<span class="fc" id="L4007">        }</span>
<span class="fc" id="L4008">        return empty;</span>
    }

    boolean destructuringObject(ObjectLiteral node,
                                int variableType,
                                String tempName,
                                Node parent,
                                List&lt;String&gt; destructuringNames)
    {
<span class="fc" id="L4017">        boolean empty = true;</span>
<span class="pc bpc" id="L4018" title="1 of 2 branches missed.">        int setOp = variableType == Token.CONST</span>
            ? Token.SETCONST : Token.SETNAME;

<span class="fc bfc" id="L4021" title="All 2 branches covered.">        for (ObjectProperty prop : node.getElements()) {</span>
<span class="fc" id="L4022">            int lineno = 0;</span>
            // This function is sometimes called from the IRFactory when
            // when executing regression tests, and in those cases the
            // tokenStream isn't set.  Deal with it.
<span class="fc bfc" id="L4026" title="All 2 branches covered.">            if (ts != null) {</span>
<span class="fc" id="L4027">              lineno = ts.lineno;</span>
            }
<span class="fc" id="L4029">            AstNode id = prop.getLeft();</span>
<span class="fc" id="L4030">            Node rightElem = null;</span>
<span class="fc bfc" id="L4031" title="All 2 branches covered.">            if (id instanceof Name) {</span>
<span class="fc" id="L4032">                Node s = Node.newString(((Name)id).getIdentifier());</span>
<span class="fc" id="L4033">                rightElem = new Node(Token.GETPROP, createName(tempName), s);</span>
<span class="pc bpc" id="L4034" title="1 of 2 branches missed.">            } else if (id instanceof StringLiteral) {</span>
<span class="nc" id="L4035">                Node s = Node.newString(((StringLiteral)id).getValue());</span>
<span class="nc" id="L4036">                rightElem = new Node(Token.GETPROP, createName(tempName), s);</span>
<span class="pc bpc" id="L4037" title="1 of 2 branches missed.">            } else if (id instanceof NumberLiteral) {</span>
<span class="fc" id="L4038">                Node s = createNumber((int)((NumberLiteral)id).getNumber());</span>
<span class="fc" id="L4039">                rightElem = new Node(Token.GETELEM, createName(tempName), s);</span>
<span class="fc" id="L4040">            } else {</span>
<span class="nc" id="L4041">                throw codeBug();</span>
            }
<span class="fc" id="L4043">            rightElem.setLineno(lineno);</span>
<span class="fc" id="L4044">            AstNode value = prop.getRight();</span>
<span class="fc bfc" id="L4045" title="All 2 branches covered.">            if (value.getType() == Token.NAME) {</span>
<span class="fc" id="L4046">                String name = ((Name)value).getIdentifier();</span>
<span class="fc" id="L4047">                parent.addChildToBack(new Node(setOp,</span>
<span class="fc" id="L4048">                                              createName(Token.BINDNAME,</span>
                                                         name, null),
                                              rightElem));
<span class="fc bfc" id="L4051" title="All 2 branches covered.">                if (variableType != -1) {</span>
<span class="fc" id="L4052">                    defineSymbol(variableType, name, true);</span>
<span class="fc" id="L4053">                    destructuringNames.add(name);</span>
                }
<span class="fc" id="L4055">            } else {</span>
<span class="fc" id="L4056">                parent.addChildToBack</span>
<span class="fc" id="L4057">                    (destructuringAssignmentHelper</span>
<span class="fc" id="L4058">                     (variableType, value, rightElem,</span>
<span class="fc" id="L4059">                      currentScriptOrFn.getNextTempName()));</span>
            }
<span class="fc" id="L4061">            empty = false;</span>
<span class="fc" id="L4062">        }</span>
<span class="fc" id="L4063">        return empty;</span>
    }

    protected Node createName(String name) {
<span class="fc" id="L4067">        checkActivationName(name, Token.NAME);</span>
<span class="fc" id="L4068">        return Node.newString(Token.NAME, name);</span>
    }

    protected Node createName(int type, String name, Node child) {
<span class="fc" id="L4072">        Node result = createName(name);</span>
<span class="fc" id="L4073">        result.setType(type);</span>
<span class="fc bfc" id="L4074" title="All 2 branches covered.">        if (child != null)</span>
<span class="fc" id="L4075">            result.addChildToBack(child);</span>
<span class="fc" id="L4076">        return result;</span>
    }

    protected Node createNumber(double number) {
<span class="fc" id="L4080">        return Node.newNumber(number);</span>
    }

    /**
     * Create a node that can be used to hold lexically scoped variable
     * definitions (via let declarations).
     *
     * @param token the token of the node to create
     * @param lineno line number of source
     * @return the created node
     */
    protected Scope createScopeNode(int token, int lineno) {
<span class="fc" id="L4092">        Scope scope =new Scope();</span>
<span class="fc" id="L4093">        scope.setType(token);</span>
<span class="fc" id="L4094">        scope.setLineno(lineno);</span>
<span class="fc" id="L4095">        return scope;</span>
    }

    // Quickie tutorial for some of the interpreter bytecodes.
    //
    // GETPROP - for normal foo.bar prop access; right side is a name
    // GETELEM - for normal foo[bar] element access; rhs is an expr
    // SETPROP - for assignment when left side is a GETPROP
    // SETELEM - for assignment when left side is a GETELEM
    // DELPROP - used for delete foo.bar or foo[bar]
    //
    // GET_REF, SET_REF, DEL_REF - in general, these mean you're using
    // get/set/delete on a right-hand side expression (possibly with no
    // explicit left-hand side) that doesn't use the normal JavaScript
    // Object (i.e. ScriptableObject) get/set/delete functions, but wants
    // to provide its own versions instead.  It will ultimately implement
    // Ref, and currently SpecialRef (for __proto__ etc.) and XmlName
    // (for E4X XML objects) are the only implementations.  The runtime
    // notices these bytecodes and delegates get/set/delete to the object.
    //
    // BINDNAME:  used in assignments.  LHS is evaluated first to get a
    // specific object containing the property (&quot;binding&quot; the property
    // to the object) so that it's always the same object, regardless of
    // side effects in the RHS.

    protected Node simpleAssignment(Node left, Node right) {
<span class="fc" id="L4121">        int nodeType = left.getType();</span>
<span class="pc bpc" id="L4122" title="1 of 4 branches missed.">        switch (nodeType) {</span>
          case Token.NAME:
<span class="fc" id="L4124">              String name = ((Name) left).getIdentifier();</span>
<span class="fc bfc" id="L4125" title="All 2 branches covered.">              if (inUseStrictDirective &amp;&amp;</span>
<span class="pc bpc" id="L4126" title="2 of 4 branches missed.">                  (&quot;eval&quot;.equals(name) || &quot;arguments&quot;.equals(name)))</span>
              {
<span class="nc" id="L4128">                  reportError(&quot;msg.bad.id.strict&quot;, name);</span>
              }
<span class="fc" id="L4130">              left.setType(Token.BINDNAME);</span>
<span class="fc" id="L4131">              return new Node(Token.SETNAME, left, right);</span>

          case Token.GETPROP:
          case Token.GETELEM: {
              Node obj, id;
              // If it's a PropertyGet or ElementGet, we're in the parse pass.
              // We could alternately have PropertyGet and ElementGet
              // override getFirstChild/getLastChild and return the appropriate
              // field, but that seems just as ugly as this casting.
<span class="fc bfc" id="L4140" title="All 2 branches covered.">              if (left instanceof PropertyGet) {</span>
<span class="fc" id="L4141">                  obj = ((PropertyGet)left).getTarget();</span>
<span class="fc" id="L4142">                  id = ((PropertyGet)left).getProperty();</span>
<span class="pc bpc" id="L4143" title="1 of 2 branches missed.">              } else if (left instanceof ElementGet) {</span>
<span class="nc" id="L4144">                  obj = ((ElementGet)left).getTarget();</span>
<span class="nc" id="L4145">                  id = ((ElementGet)left).getElement();</span>
              } else {
                  // This branch is called during IRFactory transform pass.
<span class="fc" id="L4148">                  obj = left.getFirstChild();</span>
<span class="fc" id="L4149">                  id = left.getLastChild();</span>
              }
              int type;
<span class="fc bfc" id="L4152" title="All 2 branches covered.">              if (nodeType == Token.GETPROP) {</span>
<span class="fc" id="L4153">                  type = Token.SETPROP;</span>
                  // TODO(stevey) - see https://bugzilla.mozilla.org/show_bug.cgi?id=492036
                  // The new AST code generates NAME tokens for GETPROP ids where the old parser
                  // generated STRING nodes. If we don't set the type to STRING below, this will
                  // cause java.lang.VerifyError in codegen for code like
                  // &quot;var obj={p:3};[obj.p]=[9];&quot;
<span class="fc" id="L4159">                  id.setType(Token.STRING);</span>
              } else {
<span class="fc" id="L4161">                  type = Token.SETELEM;</span>
              }
<span class="fc" id="L4163">              return new Node(type, obj, id, right);</span>
          }
          case Token.GET_REF: {
<span class="fc" id="L4166">              Node ref = left.getFirstChild();</span>
<span class="fc" id="L4167">              checkMutableReference(ref);</span>
<span class="fc" id="L4168">              return new Node(Token.SET_REF, ref, right);</span>
          }
        }

<span class="nc" id="L4172">        throw codeBug();</span>
    }

    protected void checkMutableReference(Node n) {
<span class="fc" id="L4176">        int memberTypeFlags = n.getIntProp(Node.MEMBER_TYPE_PROP, 0);</span>
<span class="fc bfc" id="L4177" title="All 2 branches covered.">        if ((memberTypeFlags &amp; Node.DESCENDANTS_FLAG) != 0) {</span>
<span class="nc" id="L4178">            reportError(&quot;msg.bad.assign.left&quot;);</span>
        }
<span class="fc" id="L4180">    }</span>

    // remove any ParenthesizedExpression wrappers
    protected AstNode removeParens(AstNode node) {
<span class="fc bfc" id="L4184" title="All 2 branches covered.">        while (node instanceof ParenthesizedExpression) {</span>
<span class="fc" id="L4185">            node = ((ParenthesizedExpression)node).getExpression();</span>
        }
<span class="fc" id="L4187">        return node;</span>
    }

    void markDestructuring(AstNode node) {
<span class="fc bfc" id="L4191" title="All 2 branches covered.">        if (node instanceof DestructuringForm) {</span>
<span class="fc" id="L4192">            ((DestructuringForm)node).setIsDestructuring(true);</span>
<span class="fc bfc" id="L4193" title="All 2 branches covered.">        } else if (node instanceof ParenthesizedExpression) {</span>
<span class="fc" id="L4194">            markDestructuring(((ParenthesizedExpression)node).getExpression());</span>
        }
<span class="fc" id="L4196">    }</span>

    // throw a failed-assertion with some helpful debugging info
    private RuntimeException codeBug()
        throws RuntimeException
    {
<span class="nc" id="L4202">        throw Kit.codeBug(&quot;ts.cursor=&quot; + ts.cursor</span>
                          + &quot;, ts.tokenBeg=&quot; + ts.tokenBeg
                          + &quot;, currentToken=&quot; + currentToken);
    }

    public void setDefaultUseStrictDirective(boolean useStrict) {
<span class="fc" id="L4208">        defaultUseStrictDirective = useStrict;</span>
<span class="fc" id="L4209">    }</span>

    public boolean inUseStrictDirective() {
<span class="fc" id="L4212">        return inUseStrictDirective;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>