<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClassFileWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rhino-Rhino1_7_9_Release</a> &gt; <a href="index.source.html" class="el_package">org.mozilla.classfile</a> &gt; <span class="el_source">ClassFileWriter.java</span></div><h1>ClassFileWriter.java</h1><pre class="source lang-java linenums">/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.classfile;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import org.mozilla.javascript.ObjArray;
import org.mozilla.javascript.UintMap;

import java.util.Arrays;

/**
 * ClassFileWriter
 *
 * A ClassFileWriter is used to write a Java class file. Methods are
 * provided to create fields and methods, and within methods to write
 * Java bytecodes.
 *
 * @author Roger Lawrence
 */
public class ClassFileWriter {

    /**
     * Thrown for cases where the error in generating the class file is due to a program size
     * constraints rather than a likely bug in the compiler.
     */
    public static class ClassFileFormatException extends RuntimeException {

        private static final long serialVersionUID = 1263998431033790599L;

        ClassFileFormatException(String message) {
<span class="nc" id="L37">            super(message);</span>
<span class="nc" id="L38">        }</span>
    }

    /**
     * Construct a ClassFileWriter for a class.
     *
     * @param className the name of the class to write, including full package qualification.
     * @param superClassName the name of the superclass of the class to write, including full package
     * qualification.
     * @param sourceFileName the name of the source file to use for producing debug information, or
     * null if debug information is not desired
     */
    public ClassFileWriter(String className, String superClassName,
<span class="fc" id="L51">        String sourceFileName) {</span>
<span class="fc" id="L52">        generatedClassName = className;</span>
<span class="fc" id="L53">        itsConstantPool = new ConstantPool(this);</span>
<span class="fc" id="L54">        itsThisClassIndex = itsConstantPool.addClass(className);</span>
<span class="fc" id="L55">        itsSuperClassIndex = itsConstantPool.addClass(superClassName);</span>
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">        if (sourceFileName != null)</span>
<span class="nc" id="L57">            itsSourceFileNameIndex = itsConstantPool.addUtf8(sourceFileName);</span>
        // All &quot;new&quot; implementations are supposed to output ACC_SUPER as a
        // class flag. This is specified in the first JVM spec, so it should
        // be old enough that it's okay to always set it.
<span class="fc" id="L61">        itsFlags = ACC_PUBLIC | ACC_SUPER;</span>
<span class="fc" id="L62">    }</span>

    public final String getClassName() {
<span class="fc" id="L65">        return generatedClassName;</span>
    }

    /**
     * Add an interface implemented by this class.
     *
     * This method may be called multiple times for classes that implement multiple interfaces.
     *
     * @param interfaceName a name of an interface implemented by the class being written, including
     * full package qualification.
     */
    public void addInterface(String interfaceName) {
<span class="fc" id="L77">        short interfaceIndex = itsConstantPool.addClass(interfaceName);</span>
<span class="fc" id="L78">        itsInterfaces.add(Short.valueOf(interfaceIndex));</span>
<span class="fc" id="L79">    }</span>

    public static final short
        ACC_PUBLIC = 0x0001,
        ACC_PRIVATE = 0x0002,
        ACC_PROTECTED = 0x0004,
        ACC_STATIC = 0x0008,
        ACC_FINAL = 0x0010,
        ACC_SUPER = 0x0020,
        ACC_SYNCHRONIZED = 0x0020,
        ACC_VOLATILE = 0x0040,
        ACC_TRANSIENT = 0x0080,
        ACC_NATIVE = 0x0100,
        ACC_ABSTRACT = 0x0400;

    /**
     * Set the class's flags.
     *
     * Flags must be a set of the following flags, bitwise or'd together: ACC_PUBLIC ACC_PRIVATE
     * ACC_PROTECTED ACC_FINAL ACC_ABSTRACT TODO: check that this is the appropriate set
     *
     * @param flags the set of class flags to set
     */
    public void setFlags(short flags) {
<span class="nc" id="L103">        itsFlags = flags;</span>
<span class="nc" id="L104">    }</span>

    static String getSlashedForm(String name) {
<span class="fc" id="L107">        return name.replace('.', '/');</span>
    }

    /**
     * Convert Java class name in dot notation into &quot;Lname-with-dots-replaced-by-slashes;&quot; form
     * suitable for use as JVM type signatures.
     */
    public static String classNameToSignature(String name) {
<span class="fc" id="L115">        int nameLength = name.length();</span>
<span class="fc" id="L116">        int colonPos = 1 + nameLength;</span>
<span class="fc" id="L117">        char[] buf = new char[colonPos + 1];</span>
<span class="fc" id="L118">        buf[0] = 'L';</span>
<span class="fc" id="L119">        buf[colonPos] = ';';</span>
<span class="fc" id="L120">        name.getChars(0, nameLength, buf, 1);</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">        for (int i = 1; i != colonPos; ++i) {</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">            if (buf[i] == '.') {</span>
<span class="fc" id="L123">                buf[i] = '/';</span>
            }
        }
<span class="fc" id="L126">        return new String(buf, 0, colonPos + 1);</span>
    }

    /**
     * Add a field to the class.
     *
     * @param fieldName the name of the field
     * @param type the type of the field using ...
     * @param flags the attributes of the field, such as ACC_PUBLIC, etc. bitwise or'd together
     */
    public void addField(String fieldName, String type, short flags) {
<span class="fc" id="L137">        short fieldNameIndex = itsConstantPool.addUtf8(fieldName);</span>
<span class="fc" id="L138">        short typeIndex = itsConstantPool.addUtf8(type);</span>
<span class="fc" id="L139">        itsFields.add(new ClassFileField(fieldNameIndex, typeIndex, flags));</span>
<span class="fc" id="L140">    }</span>

    /**
     * Add a field to the class.
     *
     * @param fieldName the name of the field
     * @param type the type of the field using ...
     * @param flags the attributes of the field, such as ACC_PUBLIC, etc. bitwise or'd together
     * @param value an initial integral value
     */
    public void addField(String fieldName, String type, short flags,
        int value) {
<span class="nc" id="L152">        short fieldNameIndex = itsConstantPool.addUtf8(fieldName);</span>
<span class="nc" id="L153">        short typeIndex = itsConstantPool.addUtf8(type);</span>
<span class="nc" id="L154">        ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex,</span>
            flags);
<span class="nc" id="L156">        field.setAttributes(itsConstantPool.addUtf8(&quot;ConstantValue&quot;),</span>
            (short) 0,
            (short) 0,
<span class="nc" id="L159">            itsConstantPool.addConstant(value));</span>
<span class="nc" id="L160">        itsFields.add(field);</span>
<span class="nc" id="L161">    }</span>

    /**
     * Add a field to the class.
     *
     * @param fieldName the name of the field
     * @param type the type of the field using ...
     * @param flags the attributes of the field, such as ACC_PUBLIC, etc. bitwise or'd together
     * @param value an initial long value
     */
    public void addField(String fieldName, String type, short flags,
        long value) {
<span class="nc" id="L173">        short fieldNameIndex = itsConstantPool.addUtf8(fieldName);</span>
<span class="nc" id="L174">        short typeIndex = itsConstantPool.addUtf8(type);</span>
<span class="nc" id="L175">        ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex,</span>
            flags);
<span class="nc" id="L177">        field.setAttributes(itsConstantPool.addUtf8(&quot;ConstantValue&quot;),</span>
            (short) 0,
            (short) 2,
<span class="nc" id="L180">            itsConstantPool.addConstant(value));</span>
<span class="nc" id="L181">        itsFields.add(field);</span>
<span class="nc" id="L182">    }</span>

    /**
     * Add a field to the class.
     *
     * @param fieldName the name of the field
     * @param type the type of the field using ...
     * @param flags the attributes of the field, such as ACC_PUBLIC, etc. bitwise or'd together
     * @param value an initial double value
     */
    public void addField(String fieldName, String type, short flags,
        double value) {
<span class="nc" id="L194">        short fieldNameIndex = itsConstantPool.addUtf8(fieldName);</span>
<span class="nc" id="L195">        short typeIndex = itsConstantPool.addUtf8(type);</span>
<span class="nc" id="L196">        ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex,</span>
            flags);
<span class="nc" id="L198">        field.setAttributes(itsConstantPool.addUtf8(&quot;ConstantValue&quot;),</span>
            (short) 0,
            (short) 2,
<span class="nc" id="L201">            itsConstantPool.addConstant(value));</span>
<span class="nc" id="L202">        itsFields.add(field);</span>
<span class="nc" id="L203">    }</span>

    /**
     * Add Information about java variable to use when generating the local variable table.
     *
     * @param name variable name.
     * @param type variable type as bytecode descriptor string.
     * @param startPC the starting bytecode PC where this variable is live, or -1 if it does not have
     * a Java register.
     * @param register the Java register number of variable or -1 if it does not have a Java
     * register.
     */
    public void addVariableDescriptor(String name, String type, int startPC, int register) {
<span class="nc" id="L216">        int nameIndex = itsConstantPool.addUtf8(name);</span>
<span class="nc" id="L217">        int descriptorIndex = itsConstantPool.addUtf8(type);</span>
<span class="nc" id="L218">        int[] chunk = {nameIndex, descriptorIndex, startPC, register};</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">        if (itsVarDescriptors == null) {</span>
<span class="nc" id="L220">            itsVarDescriptors = new ObjArray();</span>
        }
<span class="nc" id="L222">        itsVarDescriptors.add(chunk);</span>
<span class="nc" id="L223">    }</span>

    /**
     * Add a method and begin adding code.
     *
     * This method must be called before other methods for adding code, exception tables, etc. can be
     * invoked.
     *
     * @param methodName the name of the method
     * @param type a string representing the type
     * @param flags the attributes of the field, such as ACC_PUBLIC, etc. bitwise or'd together
     */
    public void startMethod(String methodName, String type, short flags) {
<span class="fc" id="L236">        short methodNameIndex = itsConstantPool.addUtf8(methodName);</span>
<span class="fc" id="L237">        short typeIndex = itsConstantPool.addUtf8(type);</span>
<span class="fc" id="L238">        itsCurrentMethod = new ClassFileMethod(methodName, methodNameIndex,</span>
            type, typeIndex, flags);
<span class="fc" id="L240">        itsJumpFroms = new UintMap();</span>
<span class="fc" id="L241">        itsMethods.add(itsCurrentMethod);</span>
<span class="fc" id="L242">        addSuperBlockStart(0);</span>
<span class="fc" id="L243">    }</span>

    /**
     * Complete generation of the method.
     *
     * After this method is called, no more code can be added to the method begun with
     * &lt;code&gt;startMethod&lt;/code&gt;.
     *
     * @param maxLocals the maximum number of local variable slots (a.k.a. Java registers) used by the
     * method
     */
    public void stopMethod(short maxLocals) {
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        if (itsCurrentMethod == null)</span>
<span class="nc" id="L256">            throw new IllegalStateException(&quot;No method to stop&quot;);</span>

<span class="fc" id="L258">        fixLabelGotos();</span>

<span class="fc" id="L260">        itsMaxLocals = maxLocals;</span>

<span class="fc" id="L262">        StackMapTable stackMap = null;</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (GenerateStackMap) {</span>
<span class="fc" id="L264">            finalizeSuperBlockStarts();</span>
<span class="fc" id="L265">            stackMap = new StackMapTable();</span>
<span class="fc" id="L266">            stackMap.generate();</span>
        }

<span class="fc" id="L269">        int lineNumberTableLength = 0;</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">        if (itsLineNumberTable != null) {</span>
            // 6 bytes for the attribute header
            // 2 bytes for the line number count
            // 4 bytes for each entry
<span class="fc" id="L274">            lineNumberTableLength = 6 + 2 + (itsLineNumberTableTop * 4);</span>
        }

<span class="fc" id="L277">        int variableTableLength = 0;</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (itsVarDescriptors != null) {</span>
            // 6 bytes for the attribute header
            // 2 bytes for the variable count
            // 10 bytes for each entry
<span class="nc" id="L282">            variableTableLength = 6 + 2 + (itsVarDescriptors.size() * 10);</span>
        }

<span class="fc" id="L285">        int stackMapTableLength = 0;</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">        if (stackMap != null) {</span>
<span class="fc" id="L287">            int stackMapWriteSize = stackMap.computeWriteSize();</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">            if (stackMapWriteSize &gt; 0) {</span>
<span class="fc" id="L289">                stackMapTableLength = 6 + stackMapWriteSize;</span>
            }
        }

<span class="fc" id="L293">        int attrLength = 2 +                    // attribute_name_index</span>
            4 +                    // attribute_length
            2 +                    // max_stack
            2 +                    // max_locals
            4 +                    // code_length
            itsCodeBufferTop +
            2 +                    // exception_table_length
            (itsExceptionTableTop * 8) +
            2 +                    // attributes_count
            lineNumberTableLength +
            variableTableLength +
            stackMapTableLength;

<span class="pc bpc" id="L306" title="1 of 2 branches missed.">        if (attrLength &gt; 65536) {</span>
            // See http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html,
            // section 4.10, &quot;The amount of code per non-native, non-abstract
            // method is limited to 65536 bytes...
<span class="nc" id="L310">            throw new ClassFileFormatException(</span>
                &quot;generated bytecode for method exceeds 64K limit.&quot;);
        }
<span class="fc" id="L313">        byte[] codeAttribute = new byte[attrLength];</span>
<span class="fc" id="L314">        int index = 0;</span>
<span class="fc" id="L315">        int codeAttrIndex = itsConstantPool.addUtf8(&quot;Code&quot;);</span>
<span class="fc" id="L316">        index = putInt16(codeAttrIndex, codeAttribute, index);</span>
<span class="fc" id="L317">        attrLength -= 6;                 // discount the attribute header</span>
<span class="fc" id="L318">        index = putInt32(attrLength, codeAttribute, index);</span>
<span class="fc" id="L319">        index = putInt16(itsMaxStack, codeAttribute, index);</span>
<span class="fc" id="L320">        index = putInt16(itsMaxLocals, codeAttribute, index);</span>
<span class="fc" id="L321">        index = putInt32(itsCodeBufferTop, codeAttribute, index);</span>
<span class="fc" id="L322">        System.arraycopy(itsCodeBuffer, 0, codeAttribute, index,</span>
            itsCodeBufferTop);
<span class="fc" id="L324">        index += itsCodeBufferTop;</span>

<span class="fc bfc" id="L326" title="All 2 branches covered.">        if (itsExceptionTableTop &gt; 0) {</span>
<span class="fc" id="L327">            index = putInt16(itsExceptionTableTop, codeAttribute, index);</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">            for (int i = 0; i &lt; itsExceptionTableTop; i++) {</span>
<span class="fc" id="L329">                ExceptionTableEntry ete = itsExceptionTable[i];</span>
<span class="fc" id="L330">                short startPC = (short) getLabelPC(ete.itsStartLabel);</span>
<span class="fc" id="L331">                short endPC = (short) getLabelPC(ete.itsEndLabel);</span>
<span class="fc" id="L332">                short handlerPC = (short) getLabelPC(ete.itsHandlerLabel);</span>
<span class="fc" id="L333">                short catchType = ete.itsCatchType;</span>
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">                if (startPC == -1)</span>
<span class="nc" id="L335">                    throw new IllegalStateException(&quot;start label not defined&quot;);</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">                if (endPC == -1)</span>
<span class="nc" id="L337">                    throw new IllegalStateException(&quot;end label not defined&quot;);</span>
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">                if (handlerPC == -1)</span>
<span class="nc" id="L339">                    throw new IllegalStateException(</span>
                        &quot;handler label not defined&quot;);

<span class="fc" id="L342">                index = putInt16(startPC, codeAttribute, index);</span>
<span class="fc" id="L343">                index = putInt16(endPC, codeAttribute, index);</span>
<span class="fc" id="L344">                index = putInt16(handlerPC, codeAttribute, index);</span>
<span class="fc" id="L345">                index = putInt16(catchType, codeAttribute, index);</span>
            }
        } else {
            // write 0 as exception table length
<span class="fc" id="L349">            index = putInt16(0, codeAttribute, index);</span>
        }

<span class="fc" id="L352">        int attributeCount = 0;</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">        if (itsLineNumberTable != null)</span>
<span class="fc" id="L354">            attributeCount++;</span>
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">        if (itsVarDescriptors != null)</span>
<span class="nc" id="L356">            attributeCount++;</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">        if (stackMapTableLength &gt; 0) {</span>
<span class="fc" id="L358">            attributeCount++;</span>
        }
<span class="fc" id="L360">        index = putInt16(attributeCount, codeAttribute, index);</span>

<span class="fc bfc" id="L362" title="All 2 branches covered.">        if (itsLineNumberTable != null) {</span>
<span class="fc" id="L363">            int lineNumberTableAttrIndex</span>
<span class="fc" id="L364">                = itsConstantPool.addUtf8(&quot;LineNumberTable&quot;);</span>
<span class="fc" id="L365">            index = putInt16(lineNumberTableAttrIndex, codeAttribute, index);</span>
<span class="fc" id="L366">            int tableAttrLength = 2 + (itsLineNumberTableTop * 4);</span>
<span class="fc" id="L367">            index = putInt32(tableAttrLength, codeAttribute, index);</span>
<span class="fc" id="L368">            index = putInt16(itsLineNumberTableTop, codeAttribute, index);</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">            for (int i = 0; i &lt; itsLineNumberTableTop; i++) {</span>
<span class="fc" id="L370">                index = putInt32(itsLineNumberTable[i], codeAttribute, index);</span>
            }
        }

<span class="pc bpc" id="L374" title="1 of 2 branches missed.">        if (itsVarDescriptors != null) {</span>
<span class="nc" id="L375">            int variableTableAttrIndex</span>
<span class="nc" id="L376">                = itsConstantPool.addUtf8(&quot;LocalVariableTable&quot;);</span>
<span class="nc" id="L377">            index = putInt16(variableTableAttrIndex, codeAttribute, index);</span>
<span class="nc" id="L378">            int varCount = itsVarDescriptors.size();</span>
<span class="nc" id="L379">            int tableAttrLength = 2 + (varCount * 10);</span>
<span class="nc" id="L380">            index = putInt32(tableAttrLength, codeAttribute, index);</span>
<span class="nc" id="L381">            index = putInt16(varCount, codeAttribute, index);</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">            for (int i = 0; i &lt; varCount; i++) {</span>
<span class="nc" id="L383">                int[] chunk = (int[]) itsVarDescriptors.get(i);</span>
<span class="nc" id="L384">                int nameIndex = chunk[0];</span>
<span class="nc" id="L385">                int descriptorIndex = chunk[1];</span>
<span class="nc" id="L386">                int startPC = chunk[2];</span>
<span class="nc" id="L387">                int register = chunk[3];</span>
<span class="nc" id="L388">                int length = itsCodeBufferTop - startPC;</span>

<span class="nc" id="L390">                index = putInt16(startPC, codeAttribute, index);</span>
<span class="nc" id="L391">                index = putInt16(length, codeAttribute, index);</span>
<span class="nc" id="L392">                index = putInt16(nameIndex, codeAttribute, index);</span>
<span class="nc" id="L393">                index = putInt16(descriptorIndex, codeAttribute, index);</span>
<span class="nc" id="L394">                index = putInt16(register, codeAttribute, index);</span>
            }
        }

<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        if (stackMapTableLength &gt; 0) {</span>
<span class="fc" id="L399">            int stackMapTableAttrIndex =</span>
<span class="fc" id="L400">                itsConstantPool.addUtf8(&quot;StackMapTable&quot;);</span>
<span class="fc" id="L401">            int start = index;</span>
<span class="fc" id="L402">            index = putInt16(stackMapTableAttrIndex, codeAttribute, index);</span>
<span class="fc" id="L403">            index = stackMap.write(codeAttribute, index);</span>
        }

<span class="fc" id="L406">        itsCurrentMethod.setCodeAttribute(codeAttribute);</span>

<span class="fc" id="L408">        itsExceptionTable = null;</span>
<span class="fc" id="L409">        itsExceptionTableTop = 0;</span>
<span class="fc" id="L410">        itsLineNumberTableTop = 0;</span>
<span class="fc" id="L411">        itsCodeBufferTop = 0;</span>
<span class="fc" id="L412">        itsCurrentMethod = null;</span>
<span class="fc" id="L413">        itsMaxStack = 0;</span>
<span class="fc" id="L414">        itsStackTop = 0;</span>
<span class="fc" id="L415">        itsLabelTableTop = 0;</span>
<span class="fc" id="L416">        itsFixupTableTop = 0;</span>
<span class="fc" id="L417">        itsVarDescriptors = null;</span>
<span class="fc" id="L418">        itsSuperBlockStarts = null;</span>
<span class="fc" id="L419">        itsSuperBlockStartsTop = 0;</span>
<span class="fc" id="L420">        itsJumpFroms = null;</span>
<span class="fc" id="L421">    }</span>

    /**
     * Add the single-byte opcode to the current method.
     *
     * @param theOpCode the opcode of the bytecode
     */
    public void add(int theOpCode) {
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">        if (opcodeCount(theOpCode) != 0)</span>
<span class="nc" id="L430">            throw new IllegalArgumentException(&quot;Unexpected operands&quot;);</span>
<span class="fc" id="L431">        int newStack = itsStackTop + stackChange(theOpCode);</span>
<span class="pc bpc" id="L432" title="2 of 4 branches missed.">        if (newStack &lt; 0 || Short.MAX_VALUE &lt; newStack)</span>
<span class="nc" id="L433">            badStack(newStack);</span>
        if (DEBUGCODE)
            System.out.println(&quot;Add &quot; + bytecodeStr(theOpCode));
<span class="fc" id="L436">        addToCodeBuffer(theOpCode);</span>
<span class="fc" id="L437">        itsStackTop = (short) newStack;</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">        if (newStack &gt; itsMaxStack)</span>
<span class="fc" id="L439">            itsMaxStack = (short) newStack;</span>
        if (DEBUGSTACK) {
            System.out.println(&quot;After &quot; + bytecodeStr(theOpCode)
                + &quot; stack = &quot; + itsStackTop);
        }
<span class="fc bfc" id="L444" title="All 2 branches covered.">        if (theOpCode == ByteCode.ATHROW) {</span>
<span class="fc" id="L445">            addSuperBlockStart(itsCodeBufferTop);</span>
        }
<span class="fc" id="L447">    }</span>

    /**
     * Add a single-operand opcode to the current method.
     *
     * @param theOpCode the opcode of the bytecode
     * @param theOperand the operand of the bytecode
     */
    public void add(int theOpCode, int theOperand) {
        if (DEBUGCODE) {
            System.out.println(&quot;Add &quot; + bytecodeStr(theOpCode)
                + &quot;, &quot; + Integer.toHexString(theOperand));
        }
<span class="fc" id="L460">        int newStack = itsStackTop + stackChange(theOpCode);</span>
<span class="pc bpc" id="L461" title="2 of 4 branches missed.">        if (newStack &lt; 0 || Short.MAX_VALUE &lt; newStack)</span>
<span class="nc" id="L462">            badStack(newStack);</span>

<span class="pc bpc" id="L464" title="3 of 9 branches missed.">        switch (theOpCode) {</span>
            case ByteCode.GOTO:
                // This is necessary because dead code is seemingly being
                // generated and Sun's verifier is expecting type state to be
                // placed even at dead blocks of code.
<span class="fc" id="L469">                addSuperBlockStart(itsCodeBufferTop + 3);</span>
                // fallthru...
            case ByteCode.IFEQ:
            case ByteCode.IFNE:
            case ByteCode.IFLT:
            case ByteCode.IFGE:
            case ByteCode.IFGT:
            case ByteCode.IFLE:
            case ByteCode.IF_ICMPEQ:
            case ByteCode.IF_ICMPNE:
            case ByteCode.IF_ICMPLT:
            case ByteCode.IF_ICMPGE:
            case ByteCode.IF_ICMPGT:
            case ByteCode.IF_ICMPLE:
            case ByteCode.IF_ACMPEQ:
            case ByteCode.IF_ACMPNE:
            case ByteCode.JSR:
            case ByteCode.IFNULL:
            case ByteCode.IFNONNULL: {
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">                if ((theOperand &amp; 0x80000000) != 0x80000000) {</span>
<span class="nc bnc" id="L489" title="All 4 branches missed.">                    if ((theOperand &lt; 0) || (theOperand &gt; 65535))</span>
<span class="nc" id="L490">                        throw new IllegalArgumentException(</span>
                            &quot;Bad label for branch&quot;);
                }
<span class="fc" id="L493">                int branchPC = itsCodeBufferTop;</span>
<span class="fc" id="L494">                addToCodeBuffer(theOpCode);</span>
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">                if ((theOperand &amp; 0x80000000) != 0x80000000) {</span>
                    // hard displacement
<span class="nc" id="L497">                    addToCodeInt16(theOperand);</span>
<span class="nc" id="L498">                    int target = theOperand + branchPC;</span>
<span class="nc" id="L499">                    addSuperBlockStart(target);</span>
<span class="nc" id="L500">                    itsJumpFroms.put(target, branchPC);</span>
<span class="nc" id="L501">                } else {  // a label</span>
<span class="fc" id="L502">                    int targetPC = getLabelPC(theOperand);</span>
                    if (DEBUGLABELS) {
                        int theLabel = theOperand &amp; 0x7FFFFFFF;
                        System.out.println(&quot;Fixing branch to &quot; +
                            theLabel + &quot; at &quot; + targetPC +
                            &quot; from &quot; + branchPC);
                    }
<span class="fc bfc" id="L509" title="All 2 branches covered.">                    if (targetPC != -1) {</span>
<span class="fc" id="L510">                        int offset = targetPC - branchPC;</span>
<span class="fc" id="L511">                        addToCodeInt16(offset);</span>
<span class="fc" id="L512">                        addSuperBlockStart(targetPC);</span>
<span class="fc" id="L513">                        itsJumpFroms.put(targetPC, branchPC);</span>
<span class="fc" id="L514">                    } else {</span>
<span class="fc" id="L515">                        addLabelFixup(theOperand, branchPC + 1);</span>
<span class="fc" id="L516">                        addToCodeInt16(0);</span>
                    }
                }
            }
<span class="fc" id="L520">            break;</span>

            case ByteCode.BIPUSH:
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">                if ((byte) theOperand != theOperand)</span>
<span class="nc" id="L524">                    throw new IllegalArgumentException(&quot;out of range byte&quot;);</span>
<span class="fc" id="L525">                addToCodeBuffer(theOpCode);</span>
<span class="fc" id="L526">                addToCodeBuffer((byte) theOperand);</span>
<span class="fc" id="L527">                break;</span>

            case ByteCode.SIPUSH:
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">                if ((short) theOperand != theOperand)</span>
<span class="nc" id="L531">                    throw new IllegalArgumentException(&quot;out of range short&quot;);</span>
<span class="fc" id="L532">                addToCodeBuffer(theOpCode);</span>
<span class="fc" id="L533">                addToCodeInt16(theOperand);</span>
<span class="fc" id="L534">                break;</span>

            case ByteCode.NEWARRAY:
<span class="nc bnc" id="L537" title="All 4 branches missed.">                if (!(0 &lt;= theOperand &amp;&amp; theOperand &lt; 256))</span>
<span class="nc" id="L538">                    throw new IllegalArgumentException(&quot;out of range index&quot;);</span>
<span class="nc" id="L539">                addToCodeBuffer(theOpCode);</span>
<span class="nc" id="L540">                addToCodeBuffer(theOperand);</span>
<span class="nc" id="L541">                break;</span>

            case ByteCode.GETFIELD:
            case ByteCode.PUTFIELD:
<span class="nc bnc" id="L545" title="All 4 branches missed.">                if (!(0 &lt;= theOperand &amp;&amp; theOperand &lt; 65536))</span>
<span class="nc" id="L546">                    throw new IllegalArgumentException(&quot;out of range field&quot;);</span>
<span class="nc" id="L547">                addToCodeBuffer(theOpCode);</span>
<span class="nc" id="L548">                addToCodeInt16(theOperand);</span>
<span class="nc" id="L549">                break;</span>

            case ByteCode.LDC:
            case ByteCode.LDC_W:
            case ByteCode.LDC2_W:
<span class="pc bpc" id="L554" title="2 of 4 branches missed.">                if (!(0 &lt;= theOperand &amp;&amp; theOperand &lt; 65536))</span>
<span class="nc" id="L555">                    throw new IllegalArgumentException(&quot;out of range index&quot;);</span>
<span class="pc bpc" id="L556" title="2 of 6 branches missed.">                if (theOperand &gt;= 256</span>
                    || theOpCode == ByteCode.LDC_W
                    || theOpCode == ByteCode.LDC2_W) {
<span class="fc bfc" id="L559" title="All 2 branches covered.">                    if (theOpCode == ByteCode.LDC) {</span>
<span class="fc" id="L560">                        addToCodeBuffer(ByteCode.LDC_W);</span>
                    } else {
<span class="fc" id="L562">                        addToCodeBuffer(theOpCode);</span>
                    }
<span class="fc" id="L564">                    addToCodeInt16(theOperand);</span>
                } else {
<span class="fc" id="L566">                    addToCodeBuffer(theOpCode);</span>
<span class="fc" id="L567">                    addToCodeBuffer(theOperand);</span>
                }
<span class="fc" id="L569">                break;</span>

            case ByteCode.RET:
            case ByteCode.ILOAD:
            case ByteCode.LLOAD:
            case ByteCode.FLOAD:
            case ByteCode.DLOAD:
            case ByteCode.ALOAD:
            case ByteCode.ISTORE:
            case ByteCode.LSTORE:
            case ByteCode.FSTORE:
            case ByteCode.DSTORE:
            case ByteCode.ASTORE:
<span class="pc bpc" id="L582" title="2 of 4 branches missed.">                if (!(0 &lt;= theOperand &amp;&amp; theOperand &lt; 65536))</span>
<span class="nc" id="L583">                    throw new ClassFileFormatException(&quot;out of range variable&quot;);</span>
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">                if (theOperand &gt;= 256) {</span>
<span class="nc" id="L585">                    addToCodeBuffer(ByteCode.WIDE);</span>
<span class="nc" id="L586">                    addToCodeBuffer(theOpCode);</span>
<span class="nc" id="L587">                    addToCodeInt16(theOperand);</span>
                } else {
<span class="fc" id="L589">                    addToCodeBuffer(theOpCode);</span>
<span class="fc" id="L590">                    addToCodeBuffer(theOperand);</span>
                }
<span class="fc" id="L592">                break;</span>

            default:
<span class="nc" id="L595">                throw new IllegalArgumentException(</span>
                    &quot;Unexpected opcode for 1 operand&quot;);
        }

<span class="fc" id="L599">        itsStackTop = (short) newStack;</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">        if (newStack &gt; itsMaxStack)</span>
<span class="fc" id="L601">            itsMaxStack = (short) newStack;</span>
        if (DEBUGSTACK) {
            System.out.println(&quot;After &quot; + bytecodeStr(theOpCode)
                + &quot; stack = &quot; + itsStackTop);
        }
<span class="fc" id="L606">    }</span>

    /**
     * Generate the load constant bytecode for the given integer.
     *
     * @param k the constant
     */
    public void addLoadConstant(int k) {
<span class="pc bpc" id="L614" title="6 of 7 branches missed.">        switch (k) {</span>
            case 0:
<span class="nc" id="L616">                add(ByteCode.ICONST_0);</span>
<span class="nc" id="L617">                break;</span>
            case 1:
<span class="nc" id="L619">                add(ByteCode.ICONST_1);</span>
<span class="nc" id="L620">                break;</span>
            case 2:
<span class="nc" id="L622">                add(ByteCode.ICONST_2);</span>
<span class="nc" id="L623">                break;</span>
            case 3:
<span class="nc" id="L625">                add(ByteCode.ICONST_3);</span>
<span class="nc" id="L626">                break;</span>
            case 4:
<span class="nc" id="L628">                add(ByteCode.ICONST_4);</span>
<span class="nc" id="L629">                break;</span>
            case 5:
<span class="nc" id="L631">                add(ByteCode.ICONST_5);</span>
<span class="nc" id="L632">                break;</span>
            default:
<span class="fc" id="L634">                add(ByteCode.LDC, itsConstantPool.addConstant(k));</span>
                break;
        }
<span class="fc" id="L637">    }</span>

    /**
     * Generate the load constant bytecode for the given long.
     *
     * @param k the constant
     */
    public void addLoadConstant(long k) {
<span class="nc" id="L645">        add(ByteCode.LDC2_W, itsConstantPool.addConstant(k));</span>
<span class="nc" id="L646">    }</span>

    /**
     * Generate the load constant bytecode for the given float.
     *
     * @param k the constant
     */
    public void addLoadConstant(float k) {
<span class="nc" id="L654">        add(ByteCode.LDC, itsConstantPool.addConstant(k));</span>
<span class="nc" id="L655">    }</span>

    /**
     * Generate the load constant bytecode for the given double.
     *
     * @param k the constant
     */
    public void addLoadConstant(double k) {
<span class="fc" id="L663">        add(ByteCode.LDC2_W, itsConstantPool.addConstant(k));</span>
<span class="fc" id="L664">    }</span>

    /**
     * Generate the load constant bytecode for the given string.
     *
     * @param k the constant
     */
    public void addLoadConstant(String k) {
<span class="fc" id="L672">        add(ByteCode.LDC, itsConstantPool.addConstant(k));</span>
<span class="fc" id="L673">    }</span>

    /**
     * Add the given two-operand bytecode to the current method.
     *
     * @param theOpCode the opcode of the bytecode
     * @param theOperand1 the first operand of the bytecode
     * @param theOperand2 the second operand of the bytecode
     */
    public void add(int theOpCode, int theOperand1, int theOperand2) {
        if (DEBUGCODE) {
            System.out.println(&quot;Add &quot; + bytecodeStr(theOpCode)
                + &quot;, &quot; + Integer.toHexString(theOperand1)
                + &quot;, &quot; + Integer.toHexString(theOperand2));
        }
<span class="nc" id="L688">        int newStack = itsStackTop + stackChange(theOpCode);</span>
<span class="nc bnc" id="L689" title="All 4 branches missed.">        if (newStack &lt; 0 || Short.MAX_VALUE &lt; newStack)</span>
<span class="nc" id="L690">            badStack(newStack);</span>

<span class="nc bnc" id="L692" title="All 2 branches missed.">        if (theOpCode == ByteCode.IINC) {</span>
<span class="nc bnc" id="L693" title="All 4 branches missed.">            if (!(0 &lt;= theOperand1 &amp;&amp; theOperand1 &lt; 65536))</span>
<span class="nc" id="L694">                throw new ClassFileFormatException(&quot;out of range variable&quot;);</span>
<span class="nc bnc" id="L695" title="All 4 branches missed.">            if (!(0 &lt;= theOperand2 &amp;&amp; theOperand2 &lt; 65536))</span>
<span class="nc" id="L696">                throw new ClassFileFormatException(&quot;out of range increment&quot;);</span>

<span class="nc bnc" id="L698" title="All 6 branches missed.">            if (theOperand1 &gt; 255 || theOperand2 &lt; -128 || theOperand2 &gt; 127) {</span>
<span class="nc" id="L699">                addToCodeBuffer(ByteCode.WIDE);</span>
<span class="nc" id="L700">                addToCodeBuffer(ByteCode.IINC);</span>
<span class="nc" id="L701">                addToCodeInt16(theOperand1);</span>
<span class="nc" id="L702">                addToCodeInt16(theOperand2);</span>
            } else {
<span class="nc" id="L704">                addToCodeBuffer(ByteCode.IINC);</span>
<span class="nc" id="L705">                addToCodeBuffer(theOperand1);</span>
<span class="nc" id="L706">                addToCodeBuffer(theOperand2);</span>
            }
<span class="nc bnc" id="L708" title="All 2 branches missed.">        } else if (theOpCode == ByteCode.MULTIANEWARRAY) {</span>
<span class="nc bnc" id="L709" title="All 4 branches missed.">            if (!(0 &lt;= theOperand1 &amp;&amp; theOperand1 &lt; 65536))</span>
<span class="nc" id="L710">                throw new IllegalArgumentException(&quot;out of range index&quot;);</span>
<span class="nc bnc" id="L711" title="All 4 branches missed.">            if (!(0 &lt;= theOperand2 &amp;&amp; theOperand2 &lt; 256))</span>
<span class="nc" id="L712">                throw new IllegalArgumentException(&quot;out of range dimensions&quot;);</span>

<span class="nc" id="L714">            addToCodeBuffer(ByteCode.MULTIANEWARRAY);</span>
<span class="nc" id="L715">            addToCodeInt16(theOperand1);</span>
<span class="nc" id="L716">            addToCodeBuffer(theOperand2);</span>
        } else {
<span class="nc" id="L718">            throw new IllegalArgumentException(</span>
                &quot;Unexpected opcode for 2 operands&quot;);
        }
<span class="nc" id="L721">        itsStackTop = (short) newStack;</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">        if (newStack &gt; itsMaxStack)</span>
<span class="nc" id="L723">            itsMaxStack = (short) newStack;</span>
        if (DEBUGSTACK) {
            System.out.println(&quot;After &quot; + bytecodeStr(theOpCode)
                + &quot; stack = &quot; + itsStackTop);
        }

<span class="nc" id="L729">    }</span>

    public void add(int theOpCode, String className) {
        if (DEBUGCODE) {
            System.out.println(&quot;Add &quot; + bytecodeStr(theOpCode)
                + &quot;, &quot; + className);
        }
<span class="fc" id="L736">        int newStack = itsStackTop + stackChange(theOpCode);</span>
<span class="pc bpc" id="L737" title="2 of 4 branches missed.">        if (newStack &lt; 0 || Short.MAX_VALUE &lt; newStack)</span>
<span class="nc" id="L738">            badStack(newStack);</span>
<span class="pc bpc" id="L739" title="1 of 2 branches missed.">        switch (theOpCode) {</span>
            case ByteCode.NEW:
            case ByteCode.ANEWARRAY:
            case ByteCode.CHECKCAST:
            case ByteCode.INSTANCEOF: {
<span class="fc" id="L744">                short classIndex = itsConstantPool.addClass(className);</span>
<span class="fc" id="L745">                addToCodeBuffer(theOpCode);</span>
<span class="fc" id="L746">                addToCodeInt16(classIndex);</span>
            }
<span class="fc" id="L748">            break;</span>

            default:
<span class="nc" id="L751">                throw new IllegalArgumentException(</span>
                    &quot;bad opcode for class reference&quot;);
        }
<span class="fc" id="L754">        itsStackTop = (short) newStack;</span>
<span class="fc bfc" id="L755" title="All 2 branches covered.">        if (newStack &gt; itsMaxStack)</span>
<span class="fc" id="L756">            itsMaxStack = (short) newStack;</span>
        if (DEBUGSTACK) {
            System.out.println(&quot;After &quot; + bytecodeStr(theOpCode)
                + &quot; stack = &quot; + itsStackTop);
        }
<span class="fc" id="L761">    }</span>


    public void add(int theOpCode, String className, String fieldName,
        String fieldType) {
        if (DEBUGCODE) {
            System.out.println(&quot;Add &quot; + bytecodeStr(theOpCode)
                + &quot;, &quot; + className + &quot;, &quot; + fieldName + &quot;, &quot; + fieldType);
        }
<span class="fc" id="L770">        int newStack = itsStackTop + stackChange(theOpCode);</span>
<span class="fc" id="L771">        char fieldTypeChar = fieldType.charAt(0);</span>
<span class="pc bpc" id="L772" title="2 of 4 branches missed.">        int fieldSize = (fieldTypeChar == 'J' || fieldTypeChar == 'D')</span>
            ? 2 : 1;
<span class="pc bpc" id="L774" title="1 of 3 branches missed.">        switch (theOpCode) {</span>
            case ByteCode.GETFIELD:
            case ByteCode.GETSTATIC:
<span class="fc" id="L777">                newStack += fieldSize;</span>
<span class="fc" id="L778">                break;</span>
            case ByteCode.PUTSTATIC:
            case ByteCode.PUTFIELD:
<span class="fc" id="L781">                newStack -= fieldSize;</span>
<span class="fc" id="L782">                break;</span>
            default:
<span class="nc" id="L784">                throw new IllegalArgumentException(</span>
                    &quot;bad opcode for field reference&quot;);
        }
<span class="pc bpc" id="L787" title="2 of 4 branches missed.">        if (newStack &lt; 0 || Short.MAX_VALUE &lt; newStack)</span>
<span class="nc" id="L788">            badStack(newStack);</span>
<span class="fc" id="L789">        short fieldRefIndex = itsConstantPool.addFieldRef(className,</span>
            fieldName, fieldType);
<span class="fc" id="L791">        addToCodeBuffer(theOpCode);</span>
<span class="fc" id="L792">        addToCodeInt16(fieldRefIndex);</span>

<span class="fc" id="L794">        itsStackTop = (short) newStack;</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">        if (newStack &gt; itsMaxStack)</span>
<span class="fc" id="L796">            itsMaxStack = (short) newStack;</span>
        if (DEBUGSTACK) {
            System.out.println(&quot;After &quot; + bytecodeStr(theOpCode)
                + &quot; stack = &quot; + itsStackTop);
        }
<span class="fc" id="L801">    }</span>

    public void addInvoke(int theOpCode, String className, String methodName,
        String methodType) {
        if (DEBUGCODE) {
            System.out.println(&quot;Add &quot; + bytecodeStr(theOpCode)
                + &quot;, &quot; + className + &quot;, &quot; + methodName + &quot;, &quot;
                + methodType);
        }
<span class="fc" id="L810">        int parameterInfo = sizeOfParameters(methodType);</span>
<span class="fc" id="L811">        int parameterCount = parameterInfo &gt;&gt;&gt; 16;</span>
<span class="fc" id="L812">        int stackDiff = (short) parameterInfo;</span>

<span class="fc" id="L814">        int newStack = itsStackTop + stackDiff;</span>
<span class="fc" id="L815">        newStack += stackChange(theOpCode);     // adjusts for 'this'</span>
<span class="pc bpc" id="L816" title="2 of 4 branches missed.">        if (newStack &lt; 0 || Short.MAX_VALUE &lt; newStack)</span>
<span class="nc" id="L817">            badStack(newStack);</span>

<span class="pc bpc" id="L819" title="1 of 2 branches missed.">        switch (theOpCode) {</span>
            case ByteCode.INVOKEVIRTUAL:
            case ByteCode.INVOKESPECIAL:
            case ByteCode.INVOKESTATIC:
            case ByteCode.INVOKEINTERFACE: {
<span class="fc" id="L824">                addToCodeBuffer(theOpCode);</span>
<span class="fc bfc" id="L825" title="All 2 branches covered.">                if (theOpCode == ByteCode.INVOKEINTERFACE) {</span>
<span class="fc" id="L826">                    short ifMethodRefIndex</span>
<span class="fc" id="L827">                        = itsConstantPool.addInterfaceMethodRef(</span>
                        className, methodName,
                        methodType);
<span class="fc" id="L830">                    addToCodeInt16(ifMethodRefIndex);</span>
<span class="fc" id="L831">                    addToCodeBuffer(parameterCount + 1);</span>
<span class="fc" id="L832">                    addToCodeBuffer(0);</span>
<span class="fc" id="L833">                } else {</span>
<span class="fc" id="L834">                    short methodRefIndex = itsConstantPool.addMethodRef(</span>
                        className, methodName,
                        methodType);
<span class="fc" id="L837">                    addToCodeInt16(methodRefIndex);</span>
                }
            }
<span class="fc" id="L840">            break;</span>

            default:
<span class="nc" id="L843">                throw new IllegalArgumentException(</span>
                    &quot;bad opcode for method reference&quot;);
        }
<span class="fc" id="L846">        itsStackTop = (short) newStack;</span>
<span class="fc bfc" id="L847" title="All 2 branches covered.">        if (newStack &gt; itsMaxStack)</span>
<span class="fc" id="L848">            itsMaxStack = (short) newStack;</span>
        if (DEBUGSTACK) {
            System.out.println(&quot;After &quot; + bytecodeStr(theOpCode)
                + &quot; stack = &quot; + itsStackTop);
        }
<span class="fc" id="L853">    }</span>

    public void addInvokeDynamic(String methodName, String methodType,
        MHandle bsm, Object... bsmArgs) {
        if (DEBUGCODE) {
            System.out.println(&quot;Add invokedynamic, &quot; + methodName + &quot;, &quot; + methodType);
        }
        // JDK 1.7 major class file version is required for invokedynamic
<span class="nc bnc" id="L861" title="All 2 branches missed.">        if (MajorVersion &lt; 51) {</span>
<span class="nc" id="L862">            throw new RuntimeException(</span>
                &quot;Please build and run with JDK 1.7 for invokedynamic support&quot;);
        }

<span class="nc" id="L866">        int parameterInfo = sizeOfParameters(methodType);</span>
        // int parameterCount = parameterInfo &gt;&gt;&gt; 16;
<span class="nc" id="L868">        int stackDiff = (short) parameterInfo;</span>

<span class="nc" id="L870">        int newStack = itsStackTop + stackDiff;</span>
<span class="nc bnc" id="L871" title="All 4 branches missed.">        if (newStack &lt; 0 || Short.MAX_VALUE &lt; newStack)</span>
<span class="nc" id="L872">            badStack(newStack);</span>

<span class="nc" id="L874">        BootstrapEntry bsmEntry = new BootstrapEntry(bsm, bsmArgs);</span>

<span class="nc bnc" id="L876" title="All 2 branches missed.">        if (itsBootstrapMethods == null) {</span>
<span class="nc" id="L877">            itsBootstrapMethods = new ObjArray();</span>
        }
<span class="nc" id="L879">        int bootstrapIndex = itsBootstrapMethods.indexOf(bsmEntry);</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">        if (bootstrapIndex == -1) {</span>
<span class="nc" id="L881">            bootstrapIndex = itsBootstrapMethods.size();</span>
<span class="nc" id="L882">            itsBootstrapMethods.add(bsmEntry);</span>
<span class="nc" id="L883">            itsBootstrapMethodsLength += bsmEntry.code.length;</span>
        }

<span class="nc" id="L886">        short invokedynamicIndex = itsConstantPool.addInvokeDynamic(</span>
            methodName, methodType, bootstrapIndex);

<span class="nc" id="L889">        addToCodeBuffer(ByteCode.INVOKEDYNAMIC);</span>
<span class="nc" id="L890">        addToCodeInt16(invokedynamicIndex);</span>
<span class="nc" id="L891">        addToCodeInt16(0);</span>

<span class="nc" id="L893">        itsStackTop = (short) newStack;</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">        if (newStack &gt; itsMaxStack)</span>
<span class="nc" id="L895">            itsMaxStack = (short) newStack;</span>
        if (DEBUGSTACK) {
            System.out.println(&quot;After invokedynamic stack = &quot; + itsStackTop);
        }

<span class="nc" id="L900">    }</span>

    /**
     * Generate code to load the given integer on stack.
     *
     * @param k the constant
     */
    public void addPush(int k) {
<span class="fc bfc" id="L908" title="All 2 branches covered.">        if ((byte) k == k) {</span>
<span class="pc bpc" id="L909" title="1 of 2 branches missed.">            if (k == -1) {</span>
<span class="nc" id="L910">                add(ByteCode.ICONST_M1);</span>
<span class="fc bfc" id="L911" title="All 4 branches covered.">            } else if (0 &lt;= k &amp;&amp; k &lt;= 5) {</span>
<span class="fc" id="L912">                add((byte) (ByteCode.ICONST_0 + k));</span>
            } else {
<span class="fc" id="L914">                add(ByteCode.BIPUSH, (byte) k);</span>
            }
<span class="fc bfc" id="L916" title="All 2 branches covered.">        } else if ((short) k == k) {</span>
<span class="fc" id="L917">            add(ByteCode.SIPUSH, (short) k);</span>
        } else {
<span class="fc" id="L919">            addLoadConstant(k);</span>
        }
<span class="fc" id="L921">    }</span>

    public void addPush(boolean k) {
<span class="pc bpc" id="L924" title="1 of 2 branches missed.">        add(k ? ByteCode.ICONST_1 : ByteCode.ICONST_0);</span>
<span class="fc" id="L925">    }</span>

    /**
     * Generate code to load the given long on stack.
     *
     * @param k the constant
     */
    public void addPush(long k) {
<span class="nc" id="L933">        int ik = (int) k;</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">        if (ik == k) {</span>
<span class="nc" id="L935">            addPush(ik);</span>
<span class="nc" id="L936">            add(ByteCode.I2L);</span>
        } else {
<span class="nc" id="L938">            addLoadConstant(k);</span>
        }
<span class="nc" id="L940">    }</span>

    /**
     * Generate code to load the given double on stack.
     *
     * @param k the constant
     */
    public void addPush(double k) {
<span class="fc bfc" id="L948" title="All 2 branches covered.">        if (k == 0.0) {</span>
            // zero
<span class="fc" id="L950">            add(ByteCode.DCONST_0);</span>
<span class="pc bpc" id="L951" title="1 of 2 branches missed.">            if (1.0 / k &lt; 0) {</span>
                // Negative zero
<span class="fc" id="L953">                add(ByteCode.DNEG);</span>
            }
<span class="pc bpc" id="L955" title="1 of 4 branches missed.">        } else if (k == 1.0 || k == -1.0) {</span>
<span class="fc" id="L956">            add(ByteCode.DCONST_1);</span>
<span class="pc bpc" id="L957" title="1 of 2 branches missed.">            if (k &lt; 0) {</span>
<span class="nc" id="L958">                add(ByteCode.DNEG);</span>
            }
        } else {
<span class="fc" id="L961">            addLoadConstant(k);</span>
        }
<span class="fc" id="L963">    }</span>

    /**
     * Generate the code to leave on stack the given string even if the string encoding exeeds the
     * class file limit for single string constant
     *
     * @param k the constant
     */
    public void addPush(String k) {
<span class="fc" id="L972">        int length = k.length();</span>
<span class="fc" id="L973">        int limit = itsConstantPool.getUtfEncodingLimit(k, 0, length);</span>
<span class="fc bfc" id="L974" title="All 2 branches covered.">        if (limit == length) {</span>
<span class="fc" id="L975">            addLoadConstant(k);</span>
<span class="fc" id="L976">            return;</span>
        }
        // Split string into picies fitting the UTF limit and generate code for
        // StringBuilder sb = new StringBuilder(length);
        // sb.append(loadConstant(piece_1));
        // ...
        // sb.append(loadConstant(piece_N));
        // sb.toString();
<span class="fc" id="L984">        final String SB = &quot;java/lang/StringBuilder&quot;;</span>
<span class="fc" id="L985">        add(ByteCode.NEW, SB);</span>
<span class="fc" id="L986">        add(ByteCode.DUP);</span>
<span class="fc" id="L987">        addPush(length);</span>
<span class="fc" id="L988">        addInvoke(ByteCode.INVOKESPECIAL, SB, &quot;&lt;init&gt;&quot;, &quot;(I)V&quot;);</span>
<span class="fc" id="L989">        int cursor = 0;</span>
        for (; ; ) {
<span class="fc" id="L991">            add(ByteCode.DUP);</span>
<span class="fc" id="L992">            String s = k.substring(cursor, limit);</span>
<span class="fc" id="L993">            addLoadConstant(s);</span>
<span class="fc" id="L994">            addInvoke(ByteCode.INVOKEVIRTUAL, SB, &quot;append&quot;,</span>
                &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;);
<span class="fc" id="L996">            add(ByteCode.POP);</span>
<span class="fc bfc" id="L997" title="All 2 branches covered.">            if (limit == length) {</span>
<span class="fc" id="L998">                break;</span>
            }
<span class="fc" id="L1000">            cursor = limit;</span>
<span class="fc" id="L1001">            limit = itsConstantPool.getUtfEncodingLimit(k, limit, length);</span>
<span class="fc" id="L1002">        }</span>
<span class="fc" id="L1003">        addInvoke(ByteCode.INVOKEVIRTUAL, SB, &quot;toString&quot;,</span>
            &quot;()Ljava/lang/String;&quot;);
<span class="fc" id="L1005">    }</span>

    /**
     * Check if k fits limit on string constant size imposed by class file format.
     *
     * @param k the string constant
     */
    public boolean isUnderStringSizeLimit(String k) {
<span class="nc" id="L1013">        return itsConstantPool.isUnderUtfEncodingLimit(k);</span>
    }

    /**
     * Store integer from stack top into the given local.
     *
     * @param local number of local register
     */
    public void addIStore(int local) {
<span class="nc" id="L1022">        xop(ByteCode.ISTORE_0, ByteCode.ISTORE, local);</span>
<span class="nc" id="L1023">    }</span>

    /**
     * Store long from stack top into the given local.
     *
     * @param local number of local register
     */
    public void addLStore(int local) {
<span class="nc" id="L1031">        xop(ByteCode.LSTORE_0, ByteCode.LSTORE, local);</span>
<span class="nc" id="L1032">    }</span>

    /**
     * Store float from stack top into the given local.
     *
     * @param local number of local register
     */
    public void addFStore(int local) {
<span class="nc" id="L1040">        xop(ByteCode.FSTORE_0, ByteCode.FSTORE, local);</span>
<span class="nc" id="L1041">    }</span>

    /**
     * Store double from stack top into the given local.
     *
     * @param local number of local register
     */
    public void addDStore(int local) {
<span class="nc" id="L1049">        xop(ByteCode.DSTORE_0, ByteCode.DSTORE, local);</span>
<span class="nc" id="L1050">    }</span>

    /**
     * Store object from stack top into the given local.
     *
     * @param local number of local register
     */
    public void addAStore(int local) {
<span class="fc" id="L1058">        xop(ByteCode.ASTORE_0, ByteCode.ASTORE, local);</span>
<span class="fc" id="L1059">    }</span>

    /**
     * Load integer from the given local into stack.
     *
     * @param local number of local register
     */
    public void addILoad(int local) {
<span class="fc" id="L1067">        xop(ByteCode.ILOAD_0, ByteCode.ILOAD, local);</span>
<span class="fc" id="L1068">    }</span>

    /**
     * Load long from the given local into stack.
     *
     * @param local number of local register
     */
    public void addLLoad(int local) {
<span class="nc" id="L1076">        xop(ByteCode.LLOAD_0, ByteCode.LLOAD, local);</span>
<span class="nc" id="L1077">    }</span>

    /**
     * Load float from the given local into stack.
     *
     * @param local number of local register
     */
    public void addFLoad(int local) {
<span class="nc" id="L1085">        xop(ByteCode.FLOAD_0, ByteCode.FLOAD, local);</span>
<span class="nc" id="L1086">    }</span>

    /**
     * Load double from the given local into stack.
     *
     * @param local number of local register
     */
    public void addDLoad(int local) {
<span class="nc" id="L1094">        xop(ByteCode.DLOAD_0, ByteCode.DLOAD, local);</span>
<span class="nc" id="L1095">    }</span>

    /**
     * Load object from the given local into stack.
     *
     * @param local number of local register
     */
    public void addALoad(int local) {
<span class="fc" id="L1103">        xop(ByteCode.ALOAD_0, ByteCode.ALOAD, local);</span>
<span class="fc" id="L1104">    }</span>

    /**
     * Load &quot;this&quot; into stack.
     */
    public void addLoadThis() {
<span class="fc" id="L1110">        add(ByteCode.ALOAD_0);</span>
<span class="fc" id="L1111">    }</span>

    private void xop(int shortOp, int op, int local) {
<span class="fc bfc" id="L1114" title="All 5 branches covered.">        switch (local) {</span>
            case 0:
<span class="fc" id="L1116">                add(shortOp);</span>
<span class="fc" id="L1117">                break;</span>
            case 1:
<span class="fc" id="L1119">                add(shortOp + 1);</span>
<span class="fc" id="L1120">                break;</span>
            case 2:
<span class="fc" id="L1122">                add(shortOp + 2);</span>
<span class="fc" id="L1123">                break;</span>
            case 3:
<span class="fc" id="L1125">                add(shortOp + 3);</span>
<span class="fc" id="L1126">                break;</span>
            default:
<span class="fc" id="L1128">                add(op, local);</span>
        }
<span class="fc" id="L1130">    }</span>

    public int addTableSwitch(int low, int high) {
        if (DEBUGCODE) {
            System.out.println(&quot;Add &quot; + bytecodeStr(ByteCode.TABLESWITCH)
                + &quot; &quot; + low + &quot; &quot; + high);
        }
<span class="pc bpc" id="L1137" title="1 of 2 branches missed.">        if (low &gt; high)</span>
<span class="nc" id="L1138">            throw new ClassFileFormatException(&quot;Bad bounds: &quot; + low + ' ' + high);</span>

<span class="fc" id="L1140">        int newStack = itsStackTop + stackChange(ByteCode.TABLESWITCH);</span>
<span class="pc bpc" id="L1141" title="2 of 4 branches missed.">        if (newStack &lt; 0 || Short.MAX_VALUE &lt; newStack)</span>
<span class="nc" id="L1142">            badStack(newStack);</span>

<span class="fc" id="L1144">        int entryCount = high - low + 1;</span>
<span class="fc" id="L1145">        int padSize = 3 &amp; ~itsCodeBufferTop; // == 3 - itsCodeBufferTop % 4</span>

<span class="fc" id="L1147">        int N = addReservedCodeSpace(1 + padSize + 4 * (1 + 2 + entryCount));</span>
<span class="fc" id="L1148">        int switchStart = N;</span>
<span class="fc" id="L1149">        itsCodeBuffer[N++] = (byte) ByteCode.TABLESWITCH;</span>
<span class="fc bfc" id="L1150" title="All 2 branches covered.">        while (padSize != 0) {</span>
<span class="fc" id="L1151">            itsCodeBuffer[N++] = 0;</span>
<span class="fc" id="L1152">            --padSize;</span>
        }
<span class="fc" id="L1154">        N += 4; // skip default offset</span>
<span class="fc" id="L1155">        N = putInt32(low, itsCodeBuffer, N);</span>
<span class="fc" id="L1156">        putInt32(high, itsCodeBuffer, N);</span>

<span class="fc" id="L1158">        itsStackTop = (short) newStack;</span>
<span class="pc bpc" id="L1159" title="1 of 2 branches missed.">        if (newStack &gt; itsMaxStack)</span>
<span class="nc" id="L1160">            itsMaxStack = (short) newStack;</span>
        if (DEBUGSTACK) {
            System.out.println(&quot;After &quot; + bytecodeStr(ByteCode.TABLESWITCH)
                + &quot; stack = &quot; + itsStackTop);
        }

<span class="fc" id="L1166">        return switchStart;</span>
    }

    public final void markTableSwitchDefault(int switchStart) {
<span class="fc" id="L1170">        addSuperBlockStart(itsCodeBufferTop);</span>
<span class="fc" id="L1171">        itsJumpFroms.put(itsCodeBufferTop, switchStart);</span>
<span class="fc" id="L1172">        setTableSwitchJump(switchStart, -1, itsCodeBufferTop);</span>
<span class="fc" id="L1173">    }</span>

    public final void markTableSwitchCase(int switchStart, int caseIndex) {
<span class="nc" id="L1176">        addSuperBlockStart(itsCodeBufferTop);</span>
<span class="nc" id="L1177">        itsJumpFroms.put(itsCodeBufferTop, switchStart);</span>
<span class="nc" id="L1178">        setTableSwitchJump(switchStart, caseIndex, itsCodeBufferTop);</span>
<span class="nc" id="L1179">    }</span>

    public final void markTableSwitchCase(int switchStart, int caseIndex,
        int stackTop) {
<span class="pc bpc" id="L1183" title="2 of 4 branches missed.">        if (!(0 &lt;= stackTop &amp;&amp; stackTop &lt;= itsMaxStack))</span>
<span class="nc" id="L1184">            throw new IllegalArgumentException(&quot;Bad stack index: &quot; + stackTop);</span>
<span class="fc" id="L1185">        itsStackTop = (short) stackTop;</span>
<span class="fc" id="L1186">        addSuperBlockStart(itsCodeBufferTop);</span>
<span class="fc" id="L1187">        itsJumpFroms.put(itsCodeBufferTop, switchStart);</span>
<span class="fc" id="L1188">        setTableSwitchJump(switchStart, caseIndex, itsCodeBufferTop);</span>
<span class="fc" id="L1189">    }</span>

    /**
     * Set a jump case for a tableswitch instruction. The jump target should be marked as a super
     * block start for stack map generation.
     */
    public void setTableSwitchJump(int switchStart, int caseIndex,
        int jumpTarget) {
<span class="pc bpc" id="L1197" title="2 of 4 branches missed.">        if (!(0 &lt;= jumpTarget &amp;&amp; jumpTarget &lt;= itsCodeBufferTop))</span>
<span class="nc" id="L1198">            throw new IllegalArgumentException(&quot;Bad jump target: &quot; + jumpTarget);</span>
<span class="pc bpc" id="L1199" title="1 of 2 branches missed.">        if (!(caseIndex &gt;= -1))</span>
<span class="nc" id="L1200">            throw new IllegalArgumentException(&quot;Bad case index: &quot; + caseIndex);</span>

<span class="fc" id="L1202">        int padSize = 3 &amp; ~switchStart; // == 3 - switchStart % 4</span>
        int caseOffset;
<span class="fc bfc" id="L1204" title="All 2 branches covered.">        if (caseIndex &lt; 0) {</span>
            // default label
<span class="fc" id="L1206">            caseOffset = switchStart + 1 + padSize;</span>
        } else {
<span class="fc" id="L1208">            caseOffset = switchStart + 1 + padSize + 4 * (3 + caseIndex);</span>
        }
<span class="pc bpc" id="L1210" title="2 of 4 branches missed.">        if (!(0 &lt;= switchStart</span>
            &amp;&amp; switchStart &lt;= itsCodeBufferTop - 4 * 4 - padSize - 1)) {
<span class="nc" id="L1212">            throw new IllegalArgumentException(</span>
                switchStart + &quot; is outside a possible range of tableswitch&quot;
                    + &quot; in already generated code&quot;);
        }
<span class="pc bpc" id="L1216" title="1 of 2 branches missed.">        if ((0xFF &amp; itsCodeBuffer[switchStart]) != ByteCode.TABLESWITCH) {</span>
<span class="nc" id="L1217">            throw new IllegalArgumentException(</span>
                switchStart + &quot; is not offset of tableswitch statement&quot;);
        }
<span class="pc bpc" id="L1220" title="2 of 4 branches missed.">        if (!(0 &lt;= caseOffset &amp;&amp; caseOffset + 4 &lt;= itsCodeBufferTop)) {</span>
            // caseIndex &gt;= -1 does not guarantee that caseOffset &gt;= 0 due
            // to a possible overflow.
<span class="nc" id="L1223">            throw new ClassFileFormatException(</span>
                &quot;Too big case index: &quot; + caseIndex);
        }
        // ALERT: perhaps check against case bounds?
<span class="fc" id="L1227">        putInt32(jumpTarget - switchStart, itsCodeBuffer, caseOffset);</span>
<span class="fc" id="L1228">    }</span>

    public int acquireLabel() {
<span class="fc" id="L1231">        int top = itsLabelTableTop;</span>
<span class="fc bfc" id="L1232" title="All 4 branches covered.">        if (itsLabelTable == null || top == itsLabelTable.length) {</span>
<span class="fc bfc" id="L1233" title="All 2 branches covered.">            if (itsLabelTable == null) {</span>
<span class="fc" id="L1234">                itsLabelTable = new int[MIN_LABEL_TABLE_SIZE];</span>
            } else {
<span class="fc" id="L1236">                int[] tmp = new int[itsLabelTable.length * 2];</span>
<span class="fc" id="L1237">                System.arraycopy(itsLabelTable, 0, tmp, 0, top);</span>
<span class="fc" id="L1238">                itsLabelTable = tmp;</span>
            }
        }
<span class="fc" id="L1241">        itsLabelTableTop = top + 1;</span>
<span class="fc" id="L1242">        itsLabelTable[top] = -1;</span>
<span class="fc" id="L1243">        return top | 0x80000000;</span>
    }

    public void markLabel(int label) {
<span class="pc bpc" id="L1247" title="1 of 2 branches missed.">        if (!(label &lt; 0))</span>
<span class="nc" id="L1248">            throw new IllegalArgumentException(&quot;Bad label, no biscuit&quot;);</span>

<span class="fc" id="L1250">        label &amp;= 0x7FFFFFFF;</span>
<span class="pc bpc" id="L1251" title="1 of 2 branches missed.">        if (label &gt; itsLabelTableTop)</span>
<span class="nc" id="L1252">            throw new IllegalArgumentException(&quot;Bad label&quot;);</span>

<span class="pc bpc" id="L1254" title="1 of 2 branches missed.">        if (itsLabelTable[label] != -1) {</span>
<span class="nc" id="L1255">            throw new IllegalStateException(&quot;Can only mark label once&quot;);</span>
        }

<span class="fc" id="L1258">        itsLabelTable[label] = itsCodeBufferTop;</span>
<span class="fc" id="L1259">    }</span>

    public void markLabel(int label, short stackTop) {
<span class="fc" id="L1262">        markLabel(label);</span>
<span class="fc" id="L1263">        itsStackTop = stackTop;</span>
<span class="fc" id="L1264">    }</span>

    public void markHandler(int theLabel) {
<span class="fc" id="L1267">        itsStackTop = 1;</span>
<span class="fc" id="L1268">        markLabel(theLabel);</span>
<span class="fc" id="L1269">    }</span>

    public int getLabelPC(int label) {
<span class="pc bpc" id="L1272" title="1 of 2 branches missed.">        if (!(label &lt; 0))</span>
<span class="nc" id="L1273">            throw new IllegalArgumentException(&quot;Bad label, no biscuit&quot;);</span>
<span class="fc" id="L1274">        label &amp;= 0x7FFFFFFF;</span>
<span class="pc bpc" id="L1275" title="1 of 2 branches missed.">        if (!(label &lt; itsLabelTableTop))</span>
<span class="nc" id="L1276">            throw new IllegalArgumentException(&quot;Bad label&quot;);</span>
<span class="fc" id="L1277">        return itsLabelTable[label];</span>
    }

    private void addLabelFixup(int label, int fixupSite) {
<span class="pc bpc" id="L1281" title="1 of 2 branches missed.">        if (!(label &lt; 0))</span>
<span class="nc" id="L1282">            throw new IllegalArgumentException(&quot;Bad label, no biscuit&quot;);</span>
<span class="fc" id="L1283">        label &amp;= 0x7FFFFFFF;</span>
<span class="pc bpc" id="L1284" title="1 of 2 branches missed.">        if (!(label &lt; itsLabelTableTop))</span>
<span class="nc" id="L1285">            throw new IllegalArgumentException(&quot;Bad label&quot;);</span>
<span class="fc" id="L1286">        int top = itsFixupTableTop;</span>
<span class="fc bfc" id="L1287" title="All 4 branches covered.">        if (itsFixupTable == null || top == itsFixupTable.length) {</span>
<span class="fc bfc" id="L1288" title="All 2 branches covered.">            if (itsFixupTable == null) {</span>
<span class="fc" id="L1289">                itsFixupTable = new long[MIN_FIXUP_TABLE_SIZE];</span>
            } else {
<span class="fc" id="L1291">                long[] tmp = new long[itsFixupTable.length * 2];</span>
<span class="fc" id="L1292">                System.arraycopy(itsFixupTable, 0, tmp, 0, top);</span>
<span class="fc" id="L1293">                itsFixupTable = tmp;</span>
            }
        }
<span class="fc" id="L1296">        itsFixupTableTop = top + 1;</span>
<span class="fc" id="L1297">        itsFixupTable[top] = ((long) label &lt;&lt; 32) | fixupSite;</span>
<span class="fc" id="L1298">    }</span>

    private void fixLabelGotos() {
<span class="fc" id="L1301">        byte[] codeBuffer = itsCodeBuffer;</span>
<span class="fc bfc" id="L1302" title="All 2 branches covered.">        for (int i = 0; i &lt; itsFixupTableTop; i++) {</span>
<span class="fc" id="L1303">            long fixup = itsFixupTable[i];</span>
<span class="fc" id="L1304">            int label = (int) (fixup &gt;&gt; 32);</span>
<span class="fc" id="L1305">            int fixupSite = (int) fixup;</span>
<span class="fc" id="L1306">            int pc = itsLabelTable[label];</span>
<span class="pc bpc" id="L1307" title="1 of 2 branches missed.">            if (pc == -1) {</span>
                // Unlocated label
<span class="nc" id="L1309">                throw new RuntimeException();</span>
            }
            // -1 to get delta from instruction start
<span class="fc" id="L1312">            addSuperBlockStart(pc);</span>
<span class="fc" id="L1313">            itsJumpFroms.put(pc, fixupSite - 1);</span>
<span class="fc" id="L1314">            int offset = pc - (fixupSite - 1);</span>
<span class="pc bpc" id="L1315" title="1 of 2 branches missed.">            if ((short) offset != offset) {</span>
<span class="nc" id="L1316">                throw new ClassFileFormatException</span>
                    (&quot;Program too complex: too big jump offset&quot;);
            }
<span class="fc" id="L1319">            codeBuffer[fixupSite] = (byte) (offset &gt;&gt; 8);</span>
<span class="fc" id="L1320">            codeBuffer[fixupSite + 1] = (byte) offset;</span>
        }
<span class="fc" id="L1322">        itsFixupTableTop = 0;</span>
<span class="fc" id="L1323">    }</span>

    /**
     * Get the current offset into the code of the current method.
     *
     * @return an integer representing the offset
     */
    public int getCurrentCodeOffset() {
<span class="fc" id="L1331">        return itsCodeBufferTop;</span>
    }

    public short getStackTop() {
<span class="fc" id="L1335">        return itsStackTop;</span>
    }

    public void setStackTop(short n) {
<span class="fc" id="L1339">        itsStackTop = n;</span>
<span class="fc" id="L1340">    }</span>

    public void adjustStackTop(int delta) {
<span class="fc" id="L1343">        int newStack = itsStackTop + delta;</span>
<span class="pc bpc" id="L1344" title="2 of 4 branches missed.">        if (newStack &lt; 0 || Short.MAX_VALUE &lt; newStack)</span>
<span class="nc" id="L1345">            badStack(newStack);</span>
<span class="fc" id="L1346">        itsStackTop = (short) newStack;</span>
<span class="pc bpc" id="L1347" title="1 of 2 branches missed.">        if (newStack &gt; itsMaxStack)</span>
<span class="nc" id="L1348">            itsMaxStack = (short) newStack;</span>
        if (DEBUGSTACK) {
            System.out.println(&quot;After &quot; + &quot;adjustStackTop(&quot; + delta + &quot;)&quot;
                + &quot; stack = &quot; + itsStackTop);
        }
<span class="fc" id="L1353">    }</span>

    private void addToCodeBuffer(int b) {
<span class="fc" id="L1356">        int N = addReservedCodeSpace(1);</span>
<span class="fc" id="L1357">        itsCodeBuffer[N] = (byte) b;</span>
<span class="fc" id="L1358">    }</span>

    private void addToCodeInt16(int value) {
<span class="fc" id="L1361">        int N = addReservedCodeSpace(2);</span>
<span class="fc" id="L1362">        putInt16(value, itsCodeBuffer, N);</span>
<span class="fc" id="L1363">    }</span>

    private int addReservedCodeSpace(int size) {
<span class="pc bpc" id="L1366" title="1 of 2 branches missed.">        if (itsCurrentMethod == null)</span>
<span class="nc" id="L1367">            throw new IllegalArgumentException(&quot;No method to add to&quot;);</span>
<span class="fc" id="L1368">        int oldTop = itsCodeBufferTop;</span>
<span class="fc" id="L1369">        int newTop = oldTop + size;</span>
<span class="fc bfc" id="L1370" title="All 2 branches covered.">        if (newTop &gt; itsCodeBuffer.length) {</span>
<span class="fc" id="L1371">            int newSize = itsCodeBuffer.length * 2;</span>
<span class="pc bpc" id="L1372" title="1 of 2 branches missed.">            if (newTop &gt; newSize) {</span>
<span class="nc" id="L1373">                newSize = newTop;</span>
            }
<span class="fc" id="L1375">            byte[] tmp = new byte[newSize];</span>
<span class="fc" id="L1376">            System.arraycopy(itsCodeBuffer, 0, tmp, 0, oldTop);</span>
<span class="fc" id="L1377">            itsCodeBuffer = tmp;</span>
        }
<span class="fc" id="L1379">        itsCodeBufferTop = newTop;</span>
<span class="fc" id="L1380">        return oldTop;</span>
    }

    public void addExceptionHandler(int startLabel, int endLabel,
        int handlerLabel, String catchClassName) {
<span class="pc bpc" id="L1385" title="1 of 2 branches missed.">        if ((startLabel &amp; 0x80000000) != 0x80000000)</span>
<span class="nc" id="L1386">            throw new IllegalArgumentException(&quot;Bad startLabel&quot;);</span>
<span class="pc bpc" id="L1387" title="1 of 2 branches missed.">        if ((endLabel &amp; 0x80000000) != 0x80000000)</span>
<span class="nc" id="L1388">            throw new IllegalArgumentException(&quot;Bad endLabel&quot;);</span>
<span class="pc bpc" id="L1389" title="1 of 2 branches missed.">        if ((handlerLabel &amp; 0x80000000) != 0x80000000)</span>
<span class="nc" id="L1390">            throw new IllegalArgumentException(&quot;Bad handlerLabel&quot;);</span>

        /*
         * If catchClassName is null, use 0 for the catch_type_index; which
         * means catch everything.  (Even when the verifier has let you throw
         * something other than a Throwable.)
         */
<span class="fc bfc" id="L1397" title="All 2 branches covered.">        short catch_type_index = (catchClassName == null)</span>
            ? 0
<span class="fc" id="L1399">            : itsConstantPool.addClass(catchClassName);</span>
<span class="fc" id="L1400">        ExceptionTableEntry newEntry = new ExceptionTableEntry(</span>
            startLabel,
            endLabel,
            handlerLabel,
            catch_type_index);
<span class="fc" id="L1405">        int N = itsExceptionTableTop;</span>
<span class="fc bfc" id="L1406" title="All 2 branches covered.">        if (N == 0) {</span>
<span class="fc" id="L1407">            itsExceptionTable = new ExceptionTableEntry[ExceptionTableSize];</span>
<span class="fc bfc" id="L1408" title="All 2 branches covered.">        } else if (N == itsExceptionTable.length) {</span>
<span class="fc" id="L1409">            ExceptionTableEntry[] tmp = new ExceptionTableEntry[N * 2];</span>
<span class="fc" id="L1410">            System.arraycopy(itsExceptionTable, 0, tmp, 0, N);</span>
<span class="fc" id="L1411">            itsExceptionTable = tmp;</span>
        }
<span class="fc" id="L1413">        itsExceptionTable[N] = newEntry;</span>
<span class="fc" id="L1414">        itsExceptionTableTop = N + 1;</span>

<span class="fc" id="L1416">    }</span>

    public void addLineNumberEntry(short lineNumber) {
<span class="pc bpc" id="L1419" title="1 of 2 branches missed.">        if (itsCurrentMethod == null)</span>
<span class="nc" id="L1420">            throw new IllegalArgumentException(&quot;No method to stop&quot;);</span>
<span class="fc" id="L1421">        int N = itsLineNumberTableTop;</span>
<span class="fc bfc" id="L1422" title="All 2 branches covered.">        if (N == 0) {</span>
<span class="fc" id="L1423">            itsLineNumberTable = new int[LineNumberTableSize];</span>
<span class="fc bfc" id="L1424" title="All 2 branches covered.">        } else if (N == itsLineNumberTable.length) {</span>
<span class="fc" id="L1425">            int[] tmp = new int[N * 2];</span>
<span class="fc" id="L1426">            System.arraycopy(itsLineNumberTable, 0, tmp, 0, N);</span>
<span class="fc" id="L1427">            itsLineNumberTable = tmp;</span>
        }
<span class="fc" id="L1429">        itsLineNumberTable[N] = (itsCodeBufferTop &lt;&lt; 16) + lineNumber;</span>
<span class="fc" id="L1430">        itsLineNumberTableTop = N + 1;</span>
<span class="fc" id="L1431">    }</span>

    /**
     * A stack map table is a code attribute introduced in Java 6 that gives type information at key
     * points in the method body (namely, at the beginning of each super block after the first). Each
     * frame of a stack map table contains the state of local variable and operand stack for a given
     * super block.
     */
    final class StackMapTable {

<span class="fc" id="L1441">        StackMapTable() {</span>
<span class="fc" id="L1442">            superBlocks = null;</span>
<span class="fc" id="L1443">            locals = stack = null;</span>
<span class="fc" id="L1444">            workList = null;</span>
<span class="fc" id="L1445">            rawStackMap = null;</span>
<span class="fc" id="L1446">            localsTop = 0;</span>
<span class="fc" id="L1447">            stackTop = 0;</span>
<span class="fc" id="L1448">            workListTop = 0;</span>
<span class="fc" id="L1449">            rawStackMapTop = 0;</span>
<span class="fc" id="L1450">            wide = false;</span>
<span class="fc" id="L1451">        }</span>

        void generate() {
<span class="fc" id="L1454">            superBlocks = new SuperBlock[itsSuperBlockStartsTop];</span>
<span class="fc" id="L1455">            int[] initialLocals = createInitialLocals();</span>

<span class="fc bfc" id="L1457" title="All 2 branches covered.">            for (int i = 0; i &lt; itsSuperBlockStartsTop; i++) {</span>
<span class="fc" id="L1458">                int start = itsSuperBlockStarts[i];</span>
                int end;
<span class="fc bfc" id="L1460" title="All 2 branches covered.">                if (i == itsSuperBlockStartsTop - 1) {</span>
<span class="fc" id="L1461">                    end = itsCodeBufferTop;</span>
                } else {
<span class="fc" id="L1463">                    end = itsSuperBlockStarts[i + 1];</span>
                }
<span class="fc" id="L1465">                superBlocks[i] = new SuperBlock(i, start, end, initialLocals);</span>
            }

            if (DEBUGSTACKMAP) {
                System.out.println(&quot;super blocks: &quot;);
                for (int i = 0;
                    i &lt; superBlocks.length &amp;&amp; superBlocks[i] != null; i++) {
                    System.out.println(&quot;sb &quot; + i + &quot;: [&quot; +
                        superBlocks[i].getStart() + &quot;, &quot; +
                        superBlocks[i].getEnd() + &quot;)&quot;);
                }
            }

<span class="fc" id="L1478">            superBlockDeps = getSuperBlockDependencies();</span>

<span class="fc" id="L1480">            verify();</span>

            if (DEBUGSTACKMAP) {
                System.out.println(&quot;type information:&quot;);
                for (int i = 0; i &lt; superBlocks.length; i++) {
                    SuperBlock sb = superBlocks[i];
                    System.out.println(&quot;sb &quot; + i + &quot;:&quot;);
                    TypeInfo.print(sb.getLocals(), sb.getStack(),
                        itsConstantPool);
                }
            }
<span class="fc" id="L1491">        }</span>

        private SuperBlock getSuperBlockFromOffset(int offset) {
<span class="pc bpc" id="L1494" title="1 of 2 branches missed.">            for (int i = 0; i &lt; superBlocks.length; i++) {</span>
<span class="fc" id="L1495">                SuperBlock sb = superBlocks[i];</span>
<span class="pc bpc" id="L1496" title="1 of 2 branches missed.">                if (sb == null) {</span>
<span class="nc" id="L1497">                    break;</span>
<span class="pc bpc" id="L1498" title="1 of 4 branches missed.">                } else if (offset &gt;= sb.getStart() &amp;&amp; offset &lt; sb.getEnd()) {</span>
<span class="fc" id="L1499">                    return sb;</span>
                }
            }
<span class="nc" id="L1502">            throw new IllegalArgumentException(&quot;bad offset: &quot; + offset);</span>
        }

        /**
         * Determine whether or not an opcode is an actual end to a super block. This includes any
         * returns or unconditional jumps.
         */
        private boolean isSuperBlockEnd(int opcode) {
<span class="fc bfc" id="L1510" title="All 2 branches covered.">            switch (opcode) {</span>
                case ByteCode.ARETURN:
                case ByteCode.FRETURN:
                case ByteCode.IRETURN:
                case ByteCode.LRETURN:
                case ByteCode.RETURN:
                case ByteCode.ATHROW:
                case ByteCode.GOTO:
                case ByteCode.GOTO_W:
                case ByteCode.TABLESWITCH:
                case ByteCode.LOOKUPSWITCH:
<span class="fc" id="L1521">                    return true;</span>
                default:
<span class="fc" id="L1523">                    return false;</span>
            }
        }

        /**
         * Calculate partial dependencies for super blocks.
         *
         * This is used as a workaround for dead code that is generated. Only one dependency per super
         * block is given.
         */
        private SuperBlock[] getSuperBlockDependencies() {
<span class="fc" id="L1534">            SuperBlock[] deps = new SuperBlock[superBlocks.length];</span>

<span class="fc bfc" id="L1536" title="All 2 branches covered.">            for (int i = 0; i &lt; itsExceptionTableTop; i++) {</span>
<span class="fc" id="L1537">                ExceptionTableEntry ete = itsExceptionTable[i];</span>
<span class="fc" id="L1538">                short startPC = (short) getLabelPC(ete.itsStartLabel);</span>
<span class="fc" id="L1539">                short handlerPC = (short) getLabelPC(ete.itsHandlerLabel);</span>
<span class="fc" id="L1540">                SuperBlock handlerSB = getSuperBlockFromOffset(handlerPC);</span>
<span class="fc" id="L1541">                SuperBlock dep = getSuperBlockFromOffset(startPC);</span>
<span class="fc" id="L1542">                deps[handlerSB.getIndex()] = dep;</span>
            }
<span class="fc" id="L1544">            int[] targetPCs = itsJumpFroms.getKeys();</span>
<span class="fc bfc" id="L1545" title="All 2 branches covered.">            for (int i = 0; i &lt; targetPCs.length; i++) {</span>
<span class="fc" id="L1546">                int targetPC = targetPCs[i];</span>
<span class="fc" id="L1547">                int branchPC = itsJumpFroms.getInt(targetPC, -1);</span>
<span class="fc" id="L1548">                SuperBlock branchSB = getSuperBlockFromOffset(branchPC);</span>
<span class="fc" id="L1549">                SuperBlock targetSB = getSuperBlockFromOffset(targetPC);</span>
<span class="fc" id="L1550">                deps[targetSB.getIndex()] = branchSB;</span>
            }

<span class="fc" id="L1553">            return deps;</span>
        }

        /**
         * Get the target super block of a branch instruction.
         *
         * @param bci the index of the branch instruction in the code buffer
         */
        private SuperBlock getBranchTarget(int bci) {
            int target;
<span class="pc bpc" id="L1563" title="1 of 2 branches missed.">            if ((itsCodeBuffer[bci] &amp; 0xFF) == ByteCode.GOTO_W) {</span>
<span class="nc" id="L1564">                target = bci + getOperand(bci + 1, 4);</span>
            } else {
<span class="fc" id="L1566">                target = bci + (short) getOperand(bci + 1, 2);</span>
            }
<span class="fc" id="L1568">            return getSuperBlockFromOffset(target);</span>
        }

        /**
         * Determine whether or not an opcode is a conditional or unconditional jump.
         */
        private boolean isBranch(int opcode) {
<span class="fc bfc" id="L1575" title="All 2 branches covered.">            switch (opcode) {</span>
                case ByteCode.GOTO:
                case ByteCode.GOTO_W:
                case ByteCode.IFEQ:
                case ByteCode.IFGE:
                case ByteCode.IFGT:
                case ByteCode.IFLE:
                case ByteCode.IFLT:
                case ByteCode.IFNE:
                case ByteCode.IFNONNULL:
                case ByteCode.IFNULL:
                case ByteCode.IF_ACMPEQ:
                case ByteCode.IF_ACMPNE:
                case ByteCode.IF_ICMPEQ:
                case ByteCode.IF_ICMPGE:
                case ByteCode.IF_ICMPGT:
                case ByteCode.IF_ICMPLE:
                case ByteCode.IF_ICMPLT:
                case ByteCode.IF_ICMPNE:
<span class="fc" id="L1594">                    return true;</span>
                default:
<span class="fc" id="L1596">                    return false;</span>
            }
        }

        private int getOperand(int offset) {
<span class="fc" id="L1601">            return getOperand(offset, 1);</span>
        }

        /**
         * Extract a logical operand from the byte code.
         *
         * This is used, for example, to get branch offsets.
         */
        private int getOperand(int start, int size) {
<span class="fc" id="L1610">            int result = 0;</span>
<span class="pc bpc" id="L1611" title="1 of 2 branches missed.">            if (size &gt; 4) {</span>
<span class="nc" id="L1612">                throw new IllegalArgumentException(&quot;bad operand size&quot;);</span>
            }
<span class="fc bfc" id="L1614" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1615">                result = (result &lt;&lt; 8) | (itsCodeBuffer[start + i] &amp; 0xFF);</span>
            }
<span class="fc" id="L1617">            return result;</span>
        }

        /**
         * Calculate initial local variable and op stack types for each super block in the method.
         */
        private void verify() {
<span class="fc" id="L1624">            int[] initialLocals = createInitialLocals();</span>
<span class="fc" id="L1625">            superBlocks[0].merge(initialLocals, initialLocals.length,</span>
<span class="fc" id="L1626">                new int[0], 0, itsConstantPool);</span>

            // Start from the top of the method and queue up block dependencies
            // as they come along.
<span class="fc" id="L1630">            workList = new SuperBlock[]{superBlocks[0]};</span>
<span class="fc" id="L1631">            workListTop = 1;</span>
<span class="fc" id="L1632">            executeWorkList();</span>

            // Replace dead code with no-ops.
<span class="fc bfc" id="L1635" title="All 2 branches covered.">            for (int i = 0; i &lt; superBlocks.length; i++) {</span>
<span class="fc" id="L1636">                SuperBlock sb = superBlocks[i];</span>
<span class="fc bfc" id="L1637" title="All 2 branches covered.">                if (!sb.isInitialized()) {</span>
<span class="fc" id="L1638">                    killSuperBlock(sb);</span>
                }
            }
<span class="fc" id="L1641">            executeWorkList();</span>
<span class="fc" id="L1642">        }</span>

        /**
         * Replace the contents of a super block with no-ops.
         *
         * The above description is not strictly true; the last instruction is an athrow instruction.
         * This technique is borrowed from ASM's developer guide: http://asm.ow2.org/doc/developer-guide.html#deadcode
         *
         * The proposed algorithm fills a block with nop, ending it with an athrow. The stack map
         * generated would be empty locals with an exception on the stack. In theory, it shouldn't
         * matter what the locals are, as long as the stack has an exception for the athrow bit.
         * However, it turns out that if the code being modified falls into an exception handler, it
         * causes problems. Therefore, if it does, then we steal the locals from the exception block.
         *
         * If the block itself is an exception handler, we remove it from the exception table to
         * simplify block dependencies.
         */
        private void killSuperBlock(SuperBlock sb) {
<span class="fc" id="L1660">            int[] locals = new int[0];</span>
<span class="fc" id="L1661">            int[] stack = new int[]{TypeInfo.OBJECT(&quot;java/lang/Throwable&quot;,</span>
<span class="fc" id="L1662">                itsConstantPool)};</span>

            // If the super block is handled by any exception handler, use its
            // locals as the killed block's locals. Ignore uninitialized
            // handlers, because they will also be killed and removed from the
            // exception table.
<span class="fc bfc" id="L1668" title="All 2 branches covered.">            for (int i = 0; i &lt; itsExceptionTableTop; i++) {</span>
<span class="fc" id="L1669">                ExceptionTableEntry ete = itsExceptionTable[i];</span>
<span class="fc" id="L1670">                int eteStart = getLabelPC(ete.itsStartLabel);</span>
<span class="fc" id="L1671">                int eteEnd = getLabelPC(ete.itsEndLabel);</span>
<span class="fc" id="L1672">                int handlerPC = getLabelPC(ete.itsHandlerLabel);</span>
<span class="fc" id="L1673">                SuperBlock handlerSB = getSuperBlockFromOffset(handlerPC);</span>
<span class="fc bfc" id="L1674" title="All 4 branches covered.">                if ((sb.getStart() &gt; eteStart &amp;&amp; sb.getStart() &lt; eteEnd) ||</span>
<span class="pc bpc" id="L1675" title="1 of 4 branches missed.">                    (eteStart &gt; sb.getStart() &amp;&amp; eteStart &lt; sb.getEnd()) &amp;&amp;</span>
<span class="nc bnc" id="L1676" title="All 2 branches missed.">                        handlerSB.isInitialized()) {</span>
<span class="fc" id="L1677">                    locals = handlerSB.getLocals();</span>
<span class="fc" id="L1678">                    break;</span>
                }
            }

            // Remove any exception table entry whose handler is the killed
            // block. This removes block dependencies to make stack maps for
            // dead blocks easier to create.
<span class="fc bfc" id="L1685" title="All 2 branches covered.">            for (int i = 0; i &lt; itsExceptionTableTop; i++) {</span>
<span class="fc" id="L1686">                ExceptionTableEntry ete = itsExceptionTable[i];</span>
<span class="fc" id="L1687">                int eteStart = getLabelPC(ete.itsStartLabel);</span>
<span class="pc bpc" id="L1688" title="1 of 2 branches missed.">                if (eteStart == sb.getStart()) {</span>
<span class="nc bnc" id="L1689" title="All 2 branches missed.">                    for (int j = i + 1; j &lt; itsExceptionTableTop; j++) {</span>
<span class="nc" id="L1690">                        itsExceptionTable[j - 1] = itsExceptionTable[j];</span>
                    }
<span class="nc" id="L1692">                    itsExceptionTableTop--;</span>
<span class="nc" id="L1693">                    i--;</span>
                }
            }

<span class="fc" id="L1697">            sb.merge(locals, locals.length, stack, stack.length,</span>
<span class="fc" id="L1698">                itsConstantPool);</span>

<span class="fc" id="L1700">            int end = sb.getEnd() - 1;</span>
<span class="fc" id="L1701">            itsCodeBuffer[end] = (byte) ByteCode.ATHROW;</span>
<span class="fc bfc" id="L1702" title="All 2 branches covered.">            for (int bci = sb.getStart(); bci &lt; end; bci++) {</span>
<span class="fc" id="L1703">                itsCodeBuffer[bci] = (byte) ByteCode.NOP;</span>
            }
<span class="fc" id="L1705">        }</span>

        private void executeWorkList() {
<span class="fc bfc" id="L1708" title="All 2 branches covered.">            while (workListTop &gt; 0) {</span>
<span class="fc" id="L1709">                SuperBlock work = workList[--workListTop];</span>
<span class="fc" id="L1710">                work.setInQueue(false);</span>
<span class="fc" id="L1711">                locals = work.getLocals();</span>
<span class="fc" id="L1712">                stack = work.getStack();</span>
<span class="fc" id="L1713">                localsTop = locals.length;</span>
<span class="fc" id="L1714">                stackTop = stack.length;</span>
<span class="fc" id="L1715">                executeBlock(work);</span>
<span class="fc" id="L1716">            }</span>
<span class="fc" id="L1717">        }</span>

        /**
         * Simulate the local variable and op stack for a super block.
         */
        private void executeBlock(SuperBlock work) {
<span class="fc" id="L1723">            int bc = 0;</span>
<span class="fc" id="L1724">            int next = 0;</span>

            if (DEBUGSTACKMAP) {
                System.out.println(&quot;working on sb &quot; + work.getIndex());
                System.out.println(&quot;initial type state:&quot;);
                TypeInfo.print(locals, localsTop, stack, stackTop,
                    itsConstantPool);
            }

<span class="fc bfc" id="L1733" title="All 2 branches covered.">            for (int bci = work.getStart(); bci &lt; work.getEnd(); bci += next) {</span>
<span class="fc" id="L1734">                bc = itsCodeBuffer[bci] &amp; 0xFF;</span>
<span class="fc" id="L1735">                next = execute(bci);</span>

                // If we have a branch to some super block, we need to merge
                // the current state of the local table and op stack with what's
                // currently stored as the initial state of the super block. If
                // something actually changed, we need to add it to the work
                // list.
<span class="fc bfc" id="L1742" title="All 2 branches covered.">                if (isBranch(bc)) {</span>
<span class="fc" id="L1743">                    SuperBlock targetSB = getBranchTarget(bci);</span>
                    if (DEBUGSTACKMAP) {
                        System.out.println(&quot;sb &quot; + work.getIndex() +
                            &quot; points to sb &quot; +
                            targetSB.getIndex() +
                            &quot; (offset &quot; + bci + &quot; -&gt; &quot; +
                            targetSB.getStart() + &quot;)&quot;);
                        System.out.println(&quot;type state at &quot; + bci + &quot;:&quot;);
                        TypeInfo.print(locals, localsTop, stack, stackTop,
                            itsConstantPool);
                    }
<span class="fc" id="L1754">                    flowInto(targetSB);</span>
                    if (DEBUGSTACKMAP) {
                        System.out.println(&quot;type state of &quot; + targetSB +
                            &quot; after merge:&quot;);
                        TypeInfo.print(targetSB.getLocals(),
                            targetSB.getStack(), itsConstantPool);
                    }
<span class="fc bfc" id="L1761" title="All 2 branches covered.">                } else if (bc == ByteCode.TABLESWITCH) {</span>
<span class="fc" id="L1762">                    int switchStart = bci + 1 + (3 &amp; ~bci); // 3 - bci % 4</span>
<span class="fc" id="L1763">                    int defaultOffset = getOperand(switchStart, 4);</span>
<span class="fc" id="L1764">                    SuperBlock targetSB =</span>
<span class="fc" id="L1765">                        getSuperBlockFromOffset(bci + defaultOffset);</span>
                    if (DEBUGSTACK) {
                        System.out.println(&quot;merging sb &quot; + work.getIndex() +
                            &quot; with sb &quot; + targetSB.getIndex());
                    }
<span class="fc" id="L1770">                    flowInto(targetSB);</span>
<span class="fc" id="L1771">                    int low = getOperand(switchStart + 4, 4);</span>
<span class="fc" id="L1772">                    int high = getOperand(switchStart + 8, 4);</span>
<span class="fc" id="L1773">                    int numCases = high - low + 1;</span>
<span class="fc" id="L1774">                    int caseBase = switchStart + 12;</span>
<span class="fc bfc" id="L1775" title="All 2 branches covered.">                    for (int i = 0; i &lt; numCases; i++) {</span>
<span class="fc" id="L1776">                        int label = bci + getOperand(caseBase + 4 * i, 4);</span>
<span class="fc" id="L1777">                        targetSB = getSuperBlockFromOffset(label);</span>
                        if (DEBUGSTACKMAP) {
                            System.out.println(&quot;merging sb &quot; +
                                work.getIndex() + &quot; with sb &quot; +
                                targetSB.getIndex());
                        }
<span class="fc" id="L1783">                        flowInto(targetSB);</span>
                    }
                }

<span class="fc bfc" id="L1787" title="All 2 branches covered.">                for (int i = 0; i &lt; itsExceptionTableTop; i++) {</span>
<span class="fc" id="L1788">                    ExceptionTableEntry ete = itsExceptionTable[i];</span>
<span class="fc" id="L1789">                    short startPC = (short) getLabelPC(ete.itsStartLabel);</span>
<span class="fc" id="L1790">                    short endPC = (short) getLabelPC(ete.itsEndLabel);</span>
<span class="fc bfc" id="L1791" title="All 4 branches covered.">                    if (bci &lt; startPC || bci &gt;= endPC) {</span>
<span class="fc" id="L1792">                        continue;</span>
                    }
<span class="fc" id="L1794">                    short handlerPC =</span>
<span class="fc" id="L1795">                        (short) getLabelPC(ete.itsHandlerLabel);</span>
<span class="fc" id="L1796">                    SuperBlock sb = getSuperBlockFromOffset(handlerPC);</span>
                    int exceptionType;

<span class="fc bfc" id="L1799" title="All 2 branches covered.">                    if (ete.itsCatchType == 0) {</span>
<span class="fc" id="L1800">                        exceptionType = TypeInfo.OBJECT(</span>
<span class="fc" id="L1801">                            itsConstantPool.addClass(&quot;java/lang/Throwable&quot;));</span>
                    } else {
<span class="fc" id="L1803">                        exceptionType = TypeInfo.OBJECT(ete.itsCatchType);</span>
                    }
<span class="fc" id="L1805">                    sb.merge(locals, localsTop, new int[]{exceptionType}, 1,</span>
<span class="fc" id="L1806">                        itsConstantPool);</span>
<span class="fc" id="L1807">                    addToWorkList(sb);</span>
                }
            }

            if (DEBUGSTACKMAP) {
                System.out.println(&quot;end of sb &quot; + work.getIndex() + &quot;:&quot;);
                TypeInfo.print(locals, localsTop, stack, stackTop,
                    itsConstantPool);
            }

            // Check the last instruction to see if it is a true end of a
            // super block (ie., if the instruction is a return). If it
            // isn't, we need to continue processing the next chunk.
<span class="fc bfc" id="L1820" title="All 2 branches covered.">            if (!isSuperBlockEnd(bc)) {</span>
<span class="fc" id="L1821">                int nextIndex = work.getIndex() + 1;</span>
<span class="pc bpc" id="L1822" title="1 of 2 branches missed.">                if (nextIndex &lt; superBlocks.length) {</span>
                    if (DEBUGSTACKMAP) {
                        System.out.println(&quot;continuing from sb &quot; +
                            work.getIndex() + &quot; into sb &quot; +
                            nextIndex);
                    }
<span class="fc" id="L1828">                    flowInto(superBlocks[nextIndex]);</span>
                }
            }
<span class="fc" id="L1831">        }</span>

        /**
         * Perform a merge of type state and add the super block to the work list if the merge changed
         * anything.
         */
        private void flowInto(SuperBlock sb) {
<span class="fc bfc" id="L1838" title="All 2 branches covered.">            if (sb.merge(locals, localsTop, stack, stackTop, itsConstantPool)) {</span>
<span class="fc" id="L1839">                addToWorkList(sb);</span>
            }
<span class="fc" id="L1841">        }</span>

        private void addToWorkList(SuperBlock sb) {
<span class="fc bfc" id="L1844" title="All 2 branches covered.">            if (!sb.isInQueue()) {</span>
<span class="fc" id="L1845">                sb.setInQueue(true);</span>
<span class="fc" id="L1846">                sb.setInitialized(true);</span>
<span class="fc bfc" id="L1847" title="All 2 branches covered.">                if (workListTop == workList.length) {</span>
<span class="fc" id="L1848">                    SuperBlock[] tmp = new SuperBlock[workListTop * 2];</span>
<span class="fc" id="L1849">                    System.arraycopy(workList, 0, tmp, 0, workListTop);</span>
<span class="fc" id="L1850">                    workList = tmp;</span>
                }
<span class="fc" id="L1852">                workList[workListTop++] = sb;</span>
            }
<span class="fc" id="L1854">        }</span>

        /**
         * Execute a single byte code instruction.
         *
         * @param bci the index of the byte code instruction to execute
         * @return the length of the byte code instruction
         */
        private int execute(int bci) {
<span class="fc" id="L1863">            int bc = itsCodeBuffer[bci] &amp; 0xFF;</span>
            int type, type2, index;
<span class="fc" id="L1865">            int length = 0;</span>
            long lType, lType2;
            String className;

<span class="pc bpc" id="L1869" title="23 of 52 branches missed.">            switch (bc) {</span>
                case ByteCode.NOP:
                case ByteCode.IINC:
                case ByteCode.GOTO:
                case ByteCode.GOTO_W:
                    // No change
<span class="fc" id="L1875">                    break;</span>
                case ByteCode.CHECKCAST:
<span class="nc" id="L1877">                    pop();</span>
<span class="nc" id="L1878">                    push(TypeInfo.OBJECT(getOperand(bci + 1, 2)));</span>
<span class="nc" id="L1879">                    break;</span>
                case ByteCode.IASTORE: // pop; pop; pop
                case ByteCode.LASTORE:
                case ByteCode.FASTORE:
                case ByteCode.DASTORE:
                case ByteCode.AASTORE:
                case ByteCode.BASTORE:
                case ByteCode.CASTORE:
                case ByteCode.SASTORE:
<span class="fc" id="L1888">                    pop();</span>
                    // fallthru
                case ByteCode.PUTFIELD: // pop; pop
                case ByteCode.IF_ICMPEQ:
                case ByteCode.IF_ICMPNE:
                case ByteCode.IF_ICMPLT:
                case ByteCode.IF_ICMPGE:
                case ByteCode.IF_ICMPGT:
                case ByteCode.IF_ICMPLE:
                case ByteCode.IF_ACMPEQ:
                case ByteCode.IF_ACMPNE:
<span class="fc" id="L1899">                    pop();</span>
                    // fallthru
                case ByteCode.IFEQ: // pop
                case ByteCode.IFNE:
                case ByteCode.IFLT:
                case ByteCode.IFGE:
                case ByteCode.IFGT:
                case ByteCode.IFLE:
                case ByteCode.IFNULL:
                case ByteCode.IFNONNULL:
                case ByteCode.POP:
                case ByteCode.MONITORENTER:
                case ByteCode.MONITOREXIT:
                case ByteCode.PUTSTATIC:
<span class="fc" id="L1913">                    pop();</span>
<span class="fc" id="L1914">                    break;</span>
                case ByteCode.POP2:
<span class="nc" id="L1916">                    pop2();</span>
<span class="nc" id="L1917">                    break;</span>
                case ByteCode.ACONST_NULL:
<span class="fc" id="L1919">                    push(TypeInfo.NULL);</span>
<span class="fc" id="L1920">                    break;</span>
                case ByteCode.IALOAD: // pop; pop; push(INTEGER)
                case ByteCode.BALOAD:
                case ByteCode.CALOAD:
                case ByteCode.SALOAD:
                case ByteCode.IADD:
                case ByteCode.ISUB:
                case ByteCode.IMUL:
                case ByteCode.IDIV:
                case ByteCode.IREM:
                case ByteCode.ISHL:
                case ByteCode.ISHR:
                case ByteCode.IUSHR:
                case ByteCode.IAND:
                case ByteCode.IOR:
                case ByteCode.IXOR:
                case ByteCode.LCMP:
                case ByteCode.FCMPL:
                case ByteCode.FCMPG:
                case ByteCode.DCMPL:
                case ByteCode.DCMPG:
<span class="fc" id="L1941">                    pop();</span>
                    // fallthru
                case ByteCode.INEG: // pop; push(INTEGER)
                case ByteCode.L2I:
                case ByteCode.F2I:
                case ByteCode.D2I:
                case ByteCode.I2B:
                case ByteCode.I2C:
                case ByteCode.I2S:
                case ByteCode.ARRAYLENGTH:
                case ByteCode.INSTANCEOF:
<span class="fc" id="L1952">                    pop();</span>
                    // fallthru
                case ByteCode.ICONST_M1: // push(INTEGER)
                case ByteCode.ICONST_0:
                case ByteCode.ICONST_1:
                case ByteCode.ICONST_2:
                case ByteCode.ICONST_3:
                case ByteCode.ICONST_4:
                case ByteCode.ICONST_5:
                case ByteCode.ILOAD:
                case ByteCode.ILOAD_0:
                case ByteCode.ILOAD_1:
                case ByteCode.ILOAD_2:
                case ByteCode.ILOAD_3:
                case ByteCode.BIPUSH:
                case ByteCode.SIPUSH:
<span class="fc" id="L1968">                    push(TypeInfo.INTEGER);</span>
<span class="fc" id="L1969">                    break;</span>
                case ByteCode.LALOAD: // pop; pop; push(LONG)
                case ByteCode.LADD:
                case ByteCode.LSUB:
                case ByteCode.LMUL:
                case ByteCode.LDIV:
                case ByteCode.LREM:
                case ByteCode.LSHL:
                case ByteCode.LSHR:
                case ByteCode.LUSHR:
                case ByteCode.LAND:
                case ByteCode.LOR:
                case ByteCode.LXOR:
<span class="nc" id="L1982">                    pop();</span>
                    // fallthru
                case ByteCode.LNEG: // pop; push(LONG)
                case ByteCode.I2L:
                case ByteCode.F2L:
                case ByteCode.D2L:
<span class="nc" id="L1988">                    pop();</span>
                    // fallthru
                case ByteCode.LCONST_0: // push(LONG)
                case ByteCode.LCONST_1:
                case ByteCode.LLOAD:
                case ByteCode.LLOAD_0:
                case ByteCode.LLOAD_1:
                case ByteCode.LLOAD_2:
                case ByteCode.LLOAD_3:
<span class="nc" id="L1997">                    push(TypeInfo.LONG);</span>
<span class="nc" id="L1998">                    break;</span>
                case ByteCode.FALOAD: // pop; pop; push(FLOAT)
                case ByteCode.FADD:
                case ByteCode.FSUB:
                case ByteCode.FMUL:
                case ByteCode.FDIV:
                case ByteCode.FREM:
<span class="nc" id="L2005">                    pop();</span>
                    // fallthru
                case ByteCode.FNEG: // pop; push(FLOAT)
                case ByteCode.I2F:
                case ByteCode.L2F:
                case ByteCode.D2F:
<span class="nc" id="L2011">                    pop();</span>
                    // fallthru
                case ByteCode.FCONST_0: // push(FLOAT)
                case ByteCode.FCONST_1:
                case ByteCode.FCONST_2:
                case ByteCode.FLOAD:
                case ByteCode.FLOAD_0:
                case ByteCode.FLOAD_1:
                case ByteCode.FLOAD_2:
                case ByteCode.FLOAD_3:
<span class="nc" id="L2021">                    push(TypeInfo.FLOAT);</span>
<span class="nc" id="L2022">                    break;</span>
                case ByteCode.DALOAD: // pop; pop; push(DOUBLE)
                case ByteCode.DADD:
                case ByteCode.DSUB:
                case ByteCode.DMUL:
                case ByteCode.DDIV:
                case ByteCode.DREM:
<span class="fc" id="L2029">                    pop();</span>
                    // fallthru
                case ByteCode.DNEG: // pop; push(DOUBLE)
                case ByteCode.I2D:
                case ByteCode.L2D:
                case ByteCode.F2D:
<span class="fc" id="L2035">                    pop();</span>
                    // fallthru
                case ByteCode.DCONST_0: // push(DOUBLE)
                case ByteCode.DCONST_1:
                case ByteCode.DLOAD:
                case ByteCode.DLOAD_0:
                case ByteCode.DLOAD_1:
                case ByteCode.DLOAD_2:
                case ByteCode.DLOAD_3:
<span class="fc" id="L2044">                    push(TypeInfo.DOUBLE);</span>
<span class="fc" id="L2045">                    break;</span>
                case ByteCode.ISTORE:
<span class="nc bnc" id="L2047" title="All 2 branches missed.">                    executeStore(getOperand(bci + 1, wide ? 2 : 1), TypeInfo.INTEGER);</span>
<span class="nc" id="L2048">                    break;</span>
                case ByteCode.ISTORE_0:
                case ByteCode.ISTORE_1:
                case ByteCode.ISTORE_2:
                case ByteCode.ISTORE_3:
<span class="nc" id="L2053">                    executeStore(bc - ByteCode.ISTORE_0, TypeInfo.INTEGER);</span>
<span class="nc" id="L2054">                    break;</span>
                case ByteCode.LSTORE:
<span class="nc bnc" id="L2056" title="All 2 branches missed.">                    executeStore(getOperand(bci + 1, wide ? 2 : 1), TypeInfo.LONG);</span>
<span class="nc" id="L2057">                    break;</span>
                case ByteCode.LSTORE_0:
                case ByteCode.LSTORE_1:
                case ByteCode.LSTORE_2:
                case ByteCode.LSTORE_3:
<span class="nc" id="L2062">                    executeStore(bc - ByteCode.LSTORE_0, TypeInfo.LONG);</span>
<span class="nc" id="L2063">                    break;</span>
                case ByteCode.FSTORE:
<span class="nc bnc" id="L2065" title="All 2 branches missed.">                    executeStore(getOperand(bci + 1, wide ? 2 : 1), TypeInfo.FLOAT);</span>
<span class="nc" id="L2066">                    break;</span>
                case ByteCode.FSTORE_0:
                case ByteCode.FSTORE_1:
                case ByteCode.FSTORE_2:
                case ByteCode.FSTORE_3:
<span class="nc" id="L2071">                    executeStore(bc - ByteCode.FSTORE_0, TypeInfo.FLOAT);</span>
<span class="nc" id="L2072">                    break;</span>
                case ByteCode.DSTORE:
<span class="nc bnc" id="L2074" title="All 2 branches missed.">                    executeStore(getOperand(bci + 1, wide ? 2 : 1), TypeInfo.DOUBLE);</span>
<span class="nc" id="L2075">                    break;</span>
                case ByteCode.DSTORE_0:
                case ByteCode.DSTORE_1:
                case ByteCode.DSTORE_2:
                case ByteCode.DSTORE_3:
<span class="nc" id="L2080">                    executeStore(bc - ByteCode.DSTORE_0, TypeInfo.DOUBLE);</span>
<span class="nc" id="L2081">                    break;</span>
                case ByteCode.ALOAD:
<span class="pc bpc" id="L2083" title="1 of 2 branches missed.">                    executeALoad(getOperand(bci + 1, wide ? 2 : 1));</span>
<span class="fc" id="L2084">                    break;</span>
                case ByteCode.ALOAD_0:
                case ByteCode.ALOAD_1:
                case ByteCode.ALOAD_2:
                case ByteCode.ALOAD_3:
<span class="fc" id="L2089">                    executeALoad(bc - ByteCode.ALOAD_0);</span>
<span class="fc" id="L2090">                    break;</span>
                case ByteCode.ASTORE:
<span class="pc bpc" id="L2092" title="1 of 2 branches missed.">                    executeAStore(getOperand(bci + 1, wide ? 2 : 1));</span>
<span class="fc" id="L2093">                    break;</span>
                case ByteCode.ASTORE_0:
                case ByteCode.ASTORE_1:
                case ByteCode.ASTORE_2:
                case ByteCode.ASTORE_3:
<span class="fc" id="L2098">                    executeAStore(bc - ByteCode.ASTORE_0);</span>
<span class="fc" id="L2099">                    break;</span>
                case ByteCode.IRETURN:
                case ByteCode.LRETURN:
                case ByteCode.FRETURN:
                case ByteCode.DRETURN:
                case ByteCode.ARETURN:
                case ByteCode.RETURN:
<span class="fc" id="L2106">                    clearStack();</span>
<span class="fc" id="L2107">                    break;</span>
                case ByteCode.ATHROW:
<span class="fc" id="L2109">                    type = pop();</span>
<span class="fc" id="L2110">                    clearStack();</span>
<span class="fc" id="L2111">                    push(type);</span>
<span class="fc" id="L2112">                    break;</span>
                case ByteCode.SWAP:
<span class="fc" id="L2114">                    type = pop();</span>
<span class="fc" id="L2115">                    type2 = pop();</span>
<span class="fc" id="L2116">                    push(type);</span>
<span class="fc" id="L2117">                    push(type2);</span>
<span class="fc" id="L2118">                    break;</span>
                case ByteCode.LDC:
                case ByteCode.LDC_W:
                case ByteCode.LDC2_W:
<span class="fc bfc" id="L2122" title="All 2 branches covered.">                    if (bc == ByteCode.LDC) {</span>
<span class="fc" id="L2123">                        index = getOperand(bci + 1);</span>
                    } else {
<span class="fc" id="L2125">                        index = getOperand(bci + 1, 2);</span>
                    }
<span class="fc" id="L2127">                    byte constType = itsConstantPool.getConstantType(index);</span>
<span class="pc bpc" id="L2128" title="3 of 6 branches missed.">                    switch (constType) {</span>
                        case ConstantPool.CONSTANT_Double:
<span class="fc" id="L2130">                            push(TypeInfo.DOUBLE);</span>
<span class="fc" id="L2131">                            break;</span>
                        case ConstantPool.CONSTANT_Float:
<span class="nc" id="L2133">                            push(TypeInfo.FLOAT);</span>
<span class="nc" id="L2134">                            break;</span>
                        case ConstantPool.CONSTANT_Long:
<span class="nc" id="L2136">                            push(TypeInfo.LONG);</span>
<span class="nc" id="L2137">                            break;</span>
                        case ConstantPool.CONSTANT_Integer:
<span class="fc" id="L2139">                            push(TypeInfo.INTEGER);</span>
<span class="fc" id="L2140">                            break;</span>
                        case ConstantPool.CONSTANT_String:
<span class="fc" id="L2142">                            push(TypeInfo.OBJECT(&quot;java/lang/String&quot;,</span>
<span class="fc" id="L2143">                                itsConstantPool));</span>
<span class="fc" id="L2144">                            break;</span>
                        default:
<span class="nc" id="L2146">                            throw new IllegalArgumentException(</span>
                                &quot;bad const type &quot; + constType);
                    }
                    break;
                case ByteCode.NEW:
<span class="fc" id="L2151">                    push(TypeInfo.UNINITIALIZED_VARIABLE(bci));</span>
<span class="fc" id="L2152">                    break;</span>
                case ByteCode.NEWARRAY:
<span class="nc" id="L2154">                    pop();</span>
<span class="nc" id="L2155">                    char componentType =</span>
<span class="nc" id="L2156">                        arrayTypeToName(itsCodeBuffer[bci + 1]);</span>
<span class="nc" id="L2157">                    index = itsConstantPool.addClass(&quot;[&quot; + componentType);</span>
<span class="nc" id="L2158">                    push(TypeInfo.OBJECT((short) index));</span>
<span class="nc" id="L2159">                    break;</span>
                case ByteCode.ANEWARRAY:
<span class="fc" id="L2161">                    index = getOperand(bci + 1, 2);</span>
<span class="fc" id="L2162">                    className = (String) itsConstantPool.getConstantData(index);</span>
<span class="fc" id="L2163">                    pop();</span>
<span class="fc" id="L2164">                    push(TypeInfo.OBJECT(&quot;[L&quot; + className + ';',</span>
<span class="fc" id="L2165">                        itsConstantPool));</span>
<span class="fc" id="L2166">                    break;</span>
                case ByteCode.INVOKEVIRTUAL:
                case ByteCode.INVOKESPECIAL:
                case ByteCode.INVOKESTATIC:
                case ByteCode.INVOKEINTERFACE:
<span class="fc" id="L2171">                    index = getOperand(bci + 1, 2);</span>
<span class="fc" id="L2172">                    FieldOrMethodRef m = (FieldOrMethodRef)</span>
<span class="fc" id="L2173">                        itsConstantPool.getConstantData(index);</span>
<span class="fc" id="L2174">                    String methodType = m.getType();</span>
<span class="fc" id="L2175">                    String methodName = m.getName();</span>
<span class="fc" id="L2176">                    int parameterCount = sizeOfParameters(methodType) &gt;&gt;&gt; 16;</span>
<span class="fc bfc" id="L2177" title="All 2 branches covered.">                    for (int i = 0; i &lt; parameterCount; i++) {</span>
<span class="fc" id="L2178">                        pop();</span>
                    }
<span class="fc bfc" id="L2180" title="All 2 branches covered.">                    if (bc != ByteCode.INVOKESTATIC) {</span>
<span class="fc" id="L2181">                        int instType = pop();</span>
<span class="fc" id="L2182">                        int tag = TypeInfo.getTag(instType);</span>
<span class="fc bfc" id="L2183" title="All 4 branches covered.">                        if (tag == TypeInfo.UNINITIALIZED_VARIABLE(0) ||</span>
                            tag == TypeInfo.UNINITIALIZED_THIS) {
<span class="pc bpc" id="L2185" title="1 of 2 branches missed.">                            if (&quot;&lt;init&gt;&quot;.equals(methodName)) {</span>
<span class="fc" id="L2186">                                int newType =</span>
<span class="fc" id="L2187">                                    TypeInfo.OBJECT(itsThisClassIndex);</span>
<span class="fc" id="L2188">                                initializeTypeInfo(instType, newType);</span>
<span class="fc" id="L2189">                            } else {</span>
<span class="nc" id="L2190">                                throw new IllegalStateException(&quot;bad instance&quot;);</span>
                            }
                        }
                    }
<span class="fc" id="L2194">                    int rParen = methodType.indexOf(')');</span>
<span class="fc" id="L2195">                    String returnType = methodType.substring(rParen + 1);</span>
<span class="fc" id="L2196">                    returnType = descriptorToInternalName(returnType);</span>
<span class="fc bfc" id="L2197" title="All 2 branches covered.">                    if (!returnType.equals(&quot;V&quot;)) {</span>
<span class="fc" id="L2198">                        push(TypeInfo.fromType(returnType, itsConstantPool));</span>
                    }
                    break;
                case ByteCode.INVOKEDYNAMIC:
<span class="nc" id="L2202">                    index = getOperand(bci + 1, 2);</span>
<span class="nc" id="L2203">                    methodType = (String) itsConstantPool.getConstantData(index);</span>
<span class="nc" id="L2204">                    parameterCount = sizeOfParameters(methodType) &gt;&gt;&gt; 16;</span>
<span class="nc bnc" id="L2205" title="All 2 branches missed.">                    for (int i = 0; i &lt; parameterCount; i++) {</span>
<span class="nc" id="L2206">                        pop();</span>
                    }
<span class="nc" id="L2208">                    rParen = methodType.indexOf(')');</span>
<span class="nc" id="L2209">                    returnType = methodType.substring(rParen + 1);</span>
<span class="nc" id="L2210">                    returnType = descriptorToInternalName(returnType);</span>
<span class="nc bnc" id="L2211" title="All 2 branches missed.">                    if (!returnType.equals(&quot;V&quot;)) {</span>
<span class="nc" id="L2212">                        push(TypeInfo.fromType(returnType, itsConstantPool));</span>
                    }
                    break;
                case ByteCode.GETFIELD:
<span class="fc" id="L2216">                    pop();</span>
                    // fallthru
                case ByteCode.GETSTATIC:
<span class="fc" id="L2219">                    index = getOperand(bci + 1, 2);</span>
<span class="fc" id="L2220">                    FieldOrMethodRef f = (FieldOrMethodRef)</span>
<span class="fc" id="L2221">                        itsConstantPool.getConstantData(index);</span>
<span class="fc" id="L2222">                    String fieldType = descriptorToInternalName(f.getType());</span>
<span class="fc" id="L2223">                    push(TypeInfo.fromType(fieldType, itsConstantPool));</span>
<span class="fc" id="L2224">                    break;</span>
                case ByteCode.DUP:
<span class="fc" id="L2226">                    type = pop();</span>
<span class="fc" id="L2227">                    push(type);</span>
<span class="fc" id="L2228">                    push(type);</span>
<span class="fc" id="L2229">                    break;</span>
                case ByteCode.DUP_X1:
<span class="fc" id="L2231">                    type = pop();</span>
<span class="fc" id="L2232">                    type2 = pop();</span>
<span class="fc" id="L2233">                    push(type);</span>
<span class="fc" id="L2234">                    push(type2);</span>
<span class="fc" id="L2235">                    push(type);</span>
<span class="fc" id="L2236">                    break;</span>
                case ByteCode.DUP_X2:
<span class="nc" id="L2238">                    type = pop();</span>
<span class="nc" id="L2239">                    lType = pop2();</span>
<span class="nc" id="L2240">                    push(type);</span>
<span class="nc" id="L2241">                    push2(lType);</span>
<span class="nc" id="L2242">                    push(type);</span>
<span class="nc" id="L2243">                    break;</span>
                case ByteCode.DUP2:
<span class="fc" id="L2245">                    lType = pop2();</span>
<span class="fc" id="L2246">                    push2(lType);</span>
<span class="fc" id="L2247">                    push2(lType);</span>
<span class="fc" id="L2248">                    break;</span>
                case ByteCode.DUP2_X1:
<span class="nc" id="L2250">                    lType = pop2();</span>
<span class="nc" id="L2251">                    type = pop();</span>
<span class="nc" id="L2252">                    push2(lType);</span>
<span class="nc" id="L2253">                    push(type);</span>
<span class="nc" id="L2254">                    push2(lType);</span>
<span class="nc" id="L2255">                    break;</span>
                case ByteCode.DUP2_X2:
<span class="nc" id="L2257">                    lType = pop2();</span>
<span class="nc" id="L2258">                    lType2 = pop2();</span>
<span class="nc" id="L2259">                    push2(lType);</span>
<span class="nc" id="L2260">                    push2(lType2);</span>
<span class="nc" id="L2261">                    push2(lType);</span>
<span class="nc" id="L2262">                    break;</span>
                case ByteCode.TABLESWITCH:
<span class="fc" id="L2264">                    int switchStart = bci + 1 + (3 &amp; ~bci);</span>
<span class="fc" id="L2265">                    int low = getOperand(switchStart + 4, 4);</span>
<span class="fc" id="L2266">                    int high = getOperand(switchStart + 8, 4);</span>
<span class="fc" id="L2267">                    length = 4 * (high - low + 4) + switchStart - bci;</span>
<span class="fc" id="L2268">                    pop();</span>
<span class="fc" id="L2269">                    break;</span>
                case ByteCode.AALOAD:
<span class="fc" id="L2271">                    pop();</span>
<span class="fc" id="L2272">                    int typeIndex = pop() &gt;&gt;&gt; 8;</span>
<span class="fc" id="L2273">                    className =</span>
<span class="fc" id="L2274">                        (String) itsConstantPool.getConstantData(typeIndex);</span>
<span class="fc" id="L2275">                    String arrayType = className;</span>
<span class="pc bpc" id="L2276" title="1 of 2 branches missed.">                    if (arrayType.charAt(0) != '[') {</span>
<span class="nc" id="L2277">                        throw new IllegalStateException(&quot;bad array type&quot;);</span>
                    }
<span class="fc" id="L2279">                    String elementDesc = arrayType.substring(1);</span>
<span class="fc" id="L2280">                    String elementType = descriptorToInternalName(elementDesc);</span>
<span class="fc" id="L2281">                    typeIndex = itsConstantPool.addClass(elementType);</span>
<span class="fc" id="L2282">                    push(TypeInfo.OBJECT(typeIndex));</span>
<span class="fc" id="L2283">                    break;</span>
                case ByteCode.WIDE:
                    // Alters behaviour of next instruction
<span class="nc" id="L2286">                    wide = true;</span>
<span class="nc" id="L2287">                    break;</span>
                case ByteCode.MULTIANEWARRAY:
                case ByteCode.LOOKUPSWITCH:
                    // Currently not used in any part of Rhino, so ignore it
                case ByteCode.JSR: // TODO: JSR is deprecated
                case ByteCode.RET:
                case ByteCode.JSR_W:
                default:
<span class="nc" id="L2295">                    throw new IllegalArgumentException(&quot;bad opcode: &quot; + bc);</span>
            }

<span class="fc bfc" id="L2298" title="All 2 branches covered.">            if (length == 0) {</span>
<span class="fc" id="L2299">                length = opcodeLength(bc, wide);</span>
            }
<span class="pc bpc" id="L2301" title="3 of 4 branches missed.">            if (wide &amp;&amp; bc != ByteCode.WIDE) {</span>
<span class="nc" id="L2302">                wide = false;</span>
            }
<span class="fc" id="L2304">            return length;</span>
        }

        private void executeALoad(int localIndex) {
<span class="fc" id="L2308">            int type = getLocal(localIndex);</span>
<span class="fc" id="L2309">            int tag = TypeInfo.getTag(type);</span>
<span class="pc bpc" id="L2310" title="5 of 8 branches missed.">            if (tag == TypeInfo.OBJECT_TAG ||</span>
                tag == TypeInfo.UNINITIALIZED_THIS ||
                tag == TypeInfo.UNINITIALIZED_VAR_TAG ||
                tag == TypeInfo.NULL) {
<span class="fc" id="L2314">                push(type);</span>
            } else {
<span class="nc" id="L2316">                throw new IllegalStateException(&quot;bad local variable type: &quot; +</span>
                    type + &quot; at index: &quot; +
                    localIndex);
            }
<span class="fc" id="L2320">        }</span>

        private void executeAStore(int localIndex) {
<span class="fc" id="L2323">            setLocal(localIndex, pop());</span>
<span class="fc" id="L2324">        }</span>

        private void executeStore(int localIndex, int typeInfo) {
<span class="nc" id="L2327">            pop();</span>
<span class="nc" id="L2328">            setLocal(localIndex, typeInfo);</span>
<span class="nc" id="L2329">        }</span>

        /**
         * Change an UNINITIALIZED_OBJECT or UNINITIALIZED_THIS to the proper type of the object. This
         * occurs when the proper constructor is invoked.
         */
        private void initializeTypeInfo(int prevType, int newType) {
<span class="fc" id="L2336">            initializeTypeInfo(prevType, newType, locals, localsTop);</span>
<span class="fc" id="L2337">            initializeTypeInfo(prevType, newType, stack, stackTop);</span>
<span class="fc" id="L2338">        }</span>

        private void initializeTypeInfo(int prevType, int newType, int[] data,
            int dataTop) {
<span class="fc bfc" id="L2342" title="All 2 branches covered.">            for (int i = 0; i &lt; dataTop; i++) {</span>
<span class="fc bfc" id="L2343" title="All 2 branches covered.">                if (data[i] == prevType) {</span>
<span class="fc" id="L2344">                    data[i] = newType;</span>
                }
            }
<span class="fc" id="L2347">        }</span>

        private int getLocal(int localIndex) {
<span class="pc bpc" id="L2350" title="1 of 2 branches missed.">            if (localIndex &lt; localsTop) {</span>
<span class="fc" id="L2351">                return locals[localIndex];</span>
            } else {
<span class="nc" id="L2353">                return TypeInfo.TOP;</span>
            }
        }

        private void setLocal(int localIndex, int typeInfo) {
<span class="pc bpc" id="L2358" title="1 of 2 branches missed.">            if (localIndex &gt;= localsTop) {</span>
<span class="nc" id="L2359">                int[] tmp = new int[localIndex + 1];</span>
<span class="nc" id="L2360">                System.arraycopy(locals, 0, tmp, 0, localsTop);</span>
<span class="nc" id="L2361">                locals = tmp;</span>
<span class="nc" id="L2362">                localsTop = localIndex + 1;</span>
            }
<span class="fc" id="L2364">            locals[localIndex] = typeInfo;</span>
<span class="fc" id="L2365">        }</span>

        private void push(int typeInfo) {
<span class="fc bfc" id="L2368" title="All 2 branches covered.">            if (stackTop == stack.length) {</span>
<span class="fc" id="L2369">                int[] tmp = new int[Math.max(stackTop * 2, 4)];</span>
<span class="fc" id="L2370">                System.arraycopy(stack, 0, tmp, 0, stackTop);</span>
<span class="fc" id="L2371">                stack = tmp;</span>
            }
<span class="fc" id="L2373">            stack[stackTop++] = typeInfo;</span>
<span class="fc" id="L2374">        }</span>

        private int pop() {
<span class="fc" id="L2377">            return stack[--stackTop];</span>
        }

        /**
         * Push two words onto the op stack.
         *
         * This is only meant to be used as a complement to pop2(), and both methods are helpers for the
         * more complex DUP operations.
         */
        private void push2(long typeInfo) {
<span class="fc" id="L2387">            push((int) (typeInfo &amp; 0xFFFFFF));</span>
<span class="fc" id="L2388">            typeInfo &gt;&gt;&gt;= 32;</span>
<span class="pc bpc" id="L2389" title="1 of 2 branches missed.">            if (typeInfo != 0) {</span>
<span class="nc" id="L2390">                push((int) (typeInfo &amp; 0xFFFFFF));</span>
            }
<span class="fc" id="L2392">        }</span>

        /**
         * Pop two words from the op stack.
         *
         * If the top of the stack is a DOUBLE or LONG, then the bottom 32 bits reflects the appropriate
         * type and the top 32 bits are 0. Otherwise, the top 32 bits are the first word on the stack
         * and the lower 32 bits are the second word on the stack.
         */
        private long pop2() {
<span class="fc" id="L2402">            long type = pop();</span>
<span class="pc bpc" id="L2403" title="1 of 2 branches missed.">            if (TypeInfo.isTwoWords((int) type)) {</span>
<span class="fc" id="L2404">                return type;</span>
            } else {
<span class="nc" id="L2406">                return type &lt;&lt; 32 | (pop() &amp; 0xFFFFFF);</span>
            }
        }

        private void clearStack() {
<span class="fc" id="L2411">            stackTop = 0;</span>
<span class="fc" id="L2412">        }</span>

        /**
         * Compute the output size of the stack map table.
         *
         * Because this would share much in common with actual writing of the stack map table, we
         * instead just write the stack map table to a buffer and return the size from it. The buffer is
         * later used in the actual writing of bytecode.
         */
        int computeWriteSize() {
            // Allocate a buffer that can handle the worst case size of the
            // stack map to prevent lots of reallocations.
<span class="fc" id="L2424">            int writeSize = getWorstCaseWriteSize();</span>
<span class="fc" id="L2425">            rawStackMap = new byte[writeSize];</span>
<span class="fc" id="L2426">            computeRawStackMap();</span>
<span class="fc" id="L2427">            return rawStackMapTop + 2;</span>
        }

        int write(byte[] data, int offset) {
<span class="fc" id="L2431">            offset = putInt32(rawStackMapTop + 2, data, offset);</span>
<span class="fc" id="L2432">            offset = putInt16(superBlocks.length - 1, data, offset);</span>
<span class="fc" id="L2433">            System.arraycopy(rawStackMap, 0, data, offset, rawStackMapTop);</span>
<span class="fc" id="L2434">            return offset + rawStackMapTop;</span>
        }

        /**
         * Compute a space-optimal stack map table.
         */
        private void computeRawStackMap() {
<span class="fc" id="L2441">            SuperBlock prev = superBlocks[0];</span>
<span class="fc" id="L2442">            int[] prevLocals = prev.getTrimmedLocals();</span>
<span class="fc" id="L2443">            int prevOffset = -1;</span>
<span class="fc bfc" id="L2444" title="All 2 branches covered.">            for (int i = 1; i &lt; superBlocks.length; i++) {</span>
<span class="fc" id="L2445">                SuperBlock current = superBlocks[i];</span>
<span class="fc" id="L2446">                int[] currentLocals = current.getTrimmedLocals();</span>
<span class="fc" id="L2447">                int[] currentStack = current.getStack();</span>
<span class="fc" id="L2448">                int offsetDelta = current.getStart() - prevOffset - 1;</span>

<span class="fc bfc" id="L2450" title="All 2 branches covered.">                if (currentStack.length == 0) {</span>
<span class="fc bfc" id="L2451" title="All 2 branches covered.">                    int last = prevLocals.length &gt; currentLocals.length ?</span>
                        currentLocals.length : prevLocals.length;
<span class="fc" id="L2453">                    int delta = Math.abs(prevLocals.length -</span>
                        currentLocals.length);
                    int j;
                    // Compare locals until one is different or the end of a
                    // local variable array is reached
<span class="fc bfc" id="L2458" title="All 2 branches covered.">                    for (j = 0; j &lt; last; j++) {</span>
<span class="fc bfc" id="L2459" title="All 2 branches covered.">                        if (prevLocals[j] != currentLocals[j]) {</span>
<span class="fc" id="L2460">                            break;</span>
                        }
                    }
<span class="fc bfc" id="L2463" title="All 4 branches covered.">                    if (j == currentLocals.length &amp;&amp; delta == 0) {</span>
                        // All of the compared locals are equal and the local
                        // arrays are of equal size
<span class="fc" id="L2466">                        writeSameFrame(currentLocals, offsetDelta);</span>
<span class="pc bpc" id="L2467" title="1 of 4 branches missed.">                    } else if (j == currentLocals.length &amp;&amp; delta &lt;= 3) {</span>
                        // All of the compared locals are equal and the current
                        // frame has less locals than the previous frame
<span class="fc" id="L2470">                        writeChopFrame(delta, offsetDelta);</span>
<span class="fc bfc" id="L2471" title="All 4 branches covered.">                    } else if (j == prevLocals.length &amp;&amp; delta &lt;= 3) {</span>
                        // All of the compared locals are equal and the current
                        // frame has more locals than the previous frame
<span class="fc" id="L2474">                        writeAppendFrame(currentLocals, delta, offsetDelta);</span>
                    } else {
                        // Not all locals were compared were equal, so a full
                        // frame is necessary
<span class="fc" id="L2478">                        writeFullFrame(currentLocals, currentStack,</span>
                            offsetDelta);
                    }
<span class="fc bfc" id="L2481" title="All 2 branches covered.">                } else if (currentStack.length == 1) {</span>
<span class="fc bfc" id="L2482" title="All 2 branches covered.">                    if (Arrays.equals(prevLocals, currentLocals)) {</span>
<span class="fc" id="L2483">                        writeSameLocalsOneStackItemFrame(currentLocals,</span>
                            currentStack,
                            offsetDelta);
                    } else {
                        // Output a full frame, since no other frame types have
                        // one operand stack item.
<span class="fc" id="L2489">                        writeFullFrame(currentLocals, currentStack,</span>
                            offsetDelta);
                    }
                } else {
                    // Any stack map frame that has more than one operand stack
                    // item has to be a full frame. All other frame types have
                    // at most one item on the stack.
<span class="fc" id="L2496">                    writeFullFrame(currentLocals, currentStack, offsetDelta);</span>
                }

<span class="fc" id="L2499">                prev = current;</span>
<span class="fc" id="L2500">                prevLocals = currentLocals;</span>
<span class="fc" id="L2501">                prevOffset = current.getStart();</span>
            }
<span class="fc" id="L2503">        }</span>

        /**
         * Get the worst case write size of the stack map table.
         *
         * This computes how much full frames would take, if each full frame contained the maximum
         * number of locals and stack operands, and each verification type was 3 bytes.
         */
        private int getWorstCaseWriteSize() {
<span class="fc" id="L2512">            return (superBlocks.length - 1) * (7 + itsMaxLocals * 3 +</span>
<span class="fc" id="L2513">                itsMaxStack * 3);</span>
        }

        private void writeSameFrame(int[] locals, int offsetDelta) {
<span class="fc bfc" id="L2517" title="All 2 branches covered.">            if (offsetDelta &lt;= 63) {</span>
                // Output a same_frame frame. Despite the name,
                // the operand stack may differ, but the current
                // operand stack must be empty.
<span class="fc" id="L2521">                rawStackMap[rawStackMapTop++] = (byte) offsetDelta;</span>
            } else {
                // Output a same_frame_extended frame. Similar to
                // the above, except with a larger offset delta.
<span class="fc" id="L2525">                rawStackMap[rawStackMapTop++] = (byte) 251;</span>
<span class="fc" id="L2526">                rawStackMapTop = putInt16(offsetDelta, rawStackMap,</span>
                    rawStackMapTop);
            }
<span class="fc" id="L2529">        }</span>

        private void writeSameLocalsOneStackItemFrame(int[] locals,
            int[] stack,
            int offsetDelta) {
<span class="fc bfc" id="L2534" title="All 2 branches covered.">            if (offsetDelta &lt;= 63) {</span>
                // Output a same_locals_1_stack_item frame. Similar
                // to same_frame, only with one item on the operand
                // stack instead of zero.
<span class="fc" id="L2538">                rawStackMap[rawStackMapTop++] = (byte) (64 + offsetDelta);</span>
            } else {
                // Output a same_locals_1_stack_item_extended frame.
                // Similar to same_frame_extended, only with one
                // item on the operand stack instead of zero.
<span class="fc" id="L2543">                rawStackMap[rawStackMapTop++] = (byte) 247;</span>
<span class="fc" id="L2544">                rawStackMapTop = putInt16(offsetDelta, rawStackMap,</span>
                    rawStackMapTop);
            }
<span class="fc" id="L2547">            writeType(stack[0]);</span>
<span class="fc" id="L2548">        }</span>

        private void writeFullFrame(int[] locals, int[] stack,
            int offsetDelta) {
<span class="fc" id="L2552">            rawStackMap[rawStackMapTop++] = (byte) 255;</span>
<span class="fc" id="L2553">            rawStackMapTop = putInt16(offsetDelta, rawStackMap, rawStackMapTop);</span>
<span class="fc" id="L2554">            rawStackMapTop = putInt16(locals.length, rawStackMap,</span>
                rawStackMapTop);
<span class="fc" id="L2556">            rawStackMapTop = writeTypes(locals);</span>
<span class="fc" id="L2557">            rawStackMapTop = putInt16(stack.length, rawStackMap,</span>
                rawStackMapTop);
<span class="fc" id="L2559">            rawStackMapTop = writeTypes(stack);</span>
<span class="fc" id="L2560">        }</span>

        private void writeAppendFrame(int[] locals, int localsDelta,
            int offsetDelta) {
<span class="fc" id="L2564">            int start = locals.length - localsDelta;</span>
<span class="fc" id="L2565">            rawStackMap[rawStackMapTop++] = (byte) (251 + localsDelta);</span>
<span class="fc" id="L2566">            rawStackMapTop = putInt16(offsetDelta, rawStackMap, rawStackMapTop);</span>
<span class="fc" id="L2567">            rawStackMapTop = writeTypes(locals, start);</span>
<span class="fc" id="L2568">        }</span>

        private void writeChopFrame(int localsDelta, int offsetDelta) {
<span class="fc" id="L2571">            rawStackMap[rawStackMapTop++] = (byte) (251 - localsDelta);</span>
<span class="fc" id="L2572">            rawStackMapTop = putInt16(offsetDelta, rawStackMap, rawStackMapTop);</span>
<span class="fc" id="L2573">        }</span>

        private int writeTypes(int[] types) {
<span class="fc" id="L2576">            return writeTypes(types, 0);</span>
        }

        private int writeTypes(int[] types, int start) {
<span class="fc" id="L2580">            int startOffset = rawStackMapTop;</span>
<span class="fc bfc" id="L2581" title="All 2 branches covered.">            for (int i = start; i &lt; types.length; i++) {</span>
<span class="fc" id="L2582">                rawStackMapTop = writeType(types[i]);</span>
            }
<span class="fc" id="L2584">            return rawStackMapTop;</span>
        }

        private int writeType(int type) {
<span class="fc" id="L2588">            int tag = type &amp; 0xFF;</span>
<span class="fc" id="L2589">            rawStackMap[rawStackMapTop++] = (byte) tag;</span>
<span class="pc bpc" id="L2590" title="1 of 4 branches missed.">            if (tag == TypeInfo.OBJECT_TAG ||</span>
                tag == TypeInfo.UNINITIALIZED_VAR_TAG) {
<span class="fc" id="L2592">                rawStackMapTop = putInt16(type &gt;&gt;&gt; 8, rawStackMap,</span>
                    rawStackMapTop);
            }
<span class="fc" id="L2595">            return rawStackMapTop;</span>
        }

        // Intermediate operand stack and local variable state. During
        // execution of a block, these are initialized to copies of the initial
        // block type state and are modified by the actual stack/local
        // emulation.
        private int[] locals;
        private int localsTop;
        private int[] stack;
        private int stackTop;

        private SuperBlock[] workList;
        private int workListTop;

        private SuperBlock[] superBlocks;
        private SuperBlock[] superBlockDeps;

        private byte[] rawStackMap;
        private int rawStackMapTop;

        private boolean wide;

        static final boolean DEBUGSTACKMAP = false;
    }

    /**
     * Convert a newarray operand into an internal type.
     */
    private static char arrayTypeToName(int type) {
<span class="nc bnc" id="L2625" title="All 9 branches missed.">        switch (type) {</span>
            case ByteCode.T_BOOLEAN:
<span class="nc" id="L2627">                return 'Z';</span>
            case ByteCode.T_CHAR:
<span class="nc" id="L2629">                return 'C';</span>
            case ByteCode.T_FLOAT:
<span class="nc" id="L2631">                return 'F';</span>
            case ByteCode.T_DOUBLE:
<span class="nc" id="L2633">                return 'D';</span>
            case ByteCode.T_BYTE:
<span class="nc" id="L2635">                return 'B';</span>
            case ByteCode.T_SHORT:
<span class="nc" id="L2637">                return 'S';</span>
            case ByteCode.T_INT:
<span class="nc" id="L2639">                return 'I';</span>
            case ByteCode.T_LONG:
<span class="nc" id="L2641">                return 'J';</span>
            default:
<span class="nc" id="L2643">                throw new IllegalArgumentException(&quot;bad operand&quot;);</span>
        }
    }

    /**
     * Convert a class descriptor into an internal name.
     *
     * For example, descriptor Ljava/lang/Object; becomes java/lang/Object.
     */
    private static String classDescriptorToInternalName(String descriptor) {
<span class="fc" id="L2653">        return descriptor.substring(1, descriptor.length() - 1);</span>
    }

    /**
     * Convert a non-method type descriptor into an internal type.
     *
     * @param descriptor the simple type descriptor to convert
     */
    private static String descriptorToInternalName(String descriptor) {
<span class="pc bpc" id="L2662" title="1 of 3 branches missed.">        switch (descriptor.charAt(0)) {</span>
            case 'B':
            case 'C':
            case 'D':
            case 'F':
            case 'I':
            case 'J':
            case 'S':
            case 'Z':
            case 'V':
            case '[':
<span class="fc" id="L2673">                return descriptor;</span>
            case 'L':
<span class="fc" id="L2675">                return classDescriptorToInternalName(descriptor);</span>
            default:
<span class="nc" id="L2677">                throw new IllegalArgumentException(&quot;bad descriptor:&quot; +</span>
                    descriptor);
        }
    }

    /**
     * Compute the initial local variable array for the current method.
     *
     * Creates an array of the size of the method's max locals, regardless of the number of parameters
     * in the method.
     */
    private int[] createInitialLocals() {
<span class="fc" id="L2689">        int[] initialLocals = new int[itsMaxLocals];</span>
<span class="fc" id="L2690">        int localsTop = 0;</span>
        // Instance methods require the first local variable in the array
        // to be &quot;this&quot;. However, if the method being created is a
        // constructor, aka the method is &lt;init&gt;, then the type of &quot;this&quot;
        // should be StackMapTable.UNINITIALIZED_THIS
<span class="fc bfc" id="L2695" title="All 2 branches covered.">        if ((itsCurrentMethod.getFlags() &amp; ACC_STATIC) == 0) {</span>
<span class="fc bfc" id="L2696" title="All 2 branches covered.">            if (&quot;&lt;init&gt;&quot;.equals(itsCurrentMethod.getName())) {</span>
<span class="fc" id="L2697">                initialLocals[localsTop++] = TypeInfo.UNINITIALIZED_THIS;</span>
            } else {
<span class="fc" id="L2699">                initialLocals[localsTop++] = TypeInfo.OBJECT(itsThisClassIndex);</span>
            }
        }

        // No error checking should be necessary, sizeOfParameters does this
<span class="fc" id="L2704">        String type = itsCurrentMethod.getType();</span>
<span class="fc" id="L2705">        int lParenIndex = type.indexOf('(');</span>
<span class="fc" id="L2706">        int rParenIndex = type.indexOf(')');</span>
<span class="pc bpc" id="L2707" title="2 of 4 branches missed.">        if (lParenIndex != 0 || rParenIndex &lt; 0) {</span>
<span class="nc" id="L2708">            throw new IllegalArgumentException(&quot;bad method type&quot;);</span>
        }
<span class="fc" id="L2710">        int start = lParenIndex + 1;</span>
<span class="fc" id="L2711">        StringBuilder paramType = new StringBuilder();</span>
<span class="fc bfc" id="L2712" title="All 2 branches covered.">        while (start &lt; rParenIndex) {</span>
<span class="pc bpc" id="L2713" title="1 of 4 branches missed.">            switch (type.charAt(start)) {</span>
                case 'B':
                case 'C':
                case 'D':
                case 'F':
                case 'I':
                case 'J':
                case 'S':
                case 'Z':
<span class="fc" id="L2722">                    paramType.append(type.charAt(start));</span>
<span class="fc" id="L2723">                    ++start;</span>
<span class="fc" id="L2724">                    break;</span>
                case 'L':
<span class="fc" id="L2726">                    int end = type.indexOf(';', start) + 1;</span>
<span class="fc" id="L2727">                    String name = type.substring(start, end);</span>
<span class="fc" id="L2728">                    paramType.append(name);</span>
<span class="fc" id="L2729">                    start = end;</span>
<span class="fc" id="L2730">                    break;</span>
                case '[':
<span class="fc" id="L2732">                    paramType.append('[');</span>
<span class="fc" id="L2733">                    ++start;</span>
<span class="fc" id="L2734">                    continue;</span>
            }
<span class="fc" id="L2736">            String internalType =</span>
<span class="fc" id="L2737">                descriptorToInternalName(paramType.toString());</span>
<span class="fc" id="L2738">            int typeInfo = TypeInfo.fromType(internalType, itsConstantPool);</span>
<span class="fc" id="L2739">            initialLocals[localsTop++] = typeInfo;</span>
<span class="pc bpc" id="L2740" title="1 of 2 branches missed.">            if (TypeInfo.isTwoWords(typeInfo)) {</span>
<span class="nc" id="L2741">                localsTop++;</span>
            }
<span class="fc" id="L2743">            paramType.setLength(0);</span>
<span class="fc" id="L2744">        }</span>
<span class="fc" id="L2745">        return initialLocals;</span>
    }

    /**
     * Write the class file to the OutputStream.
     *
     * @param oStream the stream to write to
     * @throws IOException if writing to the stream produces an exception
     */
    public void write(OutputStream oStream)
        throws IOException {
<span class="nc" id="L2756">        byte[] array = toByteArray();</span>
<span class="nc" id="L2757">        oStream.write(array);</span>
<span class="nc" id="L2758">    }</span>

    private int getWriteSize() {
<span class="fc" id="L2761">        int size = 0;</span>

<span class="pc bpc" id="L2763" title="1 of 2 branches missed.">        if (itsSourceFileNameIndex != 0) {</span>
<span class="nc" id="L2764">            itsConstantPool.addUtf8(&quot;SourceFile&quot;);</span>
        }

<span class="fc" id="L2767">        size += 8; //writeLong(FileHeaderConstant);</span>
<span class="fc" id="L2768">        size += itsConstantPool.getWriteSize();</span>
<span class="fc" id="L2769">        size += 2; //writeShort(itsFlags);</span>
<span class="fc" id="L2770">        size += 2; //writeShort(itsThisClassIndex);</span>
<span class="fc" id="L2771">        size += 2; //writeShort(itsSuperClassIndex);</span>
<span class="fc" id="L2772">        size += 2; //writeShort(itsInterfaces.size());</span>
<span class="fc" id="L2773">        size += 2 * itsInterfaces.size();</span>

<span class="fc" id="L2775">        size += 2; //writeShort(itsFields.size());</span>
<span class="fc bfc" id="L2776" title="All 2 branches covered.">        for (int i = 0; i &lt; itsFields.size(); i++) {</span>
<span class="fc" id="L2777">            size += ((ClassFileField) (itsFields.get(i))).getWriteSize();</span>
        }

<span class="fc" id="L2780">        size += 2; //writeShort(itsMethods.size());</span>
<span class="fc bfc" id="L2781" title="All 2 branches covered.">        for (int i = 0; i &lt; itsMethods.size(); i++) {</span>
<span class="fc" id="L2782">            size += ((ClassFileMethod) (itsMethods.get(i))).getWriteSize();</span>
        }

<span class="fc" id="L2785">        size += 2; //writeShort(1);  attributes count, could be zero</span>
<span class="pc bpc" id="L2786" title="1 of 2 branches missed.">        if (itsSourceFileNameIndex != 0) {</span>
<span class="nc" id="L2787">            size += 2; //writeShort(sourceFileAttributeNameIndex);</span>
<span class="nc" id="L2788">            size += 4; //writeInt(2);</span>
<span class="nc" id="L2789">            size += 2; //writeShort(itsSourceFileNameIndex);</span>
        }
<span class="pc bpc" id="L2791" title="1 of 2 branches missed.">        if (itsBootstrapMethods != null) {</span>
<span class="nc" id="L2792">            size += 2; //writeShort(bootstrapMethodsAttrNameIndex);</span>
<span class="nc" id="L2793">            size += 4; //writeInt(itsBootstrapMethodsLength);</span>
<span class="nc" id="L2794">            size += 2; //writeShort(bootstrapMethods.size());</span>
<span class="nc" id="L2795">            size += itsBootstrapMethodsLength;</span>
        }

<span class="fc" id="L2798">        return size;</span>
    }

    /**
     * Get the class file as array of bytesto the OutputStream.
     */
    public byte[] toByteArray() {
<span class="fc" id="L2805">        short bootstrapMethodsAttrNameIndex = 0;</span>
<span class="fc" id="L2806">        int attributeCount = 0;</span>

<span class="fc" id="L2808">        short sourceFileAttributeNameIndex = 0;</span>
<span class="pc bpc" id="L2809" title="1 of 2 branches missed.">        if (itsBootstrapMethods != null) {</span>
<span class="nc" id="L2810">            ++attributeCount;</span>
<span class="nc" id="L2811">            bootstrapMethodsAttrNameIndex = itsConstantPool.addUtf8(&quot;BootstrapMethods&quot;);</span>
        }

<span class="pc bpc" id="L2814" title="1 of 2 branches missed.">        if (itsSourceFileNameIndex != 0) {</span>
<span class="nc" id="L2815">            ++attributeCount;</span>
<span class="nc" id="L2816">            sourceFileAttributeNameIndex = itsConstantPool.addUtf8(</span>
                &quot;SourceFile&quot;);
        }

        // Don't calculate the data size until we know how many bootstrap
        // methods there will be.
<span class="fc" id="L2822">        int offset = 0;</span>
<span class="fc" id="L2823">        int dataSize = getWriteSize();</span>
<span class="fc" id="L2824">        byte[] data = new byte[dataSize];</span>

<span class="fc" id="L2826">        offset = putInt32(FileHeaderConstant, data, offset);</span>
<span class="fc" id="L2827">        offset = putInt16(MinorVersion, data, offset);</span>
<span class="fc" id="L2828">        offset = putInt16(MajorVersion, data, offset);</span>
<span class="fc" id="L2829">        offset = itsConstantPool.write(data, offset);</span>
<span class="fc" id="L2830">        offset = putInt16(itsFlags, data, offset);</span>
<span class="fc" id="L2831">        offset = putInt16(itsThisClassIndex, data, offset);</span>
<span class="fc" id="L2832">        offset = putInt16(itsSuperClassIndex, data, offset);</span>
<span class="fc" id="L2833">        offset = putInt16(itsInterfaces.size(), data, offset);</span>
<span class="fc bfc" id="L2834" title="All 2 branches covered.">        for (int i = 0; i &lt; itsInterfaces.size(); i++) {</span>
<span class="fc" id="L2835">            int interfaceIndex = ((Short) (itsInterfaces.get(i))).shortValue();</span>
<span class="fc" id="L2836">            offset = putInt16(interfaceIndex, data, offset);</span>
        }
<span class="fc" id="L2838">        offset = putInt16(itsFields.size(), data, offset);</span>
<span class="fc bfc" id="L2839" title="All 2 branches covered.">        for (int i = 0; i &lt; itsFields.size(); i++) {</span>
<span class="fc" id="L2840">            ClassFileField field = (ClassFileField) itsFields.get(i);</span>
<span class="fc" id="L2841">            offset = field.write(data, offset);</span>
        }
<span class="fc" id="L2843">        offset = putInt16(itsMethods.size(), data, offset);</span>
<span class="fc bfc" id="L2844" title="All 2 branches covered.">        for (int i = 0; i &lt; itsMethods.size(); i++) {</span>
<span class="fc" id="L2845">            ClassFileMethod method = (ClassFileMethod) itsMethods.get(i);</span>
<span class="fc" id="L2846">            offset = method.write(data, offset);</span>
        }
<span class="fc" id="L2848">        offset = putInt16(attributeCount, data, offset); // attributes count</span>
<span class="pc bpc" id="L2849" title="1 of 2 branches missed.">        if (itsBootstrapMethods != null) {</span>
<span class="nc" id="L2850">            offset = putInt16(bootstrapMethodsAttrNameIndex, data, offset);</span>
<span class="nc" id="L2851">            offset = putInt32(itsBootstrapMethodsLength + 2, data, offset);</span>
<span class="nc" id="L2852">            offset = putInt16(itsBootstrapMethods.size(), data, offset);</span>
<span class="nc bnc" id="L2853" title="All 2 branches missed.">            for (int i = 0; i &lt; itsBootstrapMethods.size(); i++) {</span>
<span class="nc" id="L2854">                BootstrapEntry entry = (BootstrapEntry) itsBootstrapMethods.get(i);</span>
<span class="nc" id="L2855">                System.arraycopy(entry.code, 0, data, offset, entry.code.length);</span>
<span class="nc" id="L2856">                offset += entry.code.length;</span>
            }
        }
<span class="pc bpc" id="L2859" title="1 of 2 branches missed.">        if (itsSourceFileNameIndex != 0) {</span>
<span class="nc" id="L2860">            offset = putInt16(sourceFileAttributeNameIndex, data, offset);</span>
<span class="nc" id="L2861">            offset = putInt32(2, data, offset);</span>
<span class="nc" id="L2862">            offset = putInt16(itsSourceFileNameIndex, data, offset);</span>
        }

<span class="pc bpc" id="L2865" title="1 of 2 branches missed.">        if (offset != dataSize) {</span>
            // Check getWriteSize is consistent with write!
<span class="nc" id="L2867">            throw new RuntimeException();</span>
        }

<span class="fc" id="L2870">        return data;</span>
    }

    static int putInt64(long value, byte[] array, int offset) {
<span class="fc" id="L2874">        offset = putInt32((int) (value &gt;&gt;&gt; 32), array, offset);</span>
<span class="fc" id="L2875">        return putInt32((int) value, array, offset);</span>
    }

    private static void badStack(int value) {
        String s;
<span class="nc bnc" id="L2880" title="All 2 branches missed.">        if (value &lt; 0) {</span>
<span class="nc" id="L2881">            s = &quot;Stack underflow: &quot; + value;</span>
        } else {
<span class="nc" id="L2883">            s = &quot;Too big stack: &quot; + value;</span>
        }
<span class="nc" id="L2885">        throw new IllegalStateException(s);</span>
    }

    /*
        Really weird. Returns an int with # parameters in hi 16 bits, and
        stack difference removal of parameters from stack and pushing the
        result (it does not take into account removal of this in case of
        non-static methods).
        If Java really supported references we wouldn't have to be this
        perverted.
    */
    private static int sizeOfParameters(String pString) {
<span class="fc" id="L2897">        int length = pString.length();</span>
<span class="fc" id="L2898">        int rightParenthesis = pString.lastIndexOf(')');</span>
<span class="pc bpc" id="L2899" title="1 of 2 branches missed.">        if (3 &lt;= length /* minimal signature takes at least 3 chars: ()V */</span>
<span class="pc bpc" id="L2900" title="3 of 6 branches missed.">            &amp;&amp; pString.charAt(0) == '('</span>
            &amp;&amp; 1 &lt;= rightParenthesis &amp;&amp; rightParenthesis + 1 &lt; length) {
<span class="fc" id="L2902">            boolean ok = true;</span>
<span class="fc" id="L2903">            int index = 1;</span>
<span class="fc" id="L2904">            int stackDiff = 0;</span>
<span class="fc" id="L2905">            int count = 0;</span>
            stringLoop:
<span class="fc bfc" id="L2907" title="All 2 branches covered.">            while (index != rightParenthesis) {</span>
<span class="pc bpc" id="L2908" title="1 of 5 branches missed.">                switch (pString.charAt(index)) {</span>
                    default:
<span class="nc" id="L2910">                        ok = false;</span>
<span class="nc" id="L2911">                        break stringLoop;</span>
                    case 'J':
                    case 'D':
<span class="fc" id="L2914">                        --stackDiff;</span>
                        // fallthru
                    case 'B':
                    case 'S':
                    case 'C':
                    case 'I':
                    case 'Z':
                    case 'F':
<span class="fc" id="L2922">                        --stackDiff;</span>
<span class="fc" id="L2923">                        ++count;</span>
<span class="fc" id="L2924">                        ++index;</span>
<span class="fc" id="L2925">                        continue;</span>
                    case '[':
<span class="fc" id="L2927">                        ++index;</span>
<span class="fc" id="L2928">                        int c = pString.charAt(index);</span>
<span class="pc bpc" id="L2929" title="1 of 2 branches missed.">                        while (c == '[') {</span>
<span class="nc" id="L2930">                            ++index;</span>
<span class="nc" id="L2931">                            c = pString.charAt(index);</span>
                        }
<span class="pc bpc" id="L2933" title="1 of 3 branches missed.">                        switch (c) {</span>
                            default:
<span class="nc" id="L2935">                                ok = false;</span>
<span class="nc" id="L2936">                                break stringLoop;</span>
                            case 'J':
                            case 'D':
                            case 'B':
                            case 'S':
                            case 'C':
                            case 'I':
                            case 'Z':
                            case 'F':
<span class="fc" id="L2945">                                --stackDiff;</span>
<span class="fc" id="L2946">                                ++count;</span>
<span class="fc" id="L2947">                                ++index;</span>
<span class="fc" id="L2948">                                continue;</span>
                            case 'L':
                                // fallthru
                        }
                        // fallthru
                    case 'L': {
<span class="fc" id="L2954">                        --stackDiff;</span>
<span class="fc" id="L2955">                        ++count;</span>
<span class="fc" id="L2956">                        ++index;</span>
<span class="fc" id="L2957">                        int semicolon = pString.indexOf(';', index);</span>
<span class="pc bpc" id="L2958" title="2 of 4 branches missed.">                        if (!(index + 1 &lt;= semicolon</span>
                            &amp;&amp; semicolon &lt; rightParenthesis)) {
<span class="nc" id="L2960">                            ok = false;</span>
<span class="nc" id="L2961">                            break stringLoop;</span>
                        }
<span class="fc" id="L2963">                        index = semicolon + 1;</span>
<span class="fc" id="L2964">                        continue;</span>
                    }
                }
            }
<span class="pc bpc" id="L2968" title="1 of 2 branches missed.">            if (ok) {</span>
<span class="pc bpc" id="L2969" title="1 of 4 branches missed.">                switch (pString.charAt(rightParenthesis + 1)) {</span>
                    default:
<span class="nc" id="L2971">                        ok = false;</span>
<span class="nc" id="L2972">                        break;</span>
                    case 'J':
                    case 'D':
<span class="fc" id="L2975">                        ++stackDiff;</span>
                        // fallthru
                    case 'B':
                    case 'S':
                    case 'C':
                    case 'I':
                    case 'Z':
                    case 'F':
                    case 'L':
                    case '[':
<span class="fc" id="L2985">                        ++stackDiff;</span>
                        // fallthru
                    case 'V':
                        break;
                }
<span class="pc bpc" id="L2990" title="1 of 2 branches missed.">                if (ok) {</span>
<span class="fc" id="L2991">                    return ((count &lt;&lt; 16) | (0xFFFF &amp; stackDiff));</span>
                }
            }
        }
<span class="nc" id="L2995">        throw new IllegalArgumentException(</span>
            &quot;Bad parameter signature: &quot; + pString);
    }

    static int putInt16(int value, byte[] array, int offset) {
<span class="fc" id="L3000">        array[offset + 0] = (byte) (value &gt;&gt;&gt; 8);</span>
<span class="fc" id="L3001">        array[offset + 1] = (byte) value;</span>
<span class="fc" id="L3002">        return offset + 2;</span>
    }

    static int putInt32(int value, byte[] array, int offset) {
<span class="fc" id="L3006">        array[offset + 0] = (byte) (value &gt;&gt;&gt; 24);</span>
<span class="fc" id="L3007">        array[offset + 1] = (byte) (value &gt;&gt;&gt; 16);</span>
<span class="fc" id="L3008">        array[offset + 2] = (byte) (value &gt;&gt;&gt; 8);</span>
<span class="fc" id="L3009">        array[offset + 3] = (byte) value;</span>
<span class="fc" id="L3010">        return offset + 4;</span>
    }

    /**
     * Size of a bytecode instruction, counting the opcode and its operands.
     *
     * This is different from opcodeCount, since opcodeCount counts logical operands.
     */
    private static int opcodeLength(int opcode, boolean wide) {
<span class="pc bpc" id="L3019" title="3 of 8 branches missed.">        switch (opcode) {</span>
            case ByteCode.AALOAD:
            case ByteCode.AASTORE:
            case ByteCode.ACONST_NULL:
            case ByteCode.ALOAD_0:
            case ByteCode.ALOAD_1:
            case ByteCode.ALOAD_2:
            case ByteCode.ALOAD_3:
            case ByteCode.ARETURN:
            case ByteCode.ARRAYLENGTH:
            case ByteCode.ASTORE_0:
            case ByteCode.ASTORE_1:
            case ByteCode.ASTORE_2:
            case ByteCode.ASTORE_3:
            case ByteCode.ATHROW:
            case ByteCode.BALOAD:
            case ByteCode.BASTORE:
            case ByteCode.BREAKPOINT:
            case ByteCode.CALOAD:
            case ByteCode.CASTORE:
            case ByteCode.D2F:
            case ByteCode.D2I:
            case ByteCode.D2L:
            case ByteCode.DADD:
            case ByteCode.DALOAD:
            case ByteCode.DASTORE:
            case ByteCode.DCMPG:
            case ByteCode.DCMPL:
            case ByteCode.DCONST_0:
            case ByteCode.DCONST_1:
            case ByteCode.DDIV:
            case ByteCode.DLOAD_0:
            case ByteCode.DLOAD_1:
            case ByteCode.DLOAD_2:
            case ByteCode.DLOAD_3:
            case ByteCode.DMUL:
            case ByteCode.DNEG:
            case ByteCode.DREM:
            case ByteCode.DRETURN:
            case ByteCode.DSTORE_0:
            case ByteCode.DSTORE_1:
            case ByteCode.DSTORE_2:
            case ByteCode.DSTORE_3:
            case ByteCode.DSUB:
            case ByteCode.DUP:
            case ByteCode.DUP2:
            case ByteCode.DUP2_X1:
            case ByteCode.DUP2_X2:
            case ByteCode.DUP_X1:
            case ByteCode.DUP_X2:
            case ByteCode.F2D:
            case ByteCode.F2I:
            case ByteCode.F2L:
            case ByteCode.FADD:
            case ByteCode.FALOAD:
            case ByteCode.FASTORE:
            case ByteCode.FCMPG:
            case ByteCode.FCMPL:
            case ByteCode.FCONST_0:
            case ByteCode.FCONST_1:
            case ByteCode.FCONST_2:
            case ByteCode.FDIV:
            case ByteCode.FLOAD_0:
            case ByteCode.FLOAD_1:
            case ByteCode.FLOAD_2:
            case ByteCode.FLOAD_3:
            case ByteCode.FMUL:
            case ByteCode.FNEG:
            case ByteCode.FREM:
            case ByteCode.FRETURN:
            case ByteCode.FSTORE_0:
            case ByteCode.FSTORE_1:
            case ByteCode.FSTORE_2:
            case ByteCode.FSTORE_3:
            case ByteCode.FSUB:
            case ByteCode.I2B:
            case ByteCode.I2C:
            case ByteCode.I2D:
            case ByteCode.I2F:
            case ByteCode.I2L:
            case ByteCode.I2S:
            case ByteCode.IADD:
            case ByteCode.IALOAD:
            case ByteCode.IAND:
            case ByteCode.IASTORE:
            case ByteCode.ICONST_0:
            case ByteCode.ICONST_1:
            case ByteCode.ICONST_2:
            case ByteCode.ICONST_3:
            case ByteCode.ICONST_4:
            case ByteCode.ICONST_5:
            case ByteCode.ICONST_M1:
            case ByteCode.IDIV:
            case ByteCode.ILOAD_0:
            case ByteCode.ILOAD_1:
            case ByteCode.ILOAD_2:
            case ByteCode.ILOAD_3:
            case ByteCode.IMPDEP1:
            case ByteCode.IMPDEP2:
            case ByteCode.IMUL:
            case ByteCode.INEG:
            case ByteCode.IOR:
            case ByteCode.IREM:
            case ByteCode.IRETURN:
            case ByteCode.ISHL:
            case ByteCode.ISHR:
            case ByteCode.ISTORE_0:
            case ByteCode.ISTORE_1:
            case ByteCode.ISTORE_2:
            case ByteCode.ISTORE_3:
            case ByteCode.ISUB:
            case ByteCode.IUSHR:
            case ByteCode.IXOR:
            case ByteCode.L2D:
            case ByteCode.L2F:
            case ByteCode.L2I:
            case ByteCode.LADD:
            case ByteCode.LALOAD:
            case ByteCode.LAND:
            case ByteCode.LASTORE:
            case ByteCode.LCMP:
            case ByteCode.LCONST_0:
            case ByteCode.LCONST_1:
            case ByteCode.LDIV:
            case ByteCode.LLOAD_0:
            case ByteCode.LLOAD_1:
            case ByteCode.LLOAD_2:
            case ByteCode.LLOAD_3:
            case ByteCode.LMUL:
            case ByteCode.LNEG:
            case ByteCode.LOR:
            case ByteCode.LREM:
            case ByteCode.LRETURN:
            case ByteCode.LSHL:
            case ByteCode.LSHR:
            case ByteCode.LSTORE_0:
            case ByteCode.LSTORE_1:
            case ByteCode.LSTORE_2:
            case ByteCode.LSTORE_3:
            case ByteCode.LSUB:
            case ByteCode.LUSHR:
            case ByteCode.LXOR:
            case ByteCode.MONITORENTER:
            case ByteCode.MONITOREXIT:
            case ByteCode.NOP:
            case ByteCode.POP:
            case ByteCode.POP2:
            case ByteCode.RETURN:
            case ByteCode.SALOAD:
            case ByteCode.SASTORE:
            case ByteCode.SWAP:
            case ByteCode.WIDE:
<span class="fc" id="L3171">                return 1;</span>
            case ByteCode.BIPUSH:
            case ByteCode.LDC:
            case ByteCode.NEWARRAY:
<span class="fc" id="L3175">                return 2;</span>
            case ByteCode.ALOAD:
            case ByteCode.ASTORE:
            case ByteCode.DLOAD:
            case ByteCode.DSTORE:
            case ByteCode.FLOAD:
            case ByteCode.FSTORE:
            case ByteCode.ILOAD:
            case ByteCode.ISTORE:
            case ByteCode.LLOAD:
            case ByteCode.LSTORE:
            case ByteCode.RET:
<span class="pc bpc" id="L3187" title="1 of 2 branches missed.">                return wide ? 3 : 2;</span>

            case ByteCode.ANEWARRAY:
            case ByteCode.CHECKCAST:
            case ByteCode.GETFIELD:
            case ByteCode.GETSTATIC:
            case ByteCode.GOTO:
            case ByteCode.IFEQ:
            case ByteCode.IFGE:
            case ByteCode.IFGT:
            case ByteCode.IFLE:
            case ByteCode.IFLT:
            case ByteCode.IFNE:
            case ByteCode.IFNONNULL:
            case ByteCode.IFNULL:
            case ByteCode.IF_ACMPEQ:
            case ByteCode.IF_ACMPNE:
            case ByteCode.IF_ICMPEQ:
            case ByteCode.IF_ICMPGE:
            case ByteCode.IF_ICMPGT:
            case ByteCode.IF_ICMPLE:
            case ByteCode.IF_ICMPLT:
            case ByteCode.IF_ICMPNE:
            case ByteCode.INSTANCEOF:
            case ByteCode.INVOKESPECIAL:
            case ByteCode.INVOKESTATIC:
            case ByteCode.INVOKEVIRTUAL:
            case ByteCode.JSR:
            case ByteCode.LDC_W:
            case ByteCode.LDC2_W:
            case ByteCode.NEW:
            case ByteCode.PUTFIELD:
            case ByteCode.PUTSTATIC:
            case ByteCode.SIPUSH:
<span class="fc" id="L3221">                return 3;</span>

            case ByteCode.IINC:
<span class="nc bnc" id="L3224" title="All 2 branches missed.">                return wide ? 5 : 3;</span>

            case ByteCode.MULTIANEWARRAY:
<span class="nc" id="L3227">                return 4;</span>

            case ByteCode.GOTO_W:
            case ByteCode.INVOKEINTERFACE:
            case ByteCode.INVOKEDYNAMIC:
            case ByteCode.JSR_W:
<span class="fc" id="L3233">                return 5;</span>

            /*
            case ByteCode.LOOKUPSWITCH:
            case ByteCode.TABLESWITCH:
                return -1;
            */
        }
<span class="nc" id="L3241">        throw new IllegalArgumentException(&quot;Bad opcode: &quot; + opcode);</span>
    }

    /**
     * Number of operands accompanying the opcode.
     */
    private static int opcodeCount(int opcode) {
<span class="pc bpc" id="L3248" title="4 of 5 branches missed.">        switch (opcode) {</span>
            case ByteCode.AALOAD:
            case ByteCode.AASTORE:
            case ByteCode.ACONST_NULL:
            case ByteCode.ALOAD_0:
            case ByteCode.ALOAD_1:
            case ByteCode.ALOAD_2:
            case ByteCode.ALOAD_3:
            case ByteCode.ARETURN:
            case ByteCode.ARRAYLENGTH:
            case ByteCode.ASTORE_0:
            case ByteCode.ASTORE_1:
            case ByteCode.ASTORE_2:
            case ByteCode.ASTORE_3:
            case ByteCode.ATHROW:
            case ByteCode.BALOAD:
            case ByteCode.BASTORE:
            case ByteCode.BREAKPOINT:
            case ByteCode.CALOAD:
            case ByteCode.CASTORE:
            case ByteCode.D2F:
            case ByteCode.D2I:
            case ByteCode.D2L:
            case ByteCode.DADD:
            case ByteCode.DALOAD:
            case ByteCode.DASTORE:
            case ByteCode.DCMPG:
            case ByteCode.DCMPL:
            case ByteCode.DCONST_0:
            case ByteCode.DCONST_1:
            case ByteCode.DDIV:
            case ByteCode.DLOAD_0:
            case ByteCode.DLOAD_1:
            case ByteCode.DLOAD_2:
            case ByteCode.DLOAD_3:
            case ByteCode.DMUL:
            case ByteCode.DNEG:
            case ByteCode.DREM:
            case ByteCode.DRETURN:
            case ByteCode.DSTORE_0:
            case ByteCode.DSTORE_1:
            case ByteCode.DSTORE_2:
            case ByteCode.DSTORE_3:
            case ByteCode.DSUB:
            case ByteCode.DUP:
            case ByteCode.DUP2:
            case ByteCode.DUP2_X1:
            case ByteCode.DUP2_X2:
            case ByteCode.DUP_X1:
            case ByteCode.DUP_X2:
            case ByteCode.F2D:
            case ByteCode.F2I:
            case ByteCode.F2L:
            case ByteCode.FADD:
            case ByteCode.FALOAD:
            case ByteCode.FASTORE:
            case ByteCode.FCMPG:
            case ByteCode.FCMPL:
            case ByteCode.FCONST_0:
            case ByteCode.FCONST_1:
            case ByteCode.FCONST_2:
            case ByteCode.FDIV:
            case ByteCode.FLOAD_0:
            case ByteCode.FLOAD_1:
            case ByteCode.FLOAD_2:
            case ByteCode.FLOAD_3:
            case ByteCode.FMUL:
            case ByteCode.FNEG:
            case ByteCode.FREM:
            case ByteCode.FRETURN:
            case ByteCode.FSTORE_0:
            case ByteCode.FSTORE_1:
            case ByteCode.FSTORE_2:
            case ByteCode.FSTORE_3:
            case ByteCode.FSUB:
            case ByteCode.I2B:
            case ByteCode.I2C:
            case ByteCode.I2D:
            case ByteCode.I2F:
            case ByteCode.I2L:
            case ByteCode.I2S:
            case ByteCode.IADD:
            case ByteCode.IALOAD:
            case ByteCode.IAND:
            case ByteCode.IASTORE:
            case ByteCode.ICONST_0:
            case ByteCode.ICONST_1:
            case ByteCode.ICONST_2:
            case ByteCode.ICONST_3:
            case ByteCode.ICONST_4:
            case ByteCode.ICONST_5:
            case ByteCode.ICONST_M1:
            case ByteCode.IDIV:
            case ByteCode.ILOAD_0:
            case ByteCode.ILOAD_1:
            case ByteCode.ILOAD_2:
            case ByteCode.ILOAD_3:
            case ByteCode.IMPDEP1:
            case ByteCode.IMPDEP2:
            case ByteCode.IMUL:
            case ByteCode.INEG:
            case ByteCode.IOR:
            case ByteCode.IREM:
            case ByteCode.IRETURN:
            case ByteCode.ISHL:
            case ByteCode.ISHR:
            case ByteCode.ISTORE_0:
            case ByteCode.ISTORE_1:
            case ByteCode.ISTORE_2:
            case ByteCode.ISTORE_3:
            case ByteCode.ISUB:
            case ByteCode.IUSHR:
            case ByteCode.IXOR:
            case ByteCode.L2D:
            case ByteCode.L2F:
            case ByteCode.L2I:
            case ByteCode.LADD:
            case ByteCode.LALOAD:
            case ByteCode.LAND:
            case ByteCode.LASTORE:
            case ByteCode.LCMP:
            case ByteCode.LCONST_0:
            case ByteCode.LCONST_1:
            case ByteCode.LDIV:
            case ByteCode.LLOAD_0:
            case ByteCode.LLOAD_1:
            case ByteCode.LLOAD_2:
            case ByteCode.LLOAD_3:
            case ByteCode.LMUL:
            case ByteCode.LNEG:
            case ByteCode.LOR:
            case ByteCode.LREM:
            case ByteCode.LRETURN:
            case ByteCode.LSHL:
            case ByteCode.LSHR:
            case ByteCode.LSTORE_0:
            case ByteCode.LSTORE_1:
            case ByteCode.LSTORE_2:
            case ByteCode.LSTORE_3:
            case ByteCode.LSUB:
            case ByteCode.LUSHR:
            case ByteCode.LXOR:
            case ByteCode.MONITORENTER:
            case ByteCode.MONITOREXIT:
            case ByteCode.NOP:
            case ByteCode.POP:
            case ByteCode.POP2:
            case ByteCode.RETURN:
            case ByteCode.SALOAD:
            case ByteCode.SASTORE:
            case ByteCode.SWAP:
            case ByteCode.WIDE:
<span class="fc" id="L3400">                return 0;</span>
            case ByteCode.ALOAD:
            case ByteCode.ANEWARRAY:
            case ByteCode.ASTORE:
            case ByteCode.BIPUSH:
            case ByteCode.CHECKCAST:
            case ByteCode.DLOAD:
            case ByteCode.DSTORE:
            case ByteCode.FLOAD:
            case ByteCode.FSTORE:
            case ByteCode.GETFIELD:
            case ByteCode.GETSTATIC:
            case ByteCode.GOTO:
            case ByteCode.GOTO_W:
            case ByteCode.IFEQ:
            case ByteCode.IFGE:
            case ByteCode.IFGT:
            case ByteCode.IFLE:
            case ByteCode.IFLT:
            case ByteCode.IFNE:
            case ByteCode.IFNONNULL:
            case ByteCode.IFNULL:
            case ByteCode.IF_ACMPEQ:
            case ByteCode.IF_ACMPNE:
            case ByteCode.IF_ICMPEQ:
            case ByteCode.IF_ICMPGE:
            case ByteCode.IF_ICMPGT:
            case ByteCode.IF_ICMPLE:
            case ByteCode.IF_ICMPLT:
            case ByteCode.IF_ICMPNE:
            case ByteCode.ILOAD:
            case ByteCode.INSTANCEOF:
            case ByteCode.INVOKEINTERFACE:
            case ByteCode.INVOKESPECIAL:
            case ByteCode.INVOKESTATIC:
            case ByteCode.INVOKEVIRTUAL:
            case ByteCode.ISTORE:
            case ByteCode.JSR:
            case ByteCode.JSR_W:
            case ByteCode.LDC:
            case ByteCode.LDC2_W:
            case ByteCode.LDC_W:
            case ByteCode.LLOAD:
            case ByteCode.LSTORE:
            case ByteCode.NEW:
            case ByteCode.NEWARRAY:
            case ByteCode.PUTFIELD:
            case ByteCode.PUTSTATIC:
            case ByteCode.RET:
            case ByteCode.SIPUSH:
<span class="nc" id="L3450">                return 1;</span>

            case ByteCode.IINC:
            case ByteCode.MULTIANEWARRAY:
<span class="nc" id="L3454">                return 2;</span>

            case ByteCode.LOOKUPSWITCH:
            case ByteCode.TABLESWITCH:
<span class="nc" id="L3458">                return -1;</span>
        }
<span class="nc" id="L3460">        throw new IllegalArgumentException(&quot;Bad opcode: &quot; + opcode);</span>
    }

    /**
     * The effect on the operand stack of a given opcode.
     */
    private static int stackChange(int opcode) {
        // For INVOKE... accounts only for popping this (unless static),
        // ignoring parameters and return type
<span class="pc bpc" id="L3469" title="2 of 8 branches missed.">        switch (opcode) {</span>
            case ByteCode.DASTORE:
            case ByteCode.LASTORE:
<span class="nc" id="L3472">                return -4;</span>

            case ByteCode.AASTORE:
            case ByteCode.BASTORE:
            case ByteCode.CASTORE:
            case ByteCode.DCMPG:
            case ByteCode.DCMPL:
            case ByteCode.FASTORE:
            case ByteCode.IASTORE:
            case ByteCode.LCMP:
            case ByteCode.SASTORE:
<span class="fc" id="L3483">                return -3;</span>

            case ByteCode.DADD:
            case ByteCode.DDIV:
            case ByteCode.DMUL:
            case ByteCode.DREM:
            case ByteCode.DRETURN:
            case ByteCode.DSTORE:
            case ByteCode.DSTORE_0:
            case ByteCode.DSTORE_1:
            case ByteCode.DSTORE_2:
            case ByteCode.DSTORE_3:
            case ByteCode.DSUB:
            case ByteCode.IF_ACMPEQ:
            case ByteCode.IF_ACMPNE:
            case ByteCode.IF_ICMPEQ:
            case ByteCode.IF_ICMPGE:
            case ByteCode.IF_ICMPGT:
            case ByteCode.IF_ICMPLE:
            case ByteCode.IF_ICMPLT:
            case ByteCode.IF_ICMPNE:
            case ByteCode.LADD:
            case ByteCode.LAND:
            case ByteCode.LDIV:
            case ByteCode.LMUL:
            case ByteCode.LOR:
            case ByteCode.LREM:
            case ByteCode.LRETURN:
            case ByteCode.LSTORE:
            case ByteCode.LSTORE_0:
            case ByteCode.LSTORE_1:
            case ByteCode.LSTORE_2:
            case ByteCode.LSTORE_3:
            case ByteCode.LSUB:
            case ByteCode.LXOR:
            case ByteCode.POP2:
<span class="fc" id="L3519">                return -2;</span>

            case ByteCode.AALOAD:
            case ByteCode.ARETURN:
            case ByteCode.ASTORE:
            case ByteCode.ASTORE_0:
            case ByteCode.ASTORE_1:
            case ByteCode.ASTORE_2:
            case ByteCode.ASTORE_3:
            case ByteCode.ATHROW:
            case ByteCode.BALOAD:
            case ByteCode.CALOAD:
            case ByteCode.D2F:
            case ByteCode.D2I:
            case ByteCode.FADD:
            case ByteCode.FALOAD:
            case ByteCode.FCMPG:
            case ByteCode.FCMPL:
            case ByteCode.FDIV:
            case ByteCode.FMUL:
            case ByteCode.FREM:
            case ByteCode.FRETURN:
            case ByteCode.FSTORE:
            case ByteCode.FSTORE_0:
            case ByteCode.FSTORE_1:
            case ByteCode.FSTORE_2:
            case ByteCode.FSTORE_3:
            case ByteCode.FSUB:
            case ByteCode.GETFIELD:
            case ByteCode.IADD:
            case ByteCode.IALOAD:
            case ByteCode.IAND:
            case ByteCode.IDIV:
            case ByteCode.IFEQ:
            case ByteCode.IFGE:
            case ByteCode.IFGT:
            case ByteCode.IFLE:
            case ByteCode.IFLT:
            case ByteCode.IFNE:
            case ByteCode.IFNONNULL:
            case ByteCode.IFNULL:
            case ByteCode.IMUL:
            case ByteCode.INVOKEINTERFACE:       //
            case ByteCode.INVOKESPECIAL:         // but needs to account for
            case ByteCode.INVOKEVIRTUAL:         // pops 'this' (unless static)
            case ByteCode.IOR:
            case ByteCode.IREM:
            case ByteCode.IRETURN:
            case ByteCode.ISHL:
            case ByteCode.ISHR:
            case ByteCode.ISTORE:
            case ByteCode.ISTORE_0:
            case ByteCode.ISTORE_1:
            case ByteCode.ISTORE_2:
            case ByteCode.ISTORE_3:
            case ByteCode.ISUB:
            case ByteCode.IUSHR:
            case ByteCode.IXOR:
            case ByteCode.L2F:
            case ByteCode.L2I:
            case ByteCode.LOOKUPSWITCH:
            case ByteCode.LSHL:
            case ByteCode.LSHR:
            case ByteCode.LUSHR:
            case ByteCode.MONITORENTER:
            case ByteCode.MONITOREXIT:
            case ByteCode.POP:
            case ByteCode.PUTFIELD:
            case ByteCode.SALOAD:
            case ByteCode.TABLESWITCH:
<span class="fc" id="L3589">                return -1;</span>

            case ByteCode.ANEWARRAY:
            case ByteCode.ARRAYLENGTH:
            case ByteCode.BREAKPOINT:
            case ByteCode.CHECKCAST:
            case ByteCode.D2L:
            case ByteCode.DALOAD:
            case ByteCode.DNEG:
            case ByteCode.F2I:
            case ByteCode.FNEG:
            case ByteCode.GETSTATIC:
            case ByteCode.GOTO:
            case ByteCode.GOTO_W:
            case ByteCode.I2B:
            case ByteCode.I2C:
            case ByteCode.I2F:
            case ByteCode.I2S:
            case ByteCode.IINC:
            case ByteCode.IMPDEP1:
            case ByteCode.IMPDEP2:
            case ByteCode.INEG:
            case ByteCode.INSTANCEOF:
            case ByteCode.INVOKESTATIC:
            case ByteCode.INVOKEDYNAMIC:
            case ByteCode.L2D:
            case ByteCode.LALOAD:
            case ByteCode.LNEG:
            case ByteCode.NEWARRAY:
            case ByteCode.NOP:
            case ByteCode.PUTSTATIC:
            case ByteCode.RET:
            case ByteCode.RETURN:
            case ByteCode.SWAP:
            case ByteCode.WIDE:
<span class="fc" id="L3624">                return 0;</span>

            case ByteCode.ACONST_NULL:
            case ByteCode.ALOAD:
            case ByteCode.ALOAD_0:
            case ByteCode.ALOAD_1:
            case ByteCode.ALOAD_2:
            case ByteCode.ALOAD_3:
            case ByteCode.BIPUSH:
            case ByteCode.DUP:
            case ByteCode.DUP_X1:
            case ByteCode.DUP_X2:
            case ByteCode.F2D:
            case ByteCode.F2L:
            case ByteCode.FCONST_0:
            case ByteCode.FCONST_1:
            case ByteCode.FCONST_2:
            case ByteCode.FLOAD:
            case ByteCode.FLOAD_0:
            case ByteCode.FLOAD_1:
            case ByteCode.FLOAD_2:
            case ByteCode.FLOAD_3:
            case ByteCode.I2D:
            case ByteCode.I2L:
            case ByteCode.ICONST_0:
            case ByteCode.ICONST_1:
            case ByteCode.ICONST_2:
            case ByteCode.ICONST_3:
            case ByteCode.ICONST_4:
            case ByteCode.ICONST_5:
            case ByteCode.ICONST_M1:
            case ByteCode.ILOAD:
            case ByteCode.ILOAD_0:
            case ByteCode.ILOAD_1:
            case ByteCode.ILOAD_2:
            case ByteCode.ILOAD_3:
            case ByteCode.JSR:
            case ByteCode.JSR_W:
            case ByteCode.LDC:
            case ByteCode.LDC_W:
            case ByteCode.MULTIANEWARRAY:
            case ByteCode.NEW:
            case ByteCode.SIPUSH:
<span class="fc" id="L3667">                return 1;</span>

            case ByteCode.DCONST_0:
            case ByteCode.DCONST_1:
            case ByteCode.DLOAD:
            case ByteCode.DLOAD_0:
            case ByteCode.DLOAD_1:
            case ByteCode.DLOAD_2:
            case ByteCode.DLOAD_3:
            case ByteCode.DUP2:
            case ByteCode.DUP2_X1:
            case ByteCode.DUP2_X2:
            case ByteCode.LCONST_0:
            case ByteCode.LCONST_1:
            case ByteCode.LDC2_W:
            case ByteCode.LLOAD:
            case ByteCode.LLOAD_0:
            case ByteCode.LLOAD_1:
            case ByteCode.LLOAD_2:
            case ByteCode.LLOAD_3:
<span class="fc" id="L3687">                return 2;</span>
        }
<span class="nc" id="L3689">        throw new IllegalArgumentException(&quot;Bad opcode: &quot; + opcode);</span>
    }

        /*
         * Number of bytes of operands generated after the opcode.
         * Not in use currently.
         */
/*
    int extra(int opcode)
    {
        switch (opcode) {
            case ByteCode.AALOAD:
            case ByteCode.AASTORE:
            case ByteCode.ACONST_NULL:
            case ByteCode.ALOAD_0:
            case ByteCode.ALOAD_1:
            case ByteCode.ALOAD_2:
            case ByteCode.ALOAD_3:
            case ByteCode.ARETURN:
            case ByteCode.ARRAYLENGTH:
            case ByteCode.ASTORE_0:
            case ByteCode.ASTORE_1:
            case ByteCode.ASTORE_2:
            case ByteCode.ASTORE_3:
            case ByteCode.ATHROW:
            case ByteCode.BALOAD:
            case ByteCode.BASTORE:
            case ByteCode.BREAKPOINT:
            case ByteCode.CALOAD:
            case ByteCode.CASTORE:
            case ByteCode.D2F:
            case ByteCode.D2I:
            case ByteCode.D2L:
            case ByteCode.DADD:
            case ByteCode.DALOAD:
            case ByteCode.DASTORE:
            case ByteCode.DCMPG:
            case ByteCode.DCMPL:
            case ByteCode.DCONST_0:
            case ByteCode.DCONST_1:
            case ByteCode.DDIV:
            case ByteCode.DLOAD_0:
            case ByteCode.DLOAD_1:
            case ByteCode.DLOAD_2:
            case ByteCode.DLOAD_3:
            case ByteCode.DMUL:
            case ByteCode.DNEG:
            case ByteCode.DREM:
            case ByteCode.DRETURN:
            case ByteCode.DSTORE_0:
            case ByteCode.DSTORE_1:
            case ByteCode.DSTORE_2:
            case ByteCode.DSTORE_3:
            case ByteCode.DSUB:
            case ByteCode.DUP2:
            case ByteCode.DUP2_X1:
            case ByteCode.DUP2_X2:
            case ByteCode.DUP:
            case ByteCode.DUP_X1:
            case ByteCode.DUP_X2:
            case ByteCode.F2D:
            case ByteCode.F2I:
            case ByteCode.F2L:
            case ByteCode.FADD:
            case ByteCode.FALOAD:
            case ByteCode.FASTORE:
            case ByteCode.FCMPG:
            case ByteCode.FCMPL:
            case ByteCode.FCONST_0:
            case ByteCode.FCONST_1:
            case ByteCode.FCONST_2:
            case ByteCode.FDIV:
            case ByteCode.FLOAD_0:
            case ByteCode.FLOAD_1:
            case ByteCode.FLOAD_2:
            case ByteCode.FLOAD_3:
            case ByteCode.FMUL:
            case ByteCode.FNEG:
            case ByteCode.FREM:
            case ByteCode.FRETURN:
            case ByteCode.FSTORE_0:
            case ByteCode.FSTORE_1:
            case ByteCode.FSTORE_2:
            case ByteCode.FSTORE_3:
            case ByteCode.FSUB:
            case ByteCode.I2B:
            case ByteCode.I2C:
            case ByteCode.I2D:
            case ByteCode.I2F:
            case ByteCode.I2L:
            case ByteCode.I2S:
            case ByteCode.IADD:
            case ByteCode.IALOAD:
            case ByteCode.IAND:
            case ByteCode.IASTORE:
            case ByteCode.ICONST_0:
            case ByteCode.ICONST_1:
            case ByteCode.ICONST_2:
            case ByteCode.ICONST_3:
            case ByteCode.ICONST_4:
            case ByteCode.ICONST_5:
            case ByteCode.ICONST_M1:
            case ByteCode.IDIV:
            case ByteCode.ILOAD_0:
            case ByteCode.ILOAD_1:
            case ByteCode.ILOAD_2:
            case ByteCode.ILOAD_3:
            case ByteCode.IMPDEP1:
            case ByteCode.IMPDEP2:
            case ByteCode.IMUL:
            case ByteCode.INEG:
            case ByteCode.IOR:
            case ByteCode.IREM:
            case ByteCode.IRETURN:
            case ByteCode.ISHL:
            case ByteCode.ISHR:
            case ByteCode.ISTORE_0:
            case ByteCode.ISTORE_1:
            case ByteCode.ISTORE_2:
            case ByteCode.ISTORE_3:
            case ByteCode.ISUB:
            case ByteCode.IUSHR:
            case ByteCode.IXOR:
            case ByteCode.L2D:
            case ByteCode.L2F:
            case ByteCode.L2I:
            case ByteCode.LADD:
            case ByteCode.LALOAD:
            case ByteCode.LAND:
            case ByteCode.LASTORE:
            case ByteCode.LCMP:
            case ByteCode.LCONST_0:
            case ByteCode.LCONST_1:
            case ByteCode.LDIV:
            case ByteCode.LLOAD_0:
            case ByteCode.LLOAD_1:
            case ByteCode.LLOAD_2:
            case ByteCode.LLOAD_3:
            case ByteCode.LMUL:
            case ByteCode.LNEG:
            case ByteCode.LOR:
            case ByteCode.LREM:
            case ByteCode.LRETURN:
            case ByteCode.LSHL:
            case ByteCode.LSHR:
            case ByteCode.LSTORE_0:
            case ByteCode.LSTORE_1:
            case ByteCode.LSTORE_2:
            case ByteCode.LSTORE_3:
            case ByteCode.LSUB:
            case ByteCode.LUSHR:
            case ByteCode.LXOR:
            case ByteCode.MONITORENTER:
            case ByteCode.MONITOREXIT:
            case ByteCode.NOP:
            case ByteCode.POP2:
            case ByteCode.POP:
            case ByteCode.RETURN:
            case ByteCode.SALOAD:
            case ByteCode.SASTORE:
            case ByteCode.SWAP:
            case ByteCode.WIDE:
                return 0;

            case ByteCode.ALOAD:
            case ByteCode.ASTORE:
            case ByteCode.BIPUSH:
            case ByteCode.DLOAD:
            case ByteCode.DSTORE:
            case ByteCode.FLOAD:
            case ByteCode.FSTORE:
            case ByteCode.ILOAD:
            case ByteCode.ISTORE:
            case ByteCode.LDC:
            case ByteCode.LLOAD:
            case ByteCode.LSTORE:
            case ByteCode.NEWARRAY:
            case ByteCode.RET:
                return 1;

            case ByteCode.ANEWARRAY:
            case ByteCode.CHECKCAST:
            case ByteCode.GETFIELD:
            case ByteCode.GETSTATIC:
            case ByteCode.GOTO:
            case ByteCode.IFEQ:
            case ByteCode.IFGE:
            case ByteCode.IFGT:
            case ByteCode.IFLE:
            case ByteCode.IFLT:
            case ByteCode.IFNE:
            case ByteCode.IFNONNULL:
            case ByteCode.IFNULL:
            case ByteCode.IF_ACMPEQ:
            case ByteCode.IF_ACMPNE:
            case ByteCode.IF_ICMPEQ:
            case ByteCode.IF_ICMPGE:
            case ByteCode.IF_ICMPGT:
            case ByteCode.IF_ICMPLE:
            case ByteCode.IF_ICMPLT:
            case ByteCode.IF_ICMPNE:
            case ByteCode.IINC:
            case ByteCode.INSTANCEOF:
            case ByteCode.INVOKEINTERFACE:
            case ByteCode.INVOKESPECIAL:
            case ByteCode.INVOKESTATIC:
            case ByteCode.INVOKEVIRTUAL:
            case ByteCode.JSR:
            case ByteCode.LDC2_W:
            case ByteCode.LDC_W:
            case ByteCode.NEW:
            case ByteCode.PUTFIELD:
            case ByteCode.PUTSTATIC:
            case ByteCode.SIPUSH:
                return 2;

            case ByteCode.MULTIANEWARRAY:
                return 3;

            case ByteCode.GOTO_W:
            case ByteCode.JSR_W:
                return 4;

            case ByteCode.LOOKUPSWITCH:    // depends on alignment
            case ByteCode.TABLESWITCH: // depends on alignment
                return -1;
        }
        throw new IllegalArgumentException(&quot;Bad opcode: &quot;+opcode);
    }
*/

    @SuppressWarnings(&quot;unused&quot;)
    private static String bytecodeStr(int code) {
        if (DEBUGSTACK || DEBUGCODE) {
            switch (code) {
                case ByteCode.NOP:
                    return &quot;nop&quot;;
                case ByteCode.ACONST_NULL:
                    return &quot;aconst_null&quot;;
                case ByteCode.ICONST_M1:
                    return &quot;iconst_m1&quot;;
                case ByteCode.ICONST_0:
                    return &quot;iconst_0&quot;;
                case ByteCode.ICONST_1:
                    return &quot;iconst_1&quot;;
                case ByteCode.ICONST_2:
                    return &quot;iconst_2&quot;;
                case ByteCode.ICONST_3:
                    return &quot;iconst_3&quot;;
                case ByteCode.ICONST_4:
                    return &quot;iconst_4&quot;;
                case ByteCode.ICONST_5:
                    return &quot;iconst_5&quot;;
                case ByteCode.LCONST_0:
                    return &quot;lconst_0&quot;;
                case ByteCode.LCONST_1:
                    return &quot;lconst_1&quot;;
                case ByteCode.FCONST_0:
                    return &quot;fconst_0&quot;;
                case ByteCode.FCONST_1:
                    return &quot;fconst_1&quot;;
                case ByteCode.FCONST_2:
                    return &quot;fconst_2&quot;;
                case ByteCode.DCONST_0:
                    return &quot;dconst_0&quot;;
                case ByteCode.DCONST_1:
                    return &quot;dconst_1&quot;;
                case ByteCode.BIPUSH:
                    return &quot;bipush&quot;;
                case ByteCode.SIPUSH:
                    return &quot;sipush&quot;;
                case ByteCode.LDC:
                    return &quot;ldc&quot;;
                case ByteCode.LDC_W:
                    return &quot;ldc_w&quot;;
                case ByteCode.LDC2_W:
                    return &quot;ldc2_w&quot;;
                case ByteCode.ILOAD:
                    return &quot;iload&quot;;
                case ByteCode.LLOAD:
                    return &quot;lload&quot;;
                case ByteCode.FLOAD:
                    return &quot;fload&quot;;
                case ByteCode.DLOAD:
                    return &quot;dload&quot;;
                case ByteCode.ALOAD:
                    return &quot;aload&quot;;
                case ByteCode.ILOAD_0:
                    return &quot;iload_0&quot;;
                case ByteCode.ILOAD_1:
                    return &quot;iload_1&quot;;
                case ByteCode.ILOAD_2:
                    return &quot;iload_2&quot;;
                case ByteCode.ILOAD_3:
                    return &quot;iload_3&quot;;
                case ByteCode.LLOAD_0:
                    return &quot;lload_0&quot;;
                case ByteCode.LLOAD_1:
                    return &quot;lload_1&quot;;
                case ByteCode.LLOAD_2:
                    return &quot;lload_2&quot;;
                case ByteCode.LLOAD_3:
                    return &quot;lload_3&quot;;
                case ByteCode.FLOAD_0:
                    return &quot;fload_0&quot;;
                case ByteCode.FLOAD_1:
                    return &quot;fload_1&quot;;
                case ByteCode.FLOAD_2:
                    return &quot;fload_2&quot;;
                case ByteCode.FLOAD_3:
                    return &quot;fload_3&quot;;
                case ByteCode.DLOAD_0:
                    return &quot;dload_0&quot;;
                case ByteCode.DLOAD_1:
                    return &quot;dload_1&quot;;
                case ByteCode.DLOAD_2:
                    return &quot;dload_2&quot;;
                case ByteCode.DLOAD_3:
                    return &quot;dload_3&quot;;
                case ByteCode.ALOAD_0:
                    return &quot;aload_0&quot;;
                case ByteCode.ALOAD_1:
                    return &quot;aload_1&quot;;
                case ByteCode.ALOAD_2:
                    return &quot;aload_2&quot;;
                case ByteCode.ALOAD_3:
                    return &quot;aload_3&quot;;
                case ByteCode.IALOAD:
                    return &quot;iaload&quot;;
                case ByteCode.LALOAD:
                    return &quot;laload&quot;;
                case ByteCode.FALOAD:
                    return &quot;faload&quot;;
                case ByteCode.DALOAD:
                    return &quot;daload&quot;;
                case ByteCode.AALOAD:
                    return &quot;aaload&quot;;
                case ByteCode.BALOAD:
                    return &quot;baload&quot;;
                case ByteCode.CALOAD:
                    return &quot;caload&quot;;
                case ByteCode.SALOAD:
                    return &quot;saload&quot;;
                case ByteCode.ISTORE:
                    return &quot;istore&quot;;
                case ByteCode.LSTORE:
                    return &quot;lstore&quot;;
                case ByteCode.FSTORE:
                    return &quot;fstore&quot;;
                case ByteCode.DSTORE:
                    return &quot;dstore&quot;;
                case ByteCode.ASTORE:
                    return &quot;astore&quot;;
                case ByteCode.ISTORE_0:
                    return &quot;istore_0&quot;;
                case ByteCode.ISTORE_1:
                    return &quot;istore_1&quot;;
                case ByteCode.ISTORE_2:
                    return &quot;istore_2&quot;;
                case ByteCode.ISTORE_3:
                    return &quot;istore_3&quot;;
                case ByteCode.LSTORE_0:
                    return &quot;lstore_0&quot;;
                case ByteCode.LSTORE_1:
                    return &quot;lstore_1&quot;;
                case ByteCode.LSTORE_2:
                    return &quot;lstore_2&quot;;
                case ByteCode.LSTORE_3:
                    return &quot;lstore_3&quot;;
                case ByteCode.FSTORE_0:
                    return &quot;fstore_0&quot;;
                case ByteCode.FSTORE_1:
                    return &quot;fstore_1&quot;;
                case ByteCode.FSTORE_2:
                    return &quot;fstore_2&quot;;
                case ByteCode.FSTORE_3:
                    return &quot;fstore_3&quot;;
                case ByteCode.DSTORE_0:
                    return &quot;dstore_0&quot;;
                case ByteCode.DSTORE_1:
                    return &quot;dstore_1&quot;;
                case ByteCode.DSTORE_2:
                    return &quot;dstore_2&quot;;
                case ByteCode.DSTORE_3:
                    return &quot;dstore_3&quot;;
                case ByteCode.ASTORE_0:
                    return &quot;astore_0&quot;;
                case ByteCode.ASTORE_1:
                    return &quot;astore_1&quot;;
                case ByteCode.ASTORE_2:
                    return &quot;astore_2&quot;;
                case ByteCode.ASTORE_3:
                    return &quot;astore_3&quot;;
                case ByteCode.IASTORE:
                    return &quot;iastore&quot;;
                case ByteCode.LASTORE:
                    return &quot;lastore&quot;;
                case ByteCode.FASTORE:
                    return &quot;fastore&quot;;
                case ByteCode.DASTORE:
                    return &quot;dastore&quot;;
                case ByteCode.AASTORE:
                    return &quot;aastore&quot;;
                case ByteCode.BASTORE:
                    return &quot;bastore&quot;;
                case ByteCode.CASTORE:
                    return &quot;castore&quot;;
                case ByteCode.SASTORE:
                    return &quot;sastore&quot;;
                case ByteCode.POP:
                    return &quot;pop&quot;;
                case ByteCode.POP2:
                    return &quot;pop2&quot;;
                case ByteCode.DUP:
                    return &quot;dup&quot;;
                case ByteCode.DUP_X1:
                    return &quot;dup_x1&quot;;
                case ByteCode.DUP_X2:
                    return &quot;dup_x2&quot;;
                case ByteCode.DUP2:
                    return &quot;dup2&quot;;
                case ByteCode.DUP2_X1:
                    return &quot;dup2_x1&quot;;
                case ByteCode.DUP2_X2:
                    return &quot;dup2_x2&quot;;
                case ByteCode.SWAP:
                    return &quot;swap&quot;;
                case ByteCode.IADD:
                    return &quot;iadd&quot;;
                case ByteCode.LADD:
                    return &quot;ladd&quot;;
                case ByteCode.FADD:
                    return &quot;fadd&quot;;
                case ByteCode.DADD:
                    return &quot;dadd&quot;;
                case ByteCode.ISUB:
                    return &quot;isub&quot;;
                case ByteCode.LSUB:
                    return &quot;lsub&quot;;
                case ByteCode.FSUB:
                    return &quot;fsub&quot;;
                case ByteCode.DSUB:
                    return &quot;dsub&quot;;
                case ByteCode.IMUL:
                    return &quot;imul&quot;;
                case ByteCode.LMUL:
                    return &quot;lmul&quot;;
                case ByteCode.FMUL:
                    return &quot;fmul&quot;;
                case ByteCode.DMUL:
                    return &quot;dmul&quot;;
                case ByteCode.IDIV:
                    return &quot;idiv&quot;;
                case ByteCode.LDIV:
                    return &quot;ldiv&quot;;
                case ByteCode.FDIV:
                    return &quot;fdiv&quot;;
                case ByteCode.DDIV:
                    return &quot;ddiv&quot;;
                case ByteCode.IREM:
                    return &quot;irem&quot;;
                case ByteCode.LREM:
                    return &quot;lrem&quot;;
                case ByteCode.FREM:
                    return &quot;frem&quot;;
                case ByteCode.DREM:
                    return &quot;drem&quot;;
                case ByteCode.INEG:
                    return &quot;ineg&quot;;
                case ByteCode.LNEG:
                    return &quot;lneg&quot;;
                case ByteCode.FNEG:
                    return &quot;fneg&quot;;
                case ByteCode.DNEG:
                    return &quot;dneg&quot;;
                case ByteCode.ISHL:
                    return &quot;ishl&quot;;
                case ByteCode.LSHL:
                    return &quot;lshl&quot;;
                case ByteCode.ISHR:
                    return &quot;ishr&quot;;
                case ByteCode.LSHR:
                    return &quot;lshr&quot;;
                case ByteCode.IUSHR:
                    return &quot;iushr&quot;;
                case ByteCode.LUSHR:
                    return &quot;lushr&quot;;
                case ByteCode.IAND:
                    return &quot;iand&quot;;
                case ByteCode.LAND:
                    return &quot;land&quot;;
                case ByteCode.IOR:
                    return &quot;ior&quot;;
                case ByteCode.LOR:
                    return &quot;lor&quot;;
                case ByteCode.IXOR:
                    return &quot;ixor&quot;;
                case ByteCode.LXOR:
                    return &quot;lxor&quot;;
                case ByteCode.IINC:
                    return &quot;iinc&quot;;
                case ByteCode.I2L:
                    return &quot;i2l&quot;;
                case ByteCode.I2F:
                    return &quot;i2f&quot;;
                case ByteCode.I2D:
                    return &quot;i2d&quot;;
                case ByteCode.L2I:
                    return &quot;l2i&quot;;
                case ByteCode.L2F:
                    return &quot;l2f&quot;;
                case ByteCode.L2D:
                    return &quot;l2d&quot;;
                case ByteCode.F2I:
                    return &quot;f2i&quot;;
                case ByteCode.F2L:
                    return &quot;f2l&quot;;
                case ByteCode.F2D:
                    return &quot;f2d&quot;;
                case ByteCode.D2I:
                    return &quot;d2i&quot;;
                case ByteCode.D2L:
                    return &quot;d2l&quot;;
                case ByteCode.D2F:
                    return &quot;d2f&quot;;
                case ByteCode.I2B:
                    return &quot;i2b&quot;;
                case ByteCode.I2C:
                    return &quot;i2c&quot;;
                case ByteCode.I2S:
                    return &quot;i2s&quot;;
                case ByteCode.LCMP:
                    return &quot;lcmp&quot;;
                case ByteCode.FCMPL:
                    return &quot;fcmpl&quot;;
                case ByteCode.FCMPG:
                    return &quot;fcmpg&quot;;
                case ByteCode.DCMPL:
                    return &quot;dcmpl&quot;;
                case ByteCode.DCMPG:
                    return &quot;dcmpg&quot;;
                case ByteCode.IFEQ:
                    return &quot;ifeq&quot;;
                case ByteCode.IFNE:
                    return &quot;ifne&quot;;
                case ByteCode.IFLT:
                    return &quot;iflt&quot;;
                case ByteCode.IFGE:
                    return &quot;ifge&quot;;
                case ByteCode.IFGT:
                    return &quot;ifgt&quot;;
                case ByteCode.IFLE:
                    return &quot;ifle&quot;;
                case ByteCode.IF_ICMPEQ:
                    return &quot;if_icmpeq&quot;;
                case ByteCode.IF_ICMPNE:
                    return &quot;if_icmpne&quot;;
                case ByteCode.IF_ICMPLT:
                    return &quot;if_icmplt&quot;;
                case ByteCode.IF_ICMPGE:
                    return &quot;if_icmpge&quot;;
                case ByteCode.IF_ICMPGT:
                    return &quot;if_icmpgt&quot;;
                case ByteCode.IF_ICMPLE:
                    return &quot;if_icmple&quot;;
                case ByteCode.IF_ACMPEQ:
                    return &quot;if_acmpeq&quot;;
                case ByteCode.IF_ACMPNE:
                    return &quot;if_acmpne&quot;;
                case ByteCode.GOTO:
                    return &quot;goto&quot;;
                case ByteCode.JSR:
                    return &quot;jsr&quot;;
                case ByteCode.RET:
                    return &quot;ret&quot;;
                case ByteCode.TABLESWITCH:
                    return &quot;tableswitch&quot;;
                case ByteCode.LOOKUPSWITCH:
                    return &quot;lookupswitch&quot;;
                case ByteCode.IRETURN:
                    return &quot;ireturn&quot;;
                case ByteCode.LRETURN:
                    return &quot;lreturn&quot;;
                case ByteCode.FRETURN:
                    return &quot;freturn&quot;;
                case ByteCode.DRETURN:
                    return &quot;dreturn&quot;;
                case ByteCode.ARETURN:
                    return &quot;areturn&quot;;
                case ByteCode.RETURN:
                    return &quot;return&quot;;
                case ByteCode.GETSTATIC:
                    return &quot;getstatic&quot;;
                case ByteCode.PUTSTATIC:
                    return &quot;putstatic&quot;;
                case ByteCode.GETFIELD:
                    return &quot;getfield&quot;;
                case ByteCode.PUTFIELD:
                    return &quot;putfield&quot;;
                case ByteCode.INVOKEVIRTUAL:
                    return &quot;invokevirtual&quot;;
                case ByteCode.INVOKESPECIAL:
                    return &quot;invokespecial&quot;;
                case ByteCode.INVOKESTATIC:
                    return &quot;invokestatic&quot;;
                case ByteCode.INVOKEINTERFACE:
                    return &quot;invokeinterface&quot;;
                case ByteCode.INVOKEDYNAMIC:
                    return &quot;invokedynamic&quot;;
                case ByteCode.NEW:
                    return &quot;new&quot;;
                case ByteCode.NEWARRAY:
                    return &quot;newarray&quot;;
                case ByteCode.ANEWARRAY:
                    return &quot;anewarray&quot;;
                case ByteCode.ARRAYLENGTH:
                    return &quot;arraylength&quot;;
                case ByteCode.ATHROW:
                    return &quot;athrow&quot;;
                case ByteCode.CHECKCAST:
                    return &quot;checkcast&quot;;
                case ByteCode.INSTANCEOF:
                    return &quot;instanceof&quot;;
                case ByteCode.MONITORENTER:
                    return &quot;monitorenter&quot;;
                case ByteCode.MONITOREXIT:
                    return &quot;monitorexit&quot;;
                case ByteCode.WIDE:
                    return &quot;wide&quot;;
                case ByteCode.MULTIANEWARRAY:
                    return &quot;multianewarray&quot;;
                case ByteCode.IFNULL:
                    return &quot;ifnull&quot;;
                case ByteCode.IFNONNULL:
                    return &quot;ifnonnull&quot;;
                case ByteCode.GOTO_W:
                    return &quot;goto_w&quot;;
                case ByteCode.JSR_W:
                    return &quot;jsr_w&quot;;
                case ByteCode.BREAKPOINT:
                    return &quot;breakpoint&quot;;

                case ByteCode.IMPDEP1:
                    return &quot;impdep1&quot;;
                case ByteCode.IMPDEP2:
                    return &quot;impdep2&quot;;
            }
        }
<span class="nc" id="L4337">        return &quot;&quot;;</span>
    }

    final char[] getCharBuffer(int minimalSize) {
<span class="fc bfc" id="L4341" title="All 2 branches covered.">        if (minimalSize &gt; tmpCharBuffer.length) {</span>
<span class="fc" id="L4342">            int newSize = tmpCharBuffer.length * 2;</span>
<span class="fc bfc" id="L4343" title="All 2 branches covered.">            if (minimalSize &gt; newSize) {</span>
<span class="fc" id="L4344">                newSize = minimalSize;</span>
            }
<span class="fc" id="L4346">            tmpCharBuffer = new char[newSize];</span>
        }
<span class="fc" id="L4348">        return tmpCharBuffer;</span>
    }

    /**
     * Add a pc as the start of super block.
     *
     * A pc is the beginning of a super block if: - pc == 0 - it is the target of a branch instruction
     * - it is the beginning of an exception handler - it is directly after an unconditional jump
     */
    private void addSuperBlockStart(int pc) {
<span class="pc bpc" id="L4358" title="1 of 2 branches missed.">        if (GenerateStackMap) {</span>
<span class="fc bfc" id="L4359" title="All 2 branches covered.">            if (itsSuperBlockStarts == null) {</span>
<span class="fc" id="L4360">                itsSuperBlockStarts = new int[SuperBlockStartsSize];</span>
<span class="fc bfc" id="L4361" title="All 2 branches covered.">            } else if (itsSuperBlockStarts.length == itsSuperBlockStartsTop) {</span>
<span class="fc" id="L4362">                int[] tmp = new int[itsSuperBlockStartsTop * 2];</span>
<span class="fc" id="L4363">                System.arraycopy(itsSuperBlockStarts, 0, tmp, 0,</span>
                    itsSuperBlockStartsTop);
<span class="fc" id="L4365">                itsSuperBlockStarts = tmp;</span>
            }
<span class="fc" id="L4367">            itsSuperBlockStarts[itsSuperBlockStartsTop++] = pc;</span>
        }
<span class="fc" id="L4369">    }</span>

    /**
     * Sort the list of recorded super block starts and remove duplicates.
     *
     * Also adds exception handling blocks as block starts, since there is no explicit control flow to
     * these. Used for stack map table generation.
     */
    private void finalizeSuperBlockStarts() {
<span class="pc bpc" id="L4378" title="1 of 2 branches missed.">        if (GenerateStackMap) {</span>
<span class="fc bfc" id="L4379" title="All 2 branches covered.">            for (int i = 0; i &lt; itsExceptionTableTop; i++) {</span>
<span class="fc" id="L4380">                ExceptionTableEntry ete = itsExceptionTable[i];</span>
<span class="fc" id="L4381">                short handlerPC = (short) getLabelPC(ete.itsHandlerLabel);</span>
<span class="fc" id="L4382">                addSuperBlockStart(handlerPC);</span>
            }
<span class="fc" id="L4384">            Arrays.sort(itsSuperBlockStarts, 0, itsSuperBlockStartsTop);</span>
<span class="fc" id="L4385">            int prev = itsSuperBlockStarts[0];</span>
<span class="fc" id="L4386">            int copyTo = 1;</span>
<span class="fc bfc" id="L4387" title="All 2 branches covered.">            for (int i = 1; i &lt; itsSuperBlockStartsTop; i++) {</span>
<span class="fc" id="L4388">                int curr = itsSuperBlockStarts[i];</span>
<span class="fc bfc" id="L4389" title="All 2 branches covered.">                if (prev != curr) {</span>
<span class="fc bfc" id="L4390" title="All 2 branches covered.">                    if (copyTo != i) {</span>
<span class="fc" id="L4391">                        itsSuperBlockStarts[copyTo] = curr;</span>
                    }
<span class="fc" id="L4393">                    copyTo++;</span>
<span class="fc" id="L4394">                    prev = curr;</span>
                }
            }
<span class="fc" id="L4397">            itsSuperBlockStartsTop = copyTo;</span>
<span class="fc bfc" id="L4398" title="All 2 branches covered.">            if (itsSuperBlockStarts[copyTo - 1] == itsCodeBufferTop) {</span>
<span class="fc" id="L4399">                itsSuperBlockStartsTop--;</span>
            }
        }
<span class="fc" id="L4402">    }</span>

<span class="fc" id="L4404">    private int[] itsSuperBlockStarts = null;</span>
<span class="fc" id="L4405">    private int itsSuperBlockStartsTop = 0;</span>
    private static final int SuperBlockStartsSize = 4;

    // Used to find blocks of code with no dependencies (aka dead code).
    // Necessary for generating type information for dead code, which is
    // expected by the Sun verifier. It is only necessary to store a single
    // jump source to determine if a block is reachable or not.
<span class="fc" id="L4412">    private UintMap itsJumpFroms = null;</span>

    private static final int LineNumberTableSize = 16;
    private static final int ExceptionTableSize = 4;

    private static final int MajorVersion;
    private static final int MinorVersion;
    private static final boolean GenerateStackMap;

    static {
        // Figure out which classfile version should be generated. This assumes
        // that the runtime used to compile the JavaScript files is the same as
        // the one used to run them. This is important because there are cases
        // when bytecode is generated at runtime, where it is not easy to pass
        // along what version is necessary. Instead, we grab the version numbers
        // from the bytecode of this class and use that.
        //
        // Based on the version numbers we scrape, we can also determine what
        // bytecode features we need. For example, Java 6 bytecode (classfile
        // version 50) should have stack maps generated.
<span class="fc" id="L4432">        InputStream is = null;</span>
<span class="fc" id="L4433">        int major = 48, minor = 0;</span>
        try {
<span class="fc" id="L4435">            is = ClassFileWriter.class.getResourceAsStream(&quot;ClassFileWriter.class&quot;);</span>
<span class="pc bpc" id="L4436" title="1 of 2 branches missed.">            if (is == null) {</span>
<span class="nc" id="L4437">                is = ClassLoader.getSystemResourceAsStream(</span>
                    &quot;org/mozilla/classfile/ClassFileWriter.class&quot;);
            }
<span class="fc" id="L4440">            byte[] header = new byte[8];</span>
            // read loop is required since JDK7 will only provide 2 bytes
            // on the first read() - see bug #630111
<span class="fc" id="L4443">            int read = 0;</span>
<span class="fc bfc" id="L4444" title="All 2 branches covered.">            while (read &lt; 8) {</span>
<span class="fc" id="L4445">                int c = is.read(header, read, 8 - read);</span>
<span class="pc bpc" id="L4446" title="1 of 2 branches missed.">                if (c &lt; 0)</span>
<span class="nc" id="L4447">                    throw new IOException();</span>
<span class="fc" id="L4448">                read += c;</span>
<span class="fc" id="L4449">            }</span>
<span class="fc" id="L4450">            minor = (header[4] &lt;&lt; 8) | (header[5] &amp; 0xff);</span>
<span class="fc" id="L4451">            major = (header[6] &lt;&lt; 8) | (header[7] &amp; 0xff);</span>
<span class="nc" id="L4452">        } catch (Exception e) {</span>
            // Unable to get class file, use default bytecode version
        } finally {
<span class="pc" id="L4455">            MinorVersion = minor;</span>
<span class="pc" id="L4456">            MajorVersion = major;</span>
<span class="pc bpc" id="L4457" title="5 of 6 branches missed.">            GenerateStackMap = major &gt;= 50;</span>
<span class="pc bpc" id="L4458" title="5 of 6 branches missed.">            if (is != null) {</span>
                try {
<span class="pc" id="L4460">                    is.close();</span>
<span class="nc" id="L4461">                } catch (IOException e) {</span>
<span class="pc" id="L4462">                }</span>
            }
<span class="nc" id="L4464">        }</span>
<span class="fc" id="L4465">    }</span>

    final class BootstrapEntry {

        final byte[] code;

<span class="nc" id="L4471">        BootstrapEntry(ClassFileWriter.MHandle bsm, Object... bsmArgs) {</span>
<span class="nc" id="L4472">            int length = 2 + 2 + bsmArgs.length * 2;</span>
<span class="nc" id="L4473">            code = new byte[length];</span>
<span class="nc" id="L4474">            putInt16(itsConstantPool.addMethodHandle(bsm), code, 0);</span>
<span class="nc" id="L4475">            putInt16(bsmArgs.length, code, 2);</span>
<span class="nc bnc" id="L4476" title="All 2 branches missed.">            for (int i = 0; i &lt; bsmArgs.length; i++) {</span>
<span class="nc" id="L4477">                putInt16(itsConstantPool.addConstant(bsmArgs[i]), code, 4 + i * 2);</span>
            }
<span class="nc" id="L4479">        }</span>

        @Override
        public boolean equals(Object obj) {
<span class="nc bnc" id="L4483" title="All 2 branches missed.">            return obj instanceof BootstrapEntry</span>
<span class="nc bnc" id="L4484" title="All 2 branches missed.">                &amp;&amp; Arrays.equals(code, ((BootstrapEntry) obj).code);</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L4489">            return ~Arrays.hashCode(code);</span>
        }
    }

    public static final class MHandle {

        final byte tag;
        final String owner;
        final String name;
        final String desc;

<span class="nc" id="L4500">        public MHandle(byte tag, String owner, String name, String desc) {</span>
<span class="nc" id="L4501">            this.tag = tag;</span>
<span class="nc" id="L4502">            this.owner = owner;</span>
<span class="nc" id="L4503">            this.name = name;</span>
<span class="nc" id="L4504">            this.desc = desc;</span>
<span class="nc" id="L4505">        }</span>

        @Override
        public boolean equals(Object obj) {
<span class="nc bnc" id="L4509" title="All 2 branches missed.">            if (obj == this) {</span>
<span class="nc" id="L4510">                return true;</span>
            }
<span class="nc bnc" id="L4512" title="All 2 branches missed.">            if (!(obj instanceof MHandle)) {</span>
<span class="nc" id="L4513">                return false;</span>
            }
<span class="nc" id="L4515">            MHandle mh = (MHandle) obj;</span>
<span class="nc bnc" id="L4516" title="All 4 branches missed.">            return tag == mh.tag &amp;&amp; owner.equals(mh.owner)</span>
<span class="nc bnc" id="L4517" title="All 4 branches missed.">                &amp;&amp; name.equals(mh.name) &amp;&amp; desc.equals(mh.desc);</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L4522">            return tag + owner.hashCode() * name.hashCode() * desc.hashCode();</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L4527">            return owner + '.' + name + desc + &quot; (&quot; + tag + ')';</span>
        }
    }

    private final static int FileHeaderConstant = 0xCAFEBABE;
    // Set DEBUG flags to true to get better checking and progress info.
    private static final boolean DEBUGSTACK = false;
    private static final boolean DEBUGLABELS = false;
    private static final boolean DEBUGCODE = false;

    private String generatedClassName;

    private ExceptionTableEntry itsExceptionTable[];
    private int itsExceptionTableTop;

    private int itsLineNumberTable[];   // pack start_pc &amp; line_number together
    private int itsLineNumberTableTop;

<span class="fc" id="L4545">    private byte[] itsCodeBuffer = new byte[256];</span>
    private int itsCodeBufferTop;

    private ConstantPool itsConstantPool;

    private ClassFileMethod itsCurrentMethod;
    private short itsStackTop;

    private short itsMaxStack;
    private short itsMaxLocals;

<span class="fc" id="L4556">    private ObjArray itsMethods = new ObjArray();</span>
<span class="fc" id="L4557">    private ObjArray itsFields = new ObjArray();</span>
<span class="fc" id="L4558">    private ObjArray itsInterfaces = new ObjArray();</span>

    private short itsFlags;
    private short itsThisClassIndex;
    private short itsSuperClassIndex;
    private short itsSourceFileNameIndex;

    private static final int MIN_LABEL_TABLE_SIZE = 32;
    private int[] itsLabelTable;
    private int itsLabelTableTop;

    // itsFixupTable[i] = (label_index &lt;&lt; 32) | fixup_site
    private static final int MIN_FIXUP_TABLE_SIZE = 40;
    private long[] itsFixupTable;
    private int itsFixupTableTop;
    private ObjArray itsVarDescriptors;
    private ObjArray itsBootstrapMethods;
<span class="fc" id="L4575">    private int itsBootstrapMethodsLength = 0;</span>

<span class="fc" id="L4577">    private char[] tmpCharBuffer = new char[64];</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>