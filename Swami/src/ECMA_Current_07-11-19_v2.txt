############# BEGIN ## 1 ###########################
ID= 6.2.3.4
Summary= UpdateEmpty ( completionRecord, value )
Description= The abstract operation UpdateEmpty with arguments completionRecord and value performs the following steps:
*0*assert: if VARcompletionrecord.[[TYPE]] is either return or throw, then VARcompletionrecord.[[VALUE]] is not empty. 
*0*if VARcompletionrecord.[[VALUE]] is not empty, return FUNCcompletion(VARcompletionrecord). 
*0*return completion { [[TYPE]]: VARcompletionrecord.[[TYPE]], [[VALUE]]: VARvalue, [[TARGET]]: VARcompletionrecord.[[TARGET]] }.     

############# END ## 1 ###########################
############# BEGIN ## 2 ###########################
ID= 6.2.4.1
Summary= GetBase ( V )
Description= None
*0*assert: FUNCtype(VARv) is reference. 
*0*return the base value component of VARv.     

############# END ## 2 ###########################
############# BEGIN ## 3 ###########################
ID= 6.2.4.2
Summary= GetReferencedName ( V )
Description= None
*0*assert: FUNCtype(VARv) is reference. 
*0*return the referenced name component of VARv.     

############# END ## 3 ###########################
############# BEGIN ## 4 ###########################
ID= 6.2.4.3
Summary= IsStrictReference ( V )
Description= None
*0*assert: FUNCtype(VARv) is reference. 
*0*return the strict reference flag of VARv.     

############# END ## 4 ###########################
############# BEGIN ## 5 ###########################
ID= 6.2.4.4
Summary= HasPrimitiveBase ( V )
Description= None
*0*assert: FUNCtype(VARv) is reference. 
*0*if FUNCtype(VARv's base value component) is boolean, string, symbol, or number, return true; otherwise return false.     

############# END ## 5 ###########################
############# BEGIN ## 6 ###########################
ID= 6.2.4.5
Summary= IsPropertyReference ( V )
Description= None
*0*assert: FUNCtype(VARv) is reference. 
*0*if either the base value component of VARv is an object or FUNChasprimitivebase(VARv) is true, return true; otherwise return false.     

############# END ## 6 ###########################
############# BEGIN ## 7 ###########################
ID= 6.2.4.6
Summary= IsUnresolvableReference ( V )
Description= None
*0*assert: FUNCtype(VARv) is reference. 
*0*if the base value component of VARv is undefined, return true; otherwise return false.     

############# END ## 7 ###########################
############# BEGIN ## 8 ###########################
ID= 6.2.4.7
Summary= IsSuperReference ( V )
Description= None
*0*assert: FUNCtype(VARv) is reference. 
*0*if VARv has a thisvalue component, return true; otherwise return false.     

############# END ## 8 ###########################
############# BEGIN ## 9 ###########################
ID= 6.2.4.8
Summary= GetValue ( V )
Description= The object that may be created in step 5.a.ii is not accessible outside of the above abstract operation and the ordinary object [[Get]] internal method. An implementation might choose to avoid the actual creation of the object.
*0*FUNCreturnifabrupt(VARv). 
*0*if FUNCtype(VARv) is not reference, return VARv. 
*0*let VARbase be FUNCgetbase(VARv). 
*0*if FUNCisunresolvablereference(VARv) is true, throw a referenceerror exception. 
*0*if FUNCispropertyreference(VARv) is true, then
*1*if FUNChasprimitivebase(VARv) is true, then
*2*assert: in this case, VARbase will never be undefined or null. 
*2*set VARbase to ! FUNCtoobject(VARbase). 
*1*return ? VARbase.[[GET]](FUNCgetreferencedname(VARv), FUNCgetthisvalue(VARv)). 
*0*else VARbase must be an environment record,
*1*return ? VARbase.getbindingvalue(FUNCgetreferencedname(VARv), FUNCisstrictreference(VARv)) (see 8.1.1).     

############# END ## 9 ###########################
############# BEGIN ## 10 ###########################
ID= 6.2.4.9
Summary= PutValue ( V, W )
Description= The object that may be created in step 6.a.ii is not accessible outside of the above algorithm and the ordinary object [[Set]] internal method. An implementation might choose to avoid the actual creation of that object.
*0*FUNCreturnifabrupt(VARv). 
*0*FUNCreturnifabrupt(VARw). 
*0*if FUNCtype(VARv) is not reference, throw a referenceerror exception. 
*0*let VARbase be FUNCgetbase(VARv). 
*0*if FUNCisunresolvablereference(VARv) is true, then
*1*if FUNCisstrictreference(VARv) is true, then
*2*throw a referenceerror exception. 
*1*let VARglobalobj be FUNCgetglobalobject(). 
*1*return ? FUNCset(VARglobalobj, FUNCgetreferencedname(VARv), VARw, false). 
*0*else if FUNCispropertyreference(VARv) is true, then
*1*if FUNChasprimitivebase(VARv) is true, then
*2*assert: in this case, VARbase will never be undefined or null. 
*2*set VARbase to ! FUNCtoobject(VARbase). 
*1*let VARsucceeded be ? VARbase.[[SET]](FUNCgetreferencedname(VARv), VARw, FUNCgetthisvalue(VARv)). 
*1*if VARsucceeded is false and FUNCisstrictreference(VARv) is true, throw a typeerror exception. 
*1*return. 
*0*else VARbase must be an environment record,
*1*return ? VARbase.setmutablebinding(FUNCgetreferencedname(VARv), VARw, FUNCisstrictreference(VARv)) (see 8.1.1).     

############# END ## 10 ###########################
############# BEGIN ## 11 ###########################
ID= 6.2.4.10
Summary= GetThisValue ( V )
Description= None
*0*assert: FUNCispropertyreference(VARv) is true. 
*0*if FUNCissuperreference(VARv) is true, then
*1*return the value of the thisvalue component of the reference VARv. 
*0*return FUNCgetbase(VARv).     

############# END ## 11 ###########################
############# BEGIN ## 12 ###########################
ID= 6.2.4.11
Summary= InitializeReferencedBinding ( V, W )
Description= None
*0*FUNCreturnifabrupt(VARv). 
*0*FUNCreturnifabrupt(VARw). 
*0*assert: FUNCtype(VARv) is reference. 
*0*assert: FUNCisunresolvablereference(VARv) is false. 
*0*let VARbase be FUNCgetbase(VARv). 
*0*assert: VARbase is an environment record. 
*0*return VARbase.initializebinding(FUNCgetreferencedname(VARv), VARw).     

############# END ## 12 ###########################
############# BEGIN ## 13 ###########################
ID= 6.2.5.1
Summary= IsAccessorDescriptor ( Desc )
Description= When the abstract operation IsAccessorDescriptor is called with Property Descriptor Desc, the following steps are taken:
*0*if VARdesc is undefined, return false. 
*0*if both VARdesc.[[GET]] and VARdesc.[[SET]] are absent, return false. 
*0*return true.     

############# END ## 13 ###########################
############# BEGIN ## 14 ###########################
ID= 6.2.5.2
Summary= IsDataDescriptor ( Desc )
Description= When the abstract operation IsDataDescriptor is called with Property Descriptor Desc, the following steps are taken:
*0*if VARdesc is undefined, return false. 
*0*if both VARdesc.[[VALUE]] and VARdesc.[[WRITABLE]] are absent, return false. 
*0*return true.     

############# END ## 14 ###########################
############# BEGIN ## 15 ###########################
ID= 6.2.5.3
Summary= IsGenericDescriptor ( Desc )
Description= When the abstract operation IsGenericDescriptor is called with Property Descriptor Desc, the following steps are taken:
*0*if VARdesc is undefined, return false. 
*0*if FUNCisaccessordescriptor(VARdesc) and FUNCisdatadescriptor(VARdesc) are both false, return true. 
*0*return false.     

############# END ## 15 ###########################
############# BEGIN ## 16 ###########################
ID= 6.2.5.4
Summary= FromPropertyDescriptor ( Desc )
Description= When the abstract operation FromPropertyDescriptor is called with Property Descriptor Desc, the following steps are taken:
*0*if VARdesc is undefined, return undefined. 
*0*let VARobj be FUNCobjectcreate(%objectprototype%). 
*0*assert: VARobj is an extensible ordinary object with no own properties. 
*0*if VARdesc has a [[VALUE]] field, then
*1*perform FUNCcreatedataproperty(VARobj, "value", VARdesc.[[VALUE]]). 
*0*if VARdesc has a [[WRITABLE]] field, then
*1*perform FUNCcreatedataproperty(VARobj, "writable", VARdesc.[[WRITABLE]]). 
*0*if VARdesc has a [[GET]] field, then
*1*perform FUNCcreatedataproperty(VARobj, "get", VARdesc.[[GET]]). 
*0*if VARdesc has a [[SET]] field, then
*1*perform FUNCcreatedataproperty(VARobj, "set", VARdesc.[[SET]]). 
*0*if VARdesc has an [[ENUMERABLE]] field, then
*1*perform FUNCcreatedataproperty(VARobj, "enumerable", VARdesc.[[ENUMERABLE]]). 
*0*if VARdesc has a [[CONFIGURABLE]] field, then
*1*perform FUNCcreatedataproperty(VARobj, "configurable", VARdesc.[[CONFIGURABLE]]). 
*0*assert: all of the above createdataproperty operations return true. 
*0*return VARobj.     

############# END ## 16 ###########################
############# BEGIN ## 17 ###########################
ID= 6.2.5.5
Summary= ToPropertyDescriptor ( Obj )
Description= When the abstract operation ToPropertyDescriptor is called with object Obj, the following steps are taken:
*0*if FUNCtype(VARobj) is not object, throw a typeerror exception. 
*0*let VARdesc be a new property descriptor that initially has no fields. 
*0*let VARhasenumerable be ? FUNChasproperty(VARobj, "enumerable"). 
*0*if VARhasenumerable is true, then
*1*let VARenum be FUNCtoboolean(? FUNCget(VARobj, "enumerable")). 
*1*set VARdesc.[[ENUMERABLE]] to VARenum. 
*0*let VARhasconfigurable be ? FUNChasproperty(VARobj, "configurable"). 
*0*if VARhasconfigurable is true, then
*1*let VARconf be FUNCtoboolean(? FUNCget(VARobj, "configurable")). 
*1*set VARdesc.[[CONFIGURABLE]] to VARconf. 
*0*let VARhasvalue be ? FUNChasproperty(VARobj, "value"). 
*0*if VARhasvalue is true, then
*1*let VARvalue be ? FUNCget(VARobj, "value"). 
*1*set VARdesc.[[VALUE]] to VARvalue. 
*0*let VARhaswritable be ? FUNChasproperty(VARobj, "writable"). 
*0*if VARhaswritable is true, then
*1*let VARwritable be FUNCtoboolean(? FUNCget(VARobj, "writable")). 
*1*set VARdesc.[[WRITABLE]] to VARwritable. 
*0*let VARhasget be ? FUNChasproperty(VARobj, "get"). 
*0*if VARhasget is true, then
*1*let VARgetter be ? FUNCget(VARobj, "get"). 
*1*if FUNCiscallable(VARgetter) is false and VARgetter is not undefined, throw a typeerror exception. 
*1*set VARdesc.[[GET]] to VARgetter. 
*0*let VARhasset be ? FUNChasproperty(VARobj, "set"). 
*0*if VARhasset is true, then
*1*let VARsetter be ? FUNCget(VARobj, "set"). 
*1*if FUNCiscallable(VARsetter) is false and VARsetter is not undefined, throw a typeerror exception. 
*1*set VARdesc.[[SET]] to VARsetter. 
*0*if VARdesc.[[GET]] is present or VARdesc.[[SET]] is present, then
*1*if VARdesc.[[VALUE]] is present or VARdesc.[[WRITABLE]] is present, throw a typeerror exception. 
*0*return VARdesc.     

############# END ## 17 ###########################
############# BEGIN ## 18 ###########################
ID= 6.2.5.6
Summary= CompletePropertyDescriptor ( Desc )
Description= When the abstract operation CompletePropertyDescriptor is called with Property Descriptor Desc, the following steps are taken:
*0*assert: VARdesc is a property descriptor. 
*0*let VARlike be record { [[VALUE]]: undefined, [[WRITABLE]]: false, [[GET]]: undefined, [[SET]]: undefined, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }. 
*0*if FUNCisgenericdescriptor(VARdesc) is true or FUNCisdatadescriptor(VARdesc) is true, then
*1*if VARdesc does not have a [[VALUE]] field, set VARdesc.[[VALUE]] to VARlike.[[VALUE]]. 
*1*if VARdesc does not have a [[WRITABLE]] field, set VARdesc.[[WRITABLE]] to VARlike.[[WRITABLE]]. 
*0*else,
*1*if VARdesc does not have a [[GET]] field, set VARdesc.[[GET]] to VARlike.[[GET]]. 
*1*if VARdesc does not have a [[SET]] field, set VARdesc.[[SET]] to VARlike.[[SET]]. 
*0*if VARdesc does not have an [[ENUMERABLE]] field, set VARdesc.[[ENUMERABLE]] to VARlike.[[ENUMERABLE]]. 
*0*if VARdesc does not have a [[CONFIGURABLE]] field, set VARdesc.[[CONFIGURABLE]] to VARlike.[[CONFIGURABLE]]. 
*0*return VARdesc.     

############# END ## 18 ###########################
############# BEGIN ## 19 ###########################
ID= 6.2.7.1
Summary= CreateByteDataBlock ( size )
Description= When the abstract operation CreateByteDataBlock is called with integer argument size, the following steps are taken:
*0*assert: VARsize≥0. 
*0*let VARdb be a new data block value consisting of VARsize bytes. if it is impossible to create such a data block, throw a rangeerror exception. 
*0*set all of the bytes of VARdb to 0. 
*0*return VARdb.     

############# END ## 19 ###########################
############# BEGIN ## 20 ###########################
ID= 6.2.7.2
Summary= CreateSharedByteDataBlock ( size )
Description= When the abstract operation CreateSharedByteDataBlock is called with integer argument size, the following steps are taken:
*0*assert: VARsize≥0. 
*0*let VARdb be a new shared data block value consisting of VARsize bytes. if it is impossible to create such a shared data block, throw a rangeerror exception. 
*0*let VARexecution be the [[CANDIDATEEXECUTION]] field of the surrounding agent's agent record. 
*0*let VAReventlist be the [[EVENTLIST]] field of the element in VARexecution.[[EVENTLISTS]] whose [[AGENTSIGNIFIER]] is FUNCagentsignifier(). 
*0*let VARzero be « 0 ». 
*0*for each index VARi of VARdb, do
*1*append writesharedmemory { [[ORDER]]: "init", [[NOTEAR]]: true, [[BLOCK]]: VARdb, [[BYTEINDEX]]: VARi, [[ELEMENTSIZE]]: 1, [[PAYLOAD]]: VARzero } to VAReventlist. 
*0*return VARdb.     

############# END ## 20 ###########################
############# BEGIN ## 21 ###########################
ID= 6.2.7.3
Summary= CopyDataBlockBytes ( toBlock, toIndex, fromBlock, fromIndex, count )
Description= When the abstract operation CopyDataBlockBytes is called, the following steps are taken:
*0*assert: VARfromblock and VARtoblock are distinct data block or shared data block values. 
*0*assert: VARfromindex, VARtoindex, and VARcount are integer values ≥ 0. 
*0*let VARfromsize be the number of bytes in VARfromblock. 
*0*assert: VARfromindex+VARcount ≤ VARfromsize. 
*0*let VARtosize be the number of bytes in VARtoblock. 
*0*assert: VARtoindex+VARcount ≤ VARtosize. 
*0*repeat, while VARcount&gt;0
*1*if VARfromblock is a shared data block, then
*2*let VARexecution be the [[CANDIDATEEXECUTION]] field of the surrounding agent's agent record. 
*2*let VAReventlist be the [[EVENTLIST]] field of the element in VARexecution.[[EVENTLISTS]] whose [[AGENTSIGNIFIER]] is FUNCagentsignifier(). 
*2*let VARbytes be a list of length 1 that contains a nondeterministically chosen byte value. 
*2*note: in implementations, VARbytes is the result of a non-atomic read instruction on the underlying hardware. the nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency. 
*2*let VARreadevent be readsharedmemory { [[ORDER]]: "unordered", [[NOTEAR]]: true, [[BLOCK]]: VARfromblock, [[BYTEINDEX]]: VARfromindex, [[ELEMENTSIZE]]: 1 }. 
*2*append VARreadevent to VAReventlist. 
*2*append chosen value record { [[EVENT]]: VARreadevent, [[CHOSENVALUE]]: VARbytes } to VARexecution.[[CHOSENVALUES]]. 
*2*if VARtoblock is a shared data block, then
*3*append writesharedmemory { [[ORDER]]: "unordered", [[NOTEAR]]: true, [[BLOCK]]: VARtoblock, [[BYTEINDEX]]: VARtoindex, [[ELEMENTSIZE]]: 1, [[PAYLOAD]]: VARbytes } to VAReventlist. 
*2*else,
*3*set VARtoblock[VARtoindex] to VARbytes[0]. 
*1*else,
*2*assert: VARtoblock is not a shared data block. 
*2*set VARtoblock[VARtoindex] to VARfromblock[VARfromindex]. 
*1*increment VARtoindex and VARfromindex each by 1. 
*1*decrement VARcount by 1. 
*0*return FUNCnormalcompletion(empty).     

############# END ## 21 ###########################
############# BEGIN ## 22 ###########################
ID= 7.1.1
Summary= ToPrimitive ( input [ , PreferredType ] )
Description= The abstract operation ToPrimitive takes an input argument and an optional argument PreferredType. The abstract operation ToPrimitive converts its input argument to a non-Object type. If an object is capable of converting to more than one primitive type, it may use the optional hint PreferredType to favour that type. Conversion occurs according to the following algorithm:
*0*assert: VARinput is an ecmascript language value. 
*0*if FUNCtype(VARinput) is object, then
*1*if VARpreferredtype is not present, let VARhint be "default". 
*1*else if VARpreferredtype is hint string, let VARhint be "string". 
*1*else VARpreferredtype is hint number, let VARhint be "number". 
*1*let VARexotictoprim be ? FUNCgetmethod(VARinput, @@toprimitive). 
*1*if VARexotictoprim is not undefined, then
*2*let VARresult be ? FUNCcall(VARexotictoprim, VARinput, « VARhint »). 
*2*if FUNCtype(VARresult) is not object, return VARresult. 
*2*throw a typeerror exception. 
*1*if VARhint is "default", set VARhint to "number". 
*1*return ? FUNCordinarytoprimitive(VARinput, VARhint). 
*0*return VARinput.    

############# END ## 22 ###########################
############# BEGIN ## 23 ###########################
ID= 7.1.1.1
Summary= OrdinaryToPrimitive ( O, hint )
Description= When the abstract operation OrdinaryToPrimitive is called with arguments O and hint, the following steps are taken:
*0*assert: FUNCtype(VARo) is object. 
*0*assert: FUNCtype(VARhint) is string and its value is either "string" or "number". 
*0*if VARhint is "string", then
*1*let VARmethodnames be « "tostring", "valueof" ». 
*0*else,
*1*let VARmethodnames be « "valueof", "tostring" ». 
*0*for each VARname in VARmethodnames in list order, do
*1*let VARmethod be ? FUNCget(VARo, VARname). 
*1*if FUNCiscallable(VARmethod) is true, then
*2*let VARresult be ? FUNCcall(VARmethod, VARo). 
*2*if FUNCtype(VARresult) is not object, return VARresult. 
*0*throw a typeerror exception.     

############# END ## 23 ###########################
############# BEGIN ## 24 ###########################
ID= 7.1.3
Summary= ToNumber ( argument )
Description= The abstract operation ToNumber converts argument to a value of type Number according to  Table 10:
*0*let VARprimvalue be ? FUNCtoprimitive(VARargument, hint number). 
*0*return ? FUNCtonumber(VARprimvalue).        

############# END ## 24 ###########################
############# BEGIN ## 25 ###########################
ID= 7.1.4
Summary= ToInteger ( argument )
Description= The abstract operation ToInteger converts argument to an integral numeric value. This abstract operation functions as follows:
*0*let VARnumber be ? FUNCtonumber(VARargument). 
*0*if VARnumber is nan, return +0. 
*0*if VARnumber is +0, -0, +∞, or -∞, return VARnumber. 
*0*return the number value that is the same sign as VARnumber and whose magnitude is floor(abs(VARnumber)).    

############# END ## 25 ###########################
############# BEGIN ## 26 ###########################
ID= 7.1.5
Summary= ToInt32 ( argument )
Description= The abstract operation ToInt32 converts argument to one of 232 integer values in the range  -231 through  231-1, inclusive. This abstract operation functions as follows:
*0*let VARnumber be ? FUNCtonumber(VARargument). 
*0*if VARnumber is nan, +0, -0, +∞, or -∞, return +0. 
*0*let VARint be the mathematical value that is the same sign as VARnumber and whose magnitude is floor(abs(VARnumber)). 
*0*let VARint32bit be VARint modulo 232. 
*0*if VARint32bit ≥ 231, return VARint32bit - 232; otherwise return VARint32bit.    

############# END ## 26 ###########################
############# BEGIN ## 27 ###########################
ID= 7.1.6
Summary= ToUint32 ( argument )
Description= The abstract operation ToUint32 converts argument to one of 232 integer values in the range 0 through  232-1, inclusive. This abstract operation functions as follows:
*0*let VARnumber be ? FUNCtonumber(VARargument). 
*0*if VARnumber is nan, +0, -0, +∞, or -∞, return +0. 
*0*let VARint be the mathematical value that is the same sign as VARnumber and whose magnitude is floor(abs(VARnumber)). 
*0*let VARint32bit be VARint modulo 232. 
*0*return VARint32bit.    

############# END ## 27 ###########################
############# BEGIN ## 28 ###########################
ID= 7.1.7
Summary= ToInt16 ( argument )
Description= The abstract operation ToInt16 converts argument to one of 216 integer values in the range -32768 through 32767, inclusive. This abstract operation functions as follows:
*0*let VARnumber be ? FUNCtonumber(VARargument). 
*0*if VARnumber is nan, +0, -0, +∞, or -∞, return +0. 
*0*let VARint be the mathematical value that is the same sign as VARnumber and whose magnitude is floor(abs(VARnumber)). 
*0*let VARint16bit be VARint modulo 216. 
*0*if VARint16bit ≥ 215, return VARint16bit - 216; otherwise return VARint16bit.    

############# END ## 28 ###########################
############# BEGIN ## 29 ###########################
ID= 7.1.8
Summary= ToUint16 ( argument )
Description= The abstract operation ToUint16 converts argument to one of 216 integer values in the range 0 through  216-1, inclusive. This abstract operation functions as follows:
*0*let VARnumber be ? FUNCtonumber(VARargument). 
*0*if VARnumber is nan, +0, -0, +∞, or -∞, return +0. 
*0*let VARint be the mathematical value that is the same sign as VARnumber and whose magnitude is floor(abs(VARnumber)). 
*0*let VARint16bit be VARint modulo 216. 
*0*return VARint16bit.    

############# END ## 29 ###########################
############# BEGIN ## 30 ###########################
ID= 7.1.9
Summary= ToInt8 ( argument )
Description= The abstract operation ToInt8 converts argument to one of 28 integer values in the range -128 through 127, inclusive. This abstract operation functions as follows:
*0*let VARnumber be ? FUNCtonumber(VARargument). 
*0*if VARnumber is nan, +0, -0, +∞, or -∞, return +0. 
*0*let VARint be the mathematical value that is the same sign as VARnumber and whose magnitude is floor(abs(VARnumber)). 
*0*let VARint8bit be VARint modulo 28. 
*0*if VARint8bit ≥ 27, return VARint8bit - 28; otherwise return VARint8bit.    

############# END ## 30 ###########################
############# BEGIN ## 31 ###########################
ID= 7.1.10
Summary= ToUint8 ( argument )
Description= The abstract operation ToUint8 converts argument to one of 28 integer values in the range 0 through 255, inclusive. This abstract operation functions as follows:
*0*let VARnumber be ? FUNCtonumber(VARargument). 
*0*if VARnumber is nan, +0, -0, +∞, or -∞, return +0. 
*0*let VARint be the mathematical value that is the same sign as VARnumber and whose magnitude is floor(abs(VARnumber)). 
*0*let VARint8bit be VARint modulo 28. 
*0*return VARint8bit.    

############# END ## 31 ###########################
############# BEGIN ## 32 ###########################
ID= 7.1.11
Summary= ToUint8Clamp ( argument )
Description= The abstract operation ToUint8Clamp converts argument to one of 28 integer values in the range 0 through 255, inclusive. This abstract operation functions as follows:
*0*let VARnumber be ? FUNCtonumber(VARargument). 
*0*if VARnumber is nan, return +0. 
*0*if VARnumber ≤ 0, return +0. 
*0*if VARnumber ≥ 255, return 255. 
*0*let VARf be floor(VARnumber). 
*0*if VARf + 0.5 &lt; VARnumber, return VARf + 1. 
*0*if VARnumber &lt; VARf + 0.5, return VARf. 
*0*if VARf is odd, return VARf + 1. 
*0*return VARf.    

############# END ## 32 ###########################
############# BEGIN ## 33 ###########################
ID= 7.1.12
Summary= ToString ( argument )
Description= The abstract operation ToString converts argument to a value of type String according to  Table 11:
*0*let VARprimvalue be ? FUNCtoprimitive(VARargument, hint string). 
*0*return ? FUNCtostring(VARprimvalue).        

############# END ## 33 ###########################
############# BEGIN ## 34 ###########################
ID= 7.1.12.1
Summary= NumberToString ( m )
Description= The abstract operation NumberToString converts a Number m to String format as follows:
*0*if VARm is nan, return the string "nan". 
*0*if VARm is +0 or -0, return the string "0". 
*0*if VARm is less than zero, return the FUNCstring-concatenation of "-" and ! numbertostring(-VARm). 
*0*if VARm is +∞, return the string "infinity". 
*0*otherwise, let VARn, VARk, and VARs be integers such that VARk ≥ 1, 10VARk-1 ≤ VARs &lt; 10VARk, the number value for VARs × 10VARn-VARk is VARm, and VARk is as small as possible. note that VARk is the number of digits in the decimal representation of VARs, that VARs is not divisible by 10, and that the least significant digit of VARs is not necessarily uniquely determined by these criteria. 
*0*if VARk ≤ VARn ≤ 21, return the string-concatenation of:the code units of the VARk digits of the decimal representation of VARs (in order, with no leading zeroes) VARn-VARk occurrences of the code unit 0x0030 (digit zero) 
*0*if 0 &lt; VARn ≤ 21, return the string-concatenation of:the code units of the most significant VARn digits of the decimal representation of VARs the code unit 0x002e (full stop) the code units of the remaining VARk-VARn digits of the decimal representation of VARs 
*0*if -6 &lt; VARn ≤ 0, return the string-concatenation of:the code unit 0x0030 (digit zero) the code unit 0x002e (full stop) -VARn occurrences of the code unit 0x0030 (digit zero) the code units of the VARk digits of the decimal representation of VARs 
*0*otherwise, if VARk = 1, return the FUNCstring-concatenation of:the code unit of the single digit of VARsthe code unit 0x0065 (latin small letter e)the code unit 0x002b (plus sign) or the code unit 0x002d (hyphen-minus) according to whether VARn-1 is positive or negativethe code units of the decimal representation of the integer abs(VARn-1) (with no leading zeroes) 
*0*return the FUNCstring-concatenation of:the code units of the most significant digit of the decimal representation of VARsthe code unit 0x002e (full stop)the code units of the remaining VARk-1 digits of the decimal representation of VARsthe code unit 0x0065 (latin small letter e)the code unit 0x002b (plus sign) or the code unit 0x002d (hyphen-minus) according to whether VARn-1 is positive or negativethe code units of the decimal representation of the integer abs(VARn-1) (with no leading zeroes)     

############# END ## 34 ###########################
############# BEGIN ## 35 ###########################
ID= 7.1.14
Summary= ToPropertyKey ( argument )
Description= The abstract operation ToPropertyKey converts argument to a value that can be used as a property key by performing the following steps:
*0*let VARkey be ? FUNCtoprimitive(VARargument, hint string). 
*0*if FUNCtype(VARkey) is symbol, then
*1*return VARkey. 
*0*return ! FUNCtostring(VARkey).    

############# END ## 35 ###########################
############# BEGIN ## 36 ###########################
ID= 7.1.15
Summary= ToLength ( argument )
Description= The abstract operation ToLength converts argument to an integer suitable for use as the length of an array-like object. It performs the following steps:
*0*let VARlen be ? FUNCtointeger(VARargument). 
*0*if VARlen ≤ +0, return +0. 
*0*return min(VARlen, 253-1).    

############# END ## 36 ###########################
############# BEGIN ## 37 ###########################
ID= 7.1.16
Summary= CanonicalNumericIndexString ( argument )
Description= The abstract operation CanonicalNumericIndexString returns argument converted to a numeric value if it is a String representation of a Number that would be produced by ToString, or the string "-0". Otherwise, it returns undefined. This abstract operation functions as follows:
*0*assert: FUNCtype(VARargument) is string. 
*0*if VARargument is "-0", return -0. 
*0*let VARn be ! FUNCtonumber(VARargument). 
*0*if FUNCsamevalue(! FUNCtostring(VARn), VARargument) is false, return undefined. 
*0*return VARn.    

############# END ## 37 ###########################
############# BEGIN ## 38 ###########################
ID= 7.1.17
Summary= ToIndex ( value )
Description= The abstract operation ToIndex returns value argument converted to a numeric value if it is a valid integer index value. This abstract operation functions as follows:
*0*if VARvalue is undefined, then
*1*let VARindex be 0. 
*0*else,
*1*let VARintegerindex be ? FUNCtointeger(VARvalue). 
*1*if VARintegerindex &lt; 0, throw a rangeerror exception. 
*1*let VARindex be ! FUNCtolength(VARintegerindex). 
*1*if FUNCsamevaluezero(VARintegerindex, VARindex) is false, throw a rangeerror exception. 
*0*return VARindex.    

############# END ## 38 ###########################
############# BEGIN ## 39 ###########################
ID= 7.2.2
Summary= IsArray ( argument )
Description= The abstract operation IsArray takes one argument argument, and performs the following steps:
*0*if FUNCtype(VARargument) is not object, return false. 
*0*if VARargument is an array exotic object, return true. 
*0*if VARargument is a proxy exotic object, then
*1*if VARargument.[[PROXYHANDLER]] is null, throw a typeerror exception. 
*1*let VARtarget be VARargument.[[PROXYTARGET]]. 
*1*return ? FUNCisarray(VARtarget). 
*0*return false.    

############# END ## 39 ###########################
############# BEGIN ## 40 ###########################
ID= 7.2.3
Summary= IsCallable ( argument )
Description= The abstract operation IsCallable determines if argument, which must be an ECMAScript language value, is a callable function with a [[Call]] internal method.
*0*if FUNCtype(VARargument) is not object, return false. 
*0*if VARargument has a [[CALL]] internal method, return true. 
*0*return false.    

############# END ## 40 ###########################
############# BEGIN ## 41 ###########################
ID= 7.2.4
Summary= IsConstructor ( argument )
Description= The abstract operation IsConstructor determines if argument, which must be an ECMAScript language value, is a function object with a [[Construct]] internal method.
*0*if FUNCtype(VARargument) is not object, return false. 
*0*if VARargument has a [[CONSTRUCT]] internal method, return true. 
*0*return false.    

############# END ## 41 ###########################
############# BEGIN ## 42 ###########################
ID= 7.2.5
Summary= IsExtensible ( O )
Description= The abstract operation IsExtensible is used to determine whether additional properties can be added to the object that is O. A Boolean value is returned. This abstract operation performs the following steps:
*0*assert: FUNCtype(VARo) is object. 
*0*return ? VARo.[[ISEXTENSIBLE]]().    

############# END ## 42 ###########################
############# BEGIN ## 43 ###########################
ID= 7.2.6
Summary= IsInteger ( argument )
Description= The abstract operation IsInteger determines if argument is a finite integer numeric value.
*0*if FUNCtype(VARargument) is not number, return false. 
*0*if VARargument is nan, +∞, or -∞, return false. 
*0*if floor(abs(VARargument)) ≠ abs(VARargument), return false. 
*0*return true.    

############# END ## 43 ###########################
############# BEGIN ## 44 ###########################
ID= 7.2.7
Summary= IsPropertyKey ( argument )
Description= The abstract operation IsPropertyKey determines if argument, which must be an ECMAScript language value, is a value that may be used as a property key.
*0*if FUNCtype(VARargument) is string, return true. 
*0*if FUNCtype(VARargument) is symbol, return true. 
*0*return false.    

############# END ## 44 ###########################
############# BEGIN ## 45 ###########################
ID= 7.2.8
Summary= IsRegExp ( argument )
Description= The abstract operation IsRegExp with argument argument performs the following steps:
*0*if FUNCtype(VARargument) is not object, return false. 
*0*let VARmatcher be ? FUNCget(VARargument, @@match). 
*0*if VARmatcher is not undefined, return FUNCtoboolean(VARmatcher). 
*0*if VARargument has a [[REGEXPMATCHER]] internal slot, return true. 
*0*return false.    

############# END ## 45 ###########################
############# BEGIN ## 46 ###########################
ID= 7.2.9
Summary= IsStringPrefix ( p, q )
Description= The abstract operation IsStringPrefix determines if String p is a prefix of String q.
*0*assert: FUNCtype(VARp) is string. 
*0*assert: FUNCtype(VARq) is string. 
*0*if VARq can be the string-concatenation of VARp and some other string VARr, return true. otherwise, return false. 
*0*note: any string is a prefix of itself, because VARr may be the empty string.    

############# END ## 46 ###########################
############# BEGIN ## 47 ###########################
ID= 7.2.10
Summary= SameValue ( x, y )
Description= The internal comparison abstract operation SameValue(x, y), where x and y are ECMAScript language values, produces true or false. Such a comparison is performed as follows:
*0*if FUNCtype(VARx) is different from FUNCtype(VARy), return false. 
*0*if FUNCtype(VARx) is number, then
*1*if VARx is nan and VARy is nan, return true. 
*1*if VARx is +0 and VARy is -0, return false. 
*1*if VARx is -0 and VARy is +0, return false. 
*1*if VARx is the same number value as VARy, return true. 
*1*return false. 
*0*return FUNCsamevaluenonnumber(VARx, VARy).    

############# END ## 47 ###########################
############# BEGIN ## 48 ###########################
ID= 7.2.11
Summary= SameValueZero ( x, y )
Description= The internal comparison abstract operation SameValueZero(x, y), where x and y are ECMAScript language values, produces true or false. Such a comparison is performed as follows:
*0*if FUNCtype(VARx) is different from FUNCtype(VARy), return false. 
*0*if FUNCtype(VARx) is number, then
*1*if VARx is nan and VARy is nan, return true. 
*1*if VARx is +0 and VARy is -0, return true. 
*1*if VARx is -0 and VARy is +0, return true. 
*1*if VARx is the same number value as VARy, return true. 
*1*return false. 
*0*return FUNCsamevaluenonnumber(VARx, VARy).    

############# END ## 48 ###########################
############# BEGIN ## 49 ###########################
ID= 7.2.12
Summary= SameValueNonNumber ( x, y )
Description= The internal comparison abstract operation SameValueNonNumber(x, y), where neither x nor y are Number values, produces true or false. Such a comparison is performed as follows:
*0*assert: FUNCtype(VARx) is not number. 
*0*assert: FUNCtype(VARx) is the same as FUNCtype(VARy). 
*0*if FUNCtype(VARx) is undefined, return true. 
*0*if FUNCtype(VARx) is null, return true. 
*0*if FUNCtype(VARx) is string, then
*1*if VARx and VARy are exactly the same sequence of code units (same length and same code units at corresponding indices), return true; otherwise, return false. 
*0*if FUNCtype(VARx) is boolean, then
*1*if VARx and VARy are both true or both false, return true; otherwise, return false. 
*0*if FUNCtype(VARx) is symbol, then
*1*if VARx and VARy are both the same symbol value, return true; otherwise, return false. 
*0*if VARx and VARy are the same object value, return true. otherwise, return false.    

############# END ## 49 ###########################
############# BEGIN ## 50 ###########################
ID= 7.3.1
Summary= Get ( O, P )
Description= The abstract operation Get is used to retrieve the value of a specific property of an object. The operation is called with arguments O and P where O is the object and P is the property key. This abstract operation performs the following steps:
*0*assert: FUNCtype(VARo) is object. 
*0*assert: FUNCispropertykey(VARp) is true. 
*0*return ? VARo.[[GET]](VARp, VARo).    

############# END ## 50 ###########################
############# BEGIN ## 51 ###########################
ID= 7.3.2
Summary= GetV ( V, P )
Description= The abstract operation GetV is used to retrieve the value of a specific property of an ECMAScript language value. If the value is not an object, the property lookup is performed using a wrapper object appropriate for the type of the value. The operation is called with arguments V and P where V is the value and P is the property key. This abstract operation performs the following steps:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*let VARo be ? FUNCtoobject(VARv). 
*0*return ? VARo.[[GET]](VARp, VARv).    

############# END ## 51 ###########################
############# BEGIN ## 52 ###########################
ID= 7.3.3
Summary= Set ( O, P, V, Throw )
Description= The abstract operation Set is used to set the value of a specific property of an object. The operation is called with arguments O, P, V, and Throw where O is the object, P is the property key, V is the new value for the property and Throw is a Boolean flag. This abstract operation performs the following steps:
*0*assert: FUNCtype(VARo) is object. 
*0*assert: FUNCispropertykey(VARp) is true. 
*0*assert: FUNCtype(VARthrow) is boolean. 
*0*let VARsuccess be ? VARo.[[SET]](VARp, VARv, VARo). 
*0*if VARsuccess is false and VARthrow is true, throw a typeerror exception. 
*0*return VARsuccess.    

############# END ## 52 ###########################
############# BEGIN ## 53 ###########################
ID= 7.3.4
Summary= CreateDataProperty ( O, P, V )
Description= The abstract operation CreateDataProperty is used to create a new own property of an object. The operation is called with arguments O, P, and V where O is the object, P is the property key, and V is the value for the property. This abstract operation performs the following steps:
*0*assert: FUNCtype(VARo) is object. 
*0*assert: FUNCispropertykey(VARp) is true. 
*0*let VARnewdesc be the propertydescriptor { [[VALUE]]: VARv, [[WRITABLE]]: true, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: true }. 
*0*return ? VARo.[[DEFINEOWNPROPERTY]](VARp, VARnewdesc).    

############# END ## 53 ###########################
############# BEGIN ## 54 ###########################
ID= 7.3.5
Summary= CreateMethodProperty ( O, P, V )
Description= The abstract operation CreateMethodProperty is used to create a new own property of an object. The operation is called with arguments O, P, and V where O is the object, P is the property key, and V is the value for the property. This abstract operation performs the following steps:
*0*assert: FUNCtype(VARo) is object. 
*0*assert: FUNCispropertykey(VARp) is true. 
*0*let VARnewdesc be the propertydescriptor { [[VALUE]]: VARv, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }. 
*0*return ? VARo.[[DEFINEOWNPROPERTY]](VARp, VARnewdesc).    

############# END ## 54 ###########################
############# BEGIN ## 55 ###########################
ID= 7.3.6
Summary= CreateDataPropertyOrThrow ( O, P, V )
Description= The abstract operation CreateDataPropertyOrThrow is used to create a new own property of an object. It throws a TypeError exception if the requested property update cannot be performed. The operation is called with arguments O, P, and V where O is the object, P is the property key, and V is the value for the property. This abstract operation performs the following steps:
*0*assert: FUNCtype(VARo) is object. 
*0*assert: FUNCispropertykey(VARp) is true. 
*0*let VARsuccess be ? FUNCcreatedataproperty(VARo, VARp, VARv). 
*0*if VARsuccess is false, throw a typeerror exception. 
*0*return VARsuccess.    

############# END ## 55 ###########################
############# BEGIN ## 56 ###########################
ID= 7.3.7
Summary= DefinePropertyOrThrow ( O, P, desc )
Description= The abstract operation DefinePropertyOrThrow is used to call the [[DefineOwnProperty]] internal method of an object in a manner that will throw a TypeError exception if the requested property update cannot be performed. The operation is called with arguments O, P, and desc where O is the object, P is the property key, and desc is the Property Descriptor for the property. This abstract operation performs the following steps:
*0*assert: FUNCtype(VARo) is object. 
*0*assert: FUNCispropertykey(VARp) is true. 
*0*let VARsuccess be ? VARo.[[DEFINEOWNPROPERTY]](VARp, VARdesc). 
*0*if VARsuccess is false, throw a typeerror exception. 
*0*return VARsuccess.    

############# END ## 56 ###########################
############# BEGIN ## 57 ###########################
ID= 7.3.8
Summary= DeletePropertyOrThrow ( O, P )
Description= The abstract operation DeletePropertyOrThrow is used to remove a specific own property of an object. It throws an exception if the property is not configurable. The operation is called with arguments O and P where O is the object and P is the property key. This abstract operation performs the following steps:
*0*assert: FUNCtype(VARo) is object. 
*0*assert: FUNCispropertykey(VARp) is true. 
*0*let VARsuccess be ? VARo.[[DELETE]](VARp). 
*0*if VARsuccess is false, throw a typeerror exception. 
*0*return VARsuccess.    

############# END ## 57 ###########################
############# BEGIN ## 58 ###########################
ID= 7.3.9
Summary= GetMethod ( V, P )
Description= The abstract operation GetMethod is used to get the value of a specific property of an ECMAScript language value when the value of the property is expected to be a function. The operation is called with arguments V and P where V is the ECMAScript language value, P is the property key. This abstract operation performs the following steps:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*let VARfunc be ? FUNCgetv(VARv, VARp). 
*0*if VARfunc is either undefined or null, return undefined. 
*0*if FUNCiscallable(VARfunc) is false, throw a typeerror exception. 
*0*return VARfunc.    

############# END ## 58 ###########################
############# BEGIN ## 59 ###########################
ID= 7.3.10
Summary= HasProperty ( O, P )
Description= The abstract operation HasProperty is used to determine whether an object has a property with the specified property key. The property may be either an own or inherited. A Boolean value is returned. The operation is called with arguments O and P where O is the object and P is the property key. This abstract operation performs the following steps:
*0*assert: FUNCtype(VARo) is object. 
*0*assert: FUNCispropertykey(VARp) is true. 
*0*return ? VARo.[[HASPROPERTY]](VARp).    

############# END ## 59 ###########################
############# BEGIN ## 60 ###########################
ID= 7.3.11
Summary= HasOwnProperty ( O, P )
Description= The abstract operation HasOwnProperty is used to determine whether an object has an own property with the specified property key. A Boolean value is returned. The operation is called with arguments O and P where O is the object and P is the property key. This abstract operation performs the following steps:
*0*assert: FUNCtype(VARo) is object. 
*0*assert: FUNCispropertykey(VARp) is true. 
*0*let VARdesc be ? VARo.[[GETOWNPROPERTY]](VARp). 
*0*if VARdesc is undefined, return false. 
*0*return true.    

############# END ## 60 ###########################
############# BEGIN ## 61 ###########################
ID= 7.3.12
Summary= Call ( F, V [ , argumentsList ] )
Description= The abstract operation Call is used to call the [[Call]] internal method of a function object. The operation is called with arguments F, V, and optionally argumentsList where F is the function object, V is an ECMAScript language value that is the this value of the [[Call]], and argumentsList is the value passed to the corresponding argument of the internal method. If argumentsList is not present, a new empty List is used as its value. This abstract operation performs the following steps:
*0*if VARargumentslist is not present, set VARargumentslist to a new empty list. 
*0*if FUNCiscallable(VARf) is false, throw a typeerror exception. 
*0*return ? VARf.[[CALL]](VARv, VARargumentslist).    

############# END ## 61 ###########################
############# BEGIN ## 62 ###########################
ID= 7.3.13
Summary= Construct ( F [ , argumentsList [ , newTarget ]] )
Description= The abstract operation Construct is used to call the [[Construct]] internal method of a function object. The operation is called with arguments F, and optionally argumentsList, and newTarget where F is the function object. argumentsList and newTarget are the values to be passed as the corresponding arguments of the internal method. If argumentsList is not present, a new empty List is used as its value. If newTarget is not present, F is used as its value. This abstract operation performs the following steps:
*0*if VARnewtarget is not present, set VARnewtarget to VARf. 
*0*if VARargumentslist is not present, set VARargumentslist to a new empty list. 
*0*assert: FUNCisconstructor(VARf) is true. 
*0*assert: FUNCisconstructor(VARnewtarget) is true. 
*0*return ? VARf.[[CONSTRUCT]](VARargumentslist, VARnewtarget).    

############# END ## 62 ###########################
############# BEGIN ## 63 ###########################
ID= 7.3.14
Summary= SetIntegrityLevel ( O, level )
Description= The abstract operation SetIntegrityLevel is used to fix the set of own properties of an object. This abstract operation performs the following steps:
*0*assert: FUNCtype(VARo) is object. 
*0*assert: VARlevel is either "sealed" or "frozen". 
*0*let VARstatus be ? VARo.[[PREVENTEXTENSIONS]](). 
*0*if VARstatus is false, return false. 
*0*let VARkeys be ? VARo.[[OWNPROPERTYKEYS]](). 
*0*if VARlevel is "sealed", then
*1*for each element VARk of VARkeys, do
*2*perform ? FUNCdefinepropertyorthrow(VARo, VARk, propertydescriptor { [[CONFIGURABLE]]: false }). 
*0*else VARlevel is "frozen",
*1*for each element VARk of VARkeys, do
*2*let VARcurrentdesc be ? VARo.[[GETOWNPROPERTY]](VARk). 
*2*if VARcurrentdesc is not undefined, then
*3*if FUNCisaccessordescriptor(VARcurrentdesc) is true, then
*4*let VARdesc be the propertydescriptor { [[CONFIGURABLE]]: false }. 
*3*else,
*4*let VARdesc be the propertydescriptor { [[CONFIGURABLE]]: false, [[WRITABLE]]: false }. 
*3*perform ? FUNCdefinepropertyorthrow(VARo, VARk, VARdesc). 
*0*return true.    

############# END ## 63 ###########################
############# BEGIN ## 64 ###########################
ID= 7.3.15
Summary= TestIntegrityLevel ( O, level )
Description= The abstract operation TestIntegrityLevel is used to determine if the set of own properties of an object are fixed. This abstract operation performs the following steps:
*0*assert: FUNCtype(VARo) is object. 
*0*assert: VARlevel is either "sealed" or "frozen". 
*0*let VARstatus be ? FUNCisextensible(VARo). 
*0*if VARstatus is true, return false. 
*0*note: if the object is extensible, none of its properties are examined. 
*0*let VARkeys be ? VARo.[[OWNPROPERTYKEYS]](). 
*0*for each element VARk of VARkeys, do
*1*let VARcurrentdesc be ? VARo.[[GETOWNPROPERTY]](VARk). 
*1*if VARcurrentdesc is not undefined, then
*2*if VARcurrentdesc.[[CONFIGURABLE]] is true, return false. 
*2*if VARlevel is "frozen" and FUNCisdatadescriptor(VARcurrentdesc) is true, then
*3*if VARcurrentdesc.[[WRITABLE]] is true, return false. 
*0*return true.    

############# END ## 64 ###########################
############# BEGIN ## 65 ###########################
ID= 7.3.16
Summary= CreateArrayFromList ( elements )
Description= The abstract operation CreateArrayFromList is used to create an Array object whose elements are provided by a List. This abstract operation performs the following steps:
*0*assert: VARelements is a list whose elements are all ecmascript language values. 
*0*let VARarray be ! FUNCarraycreate(0). 
*0*let VARn be 0. 
*0*for each element VARe of VARelements, do
*1*let VARstatus be FUNCcreatedataproperty(VARarray, ! FUNCtostring(VARn), VARe). 
*1*assert: VARstatus is true. 
*1*increment VARn by 1. 
*0*return VARarray.    

############# END ## 65 ###########################
############# BEGIN ## 66 ###########################
ID= 7.3.17
Summary= CreateListFromArrayLike ( obj [ , elementTypes ] )
Description= The abstract operation CreateListFromArrayLike is used to create a List value whose elements are provided by the indexed properties of an array-like object, obj. The optional argument elementTypes is a List containing the names of ECMAScript Language Types that are allowed for element values of the List that is created. This abstract operation performs the following steps:
*0*if VARelementtypes is not present, set VARelementtypes to « undefined, null, boolean, string, symbol, number, object ». 
*0*if FUNCtype(VARobj) is not object, throw a typeerror exception. 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARobj, "length")). 
*0*let VARlist be a new empty list. 
*0*let VARindex be 0. 
*0*repeat, while VARindex &lt; VARlen
*1*let VARindexname be ! FUNCtostring(VARindex). 
*1*let VARnext be ? FUNCget(VARobj, VARindexname). 
*1*if FUNCtype(VARnext) is not an element of VARelementtypes, throw a typeerror exception. 
*1*append VARnext as the last element of VARlist. 
*1*set VARindex to VARindex + 1. 
*0*return VARlist.    

############# END ## 66 ###########################
############# BEGIN ## 67 ###########################
ID= 7.3.18
Summary= Invoke ( V, P [ , argumentsList ] )
Description= The abstract operation Invoke is used to call a method property of an ECMAScript language value. The operation is called with arguments V, P, and optionally argumentsList where V serves as both the lookup point for the property and the this value of the call, P is the property key, and argumentsList is the list of arguments values passed to the method. If argumentsList is not present, a new empty List is used as its value. This abstract operation performs the following steps:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*if VARargumentslist is not present, set VARargumentslist to a new empty list. 
*0*let VARfunc be ? FUNCgetv(VARv, VARp). 
*0*return ? FUNCcall(VARfunc, VARv, VARargumentslist).    

############# END ## 67 ###########################
############# BEGIN ## 68 ###########################
ID= 7.3.19
Summary= OrdinaryHasInstance ( C, O )
Description= The abstract operation OrdinaryHasInstance implements the default algorithm for determining if an object O inherits from the instance object inheritance path provided by constructor C. This abstract operation performs the following steps:
*0*if FUNCiscallable(VARc) is false, return false. 
*0*if VARc has a [[BOUNDTARGETFUNCTION]] internal slot, then
*1*let VARbc be VARc.[[BOUNDTARGETFUNCTION]]. 
*1*return ? FUNCinstanceofoperator(VARo, VARbc). 
*0*if FUNCtype(VARo) is not object, return false. 
*0*let VARp be ? FUNCget(VARc, "prototype"). 
*0*if FUNCtype(VARp) is not object, throw a typeerror exception. 
*0*repeat,
*1*set VARo to ? VARo.[[GETPROTOTYPEOF]](). 
*1*if VARo is null, return false. 
*1*if FUNCsamevalue(VARp, VARo) is true, return true.    

############# END ## 68 ###########################
############# BEGIN ## 69 ###########################
ID= 7.3.20
Summary= SpeciesConstructor ( O, defaultConstructor )
Description= The abstract operation SpeciesConstructor is used to retrieve the constructor that should be used to create new objects that are derived from the argument object O. The defaultConstructor argument is the constructor to use if a constructor @@species property cannot be found starting from O. This abstract operation performs the following steps:
*0*assert: FUNCtype(VARo) is object. 
*0*let VARc be ? FUNCget(VARo, "constructor"). 
*0*if VARc is undefined, return VARdefaultconstructor. 
*0*if FUNCtype(VARc) is not object, throw a typeerror exception. 
*0*let VARs be ? FUNCget(VARc, @@species). 
*0*if VARs is either undefined or null, return VARdefaultconstructor. 
*0*if FUNCisconstructor(VARs) is true, return VARs. 
*0*throw a typeerror exception.    

############# END ## 69 ###########################
############# BEGIN ## 70 ###########################
ID= 7.3.21
Summary= EnumerableOwnPropertyNames ( O, kind )
Description= When the abstract operation EnumerableOwnPropertyNames is called with Object O and String kind the following steps are taken:
*0*assert: FUNCtype(VARo) is object. 
*0*let VARownkeys be ? VARo.[[OWNPROPERTYKEYS]](). 
*0*let VARproperties be a new empty list. 
*0*for each element VARkey of VARownkeys in list order, do
*1*if FUNCtype(VARkey) is string, then
*2*let VARdesc be ? VARo.[[GETOWNPROPERTY]](VARkey). 
*2*if VARdesc is not undefined and VARdesc.[[ENUMERABLE]] is true, then
*3*if VARkind is "key", append VARkey to VARproperties. 
*3*else,
*4*let VARvalue be ? FUNCget(VARo, VARkey). 
*4*if VARkind is "value", append VARvalue to VARproperties. 
*4*else,
*5*assert: VARkind is "key+value". 
*5*let VARentry be FUNCcreatearrayfromlist(« VARkey, VARvalue »). 
*5*append VARentry to VARproperties. 
*0*order the elements of VARproperties so they are in the same relative order as would be produced by the iterator that would be returned if the enumerateobjectproperties internal method were invoked with VARo. 
*0*return VARproperties.    

############# END ## 70 ###########################
############# BEGIN ## 71 ###########################
ID= 7.3.22
Summary= GetFunctionRealm ( obj )
Description= The abstract operation GetFunctionRealm with argument obj performs the following steps:
*0*assert: VARobj is a callable object. 
*0*if VARobj has a [[REALM]] internal slot, then
*1*return VARobj.[[REALM]]. 
*0*if VARobj is a bound function exotic object, then
*1*let VARtarget be VARobj.[[BOUNDTARGETFUNCTION]]. 
*1*return ? FUNCgetfunctionrealm(VARtarget). 
*0*if VARobj is a proxy exotic object, then
*1*if VARobj.[[PROXYHANDLER]] is null, throw a typeerror exception. 
*1*let VARproxytarget be VARobj.[[PROXYTARGET]]. 
*1*return ? FUNCgetfunctionrealm(VARproxytarget). 
*0*return the current realm record.    

############# END ## 71 ###########################
############# BEGIN ## 72 ###########################
ID= 7.3.23
Summary= CopyDataProperties ( target, source, excludedItems )
Description= When the abstract operation CopyDataProperties is called with arguments target, source, and excludedItems, the following steps are taken:
*0*assert: FUNCtype(VARtarget) is object. 
*0*assert: VARexcludeditems is a list of property keys. 
*0*if VARsource is undefined or null, return VARtarget. 
*0*let VARfrom be ! FUNCtoobject(VARsource). 
*0*let VARkeys be ? VARfrom.[[OWNPROPERTYKEYS]](). 
*0*for each element VARnextkey of VARkeys in list order, do
*1*let VARexcluded be false. 
*1*for each element VARe of VARexcludeditems in list order, do
*2*if FUNCsamevalue(VARe, VARnextkey) is true, then
*3*set VARexcluded to true. 
*1*if VARexcluded is false, then
*2*let VARdesc be ? VARfrom.[[GETOWNPROPERTY]](VARnextkey). 
*2*if VARdesc is not undefined and VARdesc.[[ENUMERABLE]] is true, then
*3*let VARpropvalue be ? FUNCget(VARfrom, VARnextkey). 
*3*perform ! FUNCcreatedataproperty(VARtarget, VARnextkey, VARpropvalue). 
*0*return VARtarget.    

############# END ## 72 ###########################
############# BEGIN ## 73 ###########################
ID= 7.4.1
Summary= GetIterator ( obj [ , hint [ , method ] ] )
Description= The abstract operation GetIterator with argument obj and optional arguments hint and method performs the following steps:
*0*if VARhint is not present, set VARhint to sync. 
*0*assert: VARhint is either sync or async. 
*0*if VARmethod is not present, then
*1*if VARhint is async, then
*2*set VARmethod to ? FUNCgetmethod(VARobj, @@asynciterator). 
*2*if VARmethod is undefined, then
*3*let VARsyncmethod be ? FUNCgetmethod(VARobj, @@iterator). 
*3*let VARsynciteratorrecord be ? FUNCgetiterator(VARobj, sync, VARsyncmethod). 
*3*return ? FUNCcreateasyncfromsynciterator(VARsynciteratorrecord). 
*1*otherwise, set VARmethod to ? FUNCgetmethod(VARobj, @@iterator). 
*0*let VARiterator be ? FUNCcall(VARmethod, VARobj). 
*0*if FUNCtype(VARiterator) is not object, throw a typeerror exception. 
*0*let VARnextmethod be ? FUNCgetv(VARiterator, "next"). 
*0*let VARiteratorrecord be record { [[ITERATOR]]: VARiterator, [[NEXTMETHOD]]: VARnextmethod, [[DONE]]: false }. 
*0*return VARiteratorrecord.    

############# END ## 73 ###########################
############# BEGIN ## 74 ###########################
ID= 7.4.2
Summary= IteratorNext ( iteratorRecord [ , value ] )
Description= The abstract operation IteratorNext with argument iteratorRecord and optional argument value performs the following steps:
*0*if VARvalue is not present, then
*1*let VARresult be ? FUNCcall(VARiteratorrecord.[[NEXTMETHOD]], VARiteratorrecord.[[ITERATOR]], « »). 
*0*else,
*1*let VARresult be ? FUNCcall(VARiteratorrecord.[[NEXTMETHOD]], VARiteratorrecord.[[ITERATOR]], « VARvalue »). 
*0*if FUNCtype(VARresult) is not object, throw a typeerror exception. 
*0*return VARresult.    

############# END ## 74 ###########################
############# BEGIN ## 75 ###########################
ID= 7.4.3
Summary= IteratorComplete ( iterResult )
Description= The abstract operation IteratorComplete with argument iterResult performs the following steps:
*0*assert: FUNCtype(VARiterresult) is object. 
*0*return FUNCtoboolean(? FUNCget(VARiterresult, "done")).    

############# END ## 75 ###########################
############# BEGIN ## 76 ###########################
ID= 7.4.4
Summary= IteratorValue ( iterResult )
Description= The abstract operation IteratorValue with argument iterResult performs the following steps:
*0*assert: FUNCtype(VARiterresult) is object. 
*0*return ? FUNCget(VARiterresult, "value").    

############# END ## 76 ###########################
############# BEGIN ## 77 ###########################
ID= 7.4.5
Summary= IteratorStep ( iteratorRecord )
Description= The abstract operation IteratorStep with argument iteratorRecord requests the next value from iteratorRecord.[[Iterator]] by calling iteratorRecord.[[NextMethod]] and returns either false indicating that the iterator has reached its end or the IteratorResult object if a next value is available. IteratorStep performs the following steps:
*0*let VARresult be ? FUNCiteratornext(VARiteratorrecord). 
*0*let VARdone be ? FUNCiteratorcomplete(VARresult). 
*0*if VARdone is true, return false. 
*0*return VARresult.    

############# END ## 77 ###########################
############# BEGIN ## 78 ###########################
ID= 7.4.6
Summary= IteratorClose ( iteratorRecord, completion )
Description= The abstract operation IteratorClose with arguments iteratorRecord and completion is used to notify an iterator that it should perform any actions it would normally perform when it has reached its completed state:
*0*assert: FUNCtype(VARiteratorrecord.[[ITERATOR]]) is object. 
*0*assert: VARcompletion is a completion record. 
*0*let VARiterator be VARiteratorrecord.[[ITERATOR]]. 
*0*let VARreturn be ? FUNCgetmethod(VARiterator, "return"). 
*0*if VARreturn is undefined, return FUNCcompletion(VARcompletion). 
*0*let VARinnerresult be FUNCcall(VARreturn, VARiterator, « »). 
*0*if VARcompletion.[[TYPE]] is throw, return FUNCcompletion(VARcompletion). 
*0*if VARinnerresult.[[TYPE]] is throw, return FUNCcompletion(VARinnerresult). 
*0*if FUNCtype(VARinnerresult.[[VALUE]]) is not object, throw a typeerror exception. 
*0*return FUNCcompletion(VARcompletion).    

############# END ## 78 ###########################
############# BEGIN ## 79 ###########################
ID= 7.4.7
Summary= AsyncIteratorClose ( iteratorRecord, completion )
Description= The abstract operation AsyncIteratorClose with arguments iteratorRecord and completion is used to notify an async iterator that it should perform any actions it would normally perform when it has reached its completed state:
*0*assert: FUNCtype(VARiteratorrecord.[[ITERATOR]]) is object. 
*0*assert: VARcompletion is a completion record. 
*0*let VARiterator be VARiteratorrecord.[[ITERATOR]]. 
*0*let VARreturn be ? FUNCgetmethod(VARiterator, "return"). 
*0*if VARreturn is undefined, return FUNCcompletion(VARcompletion). 
*0*let VARinnerresult be FUNCcall(VARreturn, VARiterator, « »). 
*0*if VARinnerresult.[[TYPE]] is normal, set VARinnerresult to await(VARinnerresult.[[VALUE]]). 
*0*if VARcompletion.[[TYPE]] is throw, return FUNCcompletion(VARcompletion). 
*0*if VARinnerresult.[[TYPE]] is throw, return FUNCcompletion(VARinnerresult). 
*0*if FUNCtype(VARinnerresult.[[VALUE]]) is not object, throw a typeerror exception. 
*0*return FUNCcompletion(VARcompletion).    

############# END ## 79 ###########################
############# BEGIN ## 80 ###########################
ID= 7.4.8
Summary= CreateIterResultObject ( value, done )
Description= The abstract operation CreateIterResultObject with arguments value and done creates an object that supports the IteratorResult interface by performing the following steps:
*0*assert: FUNCtype(VARdone) is boolean. 
*0*let VARobj be FUNCobjectcreate(%objectprototype%). 
*0*perform FUNCcreatedataproperty(VARobj, "value", VARvalue). 
*0*perform FUNCcreatedataproperty(VARobj, "done", VARdone). 
*0*return VARobj.    

############# END ## 80 ###########################
############# BEGIN ## 81 ###########################
ID= 7.4.9
Summary= CreateListIteratorRecord ( list )
Description= The abstract operation CreateListIteratorRecord with argument list creates an Iterator (25.1.1.2) object record whose next method returns the successive elements of list. It performs the following steps:
*0*let VARiterator be FUNCobjectcreate(%iteratorprototype%, « [[ITERATEDLIST]], [[LISTITERATORNEXTINDEX]] »). 
*0*set VARiterator.[[ITERATEDLIST]] to VARlist. 
*0*set VARiterator.[[LISTITERATORNEXTINDEX]] to 0. 
*0*let VARsteps be the algorithm steps defined in listiterator next (7.4.9.1). 
*0*let VARnext be FUNCcreatebuiltinfunction(VARsteps, « »). 
*0*return record { [[ITERATOR]]: VARiterator, [[NEXTMETHOD]]: VARnext, [[DONE]]: false }.    

############# END ## 81 ###########################
############# BEGIN ## 82 ###########################
ID= 7.4.9.1
Summary= ListIterator next ( )
Description= The ListIterator next method is a standard built-in function object (clause  17) that performs the following steps:
*0*let VARo be the this value. 
*0*assert: FUNCtype(VARo) is object. 
*0*assert: VARo has an [[ITERATEDLIST]] internal slot. 
*0*let VARlist be VARo.[[ITERATEDLIST]]. 
*0*let VARindex be VARo.[[LISTITERATORNEXTINDEX]]. 
*0*let VARlen be the number of elements of VARlist. 
*0*if VARindex ≥ VARlen, then
*1*return FUNCcreateiterresultobject(undefined, true). 
*0*set VARo.[[LISTITERATORNEXTINDEX]] to VARindex+1. 
*0*return FUNCcreateiterresultobject(VARlist[VARindex], false).     

############# END ## 82 ###########################
############# BEGIN ## 83 ###########################
ID= 8.1.1.1.1
Summary= HasBinding ( N )
Description= The concrete Environment Record method HasBinding for declarative Environment Records simply determines if the argument identifier is one of the identifiers bound by the record:
*0*let VARenvrec be the declarative environment record for which the method was invoked. 
*0*if VARenvrec has a binding for the name that is the value of VARn, return true. 
*0*return false.      

############# END ## 83 ###########################
############# BEGIN ## 84 ###########################
ID= 8.1.1.1.2
Summary= CreateMutableBinding ( N, D )
Description= The concrete Environment Record method CreateMutableBinding for declarative Environment Records creates a new mutable binding for the name N that is uninitialized. A binding must not already exist in this Environment Record for N. If Boolean argument D has the value true the new binding is marked as being subject to deletion.
*0*let VARenvrec be the declarative environment record for which the method was invoked. 
*0*assert: VARenvrec does not already have a binding for VARn. 
*0*create a mutable binding in VARenvrec for VARn and record that it is uninitialized. if VARd is true, record that the newly created binding may be deleted by a subsequent deletebinding call. 
*0*return FUNCnormalcompletion(empty).      

############# END ## 84 ###########################
############# BEGIN ## 85 ###########################
ID= 8.1.1.1.3
Summary= CreateImmutableBinding ( N, S )
Description= The concrete Environment Record method CreateImmutableBinding for declarative Environment Records creates a new immutable binding for the name N that is uninitialized. A binding must not already exist in this Environment Record for N. If the Boolean argument S has the value true the new binding is marked as a strict binding.
*0*let VARenvrec be the declarative environment record for which the method was invoked. 
*0*assert: VARenvrec does not already have a binding for VARn. 
*0*create an immutable binding in VARenvrec for VARn and record that it is uninitialized. if VARs is true, record that the newly created binding is a strict binding. 
*0*return FUNCnormalcompletion(empty).      

############# END ## 85 ###########################
############# BEGIN ## 86 ###########################
ID= 8.1.1.1.4
Summary= InitializeBinding ( N, V )
Description= The concrete Environment Record method InitializeBinding for declarative Environment Records is used to set the bound value of the current binding of the identifier whose name is the value of the argument N to the value of argument V. An uninitialized binding for N must already exist.
*0*let VARenvrec be the declarative environment record for which the method was invoked. 
*0*assert: VARenvrec must have an uninitialized binding for VARn. 
*0*set the bound value for VARn in VARenvrec to VARv. 
*0*record that the binding for VARn in VARenvrec has been initialized. 
*0*return FUNCnormalcompletion(empty).      

############# END ## 86 ###########################
############# BEGIN ## 87 ###########################
ID= 8.1.1.1.5
Summary= SetMutableBinding ( N, V, S )
Description= The concrete Environment Record method SetMutableBinding for declarative Environment Records attempts to change the bound value of the current binding of the identifier whose name is the value of the argument N to the value of argument V. A binding for N normally already exists, but in rare cases it may not. If the binding is an immutable binding, a TypeError is thrown if S is true.
*0*let VARenvrec be the declarative environment record for which the method was invoked. 
*0*if VARenvrec does not have a binding for VARn, then
*1*if VARs is true, throw a referenceerror exception. 
*1*perform VARenvrec.createmutablebinding(VARn, true). 
*1*perform VARenvrec.initializebinding(VARn, VARv). 
*1*return FUNCnormalcompletion(empty). 
*0*if the binding for VARn in VARenvrec is a strict binding, set VARs to true. 
*0*if the binding for VARn in VARenvrec has not yet been initialized, throw a referenceerror exception. 
*0*else if the binding for VARn in VARenvrec is a mutable binding, change its bound value to VARv. 
*0*else,
*1*assert: this is an attempt to change the value of an immutable binding. 
*1*if VARs is true, throw a typeerror exception. 
*0*return FUNCnormalcompletion(empty).      

############# END ## 87 ###########################
############# BEGIN ## 88 ###########################
ID= 8.1.1.1.6
Summary= GetBindingValue ( N, S )
Description= The concrete Environment Record method GetBindingValue for declarative Environment Records simply returns the value of its bound identifier whose name is the value of the argument N. If the binding exists but is uninitialized a ReferenceError is thrown, regardless of the value of S.
*0*let VARenvrec be the declarative environment record for which the method was invoked. 
*0*assert: VARenvrec has a binding for VARn. 
*0*if the binding for VARn in VARenvrec is an uninitialized binding, throw a referenceerror exception. 
*0*return the value currently bound to VARn in VARenvrec.      

############# END ## 88 ###########################
############# BEGIN ## 89 ###########################
ID= 8.1.1.1.7
Summary= DeleteBinding ( N )
Description= The concrete Environment Record method DeleteBinding for declarative Environment Records can only delete bindings that have been explicitly designated as being subject to deletion.
*0*let VARenvrec be the declarative environment record for which the method was invoked. 
*0*assert: VARenvrec has a binding for the name that is the value of VARn. 
*0*if the binding for VARn in VARenvrec cannot be deleted, return false. 
*0*remove the binding for VARn from VARenvrec. 
*0*return true.      

############# END ## 89 ###########################
############# BEGIN ## 90 ###########################
ID= 8.1.1.1.8
Summary= HasThisBinding ( )
Description= Regular declarative Environment Records do not provide a this binding.
*0*return false.      

############# END ## 90 ###########################
############# BEGIN ## 91 ###########################
ID= 8.1.1.1.9
Summary= HasSuperBinding ( )
Description= Regular declarative Environment Records do not provide a super binding.
*0*return false.      

############# END ## 91 ###########################
############# BEGIN ## 92 ###########################
ID= 8.1.1.1.10
Summary= WithBaseObject ( )
Description= Declarative Environment Records always return undefined as their WithBaseObject.
*0*return undefined.      

############# END ## 92 ###########################
############# BEGIN ## 93 ###########################
ID= 8.1.1.2.1
Summary= HasBinding ( N )
Description= The concrete Environment Record method HasBinding for object Environment Records determines if its associated binding object has a property whose name is the value of the argument N:
*0*let VARenvrec be the object environment record for which the method was invoked. 
*0*let VARbindings be the binding object for VARenvrec. 
*0*let VARfoundbinding be ? FUNChasproperty(VARbindings, VARn). 
*0*if VARfoundbinding is false, return false. 
*0*if the VARwithenvironment flag of VARenvrec is false, return true. 
*0*let VARunscopables be ? FUNCget(VARbindings, @@unscopables). 
*0*if FUNCtype(VARunscopables) is object, then
*1*let VARblocked be FUNCtoboolean(? FUNCget(VARunscopables, VARn)). 
*1*if VARblocked is true, return false. 
*0*return true.      

############# END ## 93 ###########################
############# BEGIN ## 94 ###########################
ID= 8.1.1.2.2
Summary= CreateMutableBinding ( N, D )
Description= The concrete Environment Record method CreateMutableBinding for object Environment Records creates in an Environment Record's associated binding object a property whose name is the String value and initializes it to the value undefined. If Boolean argument D has the value true the new property's [[Configurable]] attribute is set to true; otherwise it is set to false.
*0*let VARenvrec be the object environment record for which the method was invoked. 
*0*let VARbindings be the binding object for VARenvrec. 
*0*return ? FUNCdefinepropertyorthrow(VARbindings, VARn, propertydescriptor { [[VALUE]]: undefined, [[WRITABLE]]: true, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: VARd }).      

############# END ## 94 ###########################
############# BEGIN ## 95 ###########################
ID= 8.1.1.2.4
Summary= InitializeBinding ( N, V )
Description= The concrete Environment Record method InitializeBinding for object Environment Records is used to set the bound value of the current binding of the identifier whose name is the value of the argument N to the value of argument V. An uninitialized binding for N must already exist.
*0*let VARenvrec be the object environment record for which the method was invoked. 
*0*assert: VARenvrec must have an uninitialized binding for VARn. 
*0*record that the binding for VARn in VARenvrec has been initialized. 
*0*return ? VARenvrec.setmutablebinding(VARn, VARv, false).      

############# END ## 95 ###########################
############# BEGIN ## 96 ###########################
ID= 8.1.1.2.5
Summary= SetMutableBinding ( N, V, S )
Description= The concrete Environment Record method SetMutableBinding for object Environment Records attempts to set the value of the Environment Record's associated binding object's property whose name is the value of the argument N to the value of argument V. A property named N normally already exists but if it does not or is not currently writable, error handling is determined by the value of the Boolean argument S.
*0*let VARenvrec be the object environment record for which the method was invoked. 
*0*let VARbindings be the binding object for VARenvrec. 
*0*return ? FUNCset(VARbindings, VARn, VARv, VARs).      

############# END ## 96 ###########################
############# BEGIN ## 97 ###########################
ID= 8.1.1.2.6
Summary= GetBindingValue ( N, S )
Description= The concrete Environment Record method GetBindingValue for object Environment Records returns the value of its associated binding object's property whose name is the String value of the argument identifier N. The property should already exist but if it does not the result depends upon the value of the S argument:
*0*let VARenvrec be the object environment record for which the method was invoked. 
*0*let VARbindings be the binding object for VARenvrec. 
*0*let VARvalue be ? FUNChasproperty(VARbindings, VARn). 
*0*if VARvalue is false, then
*1*if VARs is false, return the value undefined; otherwise throw a referenceerror exception. 
*0*return ? FUNCget(VARbindings, VARn).      

############# END ## 97 ###########################
############# BEGIN ## 98 ###########################
ID= 8.1.1.2.7
Summary= DeleteBinding ( N )
Description= The concrete Environment Record method DeleteBinding for object Environment Records can only delete bindings that correspond to properties of the environment object whose [[Configurable]] attribute have the value true.
*0*let VARenvrec be the object environment record for which the method was invoked. 
*0*let VARbindings be the binding object for VARenvrec. 
*0*return ? VARbindings.[[DELETE]](VARn).      

############# END ## 98 ###########################
############# BEGIN ## 99 ###########################
ID= 8.1.1.2.8
Summary= HasThisBinding ( )
Description= Regular object Environment Records do not provide a this binding.
*0*return false.      

############# END ## 99 ###########################
############# BEGIN ## 100 ###########################
ID= 8.1.1.2.9
Summary= HasSuperBinding ( )
Description= Regular object Environment Records do not provide a super binding.
*0*return false.      

############# END ## 100 ###########################
############# BEGIN ## 101 ###########################
ID= 8.1.1.2.10
Summary= WithBaseObject ( )
Description= Object Environment Records return undefined as their WithBaseObject unless their withEnvironment flag is true.
*0*let VARenvrec be the object environment record for which the method was invoked. 
*0*if the VARwithenvironment flag of VARenvrec is true, return the binding object for VARenvrec. 
*0*otherwise, return undefined.      

############# END ## 101 ###########################
############# BEGIN ## 102 ###########################
ID= 8.1.1.3.1
Summary= BindThisValue ( V )
Description= None
*0*let VARenvrec be the function environment record for which the method was invoked. 
*0*assert: VARenvrec.[[THISBINDINGSTATUS]] is not "lexical". 
*0*if VARenvrec.[[THISBINDINGSTATUS]] is "initialized", throw a referenceerror exception. 
*0*set VARenvrec.[[THISVALUE]] to VARv. 
*0*set VARenvrec.[[THISBINDINGSTATUS]] to "initialized". 
*0*return VARv.      

############# END ## 102 ###########################
############# BEGIN ## 103 ###########################
ID= 8.1.1.3.2
Summary= HasThisBinding ( )
Description= None
*0*let VARenvrec be the function environment record for which the method was invoked. 
*0*if VARenvrec.[[THISBINDINGSTATUS]] is "lexical", return false; otherwise, return true.      

############# END ## 103 ###########################
############# BEGIN ## 104 ###########################
ID= 8.1.1.3.3
Summary= HasSuperBinding ( )
Description= None
*0*let VARenvrec be the function environment record for which the method was invoked. 
*0*if VARenvrec.[[THISBINDINGSTATUS]] is "lexical", return false. 
*0*if VARenvrec.[[HOMEOBJECT]] has the value undefined, return false; otherwise, return true.      

############# END ## 104 ###########################
############# BEGIN ## 105 ###########################
ID= 8.1.1.3.4
Summary= GetThisBinding ( )
Description= None
*0*let VARenvrec be the function environment record for which the method was invoked. 
*0*assert: VARenvrec.[[THISBINDINGSTATUS]] is not "lexical". 
*0*if VARenvrec.[[THISBINDINGSTATUS]] is "uninitialized", throw a referenceerror exception. 
*0*return VARenvrec.[[THISVALUE]].      

############# END ## 105 ###########################
############# BEGIN ## 106 ###########################
ID= 8.1.1.3.5
Summary= GetSuperBase ( )
Description= None
*0*let VARenvrec be the function environment record for which the method was invoked. 
*0*let VARhome be VARenvrec.[[HOMEOBJECT]]. 
*0*if VARhome has the value undefined, return undefined. 
*0*assert: FUNCtype(VARhome) is object. 
*0*return ? VARhome.[[GETPROTOTYPEOF]]().      

############# END ## 106 ###########################
############# BEGIN ## 107 ###########################
ID= 8.1.1.4.1
Summary= HasBinding ( N )
Description= The concrete Environment Record method HasBinding for global Environment Records simply determines if the argument identifier is one of the identifiers bound by the record:
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*let VARdclrec be VARenvrec.[[DECLARATIVERECORD]]. 
*0*if VARdclrec.hasbinding(VARn) is true, return true. 
*0*let VARobjrec be VARenvrec.[[OBJECTRECORD]]. 
*0*return ? VARobjrec.hasbinding(VARn).      

############# END ## 107 ###########################
############# BEGIN ## 108 ###########################
ID= 8.1.1.4.2
Summary= CreateMutableBinding ( N, D )
Description= The concrete Environment Record method CreateMutableBinding for global Environment Records creates a new mutable binding for the name N that is uninitialized. The binding is created in the associated DeclarativeRecord. A binding for N must not already exist in the DeclarativeRecord. If Boolean argument D has the value true the new binding is marked as being subject to deletion.
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*let VARdclrec be VARenvrec.[[DECLARATIVERECORD]]. 
*0*if VARdclrec.hasbinding(VARn) is true, throw a typeerror exception. 
*0*return VARdclrec.createmutablebinding(VARn, VARd).      

############# END ## 108 ###########################
############# BEGIN ## 109 ###########################
ID= 8.1.1.4.3
Summary= CreateImmutableBinding ( N, S )
Description= The concrete Environment Record method CreateImmutableBinding for global Environment Records creates a new immutable binding for the name N that is uninitialized. A binding must not already exist in this Environment Record for N. If the Boolean argument S has the value true the new binding is marked as a strict binding.
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*let VARdclrec be VARenvrec.[[DECLARATIVERECORD]]. 
*0*if VARdclrec.hasbinding(VARn) is true, throw a typeerror exception. 
*0*return VARdclrec.createimmutablebinding(VARn, VARs).      

############# END ## 109 ###########################
############# BEGIN ## 110 ###########################
ID= 8.1.1.4.4
Summary= InitializeBinding ( N, V )
Description= The concrete Environment Record method InitializeBinding for global Environment Records is used to set the bound value of the current binding of the identifier whose name is the value of the argument N to the value of argument V. An uninitialized binding for N must already exist.
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*let VARdclrec be VARenvrec.[[DECLARATIVERECORD]]. 
*0*if VARdclrec.hasbinding(VARn) is true, then
*1*return VARdclrec.initializebinding(VARn, VARv). 
*0*assert: if the binding exists, it must be in the object environment record. 
*0*let VARobjrec be VARenvrec.[[OBJECTRECORD]]. 
*0*return ? VARobjrec.initializebinding(VARn, VARv).      

############# END ## 110 ###########################
############# BEGIN ## 111 ###########################
ID= 8.1.1.4.5
Summary= SetMutableBinding ( N, V, S )
Description= The concrete Environment Record method SetMutableBinding for global Environment Records attempts to change the bound value of the current binding of the identifier whose name is the value of the argument N to the value of argument V. If the binding is an immutable binding, a TypeError is thrown if S is true. A property named N normally already exists but if it does not or is not currently writable, error handling is determined by the value of the Boolean argument S.
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*let VARdclrec be VARenvrec.[[DECLARATIVERECORD]]. 
*0*if VARdclrec.hasbinding(VARn) is true, then
*1*return VARdclrec.setmutablebinding(VARn, VARv, VARs). 
*0*let VARobjrec be VARenvrec.[[OBJECTRECORD]]. 
*0*return ? VARobjrec.setmutablebinding(VARn, VARv, VARs).      

############# END ## 111 ###########################
############# BEGIN ## 112 ###########################
ID= 8.1.1.4.6
Summary= GetBindingValue ( N, S )
Description= The concrete Environment Record method GetBindingValue for global Environment Records returns the value of its bound identifier whose name is the value of the argument N. If the binding is an uninitialized binding throw a ReferenceError exception. A property named N normally already exists but if it does not or is not currently writable, error handling is determined by the value of the Boolean argument S.
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*let VARdclrec be VARenvrec.[[DECLARATIVERECORD]]. 
*0*if VARdclrec.hasbinding(VARn) is true, then
*1*return VARdclrec.getbindingvalue(VARn, VARs). 
*0*let VARobjrec be VARenvrec.[[OBJECTRECORD]]. 
*0*return ? VARobjrec.getbindingvalue(VARn, VARs).      

############# END ## 112 ###########################
############# BEGIN ## 113 ###########################
ID= 8.1.1.4.7
Summary= DeleteBinding ( N )
Description= The concrete Environment Record method DeleteBinding for global Environment Records can only delete bindings that have been explicitly designated as being subject to deletion.
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*let VARdclrec be VARenvrec.[[DECLARATIVERECORD]]. 
*0*if VARdclrec.hasbinding(VARn) is true, then
*1*return VARdclrec.deletebinding(VARn). 
*0*let VARobjrec be VARenvrec.[[OBJECTRECORD]]. 
*0*let VARglobalobject be the binding object for VARobjrec. 
*0*let VARexistingprop be ? FUNChasownproperty(VARglobalobject, VARn). 
*0*if VARexistingprop is true, then
*1*let VARstatus be ? VARobjrec.deletebinding(VARn). 
*1*if VARstatus is true, then
*2*let VARvarnames be VARenvrec.[[VARNAMES]]. 
*2*if VARn is an element of VARvarnames, remove that element from the VARvarnames. 
*1*return VARstatus. 
*0*return true.      

############# END ## 113 ###########################
############# BEGIN ## 114 ###########################
ID= 8.1.1.4.8
Summary= HasThisBinding ( )
Description= None
*0*return true.      

############# END ## 114 ###########################
############# BEGIN ## 115 ###########################
ID= 8.1.1.4.9
Summary= HasSuperBinding ( )
Description= None
*0*return false.      

############# END ## 115 ###########################
############# BEGIN ## 116 ###########################
ID= 8.1.1.4.10
Summary= WithBaseObject ( )
Description= Global Environment Records always return undefined as their WithBaseObject.
*0*return undefined.      

############# END ## 116 ###########################
############# BEGIN ## 117 ###########################
ID= 8.1.1.4.11
Summary= GetThisBinding ( )
Description= None
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*return VARenvrec.[[GLOBALTHISVALUE]].      

############# END ## 117 ###########################
############# BEGIN ## 118 ###########################
ID= 8.1.1.4.12
Summary= HasVarDeclaration ( N )
Description= The concrete Environment Record method HasVarDeclaration for global Environment Records determines if the argument identifier has a binding in this record that was created using a VariableStatement or a FunctionDeclaration:
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*let VARvardeclarednames be VARenvrec.[[VARNAMES]]. 
*0*if VARvardeclarednames contains VARn, return true. 
*0*return false.      

############# END ## 118 ###########################
############# BEGIN ## 119 ###########################
ID= 8.1.1.4.13
Summary= HasLexicalDeclaration ( N )
Description= The concrete Environment Record method HasLexicalDeclaration for global Environment Records determines if the argument identifier has a binding in this record that was created using a lexical declaration such as a LexicalDeclaration or a ClassDeclaration:
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*let VARdclrec be VARenvrec.[[DECLARATIVERECORD]]. 
*0*return VARdclrec.hasbinding(VARn).      

############# END ## 119 ###########################
############# BEGIN ## 120 ###########################
ID= 8.1.1.4.14
Summary= HasRestrictedGlobalProperty ( N )
Description= The concrete Environment Record method HasRestrictedGlobalProperty for global Environment Records determines if the argument identifier is the name of a property of the global object that must not be shadowed by a global lexical binding:
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*let VARobjrec be VARenvrec.[[OBJECTRECORD]]. 
*0*let VARglobalobject be the binding object for VARobjrec. 
*0*let VARexistingprop be ? VARglobalobject.[[GETOWNPROPERTY]](VARn). 
*0*if VARexistingprop is undefined, return false. 
*0*if VARexistingprop.[[CONFIGURABLE]] is true, return false. 
*0*return true.      

############# END ## 120 ###########################
############# BEGIN ## 121 ###########################
ID= 8.1.1.4.15
Summary= CanDeclareGlobalVar ( N )
Description= The concrete Environment Record method CanDeclareGlobalVar for global Environment Records determines if a corresponding CreateGlobalVarBinding call would succeed if called for the same argument N. Redundant var declarations and var declarations for pre-existing global object properties are allowed.
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*let VARobjrec be VARenvrec.[[OBJECTRECORD]]. 
*0*let VARglobalobject be the binding object for VARobjrec. 
*0*let VARhasproperty be ? FUNChasownproperty(VARglobalobject, VARn). 
*0*if VARhasproperty is true, return true. 
*0*return ? FUNCisextensible(VARglobalobject).      

############# END ## 121 ###########################
############# BEGIN ## 122 ###########################
ID= 8.1.1.4.16
Summary= CanDeclareGlobalFunction ( N )
Description= The concrete Environment Record method CanDeclareGlobalFunction for global Environment Records determines if a corresponding CreateGlobalFunctionBinding call would succeed if called for the same argument N.
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*let VARobjrec be VARenvrec.[[OBJECTRECORD]]. 
*0*let VARglobalobject be the binding object for VARobjrec. 
*0*let VARexistingprop be ? VARglobalobject.[[GETOWNPROPERTY]](VARn). 
*0*if VARexistingprop is undefined, return ? FUNCisextensible(VARglobalobject). 
*0*if VARexistingprop.[[CONFIGURABLE]] is true, return true. 
*0*if FUNCisdatadescriptor(VARexistingprop) is true and VARexistingprop has attribute values { [[WRITABLE]]: true, [[ENUMERABLE]]: true }, return true. 
*0*return false.      

############# END ## 122 ###########################
############# BEGIN ## 123 ###########################
ID= 8.1.1.4.17
Summary= CreateGlobalVarBinding ( N, D )
Description= The concrete Environment Record method CreateGlobalVarBinding for global Environment Records creates and initializes a mutable binding in the associated object Environment Record and records the bound name in the associated [[VarNames]] List. If a binding already exists, it is reused and assumed to be initialized.
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*let VARobjrec be VARenvrec.[[OBJECTRECORD]]. 
*0*let VARglobalobject be the binding object for VARobjrec. 
*0*let VARhasproperty be ? FUNChasownproperty(VARglobalobject, VARn). 
*0*let VARextensible be ? FUNCisextensible(VARglobalobject). 
*0*if VARhasproperty is false and VARextensible is true, then
*1*perform ? VARobjrec.createmutablebinding(VARn, VARd). 
*1*perform ? VARobjrec.initializebinding(VARn, undefined). 
*0*let VARvardeclarednames be VARenvrec.[[VARNAMES]]. 
*0*if VARvardeclarednames does not contain VARn, then
*1*append VARn to VARvardeclarednames. 
*0*return FUNCnormalcompletion(empty).      

############# END ## 123 ###########################
############# BEGIN ## 124 ###########################
ID= 8.1.1.4.18
Summary= CreateGlobalFunctionBinding ( N, V, D )
Description= The concrete Environment Record method CreateGlobalFunctionBinding for global Environment Records creates and initializes a mutable binding in the associated object Environment Record and records the bound name in the associated [[VarNames]] List. If a binding already exists, it is replaced.
*0*let VARenvrec be the global environment record for which the method was invoked. 
*0*let VARobjrec be VARenvrec.[[OBJECTRECORD]]. 
*0*let VARglobalobject be the binding object for VARobjrec. 
*0*let VARexistingprop be ? VARglobalobject.[[GETOWNPROPERTY]](VARn). 
*0*if VARexistingprop is undefined or VARexistingprop.[[CONFIGURABLE]] is true, then
*1*let VARdesc be the propertydescriptor { [[VALUE]]: VARv, [[WRITABLE]]: true, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: VARd }. 
*0*else,
*1*let VARdesc be the propertydescriptor { [[VALUE]]: VARv }. 
*0*perform ? FUNCdefinepropertyorthrow(VARglobalobject, VARn, VARdesc). 
*0*record that the binding for VARn in VARobjrec has been initialized. 
*0*perform ? FUNCset(VARglobalobject, VARn, VARv, false). 
*0*let VARvardeclarednames be VARenvrec.[[VARNAMES]]. 
*0*if VARvardeclarednames does not contain VARn, then
*1*append VARn to VARvardeclarednames. 
*0*return FUNCnormalcompletion(empty).      

############# END ## 124 ###########################
############# BEGIN ## 125 ###########################
ID= 8.1.1.5.1
Summary= GetBindingValue ( N, S )
Description= The concrete Environment Record method GetBindingValue for module Environment Records returns the value of its bound identifier whose name is the value of the argument N. However, if the binding is an indirect binding the value of the target binding is returned. If the binding exists but is uninitialized a ReferenceError is thrown.
*0*assert: VARs is true. 
*0*let VARenvrec be the module environment record for which the method was invoked. 
*0*assert: VARenvrec has a binding for VARn. 
*0*if the binding for VARn is an indirect binding, then
*1*let VARm and VARn2 be the indirection values provided when this binding for VARn was created. 
*1*let VARtargetenv be VARm.[[ENVIRONMENT]]. 
*1*if VARtargetenv is undefined, throw a referenceerror exception. 
*1*let VARtargeter be VARtargetenv's environmentrecord. 
*1*return ? VARtargeter.getbindingvalue(VARn2, true). 
*0*if the binding for VARn in VARenvrec is an uninitialized binding, throw a referenceerror exception. 
*0*return the value currently bound to VARn in VARenvrec.      

############# END ## 125 ###########################
############# BEGIN ## 126 ###########################
ID= 8.1.1.5.2
Summary= DeleteBinding ( N )
Description= The concrete Environment Record method DeleteBinding for module Environment Records refuses to delete bindings.
*0*assert: this method is never invoked. see 12.5.3.1.      

############# END ## 126 ###########################
############# BEGIN ## 127 ###########################
ID= 8.1.1.5.3
Summary= HasThisBinding ( )
Description= Module Environment Records provide a this binding.
*0*return true.      

############# END ## 127 ###########################
############# BEGIN ## 128 ###########################
ID= 8.1.1.5.4
Summary= GetThisBinding ( )
Description= None
*0*return undefined.      

############# END ## 128 ###########################
############# BEGIN ## 129 ###########################
ID= 8.1.1.5.5
Summary= CreateImportBinding ( N, M, N2 )
Description= The concrete Environment Record method CreateImportBinding for module Environment Records creates a new initialized immutable indirect binding for the name N. A binding must not already exist in this Environment Record for N. M is a Module Record, and N2 is the name of a binding that exists in M's module Environment Record. Accesses to the value of the new binding will indirectly access the bound value of the target binding.
*0*let VARenvrec be the module environment record for which the method was invoked. 
*0*assert: VARenvrec does not already have a binding for VARn. 
*0*assert: VARm is a module record. 
*0*assert: when VARm.[[ENVIRONMENT]] is instantiated it will have a direct binding for VARn2. 
*0*create an immutable indirect binding in VARenvrec for VARn that references VARm and VARn2 as its target binding and record that the binding is initialized. 
*0*return FUNCnormalcompletion(empty).      

############# END ## 129 ###########################
############# BEGIN ## 130 ###########################
ID= 8.1.2.1
Summary= GetIdentifierReference ( lex, name, strict )
Description= The abstract operation GetIdentifierReference is called with a Lexical Environment lex, a String name, and a Boolean flag strict. The value of lex may be null. When called, the following steps are performed:
*0*if VARlex is the value null, then
*1*return a value of type reference whose base value component is undefined, whose referenced name component is VARname, and whose strict reference flag is VARstrict. 
*0*let VARenvrec be VARlex's environmentrecord. 
*0*let VARexists be ? VARenvrec.hasbinding(VARname). 
*0*if VARexists is true, then
*1*return a value of type reference whose base value component is VARenvrec, whose referenced name component is VARname, and whose strict reference flag is VARstrict. 
*0*else,
*1*let VARouter be the value of VARlex's outer environment reference. 
*1*return ? FUNCgetidentifierreference(VARouter, VARname, VARstrict).     

############# END ## 130 ###########################
############# BEGIN ## 131 ###########################
ID= 8.1.2.2
Summary= NewDeclarativeEnvironment ( E )
Description= When the abstract operation NewDeclarativeEnvironment is called with a Lexical Environment as argument E the following steps are performed:
*0*let VARenv be a new lexical environment. 
*0*let VARenvrec be a new declarative environment record containing no bindings. 
*0*set VARenv's environmentrecord to VARenvrec. 
*0*set the outer lexical environment reference of VARenv to VARe. 
*0*return VARenv.     

############# END ## 131 ###########################
############# BEGIN ## 132 ###########################
ID= 8.1.2.3
Summary= NewObjectEnvironment ( O, E )
Description= When the abstract operation NewObjectEnvironment is called with an Object O and a Lexical Environment E as arguments, the following steps are performed:
*0*let VARenv be a new lexical environment. 
*0*let VARenvrec be a new object environment record containing VARo as the binding object. 
*0*set VARenv's environmentrecord to VARenvrec. 
*0*set the outer lexical environment reference of VARenv to VARe. 
*0*return VARenv.     

############# END ## 132 ###########################
############# BEGIN ## 133 ###########################
ID= 8.1.2.4
Summary= NewFunctionEnvironment ( F, newTarget )
Description= When the abstract operation NewFunctionEnvironment is called with arguments F and newTarget the following steps are performed:
*0*assert: VARf is an ecmascript function. 
*0*assert: FUNCtype(VARnewtarget) is undefined or object. 
*0*let VARenv be a new lexical environment. 
*0*let VARenvrec be a new function environment record containing no bindings. 
*0*set VARenvrec.[[FUNCTIONOBJECT]] to VARf. 
*0*if VARf.[[THISMODE]] is lexical, set VARenvrec.[[THISBINDINGSTATUS]] to "lexical". 
*0*else, set VARenvrec.[[THISBINDINGSTATUS]] to "uninitialized". 
*0*let VARhome be VARf.[[HOMEOBJECT]]. 
*0*set VARenvrec.[[HOMEOBJECT]] to VARhome. 
*0*set VARenvrec.[[NEWTARGET]] to VARnewtarget. 
*0*set VARenv's environmentrecord to VARenvrec. 
*0*set the outer lexical environment reference of VARenv to VARf.[[ENVIRONMENT]]. 
*0*return VARenv.     

############# END ## 133 ###########################
############# BEGIN ## 134 ###########################
ID= 8.1.2.5
Summary= NewGlobalEnvironment ( G, thisValue )
Description= When the abstract operation NewGlobalEnvironment is called with arguments G and thisValue, the following steps are performed:
*0*let VARenv be a new lexical environment. 
*0*let VARobjrec be a new object environment record containing VARg as the binding object. 
*0*let VARdclrec be a new declarative environment record containing no bindings. 
*0*let VARglobalrec be a new global environment record. 
*0*set VARglobalrec.[[OBJECTRECORD]] to VARobjrec. 
*0*set VARglobalrec.[[GLOBALTHISVALUE]] to VARthisvalue. 
*0*set VARglobalrec.[[DECLARATIVERECORD]] to VARdclrec. 
*0*set VARglobalrec.[[VARNAMES]] to a new empty list. 
*0*set VARenv's environmentrecord to VARglobalrec. 
*0*set the outer lexical environment reference of VARenv to null. 
*0*return VARenv.     

############# END ## 134 ###########################
############# BEGIN ## 135 ###########################
ID= 8.1.2.6
Summary= NewModuleEnvironment ( E )
Description= When the abstract operation NewModuleEnvironment is called with a Lexical Environment argument E the following steps are performed:
*0*let VARenv be a new lexical environment. 
*0*let VARenvrec be a new module environment record containing no bindings. 
*0*set VARenv's environmentrecord to VARenvrec. 
*0*set the outer lexical environment reference of VARenv to VARe. 
*0*return VARenv.     

############# END ## 135 ###########################
############# BEGIN ## 136 ###########################
ID= 8.2.1
Summary= CreateRealm ( )
Description= The abstract operation CreateRealm with no arguments performs the following steps:
*0*let VARrealmrec be a new realm record. 
*0*perform FUNCcreateintrinsics(VARrealmrec). 
*0*set VARrealmrec.[[GLOBALOBJECT]] to undefined. 
*0*set VARrealmrec.[[GLOBALENV]] to undefined. 
*0*set VARrealmrec.[[TEMPLATEMAP]] to a new empty list. 
*0*return VARrealmrec.    

############# END ## 136 ###########################
############# BEGIN ## 137 ###########################
ID= 8.2.2
Summary= CreateIntrinsics ( realmRec )
Description= The abstract operation CreateIntrinsics with argument realmRec performs the following steps:
*0*let VARintrinsics be a new record. 
*0*set VARrealmrec.[[INTRINSICS]] to VARintrinsics. 
*0*let VARobjproto be FUNCobjectcreate(null). 
*0*set VARintrinsics.[[%OBJECTPROTOTYPE%]] to VARobjproto. 
*0*let VARthrowersteps be the algorithm steps specified in 9.2.9.1 for the %throwtypeerror% function. 
*0*let VARthrower be FUNCcreatebuiltinfunction(VARthrowersteps, « », VARrealmrec, null). 
*0*set VARintrinsics.[[%THROWTYPEERROR%]] to VARthrower. 
*0*let VARnosteps be an empty sequence of algorithm steps. 
*0*let VARfuncproto be FUNCcreatebuiltinfunction(VARnosteps, « », VARrealmrec, VARobjproto). 
*0*set VARintrinsics.[[%FUNCTIONPROTOTYPE%]] to VARfuncproto. 
*0*call VARthrower.[[SETPROTOTYPEOF]](VARfuncproto). 
*0*perform FUNCaddrestrictedfunctionproperties(VARfuncproto, VARrealmrec). 
*0*set fields of VARintrinsics with the values listed in table 7 that have not already been handled above. the field names are the names listed in column one of the table. the value of each field is a new object value fully and recursively populated with property values as defined by the specification of each object in clauses 18-26. all object property values are newly created object values. all values that are built-in function objects are created by performing FUNCcreatebuiltinfunction(&lt;steps&gt;, &lt;slots&gt;, VARrealmrec, &lt;prototype&gt;) where &lt;steps&gt; is the definition of that function provided by this specification, &lt;slots&gt; is a list of the names, if any, of the function's specified internal slots, and &lt;prototype&gt; is the specified value of the function's [[PROTOTYPE]] internal slot. the creation of the intrinsics and their properties must be ordered to avoid any dependencies upon objects that have not yet been created. 
*0*return VARintrinsics.    

############# END ## 137 ###########################
############# BEGIN ## 138 ###########################
ID= 8.2.3
Summary= SetRealmGlobalObject ( realmRec, globalObj, thisValue )
Description= The abstract operation SetRealmGlobalObject with arguments realmRec, globalObj, and thisValue performs the following steps:
*0*if VARglobalobj is undefined, then
*1*let VARintrinsics be VARrealmrec.[[INTRINSICS]]. 
*1*set VARglobalobj to FUNCobjectcreate(VARintrinsics.[[%OBJECTPROTOTYPE%]]). 
*0*assert: FUNCtype(VARglobalobj) is object. 
*0*if VARthisvalue is undefined, set VARthisvalue to VARglobalobj. 
*0*set VARrealmrec.[[GLOBALOBJECT]] to VARglobalobj. 
*0*let VARnewglobalenv be FUNCnewglobalenvironment(VARglobalobj, VARthisvalue). 
*0*set VARrealmrec.[[GLOBALENV]] to VARnewglobalenv. 
*0*return VARrealmrec.    

############# END ## 138 ###########################
############# BEGIN ## 139 ###########################
ID= 8.2.4
Summary= SetDefaultGlobalBindings ( realmRec )
Description= The abstract operation SetDefaultGlobalBindings with argument realmRec performs the following steps:
*0*let VARglobal be VARrealmrec.[[GLOBALOBJECT]]. 
*0*for each property of the global object specified in clause 18, do
*1*let VARname be the string value of the property name. 
*1*let VARdesc be the fully populated data property descriptor for the property containing the specified attributes for the property. for properties listed in 18.2, 18.3, or 18.4 the value of the [[VALUE]] attribute is the corresponding intrinsic object from VARrealmrec. 
*1*perform ? FUNCdefinepropertyorthrow(VARglobal, VARname, VARdesc). 
*0*return VARglobal.    

############# END ## 139 ###########################
############# BEGIN ## 140 ###########################
ID= 8.3.1
Summary= GetActiveScriptOrModule ( )
Description= The GetActiveScriptOrModule abstract operation is used to determine the running script or module, based on the running execution context. GetActiveScriptOrModule performs the following steps:
*0*if the execution context stack is empty, return null. 
*0*let VARec be the topmost execution context on the execution context stack whose scriptormodule component is not null. 
*0*if no such execution context exists, return null. otherwise, return VARec's scriptormodule component.    

############# END ## 140 ###########################
############# BEGIN ## 141 ###########################
ID= 8.3.2
Summary= ResolveBinding ( name [ , env ] )
Description= The ResolveBinding abstract operation is used to determine the binding of name passed as a String value. The optional argument env can be used to explicitly provide the Lexical Environment that is to be searched for the binding. During execution of ECMAScript code, ResolveBinding is performed using the following algorithm:
*0*if VARenv is not present or if VARenv is undefined, then
*1*set VARenv to the running execution context's lexicalenvironment. 
*0*assert: VARenv is a lexical environment. 
*0*if the code matching the syntactic production that is being evaluated is contained in strict mode code, let VARstrict be true, else let VARstrict be false. 
*0*return ? FUNCgetidentifierreference(VARenv, VARname, VARstrict).    

############# END ## 141 ###########################
############# BEGIN ## 142 ###########################
ID= 8.3.3
Summary= GetThisEnvironment ( )
Description= The abstract operation GetThisEnvironment finds the Environment Record that currently supplies the binding of the keyword this. GetThisEnvironment performs the following steps:
*0*let VARlex be the running execution context's lexicalenvironment. 
*0*repeat,
*1*let VARenvrec be VARlex's environmentrecord. 
*1*let VARexists be VARenvrec.hasthisbinding(). 
*1*if VARexists is true, return VARenvrec. 
*1*let VARouter be the value of VARlex's outer environment reference. 
*1*assert: VARouter is not null. 
*1*set VARlex to VARouter.    

############# END ## 142 ###########################
############# BEGIN ## 143 ###########################
ID= 8.3.4
Summary= ResolveThisBinding ( )
Description= The abstract operation ResolveThisBinding determines the binding of the keyword this using the LexicalEnvironment of the running execution context. ResolveThisBinding performs the following steps:
*0*let VARenvrec be FUNCgetthisenvironment(). 
*0*return ? VARenvrec.getthisbinding().    

############# END ## 143 ###########################
############# BEGIN ## 144 ###########################
ID= 8.3.5
Summary= GetNewTarget ( )
Description= The abstract operation GetNewTarget determines the NewTarget value using the LexicalEnvironment of the running execution context. GetNewTarget performs the following steps:
*0*let VARenvrec be FUNCgetthisenvironment(). 
*0*assert: VARenvrec has a [[NEWTARGET]] field. 
*0*return VARenvrec.[[NEWTARGET]].    

############# END ## 144 ###########################
############# BEGIN ## 145 ###########################
ID= 8.3.6
Summary= GetGlobalObject ( )
Description= The abstract operation GetGlobalObject returns the global object used by the currently running execution context. GetGlobalObject performs the following steps:
*0*let VARctx be the running execution context. 
*0*let VARcurrentrealm be VARctx's realm. 
*0*return VARcurrentrealm.[[GLOBALOBJECT]].    

############# END ## 145 ###########################
############# BEGIN ## 146 ###########################
ID= 8.4.1
Summary= EnqueueJob ( queueName, job, arguments )
Description= The EnqueueJob abstract operation requires three arguments: queueName, job, and arguments. It performs the following steps:
*0*assert: FUNCtype(VARqueuename) is string and its value is the name of a job queue recognized by this implementation. 
*0*assert: VARjob is the name of a job. 
*0*assert: VARarguments is a list that has the same number of elements as the number of parameters required by VARjob. 
*0*let VARcallercontext be the running execution context. 
*0*let VARcallerrealm be VARcallercontext's realm. 
*0*let VARcallerscriptormodule be VARcallercontext's scriptormodule. 
*0*let VARpending be pendingjob { [[JOB]]: VARjob, [[ARGUMENTS]]: VARarguments, [[REALM]]: VARcallerrealm, [[SCRIPTORMODULE]]: VARcallerscriptormodule, [[HOSTDEFINED]]: undefined }. 
*0*perform any implementation or host environment defined processing of VARpending. this may include modifying the [[HOSTDEFINED]] field or any other field of VARpending. 
*0*add VARpending at the back of the job queue named by VARqueuename. 
*0*return FUNCnormalcompletion(empty).    

############# END ## 146 ###########################
############# BEGIN ## 147 ###########################
ID= 8.5
Summary= InitializeHostDefinedRealm ( )
Description= The abstract operation InitializeHostDefinedRealm performs the following steps:
*0*let VARrealm be FUNCcreaterealm(). 
*0*let VARnewcontext be a new execution context. 
*0*set the function of VARnewcontext to null. 
*0*set the realm of VARnewcontext to VARrealm. 
*0*set the scriptormodule of VARnewcontext to null. 
*0*push VARnewcontext onto the execution context stack; VARnewcontext is now the running execution context. 
*0*if the host requires use of an exotic object to serve as VARrealm's global object, let VARglobal be such an object created in an implementation-defined manner. otherwise, let VARglobal be undefined, indicating that an ordinary object should be created as the global object. 
*0*if the host requires that the this binding in VARrealm's global scope return an object other than the global object, let VARthisvalue be such an object created in an implementation-defined manner. otherwise, let VARthisvalue be undefined, indicating that VARrealm's global this binding should be the global object. 
*0*perform FUNCsetrealmglobalobject(VARrealm, VARglobal, VARthisvalue). 
*0*let VARglobalobj be ? FUNCsetdefaultglobalbindings(VARrealm). 
*0*create any implementation-defined global object properties on VARglobalobj. 
*0*return FUNCnormalcompletion(empty).   

############# END ## 147 ###########################
############# BEGIN ## 148 ###########################
ID= 8.6
Summary= RunJobs ( )
Description= The abstract operation RunJobs performs the following steps:
*0*perform ? FUNCinitializehostdefinedrealm(). 
*0*in an implementation-dependent manner, obtain the ecmascript source texts (see clause 10) and any associated host-defined values for zero or more ecmascript scripts and/or ecmascript modules. for each such VARsourcetext and VARhostdefined, do
*1*if VARsourcetext is the source code of a script, then
*2*perform FUNCenqueuejob("scriptjobs", scriptevaluationjob, « VARsourcetext, VARhostdefined »). 
*1*else VARsourcetext is the source code of a module,
*2*perform FUNCenqueuejob("scriptjobs", toplevelmoduleevaluationjob, « VARsourcetext, VARhostdefined »). 
*0*repeat,
*1*suspend the running execution context and remove it from the execution context stack. 
*1*assert: the execution context stack is now empty. 
*1*let VARnextqueue be a non-empty job queue chosen in an implementation-defined manner. if all job queues are empty, the result is implementation-defined. 
*1*let VARnextpending be the pendingjob record at the front of VARnextqueue. remove that record from VARnextqueue. 
*1*let VARnewcontext be a new execution context. 
*1*set VARnewcontext's function to null. 
*1*set VARnewcontext's realm to VARnextpending.[[REALM]]. 
*1*set VARnewcontext's scriptormodule to VARnextpending.[[SCRIPTORMODULE]]. 
*1*push VARnewcontext onto the execution context stack; VARnewcontext is now the running execution context. 
*1*perform any implementation or host environment defined job initialization using VARnextpending. 
*1*let VARresult be the result of performing the abstract operation named by VARnextpending.[[JOB]] using the elements of VARnextpending.[[ARGUMENTS]] as its arguments. 
*1*if VARresult is an FUNCabrupt completion, perform hostreporterrors(« VARresult.[[VALUE]] »).   

############# END ## 148 ###########################
############# BEGIN ## 149 ###########################
ID= 8.7.1
Summary= AgentSignifier ( )
Description= The abstract operation AgentSignifier takes no arguments. It performs the following steps:
*0*let VARar be the agent record of the surrounding agent. 
*0*return VARar.[[SIGNIFIER]].    

############# END ## 149 ###########################
############# BEGIN ## 150 ###########################
ID= 8.7.2
Summary= AgentCanSuspend ( )
Description= The abstract operation AgentCanSuspend takes no arguments. It performs the following steps:
*0*let VARar be the agent record of the surrounding agent. 
*0*return VARar.[[CANBLOCK]].    

############# END ## 150 ###########################
############# BEGIN ## 151 ###########################
ID= 9.1.1
Summary= [[GetPrototypeOf]] ( )
Description= When the [[GetPrototypeOf]] internal method of O is called, the following steps are taken:
*0*return ! FUNCordinarygetprototypeof(VARo).    

############# END ## 151 ###########################
############# BEGIN ## 152 ###########################
ID= 9.1.1.1
Summary= OrdinaryGetPrototypeOf ( O )
Description= When the abstract operation OrdinaryGetPrototypeOf is called with Object O, the following steps are taken:
*0*return VARo.[[PROTOTYPE]].     

############# END ## 152 ###########################
############# BEGIN ## 153 ###########################
ID= 9.1.2
Summary= [[SetPrototypeOf]] ( V )
Description= When the [[SetPrototypeOf]] internal method of O is called with argument V, the following steps are taken:
*0*return ! FUNCordinarysetprototypeof(VARo, VARv).    

############# END ## 153 ###########################
############# BEGIN ## 154 ###########################
ID= 9.1.2.1
Summary= OrdinarySetPrototypeOf ( O, V )
Description= When the abstract operation OrdinarySetPrototypeOf is called with Object O and value V, the following steps are taken:
*0*assert: either FUNCtype(VARv) is object or FUNCtype(VARv) is null. 
*0*let VARextensible be VARo.[[EXTENSIBLE]]. 
*0*let VARcurrent be VARo.[[PROTOTYPE]]. 
*0*if FUNCsamevalue(VARv, VARcurrent) is true, return true. 
*0*if VARextensible is false, return false. 
*0*let VARp be VARv. 
*0*let VARdone be false. 
*0*repeat, while VARdone is false,
*1*if VARp is null, set VARdone to true. 
*1*else if FUNCsamevalue(VARp, VARo) is true, return false. 
*1*else,
*2*if VARp.[[GETPROTOTYPEOF]] is not the ordinary object internal method defined in 9.1.1, set VARdone to true. 
*2*else, set VARp to VARp.[[PROTOTYPE]]. 
*0*set VARo.[[PROTOTYPE]] to VARv. 
*0*return true.     

############# END ## 154 ###########################
############# BEGIN ## 155 ###########################
ID= 9.1.3
Summary= [[IsExtensible]] ( )
Description= When the [[IsExtensible]] internal method of O is called, the following steps are taken:
*0*return ! FUNCordinaryisextensible(VARo).    

############# END ## 155 ###########################
############# BEGIN ## 156 ###########################
ID= 9.1.3.1
Summary= OrdinaryIsExtensible ( O )
Description= When the abstract operation OrdinaryIsExtensible is called with Object O, the following steps are taken:
*0*return VARo.[[EXTENSIBLE]].     

############# END ## 156 ###########################
############# BEGIN ## 157 ###########################
ID= 9.1.4
Summary= [[PreventExtensions]] ( )
Description= When the [[PreventExtensions]] internal method of O is called, the following steps are taken:
*0*return ! FUNCordinarypreventextensions(VARo).    

############# END ## 157 ###########################
############# BEGIN ## 158 ###########################
ID= 9.1.4.1
Summary= OrdinaryPreventExtensions ( O )
Description= When the abstract operation OrdinaryPreventExtensions is called with Object O, the following steps are taken:
*0*set VARo.[[EXTENSIBLE]] to false. 
*0*return true.     

############# END ## 158 ###########################
############# BEGIN ## 159 ###########################
ID= 9.1.5
Summary= [[GetOwnProperty]] ( P )
Description= When the [[GetOwnProperty]] internal method of O is called with property key P, the following steps are taken:
*0*return ! FUNCordinarygetownproperty(VARo, VARp).    

############# END ## 159 ###########################
############# BEGIN ## 160 ###########################
ID= 9.1.5.1
Summary= OrdinaryGetOwnProperty ( O, P )
Description= When the abstract operation OrdinaryGetOwnProperty is called with Object O and with property key P, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*if VARo does not have an own property with key VARp, return undefined. 
*0*let VARd be a newly created property descriptor with no fields. 
*0*let VARx be VARo's own property whose key is VARp. 
*0*if VARx is a data property, then
*1*set VARd.[[VALUE]] to the value of VARx's [[VALUE]] attribute. 
*1*set VARd.[[WRITABLE]] to the value of VARx's [[WRITABLE]] attribute. 
*0*else VARx is an accessor property,
*1*set VARd.[[GET]] to the value of VARx's [[GET]] attribute. 
*1*set VARd.[[SET]] to the value of VARx's [[SET]] attribute. 
*0*set VARd.[[ENUMERABLE]] to the value of VARx's [[ENUMERABLE]] attribute. 
*0*set VARd.[[CONFIGURABLE]] to the value of VARx's [[CONFIGURABLE]] attribute. 
*0*return VARd.     

############# END ## 160 ###########################
############# BEGIN ## 161 ###########################
ID= 9.1.6
Summary= [[DefineOwnProperty]] ( P, Desc )
Description= When the [[DefineOwnProperty]] internal method of O is called with property key P and Property Descriptor Desc, the following steps are taken:
*0*return ? FUNCordinarydefineownproperty(VARo, VARp, VARdesc).    

############# END ## 161 ###########################
############# BEGIN ## 162 ###########################
ID= 9.1.6.1
Summary= OrdinaryDefineOwnProperty ( O, P, Desc )
Description= When the abstract operation OrdinaryDefineOwnProperty is called with Object O, property key P, and Property Descriptor Desc, the following steps are taken:
*0*let VARcurrent be ? VARo.[[GETOWNPROPERTY]](VARp). 
*0*let VARextensible be VARo.[[EXTENSIBLE]]. 
*0*return FUNCvalidateandapplypropertydescriptor(VARo, VARp, VARextensible, VARdesc, VARcurrent).     

############# END ## 162 ###########################
############# BEGIN ## 163 ###########################
ID= 9.1.6.2
Summary= IsCompatiblePropertyDescriptor ( Extensible, Desc, Current )
Description= When the abstract operation IsCompatiblePropertyDescriptor is called with Boolean value Extensible, and Property Descriptors Desc, and Current, the following steps are taken:
*0*return FUNCvalidateandapplypropertydescriptor(undefined, undefined, VARextensible, VARdesc, VARcurrent).     

############# END ## 163 ###########################
############# BEGIN ## 164 ###########################
ID= 9.1.6.3
Summary= ValidateAndApplyPropertyDescriptor ( O, P, extensible, Desc, current )
Description= When the abstract operation ValidateAndApplyPropertyDescriptor is called with Object O, property key P, Boolean value extensible, and Property Descriptors Desc, and current, the following steps are taken:
*0*assert: if VARo is not undefined, then FUNCispropertykey(VARp) is true. 
*0*if VARcurrent is undefined, then
*1*if VARextensible is false, return false. 
*1*assert: VARextensible is true. 
*1*if FUNCisgenericdescriptor(VARdesc) is true or FUNCisdatadescriptor(VARdesc) is true, then
*2*if VARo is not undefined, create an own data property named VARp of object VARo whose [[VALUE]], [[WRITABLE]], [[ENUMERABLE]] and [[CONFIGURABLE]] attribute values are described by VARdesc. if the value of an attribute field of VARdesc is absent, the attribute of the newly created property is set to its default value. 
*1*else VARdesc must be an accessor property descriptor,
*2*if VARo is not undefined, create an own accessor property named VARp of object VARo whose [[GET]], [[SET]], [[ENUMERABLE]] and [[CONFIGURABLE]] attribute values are described by VARdesc. if the value of an attribute field of VARdesc is absent, the attribute of the newly created property is set to its default value. 
*1*return true. 
*0*if every field in VARdesc is absent, return true. 
*0*if VARcurrent.[[CONFIGURABLE]] is false, then
*1*if VARdesc.[[CONFIGURABLE]] is present and its value is true, return false. 
*1*if VARdesc.[[ENUMERABLE]] is present and the [[ENUMERABLE]] fields of VARcurrent and VARdesc are the boolean negation of each other, return false. 
*0*if FUNCisgenericdescriptor(VARdesc) is true, no further validation is required. 
*0*else if FUNCisdatadescriptor(VARcurrent) and FUNCisdatadescriptor(VARdesc) have different results, then
*1*if VARcurrent.[[CONFIGURABLE]] is false, return false. 
*1*if FUNCisdatadescriptor(VARcurrent) is true, then
*2*if VARo is not undefined, convert the property named VARp of object VARo from a data property to an accessor property. preserve the existing values of the converted property's [[CONFIGURABLE]] and [[ENUMERABLE]] attributes and set the rest of the property's attributes to their default values. 
*1*else,
*2*if VARo is not undefined, convert the property named VARp of object VARo from an accessor property to a data property. preserve the existing values of the converted property's [[CONFIGURABLE]] and [[ENUMERABLE]] attributes and set the rest of the property's attributes to their default values. 
*0*else if FUNCisdatadescriptor(VARcurrent) and FUNCisdatadescriptor(VARdesc) are both true, then
*1*if VARcurrent.[[CONFIGURABLE]] is false and VARcurrent.[[WRITABLE]] is false, then
*2*if VARdesc.[[WRITABLE]] is present and VARdesc.[[WRITABLE]] is true, return false. 
*2*if VARdesc.[[VALUE]] is present and FUNCsamevalue(VARdesc.[[VALUE]], VARcurrent.[[VALUE]]) is false, return false. 
*2*return true. 
*0*else FUNCisaccessordescriptor(VARcurrent) and FUNCisaccessordescriptor(VARdesc) are both true,
*1*if VARcurrent.[[CONFIGURABLE]] is false, then
*2*if VARdesc.[[SET]] is present and FUNCsamevalue(VARdesc.[[SET]], VARcurrent.[[SET]]) is false, return false. 
*2*if VARdesc.[[GET]] is present and FUNCsamevalue(VARdesc.[[GET]], VARcurrent.[[GET]]) is false, return false. 
*2*return true. 
*0*if VARo is not undefined, then
*1*for each field of VARdesc that is present, set the corresponding attribute of the property named VARp of object VARo to the value of the field. 
*0*return true.     

############# END ## 164 ###########################
############# BEGIN ## 165 ###########################
ID= 9.1.7
Summary= [[HasProperty]] ( P )
Description= When the [[HasProperty]] internal method of O is called with property key P, the following steps are taken:
*0*return ? FUNCordinaryhasproperty(VARo, VARp).    

############# END ## 165 ###########################
############# BEGIN ## 166 ###########################
ID= 9.1.7.1
Summary= OrdinaryHasProperty ( O, P )
Description= When the abstract operation OrdinaryHasProperty is called with Object O and with property key P, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*let VARhasown be ? VARo.[[GETOWNPROPERTY]](VARp). 
*0*if VARhasown is not undefined, return true. 
*0*let VARparent be ? VARo.[[GETPROTOTYPEOF]](). 
*0*if VARparent is not null, then
*1*return ? VARparent.[[HASPROPERTY]](VARp). 
*0*return false.     

############# END ## 166 ###########################
############# BEGIN ## 167 ###########################
ID= 9.1.8
Summary= [[Get]] ( P, Receiver )
Description= When the [[Get]] internal method of O is called with property key P and ECMAScript language value Receiver, the following steps are taken:
*0*return ? FUNCordinaryget(VARo, VARp, VARreceiver).    

############# END ## 167 ###########################
############# BEGIN ## 168 ###########################
ID= 9.1.8.1
Summary= OrdinaryGet ( O, P, Receiver )
Description= When the abstract operation OrdinaryGet is called with Object O, property key P, and ECMAScript language value Receiver, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*let VARdesc be ? VARo.[[GETOWNPROPERTY]](VARp). 
*0*if VARdesc is undefined, then
*1*let VARparent be ? VARo.[[GETPROTOTYPEOF]](). 
*1*if VARparent is null, return undefined. 
*1*return ? VARparent.[[GET]](VARp, VARreceiver). 
*0*if FUNCisdatadescriptor(VARdesc) is true, return VARdesc.[[VALUE]]. 
*0*assert: FUNCisaccessordescriptor(VARdesc) is true. 
*0*let VARgetter be VARdesc.[[GET]]. 
*0*if VARgetter is undefined, return undefined. 
*0*return ? FUNCcall(VARgetter, VARreceiver).     

############# END ## 168 ###########################
############# BEGIN ## 169 ###########################
ID= 9.1.9
Summary= [[Set]] ( P, V, Receiver )
Description= When the [[Set]] internal method of O is called with property key P, value V, and ECMAScript language value Receiver, the following steps are taken:
*0*return ? FUNCordinaryset(VARo, VARp, VARv, VARreceiver).    

############# END ## 169 ###########################
############# BEGIN ## 170 ###########################
ID= 9.1.9.1
Summary= OrdinarySet ( O, P, V, Receiver )
Description= When the abstract operation OrdinarySet is called with Object O, property key P, value V, and ECMAScript language value Receiver, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*let VARowndesc be ? VARo.[[GETOWNPROPERTY]](VARp). 
*0*return FUNCordinarysetwithowndescriptor(VARo, VARp, VARv, VARreceiver, VARowndesc).     

############# END ## 170 ###########################
############# BEGIN ## 171 ###########################
ID= 9.1.9.2
Summary= OrdinarySetWithOwnDescriptor ( O, P, V, Receiver, ownDesc )
Description= When the abstract operation OrdinarySetWithOwnDescriptor is called with Object O, property key P, value V, ECMAScript language value Receiver, and Property Descriptor (or undefined) ownDesc, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*if VARowndesc is undefined, then
*1*let VARparent be ? VARo.[[GETPROTOTYPEOF]](). 
*1*if VARparent is not null, then
*2*return ? VARparent.[[SET]](VARp, VARv, VARreceiver). 
*1*else,
*2*set VARowndesc to the propertydescriptor { [[VALUE]]: undefined, [[WRITABLE]]: true, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: true }. 
*0*if FUNCisdatadescriptor(VARowndesc) is true, then
*1*if VARowndesc.[[WRITABLE]] is false, return false. 
*1*if FUNCtype(VARreceiver) is not object, return false. 
*1*let VARexistingdescriptor be ? VARreceiver.[[GETOWNPROPERTY]](VARp). 
*1*if VARexistingdescriptor is not undefined, then
*2*if FUNCisaccessordescriptor(VARexistingdescriptor) is true, return false. 
*2*if VARexistingdescriptor.[[WRITABLE]] is false, return false. 
*2*let VARvaluedesc be the propertydescriptor { [[VALUE]]: VARv }. 
*2*return ? VARreceiver.[[DEFINEOWNPROPERTY]](VARp, VARvaluedesc). 
*1*else VARreceiver does not currently have a property VARp,
*2*return ? FUNCcreatedataproperty(VARreceiver, VARp, VARv). 
*0*assert: FUNCisaccessordescriptor(VARowndesc) is true. 
*0*let VARsetter be VARowndesc.[[SET]]. 
*0*if VARsetter is undefined, return false. 
*0*perform ? FUNCcall(VARsetter, VARreceiver, « VARv »). 
*0*return true.     

############# END ## 171 ###########################
############# BEGIN ## 172 ###########################
ID= 9.1.10
Summary= [[Delete]] ( P )
Description= When the [[Delete]] internal method of O is called with property key P, the following steps are taken:
*0*return ? FUNCordinarydelete(VARo, VARp).    

############# END ## 172 ###########################
############# BEGIN ## 173 ###########################
ID= 9.1.10.1
Summary= OrdinaryDelete ( O, P )
Description= When the abstract operation OrdinaryDelete is called with Object O and property key P, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*let VARdesc be ? VARo.[[GETOWNPROPERTY]](VARp). 
*0*if VARdesc is undefined, return true. 
*0*if VARdesc.[[CONFIGURABLE]] is true, then
*1*remove the own property with name VARp from VARo. 
*1*return true. 
*0*return false.     

############# END ## 173 ###########################
############# BEGIN ## 174 ###########################
ID= 9.1.11
Summary= [[OwnPropertyKeys]] ( )
Description= When the [[OwnPropertyKeys]] internal method of O is called, the following steps are taken:
*0*return ! FUNCordinaryownpropertykeys(VARo).    

############# END ## 174 ###########################
############# BEGIN ## 175 ###########################
ID= 9.1.11.1
Summary= OrdinaryOwnPropertyKeys ( O )
Description= When the abstract operation OrdinaryOwnPropertyKeys is called with Object O, the following steps are taken:
*0*let VARkeys be a new empty list. 
*0*for each own property key VARp of VARo that is an integer index, in ascending numeric index order, do
*1*add VARp as the last element of VARkeys. 
*0*for each own property key VARp of VARo that is a string but is not an integer index, in ascending chronological order of property creation, do
*1*add VARp as the last element of VARkeys. 
*0*for each own property key VARp of VARo that is a symbol, in ascending chronological order of property creation, do
*1*add VARp as the last element of VARkeys. 
*0*return VARkeys.     

############# END ## 175 ###########################
############# BEGIN ## 176 ###########################
ID= 9.1.12
Summary= ObjectCreate ( proto [ , internalSlotsList ] )
Description= The abstract operation ObjectCreate with argument proto (an object or null) is used to specify the runtime creation of new ordinary objects. The optional argument internalSlotsList is a List of the names of additional internal slots that must be defined as part of the object. If the list is not provided, a new empty List is used. This abstract operation performs the following steps:
*0*if VARinternalslotslist is not present, set VARinternalslotslist to a new empty list. 
*0*let VARobj be a newly created object with an internal slot for each name in VARinternalslotslist. 
*0*set VARobj's essential internal methods to the default ordinary object definitions specified in 9.1. 
*0*set VARobj.[[PROTOTYPE]] to VARproto. 
*0*set VARobj.[[EXTENSIBLE]] to true. 
*0*return VARobj.    

############# END ## 176 ###########################
############# BEGIN ## 177 ###########################
ID= 9.1.13
Summary= OrdinaryCreateFromConstructor ( constructor, intrinsicDefaultProto [ , internalSlotsList ] )
Description= The abstract operation OrdinaryCreateFromConstructor creates an ordinary object whose [[Prototype]] value is retrieved from a constructor's prototype property, if it exists. Otherwise the intrinsic named by intrinsicDefaultProto is used for [[Prototype]]. The optional internalSlotsList is a List of the names of additional internal slots that must be defined as part of the object. If the list is not provided, a new empty List is used. This abstract operation performs the following steps:
*0*assert: VARintrinsicdefaultproto is a string value that is this specification's name of an intrinsic object. the corresponding object must be an intrinsic that is intended to be used as the [[PROTOTYPE]] value of an object. 
*0*let VARproto be ? FUNCgetprototypefromconstructor(VARconstructor, VARintrinsicdefaultproto). 
*0*return FUNCobjectcreate(VARproto, VARinternalslotslist).    

############# END ## 177 ###########################
############# BEGIN ## 178 ###########################
ID= 9.1.14
Summary= GetPrototypeFromConstructor ( constructor, intrinsicDefaultProto )
Description= The abstract operation GetPrototypeFromConstructor determines the [[Prototype]] value that should be used to create an object corresponding to a specific constructor. The value is retrieved from the constructor's prototype property, if it exists. Otherwise the intrinsic named by intrinsicDefaultProto is used for [[Prototype]]. This abstract operation performs the following steps:
*0*assert: VARintrinsicdefaultproto is a string value that is this specification's name of an intrinsic object. the corresponding object must be an intrinsic that is intended to be used as the [[PROTOTYPE]] value of an object. 
*0*assert: FUNCiscallable(VARconstructor) is true. 
*0*let VARproto be ? FUNCget(VARconstructor, "prototype"). 
*0*if FUNCtype(VARproto) is not object, then
*1*let VARrealm be ? FUNCgetfunctionrealm(VARconstructor). 
*1*set VARproto to VARrealm's intrinsic object named VARintrinsicdefaultproto. 
*0*return VARproto.    

############# END ## 178 ###########################
############# BEGIN ## 179 ###########################
ID= 9.2.1
Summary= [[Call]] ( thisArgument, argumentsList )
Description= The [[Call]] internal method for an ECMAScript function object F is called with parameters thisArgument and argumentsList, a List of ECMAScript language values. The following steps are taken:
*0*assert: VARf is an ecmascript function object. 
*0*if VARf.[[FUNCTIONKIND]] is "classconstructor", throw a typeerror exception. 
*0*let VARcallercontext be the running execution context. 
*0*let VARcalleecontext be FUNCprepareforordinarycall(VARf, undefined). 
*0*assert: VARcalleecontext is now the running execution context. 
*0*perform FUNCordinarycallbindthis(VARf, VARcalleecontext, VARthisargument). 
*0*let VARresult be FUNCordinarycallevaluatebody(VARf, VARargumentslist). 
*0*remove VARcalleecontext from the execution context stack and restore VARcallercontext as the running execution context. 
*0*if VARresult.[[TYPE]] is return, return FUNCnormalcompletion(VARresult.[[VALUE]]). 
*0*FUNCreturnifabrupt(VARresult). 
*0*return FUNCnormalcompletion(undefined).    

############# END ## 179 ###########################
############# BEGIN ## 180 ###########################
ID= 9.2.1.1
Summary= PrepareForOrdinaryCall ( F, newTarget )
Description= When the abstract operation PrepareForOrdinaryCall is called with function object F and ECMAScript language value newTarget, the following steps are taken:
*0*assert: FUNCtype(VARnewtarget) is undefined or object. 
*0*let VARcallercontext be the running execution context. 
*0*let VARcalleecontext be a new ecmascript code execution context. 
*0*set the function of VARcalleecontext to VARf. 
*0*let VARcalleerealm be VARf.[[REALM]]. 
*0*set the realm of VARcalleecontext to VARcalleerealm. 
*0*set the scriptormodule of VARcalleecontext to VARf.[[SCRIPTORMODULE]]. 
*0*let VARlocalenv be FUNCnewfunctionenvironment(VARf, VARnewtarget). 
*0*set the lexicalenvironment of VARcalleecontext to VARlocalenv. 
*0*set the variableenvironment of VARcalleecontext to VARlocalenv. 
*0*if VARcallercontext is not already suspended, suspend VARcallercontext. 
*0*push VARcalleecontext onto the execution context stack; VARcalleecontext is now the running execution context. 
*0*note: any exception objects produced after this point are associated with VARcalleerealm. 
*0*return VARcalleecontext.     

############# END ## 180 ###########################
############# BEGIN ## 181 ###########################
ID= 9.2.1.2
Summary= OrdinaryCallBindThis ( F, calleeContext, thisArgument )
Description= When the abstract operation OrdinaryCallBindThis is called with function object F, execution context calleeContext, and ECMAScript value thisArgument, the following steps are taken:
*0*let VARthismode be VARf.[[THISMODE]]. 
*0*if VARthismode is lexical, return FUNCnormalcompletion(undefined). 
*0*let VARcalleerealm be VARf.[[REALM]]. 
*0*let VARlocalenv be the lexicalenvironment of VARcalleecontext. 
*0*if VARthismode is strict, let VARthisvalue be VARthisargument. 
*0*else,
*1*if VARthisargument is undefined or null, then
*2*let VARglobalenv be VARcalleerealm.[[GLOBALENV]]. 
*2*let VARglobalenvrec be VARglobalenv's environmentrecord. 
*2*assert: VARglobalenvrec is a global environment record. 
*2*let VARthisvalue be VARglobalenvrec.[[GLOBALTHISVALUE]]. 
*1*else,
*2*let VARthisvalue be ! FUNCtoobject(VARthisargument). 
*2*note: toobject produces wrapper objects using VARcalleerealm. 
*0*let VARenvrec be VARlocalenv's environmentrecord. 
*0*assert: VARenvrec is a function environment record. 
*0*assert: the next step never returns an abrupt completion because VARenvrec.[[THISBINDINGSTATUS]] is not "initialized". 
*0*return VARenvrec.bindthisvalue(VARthisvalue).     

############# END ## 181 ###########################
############# BEGIN ## 182 ###########################
ID= 9.2.1.3
Summary= OrdinaryCallEvaluateBody ( F, argumentsList )
Description= When the abstract operation OrdinaryCallEvaluateBody is called with function object F and List argumentsList, the following steps are taken:
*0*return the result of evaluatebody of the parsed code that is VARf.[[ECMASCRIPTCODE]] passing VARf and VARargumentslist as the arguments.     

############# END ## 182 ###########################
############# BEGIN ## 183 ###########################
ID= 9.2.2
Summary= [[Construct]] ( argumentsList, newTarget )
Description= The [[Construct]] internal method for an ECMAScript function object F is called with parameters argumentsList and newTarget. argumentsList is a possibly empty List of ECMAScript language values. The following steps are taken:
*0*assert: VARf is an ecmascript function object. 
*0*assert: FUNCtype(VARnewtarget) is object. 
*0*let VARcallercontext be the running execution context. 
*0*let VARkind be VARf.[[CONSTRUCTORKIND]]. 
*0*if VARkind is "base", then
*1*let VARthisargument be ? FUNCordinarycreatefromconstructor(VARnewtarget, "%objectprototype%"). 
*0*let VARcalleecontext be FUNCprepareforordinarycall(VARf, VARnewtarget). 
*0*assert: VARcalleecontext is now the running execution context. 
*0*if VARkind is "base", perform FUNCordinarycallbindthis(VARf, VARcalleecontext, VARthisargument). 
*0*let VARconstructorenv be the lexicalenvironment of VARcalleecontext. 
*0*let VARenvrec be VARconstructorenv's environmentrecord. 
*0*let VARresult be FUNCordinarycallevaluatebody(VARf, VARargumentslist). 
*0*remove VARcalleecontext from the execution context stack and restore VARcallercontext as the running execution context. 
*0*if VARresult.[[TYPE]] is return, then
*1*if FUNCtype(VARresult.[[VALUE]]) is object, return FUNCnormalcompletion(VARresult.[[VALUE]]). 
*1*if VARkind is "base", return FUNCnormalcompletion(VARthisargument). 
*1*if VARresult.[[VALUE]] is not undefined, throw a typeerror exception. 
*0*else, FUNCreturnifabrupt(VARresult). 
*0*return ? VARenvrec.getthisbinding().    

############# END ## 183 ###########################
############# BEGIN ## 184 ###########################
ID= 9.2.3
Summary= FunctionAllocate ( functionPrototype, strict, functionKind )
Description= The abstract operation FunctionAllocate requires the three arguments functionPrototype, strict and functionKind. FunctionAllocate performs the following steps:
*0*assert: FUNCtype(VARfunctionprototype) is object. 
*0*assert: VARfunctionkind is either "normal", "non-constructor", "generator", "async", or "async generator". 
*0*if VARfunctionkind is "normal", let VARneedsconstruct be true. 
*0*else, let VARneedsconstruct be false. 
*0*if VARfunctionkind is "non-constructor", set VARfunctionkind to "normal". 
*0*let VARf be a newly created ecmascript function object with the internal slots listed in table 27. all of those internal slots are initialized to undefined. 
*0*set VARf's essential internal methods to the default ordinary object definitions specified in 9.1. 
*0*set VARf.[[CALL]] to the definition specified in 9.2.1. 
*0*if VARneedsconstruct is true, then
*1*set VARf.[[CONSTRUCT]] to the definition specified in 9.2.2. 
*1*set VARf.[[CONSTRUCTORKIND]] to "base". 
*0*set VARf.[[STRICT]] to VARstrict. 
*0*set VARf.[[FUNCTIONKIND]] to VARfunctionkind. 
*0*set VARf.[[PROTOTYPE]] to VARfunctionprototype. 
*0*set VARf.[[EXTENSIBLE]] to true. 
*0*set VARf.[[REALM]] to the current realm record. 
*0*return VARf.    

############# END ## 184 ###########################
############# BEGIN ## 185 ###########################
ID= 9.2.4
Summary= FunctionInitialize ( F, kind, ParameterList, Body, Scope )
Description= The abstract operation FunctionInitialize requires the arguments: a function object F, kind which is one of (Normal, Method, Arrow), a parameter list Parse Node specified by ParameterList, a body Parse Node specified by Body, a Lexical Environment specified by Scope. FunctionInitialize performs the following steps:
*0*let VARlen be the expectedargumentcount of VARparameterlist. 
*0*perform ! FUNCsetfunctionlength(VARf, VARlen). 
*0*let VARstrict be VARf.[[STRICT]]. 
*0*set VARf.[[ENVIRONMENT]] to VARscope. 
*0*set VARf.[[FORMALPARAMETERS]] to VARparameterlist. 
*0*set VARf.[[ECMASCRIPTCODE]] to VARbody. 
*0*set VARf.[[SCRIPTORMODULE]] to FUNCgetactivescriptormodule(). 
*0*if VARkind is arrow, set VARf.[[THISMODE]] to lexical. 
*0*else if VARstrict is true, set VARf.[[THISMODE]] to strict. 
*0*else, set VARf.[[THISMODE]] to global. 
*0*return VARf.    

############# END ## 185 ###########################
############# BEGIN ## 186 ###########################
ID= 9.2.5
Summary= FunctionCreate ( kind, ParameterList, Body, Scope, Strict [ , prototype ] )
Description= The abstract operation FunctionCreate requires the arguments: kind which is one of (Normal, Method, Arrow), a parameter list Parse Node specified by ParameterList, a body Parse Node specified by Body, a Lexical Environment specified by Scope, a Boolean flag Strict, and optionally, an object prototype. FunctionCreate performs the following steps:
*0*if VARprototype is not present, then
*1*set VARprototype to the intrinsic object %functionprototype%. 
*0*if VARkind is not normal, let VARallockind be "non-constructor". 
*0*else, let VARallockind be "normal". 
*0*let VARf be FUNCfunctionallocate(VARprototype, VARstrict, VARallockind). 
*0*return FUNCfunctioninitialize(VARf, VARkind, VARparameterlist, VARbody, VARscope).    

############# END ## 186 ###########################
############# BEGIN ## 187 ###########################
ID= 9.2.6
Summary= GeneratorFunctionCreate ( kind, ParameterList, Body, Scope, Strict )
Description= The abstract operation GeneratorFunctionCreate requires the arguments: kind which is one of (Normal, Method), a parameter list Parse Node specified by ParameterList, a body Parse Node specified by Body, a Lexical Environment specified by Scope, and a Boolean flag Strict. GeneratorFunctionCreate performs the following steps:
*0*let VARfunctionprototype be the intrinsic object %generator%. 
*0*let VARf be FUNCfunctionallocate(VARfunctionprototype, VARstrict, "generator"). 
*0*return FUNCfunctioninitialize(VARf, VARkind, VARparameterlist, VARbody, VARscope).    

############# END ## 187 ###########################
############# BEGIN ## 188 ###########################
ID= 9.2.7
Summary= AsyncGeneratorFunctionCreate ( kind, ParameterList, Body, Scope, Strict )
Description= The abstract operation AsyncGeneratorFunctionCreate requires the arguments: kind which is one of (Normal, Method), a parameter list Parse Node specified by ParameterList, a body Parse Node specified by Body, a Lexical Environment specified by Scope, and a Boolean flag Strict. AsyncGeneratorFunctionCreate performs the following steps:
*0*let VARfunctionprototype be the intrinsic object %asyncgenerator%. 
*0*let VARf be ! FUNCfunctionallocate(VARfunctionprototype, VARstrict, "generator"). 
*0*return ! FUNCfunctioninitialize(VARf, VARkind, VARparameterlist, VARbody, VARscope).    

############# END ## 188 ###########################
############# BEGIN ## 189 ###########################
ID= 9.2.8
Summary= AsyncFunctionCreate ( kind, parameters, body, Scope, Strict )
Description= The abstract operation AsyncFunctionCreate requires the arguments: kind which is one of (Normal, Method, Arrow), a parameter list Parse Node specified by parameters, a body Parse Node specified by body, a Lexical Environment specified by Scope, and a Boolean flag Strict. AsyncFunctionCreate performs the following steps:
*0*let VARfunctionprototype be the intrinsic object %asyncfunctionprototype%. 
*0*let VARf be ! FUNCfunctionallocate(VARfunctionprototype, VARstrict, "async"). 
*0*return ! FUNCfunctioninitialize(VARf, VARkind, VARparameters, VARbody, VARscope).    

############# END ## 189 ###########################
############# BEGIN ## 190 ###########################
ID= 9.2.9
Summary= AddRestrictedFunctionProperties ( F, realm )
Description= The abstract operation AddRestrictedFunctionProperties is called with a function object F and Realm Record realm as its argument. It performs the following steps:
*0*assert: VARrealm.[[INTRINSICS]].[[%THROWTYPEERROR%]] exists and has been initialized. 
*0*let VARthrower be VARrealm.[[INTRINSICS]].[[%THROWTYPEERROR%]]. 
*0*perform ! FUNCdefinepropertyorthrow(VARf, "caller", propertydescriptor { [[GET]]: VARthrower, [[SET]]: VARthrower, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }). 
*0*return ! FUNCdefinepropertyorthrow(VARf, "arguments", propertydescriptor { [[GET]]: VARthrower, [[SET]]: VARthrower, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }).    

############# END ## 190 ###########################
############# BEGIN ## 191 ###########################
ID= 9.2.9.1
Summary= %ThrowTypeError% ( )
Description= The  %ThrowTypeError% intrinsic is an anonymous built-in function object that is defined once for each realm. When %ThrowTypeError% is called it performs the following steps:
*0*throw a typeerror exception.     

############# END ## 191 ###########################
############# BEGIN ## 192 ###########################
ID= 9.2.10
Summary= MakeConstructor ( F [ , writablePrototype [ , prototype ] ] )
Description= The abstract operation MakeConstructor requires a Function argument F and optionally, a Boolean writablePrototype and an object prototype. If prototype is provided it is assumed to already contain, if needed, a "constructor" property whose value is F. This operation converts F into a constructor by performing the following steps:
*0*assert: VARf is an ecmascript function object. 
*0*assert: FUNCisconstructor(VARf) is true. 
*0*assert: VARf is an extensible object that does not have a prototype own property. 
*0*if VARwritableprototype is not present, set VARwritableprototype to true. 
*0*if VARprototype is not present, then
*1*set VARprototype to FUNCobjectcreate(%objectprototype%). 
*1*perform ! FUNCdefinepropertyorthrow(VARprototype, "constructor", propertydescriptor { [[VALUE]]: VARf, [[WRITABLE]]: VARwritableprototype, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }). 
*0*perform ! FUNCdefinepropertyorthrow(VARf, "prototype", propertydescriptor { [[VALUE]]: VARprototype, [[WRITABLE]]: VARwritableprototype, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }). 
*0*return FUNCnormalcompletion(undefined).    

############# END ## 192 ###########################
############# BEGIN ## 193 ###########################
ID= 9.2.11
Summary= MakeClassConstructor ( F )
Description= The abstract operation MakeClassConstructor with argument F performs the following steps:
*0*assert: VARf is an ecmascript function object. 
*0*assert: VARf.[[FUNCTIONKIND]] is "normal". 
*0*set VARf.[[FUNCTIONKIND]] to "classconstructor". 
*0*return FUNCnormalcompletion(undefined).    

############# END ## 193 ###########################
############# BEGIN ## 194 ###########################
ID= 9.2.12
Summary= MakeMethod ( F, homeObject )
Description= The abstract operation MakeMethod with arguments F and homeObject configures F as a method by performing the following steps:
*0*assert: VARf is an ecmascript function object. 
*0*assert: FUNCtype(VARhomeobject) is object. 
*0*set VARf.[[HOMEOBJECT]] to VARhomeobject. 
*0*return FUNCnormalcompletion(undefined).    

############# END ## 194 ###########################
############# BEGIN ## 195 ###########################
ID= 9.2.13
Summary= SetFunctionName ( F, name [ , prefix ] )
Description= The abstract operation SetFunctionName requires a Function argument F, a String or Symbol argument name and optionally a String argument prefix. This operation adds a name property to F by performing the following steps:
*0*assert: VARf is an extensible object that does not have a name own property. 
*0*assert: FUNCtype(VARname) is either symbol or string. 
*0*assert: if VARprefix is present, then FUNCtype(VARprefix) is string. 
*0*if FUNCtype(VARname) is symbol, then
*1*let VARdescription be VARname's [[DESCRIPTION]] value. 
*1*if VARdescription is undefined, set VARname to the empty string. 
*1*else, set VARname to the string-concatenation of "[", VARdescription, and "]". 
*0*if VARprefix is present, then
*1*set VARname to the string-concatenation of VARprefix, the code unit 0x0020 (space), and VARname. 
*0*return ! FUNCdefinepropertyorthrow(VARf, "name", propertydescriptor { [[VALUE]]: VARname, [[WRITABLE]]: false, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }).    

############# END ## 195 ###########################
############# BEGIN ## 196 ###########################
ID= 9.2.14
Summary= SetFunctionLength ( F, length )
Description= The abstract operation SetFunctionLength requires a Function argument F and a Number argument length. This operation adds a length property to F by performing the following steps:
*0*assert: VARf is an extensible object that does not have a length own property. 
*0*assert: FUNCtype(VARlength) is number. 
*0*assert: VARlength ≥ 0 and ! FUNCtointeger(VARlength) is equal to VARlength. 
*0*return ! FUNCdefinepropertyorthrow(VARf, "length", propertydescriptor { [[VALUE]]: VARlength, [[WRITABLE]]: false, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }).    

############# END ## 196 ###########################
############# BEGIN ## 197 ###########################
ID= 9.2.15
Summary= FunctionDeclarationInstantiation ( func, argumentsList )
Description= When an execution context is established for evaluating an ECMAScript function a new function Environment Record is created and bindings for each formal parameter are instantiated in that Environment Record. Each declaration in the function body is also instantiated. If the function's formal parameters do not include any default value initializers then the body declarations are instantiated in the same Environment Record as the parameters. If default value parameter initializers exist, a second Environment Record is created for the body declarations. Formal parameters and functions are initialized as part of FunctionDeclarationInstantiation. All other bindings are initialized during evaluation of the function body.
*0*let VARcalleecontext be the running execution context. 
*0*let VARenv be the lexicalenvironment of VARcalleecontext. 
*0*let VARenvrec be VARenv's environmentrecord. 
*0*let VARcode be VARfunc.[[ECMASCRIPTCODE]]. 
*0*let VARstrict be VARfunc.[[STRICT]]. 
*0*let VARformals be VARfunc.[[FORMALPARAMETERS]]. 
*0*let VARparameternames be the boundnames of VARformals. 
*0*if VARparameternames has any duplicate entries, let VARhasduplicates be true. otherwise, let VARhasduplicates be false. 
*0*let VARsimpleparameterlist be issimpleparameterlist of VARformals. 
*0*let VARhasparameterexpressions be containsexpression of VARformals. 
*0*let VARvarnames be the vardeclarednames of VARcode. 
*0*let VARvardeclarations be the varscopeddeclarations of VARcode. 
*0*let VARlexicalnames be the lexicallydeclarednames of VARcode. 
*0*let VARfunctionnames be a new empty list. 
*0*let VARfunctionstoinitialize be a new empty list. 
*0*for each VARd in VARvardeclarations, in reverse list order, do
*1*if VARd is neither a variabledeclaration nor a forbinding nor a bindingidentifier, then
*2*assert: VARd is either a functiondeclaration, a generatordeclaration, an asyncfunctiondeclaration, or an asyncgeneratordeclaration. 
*2*let VARfn be the sole element of the boundnames of VARd. 
*2*if VARfn is not an element of VARfunctionnames, then
*3*insert VARfn as the first element of VARfunctionnames. 
*3*note: if there are multiple function declarations for the same name, the last declaration is used. 
*3*insert VARd as the first element of VARfunctionstoinitialize. 
*0*let VARargumentsobjectneeded be true. 
*0*if VARfunc.[[THISMODE]] is lexical, then
*1*note: arrow functions never have an arguments objects. 
*1*set VARargumentsobjectneeded to false. 
*0*else if "arguments" is an element of VARparameternames, then
*1*set VARargumentsobjectneeded to false. 
*0*else if VARhasparameterexpressions is false, then
*1*if "arguments" is an element of VARfunctionnames or if "arguments" is an element of VARlexicalnames, then
*2*set VARargumentsobjectneeded to false. 
*0*for each string VARparamname in VARparameternames, do
*1*let VARalreadydeclared be VARenvrec.hasbinding(VARparamname). 
*1*note: early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters. 
*1*if VARalreadydeclared is false, then
*2*perform ! VARenvrec.createmutablebinding(VARparamname, false). 
*2*if VARhasduplicates is true, then
*3*perform ! VARenvrec.initializebinding(VARparamname, undefined). 
*0*if VARargumentsobjectneeded is true, then
*1*if VARstrict is true or if VARsimpleparameterlist is false, then
*2*let VARao be FUNCcreateunmappedargumentsobject(VARargumentslist). 
*1*else,
*2*note: mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters. 
*2*let VARao be FUNCcreatemappedargumentsobject(VARfunc, VARformals, VARargumentslist, VARenvrec). 
*1*if VARstrict is true, then
*2*perform ! VARenvrec.createimmutablebinding("arguments", false). 
*1*else,
*2*perform ! VARenvrec.createmutablebinding("arguments", false). 
*1*call VARenvrec.initializebinding("arguments", VARao). 
*1*let VARparameterbindings be a new list of VARparameternames with "arguments" appended. 
*0*else,
*1*let VARparameterbindings be VARparameternames. 
*0*let VARiteratorrecord be FUNCcreatelistiteratorrecord(VARargumentslist). 
*0*if VARhasduplicates is true, then
*1*perform ? iteratorbindinginitialization for VARformals with VARiteratorrecord and undefined as arguments. 
*0*else,
*1*perform ? iteratorbindinginitialization for VARformals with VARiteratorrecord and VARenv as arguments. 
*0*if VARhasparameterexpressions is false, then
*1*note: only a single lexical environment is needed for the parameters and top-level vars. 
*1*let VARinstantiatedvarnames be a copy of the list VARparameterbindings. 
*1*for each VARn in VARvarnames, do
*2*if VARn is not an element of VARinstantiatedvarnames, then
*3*append VARn to VARinstantiatedvarnames. 
*3*perform ! VARenvrec.createmutablebinding(VARn, false). 
*3*call VARenvrec.initializebinding(VARn, undefined). 
*1*let VARvarenv be VARenv. 
*1*let VARvarenvrec be VARenvrec. 
*0*else,
*1*note: a separate environment record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body. 
*1*let VARvarenv be FUNCnewdeclarativeenvironment(VARenv). 
*1*let VARvarenvrec be VARvarenv's environmentrecord. 
*1*set the variableenvironment of VARcalleecontext to VARvarenv. 
*1*let VARinstantiatedvarnames be a new empty list. 
*1*for each VARn in VARvarnames, do
*2*if VARn is not an element of VARinstantiatedvarnames, then
*3*append VARn to VARinstantiatedvarnames. 
*3*perform ! VARvarenvrec.createmutablebinding(VARn, false). 
*3*if VARn is not an element of VARparameterbindings or if VARn is an element of VARfunctionnames, let VARinitialvalue be undefined. 
*3*else,
*4*let VARinitialvalue be ! VARenvrec.getbindingvalue(VARn, false). 
*3*call VARvarenvrec.initializebinding(VARn, VARinitialvalue). 
*3*note: vars whose names are the same as a formal parameter, initially have the same value as the corresponding initialized parameter. 
*0*note: annex b.3.3.1 adds additional steps at this point. 
*0*if VARstrict is false, then
*1*let VARlexenv be FUNCnewdeclarativeenvironment(VARvarenv). 
*1*note: non-strict functions use a separate lexical environment record for top-level lexical declarations so that a direct eval can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. this is not needed for strict functions because a strict direct eval always places all declarations into a new environment record. 
*0*else, let VARlexenv be VARvarenv. 
*0*let VARlexenvrec be VARlexenv's environmentrecord. 
*0*set the lexicalenvironment of VARcalleecontext to VARlexenv. 
*0*let VARlexdeclarations be the lexicallyscopeddeclarations of VARcode. 
*0*for each element VARd in VARlexdeclarations, do
*1*note: a lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. lexically declared names are only instantiated here but not initialized. 
*1*for each element VARdn of the boundnames of VARd, do
*2*if isconstantdeclaration of VARd is true, then
*3*perform ! VARlexenvrec.createimmutablebinding(VARdn, true). 
*2*else,
*3*perform ! VARlexenvrec.createmutablebinding(VARdn, false). 
*0*for each parse node VARf in VARfunctionstoinitialize, do
*1*let VARfn be the sole element of the boundnames of VARf. 
*1*let VARfo be the result of performing instantiatefunctionobject for VARf with argument VARlexenv. 
*1*perform ! VARvarenvrec.setmutablebinding(VARfn, VARfo, false). 
*0*return FUNCnormalcompletion(empty).    

############# END ## 197 ###########################
############# BEGIN ## 198 ###########################
ID= 9.3.1
Summary= [[Call]] ( thisArgument, argumentsList )
Description= The [[Call]] internal method for a built-in function object F is called with parameters thisArgument and argumentsList, a List of ECMAScript language values. The following steps are taken:
*0*let VARcallercontext be the running execution context. 
*0*if VARcallercontext is not already suspended, suspend VARcallercontext. 
*0*let VARcalleecontext be a new ecmascript code execution context. 
*0*set the function of VARcalleecontext to VARf. 
*0*let VARcalleerealm be VARf.[[REALM]]. 
*0*set the realm of VARcalleecontext to VARcalleerealm. 
*0*set the scriptormodule of VARcalleecontext to VARf.[[SCRIPTORMODULE]]. 
*0*perform any necessary implementation-defined initialization of VARcalleecontext. 
*0*push VARcalleecontext onto the execution context stack; VARcalleecontext is now the running execution context. 
*0*let VARresult be the completion record that is the result of evaluating VARf in an implementation-defined manner that conforms to the specification of VARf. VARthisargument is the this value, VARargumentslist provides the named parameters, and the newtarget value is undefined. 
*0*remove VARcalleecontext from the execution context stack and restore VARcallercontext as the running execution context. 
*0*return VARresult.    

############# END ## 198 ###########################
############# BEGIN ## 199 ###########################
ID= 9.3.2
Summary= [[Construct]] ( argumentsList, newTarget )
Description= The [[Construct]] internal method for built-in function object F is called with parameters argumentsList and newTarget. The steps performed are the same as [[Call]] (see  9.3.1) except that step 10 is replaced by:
*0*let VARresult be the completion record that is the result of evaluating VARf in an implementation-defined manner that conforms to the specification of VARf. the this value is uninitialized, VARargumentslist provides the named parameters, and VARnewtarget provides the newtarget value.    

############# END ## 199 ###########################
############# BEGIN ## 200 ###########################
ID= 9.3.3
Summary= CreateBuiltinFunction ( steps, internalSlotsList [ , realm [ , prototype ] ] )
Description= The abstract operation CreateBuiltinFunction takes arguments steps, internalSlotsList, realm, and prototype. The argument internalSlotsList is a List of the names of additional internal slots that must be defined as part of the object. CreateBuiltinFunction returns a built-in function object created by the following steps:
*0*assert: VARsteps is either a set of algorithm steps or other definition of a function's behaviour provided in this specification. 
*0*if VARrealm is not present, set VARrealm to the current realm record. 
*0*assert: VARrealm is a realm record. 
*0*if VARprototype is not present, set VARprototype to VARrealm.[[INTRINSICS]].[[%FUNCTIONPROTOTYPE%]]. 
*0*let VARfunc be a new built-in function object that when called performs the action described by VARsteps. the new function object has internal slots whose names are the elements of VARinternalslotslist. the initial value of each of those internal slots is undefined. 
*0*set VARfunc.[[REALM]] to VARrealm. 
*0*set VARfunc.[[PROTOTYPE]] to VARprototype. 
*0*set VARfunc.[[EXTENSIBLE]] to true. 
*0*set VARfunc.[[SCRIPTORMODULE]] to null. 
*0*return VARfunc.    

############# END ## 200 ###########################
############# BEGIN ## 201 ###########################
ID= 9.4.1.1
Summary= [[Call]] ( thisArgument, argumentsList )
Description= When the [[Call]] internal method of a bound function exotic object, F, which was created using the bind function is called with parameters thisArgument and argumentsList, a List of ECMAScript language values, the following steps are taken:
*0*let VARtarget be VARf.[[BOUNDTARGETFUNCTION]]. 
*0*let VARboundthis be VARf.[[BOUNDTHIS]]. 
*0*let VARboundargs be VARf.[[BOUNDARGUMENTS]]. 
*0*let VARargs be a new list containing the same values as the list VARboundargs in the same order followed by the same values as the list VARargumentslist in the same order. 
*0*return ? FUNCcall(VARtarget, VARboundthis, VARargs).     

############# END ## 201 ###########################
############# BEGIN ## 202 ###########################
ID= 9.4.1.2
Summary= [[Construct]] ( argumentsList, newTarget )
Description= When the [[Construct]] internal method of a bound function exotic object, F that was created using the bind function is called with a list of arguments argumentsList and newTarget, the following steps are taken:
*0*let VARtarget be VARf.[[BOUNDTARGETFUNCTION]]. 
*0*assert: FUNCisconstructor(VARtarget) is true. 
*0*let VARboundargs be VARf.[[BOUNDARGUMENTS]]. 
*0*let VARargs be a new list containing the same values as the list VARboundargs in the same order followed by the same values as the list VARargumentslist in the same order. 
*0*if FUNCsamevalue(VARf, VARnewtarget) is true, set VARnewtarget to VARtarget. 
*0*return ? FUNCconstruct(VARtarget, VARargs, VARnewtarget).     

############# END ## 202 ###########################
############# BEGIN ## 203 ###########################
ID= 9.4.1.3
Summary= BoundFunctionCreate ( targetFunction, boundThis, boundArgs )
Description= The abstract operation BoundFunctionCreate with arguments targetFunction, boundThis and boundArgs is used to specify the creation of new Bound Function exotic objects. It performs the following steps:
*0*assert: FUNCtype(VARtargetfunction) is object. 
*0*let VARproto be ? VARtargetfunction.[[GETPROTOTYPEOF]](). 
*0*let VARobj be a newly created object. 
*0*set VARobj's essential internal methods to the default ordinary object definitions specified in 9.1. 
*0*set VARobj.[[CALL]] as described in 9.4.1.1. 
*0*if FUNCisconstructor(VARtargetfunction) is true, then
*1*set VARobj.[[CONSTRUCT]] as described in 9.4.1.2. 
*0*set VARobj.[[PROTOTYPE]] to VARproto. 
*0*set VARobj.[[EXTENSIBLE]] to true. 
*0*set VARobj.[[BOUNDTARGETFUNCTION]] to VARtargetfunction. 
*0*set VARobj.[[BOUNDTHIS]] to VARboundthis. 
*0*set VARobj.[[BOUNDARGUMENTS]] to VARboundargs. 
*0*return VARobj.     

############# END ## 203 ###########################
############# BEGIN ## 204 ###########################
ID= 9.4.2.1
Summary= [[DefineOwnProperty]] ( P, Desc )
Description= When the [[DefineOwnProperty]] internal method of an Array exotic object A is called with property key P, and Property Descriptor Desc, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*if VARp is "length", then
*1*return ? FUNCarraysetlength(VARa, VARdesc). 
*0*else if VARp is an array index, then
*1*let VARoldlendesc be FUNCordinarygetownproperty(VARa, "length"). 
*1*assert: VARoldlendesc will never be undefined or an accessor descriptor because array objects are created with a length data property that cannot be deleted or reconfigured. 
*1*let VARoldlen be VARoldlendesc.[[VALUE]]. 
*1*let VARindex be ! FUNCtouint32(VARp). 
*1*if VARindex ≥ VARoldlen and VARoldlendesc.[[WRITABLE]] is false, return false. 
*1*let VARsucceeded be ! FUNCordinarydefineownproperty(VARa, VARp, VARdesc). 
*1*if VARsucceeded is false, return false. 
*1*if VARindex ≥ VARoldlen, then
*2*set VARoldlendesc.[[VALUE]] to VARindex + 1. 
*2*let VARsucceeded be FUNCordinarydefineownproperty(VARa, "length", VARoldlendesc). 
*2*assert: VARsucceeded is true. 
*1*return true. 
*0*return FUNCordinarydefineownproperty(VARa, VARp, VARdesc).     

############# END ## 204 ###########################
############# BEGIN ## 205 ###########################
ID= 9.4.2.2
Summary= ArrayCreate ( length [ , proto ] )
Description= The abstract operation ArrayCreate with argument length (either 0 or a positive integer) and optional argument proto is used to specify the creation of new Array exotic objects. It performs the following steps:
*0*assert: VARlength is an integer number ≥ 0. 
*0*if VARlength is -0, set VARlength to +0. 
*0*if VARlength&gt;232-1, throw a rangeerror exception. 
*0*if VARproto is not present, set VARproto to the intrinsic object %arrayprototype%. 
*0*let VARa be a newly created array exotic object. 
*0*set VARa's essential internal methods except for [[DEFINEOWNPROPERTY]] to the default ordinary object definitions specified in 9.1. 
*0*set VARa.[[DEFINEOWNPROPERTY]] as specified in 9.4.2.1. 
*0*set VARa.[[PROTOTYPE]] to VARproto. 
*0*set VARa.[[EXTENSIBLE]] to true. 
*0*perform ! FUNCordinarydefineownproperty(VARa, "length", propertydescriptor { [[VALUE]]: VARlength, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }). 
*0*return VARa.     

############# END ## 205 ###########################
############# BEGIN ## 206 ###########################
ID= 9.4.2.3
Summary= ArraySpeciesCreate ( originalArray, length )
Description= The abstract operation ArraySpeciesCreate with arguments originalArray and length is used to specify the creation of a new Array object using a constructor function that is derived from originalArray. It performs the following steps:
*0*assert: VARlength is an integer number ≥ 0. 
*0*if VARlength is -0, set VARlength to +0. 
*0*let VARisarray be ? FUNCisarray(VARoriginalarray). 
*0*if VARisarray is false, return ? FUNCarraycreate(VARlength). 
*0*let VARc be ? FUNCget(VARoriginalarray, "constructor"). 
*0*if FUNCisconstructor(VARc) is true, then
*1*let VARthisrealm be the current realm record. 
*1*let VARrealmc be ? FUNCgetfunctionrealm(VARc). 
*1*if VARthisrealm and VARrealmc are not the same realm record, then
*2*if FUNCsamevalue(VARc, VARrealmc.[[INTRINSICS]].[[%ARRAY%]]) is true, set VARc to undefined. 
*0*if FUNCtype(VARc) is object, then
*1*set VARc to ? FUNCget(VARc, @@species). 
*1*if VARc is null, set VARc to undefined. 
*0*if VARc is undefined, return ? FUNCarraycreate(VARlength). 
*0*if FUNCisconstructor(VARc) is false, throw a typeerror exception. 
*0*return ? FUNCconstruct(VARc, « VARlength »).     

############# END ## 206 ###########################
############# BEGIN ## 207 ###########################
ID= 9.4.2.4
Summary= ArraySetLength ( A, Desc )
Description= When the abstract operation ArraySetLength is called with an Array exotic object A, and Property Descriptor Desc, the following steps are taken:
*0*if VARdesc.[[VALUE]] is absent, then
*1*return FUNCordinarydefineownproperty(VARa, "length", VARdesc). 
*0*let VARnewlendesc be a copy of VARdesc. 
*0*let VARnewlen be ? FUNCtouint32(VARdesc.[[VALUE]]). 
*0*let VARnumberlen be ? FUNCtonumber(VARdesc.[[VALUE]]). 
*0*if VARnewlen ≠ VARnumberlen, throw a rangeerror exception. 
*0*set VARnewlendesc.[[VALUE]] to VARnewlen. 
*0*let VARoldlendesc be FUNCordinarygetownproperty(VARa, "length"). 
*0*assert: VARoldlendesc will never be undefined or an accessor descriptor because array objects are created with a length data property that cannot be deleted or reconfigured. 
*0*let VARoldlen be VARoldlendesc.[[VALUE]]. 
*0*if VARnewlen ≥ VARoldlen, then
*1*return FUNCordinarydefineownproperty(VARa, "length", VARnewlendesc). 
*0*if VARoldlendesc.[[WRITABLE]] is false, return false. 
*0*if VARnewlendesc.[[WRITABLE]] is absent or has the value true, let VARnewwritable be true. 
*0*else,
*1*need to defer setting the [[WRITABLE]] attribute to false in case any elements cannot be deleted. 
*1*let VARnewwritable be false. 
*1*set VARnewlendesc.[[WRITABLE]] to true. 
*0*let VARsucceeded be ! FUNCordinarydefineownproperty(VARa, "length", VARnewlendesc). 
*0*if VARsucceeded is false, return false. 
*0*repeat, while VARnewlen &lt; VARoldlen,
*1*set VARoldlen to VARoldlen - 1. 
*1*let VARdeletesucceeded be ! VARa.[[DELETE]](! FUNCtostring(VARoldlen)). 
*1*if VARdeletesucceeded is false, then
*2*set VARnewlendesc.[[VALUE]] to VARoldlen + 1. 
*2*if VARnewwritable is false, set VARnewlendesc.[[WRITABLE]] to false. 
*2*perform ! FUNCordinarydefineownproperty(VARa, "length", VARnewlendesc). 
*2*return false. 
*0*if VARnewwritable is false, then
*1*return FUNCordinarydefineownproperty(VARa, "length", propertydescriptor { [[WRITABLE]]: false }). this call will always return true. 
*0*return true.     

############# END ## 207 ###########################
############# BEGIN ## 208 ###########################
ID= 9.4.3.1
Summary= [[GetOwnProperty]] ( P )
Description= When the [[GetOwnProperty]] internal method of a String exotic object S is called with property key P, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*let VARdesc be FUNCordinarygetownproperty(VARs, VARp). 
*0*if VARdesc is not undefined, return VARdesc. 
*0*return ! FUNCstringgetownproperty(VARs, VARp).     

############# END ## 208 ###########################
############# BEGIN ## 209 ###########################
ID= 9.4.3.2
Summary= [[DefineOwnProperty]] ( P, Desc )
Description= When the [[DefineOwnProperty]] internal method of a String exotic object S is called with property key P, and Property Descriptor Desc, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*let VARstringdesc be ! FUNCstringgetownproperty(VARs, VARp). 
*0*if VARstringdesc is not undefined, then
*1*let VARextensible be VARs.[[EXTENSIBLE]]. 
*1*return ! FUNCiscompatiblepropertydescriptor(VARextensible, VARdesc, VARstringdesc). 
*0*return ! FUNCordinarydefineownproperty(VARs, VARp, VARdesc).     

############# END ## 209 ###########################
############# BEGIN ## 210 ###########################
ID= 9.4.3.3
Summary= [[OwnPropertyKeys]] ( )
Description= When the [[OwnPropertyKeys]] internal method of a String exotic object O is called, the following steps are taken:
*0*let VARkeys be a new empty list. 
*0*let VARstr be the string value of VARo.[[STRINGDATA]]. 
*0*let VARlen be the length of VARstr. 
*0*for each integer VARi starting with 0 such that VARi &lt; VARlen, in ascending order, do
*1*add ! FUNCtostring(VARi) as the last element of VARkeys. 
*0*for each own property key VARp of VARo such that VARp is an integer index and FUNCtointeger(VARp) ≥ VARlen, in ascending numeric index order, do
*1*add VARp as the last element of VARkeys. 
*0*for each own property key VARp of VARo such that FUNCtype(VARp) is string and VARp is not an integer index, in ascending chronological order of property creation, do
*1*add VARp as the last element of VARkeys. 
*0*for each own property key VARp of VARo such that FUNCtype(VARp) is symbol, in ascending chronological order of property creation, do
*1*add VARp as the last element of VARkeys. 
*0*return VARkeys.     

############# END ## 210 ###########################
############# BEGIN ## 211 ###########################
ID= 9.4.3.4
Summary= StringCreate ( value, prototype )
Description= The abstract operation StringCreate with arguments value and prototype is used to specify the creation of new String exotic objects. It performs the following steps:
*0*assert: FUNCtype(VARvalue) is string. 
*0*let VARs be a newly created string exotic object. 
*0*set VARs.[[STRINGDATA]] to VARvalue. 
*0*set VARs's essential internal methods to the default ordinary object definitions specified in 9.1. 
*0*set VARs.[[GETOWNPROPERTY]] as specified in 9.4.3.1. 
*0*set VARs.[[DEFINEOWNPROPERTY]] as specified in 9.4.3.2. 
*0*set VARs.[[OWNPROPERTYKEYS]] as specified in 9.4.3.3. 
*0*set VARs.[[PROTOTYPE]] to VARprototype. 
*0*set VARs.[[EXTENSIBLE]] to true. 
*0*let VARlength be the number of code unit elements in VARvalue. 
*0*perform ! FUNCdefinepropertyorthrow(VARs, "length", propertydescriptor { [[VALUE]]: VARlength, [[WRITABLE]]: false, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }). 
*0*return VARs.     

############# END ## 211 ###########################
############# BEGIN ## 212 ###########################
ID= 9.4.3.5
Summary= StringGetOwnProperty ( S, P )
Description= The abstract operation StringGetOwnProperty called with arguments S and P performs the following steps:
*0*assert: VARs is an object that has a [[STRINGDATA]] internal slot. 
*0*assert: FUNCispropertykey(VARp) is true. 
*0*if FUNCtype(VARp) is not string, return undefined. 
*0*let VARindex be ! FUNCcanonicalnumericindexstring(VARp). 
*0*if VARindex is undefined, return undefined. 
*0*if FUNCisinteger(VARindex) is false, return undefined. 
*0*if VARindex = -0, return undefined. 
*0*let VARstr be the string value of VARs.[[STRINGDATA]]. 
*0*let VARlen be the length of VARstr. 
*0*if VARindex &lt; 0 or VARlen ≤ VARindex, return undefined. 
*0*let VARresultstr be the string value of length 1, containing one code unit from VARstr, specifically the code unit at index VARindex. 
*0*return a propertydescriptor { [[VALUE]]: VARresultstr, [[WRITABLE]]: false, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: false }.     

############# END ## 212 ###########################
############# BEGIN ## 213 ###########################
ID= 9.4.4.1
Summary= [[GetOwnProperty]] ( P )
Description= The [[GetOwnProperty]] internal method of an arguments exotic object when called with a property key P performs the following steps:
*0*let VARargs be the arguments object. 
*0*let VARdesc be FUNCordinarygetownproperty(VARargs, VARp). 
*0*if VARdesc is undefined, return VARdesc. 
*0*let VARmap be VARargs.[[PARAMETERMAP]]. 
*0*let VARismapped be ! FUNChasownproperty(VARmap, VARp). 
*0*if VARismapped is true, then
*1*set VARdesc.[[VALUE]] to FUNCget(VARmap, VARp). 
*0*return VARdesc.     

############# END ## 213 ###########################
############# BEGIN ## 214 ###########################
ID= 9.4.4.2
Summary= [[DefineOwnProperty]] ( P, Desc )
Description= The [[DefineOwnProperty]] internal method of an arguments exotic object when called with a property key P and Property Descriptor Desc performs the following steps:
*0*let VARargs be the arguments object. 
*0*let VARmap be VARargs.[[PARAMETERMAP]]. 
*0*let VARismapped be FUNChasownproperty(VARmap, VARp). 
*0*let VARnewargdesc be VARdesc. 
*0*if VARismapped is true and FUNCisdatadescriptor(VARdesc) is true, then
*1*if VARdesc.[[VALUE]] is not present and VARdesc.[[WRITABLE]] is present and its value is false, then
*2*set VARnewargdesc to a copy of VARdesc. 
*2*set VARnewargdesc.[[VALUE]] to FUNCget(VARmap, VARp). 
*0*let VARallowed be ? FUNCordinarydefineownproperty(VARargs, VARp, VARnewargdesc). 
*0*if VARallowed is false, return false. 
*0*if VARismapped is true, then
*1*if FUNCisaccessordescriptor(VARdesc) is true, then
*2*call VARmap.[[DELETE]](VARp). 
*1*else,
*2*if VARdesc.[[VALUE]] is present, then
*3*let VARsetstatus be FUNCset(VARmap, VARp, VARdesc.[[VALUE]], false). 
*3*assert: VARsetstatus is true because formal parameters mapped by argument objects are always writable. 
*2*if VARdesc.[[WRITABLE]] is present and its value is false, then
*3*call VARmap.[[DELETE]](VARp). 
*0*return true.     

############# END ## 214 ###########################
############# BEGIN ## 215 ###########################
ID= 9.4.4.3
Summary= [[Get]] ( P, Receiver )
Description= The [[Get]] internal method of an arguments exotic object when called with a property key P and ECMAScript language value Receiver performs the following steps:
*0*let VARargs be the arguments object. 
*0*let VARmap be VARargs.[[PARAMETERMAP]]. 
*0*let VARismapped be ! FUNChasownproperty(VARmap, VARp). 
*0*if VARismapped is false, then
*1*return ? FUNCordinaryget(VARargs, VARp, VARreceiver). 
*0*else VARmap contains a formal parameter mapping for VARp,
*1*return FUNCget(VARmap, VARp).     

############# END ## 215 ###########################
############# BEGIN ## 216 ###########################
ID= 9.4.4.4
Summary= [[Set]] ( P, V, Receiver )
Description= The [[Set]] internal method of an arguments exotic object when called with property key P, value V, and ECMAScript language value Receiver performs the following steps:
*0*let VARargs be the arguments object. 
*0*if FUNCsamevalue(VARargs, VARreceiver) is false, then
*1*let VARismapped be false. 
*0*else,
*1*let VARmap be VARargs.[[PARAMETERMAP]]. 
*1*let VARismapped be ! FUNChasownproperty(VARmap, VARp). 
*0*if VARismapped is true, then
*1*let VARsetstatus be FUNCset(VARmap, VARp, VARv, false). 
*1*assert: VARsetstatus is true because formal parameters mapped by argument objects are always writable. 
*0*return ? FUNCordinaryset(VARargs, VARp, VARv, VARreceiver).     

############# END ## 216 ###########################
############# BEGIN ## 217 ###########################
ID= 9.4.4.5
Summary= [[Delete]] ( P )
Description= The [[Delete]] internal method of an arguments exotic object when called with a property key P performs the following steps:
*0*let VARargs be the arguments object. 
*0*let VARmap be VARargs.[[PARAMETERMAP]]. 
*0*let VARismapped be ! FUNChasownproperty(VARmap, VARp). 
*0*let VARresult be ? FUNCordinarydelete(VARargs, VARp). 
*0*if VARresult is true and VARismapped is true, then
*1*call VARmap.[[DELETE]](VARp). 
*0*return VARresult.     

############# END ## 217 ###########################
############# BEGIN ## 218 ###########################
ID= 9.4.4.6
Summary= CreateUnmappedArgumentsObject ( argumentsList )
Description= The abstract operation CreateUnmappedArgumentsObject called with an argument argumentsList performs the following steps:
*0*let VARlen be the number of elements in VARargumentslist. 
*0*let VARobj be FUNCobjectcreate(%objectprototype%, « [[PARAMETERMAP]] »). 
*0*set VARobj.[[PARAMETERMAP]] to undefined. 
*0*perform FUNCdefinepropertyorthrow(VARobj, "length", propertydescriptor { [[VALUE]]: VARlen, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }). 
*0*let VARindex be 0. 
*0*repeat, while VARindex &lt; VARlen,
*1*let VARval be VARargumentslist[VARindex]. 
*1*perform FUNCcreatedataproperty(VARobj, ! FUNCtostring(VARindex), VARval). 
*1*let VARindex be VARindex + 1. 
*0*perform ! FUNCdefinepropertyorthrow(VARobj, @@iterator, propertydescriptor { [[VALUE]]: %arrayproto_values%, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }). 
*0*perform ! FUNCdefinepropertyorthrow(VARobj, "callee", propertydescriptor { [[GET]]: %throwtypeerror%, [[SET]]: %throwtypeerror%, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }). 
*0*return VARobj.     

############# END ## 218 ###########################
############# BEGIN ## 219 ###########################
ID= 9.4.4.7
Summary= CreateMappedArgumentsObject ( func, formals, argumentsList, env )
Description= The abstract operation CreateMappedArgumentsObject is called with object func, Parse Node formals, List argumentsList, and Environment Record env. The following steps are performed:
*0*assert: VARformals does not contain a rest parameter, any binding patterns, or any initializers. it may contain duplicate identifiers. 
*0*let VARlen be the number of elements in VARargumentslist. 
*0*let VARobj be a newly created arguments exotic object with a [[PARAMETERMAP]] internal slot. 
*0*set VARobj.[[GETOWNPROPERTY]] as specified in 9.4.4.1. 
*0*set VARobj.[[DEFINEOWNPROPERTY]] as specified in 9.4.4.2. 
*0*set VARobj.[[GET]] as specified in 9.4.4.3. 
*0*set VARobj.[[SET]] as specified in 9.4.4.4. 
*0*set VARobj.[[DELETE]] as specified in 9.4.4.5. 
*0*set the remainder of VARobj's essential internal methods to the default ordinary object definitions specified in 9.1. 
*0*set VARobj.[[PROTOTYPE]] to %objectprototype%. 
*0*set VARobj.[[EXTENSIBLE]] to true. 
*0*let VARmap be FUNCobjectcreate(null). 
*0*set VARobj.[[PARAMETERMAP]] to VARmap. 
*0*let VARparameternames be the boundnames of VARformals. 
*0*let VARnumberofparameters be the number of elements in VARparameternames. 
*0*let VARindex be 0. 
*0*repeat, while VARindex &lt; VARlen,
*1*let VARval be VARargumentslist[VARindex]. 
*1*perform FUNCcreatedataproperty(VARobj, ! FUNCtostring(VARindex), VARval). 
*1*let VARindex be VARindex + 1. 
*0*perform FUNCdefinepropertyorthrow(VARobj, "length", propertydescriptor { [[VALUE]]: VARlen, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }). 
*0*let VARmappednames be a new empty list. 
*0*let VARindex be VARnumberofparameters - 1. 
*0*repeat, while VARindex ≥ 0,
*1*let VARname be VARparameternames[VARindex]. 
*1*if VARname is not an element of VARmappednames, then
*2*add VARname as an element of the list VARmappednames. 
*2*if VARindex &lt; VARlen, then
*3*let VARg be FUNCmakearggetter(VARname, VARenv). 
*3*let VARp be FUNCmakeargsetter(VARname, VARenv). 
*3*perform VARmap.[[DEFINEOWNPROPERTY]](! FUNCtostring(VARindex), propertydescriptor { [[SET]]: VARp, [[GET]]: VARg, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }). 
*1*let VARindex be VARindex - 1. 
*0*perform ! FUNCdefinepropertyorthrow(VARobj, @@iterator, propertydescriptor { [[VALUE]]: %arrayproto_values%, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }). 
*0*perform ! FUNCdefinepropertyorthrow(VARobj, "callee", propertydescriptor { [[VALUE]]: VARfunc, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }). 
*0*return VARobj.     

############# END ## 219 ###########################
############# BEGIN ## 220 ###########################
ID= 9.4.4.7.1
Summary= MakeArgGetter ( name, env )
Description= The abstract operation MakeArgGetter called with String name and Environment Record env creates a built-in function object that when executed returns the value bound for name in env. It performs the following steps:
*0*let VARsteps be the steps of an arggetter function as specified below. 
*0*let VARgetter be FUNCcreatebuiltinfunction(VARsteps, « [[NAME]], [[ENV]] »). 
*0*set VARgetter.[[NAME]] to VARname. 
*0*set VARgetter.[[ENV]] to VARenv. 
*0*return VARgetter.      

############# END ## 220 ###########################
############# BEGIN ## 221 ###########################
ID= 9.4.4.7.2
Summary= MakeArgSetter ( name, env )
Description= The abstract operation MakeArgSetter called with String name and Environment Record env creates a built-in function object that when executed sets the value bound for name in env. It performs the following steps:
*0*let VARsteps be the steps of an argsetter function as specified below. 
*0*let VARsetter be FUNCcreatebuiltinfunction(VARsteps, « [[NAME]], [[ENV]] »). 
*0*set VARsetter.[[NAME]] to VARname. 
*0*set VARsetter.[[ENV]] to VARenv. 
*0*return VARsetter.      

############# END ## 221 ###########################
############# BEGIN ## 222 ###########################
ID= 9.4.5.1
Summary= [[GetOwnProperty]] ( P )
Description= When the [[GetOwnProperty]] internal method of an Integer-Indexed exotic object O is called with property key P, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*assert: VARo is an object that has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*if FUNCtype(VARp) is string, then
*1*let VARnumericindex be ! FUNCcanonicalnumericindexstring(VARp). 
*1*if VARnumericindex is not undefined, then
*2*let VARvalue be ? FUNCintegerindexedelementget(VARo, VARnumericindex). 
*2*if VARvalue is undefined, return undefined. 
*2*return a propertydescriptor { [[VALUE]]: VARvalue, [[WRITABLE]]: true, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: false }. 
*0*return FUNCordinarygetownproperty(VARo, VARp).     

############# END ## 222 ###########################
############# BEGIN ## 223 ###########################
ID= 9.4.5.2
Summary= [[HasProperty]] ( P )
Description= When the [[HasProperty]] internal method of an Integer-Indexed exotic object O is called with property key P, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*assert: VARo is an object that has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*if FUNCtype(VARp) is string, then
*1*let VARnumericindex be ! FUNCcanonicalnumericindexstring(VARp). 
*1*if VARnumericindex is not undefined, then
*2*let VARbuffer be VARo.[[VIEWEDARRAYBUFFER]]. 
*2*if FUNCisdetachedbuffer(VARbuffer) is true, throw a typeerror exception. 
*2*if FUNCisinteger(VARnumericindex) is false, return false. 
*2*if VARnumericindex = -0, return false. 
*2*if VARnumericindex &lt; 0, return false. 
*2*if VARnumericindex ≥ VARo.[[ARRAYLENGTH]], return false. 
*2*return true. 
*0*return ? FUNCordinaryhasproperty(VARo, VARp).     

############# END ## 223 ###########################
############# BEGIN ## 224 ###########################
ID= 9.4.5.3
Summary= [[DefineOwnProperty]] ( P, Desc )
Description= When the [[DefineOwnProperty]] internal method of an Integer-Indexed exotic object O is called with property key P, and Property Descriptor Desc, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*assert: VARo is an object that has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*if FUNCtype(VARp) is string, then
*1*let VARnumericindex be ! FUNCcanonicalnumericindexstring(VARp). 
*1*if VARnumericindex is not undefined, then
*2*if FUNCisinteger(VARnumericindex) is false, return false. 
*2*if VARnumericindex = -0, return false. 
*2*if VARnumericindex &lt; 0, return false. 
*2*let VARlength be VARo.[[ARRAYLENGTH]]. 
*2*if VARnumericindex ≥ VARlength, return false. 
*2*if FUNCisaccessordescriptor(VARdesc) is true, return false. 
*2*if VARdesc has a [[CONFIGURABLE]] field and if VARdesc.[[CONFIGURABLE]] is true, return false. 
*2*if VARdesc has an [[ENUMERABLE]] field and if VARdesc.[[ENUMERABLE]] is false, return false. 
*2*if VARdesc has a [[WRITABLE]] field and if VARdesc.[[WRITABLE]] is false, return false. 
*2*if VARdesc has a [[VALUE]] field, then
*3*let VARvalue be VARdesc.[[VALUE]]. 
*3*return ? FUNCintegerindexedelementset(VARo, VARnumericindex, VARvalue). 
*2*return true. 
*0*return ! FUNCordinarydefineownproperty(VARo, VARp, VARdesc).     

############# END ## 224 ###########################
############# BEGIN ## 225 ###########################
ID= 9.4.5.4
Summary= [[Get]] ( P, Receiver )
Description= When the [[Get]] internal method of an Integer-Indexed exotic object O is called with property key P and ECMAScript language value Receiver, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*if FUNCtype(VARp) is string, then
*1*let VARnumericindex be ! FUNCcanonicalnumericindexstring(VARp). 
*1*if VARnumericindex is not undefined, then
*2*return ? FUNCintegerindexedelementget(VARo, VARnumericindex). 
*0*return ? FUNCordinaryget(VARo, VARp, VARreceiver).     

############# END ## 225 ###########################
############# BEGIN ## 226 ###########################
ID= 9.4.5.5
Summary= [[Set]] ( P, V, Receiver )
Description= When the [[Set]] internal method of an Integer-Indexed exotic object O is called with property key P, value V, and ECMAScript language value Receiver, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*if FUNCtype(VARp) is string, then
*1*let VARnumericindex be ! FUNCcanonicalnumericindexstring(VARp). 
*1*if VARnumericindex is not undefined, then
*2*return ? FUNCintegerindexedelementset(VARo, VARnumericindex, VARv). 
*0*return ? FUNCordinaryset(VARo, VARp, VARv, VARreceiver).     

############# END ## 226 ###########################
############# BEGIN ## 227 ###########################
ID= 9.4.5.6
Summary= [[OwnPropertyKeys]] ( )
Description= When the [[OwnPropertyKeys]] internal method of an Integer-Indexed exotic object O is called, the following steps are taken:
*0*let VARkeys be a new empty list. 
*0*assert: VARo is an object that has [[VIEWEDARRAYBUFFER]], [[ARRAYLENGTH]], [[BYTEOFFSET]], and [[TYPEDARRAYNAME]] internal slots. 
*0*let VARlen be VARo.[[ARRAYLENGTH]]. 
*0*for each integer VARi starting with 0 such that VARi &lt; VARlen, in ascending order, do
*1*add ! FUNCtostring(VARi) as the last element of VARkeys. 
*0*for each own property key VARp of VARo such that FUNCtype(VARp) is string and VARp is not an integer index, in ascending chronological order of property creation, do
*1*add VARp as the last element of VARkeys. 
*0*for each own property key VARp of VARo such that FUNCtype(VARp) is symbol, in ascending chronological order of property creation, do
*1*add VARp as the last element of VARkeys. 
*0*return VARkeys.     

############# END ## 227 ###########################
############# BEGIN ## 228 ###########################
ID= 9.4.5.7
Summary= IntegerIndexedObjectCreate ( prototype, internalSlotsList )
Description= The abstract operation IntegerIndexedObjectCreate with arguments prototype and internalSlotsList is used to specify the creation of new  Integer-Indexed exotic objects. The argument internalSlotsList is a List of the names of additional internal slots that must be defined as part of the object. IntegerIndexedObjectCreate performs the following steps:
*0*assert: VARinternalslotslist contains the names [[VIEWEDARRAYBUFFER]], [[ARRAYLENGTH]], [[BYTEOFFSET]], and [[TYPEDARRAYNAME]]. 
*0*let VARa be a newly created object with an internal slot for each name in VARinternalslotslist. 
*0*set VARa's essential internal methods to the default ordinary object definitions specified in 9.1. 
*0*set VARa.[[GETOWNPROPERTY]] as specified in 9.4.5.1. 
*0*set VARa.[[HASPROPERTY]] as specified in 9.4.5.2. 
*0*set VARa.[[DEFINEOWNPROPERTY]] as specified in 9.4.5.3. 
*0*set VARa.[[GET]] as specified in 9.4.5.4. 
*0*set VARa.[[SET]] as specified in 9.4.5.5. 
*0*set VARa.[[OWNPROPERTYKEYS]] as specified in 9.4.5.6. 
*0*set VARa.[[PROTOTYPE]] to VARprototype. 
*0*set VARa.[[EXTENSIBLE]] to true. 
*0*return VARa.     

############# END ## 228 ###########################
############# BEGIN ## 229 ###########################
ID= 9.4.5.8
Summary= IntegerIndexedElementGet ( O, index )
Description= The abstract operation IntegerIndexedElementGet with arguments O and index performs the following steps:
*0*assert: FUNCtype(VARindex) is number. 
*0*assert: VARo is an object that has [[VIEWEDARRAYBUFFER]], [[ARRAYLENGTH]], [[BYTEOFFSET]], and [[TYPEDARRAYNAME]] internal slots. 
*0*let VARbuffer be VARo.[[VIEWEDARRAYBUFFER]]. 
*0*if FUNCisdetachedbuffer(VARbuffer) is true, throw a typeerror exception. 
*0*if FUNCisinteger(VARindex) is false, return undefined. 
*0*if VARindex = -0, return undefined. 
*0*let VARlength be VARo.[[ARRAYLENGTH]]. 
*0*if VARindex &lt; 0 or VARindex ≥ VARlength, return undefined. 
*0*let VARoffset be VARo.[[BYTEOFFSET]]. 
*0*let VARarraytypename be the string value of VARo.[[TYPEDARRAYNAME]]. 
*0*let VARelementsize be the number value of the element size value specified in table 56 for VARarraytypename. 
*0*let VARindexedposition be (VARindex × VARelementsize) + VARoffset. 
*0*let VARelementtype be the string value of the element type value in table 56 for VARarraytypename. 
*0*return FUNCgetvaluefrombuffer(VARbuffer, VARindexedposition, VARelementtype, true, "unordered").     

############# END ## 229 ###########################
############# BEGIN ## 230 ###########################
ID= 9.4.5.9
Summary= IntegerIndexedElementSet ( O, index, value )
Description= The abstract operation IntegerIndexedElementSet with arguments O, index, and value performs the following steps:
*0*assert: FUNCtype(VARindex) is number. 
*0*assert: VARo is an object that has [[VIEWEDARRAYBUFFER]], [[ARRAYLENGTH]], [[BYTEOFFSET]], and [[TYPEDARRAYNAME]] internal slots. 
*0*let VARnumvalue be ? FUNCtonumber(VARvalue). 
*0*let VARbuffer be VARo.[[VIEWEDARRAYBUFFER]]. 
*0*if FUNCisdetachedbuffer(VARbuffer) is true, throw a typeerror exception. 
*0*if FUNCisinteger(VARindex) is false, return false. 
*0*if VARindex = -0, return false. 
*0*let VARlength be VARo.[[ARRAYLENGTH]]. 
*0*if VARindex &lt; 0 or VARindex ≥ VARlength, return false. 
*0*let VARoffset be VARo.[[BYTEOFFSET]]. 
*0*let VARarraytypename be the string value of VARo.[[TYPEDARRAYNAME]]. 
*0*let VARelementsize be the number value of the element size value specified in table 56 for VARarraytypename. 
*0*let VARindexedposition be (VARindex × VARelementsize) + VARoffset. 
*0*let VARelementtype be the string value of the element type value in table 56 for VARarraytypename. 
*0*perform FUNCsetvalueinbuffer(VARbuffer, VARindexedposition, VARelementtype, VARnumvalue, true, "unordered"). 
*0*return true.     

############# END ## 230 ###########################
############# BEGIN ## 231 ###########################
ID= 9.4.6.1
Summary= [[SetPrototypeOf]] ( V )
Description= When the [[SetPrototypeOf]] internal method of a module namespace exotic object O is called with argument V, the following steps are taken:
*0*return ? FUNCsetimmutableprototype(VARo, VARv).     

############# END ## 231 ###########################
############# BEGIN ## 232 ###########################
ID= 9.4.6.2
Summary= [[IsExtensible]] ( )
Description= When the [[IsExtensible]] internal method of a module namespace exotic object O is called, the following steps are taken:
*0*return false.     

############# END ## 232 ###########################
############# BEGIN ## 233 ###########################
ID= 9.4.6.3
Summary= [[PreventExtensions]] ( )
Description= When the [[PreventExtensions]] internal method of a module namespace exotic object O is called, the following steps are taken:
*0*return true.     

############# END ## 233 ###########################
############# BEGIN ## 234 ###########################
ID= 9.4.6.4
Summary= [[GetOwnProperty]] ( P )
Description= When the [[GetOwnProperty]] internal method of a module namespace exotic object O is called with property key P, the following steps are taken:
*0*if FUNCtype(VARp) is symbol, return FUNCordinarygetownproperty(VARo, VARp). 
*0*let VARexports be VARo.[[EXPORTS]]. 
*0*if VARp is not an element of VARexports, return undefined. 
*0*let VARvalue be ? VARo.[[GET]](VARp, VARo). 
*0*return propertydescriptor { [[VALUE]]: VARvalue, [[WRITABLE]]: true, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: false }.     

############# END ## 234 ###########################
############# BEGIN ## 235 ###########################
ID= 9.4.6.5
Summary= [[DefineOwnProperty]] ( P, Desc )
Description= When the [[DefineOwnProperty]] internal method of a module namespace exotic object O is called with property key P and Property Descriptor Desc, the following steps are taken:
*0*return false.     

############# END ## 235 ###########################
############# BEGIN ## 236 ###########################
ID= 9.4.6.6
Summary= [[HasProperty]] ( P )
Description= When the [[HasProperty]] internal method of a module namespace exotic object O is called with property key P, the following steps are taken:
*0*if FUNCtype(VARp) is symbol, return FUNCordinaryhasproperty(VARo, VARp). 
*0*let VARexports be VARo.[[EXPORTS]]. 
*0*if VARp is an element of VARexports, return true. 
*0*return false.     

############# END ## 236 ###########################
############# BEGIN ## 237 ###########################
ID= 9.4.6.7
Summary= [[Get]] ( P, Receiver )
Description= When the [[Get]] internal method of a module namespace exotic object O is called with property key P and ECMAScript language value Receiver, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*if FUNCtype(VARp) is symbol, then
*1*return ? FUNCordinaryget(VARo, VARp, VARreceiver). 
*0*let VARexports be VARo.[[EXPORTS]]. 
*0*if VARp is not an element of VARexports, return undefined. 
*0*let VARm be VARo.[[MODULE]]. 
*0*let VARbinding be ! VARm.resolveexport(VARp, « »). 
*0*assert: VARbinding is a resolvedbinding record. 
*0*let VARtargetmodule be VARbinding.[[MODULE]]. 
*0*assert: VARtargetmodule is not undefined. 
*0*let VARtargetenv be VARtargetmodule.[[ENVIRONMENT]]. 
*0*if VARtargetenv is undefined, throw a referenceerror exception. 
*0*let VARtargetenvrec be VARtargetenv's environmentrecord. 
*0*return ? VARtargetenvrec.getbindingvalue(VARbinding.[[BINDINGNAME]], true).     

############# END ## 237 ###########################
############# BEGIN ## 238 ###########################
ID= 9.4.6.8
Summary= [[Set]] ( P, V, Receiver )
Description= When the [[Set]] internal method of a module namespace exotic object O is called with property key P, value V, and ECMAScript language value Receiver, the following steps are taken:
*0*return false.     

############# END ## 238 ###########################
############# BEGIN ## 239 ###########################
ID= 9.4.6.9
Summary= [[Delete]] ( P )
Description= When the [[Delete]] internal method of a module namespace exotic object O is called with property key P, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*if FUNCtype(VARp) is symbol, then
*1*return ? FUNCordinarydelete(VARo, VARp). 
*0*let VARexports be VARo.[[EXPORTS]]. 
*0*if VARp is an element of VARexports, return false. 
*0*return true.     

############# END ## 239 ###########################
############# BEGIN ## 240 ###########################
ID= 9.4.6.10
Summary= [[OwnPropertyKeys]] ( )
Description= When the [[OwnPropertyKeys]] internal method of a module namespace exotic object O is called, the following steps are taken:
*0*let VARexports be a copy of VARo.[[EXPORTS]]. 
*0*let VARsymbolkeys be ! FUNCordinaryownpropertykeys(VARo). 
*0*append all the entries of VARsymbolkeys to the end of VARexports. 
*0*return VARexports.     

############# END ## 240 ###########################
############# BEGIN ## 241 ###########################
ID= 9.4.6.11
Summary= ModuleNamespaceCreate ( module, exports )
Description= The abstract operation ModuleNamespaceCreate with arguments module, and exports is used to specify the creation of new module namespace exotic objects. It performs the following steps:
*0*assert: VARmodule is a module record. 
*0*assert: VARmodule.[[NAMESPACE]] is undefined. 
*0*assert: VARexports is a list of string values. 
*0*let VARm be a newly created object. 
*0*set VARm's essential internal methods to the definitions specified in 9.4.6. 
*0*set VARm.[[MODULE]] to VARmodule. 
*0*let VARsortedexports be a new list containing the same values as the list VARexports where the values are ordered as if an array of the same values had been sorted using array.prototype.sort using undefined as VARcomparefn. 
*0*set VARm.[[EXPORTS]] to VARsortedexports. 
*0*create own properties of VARm corresponding to the definitions in 26.3. 
*0*set VARmodule.[[NAMESPACE]] to VARm. 
*0*return VARm.     

############# END ## 241 ###########################
############# BEGIN ## 242 ###########################
ID= 9.4.7.1
Summary= [[SetPrototypeOf]] ( V )
Description= When the [[SetPrototypeOf]] internal method of an immutable prototype exotic object O is called with argument V, the following steps are taken:
*0*return ? FUNCsetimmutableprototype(VARo, VARv).     

############# END ## 242 ###########################
############# BEGIN ## 243 ###########################
ID= 9.4.7.2
Summary= SetImmutablePrototype ( O, V )
Description= When the SetImmutablePrototype abstract operation is called with arguments O and V, the following steps are taken:
*0*assert: either FUNCtype(VARv) is object or FUNCtype(VARv) is null. 
*0*let VARcurrent be ? VARo.[[GETPROTOTYPEOF]](). 
*0*if FUNCsamevalue(VARv, VARcurrent) is true, return true. 
*0*return false.     

############# END ## 243 ###########################
############# BEGIN ## 244 ###########################
ID= 9.5.1
Summary= [[GetPrototypeOf]] ( )
Description= When the [[GetPrototypeOf]] internal method of a Proxy exotic object O is called, the following steps are taken:
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*if VARhandler is null, throw a typeerror exception. 
*0*assert: FUNCtype(VARhandler) is object. 
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "getprototypeof"). 
*0*if VARtrap is undefined, then
*1*return ? VARtarget.[[GETPROTOTYPEOF]](). 
*0*let VARhandlerproto be ? FUNCcall(VARtrap, VARhandler, « VARtarget »). 
*0*if FUNCtype(VARhandlerproto) is neither object nor null, throw a typeerror exception. 
*0*let VARextensibletarget be ? FUNCisextensible(VARtarget). 
*0*if VARextensibletarget is true, return VARhandlerproto. 
*0*let VARtargetproto be ? VARtarget.[[GETPROTOTYPEOF]](). 
*0*if FUNCsamevalue(VARhandlerproto, VARtargetproto) is false, throw a typeerror exception. 
*0*return VARhandlerproto.    

############# END ## 244 ###########################
############# BEGIN ## 245 ###########################
ID= 9.5.2
Summary= [[SetPrototypeOf]] ( V )
Description= When the [[SetPrototypeOf]] internal method of a Proxy exotic object O is called with argument V, the following steps are taken:
*0*assert: either FUNCtype(VARv) is object or FUNCtype(VARv) is null. 
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*if VARhandler is null, throw a typeerror exception. 
*0*assert: FUNCtype(VARhandler) is object. 
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "setprototypeof"). 
*0*if VARtrap is undefined, then
*1*return ? VARtarget.[[SETPROTOTYPEOF]](VARv). 
*0*let VARbooleantrapresult be FUNCtoboolean(? FUNCcall(VARtrap, VARhandler, « VARtarget, VARv »)). 
*0*if VARbooleantrapresult is false, return false. 
*0*let VARextensibletarget be ? FUNCisextensible(VARtarget). 
*0*if VARextensibletarget is true, return true. 
*0*let VARtargetproto be ? VARtarget.[[GETPROTOTYPEOF]](). 
*0*if FUNCsamevalue(VARv, VARtargetproto) is false, throw a typeerror exception. 
*0*return true.    

############# END ## 245 ###########################
############# BEGIN ## 246 ###########################
ID= 9.5.3
Summary= [[IsExtensible]] ( )
Description= When the [[IsExtensible]] internal method of a Proxy exotic object O is called, the following steps are taken:
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*if VARhandler is null, throw a typeerror exception. 
*0*assert: FUNCtype(VARhandler) is object. 
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "isextensible"). 
*0*if VARtrap is undefined, then
*1*return ? VARtarget.[[ISEXTENSIBLE]](). 
*0*let VARbooleantrapresult be FUNCtoboolean(? FUNCcall(VARtrap, VARhandler, « VARtarget »)). 
*0*let VARtargetresult be ? VARtarget.[[ISEXTENSIBLE]](). 
*0*if FUNCsamevalue(VARbooleantrapresult, VARtargetresult) is false, throw a typeerror exception. 
*0*return VARbooleantrapresult.    

############# END ## 246 ###########################
############# BEGIN ## 247 ###########################
ID= 9.5.4
Summary= [[PreventExtensions]] ( )
Description= When the [[PreventExtensions]] internal method of a Proxy exotic object O is called, the following steps are taken:
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*if VARhandler is null, throw a typeerror exception. 
*0*assert: FUNCtype(VARhandler) is object. 
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "preventextensions"). 
*0*if VARtrap is undefined, then
*1*return ? VARtarget.[[PREVENTEXTENSIONS]](). 
*0*let VARbooleantrapresult be FUNCtoboolean(? FUNCcall(VARtrap, VARhandler, « VARtarget »)). 
*0*if VARbooleantrapresult is true, then
*1*let VARtargetisextensible be ? VARtarget.[[ISEXTENSIBLE]](). 
*1*if VARtargetisextensible is true, throw a typeerror exception. 
*0*return VARbooleantrapresult.    

############# END ## 247 ###########################
############# BEGIN ## 248 ###########################
ID= 9.5.5
Summary= [[GetOwnProperty]] ( P )
Description= When the [[GetOwnProperty]] internal method of a Proxy exotic object O is called with property key P, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*if VARhandler is null, throw a typeerror exception. 
*0*assert: FUNCtype(VARhandler) is object. 
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "getownpropertydescriptor"). 
*0*if VARtrap is undefined, then
*1*return ? VARtarget.[[GETOWNPROPERTY]](VARp). 
*0*let VARtrapresultobj be ? FUNCcall(VARtrap, VARhandler, « VARtarget, VARp »). 
*0*if FUNCtype(VARtrapresultobj) is neither object nor undefined, throw a typeerror exception. 
*0*let VARtargetdesc be ? VARtarget.[[GETOWNPROPERTY]](VARp). 
*0*if VARtrapresultobj is undefined, then
*1*if VARtargetdesc is undefined, return undefined. 
*1*if VARtargetdesc.[[CONFIGURABLE]] is false, throw a typeerror exception. 
*1*let VARextensibletarget be ? FUNCisextensible(VARtarget). 
*1*assert: FUNCtype(VARextensibletarget) is boolean. 
*1*if VARextensibletarget is false, throw a typeerror exception. 
*1*return undefined. 
*0*let VARextensibletarget be ? FUNCisextensible(VARtarget). 
*0*let VARresultdesc be ? FUNCtopropertydescriptor(VARtrapresultobj). 
*0*call FUNCcompletepropertydescriptor(VARresultdesc). 
*0*let VARvalid be FUNCiscompatiblepropertydescriptor(VARextensibletarget, VARresultdesc, VARtargetdesc). 
*0*if VARvalid is false, throw a typeerror exception. 
*0*if VARresultdesc.[[CONFIGURABLE]] is false, then
*1*if VARtargetdesc is undefined or VARtargetdesc.[[CONFIGURABLE]] is true, then
*2*throw a typeerror exception. 
*0*return VARresultdesc.    

############# END ## 248 ###########################
############# BEGIN ## 249 ###########################
ID= 9.5.6
Summary= [[DefineOwnProperty]] ( P, Desc )
Description= When the [[DefineOwnProperty]] internal method of a Proxy exotic object O is called with property key P and Property Descriptor Desc, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*if VARhandler is null, throw a typeerror exception. 
*0*assert: FUNCtype(VARhandler) is object. 
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "defineproperty"). 
*0*if VARtrap is undefined, then
*1*return ? VARtarget.[[DEFINEOWNPROPERTY]](VARp, VARdesc). 
*0*let VARdescobj be FUNCfrompropertydescriptor(VARdesc). 
*0*let VARbooleantrapresult be FUNCtoboolean(? FUNCcall(VARtrap, VARhandler, « VARtarget, VARp, VARdescobj »)). 
*0*if VARbooleantrapresult is false, return false. 
*0*let VARtargetdesc be ? VARtarget.[[GETOWNPROPERTY]](VARp). 
*0*let VARextensibletarget be ? FUNCisextensible(VARtarget). 
*0*if VARdesc has a [[CONFIGURABLE]] field and if VARdesc.[[CONFIGURABLE]] is false, then
*1*let VARsettingconfigfalse be true. 
*0*else, let VARsettingconfigfalse be false. 
*0*if VARtargetdesc is undefined, then
*1*if VARextensibletarget is false, throw a typeerror exception. 
*1*if VARsettingconfigfalse is true, throw a typeerror exception. 
*0*else VARtargetdesc is not undefined,
*1*if FUNCiscompatiblepropertydescriptor(VARextensibletarget, VARdesc, VARtargetdesc) is false, throw a typeerror exception. 
*1*if VARsettingconfigfalse is true and VARtargetdesc.[[CONFIGURABLE]] is true, throw a typeerror exception. 
*0*return true.    

############# END ## 249 ###########################
############# BEGIN ## 250 ###########################
ID= 9.5.7
Summary= [[HasProperty]] ( P )
Description= When the [[HasProperty]] internal method of a Proxy exotic object O is called with property key P, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*if VARhandler is null, throw a typeerror exception. 
*0*assert: FUNCtype(VARhandler) is object. 
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "has"). 
*0*if VARtrap is undefined, then
*1*return ? VARtarget.[[HASPROPERTY]](VARp). 
*0*let VARbooleantrapresult be FUNCtoboolean(? FUNCcall(VARtrap, VARhandler, « VARtarget, VARp »)). 
*0*if VARbooleantrapresult is false, then
*1*let VARtargetdesc be ? VARtarget.[[GETOWNPROPERTY]](VARp). 
*1*if VARtargetdesc is not undefined, then
*2*if VARtargetdesc.[[CONFIGURABLE]] is false, throw a typeerror exception. 
*2*let VARextensibletarget be ? FUNCisextensible(VARtarget). 
*2*if VARextensibletarget is false, throw a typeerror exception. 
*0*return VARbooleantrapresult.    

############# END ## 250 ###########################
############# BEGIN ## 251 ###########################
ID= 9.5.8
Summary= [[Get]] ( P, Receiver )
Description= When the [[Get]] internal method of a Proxy exotic object O is called with property key P and ECMAScript language value Receiver, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*if VARhandler is null, throw a typeerror exception. 
*0*assert: FUNCtype(VARhandler) is object. 
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "get"). 
*0*if VARtrap is undefined, then
*1*return ? VARtarget.[[GET]](VARp, VARreceiver). 
*0*let VARtrapresult be ? FUNCcall(VARtrap, VARhandler, « VARtarget, VARp, VARreceiver »). 
*0*let VARtargetdesc be ? VARtarget.[[GETOWNPROPERTY]](VARp). 
*0*if VARtargetdesc is not undefined and VARtargetdesc.[[CONFIGURABLE]] is false, then
*1*if FUNCisdatadescriptor(VARtargetdesc) is true and VARtargetdesc.[[WRITABLE]] is false, then
*2*if FUNCsamevalue(VARtrapresult, VARtargetdesc.[[VALUE]]) is false, throw a typeerror exception. 
*1*if FUNCisaccessordescriptor(VARtargetdesc) is true and VARtargetdesc.[[GET]] is undefined, then
*2*if VARtrapresult is not undefined, throw a typeerror exception. 
*0*return VARtrapresult.    

############# END ## 251 ###########################
############# BEGIN ## 252 ###########################
ID= 9.5.9
Summary= [[Set]] ( P, V, Receiver )
Description= When the [[Set]] internal method of a Proxy exotic object O is called with property key P, value V, and ECMAScript language value Receiver, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*if VARhandler is null, throw a typeerror exception. 
*0*assert: FUNCtype(VARhandler) is object. 
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "set"). 
*0*if VARtrap is undefined, then
*1*return ? VARtarget.[[SET]](VARp, VARv, VARreceiver). 
*0*let VARbooleantrapresult be FUNCtoboolean(? FUNCcall(VARtrap, VARhandler, « VARtarget, VARp, VARv, VARreceiver »)). 
*0*if VARbooleantrapresult is false, return false. 
*0*let VARtargetdesc be ? VARtarget.[[GETOWNPROPERTY]](VARp). 
*0*if VARtargetdesc is not undefined and VARtargetdesc.[[CONFIGURABLE]] is false, then
*1*if FUNCisdatadescriptor(VARtargetdesc) is true and VARtargetdesc.[[WRITABLE]] is false, then
*2*if FUNCsamevalue(VARv, VARtargetdesc.[[VALUE]]) is false, throw a typeerror exception. 
*1*if FUNCisaccessordescriptor(VARtargetdesc) is true, then
*2*if VARtargetdesc.[[SET]] is undefined, throw a typeerror exception. 
*0*return true.    

############# END ## 252 ###########################
############# BEGIN ## 253 ###########################
ID= 9.5.10
Summary= [[Delete]] ( P )
Description= When the [[Delete]] internal method of a Proxy exotic object O is called with property key P, the following steps are taken:
*0*assert: FUNCispropertykey(VARp) is true. 
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*if VARhandler is null, throw a typeerror exception. 
*0*assert: FUNCtype(VARhandler) is object. 
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "deleteproperty"). 
*0*if VARtrap is undefined, then
*1*return ? VARtarget.[[DELETE]](VARp). 
*0*let VARbooleantrapresult be FUNCtoboolean(? FUNCcall(VARtrap, VARhandler, « VARtarget, VARp »)). 
*0*if VARbooleantrapresult is false, return false. 
*0*let VARtargetdesc be ? VARtarget.[[GETOWNPROPERTY]](VARp). 
*0*if VARtargetdesc is undefined, return true. 
*0*if VARtargetdesc.[[CONFIGURABLE]] is false, throw a typeerror exception. 
*0*return true.    

############# END ## 253 ###########################
############# BEGIN ## 254 ###########################
ID= 9.5.11
Summary= [[OwnPropertyKeys]] ( )
Description= When the [[OwnPropertyKeys]] internal method of a Proxy exotic object O is called, the following steps are taken:
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*if VARhandler is null, throw a typeerror exception. 
*0*assert: FUNCtype(VARhandler) is object. 
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "ownkeys"). 
*0*if VARtrap is undefined, then
*1*return ? VARtarget.[[OWNPROPERTYKEYS]](). 
*0*let VARtrapresultarray be ? FUNCcall(VARtrap, VARhandler, « VARtarget »). 
*0*let VARtrapresult be ? FUNCcreatelistfromarraylike(VARtrapresultarray, « string, symbol »). 
*0*if VARtrapresult contains any duplicate entries, throw a typeerror exception. 
*0*let VARextensibletarget be ? FUNCisextensible(VARtarget). 
*0*let VARtargetkeys be ? VARtarget.[[OWNPROPERTYKEYS]](). 
*0*assert: VARtargetkeys is a list containing only string and symbol values. 
*0*assert: VARtargetkeys contains no duplicate entries. 
*0*let VARtargetconfigurablekeys be a new empty list. 
*0*let VARtargetnonconfigurablekeys be a new empty list. 
*0*for each element VARkey of VARtargetkeys, do
*1*let VARdesc be ? VARtarget.[[GETOWNPROPERTY]](VARkey). 
*1*if VARdesc is not undefined and VARdesc.[[CONFIGURABLE]] is false, then
*2*append VARkey as an element of VARtargetnonconfigurablekeys. 
*1*else,
*2*append VARkey as an element of VARtargetconfigurablekeys. 
*0*if VARextensibletarget is true and VARtargetnonconfigurablekeys is empty, then
*1*return VARtrapresult. 
*0*let VARuncheckedresultkeys be a new list which is a copy of VARtrapresult. 
*0*for each VARkey that is an element of VARtargetnonconfigurablekeys, do
*1*if VARkey is not an element of VARuncheckedresultkeys, throw a typeerror exception. 
*1*remove VARkey from VARuncheckedresultkeys. 
*0*if VARextensibletarget is true, return VARtrapresult. 
*0*for each VARkey that is an element of VARtargetconfigurablekeys, do
*1*if VARkey is not an element of VARuncheckedresultkeys, throw a typeerror exception. 
*1*remove VARkey from VARuncheckedresultkeys. 
*0*if VARuncheckedresultkeys is not empty, throw a typeerror exception. 
*0*return VARtrapresult.    

############# END ## 254 ###########################
############# BEGIN ## 255 ###########################
ID= 9.5.12
Summary= [[Call]] ( thisArgument, argumentsList )
Description= The [[Call]] internal method of a Proxy exotic object O is called with parameters thisArgument and argumentsList, a List of ECMAScript language values. The following steps are taken:
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*if VARhandler is null, throw a typeerror exception. 
*0*assert: FUNCtype(VARhandler) is object. 
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "apply"). 
*0*if VARtrap is undefined, then
*1*return ? FUNCcall(VARtarget, VARthisargument, VARargumentslist). 
*0*let VARargarray be FUNCcreatearrayfromlist(VARargumentslist). 
*0*return ? FUNCcall(VARtrap, VARhandler, « VARtarget, VARthisargument, VARargarray »).    

############# END ## 255 ###########################
############# BEGIN ## 256 ###########################
ID= 9.5.13
Summary= [[Construct]] ( argumentsList, newTarget )
Description= The [[Construct]] internal method of a Proxy exotic object O is called with parameters argumentsList which is a possibly empty List of ECMAScript language values and newTarget. The following steps are taken:
*0*let VARhandler be VARo.[[PROXYHANDLER]]. 
*0*if VARhandler is null, throw a typeerror exception. 
*0*assert: FUNCtype(VARhandler) is object. 
*0*let VARtarget be VARo.[[PROXYTARGET]]. 
*0*let VARtrap be ? FUNCgetmethod(VARhandler, "construct"). 
*0*if VARtrap is undefined, then
*1*assert: FUNCisconstructor(VARtarget) is true. 
*1*return ? FUNCconstruct(VARtarget, VARargumentslist, VARnewtarget). 
*0*let VARargarray be FUNCcreatearrayfromlist(VARargumentslist). 
*0*let VARnewobj be ? FUNCcall(VARtrap, VARhandler, « VARtarget, VARargarray, VARnewtarget »). 
*0*if FUNCtype(VARnewobj) is not object, throw a typeerror exception. 
*0*return VARnewobj.    

############# END ## 256 ###########################
############# BEGIN ## 257 ###########################
ID= 9.5.14
Summary= ProxyCreate ( target, handler )
Description= The abstract operation ProxyCreate with arguments target and handler is used to specify the creation of new Proxy exotic objects. It performs the following steps:
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*if VARtarget is a proxy exotic object and VARtarget.[[PROXYHANDLER]] is null, throw a typeerror exception. 
*0*if FUNCtype(VARhandler) is not object, throw a typeerror exception. 
*0*if VARhandler is a proxy exotic object and VARhandler.[[PROXYHANDLER]] is null, throw a typeerror exception. 
*0*let VARp be a newly created object. 
*0*set VARp's essential internal methods (except for [[CALL]] and [[CONSTRUCT]]) to the definitions specified in 9.5. 
*0*if FUNCiscallable(VARtarget) is true, then
*1*set VARp.[[CALL]] as specified in 9.5.12. 
*1*if FUNCisconstructor(VARtarget) is true, then
*2*set VARp.[[CONSTRUCT]] as specified in 9.5.13. 
*0*set VARp.[[PROXYTARGET]] to VARtarget. 
*0*set VARp.[[PROXYHANDLER]] to VARhandler. 
*0*return VARp.    

############# END ## 257 ###########################
############# BEGIN ## 258 ###########################
ID= 10.1.1
Summary= Static Semantics: UTF16Encoding ( cp )
Description= The UTF16Encoding of a numeric code point value, cp, is determined as follows:
*0*assert: 0 ≤ VARcp ≤ 0x10ffff. 
*0*if VARcp ≤ 0xffff, return VARcp. 
*0*let VARcu1 be floor((VARcp - 0x10000) / 0x400) + 0xd800. 
*0*let VARcu2 be ((VARcp - 0x10000) modulo 0x400) + 0xdc00. 
*0*return the code unit sequence consisting of VARcu1 followed by VARcu2.    

############# END ## 258 ###########################
############# BEGIN ## 259 ###########################
ID= 10.1.2
Summary= Static Semantics: UTF16Decode ( lead, trail )
Description= Two code units, lead and trail, that form a UTF-16  surrogate pair are converted to a code point by performing the following steps:
*0*assert: VARlead is a leading surrogate and VARtrail is a trailing surrogate. 
*0*let VARcp be (VARlead - 0xd800) × 0x400 + (VARtrail - 0xdc00) + 0x10000. 
*0*return the code point VARcp.    

############# END ## 259 ###########################
############# BEGIN ## 260 ###########################
ID= 12.1.5.1
Summary= Runtime Semantics: InitializeBoundName ( name, value, environment )
Description= None
*0*assert: FUNCtype(VARname) is string. 
*0*if VARenvironment is not undefined, then
*1*let VARenv be the environmentrecord component of VARenvironment. 
*1*perform VARenv.initializebinding(VARname, VARvalue). 
*1*return FUNCnormalcompletion(undefined). 
*0*else,
*1*let VARlhs be FUNCresolvebinding(VARname). 
*1*return ? FUNCputvalue(VARlhs, VARvalue).     

############# END ## 260 ###########################
############# BEGIN ## 261 ###########################
ID= 12.2.9.4
Summary= Runtime Semantics: GetTemplateObject ( templateLiteral )
Description= The abstract operation GetTemplateObject is called with a Parse Node, templateLiteral, as an argument. It performs the following steps:
*0*let VARrawstrings be templatestrings of VARtemplateliteral with argument true. 
*0*let VARrealm be the current realm record. 
*0*let VARtemplateregistry be VARrealm.[[TEMPLATEMAP]]. 
*0*for each element VARe of VARtemplateregistry, do
*1*if VARe.[[SITE]] is the same parse node as VARtemplateliteral, then
*2*return VARe.[[ARRAY]]. 
*0*let VARcookedstrings be templatestrings of VARtemplateliteral with argument false. 
*0*let VARcount be the number of elements in the list VARcookedstrings. 
*0*assert: VARcount ≤ 232-1. 
*0*let VARtemplate be ! FUNCarraycreate(VARcount). 
*0*let VARrawobj be ! FUNCarraycreate(VARcount). 
*0*let VARindex be 0. 
*0*repeat, while VARindex &lt; VARcount
*1*let VARprop be ! FUNCtostring(VARindex). 
*1*let VARcookedvalue be the string value VARcookedstrings[VARindex]. 
*1*call VARtemplate.[[DEFINEOWNPROPERTY]](VARprop, propertydescriptor { [[VALUE]]: VARcookedvalue, [[WRITABLE]]: false, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: false }). 
*1*let VARrawvalue be the string value VARrawstrings[VARindex]. 
*1*call VARrawobj.[[DEFINEOWNPROPERTY]](VARprop, propertydescriptor { [[VALUE]]: VARrawvalue, [[WRITABLE]]: false, [[ENUMERABLE]]: true, [[CONFIGURABLE]]: false }). 
*1*let VARindex be VARindex+1. 
*0*perform FUNCsetintegritylevel(VARrawobj, "frozen"). 
*0*call VARtemplate.[[DEFINEOWNPROPERTY]]("raw", propertydescriptor { [[VALUE]]: VARrawobj, [[WRITABLE]]: false, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }). 
*0*perform FUNCsetintegritylevel(VARtemplate, "frozen"). 
*0*append the record { [[SITE]]: VARtemplateliteral, [[ARRAY]]: VARtemplate } to VARtemplateregistry. 
*0*return VARtemplate.     

############# END ## 261 ###########################
############# BEGIN ## 262 ###########################
ID= 12.3.3.1.1
Summary= Runtime Semantics: EvaluateNew ( constructExpr, arguments )
Description= The abstract operation EvaluateNew with arguments constructExpr, and arguments performs the following steps:
*0*assert: VARconstructexpr is either a newexpression or a memberexpression. 
*0*assert: VARarguments is either empty or an arguments. 
*0*let VARref be the result of evaluating VARconstructexpr. 
*0*let VARconstructor be ? FUNCgetvalue(VARref). 
*0*if VARarguments is empty, let VARarglist be a new empty list. 
*0*else,
*1*let VARarglist be argumentlistevaluation of VARarguments. 
*1*FUNCreturnifabrupt(VARarglist). 
*0*if FUNCisconstructor(VARconstructor) is false, throw a typeerror exception. 
*0*return ? FUNCconstruct(VARconstructor, VARarglist).      

############# END ## 262 ###########################
############# BEGIN ## 263 ###########################
ID= 12.3.4.2
Summary= Runtime Semantics: EvaluateCall ( func, ref, arguments, tailPosition )
Description= The abstract operation EvaluateCall takes as arguments a value func, a value ref, a Parse Node arguments, and a Boolean argument tailPosition. It performs the following steps:
*0*if FUNCtype(VARref) is reference, then
*1*if FUNCispropertyreference(VARref) is true, then
*2*let VARthisvalue be FUNCgetthisvalue(VARref). 
*1*else the base of VARref is an environment record,
*2*let VARrefenv be FUNCgetbase(VARref). 
*2*let VARthisvalue be VARrefenv.withbaseobject(). 
*0*else FUNCtype(VARref) is not reference,
*1*let VARthisvalue be undefined. 
*0*let VARarglist be argumentlistevaluation of VARarguments. 
*0*FUNCreturnifabrupt(VARarglist). 
*0*if FUNCtype(VARfunc) is not object, throw a typeerror exception. 
*0*if FUNCiscallable(VARfunc) is false, throw a typeerror exception. 
*0*if VARtailposition is true, perform FUNCpreparefortailcall(). 
*0*let VARresult be FUNCcall(VARfunc, VARthisvalue, VARarglist). 
*0*assert: if VARtailposition is true, the above call will not return here, but instead evaluation will continue as if the following return has already occurred. 
*0*assert: if VARresult is not an FUNCabrupt completion, then type(VARresult) is an ecmascript language type. 
*0*return VARresult.     

############# END ## 263 ###########################
############# BEGIN ## 264 ###########################
ID= 12.3.5.2
Summary= Runtime Semantics: GetSuperConstructor ( )
Description= The abstract operation GetSuperConstructor performs the following steps:
*0*let VARenvrec be FUNCgetthisenvironment(). 
*0*assert: VARenvrec is a function environment record. 
*0*let VARactivefunction be VARenvrec.[[FUNCTIONOBJECT]]. 
*0*assert: VARactivefunction is an ecmascript function object. 
*0*let VARsuperconstructor be ! VARactivefunction.[[GETPROTOTYPEOF]](). 
*0*if FUNCisconstructor(VARsuperconstructor) is false, throw a typeerror exception. 
*0*return VARsuperconstructor.     

############# END ## 264 ###########################
############# BEGIN ## 265 ###########################
ID= 12.3.5.3
Summary= Runtime Semantics: MakeSuperPropertyReference ( propertyKey, strict )
Description= The abstract operation MakeSuperPropertyReference with arguments propertyKey and strict performs the following steps:
*0*let VARenv be FUNCgetthisenvironment(). 
*0*assert: VARenv.hassuperbinding() is true. 
*0*let VARactualthis be ? VARenv.getthisbinding(). 
*0*let VARbasevalue be ? VARenv.getsuperbase(). 
*0*let VARbv be ? FUNCrequireobjectcoercible(VARbasevalue). 
*0*return a value of type reference that is a super reference whose base value component is VARbv, whose referenced name component is VARpropertykey, whose thisvalue component is VARactualthis, and whose strict reference flag is VARstrict.     

############# END ## 265 ###########################
############# BEGIN ## 266 ###########################
ID= 12.5.8
Summary= Bitwise NOT Operator ( ~ )
Description= None
*0*let VARexpr be the result of evaluating unaryexpression. 
*0*let VARoldvalue be ? FUNCtoint32(? FUNCgetvalue(VARexpr)). 
*0*return the result of applying bitwise complement to VARoldvalue. the result is a signed 32-bit integer.     

############# END ## 266 ###########################
############# BEGIN ## 267 ###########################
ID= 12.5.9
Summary= Logical NOT Operator ( ! )
Description= None
*0*let VARexpr be the result of evaluating unaryexpression. 
*0*let VARoldvalue be FUNCtoboolean(? FUNCgetvalue(VARexpr)). 
*0*if VARoldvalue is true, return false. 
*0*return true.     

############# END ## 267 ###########################
############# BEGIN ## 268 ###########################
ID= 12.8.3
Summary= The Addition Operator ( + )
Description= The addition operator either performs string concatenation or numeric addition.
*0*let VARlref be the result of evaluating additiveexpression. 
*0*let VARlval be ? FUNCgetvalue(VARlref). 
*0*let VARrref be the result of evaluating multiplicativeexpression. 
*0*let VARrval be ? FUNCgetvalue(VARrref). 
*0*let VARlprim be ? FUNCtoprimitive(VARlval). 
*0*let VARrprim be ? FUNCtoprimitive(VARrval). 
*0*if FUNCtype(VARlprim) is string or FUNCtype(VARrprim) is string, then
*1*let VARlstr be ? FUNCtostring(VARlprim). 
*1*let VARrstr be ? FUNCtostring(VARrprim). 
*1*return the string-concatenation of VARlstr and VARrstr. 
*0*let VARlnum be ? FUNCtonumber(VARlprim). 
*0*let VARrnum be ? FUNCtonumber(VARrprim). 
*0*return the result of applying the addition operation to VARlnum and VARrnum. see the note below 12.8.5.     

############# END ## 268 ###########################
############# BEGIN ## 269 ###########################
ID= 12.8.4
Summary= The Subtraction Operator ( - )
Description= None
*0*let VARlref be the result of evaluating additiveexpression. 
*0*let VARlval be ? FUNCgetvalue(VARlref). 
*0*let VARrref be the result of evaluating multiplicativeexpression. 
*0*let VARrval be ? FUNCgetvalue(VARrref). 
*0*let VARlnum be ? FUNCtonumber(VARlval). 
*0*let VARrnum be ? FUNCtonumber(VARrval). 
*0*return the result of applying the subtraction operation to VARlnum and VARrnum. see the note below 12.8.5.     

############# END ## 269 ###########################
############# BEGIN ## 270 ###########################
ID= 12.9.3
Summary= The Left Shift Operator ( &lt;&lt; )
Description= Performs a bitwise left shift operation on the left operand by the amount specified by the right operand.
*0*let VARlref be the result of evaluating shiftexpression. 
*0*let VARlval be ? FUNCgetvalue(VARlref). 
*0*let VARrref be the result of evaluating additiveexpression. 
*0*let VARrval be ? FUNCgetvalue(VARrref). 
*0*let VARlnum be ? FUNCtoint32(VARlval). 
*0*let VARrnum be ? FUNCtouint32(VARrval). 
*0*let VARshiftcount be the result of masking out all but the least significant 5 bits of VARrnum, that is, compute VARrnum &amp; 0x1f. 
*0*return the result of left shifting VARlnum by VARshiftcount bits. the result is a signed 32-bit integer.     

############# END ## 270 ###########################
############# BEGIN ## 271 ###########################
ID= 12.9.4
Summary= The Signed Right Shift Operator ( &gt;&gt; )
Description= Performs a sign-filling bitwise right shift operation on the left operand by the amount specified by the right operand.
*0*let VARlref be the result of evaluating shiftexpression. 
*0*let VARlval be ? FUNCgetvalue(VARlref). 
*0*let VARrref be the result of evaluating additiveexpression. 
*0*let VARrval be ? FUNCgetvalue(VARrref). 
*0*let VARlnum be ? FUNCtoint32(VARlval). 
*0*let VARrnum be ? FUNCtouint32(VARrval). 
*0*let VARshiftcount be the result of masking out all but the least significant 5 bits of VARrnum, that is, compute VARrnum &amp; 0x1f. 
*0*return the result of performing a sign-extending right shift of VARlnum by VARshiftcount bits. the most significant bit is propagated. the result is a signed 32-bit integer.     

############# END ## 271 ###########################
############# BEGIN ## 272 ###########################
ID= 12.9.5
Summary= The Unsigned Right Shift Operator ( &gt;&gt;&gt; )
Description= Performs a zero-filling bitwise right shift operation on the left operand by the amount specified by the right operand.
*0*let VARlref be the result of evaluating shiftexpression. 
*0*let VARlval be ? FUNCgetvalue(VARlref). 
*0*let VARrref be the result of evaluating additiveexpression. 
*0*let VARrval be ? FUNCgetvalue(VARrref). 
*0*let VARlnum be ? FUNCtouint32(VARlval). 
*0*let VARrnum be ? FUNCtouint32(VARrval). 
*0*let VARshiftcount be the result of masking out all but the least significant 5 bits of VARrnum, that is, compute VARrnum &amp; 0x1f. 
*0*return the result of performing a zero-filling right shift of VARlnum by VARshiftcount bits. vacated bits are filled with zero. the result is an unsigned 32-bit integer.     

############# END ## 272 ###########################
############# BEGIN ## 273 ###########################
ID= 12.10.4
Summary= Runtime Semantics: InstanceofOperator ( V, target )
Description= The abstract operation InstanceofOperator(V, target) implements the generic algorithm for determining if  ECMAScript value V is an instance of object target either by consulting target's @@hasinstance method or, if absent, determining whether the value of target's prototype property is present in V's prototype chain. This abstract operation performs the following steps:
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*let VARinstofhandler be ? FUNCgetmethod(VARtarget, @@hasinstance). 
*0*if VARinstofhandler is not undefined, then
*1*return FUNCtoboolean(? FUNCcall(VARinstofhandler, VARtarget, « VARv »)). 
*0*if FUNCiscallable(VARtarget) is false, throw a typeerror exception. 
*0*return ? FUNCordinaryhasinstance(VARtarget, VARv).    

############# END ## 273 ###########################
############# BEGIN ## 274 ###########################
ID= 12.14
Summary= Conditional Operator ( ? : )
Description= The grammar for a ConditionalExpression in ECMAScript is slightly different from that in C and Java, which each allow the second subexpression to be an Expression but restrict the third expression to be a ConditionalExpression. The motivation for this difference in ECMAScript is to allow an assignment expression to be governed by either arm of a conditional and to eliminate the confusing and fairly useless case of a comma expression as the centre expression.
*0*return false.    

############# END ## 274 ###########################
############# BEGIN ## 275 ###########################
ID= 12.16
Summary= Comma Operator ( , )
Description= GetValue must be called even though its value is not used because it may have observable side-effects.
*0*return false.    

############# END ## 275 ###########################
############# BEGIN ## 276 ###########################
ID= 13.2.14
Summary= Runtime Semantics: BlockDeclarationInstantiation ( code, env )
Description= When a Block or CaseBlock is evaluated a new declarative Environment Record is created and bindings for each block scoped variable, constant, function, or class declared in the block are instantiated in the Environment Record.
*0*let VARenvrec be VARenv's environmentrecord. 
*0*assert: VARenvrec is a declarative environment record. 
*0*let VARdeclarations be the lexicallyscopeddeclarations of VARcode. 
*0*for each element VARd in VARdeclarations, do
*1*for each element VARdn of the boundnames of VARd, do
*2*if isconstantdeclaration of VARd is true, then
*3*perform ! VARenvrec.createimmutablebinding(VARdn, true). 
*2*else,
*3*perform ! VARenvrec.createmutablebinding(VARdn, false). 
*1*if VARd is a functiondeclaration, a generatordeclaration, an asyncfunctiondeclaration, or an asyncgeneratordeclaration, then
*2*let VARfn be the sole element of the boundnames of VARd. 
*2*let VARfo be the result of performing instantiatefunctionobject for VARd with argument VARenv. 
*2*perform VARenvrec.initializebinding(VARfn, VARfo).    

############# END ## 276 ###########################
############# BEGIN ## 277 ###########################
ID= 13.7.1.2
Summary= Runtime Semantics: LoopContinues ( completion, labelSet )
Description= The abstract operation LoopContinues with arguments completion and labelSet is defined by the following steps:
*0*if VARcompletion.[[TYPE]] is normal, return true. 
*0*if VARcompletion.[[TYPE]] is not continue, return false. 
*0*if VARcompletion.[[TARGET]] is empty, return true. 
*0*if VARcompletion.[[TARGET]] is an element of VARlabelset, return true. 
*0*return false.     

############# END ## 277 ###########################
############# BEGIN ## 278 ###########################
ID= 13.7.4.8
Summary= Runtime Semantics: ForBodyEvaluation ( test, increment, stmt, perIterationBindings, labelSet )
Description= The abstract operation ForBodyEvaluation with arguments test, increment, stmt, perIterationBindings, and labelSet is performed as follows:
*0*let VARv be undefined. 
*0*perform ? FUNCcreateperiterationenvironment(VARperiterationbindings). 
*0*repeat,
*1*if VARtest is not [empty], then
*2*let VARtestref be the result of evaluating VARtest. 
*2*let VARtestvalue be ? FUNCgetvalue(VARtestref). 
*2*if FUNCtoboolean(VARtestvalue) is false, return FUNCnormalcompletion(VARv). 
*1*let VARresult be the result of evaluating VARstmt. 
*1*if FUNCloopcontinues(VARresult, VARlabelset) is false, return FUNCcompletion(FUNCupdateempty(VARresult, VARv)). 
*1*if VARresult.[[VALUE]] is not empty, set VARv to VARresult.[[VALUE]]. 
*1*perform ? FUNCcreateperiterationenvironment(VARperiterationbindings). 
*1*if VARincrement is not [empty], then
*2*let VARincref be the result of evaluating VARincrement. 
*2*perform ? FUNCgetvalue(VARincref).     

############# END ## 278 ###########################
############# BEGIN ## 279 ###########################
ID= 13.7.4.9
Summary= Runtime Semantics: CreatePerIterationEnvironment ( perIterationBindings )
Description= The abstract operation CreatePerIterationEnvironment with argument perIterationBindings is performed as follows:
*0*if VARperiterationbindings has any elements, then
*1*let VARlastiterationenv be the running execution context's lexicalenvironment. 
*1*let VARlastiterationenvrec be VARlastiterationenv's environmentrecord. 
*1*let VARouter be VARlastiterationenv's outer environment reference. 
*1*assert: VARouter is not null. 
*1*let VARthisiterationenv be FUNCnewdeclarativeenvironment(VARouter). 
*1*let VARthisiterationenvrec be VARthisiterationenv's environmentrecord. 
*1*for each element VARbn of VARperiterationbindings, do
*2*perform ! VARthisiterationenvrec.createmutablebinding(VARbn, false). 
*2*let VARlastvalue be ? VARlastiterationenvrec.getbindingvalue(VARbn, true). 
*2*perform VARthisiterationenvrec.initializebinding(VARbn, VARlastvalue). 
*1*set the running execution context's lexicalenvironment to VARthisiterationenv. 
*0*return undefined.     

############# END ## 279 ###########################
############# BEGIN ## 280 ###########################
ID= 13.7.5.12
Summary= Runtime Semantics: ForIn/OfHeadEvaluation ( TDZnames, expr, iterationKind )
Description= The abstract operation ForIn/OfHeadEvaluation is called with arguments TDZnames, expr, and iterationKind. The value of iterationKind is either enumerate, iterate, or async-iterate.
*0*let VARoldenv be the running execution context's lexicalenvironment. 
*0*if VARtdznames is not an empty list, then
*1*assert: VARtdznames has no duplicate entries. 
*1*let VARtdz be FUNCnewdeclarativeenvironment(VARoldenv). 
*1*let VARtdzenvrec be VARtdz's environmentrecord. 
*1*for each string VARname in VARtdznames, do
*2*perform ! VARtdzenvrec.createmutablebinding(VARname, false). 
*1*set the running execution context's lexicalenvironment to VARtdz. 
*0*let VARexprref be the result of evaluating VARexpr. 
*0*set the running execution context's lexicalenvironment to VARoldenv. 
*0*let VARexprvalue be ? FUNCgetvalue(VARexprref). 
*0*if VARiterationkind is enumerate, then
*1*if VARexprvalue is undefined or null, then
*2*return completion { [[TYPE]]: break, [[VALUE]]: empty, [[TARGET]]: empty }. 
*1*let VARobj be ! FUNCtoobject(VARexprvalue). 
*1*return ? FUNCenumerateobjectproperties(VARobj). 
*0*else,
*1*assert: VARiterationkind is iterate. 
*1*if VARiterationkind is async-iterate, let VARiteratorhint be async. 
*1*else, let VARiteratorhint be sync. 
*1*return ? FUNCgetiterator(VARexprvalue, VARiteratorhint).     

############# END ## 280 ###########################
############# BEGIN ## 281 ###########################
ID= 13.7.5.13
Summary= Runtime Semantics: ForIn/OfBodyEvaluation ( lhs, stmt, iteratorRecord, iterationKind, lhsKind, labelSet [ , iteratorKind ] )
Description= The abstract operation ForIn/OfBodyEvaluation is called with arguments lhs, stmt, iteratorRecord, iterationKind, lhsKind, labelSet, and optional argument iteratorKind. The value of lhsKind is either assignment, varBinding or lexicalBinding. The value of iteratorKind is either sync or async.
*0*if VARiteratorkind is not present, set VARiteratorkind to sync. 
*0*let VARoldenv be the running execution context's lexicalenvironment. 
*0*let VARv be undefined. 
*0*let VARdestructuring be isdestructuring of VARlhs. 
*0*if VARdestructuring is true and if VARlhskind is assignment, then
*1*assert: VARlhs is a lefthandsideexpression. 
*1*let VARassignmentpattern be the assignmentpattern that is covered by VARlhs. 
*0*repeat,
*1*let VARnextresult be ? FUNCcall(VARiteratorrecord.[[NEXTMETHOD]], VARiteratorrecord.[[ITERATOR]], « »). 
*1*if VARiteratorkind is async, then set VARnextresult to ? await(VARnextresult). 
*1*if FUNCtype(VARnextresult) is not object, throw a typeerror exception. 
*1*let VARnextvalue be ? FUNCiteratorvalue(VARnextresult). 
*1*if VARlhskind is either assignment or varbinding, then
*2*if VARdestructuring is false, then
*3*let VARlhsref be the result of evaluating VARlhs. (it may be evaluated repeatedly.) 
*1*else,
*2*assert: VARlhskind is lexicalbinding. 
*2*assert: VARlhs is a fordeclaration. 
*2*let VARiterationenv be FUNCnewdeclarativeenvironment(VARoldenv). 
*2*perform bindinginstantiation for VARlhs passing VARiterationenv as the argument. 
*2*set the running execution context's lexicalenvironment to VARiterationenv. 
*2*if VARdestructuring is false, then
*3*assert: VARlhs binds a single name. 
*3*let VARlhsname be the sole element of boundnames of VARlhs. 
*3*let VARlhsref be ! FUNCresolvebinding(VARlhsname). 
*1*if VARdestructuring is false, then
*2*if VARlhsref is an abrupt completion, then
*3*let VARstatus be VARlhsref. 
*2*else if VARlhskind is lexicalbinding, then
*3*let VARstatus be FUNCinitializereferencedbinding(VARlhsref, VARnextvalue). 
*2*else,
*3*let VARstatus be FUNCputvalue(VARlhsref, VARnextvalue). 
*1*else,
*2*if VARlhskind is assignment, then
*3*let VARstatus be the result of performing destructuringassignmentevaluation of VARassignmentpattern using VARnextvalue as the argument. 
*2*else if VARlhskind is varbinding, then
*3*assert: VARlhs is a forbinding. 
*3*let VARstatus be the result of performing bindinginitialization for VARlhs passing VARnextvalue and undefined as the arguments. 
*2*else,
*3*assert: VARlhskind is lexicalbinding. 
*3*assert: VARlhs is a fordeclaration. 
*3*let VARstatus be the result of performing bindinginitialization for VARlhs passing VARnextvalue and VARiterationenv as arguments. 
*1*if VARstatus is an abrupt completion, then
*2*set the running execution context's lexicalenvironment to VARoldenv. 
*2*if VARiteratorkind is async, return ? FUNCasynciteratorclose(VARiteratorrecord, VARstatus). 
*2*if VARiterationkind is enumerate, then
*3*return VARstatus. 
*2*else,
*3*assert: VARiterationkind is iterate. 
*3*return ? FUNCiteratorclose(VARiteratorrecord, VARstatus). 
*1*let VARresult be the result of evaluating VARstmt. 
*1*set the running execution context's lexicalenvironment to VARoldenv. 
*1*if FUNCloopcontinues(VARresult, VARlabelset) is false, then
*2*if VARiterationkind is enumerate, then
*3*return FUNCcompletion(FUNCupdateempty(VARresult, VARv)). 
*2*else,
*3*assert: VARiterationkind is iterate. 
*3*set VARstatus to FUNCupdateempty(VARresult, VARv). 
*3*if VARiteratorkind is async, return ? FUNCasynciteratorclose(VARiteratorrecord, VARstatus). 
*3*return ? FUNCiteratorclose(VARiteratorrecord, VARstatus). 
*1*if VARresult.[[VALUE]] is not empty, set VARv to VARresult.[[VALUE]].     

############# END ## 281 ###########################
############# BEGIN ## 282 ###########################
ID= 13.7.5.15
Summary= EnumerateObjectProperties ( O )
Description= When the abstract operation EnumerateObjectProperties is called with argument O, the following steps are taken:
*0*assert: FUNCtype(VARo) is object. 
*0*return an iterator object (25.1.1.2) whose next method iterates over all the string-valued keys of enumerable properties of VARo. the iterator object is never directly accessible to ecmascript code. the mechanics and order of enumerating the properties is not specified but must conform to the rules specified below.     

############# END ## 282 ###########################
############# BEGIN ## 283 ###########################
ID= 13.12.10
Summary= Runtime Semantics: CaseClauseIsSelected ( C, input )
Description= The abstract operation CaseClauseIsSelected, given CaseClause C and value input, determines whether C matches input.
*0*assert: VARc is an instance of the production caseclause:caseexpression:statementlistopt. 
*0*let VARexprref be the result of evaluating the expression of VARc. 
*0*let VARclauseselector be ? FUNCgetvalue(VARexprref). 
*0*return the result of performing strict equality comparison VARinput === VARclauseselector.    

############# END ## 283 ###########################
############# BEGIN ## 284 ###########################
ID= 13.13.5
Summary= Static Semantics: IsLabelledFunction ( stmt )
Description= The abstract operation IsLabelledFunction with argument stmt performs the following steps:
*0*if VARstmt is not a labelledstatement, return false. 
*0*let VARitem be the labelleditem of VARstmt. 
*0*if VARitem is labelleditem:functiondeclaration , return true. 
*0*let VARsubstmt be the statement of VARitem. 
*0*return FUNCislabelledfunction(VARsubstmt).    

############# END ## 284 ###########################
############# BEGIN ## 285 ###########################
ID= 14.1.10
Summary= Static Semantics: IsAnonymousFunctionDefinition ( expr )
Description= The abstract operation IsAnonymousFunctionDefinition determines if its argument is a function definition that does not bind a name. The argument expr is the result of parsing an AssignmentExpression or Initializer. The following steps are taken:
*0*if isfunctiondefinition of VARexpr is false, return false. 
*0*let VARhasname be the result of hasname of VARexpr. 
*0*if VARhasname is true, return false. 
*0*return true.    

############# END ## 285 ###########################
############# BEGIN ## 286 ###########################
ID= 14.9.1
Summary= Static Semantics: IsInTailPosition ( call )
Description= The abstract operation IsInTailPosition with argument call performs the following steps:
*0*assert: VARcall is a parse node. 
*0*if the source code matching VARcall is non-strict code, return false. 
*0*if VARcall is not contained within a functionbody, concisebody, or asyncconcisebody, return false. 
*0*let VARbody be the functionbody, concisebody, or asyncconcisebody that most closely contains VARcall. 
*0*if VARbody is the functionbody of a generatorbody, return false. 
*0*if VARbody is the functionbody of an asyncfunctionbody, return false. 
*0*if VARbody is the functionbody of an asyncgeneratorbody, return false. 
*0*if VARbody is an asyncconcisebody, return false. 
*0*return the result of hascallintailposition of VARbody with argument VARcall.    

############# END ## 286 ###########################
############# BEGIN ## 287 ###########################
ID= 14.9.3
Summary= Runtime Semantics: PrepareForTailCall ( )
Description= The abstract operation PrepareForTailCall performs the following steps:
*0*let VARleafcontext be the running execution context. 
*0*suspend VARleafcontext. 
*0*pop VARleafcontext from the execution context stack. the execution context now on the top of the stack becomes the running execution context. 
*0*assert: VARleafcontext has no further use. it will never be activated as the running execution context.    

############# END ## 287 ###########################
############# BEGIN ## 288 ###########################
ID= 15.1.9
Summary= ParseScript ( sourceText, realm, hostDefined )
Description= The abstract operation ParseScript with arguments sourceText, realm, and hostDefined creates a Script Record based upon the result of parsing sourceText as a Script. ParseScript performs the following steps:
*0*assert: VARsourcetext is an ecmascript source text (see clause 10). 
*0*parse VARsourcetext using script as the goal symbol and analyse the parse result for any early error conditions. if the parse was successful and no early errors were found, let VARbody be the resulting parse tree. otherwise, let VARbody be a list of one or more syntaxerror or referenceerror objects representing the parsing errors and/or early errors. parsing and early error detection may be interweaved in an implementation-dependent manner. if more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-dependent, but at least one must be present. 
*0*if VARbody is a list of errors, return VARbody. 
*0*return script record { [[REALM]]: VARrealm, [[ENVIRONMENT]]: undefined, [[ECMASCRIPTCODE]]: VARbody, [[HOSTDEFINED]]: VARhostdefined }.    

############# END ## 288 ###########################
############# BEGIN ## 289 ###########################
ID= 15.1.10
Summary= ScriptEvaluation ( scriptRecord )
Description= None
*0*let VARglobalenv be VARscriptrecord.[[REALM]].[[GLOBALENV]]. 
*0*let VARscriptcxt be a new ecmascript code execution context. 
*0*set the function of VARscriptcxt to null. 
*0*set the realm of VARscriptcxt to VARscriptrecord.[[REALM]]. 
*0*set the scriptormodule of VARscriptcxt to VARscriptrecord. 
*0*set the variableenvironment of VARscriptcxt to VARglobalenv. 
*0*set the lexicalenvironment of VARscriptcxt to VARglobalenv. 
*0*suspend the currently running execution context. 
*0*push VARscriptcxt on to the execution context stack; VARscriptcxt is now the running execution context. 
*0*let VARscriptbody be VARscriptrecord.[[ECMASCRIPTCODE]]. 
*0*let VARresult be FUNCglobaldeclarationinstantiation(VARscriptbody, VARglobalenv). 
*0*if VARresult.[[TYPE]] is normal, then
*1*set VARresult to the result of evaluating VARscriptbody. 
*0*if VARresult.[[TYPE]] is normal and VARresult.[[VALUE]] is empty, then
*1*set VARresult to FUNCnormalcompletion(undefined). 
*0*suspend VARscriptcxt and remove it from the execution context stack. 
*0*assert: the execution context stack is not empty. 
*0*resume the context that is now on the top of the execution context stack as the running execution context. 
*0*return FUNCcompletion(VARresult).    

############# END ## 289 ###########################
############# BEGIN ## 290 ###########################
ID= 15.1.11
Summary= Runtime Semantics: GlobalDeclarationInstantiation ( script, env )
Description= When an execution context is established for evaluating scripts, declarations are instantiated in the current global environment. Each global binding declared in the code is instantiated.
*0*let VARenvrec be VARenv's environmentrecord. 
*0*assert: VARenvrec is a global environment record. 
*0*let VARlexnames be the lexicallydeclarednames of VARscript. 
*0*let VARvarnames be the vardeclarednames of VARscript. 
*0*for each VARname in VARlexnames, do
*1*if VARenvrec.hasvardeclaration(VARname) is true, throw a syntaxerror exception. 
*1*if VARenvrec.haslexicaldeclaration(VARname) is true, throw a syntaxerror exception. 
*1*let VARhasrestrictedglobal be ? VARenvrec.hasrestrictedglobalproperty(VARname). 
*1*if VARhasrestrictedglobal is true, throw a syntaxerror exception. 
*0*for each VARname in VARvarnames, do
*1*if VARenvrec.haslexicaldeclaration(VARname) is true, throw a syntaxerror exception. 
*0*let VARvardeclarations be the varscopeddeclarations of VARscript. 
*0*let VARfunctionstoinitialize be a new empty list. 
*0*let VARdeclaredfunctionnames be a new empty list. 
*0*for each VARd in VARvardeclarations, in reverse list order, do
*1*if VARd is neither a variabledeclaration nor a forbinding nor a bindingidentifier, then
*2*assert: VARd is either a functiondeclaration, a generatordeclaration, an asyncfunctiondeclaration, or an asyncgeneratordeclaration. 
*2*note: if there are multiple function declarations for the same name, the last declaration is used. 
*2*let VARfn be the sole element of the boundnames of VARd. 
*2*if VARfn is not an element of VARdeclaredfunctionnames, then
*3*let VARfndefinable be ? VARenvrec.candeclareglobalfunction(VARfn). 
*3*if VARfndefinable is false, throw a typeerror exception. 
*3*append VARfn to VARdeclaredfunctionnames. 
*3*insert VARd as the first element of VARfunctionstoinitialize. 
*0*let VARdeclaredvarnames be a new empty list. 
*0*for each VARd in VARvardeclarations, do
*1*if VARd is a variabledeclaration, a forbinding, or a bindingidentifier, then
*2*for each string VARvn in the boundnames of VARd, do
*3*if VARvn is not an element of VARdeclaredfunctionnames, then
*4*let VARvndefinable be ? VARenvrec.candeclareglobalvar(VARvn). 
*4*if VARvndefinable is false, throw a typeerror exception. 
*4*if VARvn is not an element of VARdeclaredvarnames, then
*5*append VARvn to VARdeclaredvarnames. 
*0*note: no abnormal terminations occur after this algorithm step if the global object is an ordinary object. however, if the global object is a proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps. 
*0*note: annex b.3.3.2 adds additional steps at this point. 
*0*let VARlexdeclarations be the lexicallyscopeddeclarations of VARscript. 
*0*for each element VARd in VARlexdeclarations, do
*1*note: lexically declared names are only instantiated here but not initialized. 
*1*for each element VARdn of the boundnames of VARd, do
*2*if isconstantdeclaration of VARd is true, then
*3*perform ? VARenvrec.createimmutablebinding(VARdn, true). 
*2*else,
*3*perform ? VARenvrec.createmutablebinding(VARdn, false). 
*0*for each parse node VARf in VARfunctionstoinitialize, do
*1*let VARfn be the sole element of the boundnames of VARf. 
*1*let VARfo be the result of performing instantiatefunctionobject for VARf with argument VARenv. 
*1*perform ? VARenvrec.createglobalfunctionbinding(VARfn, VARfo, false). 
*0*for each string VARvn in VARdeclaredvarnames, in list order, do
*1*perform ? VARenvrec.createglobalvarbinding(VARvn, false). 
*0*return FUNCnormalcompletion(empty).    

############# END ## 290 ###########################
############# BEGIN ## 291 ###########################
ID= 15.1.12
Summary= Runtime Semantics: ScriptEvaluationJob ( sourceText, hostDefined )
Description= The job ScriptEvaluationJob with parameters sourceText and hostDefined parses, validates, and evaluates sourceText as a Script.
*0*assert: VARsourcetext is an ecmascript source text (see clause 10). 
*0*let VARrealm be the current realm record. 
*0*let VARs be FUNCparsescript(VARsourcetext, VARrealm, VARhostdefined). 
*0*if VARs is a list of errors, then
*1*perform FUNChostreporterrors(VARs). 
*1*return FUNCnormalcompletion(undefined). 
*0*return ? FUNCscriptevaluation(VARs).    

############# END ## 291 ###########################
############# BEGIN ## 292 ###########################
ID= 15.2.1.9
Summary= Static Semantics: ImportedLocalNames ( importEntries )
Description= The abstract operation ImportedLocalNames with argument importEntries creates a List of all of the local name bindings defined by a List of ImportEntry Records (see  Table 40). ImportedLocalNames performs the following steps:
*0*let VARlocalnames be a new empty list. 
*0*for each importentry record VARi in VARimportentries, do
*1*append VARi.[[LOCALNAME]] to VARlocalnames. 
*0*return VARlocalnames.     

############# END ## 292 ###########################
############# BEGIN ## 293 ###########################
ID= 15.2.1.16.1
Summary= ParseModule ( sourceText, realm, hostDefined )
Description= The abstract operation ParseModule with arguments sourceText, realm, and hostDefined creates a Source Text Module Record based upon the result of parsing sourceText as a Module. ParseModule performs the following steps:
*0*assert: VARsourcetext is an ecmascript source text (see clause 10). 
*0*parse VARsourcetext using module as the goal symbol and analyse the parse result for any early error conditions. if the parse was successful and no early errors were found, let VARbody be the resulting parse tree. otherwise, let VARbody be a list of one or more syntaxerror or referenceerror objects representing the parsing errors and/or early errors. parsing and early error detection may be interweaved in an implementation-dependent manner. if more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-dependent, but at least one must be present. 
*0*if VARbody is a list of errors, return VARbody. 
*0*let VARrequestedmodules be the modulerequests of VARbody. 
*0*let VARimportentries be importentries of VARbody. 
*0*let VARimportedboundnames be FUNCimportedlocalnames(VARimportentries). 
*0*let VARindirectexportentries be a new empty list. 
*0*let VARlocalexportentries be a new empty list. 
*0*let VARstarexportentries be a new empty list. 
*0*let VARexportentries be exportentries of VARbody. 
*0*for each exportentry record VARee in VARexportentries, do
*1*if VARee.[[MODULEREQUEST]] is null, then
*2*if VARee.[[LOCALNAME]] is not an element of VARimportedboundnames, then
*3*append VARee to VARlocalexportentries. 
*2*else,
*3*let VARie be the element of VARimportentries whose [[LOCALNAME]] is the same as VARee.[[LOCALNAME]]. 
*3*if VARie.[[IMPORTNAME]] is "*", then
*4*assert: this is a re-export of an imported module namespace object. 
*4*append VARee to VARlocalexportentries. 
*3*else this is a re-export of a single name,
*4*append the exportentry record { [[MODULEREQUEST]]: VARie.[[MODULEREQUEST]], [[IMPORTNAME]]: VARie.[[IMPORTNAME]], [[LOCALNAME]]: null, [[EXPORTNAME]]: VARee.[[EXPORTNAME]] } to VARindirectexportentries. 
*1*else if VARee.[[IMPORTNAME]] is "*", then
*2*append VARee to VARstarexportentries. 
*1*else,
*2*append VARee to VARindirectexportentries. 
*0*return source text module record { [[REALM]]: VARrealm, [[ENVIRONMENT]]: undefined, [[NAMESPACE]]: undefined, [[STATUS]]: "uninstantiated", [[EVALUATIONERROR]]: undefined, [[HOSTDEFINED]]: VARhostdefined, [[ECMASCRIPTCODE]]: VARbody, [[REQUESTEDMODULES]]: VARrequestedmodules, [[IMPORTENTRIES]]: VARimportentries, [[LOCALEXPORTENTRIES]]: VARlocalexportentries, [[INDIRECTEXPORTENTRIES]]: VARindirectexportentries, [[STAREXPORTENTRIES]]: VARstarexportentries, [[DFSINDEX]]: undefined, [[DFSANCESTORINDEX]]: undefined }.      

############# END ## 293 ###########################
############# BEGIN ## 294 ###########################
ID= 15.2.1.16.4.1
Summary= InnerModuleInstantiation ( module, stack, index )
Description= The InnerModuleInstantiation abstract operation is used by Instantiate to perform the actual instantiation process for the Source Text Module Record module, as well as recursively on all other modules in the dependency graph. The stack and index parameters, as well as a module's [[DFSIndex]] and [[DFSAncestorIndex]] fields, keep track of the depth-first search (DFS) traversal. In particular, [[DFSAncestorIndex]] is used to discover strongly connected components (SCCs), such that all modules in an SCC transition to "instantiated" together.
*0*if VARmodule is not a source text module record, then
*1*perform ? VARmodule.instantiate(). 
*1*return VARindex. 
*0*if VARmodule.[[STATUS]] is "instantiating", "instantiated", or "evaluated", then
*1*return VARindex. 
*0*assert: VARmodule.[[STATUS]] is "uninstantiated". 
*0*set VARmodule.[[STATUS]] to "instantiating". 
*0*set VARmodule.[[DFSINDEX]] to VARindex. 
*0*set VARmodule.[[DFSANCESTORINDEX]] to VARindex. 
*0*set VARindex to VARindex + 1. 
*0*append VARmodule to VARstack. 
*0*for each string VARrequired that is an element of VARmodule.[[REQUESTEDMODULES]], do
*1*let VARrequiredmodule be ? FUNChostresolveimportedmodule(VARmodule, VARrequired). 
*1*set VARindex to ? FUNCinnermoduleinstantiation(VARrequiredmodule, VARstack, VARindex). 
*1*assert: VARrequiredmodule.[[STATUS]] is either "instantiating", "instantiated", or "evaluated". 
*1*assert: VARrequiredmodule.[[STATUS]] is "instantiating" if and only if VARrequiredmodule is in VARstack. 
*1*if VARrequiredmodule.[[STATUS]] is "instantiating", then
*2*assert: VARrequiredmodule is a source text module record. 
*2*set VARmodule.[[DFSANCESTORINDEX]] to min(VARmodule.[[DFSANCESTORINDEX]], VARrequiredmodule.[[DFSANCESTORINDEX]]). 
*0*perform ? FUNCmoduledeclarationenvironmentsetup(VARmodule). 
*0*assert: VARmodule occurs exactly once in VARstack. 
*0*assert: VARmodule.[[DFSANCESTORINDEX]] is less than or equal to VARmodule.[[DFSINDEX]]. 
*0*if VARmodule.[[DFSANCESTORINDEX]] equals VARmodule.[[DFSINDEX]], then
*1*let VARdone be false. 
*1*repeat, while VARdone is false,
*2*let VARrequiredmodule be the last element in VARstack. 
*2*remove the last element of VARstack. 
*2*set VARrequiredmodule.[[STATUS]] to "instantiated". 
*2*if VARrequiredmodule and VARmodule are the same module record, set VARdone to true. 
*0*return VARindex.       

############# END ## 294 ###########################
############# BEGIN ## 295 ###########################
ID= 15.2.1.16.4.2
Summary= ModuleDeclarationEnvironmentSetup ( module )
Description= The ModuleDeclarationEnvironmentSetup abstract operation is used by InnerModuleInstantiation to initialize the Lexical Environment of the module, including resolving all imported bindings.
*0*for each exportentry record VARe in VARmodule.[[INDIRECTEXPORTENTRIES]], do
*1*let VARresolution be ? VARmodule.resolveexport(VARe.[[EXPORTNAME]], « »). 
*1*if VARresolution is null or "ambiguous", throw a syntaxerror exception. 
*1*assert: VARresolution is a resolvedbinding record. 
*0*assert: all named exports from VARmodule are resolvable. 
*0*let VARrealm be VARmodule.[[REALM]]. 
*0*assert: VARrealm is not undefined. 
*0*let VARenv be FUNCnewmoduleenvironment(VARrealm.[[GLOBALENV]]). 
*0*set VARmodule.[[ENVIRONMENT]] to VARenv. 
*0*let VARenvrec be VARenv's environmentrecord. 
*0*for each importentry record VARin in VARmodule.[[IMPORTENTRIES]], do
*1*let VARimportedmodule be ! FUNChostresolveimportedmodule(VARmodule, VARin.[[MODULEREQUEST]]). 
*1*note: the above call cannot fail because imported module requests are a subset of VARmodule.[[REQUESTEDMODULES]], and these have been resolved earlier in this algorithm. 
*1*if VARin.[[IMPORTNAME]] is "*", then
*2*let VARnamespace be ? FUNCgetmodulenamespace(VARimportedmodule). 
*2*perform ! VARenvrec.createimmutablebinding(VARin.[[LOCALNAME]], true). 
*2*call VARenvrec.initializebinding(VARin.[[LOCALNAME]], VARnamespace). 
*1*else,
*2*let VARresolution be ? VARimportedmodule.resolveexport(VARin.[[IMPORTNAME]], « »). 
*2*if VARresolution is null or "ambiguous", throw a syntaxerror exception. 
*2*call VARenvrec.createimportbinding(VARin.[[LOCALNAME]], VARresolution.[[MODULE]], VARresolution.[[BINDINGNAME]]). 
*0*let VARcode be VARmodule.[[ECMASCRIPTCODE]]. 
*0*let VARvardeclarations be the varscopeddeclarations of VARcode. 
*0*let VARdeclaredvarnames be a new empty list. 
*0*for each element VARd in VARvardeclarations, do
*1*for each element VARdn of the boundnames of VARd, do
*2*if VARdn is not an element of VARdeclaredvarnames, then
*3*perform ! VARenvrec.createmutablebinding(VARdn, false). 
*3*call VARenvrec.initializebinding(VARdn, undefined). 
*3*append VARdn to VARdeclaredvarnames. 
*0*let VARlexdeclarations be the lexicallyscopeddeclarations of VARcode. 
*0*for each element VARd in VARlexdeclarations, do
*1*for each element VARdn of the boundnames of VARd, do
*2*if isconstantdeclaration of VARd is true, then
*3*perform ! VARenvrec.createimmutablebinding(VARdn, true). 
*2*else,
*3*perform ! VARenvrec.createmutablebinding(VARdn, false). 
*2*if VARd is a functiondeclaration, a generatordeclaration, an asyncfunctiondeclaration, or an asyncgeneratordeclaration, then
*3*let VARfo be the result of performing instantiatefunctionobject for VARd with argument VARenv. 
*3*call VARenvrec.initializebinding(VARdn, VARfo).       

############# END ## 295 ###########################
############# BEGIN ## 296 ###########################
ID= 15.2.1.16.5.1
Summary= InnerModuleEvaluation ( module, stack, index )
Description= The InnerModuleEvaluation abstract operation is used by Evaluate to perform the actual evaluation process for the Source Text Module Record module, as well as recursively on all other modules in the dependency graph. The stack and index parameters, as well as module's [[DFSIndex]] and [[DFSAncestoreIndex]] fields, are used the same way as in InnerModuleInstantiation.
*0*if VARmodule is not a source text module record, then
*1*perform ? VARmodule.evaluate(). 
*1*return VARindex. 
*0*if VARmodule.[[STATUS]] is "evaluated", then
*1*if VARmodule.[[EVALUATIONERROR]] is undefined, return VARindex. 
*1*otherwise return VARmodule.[[EVALUATIONERROR]]. 
*0*if VARmodule.[[STATUS]] is "evaluating", return VARindex. 
*0*assert: VARmodule.[[STATUS]] is "instantiated". 
*0*set VARmodule.[[STATUS]] to "evaluating". 
*0*set VARmodule.[[DFSINDEX]] to VARindex. 
*0*set VARmodule.[[DFSANCESTORINDEX]] to VARindex. 
*0*set VARindex to VARindex + 1. 
*0*append VARmodule to VARstack. 
*0*for each string VARrequired that is an element of VARmodule.[[REQUESTEDMODULES]], do
*1*let VARrequiredmodule be ! FUNChostresolveimportedmodule(VARmodule, VARrequired). 
*1*note: instantiate must be completed successfully prior to invoking this method, so every requested module is guaranteed to resolve successfully. 
*1*set VARindex to ? FUNCinnermoduleevaluation(VARrequiredmodule, VARstack, VARindex). 
*1*assert: VARrequiredmodule.[[STATUS]] is either "evaluating" or "evaluated". 
*1*assert: VARrequiredmodule.[[STATUS]] is "evaluating" if and only if VARrequiredmodule is in VARstack. 
*1*if VARrequiredmodule.[[STATUS]] is "evaluating", then
*2*assert: VARrequiredmodule is a source text module record. 
*2*set VARmodule.[[DFSANCESTORINDEX]] to min(VARmodule.[[DFSANCESTORINDEX]], VARrequiredmodule.[[DFSANCESTORINDEX]]). 
*0*perform ? FUNCmoduleexecution(VARmodule). 
*0*assert: VARmodule occurs exactly once in VARstack. 
*0*assert: VARmodule.[[DFSANCESTORINDEX]] is less than or equal to VARmodule.[[DFSINDEX]]. 
*0*if VARmodule.[[DFSANCESTORINDEX]] equals VARmodule.[[DFSINDEX]], then
*1*let VARdone be false. 
*1*repeat, while VARdone is false,
*2*let VARrequiredmodule be the last element in VARstack. 
*2*remove the last element of VARstack. 
*2*set VARrequiredmodule.[[STATUS]] to "evaluated". 
*2*if VARrequiredmodule and VARmodule are the same module record, set VARdone to true. 
*0*return VARindex.       

############# END ## 296 ###########################
############# BEGIN ## 297 ###########################
ID= 15.2.1.16.5.2
Summary= ModuleExecution ( module )
Description= The ModuleExecution abstract operation is used by InnerModuleEvaluation to initialize the execution context of the module and evaluate the module's code within it.
*0*let VARmodulecxt be a new ecmascript code execution context. 
*0*set the function of VARmodulecxt to null. 
*0*assert: VARmodule.[[REALM]] is not undefined. 
*0*set the realm of VARmodulecxt to VARmodule.[[REALM]]. 
*0*set the scriptormodule of VARmodulecxt to VARmodule. 
*0*assert: VARmodule has been linked and declarations in its module environment have been instantiated. 
*0*set the variableenvironment of VARmodulecxt to VARmodule.[[ENVIRONMENT]]. 
*0*set the lexicalenvironment of VARmodulecxt to VARmodule.[[ENVIRONMENT]]. 
*0*suspend the currently running execution context. 
*0*push VARmodulecxt on to the execution context stack; VARmodulecxt is now the running execution context. 
*0*let VARresult be the result of evaluating VARmodule.[[ECMASCRIPTCODE]]. 
*0*suspend VARmodulecxt and remove it from the execution context stack. 
*0*resume the context that is now on the top of the execution context stack as the running execution context. 
*0*return FUNCcompletion(VARresult).       

############# END ## 297 ###########################
############# BEGIN ## 298 ###########################
ID= 15.2.1.18
Summary= Runtime Semantics: GetModuleNamespace ( module )
Description= The GetModuleNamespace abstract operation retrieves the Module Namespace Exotic object representing module's exports, lazily creating it the first time it was requested, and storing it in module.[[Namespace]] for future retrieval.
*0*assert: VARmodule is an instance of a concrete subclass of module record. 
*0*assert: VARmodule.[[STATUS]] is not "uninstantiated". 
*0*assert: if VARmodule.[[STATUS]] is "evaluated", VARmodule.[[EVALUATIONERROR]] is undefined. 
*0*let VARnamespace be VARmodule.[[NAMESPACE]]. 
*0*if VARnamespace is undefined, then
*1*let VARexportednames be ? VARmodule.getexportednames(« »). 
*1*let VARunambiguousnames be a new empty list. 
*1*for each VARname that is an element of VARexportednames, do
*2*let VARresolution be ? VARmodule.resolveexport(VARname, « »). 
*2*if VARresolution is a resolvedbinding record, append VARname to VARunambiguousnames. 
*1*set VARnamespace to FUNCmodulenamespacecreate(VARmodule, VARunambiguousnames). 
*0*return VARnamespace.     

############# END ## 298 ###########################
############# BEGIN ## 299 ###########################
ID= 15.2.1.19
Summary= Runtime Semantics: TopLevelModuleEvaluationJob ( sourceText, hostDefined )
Description= A TopLevelModuleEvaluationJob with parameters sourceText and hostDefined is a job that parses, validates, and evaluates sourceText as a Module.
*0*assert: VARsourcetext is an ecmascript source text (see clause 10). 
*0*let VARrealm be the current realm record. 
*0*let VARm be FUNCparsemodule(VARsourcetext, VARrealm, VARhostdefined). 
*0*if VARm is a list of errors, then
*1*perform FUNChostreporterrors(VARm). 
*1*return FUNCnormalcompletion(undefined). 
*0*perform ? VARm.instantiate(). 
*0*assert: all dependencies of VARm have been transitively resolved and VARm is ready for evaluation. 
*0*return ? VARm.evaluate().     

############# END ## 299 ###########################
############# BEGIN ## 300 ###########################
ID= 18.2.1
Summary= eval ( x )
Description= The eval function is the  %eval% intrinsic object. When the eval function is called with one argument x, the following steps are taken:
*0*assert: the execution context stack has at least two elements. 
*0*let VARcallercontext be the second to top element of the execution context stack. 
*0*let VARcallerrealm be VARcallercontext's realm. 
*0*let VARcalleerealm be the current realm record. 
*0*perform ? FUNChostensurecancompilestrings(VARcallerrealm, VARcalleerealm). 
*0*return ? FUNCperformeval(VARx, VARcalleerealm, false, false).    

############# END ## 300 ###########################
############# BEGIN ## 301 ###########################
ID= 18.2.1.1
Summary= Runtime Semantics: PerformEval ( x, evalRealm, strictCaller, direct )
Description= The abstract operation PerformEval with arguments x, evalRealm, strictCaller, and direct performs the following steps:
*0*assert: if VARdirect is false, then VARstrictcaller is also false. 
*0*if FUNCtype(VARx) is not string, return VARx. 
*0*let VARthisenvrec be ! FUNCgetthisenvironment(). 
*0*if VARthisenvrec is a function environment record, then
*1*let VARf be VARthisenvrec.[[FUNCTIONOBJECT]]. 
*1*let VARinfunction be true. 
*1*let VARinmethod be VARthisenvrec.hassuperbinding(). 
*1*if VARf.[[CONSTRUCTORKIND]] is "derived", let VARinderivedconstructor be true; otherwise, let VARinderivedconstructor be false. 
*0*else,
*1*let VARinfunction be false. 
*1*let VARinmethod be false. 
*1*let VARinderivedconstructor be false. 
*0*let VARscript be the ecmascript code that is the result of parsing VARx, interpreted as utf-16 encoded unicode text as described in 6.1.4, for the goal symbol script. if VARinfunction is false, additional early error rules from 18.2.1.1.1 are applied. if VARinmethod is false, additional early error rules from 18.2.1.1.2 are applied. if VARinderivedconstructor is false, additional early error rules from 18.2.1.1.3 are applied. if the parse fails, throw a syntaxerror exception. if any early errors are detected, throw a syntaxerror or a referenceerror exception, depending on the type of the error (but see also clause 16). parsing and early error detection may be interweaved in an implementation-dependent manner. 
*0*if VARscript contains scriptbody is false, return undefined. 
*0*let VARbody be the scriptbody of VARscript. 
*0*if VARstrictcaller is true, let VARstricteval be true. 
*0*else, let VARstricteval be isstrict of VARscript. 
*0*let VARctx be the running execution context. 
*0*note: if VARdirect is true, VARctx will be the execution context that performed the direct eval. if VARdirect is false, VARctx will be the execution context for the invocation of the eval function. 
*0*if VARdirect is true, then
*1*let VARlexenv be FUNCnewdeclarativeenvironment(VARctx's lexicalenvironment). 
*1*let VARvarenv be VARctx's variableenvironment. 
*0*else,
*1*let VARlexenv be FUNCnewdeclarativeenvironment(VARevalrealm.[[GLOBALENV]]). 
*1*let VARvarenv be VARevalrealm.[[GLOBALENV]]. 
*0*if VARstricteval is true, set VARvarenv to VARlexenv. 
*0*if VARctx is not already suspended, suspend VARctx. 
*0*let VARevalcxt be a new ecmascript code execution context. 
*0*set the VARevalcxt's function to null. 
*0*set the VARevalcxt's realm to VARevalrealm. 
*0*set the VARevalcxt's scriptormodule to VARctx's scriptormodule. 
*0*set the VARevalcxt's variableenvironment to VARvarenv. 
*0*set the VARevalcxt's lexicalenvironment to VARlexenv. 
*0*push VARevalcxt on to the execution context stack; VARevalcxt is now the running execution context. 
*0*let VARresult be FUNCevaldeclarationinstantiation(VARbody, VARvarenv, VARlexenv, VARstricteval). 
*0*if VARresult.[[TYPE]] is normal, then
*1*set VARresult to the result of evaluating VARbody. 
*0*if VARresult.[[TYPE]] is normal and VARresult.[[VALUE]] is empty, then
*1*set VARresult to FUNCnormalcompletion(undefined). 
*0*suspend VARevalcxt and remove it from the execution context stack. 
*0*resume the context that is now on the top of the execution context stack as the running execution context. 
*0*return FUNCcompletion(VARresult).     

############# END ## 301 ###########################
############# BEGIN ## 302 ###########################
ID= 18.2.1.3
Summary= Runtime Semantics: EvalDeclarationInstantiation ( body, varEnv, lexEnv, strict )
Description= When the abstract operation EvalDeclarationInstantiation is called with arguments body, varEnv, lexEnv, and strict, the following steps are taken:
*0*let VARvarnames be the vardeclarednames of VARbody. 
*0*let VARvardeclarations be the varscopeddeclarations of VARbody. 
*0*let VARlexenvrec be VARlexenv's environmentrecord. 
*0*let VARvarenvrec be VARvarenv's environmentrecord. 
*0*if VARstrict is false, then
*1*if VARvarenvrec is a global environment record, then
*2*for each VARname in VARvarnames, do
*3*if VARvarenvrec.haslexicaldeclaration(VARname) is true, throw a syntaxerror exception. 
*3*note: eval will not create a global var declaration that would be shadowed by a global lexical declaration. 
*1*let VARthislex be VARlexenv. 
*1*assert: the following loop will terminate. 
*1*repeat, while VARthislex is not the same as VARvarenv,
*2*let VARthisenvrec be VARthislex's environmentrecord. 
*2*if VARthisenvrec is not an object environment record, then
*3*note: the environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts. 
*3*for each VARname in VARvarnames, do
*4*if VARthisenvrec.hasbinding(VARname) is true, then
*5*throw a syntaxerror exception. 
*5*note: annex b.3.5 defines alternate semantics for the above step. 
*4*note: a direct eval will not hoist var declaration over a like-named lexical declaration. 
*2*set VARthislex to VARthislex's outer environment reference. 
*0*let VARfunctionstoinitialize be a new empty list. 
*0*let VARdeclaredfunctionnames be a new empty list. 
*0*for each VARd in VARvardeclarations, in reverse list order, do
*1*if VARd is neither a variabledeclaration nor a forbinding nor a bindingidentifier, then
*2*assert: VARd is either a functiondeclaration, a generatordeclaration, an asyncfunctiondeclaration, or an asyncgeneratordeclaration. 
*2*note: if there are multiple function declarations for the same name, the last declaration is used. 
*2*let VARfn be the sole element of the boundnames of VARd. 
*2*if VARfn is not an element of VARdeclaredfunctionnames, then
*3*if VARvarenvrec is a global environment record, then
*4*let VARfndefinable be ? VARvarenvrec.candeclareglobalfunction(VARfn). 
*4*if VARfndefinable is false, throw a typeerror exception. 
*3*append VARfn to VARdeclaredfunctionnames. 
*3*insert VARd as the first element of VARfunctionstoinitialize. 
*0*note: annex b.3.3.3 adds additional steps at this point. 
*0*let VARdeclaredvarnames be a new empty list. 
*0*for each VARd in VARvardeclarations, do
*1*if VARd is a variabledeclaration, a forbinding, or a bindingidentifier, then
*2*for each string VARvn in the boundnames of VARd, do
*3*if VARvn is not an element of VARdeclaredfunctionnames, then
*4*if VARvarenvrec is a global environment record, then
*5*let VARvndefinable be ? VARvarenvrec.candeclareglobalvar(VARvn). 
*5*if VARvndefinable is false, throw a typeerror exception. 
*4*if VARvn is not an element of VARdeclaredvarnames, then
*5*append VARvn to VARdeclaredvarnames. 
*0*note: no abnormal terminations occur after this algorithm step unless VARvarenvrec is a global environment record and the global object is a proxy exotic object. 
*0*let VARlexdeclarations be the lexicallyscopeddeclarations of VARbody. 
*0*for each element VARd in VARlexdeclarations, do
*1*note: lexically declared names are only instantiated here but not initialized. 
*1*for each element VARdn of the boundnames of VARd, do
*2*if isconstantdeclaration of VARd is true, then
*3*perform ? VARlexenvrec.createimmutablebinding(VARdn, true). 
*2*else,
*3*perform ? VARlexenvrec.createmutablebinding(VARdn, false). 
*0*for each parse node VARf in VARfunctionstoinitialize, do
*1*let VARfn be the sole element of the boundnames of VARf. 
*1*let VARfo be the result of performing instantiatefunctionobject for VARf with argument VARlexenv. 
*1*if VARvarenvrec is a global environment record, then
*2*perform ? VARvarenvrec.createglobalfunctionbinding(VARfn, VARfo, true). 
*1*else,
*2*let VARbindingexists be VARvarenvrec.hasbinding(VARfn). 
*2*if VARbindingexists is false, then
*3*let VARstatus be ! VARvarenvrec.createmutablebinding(VARfn, true). 
*3*assert: VARstatus is not an abrupt completion because of validation preceding step 12. 
*3*perform ! VARvarenvrec.initializebinding(VARfn, VARfo). 
*2*else,
*3*perform ! VARvarenvrec.setmutablebinding(VARfn, VARfo, false). 
*0*for each string VARvn in VARdeclaredvarnames, in list order, do
*1*if VARvarenvrec is a global environment record, then
*2*perform ? VARvarenvrec.createglobalvarbinding(VARvn, true). 
*1*else,
*2*let VARbindingexists be VARvarenvrec.hasbinding(VARvn). 
*2*if VARbindingexists is false, then
*3*let VARstatus be ! VARvarenvrec.createmutablebinding(VARvn, true). 
*3*assert: VARstatus is not an abrupt completion because of validation preceding step 12. 
*3*perform ! VARvarenvrec.initializebinding(VARvn, undefined). 
*0*return FUNCnormalcompletion(empty).     

############# END ## 302 ###########################
############# BEGIN ## 303 ###########################
ID= 18.2.2
Summary= isFinite ( number )
Description= The isFinite function is the  %isFinite% intrinsic object. When the isFinite function is called with one argument number, the following steps are taken:
*0*let VARnum be ? FUNCtonumber(VARnumber). 
*0*if VARnum is nan, +∞, or -∞, return false. 
*0*otherwise, return true.    

############# END ## 303 ###########################
############# BEGIN ## 304 ###########################
ID= 18.2.3
Summary= isNaN ( number )
Description= The isNaN function is the  %isNaN% intrinsic object. When the isNaN function is called with one argument number, the following steps are taken:
*0*let VARnum be ? FUNCtonumber(VARnumber). 
*0*if VARnum is nan, return true. 
*0*otherwise, return false.    

############# END ## 304 ###########################
############# BEGIN ## 305 ###########################
ID= 18.2.4
Summary= parseFloat ( string )
Description= The parseFloat function produces a Number value dictated by interpretation of the contents of the string argument as a decimal literal.
*0*let VARinputstring be ? FUNCtostring(VARstring). 
*0*let VARtrimmedstring be a substring of VARinputstring consisting of the leftmost code unit that is not a strwhitespacechar and all code units to the right of that code unit. (in other words, remove leading white space.) if VARinputstring does not contain any such code units, let VARtrimmedstring be the empty string. 
*0*if neither VARtrimmedstring nor any prefix of VARtrimmedstring satisfies the syntax of a strdecimalliteral (see 7.1.3.1), return nan. 
*0*let VARnumberstring be the longest prefix of VARtrimmedstring, which might be VARtrimmedstring itself, that satisfies the syntax of a strdecimalliteral. 
*0*let VARmathfloat be mv of VARnumberstring. 
*0*if VARmathfloat=0, then
*1*if the first code unit of VARtrimmedstring is the code unit 0x002d (hyphen-minus), return -0. 
*1*return +0. 
*0*return the number value for VARmathfloat.    

############# END ## 305 ###########################
############# BEGIN ## 306 ###########################
ID= 18.2.5
Summary= parseInt ( string, radix )
Description= The parseInt function produces an integer value dictated by interpretation of the contents of the string argument according to the specified radix. Leading white space in string is ignored. If radix is undefined or 0, it is assumed to be 10 except when the number begins with the code unit pairs 0x or 0X, in which case a radix of 16 is assumed. If radix is 16, the number may also optionally begin with the code unit pairs 0x or 0X.
*0*let VARinputstring be ? FUNCtostring(VARstring). 
*0*let VARs be a newly created substring of VARinputstring consisting of the first code unit that is not a strwhitespacechar and all code units following that code unit. (in other words, remove leading white space.) if VARinputstring does not contain any such code unit, let VARs be the empty string. 
*0*let VARsign be 1. 
*0*if VARs is not empty and the first code unit of VARs is the code unit 0x002d (hyphen-minus), let VARsign be -1. 
*0*if VARs is not empty and the first code unit of VARs is the code unit 0x002b (plus sign) or the code unit 0x002d (hyphen-minus), remove the first code unit from VARs. 
*0*let VARr be ? FUNCtoint32(VARradix). 
*0*let VARstripprefix be true. 
*0*if VARr ≠ 0, then
*1*if VARr &lt; 2 or VARr &gt; 36, return nan. 
*1*if VARr ≠ 16, let VARstripprefix be false. 
*0*else VARr = 0,
*1*let VARr be 10. 
*0*if VARstripprefix is true, then
*1*if the length of VARs is at least 2 and the first two code units of VARs are either "0x" or "0x", remove the first two code units from VARs and let VARr be 16. 
*0*if VARs contains a code unit that is not a radix-VARr digit, let VARz be the substring of VARs consisting of all code units before the first such code unit; otherwise, let VARz be VARs. 
*0*if VARz is empty, return nan. 
*0*let VARmathint be the mathematical integer value that is represented by VARz in radix-VARr notation, using the letters a-z and a-z for digits with values 10 through 35. (however, if VARr is 10 and VARz contains more than 20 significant digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the implementation; and if VARr is not 2, 4, 8, 10, 16, or 32, then VARmathint may be an implementation-dependent approximation to the mathematical integer value that is represented by VARz in radix-VARr notation.) 
*0*if VARmathint = 0, then
*1*if VARsign = -1, return -0. 
*1*return +0. 
*0*let VARnumber be the number value for VARmathint. 
*0*return VARsign × VARnumber.    

############# END ## 306 ###########################
############# BEGIN ## 307 ###########################
ID= 18.2.6.1.1
Summary= Runtime Semantics: Encode ( string, unescapedSet )
Description= The encoding and escaping process is described by the abstract operation Encode taking two String arguments string and unescapedSet.
*0*let VARstrlen be the number of code units in VARstring. 
*0*let VARr be the empty string. 
*0*let VARk be 0. 
*0*repeat,
*1*if VARk equals VARstrlen, return VARr. 
*1*let VARc be the code unit at index VARk within VARstring. 
*1*if VARc is in VARunescapedset, then
*2*let VARs be the string value containing only the code unit VARc. 
*2*set VARr to the string-concatenation of the previous value of VARr and VARs. 
*1*else VARc is not in VARunescapedset,
*2*if VARc is a trailing surrogate, throw a urierror exception. 
*2*if VARc is not a leading surrogate, then
*3*let VARv be the code point with the same numeric value as code unit VARc. 
*2*else,
*3*increase VARk by 1. 
*3*if VARk equals VARstrlen, throw a urierror exception. 
*3*let VARkchar be the code unit at index VARk within VARstring. 
*3*if VARkchar is not a trailing surrogate, throw a urierror exception. 
*3*let VARv be FUNCutf16decode(VARc, VARkchar). 
*2*let VARoctets be the list of octets resulting by applying the utf-8 transformation to VARv. 
*2*for each element VARoctet of VARoctets in list order, do
*3*let VARs be the string-concatenation of:"%" the string representation of VARoctet, formatted as a two-digit uppercase hexadecimal number, padded to the left with a zero if necessary 
*3*set VARr to the string-concatenation of the previous value of VARr and VARs. 
*1*increase VARk by 1.      

############# END ## 307 ###########################
############# BEGIN ## 308 ###########################
ID= 18.2.6.1.2
Summary= Runtime Semantics: Decode ( string, reservedSet )
Description= The unescaping and decoding process is described by the abstract operation Decode taking two String arguments string and reservedSet.
*0*let VARstrlen be the number of code units in VARstring. 
*0*let VARr be the empty string. 
*0*let VARk be 0. 
*0*repeat,
*1*if VARk equals VARstrlen, return VARr. 
*1*let VARc be the code unit at index VARk within VARstring. 
*1*if VARc is not the code unit 0x0025 (percent sign), then
*2*let VARs be the string value containing only the code unit VARc. 
*1*else VARc is the code unit 0x0025 (percent sign),
*2*let VARstart be VARk. 
*2*if VARk + 2 is greater than or equal to VARstrlen, throw a urierror exception. 
*2*if the code units at index (VARk + 1) and (VARk + 2) within VARstring do not represent hexadecimal digits, throw a urierror exception. 
*2*let VARb be the 8-bit value represented by the two hexadecimal digits at index (VARk + 1) and (VARk + 2). 
*2*increment VARk by 2. 
*2*if the most significant bit in VARb is 0, then
*3*let VARc be the code unit whose value is VARb. 
*3*if VARc is not in VARreservedset, then
*4*let VARs be the string value containing only the code unit VARc. 
*3*else VARc is in VARreservedset,
*4*let VARs be the substring of VARstring from index VARstart to index VARk inclusive. 
*2*else the most significant bit in VARb is 1,
*3*let VARn be the smallest nonnegative integer such that (VARb &lt;&lt; VARn) &amp; 0x80 is equal to 0. 
*3*if VARn equals 1 or VARn is greater than 4, throw a urierror exception. 
*3*let VARoctets be a list of 8-bit integers of size VARn. 
*3*set VARoctets[0] to VARb. 
*3*if VARk + (3 × (VARn - 1)) is greater than or equal to VARstrlen, throw a urierror exception. 
*3*let VARj be 1. 
*3*repeat, while VARj &lt; VARn
*4*increment VARk by 1. 
*4*if the code unit at index VARk within VARstring is not the code unit 0x0025 (percent sign), throw a urierror exception. 
*4*if the code units at index (VARk + 1) and (VARk + 2) within VARstring do not represent hexadecimal digits, throw a urierror exception. 
*4*let VARb be the 8-bit value represented by the two hexadecimal digits at index (VARk + 1) and (VARk + 2). 
*4*if the two most significant bits in VARb are not 10, throw a urierror exception. 
*4*increment VARk by 2. 
*4*set VARoctets[VARj] to VARb. 
*4*increment VARj by 1. 
*3*if VARoctets does not contain a valid utf-8 encoding of a unicode code point, throw a urierror exception. 
*3*let VARv be the value obtained by applying the utf-8 transformation to VARoctets, that is, from a list of octets into a 21-bit value. 
*3*let VARs be the string value whose elements are, in order, the elements in FUNCutf16encoding(VARv). 
*1*set VARr to the string-concatenation of the previous value of VARr and VARs. 
*1*increase VARk by 1.      

############# END ## 308 ###########################
############# BEGIN ## 309 ###########################
ID= 18.2.6.2
Summary= decodeURI ( encodedURI )
Description= The decodeURI function computes a new version of a URI in which each escape sequence and UTF-8 encoding of the sort that might be introduced by the encodeURI function is replaced with the UTF-16 encoding of the code points that it represents. Escape sequences that could not have been introduced by encodeURI are not replaced.
*0*let VARuristring be ? FUNCtostring(VARencodeduri). 
*0*let VARreserveduriset be a string containing one instance of each code unit valid in urireserved plus "#". 
*0*return ? FUNCdecode(VARuristring, VARreserveduriset).     

############# END ## 309 ###########################
############# BEGIN ## 310 ###########################
ID= 18.2.6.3
Summary= decodeURIComponent ( encodedURIComponent )
Description= The decodeURIComponent function computes a new version of a URI in which each escape sequence and UTF-8 encoding of the sort that might be introduced by the encodeURIComponent function is replaced with the UTF-16 encoding of the code points that it represents.
*0*let VARcomponentstring be ? FUNCtostring(VARencodeduricomponent). 
*0*let VARreserveduricomponentset be the empty string. 
*0*return ? FUNCdecode(VARcomponentstring, VARreserveduricomponentset).     

############# END ## 310 ###########################
############# BEGIN ## 311 ###########################
ID= 18.2.6.4
Summary= encodeURI ( uri )
Description= The encodeURI function computes a new version of a UTF-16 encoded (6.1.4) URI in which each instance of certain code points is replaced by one, two, three, or four escape sequences representing the UTF-8 encoding of the code points.
*0*let VARuristring be ? FUNCtostring(VARuri). 
*0*let VARunescapeduriset be a string containing one instance of each code unit valid in urireserved and uriunescaped plus "#". 
*0*return ? FUNCencode(VARuristring, VARunescapeduriset).     

############# END ## 311 ###########################
############# BEGIN ## 312 ###########################
ID= 18.2.6.5
Summary= encodeURIComponent ( uriComponent )
Description= The encodeURIComponent function computes a new version of a UTF-16 encoded (6.1.4) URI in which each instance of certain code points is replaced by one, two, three, or four escape sequences representing the UTF-8 encoding of the code point.
*0*let VARcomponentstring be ? FUNCtostring(VARuricomponent). 
*0*let VARunescapeduricomponentset be a string containing one instance of each code unit valid in uriunescaped. 
*0*return ? FUNCencode(VARcomponentstring, VARunescapeduricomponentset).     

############# END ## 312 ###########################
############# BEGIN ## 313 ###########################
ID= 19.1.1.1
Summary= Object ( [ value ] )
Description= When Object function is called with optional argument value, the following steps are taken:
*0*if newtarget is neither undefined nor the active function, then
*1*return ? FUNCordinarycreatefromconstructor(newtarget, "%objectprototype%"). 
*0*if VARvalue is null, undefined or not supplied, return FUNCobjectcreate(%objectprototype%). 
*0*return ! FUNCtoobject(VARvalue).     

############# END ## 313 ###########################
############# BEGIN ## 314 ###########################
ID= 19.1.2.1
Summary= Object.assign ( target, ...sources )
Description= The assign function is used to copy the values of all of the enumerable own properties from one or more source objects to a target object. When the assign function is called, the following steps are taken:
*0*let VARto be ? FUNCtoobject(VARtarget). 
*0*if only one argument was passed, return VARto. 
*0*let VARsources be the list of argument values starting with the second argument. 
*0*for each element VARnextsource of VARsources, in ascending index order, do
*1*if VARnextsource is undefined or null, let VARkeys be a new empty list. 
*1*else,
*2*let VARfrom be ! FUNCtoobject(VARnextsource). 
*2*let VARkeys be ? VARfrom.[[OWNPROPERTYKEYS]](). 
*1*for each element VARnextkey of VARkeys in list order, do
*2*let VARdesc be ? VARfrom.[[GETOWNPROPERTY]](VARnextkey). 
*2*if VARdesc is not undefined and VARdesc.[[ENUMERABLE]] is true, then
*3*let VARpropvalue be ? FUNCget(VARfrom, VARnextkey). 
*3*perform ? FUNCset(VARto, VARnextkey, VARpropvalue, true). 
*0*return VARto.     

############# END ## 314 ###########################
############# BEGIN ## 315 ###########################
ID= 19.1.2.2
Summary= Object.create ( O, Properties )
Description= The create function creates a new object with a specified prototype. When the create function is called, the following steps are taken:
*0*if FUNCtype(VARo) is neither object nor null, throw a typeerror exception. 
*0*let VARobj be FUNCobjectcreate(VARo). 
*0*if VARproperties is not undefined, then
*1*return ? FUNCobjectdefineproperties(VARobj, VARproperties). 
*0*return VARobj.     

############# END ## 315 ###########################
############# BEGIN ## 316 ###########################
ID= 19.1.2.3
Summary= Object.defineProperties ( O, Properties )
Description= The defineProperties function is used to add own properties and/or update the attributes of existing own properties of an object. When the defineProperties function is called, the following steps are taken:
*0*return ? FUNCobjectdefineproperties(VARo, VARproperties).     

############# END ## 316 ###########################
############# BEGIN ## 317 ###########################
ID= 19.1.2.3.1
Summary= Runtime Semantics: ObjectDefineProperties ( O, Properties )
Description= The abstract operation ObjectDefineProperties with arguments O and Properties performs the following steps:
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*let VARprops be ? FUNCtoobject(VARproperties). 
*0*let VARkeys be ? VARprops.[[OWNPROPERTYKEYS]](). 
*0*let VARdescriptors be a new empty list. 
*0*for each element VARnextkey of VARkeys in list order, do
*1*let VARpropdesc be ? VARprops.[[GETOWNPROPERTY]](VARnextkey). 
*1*if VARpropdesc is not undefined and VARpropdesc.[[ENUMERABLE]] is true, then
*2*let VARdescobj be ? FUNCget(VARprops, VARnextkey). 
*2*let VARdesc be ? FUNCtopropertydescriptor(VARdescobj). 
*2*append the pair (a two element list) consisting of VARnextkey and VARdesc to the end of VARdescriptors. 
*0*for each VARpair from VARdescriptors in list order, do
*1*let VARp be the first element of VARpair. 
*1*let VARdesc be the second element of VARpair. 
*1*perform ? FUNCdefinepropertyorthrow(VARo, VARp, VARdesc). 
*0*return VARo.      

############# END ## 317 ###########################
############# BEGIN ## 318 ###########################
ID= 19.1.2.4
Summary= Object.defineProperty ( O, P, Attributes )
Description= The defineProperty function is used to add an own property and/or update the attributes of an existing own property of an object. When the defineProperty function is called, the following steps are taken:
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*let VARkey be ? FUNCtopropertykey(VARp). 
*0*let VARdesc be ? FUNCtopropertydescriptor(VARattributes). 
*0*perform ? FUNCdefinepropertyorthrow(VARo, VARkey, VARdesc). 
*0*return VARo.     

############# END ## 318 ###########################
############# BEGIN ## 319 ###########################
ID= 19.1.2.5
Summary= Object.entries ( O )
Description= When the entries function is called with argument O, the following steps are taken:
*0*let VARobj be ? FUNCtoobject(VARo). 
*0*let VARnamelist be ? FUNCenumerableownpropertynames(VARobj, "key+value"). 
*0*return FUNCcreatearrayfromlist(VARnamelist).     

############# END ## 319 ###########################
############# BEGIN ## 320 ###########################
ID= 19.1.2.6
Summary= Object.freeze ( O )
Description= When the freeze function is called, the following steps are taken:
*0*if FUNCtype(VARo) is not object, return VARo. 
*0*let VARstatus be ? FUNCsetintegritylevel(VARo, "frozen"). 
*0*if VARstatus is false, throw a typeerror exception. 
*0*return VARo.     

############# END ## 320 ###########################
############# BEGIN ## 321 ###########################
ID= 19.1.2.7
Summary= Object.getOwnPropertyDescriptor ( O, P )
Description= When the getOwnPropertyDescriptor function is called, the following steps are taken:
*0*let VARobj be ? FUNCtoobject(VARo). 
*0*let VARkey be ? FUNCtopropertykey(VARp). 
*0*let VARdesc be ? VARobj.[[GETOWNPROPERTY]](VARkey). 
*0*return FUNCfrompropertydescriptor(VARdesc).     

############# END ## 321 ###########################
############# BEGIN ## 322 ###########################
ID= 19.1.2.8
Summary= Object.getOwnPropertyDescriptors ( O )
Description= When the getOwnPropertyDescriptors function is called, the following steps are taken:
*0*let VARobj be ? FUNCtoobject(VARo). 
*0*let VARownkeys be ? VARobj.[[OWNPROPERTYKEYS]](). 
*0*let VARdescriptors be ! FUNCobjectcreate(%objectprototype%). 
*0*for each element VARkey of VARownkeys in list order, do
*1*let VARdesc be ? VARobj.[[GETOWNPROPERTY]](VARkey). 
*1*let VARdescriptor be ! FUNCfrompropertydescriptor(VARdesc). 
*1*if VARdescriptor is not undefined, perform ! FUNCcreatedataproperty(VARdescriptors, VARkey, VARdescriptor). 
*0*return VARdescriptors.     

############# END ## 322 ###########################
############# BEGIN ## 323 ###########################
ID= 19.1.2.9
Summary= Object.getOwnPropertyNames ( O )
Description= When the getOwnPropertyNames function is called, the following steps are taken:
*0*return ? FUNCgetownpropertykeys(VARo, string).     

############# END ## 323 ###########################
############# BEGIN ## 324 ###########################
ID= 19.1.2.10
Summary= Object.getOwnPropertySymbols ( O )
Description= When the getOwnPropertySymbols function is called with argument O, the following steps are taken:
*0*return ? FUNCgetownpropertykeys(VARo, symbol).     

############# END ## 324 ###########################
############# BEGIN ## 325 ###########################
ID= 19.1.2.10.1
Summary= Runtime Semantics: GetOwnPropertyKeys ( O, Type )
Description= The abstract operation GetOwnPropertyKeys is called with arguments O and Type where O is an Object and Type is one of the ECMAScript specification types String or Symbol. The following steps are taken:
*0*let VARobj be ? FUNCtoobject(VARo). 
*0*let VARkeys be ? VARobj.[[OWNPROPERTYKEYS]](). 
*0*let VARnamelist be a new empty list. 
*0*for each element VARnextkey of VARkeys in list order, do
*1*if FUNCtype(VARnextkey) is VARtype, then
*2*append VARnextkey as the last element of VARnamelist. 
*0*return FUNCcreatearrayfromlist(VARnamelist).      

############# END ## 325 ###########################
############# BEGIN ## 326 ###########################
ID= 19.1.2.11
Summary= Object.getPrototypeOf ( O )
Description= When the getPrototypeOf function is called with argument O, the following steps are taken:
*0*let VARobj be ? FUNCtoobject(VARo). 
*0*return ? VARobj.[[GETPROTOTYPEOF]]().     

############# END ## 326 ###########################
############# BEGIN ## 327 ###########################
ID= 19.1.2.12
Summary= Object.is ( value1, value2 )
Description= When the is function is called with arguments value1 and value2, the following steps are taken:
*0*return FUNCsamevalue(VARvalue1, VARvalue2).     

############# END ## 327 ###########################
############# BEGIN ## 328 ###########################
ID= 19.1.2.13
Summary= Object.isExtensible ( O )
Description= When the isExtensible function is called with argument O, the following steps are taken:
*0*if FUNCtype(VARo) is not object, return false. 
*0*return ? FUNCisextensible(VARo).     

############# END ## 328 ###########################
############# BEGIN ## 329 ###########################
ID= 19.1.2.14
Summary= Object.isFrozen ( O )
Description= When the isFrozen function is called with argument O, the following steps are taken:
*0*if FUNCtype(VARo) is not object, return true. 
*0*return ? FUNCtestintegritylevel(VARo, "frozen").     

############# END ## 329 ###########################
############# BEGIN ## 330 ###########################
ID= 19.1.2.15
Summary= Object.isSealed ( O )
Description= When the isSealed function is called with argument O, the following steps are taken:
*0*if FUNCtype(VARo) is not object, return true. 
*0*return ? FUNCtestintegritylevel(VARo, "sealed").     

############# END ## 330 ###########################
############# BEGIN ## 331 ###########################
ID= 19.1.2.16
Summary= Object.keys ( O )
Description= When the keys function is called with argument O, the following steps are taken:
*0*let VARobj be ? FUNCtoobject(VARo). 
*0*let VARnamelist be ? FUNCenumerableownpropertynames(VARobj, "key"). 
*0*return FUNCcreatearrayfromlist(VARnamelist).     

############# END ## 331 ###########################
############# BEGIN ## 332 ###########################
ID= 19.1.2.17
Summary= Object.preventExtensions ( O )
Description= When the preventExtensions function is called, the following steps are taken:
*0*if FUNCtype(VARo) is not object, return VARo. 
*0*let VARstatus be ? VARo.[[PREVENTEXTENSIONS]](). 
*0*if VARstatus is false, throw a typeerror exception. 
*0*return VARo.     

############# END ## 332 ###########################
############# BEGIN ## 333 ###########################
ID= 19.1.2.19
Summary= Object.seal ( O )
Description= When the seal function is called, the following steps are taken:
*0*if FUNCtype(VARo) is not object, return VARo. 
*0*let VARstatus be ? FUNCsetintegritylevel(VARo, "sealed"). 
*0*if VARstatus is false, throw a typeerror exception. 
*0*return VARo.     

############# END ## 333 ###########################
############# BEGIN ## 334 ###########################
ID= 19.1.2.20
Summary= Object.setPrototypeOf ( O, proto )
Description= When the setPrototypeOf function is called with arguments O and proto, the following steps are taken:
*0*let VARo be ? FUNCrequireobjectcoercible(VARo). 
*0*if FUNCtype(VARproto) is neither object nor null, throw a typeerror exception. 
*0*if FUNCtype(VARo) is not object, return VARo. 
*0*let VARstatus be ? VARo.[[SETPROTOTYPEOF]](VARproto). 
*0*if VARstatus is false, throw a typeerror exception. 
*0*return VARo.     

############# END ## 334 ###########################
############# BEGIN ## 335 ###########################
ID= 19.1.2.21
Summary= Object.values ( O )
Description= When the values function is called with argument O, the following steps are taken:
*0*let VARobj be ? FUNCtoobject(VARo). 
*0*let VARnamelist be ? FUNCenumerableownpropertynames(VARobj, "value"). 
*0*return FUNCcreatearrayfromlist(VARnamelist).     

############# END ## 335 ###########################
############# BEGIN ## 336 ###########################
ID= 19.1.3.2
Summary= Object.prototype.hasOwnProperty ( V )
Description= When the hasOwnProperty method is called with argument V, the following steps are taken:
*0*let VARp be ? FUNCtopropertykey(VARv). 
*0*let VARo be ? FUNCtoobject(this value). 
*0*return ? FUNChasownproperty(VARo, VARp).     

############# END ## 336 ###########################
############# BEGIN ## 337 ###########################
ID= 19.1.3.3
Summary= Object.prototype.isPrototypeOf ( V )
Description= When the isPrototypeOf method is called with argument V, the following steps are taken:
*0*if FUNCtype(VARv) is not object, return false. 
*0*let VARo be ? FUNCtoobject(this value). 
*0*repeat,
*1*let VARv be ? VARv.[[GETPROTOTYPEOF]](). 
*1*if VARv is null, return false. 
*1*if FUNCsamevalue(VARo, VARv) is true, return true.     

############# END ## 337 ###########################
############# BEGIN ## 338 ###########################
ID= 19.1.3.4
Summary= Object.prototype.propertyIsEnumerable ( V )
Description= When the propertyIsEnumerable method is called with argument V, the following steps are taken:
*0*let VARp be ? FUNCtopropertykey(VARv). 
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARdesc be ? VARo.[[GETOWNPROPERTY]](VARp). 
*0*if VARdesc is undefined, return false. 
*0*return VARdesc.[[ENUMERABLE]].     

############# END ## 338 ###########################
############# BEGIN ## 339 ###########################
ID= 19.1.3.5
Summary= Object.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
Description= When the toLocaleString method is called, the following steps are taken:
*0*let VARo be the this value. 
*0*return ? FUNCinvoke(VARo, "tostring").     

############# END ## 339 ###########################
############# BEGIN ## 340 ###########################
ID= 19.1.3.6
Summary= Object.prototype.toString ( )
Description= When the toString method is called, the following steps are taken:
*0*if the this value is undefined, return "[object undefined]". 
*0*if the this value is null, return "[object null]". 
*0*let VARo be ! FUNCtoobject(this value). 
*0*let VARisarray be ? FUNCisarray(VARo). 
*0*if VARisarray is true, let VARbuiltintag be "array". 
*0*else if VARo is a string exotic object, let VARbuiltintag be "string". 
*0*else if VARo has a [[PARAMETERMAP]] internal slot, let VARbuiltintag be "arguments". 
*0*else if VARo has a [[CALL]] internal method, let VARbuiltintag be "function". 
*0*else if VARo has an [[ERRORDATA]] internal slot, let VARbuiltintag be "error". 
*0*else if VARo has a [[BOOLEANDATA]] internal slot, let VARbuiltintag be "boolean". 
*0*else if VARo has a [[NUMBERDATA]] internal slot, let VARbuiltintag be "number". 
*0*else if VARo has a [[DATEVALUE]] internal slot, let VARbuiltintag be "date". 
*0*else if VARo has a [[REGEXPMATCHER]] internal slot, let VARbuiltintag be "regexp". 
*0*else, let VARbuiltintag be "object". 
*0*let VARtag be ? FUNCget(VARo, @@tostringtag). 
*0*if FUNCtype(VARtag) is not string, let VARtag be VARbuiltintag. 
*0*return the string-concatenation of "[object ", VARtag, and "]".     

############# END ## 340 ###########################
############# BEGIN ## 341 ###########################
ID= 19.1.3.7
Summary= Object.prototype.valueOf ( )
Description= When the valueOf method is called, the following steps are taken:
*0*return ? FUNCtoobject(this value).     

############# END ## 341 ###########################
############# BEGIN ## 342 ###########################
ID= 19.2.1.1
Summary= Function ( p1, p2, … , pn, body )
Description= The last argument specifies the body (executable code) of a function; any preceding arguments specify formal parameters.
*0*let VARc be the active function object. 
*0*let VARargs be the VARargumentslist that was passed to this function by [[CALL]] or [[CONSTRUCT]]. 
*0*return ? FUNCcreatedynamicfunction(VARc, newtarget, "normal", VARargs).     

############# END ## 342 ###########################
############# BEGIN ## 343 ###########################
ID= 19.2.1.1.1
Summary= Runtime Semantics: CreateDynamicFunction ( constructor, newTarget, kind, args )
Description= The abstract operation CreateDynamicFunction is called with arguments constructor, newTarget, kind, and args. constructor is the constructor function that is performing this action, newTarget is the constructor that new was initially applied to, kind is either "normal", "generator", "async", or "async generator", and args is a List containing the actual argument values that were passed to constructor. The following steps are taken:
*0*assert: the execution context stack has at least two elements. 
*0*let VARcallercontext be the second to top element of the execution context stack. 
*0*let VARcallerrealm be VARcallercontext's realm. 
*0*let VARcalleerealm be the current realm record. 
*0*perform ? FUNChostensurecancompilestrings(VARcallerrealm, VARcalleerealm). 
*0*if VARnewtarget is undefined, set VARnewtarget to VARconstructor. 
*0*if VARkind is "normal", then
*1*let VARgoal be the grammar symbol functionbody[~yield, ~await]. 
*1*let VARparametergoal be the grammar symbol formalparameters[~yield, ~await]. 
*1*let VARfallbackproto be "%functionprototype%". 
*0*else if VARkind is "generator", then
*1*let VARgoal be the grammar symbol generatorbody. 
*1*let VARparametergoal be the grammar symbol formalparameters[+yield, ~await]. 
*1*let VARfallbackproto be "%generator%". 
*0*else if VARkind is "async", then
*1*assert: VARkind is "async". 
*1*let VARgoal be the grammar symbol asyncfunctionbody. 
*1*let VARparametergoal be the grammar symbol formalparameters[~yield, +await]. 
*1*let VARfallbackproto be "%asyncfunctionprototype%". 
*0*else,
*1*assert: VARkind is "async generator". 
*1*let VARgoal be the grammar symbol asyncgeneratorbody. 
*1*let VARparametergoal be the grammar symbol formalparameters[+yield, +await]. 
*1*let VARfallbackproto be "%asyncgenerator%". 
*0*let VARargcount be the number of elements in VARargs. 
*0*let VARp be the empty string. 
*0*if VARargcount = 0, let VARbodytext be the empty string. 
*0*else if VARargcount = 1, let VARbodytext be VARargs[0]. 
*0*else VARargcount &gt; 1,
*1*let VARfirstarg be VARargs[0]. 
*1*set VARp to ? FUNCtostring(VARfirstarg). 
*1*let VARk be 1. 
*1*repeat, while VARk &lt; VARargcount-1
*2*let VARnextarg be VARargs[VARk]. 
*2*let VARnextargstring be ? FUNCtostring(VARnextarg). 
*2*set VARp to the string-concatenation of the previous value of VARp, "," (a comma), and VARnextargstring. 
*2*increase VARk by 1. 
*1*let VARbodytext be VARargs[VARk]. 
*0*set VARbodytext to ? FUNCtostring(VARbodytext). 
*0*let VARparameters be the result of parsing VARp, interpreted as utf-16 encoded unicode text as described in 6.1.4, using VARparametergoal as the goal symbol. throw a syntaxerror exception if the parse fails. 
*0*let VARbody be the result of parsing VARbodytext, interpreted as utf-16 encoded unicode text as described in 6.1.4, using VARgoal as the goal symbol. throw a syntaxerror exception if the parse fails. 
*0*let VARstrict be containsusestrict of VARbody. 
*0*if any static semantics errors are detected for VARparameters or VARbody, throw a syntaxerror or a referenceerror exception, depending on the type of the error. if VARstrict is true, the early error rules for uniqueformalparameters:formalparameters are applied. parsing and early error detection may be interweaved in an implementation-dependent manner. 
*0*if VARstrict is true and issimpleparameterlist of VARparameters is false, throw a syntaxerror exception. 
*0*if any element of the boundnames of VARparameters also occurs in the lexicallydeclarednames of VARbody, throw a syntaxerror exception. 
*0*if VARbody contains supercall is true, throw a syntaxerror exception. 
*0*if VARparameters contains supercall is true, throw a syntaxerror exception. 
*0*if VARbody contains superproperty is true, throw a syntaxerror exception. 
*0*if VARparameters contains superproperty is true, throw a syntaxerror exception. 
*0*if VARkind is "generator" or "async generator", then
*1*if VARparameters contains yieldexpression is true, throw a syntaxerror exception. 
*0*if VARkind is "async" or "async generator", then
*1*if VARparameters contains awaitexpression is true, throw a syntaxerror exception. 
*0*if VARstrict is true, then
*1*if boundnames of VARparameters contains any duplicate elements, throw a syntaxerror exception. 
*0*let VARproto be ? FUNCgetprototypefromconstructor(VARnewtarget, VARfallbackproto). 
*0*let VARf be FUNCfunctionallocate(VARproto, VARstrict, VARkind). 
*0*let VARrealmf be VARf.[[REALM]]. 
*0*let VARscope be VARrealmf.[[GLOBALENV]]. 
*0*perform FUNCfunctioninitialize(VARf, normal, VARparameters, VARbody, VARscope). 
*0*if VARkind is "generator", then
*1*let VARprototype be FUNCobjectcreate(%generatorprototype%). 
*1*perform FUNCdefinepropertyorthrow(VARf, "prototype", propertydescriptor { [[VALUE]]: VARprototype, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }). 
*0*else if VARkind is "async generator", then
*1*let VARprototype be FUNCobjectcreate(%asyncgeneratorprototype%). 
*1*perform FUNCdefinepropertyorthrow(VARf, "prototype", propertydescriptor { [[VALUE]]: VARprototype, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }). 
*0*else if VARkind is "normal", perform FUNCmakeconstructor(VARf). 
*0*note: async functions are not constructable and do not have a [[CONSTRUCT]] internal method or a "prototype" property. 
*0*perform FUNCsetfunctionname(VARf, "anonymous"). 
*0*return VARf.      

############# END ## 343 ###########################
############# BEGIN ## 344 ###########################
ID= 19.2.3.1
Summary= Function.prototype.apply ( thisArg, argArray )
Description= When the apply method is called on an object func with arguments thisArg and argArray, the following steps are taken:
*0*if FUNCiscallable(VARfunc) is false, throw a typeerror exception. 
*0*if VARargarray is undefined or null, then
*1*perform FUNCpreparefortailcall(). 
*1*return ? FUNCcall(VARfunc, VARthisarg). 
*0*let VARarglist be ? FUNCcreatelistfromarraylike(VARargarray). 
*0*perform FUNCpreparefortailcall(). 
*0*return ? FUNCcall(VARfunc, VARthisarg, VARarglist).     

############# END ## 344 ###########################
############# BEGIN ## 345 ###########################
ID= 19.2.3.2
Summary= Function.prototype.bind ( thisArg, ...args )
Description= When the bind method is called with argument thisArg and zero or more args, it performs the following steps:
*0*let VARtarget be the this value. 
*0*if FUNCiscallable(VARtarget) is false, throw a typeerror exception. 
*0*let VARargs be a new (possibly empty) list consisting of all of the argument values provided after VARthisarg in order. 
*0*let VARf be ? FUNCboundfunctioncreate(VARtarget, VARthisarg, VARargs). 
*0*let VARtargethaslength be ? FUNChasownproperty(VARtarget, "length"). 
*0*if VARtargethaslength is true, then
*1*let VARtargetlen be ? FUNCget(VARtarget, "length"). 
*1*if FUNCtype(VARtargetlen) is not number, let VARl be 0. 
*1*else,
*2*let VARtargetlen be FUNCtointeger(VARtargetlen). 
*2*let VARl be the larger of 0 and the result of VARtargetlen minus the number of elements of VARargs. 
*0*else, let VARl be 0. 
*0*perform ! FUNCsetfunctionlength(VARf, VARl). 
*0*let VARtargetname be ? FUNCget(VARtarget, "name"). 
*0*if FUNCtype(VARtargetname) is not string, let VARtargetname be the empty string. 
*0*perform FUNCsetfunctionname(VARf, VARtargetname, "bound"). 
*0*return VARf.     

############# END ## 345 ###########################
############# BEGIN ## 346 ###########################
ID= 19.2.3.3
Summary= Function.prototype.call ( thisArg, ...args )
Description= When the call method is called on an object func with argument, thisArg and zero or more args, the following steps are taken:
*0*if FUNCiscallable(VARfunc) is false, throw a typeerror exception. 
*0*let VARarglist be a new empty list. 
*0*if this method was called with more than one argument, then in left to right order, starting with the second argument, append each argument as the last element of VARarglist. 
*0*perform FUNCpreparefortailcall(). 
*0*return ? FUNCcall(VARfunc, VARthisarg, VARarglist).     

############# END ## 346 ###########################
############# BEGIN ## 347 ###########################
ID= 19.2.3.5
Summary= Function.prototype.toString ( )
Description= When the toString method is called on an object func, the following steps are taken:
*0*if VARfunc is a bound function exotic object, then
*1*return an implementation-dependent string source code representation of VARfunc. the representation must conform to the rules below. it is implementation-dependent whether the representation includes bound function information or information about the target function. 
*0*if FUNCtype(VARfunc) is object and is either a built-in function object or has an [[ECMASCRIPTCODE]] internal slot, then
*1*return an implementation-dependent string source code representation of VARfunc. the representation must conform to the rules below. 
*0*throw a typeerror exception.     

############# END ## 347 ###########################
############# BEGIN ## 348 ###########################
ID= 19.2.3.6
Summary= Function.prototype [ @@hasInstance ] ( V )
Description= When the @@hasInstance method of an object F is called with value V, the following steps are taken:
*0*let VARf be the this value. 
*0*return ? FUNCordinaryhasinstance(VARf, VARv).     

############# END ## 348 ###########################
############# BEGIN ## 349 ###########################
ID= 19.3.1.1
Summary= Boolean ( value )
Description= When Boolean is called with argument value, the following steps are taken:
*0*let VARb be FUNCtoboolean(VARvalue). 
*0*if newtarget is undefined, return VARb. 
*0*let VARo be ? FUNCordinarycreatefromconstructor(newtarget, "%booleanprototype%", « [[BOOLEANDATA]] »). 
*0*set VARo.[[BOOLEANDATA]] to VARb. 
*0*return VARo.     

############# END ## 349 ###########################
############# BEGIN ## 350 ###########################
ID= 19.3.3.2
Summary= Boolean.prototype.toString ( )
Description= The following steps are taken:
*0*let VARb be ? thisbooleanvalue(this value). 
*0*if VARb is true, return "true"; else return "false".     

############# END ## 350 ###########################
############# BEGIN ## 351 ###########################
ID= 19.3.3.3
Summary= Boolean.prototype.valueOf ( )
Description= The following steps are taken:
*0*return ? thisbooleanvalue(this value).     

############# END ## 351 ###########################
############# BEGIN ## 352 ###########################
ID= 19.4.1.1
Summary= Symbol ( [ description ] )
Description= When Symbol is called with optional argument description, the following steps are taken:
*0*if newtarget is not undefined, throw a typeerror exception. 
*0*if VARdescription is undefined, let VARdescstring be undefined. 
*0*else, let VARdescstring be ? FUNCtostring(VARdescription). 
*0*return a new unique symbol value whose [[DESCRIPTION]] value is VARdescstring.     

############# END ## 352 ###########################
############# BEGIN ## 353 ###########################
ID= 19.4.2.2
Summary= Symbol.for ( key )
Description= When Symbol.for is called with argument key it performs the following steps:
*0*let VARstringkey be ? FUNCtostring(VARkey). 
*0*for each element VARe of the globalsymbolregistry list, do
*1*if FUNCsamevalue(VARe.[[KEY]], VARstringkey) is true, return VARe.[[SYMBOL]]. 
*0*assert: globalsymbolregistry does not currently contain an entry for VARstringkey. 
*0*let VARnewsymbol be a new unique symbol value whose [[DESCRIPTION]] value is VARstringkey. 
*0*append the record { [[KEY]]: VARstringkey, [[SYMBOL]]: VARnewsymbol } to the globalsymbolregistry list. 
*0*return VARnewsymbol.     

############# END ## 353 ###########################
############# BEGIN ## 354 ###########################
ID= 19.4.2.6
Summary= Symbol.keyFor ( sym )
Description= When Symbol.keyFor is called with argument sym it performs the following steps:
*0*if FUNCtype(VARsym) is not symbol, throw a typeerror exception. 
*0*for each element VARe of the globalsymbolregistry list (see 19.4.2.2), do
*1*if FUNCsamevalue(VARe.[[SYMBOL]], VARsym) is true, return VARe.[[KEY]]. 
*0*assert: globalsymbolregistry does not currently contain an entry for VARsym. 
*0*return undefined.     

############# END ## 354 ###########################
############# BEGIN ## 355 ###########################
ID= 19.4.3.2
Summary= Symbol.prototype.toString ( )
Description= The following steps are taken:
*0*let VARsym be ? FUNCthissymbolvalue(this value). 
*0*return FUNCsymboldescriptivestring(VARsym).     

############# END ## 355 ###########################
############# BEGIN ## 356 ###########################
ID= 19.4.3.2.1
Summary= Runtime Semantics: SymbolDescriptiveString ( sym )
Description= When the abstract operation SymbolDescriptiveString is called with argument sym, the following steps are taken:
*0*assert: FUNCtype(VARsym) is symbol. 
*0*let VARdesc be VARsym's [[DESCRIPTION]] value. 
*0*if VARdesc is undefined, let VARdesc be the empty string. 
*0*assert: FUNCtype(VARdesc) is string. 
*0*return the string-concatenation of "symbol(", VARdesc, and ")".      

############# END ## 356 ###########################
############# BEGIN ## 357 ###########################
ID= 19.4.3.3
Summary= Symbol.prototype.valueOf ( )
Description= The following steps are taken:
*0*return ? FUNCthissymbolvalue(this value).     

############# END ## 357 ###########################
############# BEGIN ## 358 ###########################
ID= 19.4.3.4
Summary= Symbol.prototype [ @@toPrimitive ] ( hint )
Description= This function is called by ECMAScript language operators to convert a Symbol object to a primitive value. The allowed values for hint are "default", "number", and "string".
*0*return ? FUNCthissymbolvalue(this value).     

############# END ## 358 ###########################
############# BEGIN ## 359 ###########################
ID= 19.5.1.1
Summary= Error ( message )
Description= When the Error function is called with argument message, the following steps are taken:
*0*if newtarget is undefined, let VARnewtarget be the active function object, else let VARnewtarget be newtarget. 
*0*let VARo be ? FUNCordinarycreatefromconstructor(VARnewtarget, "%errorprototype%", « [[ERRORDATA]] »). 
*0*if VARmessage is not undefined, then
*1*let VARmsg be ? FUNCtostring(VARmessage). 
*1*let VARmsgdesc be the propertydescriptor { [[VALUE]]: VARmsg, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }. 
*1*perform ! FUNCdefinepropertyorthrow(VARo, "message", VARmsgdesc). 
*0*return VARo.     

############# END ## 359 ###########################
############# BEGIN ## 360 ###########################
ID= 19.5.3.4
Summary= Error.prototype.toString ( )
Description= The following steps are taken:
*0*let VARo be the this value. 
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*let VARname be ? FUNCget(VARo, "name"). 
*0*if VARname is undefined, let VARname be "error"; otherwise let VARname be ? FUNCtostring(VARname). 
*0*let VARmsg be ? FUNCget(VARo, "message"). 
*0*if VARmsg is undefined, let VARmsg be the empty string; otherwise let VARmsg be ? FUNCtostring(VARmsg). 
*0*if VARname is the empty string, return VARmsg. 
*0*if VARmsg is the empty string, return VARname. 
*0*return the string-concatenation of VARname, the code unit 0x003a (colon), the code unit 0x0020 (space), and VARmsg.     

############# END ## 360 ###########################
############# BEGIN ## 361 ###########################
ID= 19.5.6.1.1
Summary= NativeError ( message )
Description= When a NativeError function is called with argument message, the following steps are taken:
*0*if newtarget is undefined, let VARnewtarget be the active function object, else let VARnewtarget be newtarget. 
*0*let VARo be ? FUNCordinarycreatefromconstructor(VARnewtarget, "%VARnativeerrorprototype%", « [[ERRORDATA]] »). 
*0*if VARmessage is not undefined, then
*1*let VARmsg be ? FUNCtostring(VARmessage). 
*1*let VARmsgdesc be the propertydescriptor { [[VALUE]]: VARmsg, [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: true }. 
*1*perform ! FUNCdefinepropertyorthrow(VARo, "message", VARmsgdesc). 
*0*return VARo.      

############# END ## 361 ###########################
############# BEGIN ## 362 ###########################
ID= 20.1.1.1
Summary= Number ( value )
Description= When Number is called with argument value, the following steps are taken:
*0*if no arguments were passed to this function invocation, let VARn be +0. 
*0*else, let VARn be ? FUNCtonumber(VARvalue). 
*0*if newtarget is undefined, return VARn. 
*0*let VARo be ? FUNCordinarycreatefromconstructor(newtarget, "%numberprototype%", « [[NUMBERDATA]] »). 
*0*set VARo.[[NUMBERDATA]] to VARn. 
*0*return VARo.     

############# END ## 362 ###########################
############# BEGIN ## 363 ###########################
ID= 20.1.2.2
Summary= Number.isFinite ( number )
Description= When Number.isFinite is called with one argument number, the following steps are taken:
*0*if FUNCtype(VARnumber) is not number, return false. 
*0*if VARnumber is nan, +∞, or -∞, return false. 
*0*otherwise, return true.     

############# END ## 363 ###########################
############# BEGIN ## 364 ###########################
ID= 20.1.2.3
Summary= Number.isInteger ( number )
Description= When Number.isInteger is called with one argument number, the following steps are taken:
*0*if FUNCtype(VARnumber) is not number, return false. 
*0*if VARnumber is nan, +∞, or -∞, return false. 
*0*let VARinteger be FUNCtointeger(VARnumber). 
*0*if VARinteger is not equal to VARnumber, return false. 
*0*otherwise, return true.     

############# END ## 364 ###########################
############# BEGIN ## 365 ###########################
ID= 20.1.2.4
Summary= Number.isNaN ( number )
Description= When Number.isNaN is called with one argument number, the following steps are taken:
*0*if FUNCtype(VARnumber) is not number, return false. 
*0*if VARnumber is nan, return true. 
*0*otherwise, return false.     

############# END ## 365 ###########################
############# BEGIN ## 366 ###########################
ID= 20.1.2.5
Summary= Number.isSafeInteger ( number )
Description= When Number.isSafeInteger is called with one argument number, the following steps are taken:
*0*if FUNCtype(VARnumber) is not number, return false. 
*0*if VARnumber is nan, +∞, or -∞, return false. 
*0*let VARinteger be FUNCtointeger(VARnumber). 
*0*if VARinteger is not equal to VARnumber, return false. 
*0*if abs(VARinteger) ≤ 253-1, return true. 
*0*otherwise, return false.     

############# END ## 366 ###########################
############# BEGIN ## 367 ###########################
ID= 20.1.3.2
Summary= Number.prototype.toExponential ( fractionDigits )
Description= Return a String containing this Number value represented in decimal exponential notation with one digit before the significand's decimal point and fractionDigits digits after the significand's decimal point. If fractionDigits is undefined, include as many significand digits as necessary to uniquely specify the Number (just like in ToString except that in this case the Number is always output in exponential notation). Specifically, perform the following steps:
*0*let VARx be ? FUNCthisnumbervalue(this value). 
*0*let VARf be ? FUNCtointeger(VARfractiondigits). 
*0*assert: VARf is 0, when VARfractiondigits is undefined. 
*0*if VARx is nan, return the string "nan". 
*0*let VARs be the empty string. 
*0*if VARx &lt; 0, then
*1*let VARs be "-". 
*1*let VARx be -VARx. 
*0*if VARx = +∞, then
*1*return the string-concatenation of VARs and "infinity". 
*0*if VARf &lt; 0 or VARf &gt; 100, throw a rangeerror exception. 
*0*if VARx = 0, then
*1*let VARm be the string value consisting of VARf+1 occurrences of the code unit 0x0030 (digit zero). 
*1*let VARe be 0. 
*0*else VARx ≠ 0,
*1*if VARfractiondigits is not undefined, then
*2*let VARe and VARn be integers such that 10VARf ≤ VARn &lt; 10VARf+1 and for which the exact mathematical value of VARn × 10VARe-VARf - VARx is as close to zero as possible. if there are two such sets of VARe and VARn, pick the VARe and VARn for which VARn × 10VARe-VARf is larger. 
*1*else VARfractiondigits is undefined,
*2*let VARe, VARn, and VARf be integers such that VARf ≥ 0, 10VARf ≤ VARn &lt; 10VARf+1, the number value for VARn × 10VARe-VARf is VARx, and VARf is as small as possible. note that the decimal representation of VARn has VARf+1 digits, VARn is not divisible by 10, and the least significant digit of VARn is not necessarily uniquely determined by these criteria. 
*1*let VARm be the string value consisting of the digits of the decimal representation of VARn (in order, with no leading zeroes). 
*0*if VARf ≠ 0, then
*1*let VARa be the first element of VARm, and let VARb be the remaining VARf elements of VARm. 
*1*let VARm be the string-concatenation of VARa, ".", and VARb. 
*0*if VARe = 0, then
*1*let VARc be "+". 
*1*let VARd be "0". 
*0*else,
*1*if VARe &gt; 0, let VARc be "+". 
*1*else VARe ≤ 0,
*2*let VARc be "-". 
*2*let VARe be -VARe. 
*1*let VARd be the string value consisting of the digits of the decimal representation of VARe (in order, with no leading zeroes). 
*0*let VARm be the string-concatenation of VARm, "e", VARc, and VARd. 
*0*return the string-concatenation of VARs and VARm.     

############# END ## 367 ###########################
############# BEGIN ## 368 ###########################
ID= 20.1.3.3
Summary= Number.prototype.toFixed ( fractionDigits )
Description= toFixed returns a String containing this Number value represented in decimal fixed-point notation with fractionDigits digits after the decimal point. If fractionDigits is undefined, 0 is assumed.
*0*let VARx be ? FUNCthisnumbervalue(this value). 
*0*let VARf be ? FUNCtointeger(VARfractiondigits). (if VARfractiondigits is undefined, this step produces the value 0.) 
*0*if VARf &lt; 0 or VARf &gt; 100, throw a rangeerror exception. 
*0*if VARx is nan, return the string "nan". 
*0*let VARs be the empty string. 
*0*if VARx &lt; 0, then
*1*let VARs be "-". 
*1*let VARx be -VARx. 
*0*if VARx ≥ 1021, then
*1*let VARm be ! FUNCtostring(VARx). 
*0*else VARx &lt; 1021,
*1*let VARn be an integer for which the exact mathematical value of VARn ÷ 10VARf - VARx is as close to zero as possible. if there are two such VARn, pick the larger VARn. 
*1*if VARn = 0, let VARm be the string "0". otherwise, let VARm be the string value consisting of the digits of the decimal representation of VARn (in order, with no leading zeroes). 
*1*if VARf ≠ 0, then
*2*let VARk be the length of VARm. 
*2*if VARk ≤ VARf, then
*3*let VARz be the string value consisting of VARf+1-VARk occurrences of the code unit 0x0030 (digit zero). 
*3*let VARm be the string-concatenation of VARz and VARm. 
*3*let VARk be VARf + 1. 
*2*let VARa be the first VARk-VARf elements of VARm, and let VARb be the remaining VARf elements of VARm. 
*2*let VARm be the string-concatenation of VARa, ".", and VARb. 
*0*return the string-concatenation of VARs and VARm.     

############# END ## 368 ###########################
############# BEGIN ## 369 ###########################
ID= 20.1.3.5
Summary= Number.prototype.toPrecision ( precision )
Description= Return a String containing this Number value represented either in decimal exponential notation with one digit before the significand's decimal point and  precision-1 digits after the significand's decimal point or in decimal fixed notation with precision significant digits. If precision is undefined, call ToString instead. Specifically, perform the following steps:
*0*let VARx be ? FUNCthisnumbervalue(this value). 
*0*if VARprecision is undefined, return ! FUNCtostring(VARx). 
*0*let VARp be ? FUNCtointeger(VARprecision). 
*0*if VARx is nan, return the string "nan". 
*0*let VARs be the empty string. 
*0*if VARx &lt; 0, then
*1*let VARs be the code unit 0x002d (hyphen-minus). 
*1*let VARx be -VARx. 
*0*if VARx = +∞, then
*1*return the string-concatenation of VARs and "infinity". 
*0*if VARp &lt; 1 or VARp &gt; 100, throw a rangeerror exception. 
*0*if VARx = 0, then
*1*let VARm be the string value consisting of VARp occurrences of the code unit 0x0030 (digit zero). 
*1*let VARe be 0. 
*0*else VARx ≠ 0,
*1*let VARe and VARn be integers such that 10VARp-1 ≤ VARn &lt; 10VARp and for which the exact mathematical value of VARn × 10VARe-VARp+1 - VARx is as close to zero as possible. if there are two such sets of VARe and VARn, pick the VARe and VARn for which VARn × 10VARe-VARp+1 is larger. 
*1*let VARm be the string value consisting of the digits of the decimal representation of VARn (in order, with no leading zeroes). 
*1*if VARe &lt; -6 or VARe ≥ VARp, then
*2*assert: VARe ≠ 0. 
*2*if VARp ≠ 1, then
*3*let VARa be the first element of VARm, and let VARb be the remaining VARp-1 elements of VARm. 
*3*let VARm be the string-concatenation of VARa, ".", and VARb. 
*2*if VARe &gt; 0, then
*3*let VARc be the code unit 0x002b (plus sign). 
*2*else VARe &lt; 0,
*3*let VARc be the code unit 0x002d (hyphen-minus). 
*3*let VARe be -VARe. 
*2*let VARd be the string value consisting of the digits of the decimal representation of VARe (in order, with no leading zeroes). 
*2*return the string-concatenation of VARs, VARm, the code unit 0x0065 (latin small letter e), VARc, and VARd. 
*0*if VARe = VARp-1, return the string-concatenation of VARs and VARm. 
*0*if VARe ≥ 0, then
*1*let VARm be the string-concatenation of the first VARe+1 elements of VARm, the code unit 0x002e (full stop), and the remaining VARp- (VARe+1) elements of VARm. 
*0*else VARe &lt; 0,
*1*let VARm be the string-concatenation of the code unit 0x0030 (digit zero), the code unit 0x002e (full stop), -(VARe+1) occurrences of the code unit 0x0030 (digit zero), and the string VARm. 
*0*return the string-concatenation of VARs and VARm.     

############# END ## 369 ###########################
############# BEGIN ## 370 ###########################
ID= 20.1.3.6
Summary= Number.prototype.toString ( [ radix ] )
Description= The optional radix should be an integer value in the inclusive range 2 to 36. If radix is not present or is undefined the Number 10 is used as the value of radix.
*0*let VARx be ? FUNCthisnumbervalue(this value). 
*0*if VARradix is not present, let VARradixnumber be 10. 
*0*else if VARradix is undefined, let VARradixnumber be 10. 
*0*else, let VARradixnumber be ? FUNCtointeger(VARradix). 
*0*if VARradixnumber &lt; 2 or VARradixnumber &gt; 36, throw a rangeerror exception. 
*0*if VARradixnumber = 10, return ! FUNCtostring(VARx). 
*0*return the string representation of this number value using the radix specified by VARradixnumber. letters a-z are used for digits with values 10 through 35. the precise algorithm is implementation-dependent, however the algorithm should be a generalization of that specified in 7.1.12.1.     

############# END ## 370 ###########################
############# BEGIN ## 371 ###########################
ID= 20.1.3.7
Summary= Number.prototype.valueOf ( )
Description= None
*0*return ? FUNCthisnumbervalue(this value).     

############# END ## 371 ###########################
############# BEGIN ## 372 ###########################
ID= 20.2.2.11
Summary= Math.clz32 ( x )
Description= When Math.clz32 is called with one argument x, the following steps are taken:
*0*let VARn be FUNCtouint32(VARx). 
*0*let VARp be the number of leading zero bits in the 32-bit binary representation of VARn. 
*0*return VARp.     

############# END ## 372 ###########################
############# BEGIN ## 373 ###########################
ID= 20.2.2.17
Summary= Math.fround ( x )
Description= When Math.fround is called with argument x, the following steps are taken:
*0*if VARx is nan, return nan. 
*0*if VARx is one of +0, -0, +∞, -∞, return VARx. 
*0*let VARx32 be the result of converting VARx to a value in ieee 754-2008 binary32 format using roundtiestoeven. 
*0*let VARx64 be the result of converting VARx32 to a value in ieee 754-2008 binary64 format. 
*0*return the ecmascript number value corresponding to VARx64.     

############# END ## 373 ###########################
############# BEGIN ## 374 ###########################
ID= 20.2.2.19
Summary= Math.imul ( x, y )
Description= When Math.imul is called with arguments x and y, the following steps are taken:
*0*let VARa be FUNCtouint32(VARx). 
*0*let VARb be FUNCtouint32(VARy). 
*0*let VARproduct be (VARa × VARb) modulo 232. 
*0*if VARproduct ≥ 231, return VARproduct - 232; otherwise return VARproduct.     

############# END ## 374 ###########################
############# BEGIN ## 375 ###########################
ID= 20.3.1.8
Summary= LocalTime ( t )
Description= The abstract operation LocalTime with argument t converts t from UTC to local time by performing the following steps:
*0*return VARt + FUNClocaltza(VARt, true).     

############# END ## 375 ###########################
############# BEGIN ## 376 ###########################
ID= 20.3.1.9
Summary= UTC ( t )
Description= The abstract operation UTC with argument t converts t from local time to UTC. It performs the following steps:
*0*return VARt - FUNClocaltza(VARt, false).     

############# END ## 376 ###########################
############# BEGIN ## 377 ###########################
ID= 20.3.1.11
Summary= MakeTime ( hour, min, sec, ms )
Description= The abstract operation MakeTime calculates a number of milliseconds from its four arguments, which must be ECMAScript Number values. This operator functions as follows:
*0*if VARhour is not finite or VARmin is not finite or VARsec is not finite or VARms is not finite, return nan. 
*0*let VARh be ! FUNCtointeger(VARhour). 
*0*let VARm be ! FUNCtointeger(VARmin). 
*0*let VARs be ! FUNCtointeger(VARsec). 
*0*let VARmilli be ! FUNCtointeger(VARms). 
*0*let VARt be VARh * msperhour + VARm * msperminute + VARs * mspersecond + VARmilli, performing the arithmetic according to ieee 754-2008 rules (that is, as if using the ecmascript operators * and +). 
*0*return VARt.     

############# END ## 377 ###########################
############# BEGIN ## 378 ###########################
ID= 20.3.1.12
Summary= MakeDay ( year, month, date )
Description= The abstract operation MakeDay calculates a number of days from its three arguments, which must be ECMAScript Number values. This operator functions as follows:
*0*if VARyear is not finite or VARmonth is not finite or VARdate is not finite, return nan. 
*0*let VARy be ! FUNCtointeger(VARyear). 
*0*let VARm be ! FUNCtointeger(VARmonth). 
*0*let VARdt be ! FUNCtointeger(VARdate). 
*0*let VARym be VARy + floor(VARm / 12). 
*0*let VARmn be VARm modulo 12. 
*0*find a value VARt such that yearfromtime(VARt) is VARym and monthfromtime(VARt) is VARmn and FUNCdatefromtime(VARt) is 1; but if this is not possible (because some argument is out of range), return nan. 
*0*return day(VARt) + VARdt - 1.     

############# END ## 378 ###########################
############# BEGIN ## 379 ###########################
ID= 20.3.1.13
Summary= MakeDate ( day, time )
Description= The abstract operation MakeDate calculates a number of milliseconds from its two arguments, which must be ECMAScript Number values. This operator functions as follows:
*0*if VARday is not finite or VARtime is not finite, return nan. 
*0*return VARday × msperday + VARtime.     

############# END ## 379 ###########################
############# BEGIN ## 380 ###########################
ID= 20.3.1.14
Summary= TimeClip ( time )
Description= The abstract operation TimeClip calculates a number of milliseconds from its argument, which must be an ECMAScript Number value. This operator functions as follows:
*0*if VARtime is not finite, return nan. 
*0*if abs(VARtime) &gt; 8.64 × 1015, return nan. 
*0*let VARclippedtime be ! FUNCtointeger(VARtime). 
*0*if VARclippedtime is -0, set VARclippedtime to +0. 
*0*return VARclippedtime.     

############# END ## 380 ###########################
############# BEGIN ## 381 ###########################
ID= 20.3.2.1
Summary= Date ( year, month [ , date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] )
Description= This description applies only if the Date constructor is called with at least two arguments.
*0*let VARnumberofargs be the number of arguments passed to this function call. 
*0*assert: VARnumberofargs ≥ 2. 
*0*if newtarget is undefined, then
*1*let VARnow be the number that is the time value (utc) identifying the current time. 
*1*return FUNCtodatestring(VARnow). 
*0*else,
*1*let VARy be ? FUNCtonumber(VARyear). 
*1*let VARm be ? FUNCtonumber(VARmonth). 
*1*if VARdate is present, let VARdt be ? FUNCtonumber(VARdate); else let VARdt be 1. 
*1*if VARhours is present, let VARh be ? FUNCtonumber(VARhours); else let VARh be 0. 
*1*if VARminutes is present, let VARmin be ? FUNCtonumber(VARminutes); else let VARmin be 0. 
*1*if VARseconds is present, let VARs be ? FUNCtonumber(VARseconds); else let VARs be 0. 
*1*if VARms is present, let VARmilli be ? FUNCtonumber(VARms); else let VARmilli be 0. 
*1*if VARy is not nan and 0 ≤ FUNCtointeger(VARy) ≤ 99, let VARyr be 1900+FUNCtointeger(VARy); otherwise, let VARyr be VARy. 
*1*let VARfinaldate be FUNCmakedate(FUNCmakeday(VARyr, VARm, VARdt), FUNCmaketime(VARh, VARmin, VARs, VARmilli)). 
*1*let VARo be ? FUNCordinarycreatefromconstructor(newtarget, "%dateprototype%", « [[DATEVALUE]] »). 
*1*set VARo.[[DATEVALUE]] to FUNCtimeclip(FUNCutc(VARfinaldate)). 
*1*return VARo.     

############# END ## 381 ###########################
############# BEGIN ## 382 ###########################
ID= 20.3.2.2
Summary= Date ( value )
Description= This description applies only if the Date constructor is called with exactly one argument.
*0*let VARnumberofargs be the number of arguments passed to this function call. 
*0*assert: VARnumberofargs = 1. 
*0*if newtarget is undefined, then
*1*let VARnow be the number that is the time value (utc) identifying the current time. 
*1*return FUNCtodatestring(VARnow). 
*0*else,
*1*if FUNCtype(VARvalue) is object and VARvalue has a [[DATEVALUE]] internal slot, then
*2*let VARtv be thistimevalue(VARvalue). 
*1*else,
*2*let VARv be ? FUNCtoprimitive(VARvalue). 
*2*if FUNCtype(VARv) is string, then
*3*assert: the next step never returns an abrupt completion because VARv is a string value. 
*3*let VARtv be the result of parsing VARv as a date, in exactly the same manner as for the parse method (20.3.3.2). 
*2*else,
*3*let VARtv be ? FUNCtonumber(VARv). 
*1*let VARo be ? FUNCordinarycreatefromconstructor(newtarget, "%dateprototype%", « [[DATEVALUE]] »). 
*1*set VARo.[[DATEVALUE]] to FUNCtimeclip(VARtv). 
*1*return VARo.     

############# END ## 382 ###########################
############# BEGIN ## 383 ###########################
ID= 20.3.2.3
Summary= Date ( )
Description= This description applies only if the Date constructor is called with no arguments.
*0*let VARnumberofargs be the number of arguments passed to this function call. 
*0*assert: VARnumberofargs = 0. 
*0*if newtarget is undefined, then
*1*let VARnow be the number that is the time value (utc) identifying the current time. 
*1*return FUNCtodatestring(VARnow). 
*0*else,
*1*let VARo be ? FUNCordinarycreatefromconstructor(newtarget, "%dateprototype%", « [[DATEVALUE]] »). 
*1*set VARo.[[DATEVALUE]] to the time value (utc) identifying the current time. 
*1*return VARo.     

############# END ## 383 ###########################
############# BEGIN ## 384 ###########################
ID= 20.3.3.4
Summary= Date.UTC ( year [ , month [ , date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] ] )
Description= When the UTC function is called, the following steps are taken:
*0*let VARy be ? FUNCtonumber(VARyear). 
*0*if VARmonth is present, let VARm be ? FUNCtonumber(VARmonth); else let VARm be 0. 
*0*if VARdate is present, let VARdt be ? FUNCtonumber(VARdate); else let VARdt be 1. 
*0*if VARhours is present, let VARh be ? FUNCtonumber(VARhours); else let VARh be 0. 
*0*if VARminutes is present, let VARmin be ? FUNCtonumber(VARminutes); else let VARmin be 0. 
*0*if VARseconds is present, let VARs be ? FUNCtonumber(VARseconds); else let VARs be 0. 
*0*if VARms is present, let VARmilli be ? FUNCtonumber(VARms); else let VARmilli be 0. 
*0*if VARy is not nan and 0 ≤ FUNCtointeger(VARy) ≤ 99, let VARyr be 1900+FUNCtointeger(VARy); otherwise, let VARyr be VARy. 
*0*return FUNCtimeclip(FUNCmakedate(FUNCmakeday(VARyr, VARm, VARdt), FUNCmaketime(VARh, VARmin, VARs, VARmilli))).     

############# END ## 384 ###########################
############# BEGIN ## 385 ###########################
ID= 20.3.4.2
Summary= Date.prototype.getDate ( )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*if VARt is nan, return nan. 
*0*return FUNCdatefromtime(FUNClocaltime(VARt)).     

############# END ## 385 ###########################
############# BEGIN ## 386 ###########################
ID= 20.3.4.3
Summary= Date.prototype.getDay ( )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*if VARt is nan, return nan. 
*0*return FUNCweekday(FUNClocaltime(VARt)).     

############# END ## 386 ###########################
############# BEGIN ## 387 ###########################
ID= 20.3.4.4
Summary= Date.prototype.getFullYear ( )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*if VARt is nan, return nan. 
*0*return yearfromtime(FUNClocaltime(VARt)).     

############# END ## 387 ###########################
############# BEGIN ## 388 ###########################
ID= 20.3.4.5
Summary= Date.prototype.getHours ( )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*if VARt is nan, return nan. 
*0*return hourfromtime(FUNClocaltime(VARt)).     

############# END ## 388 ###########################
############# BEGIN ## 389 ###########################
ID= 20.3.4.6
Summary= Date.prototype.getMilliseconds ( )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*if VARt is nan, return nan. 
*0*return msfromtime(FUNClocaltime(VARt)).     

############# END ## 389 ###########################
############# BEGIN ## 390 ###########################
ID= 20.3.4.7
Summary= Date.prototype.getMinutes ( )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*if VARt is nan, return nan. 
*0*return minfromtime(FUNClocaltime(VARt)).     

############# END ## 390 ###########################
############# BEGIN ## 391 ###########################
ID= 20.3.4.8
Summary= Date.prototype.getMonth ( )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*if VARt is nan, return nan. 
*0*return monthfromtime(FUNClocaltime(VARt)).     

############# END ## 391 ###########################
############# BEGIN ## 392 ###########################
ID= 20.3.4.9
Summary= Date.prototype.getSeconds ( )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*if VARt is nan, return nan. 
*0*return secfromtime(FUNClocaltime(VARt)).     

############# END ## 392 ###########################
############# BEGIN ## 393 ###########################
ID= 20.3.4.10
Summary= Date.prototype.getTime ( )
Description= The following steps are performed:
*0*return ? thistimevalue(this value).     

############# END ## 393 ###########################
############# BEGIN ## 394 ###########################
ID= 20.3.4.11
Summary= Date.prototype.getTimezoneOffset ( )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*if VARt is nan, return nan. 
*0*return (VARt - FUNClocaltime(VARt)) / msperminute.     

############# END ## 394 ###########################
############# BEGIN ## 395 ###########################
ID= 20.3.4.12
Summary= Date.prototype.getUTCDate ( )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*if VARt is nan, return nan. 
*0*return FUNCdatefromtime(VARt).     

############# END ## 395 ###########################
############# BEGIN ## 396 ###########################
ID= 20.3.4.13
Summary= Date.prototype.getUTCDay ( )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*if VARt is nan, return nan. 
*0*return FUNCweekday(VARt).     

############# END ## 396 ###########################
############# BEGIN ## 397 ###########################
ID= 20.3.4.14
Summary= Date.prototype.getUTCFullYear ( )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*if VARt is nan, return nan. 
*0*return yearfromtime(VARt).     

############# END ## 397 ###########################
############# BEGIN ## 398 ###########################
ID= 20.3.4.15
Summary= Date.prototype.getUTCHours ( )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*if VARt is nan, return nan. 
*0*return hourfromtime(VARt).     

############# END ## 398 ###########################
############# BEGIN ## 399 ###########################
ID= 20.3.4.16
Summary= Date.prototype.getUTCMilliseconds ( )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*if VARt is nan, return nan. 
*0*return msfromtime(VARt).     

############# END ## 399 ###########################
############# BEGIN ## 400 ###########################
ID= 20.3.4.17
Summary= Date.prototype.getUTCMinutes ( )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*if VARt is nan, return nan. 
*0*return minfromtime(VARt).     

############# END ## 400 ###########################
############# BEGIN ## 401 ###########################
ID= 20.3.4.18
Summary= Date.prototype.getUTCMonth ( )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*if VARt is nan, return nan. 
*0*return monthfromtime(VARt).     

############# END ## 401 ###########################
############# BEGIN ## 402 ###########################
ID= 20.3.4.19
Summary= Date.prototype.getUTCSeconds ( )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*if VARt is nan, return nan. 
*0*return secfromtime(VARt).     

############# END ## 402 ###########################
############# BEGIN ## 403 ###########################
ID= 20.3.4.20
Summary= Date.prototype.setDate ( date )
Description= The following steps are performed:
*0*let VARt be FUNClocaltime(? thistimevalue(this value)). 
*0*let VARdt be ? FUNCtonumber(VARdate). 
*0*let VARnewdate be FUNCmakedate(FUNCmakeday(yearfromtime(VARt), monthfromtime(VARt), VARdt), timewithinday(VARt)). 
*0*let VARu be FUNCtimeclip(FUNCutc(VARnewdate)). 
*0*set the [[DATEVALUE]] internal slot of this date object to VARu. 
*0*return VARu.     

############# END ## 403 ###########################
############# BEGIN ## 404 ###########################
ID= 20.3.4.21
Summary= Date.prototype.setFullYear ( year [ , month [ , date ] ] )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*if VARt is nan, let VARt be +0; otherwise, let VARt be FUNClocaltime(VARt). 
*0*let VARy be ? FUNCtonumber(VARyear). 
*0*if VARmonth is not present, let VARm be monthfromtime(VARt); otherwise, let VARm be ? FUNCtonumber(VARmonth). 
*0*if VARdate is not present, let VARdt be FUNCdatefromtime(VARt); otherwise, let VARdt be ? FUNCtonumber(VARdate). 
*0*let VARnewdate be FUNCmakedate(FUNCmakeday(VARy, VARm, VARdt), timewithinday(VARt)). 
*0*let VARu be FUNCtimeclip(FUNCutc(VARnewdate)). 
*0*set the [[DATEVALUE]] internal slot of this date object to VARu. 
*0*return VARu.     

############# END ## 404 ###########################
############# BEGIN ## 405 ###########################
ID= 20.3.4.22
Summary= Date.prototype.setHours ( hour [ , min [ , sec [ , ms ] ] ] )
Description= The following steps are performed:
*0*let VARt be FUNClocaltime(? thistimevalue(this value)). 
*0*let VARh be ? FUNCtonumber(VARhour). 
*0*if VARmin is not present, let VARm be minfromtime(VARt); otherwise, let VARm be ? FUNCtonumber(VARmin). 
*0*if VARsec is not present, let VARs be secfromtime(VARt); otherwise, let VARs be ? FUNCtonumber(VARsec). 
*0*if VARms is not present, let VARmilli be msfromtime(VARt); otherwise, let VARmilli be ? FUNCtonumber(VARms). 
*0*let VARdate be FUNCmakedate(day(VARt), FUNCmaketime(VARh, VARm, VARs, VARmilli)). 
*0*let VARu be FUNCtimeclip(FUNCutc(VARdate)). 
*0*set the [[DATEVALUE]] internal slot of this date object to VARu. 
*0*return VARu.     

############# END ## 405 ###########################
############# BEGIN ## 406 ###########################
ID= 20.3.4.23
Summary= Date.prototype.setMilliseconds ( ms )
Description= The following steps are performed:
*0*let VARt be FUNClocaltime(? thistimevalue(this value)). 
*0*let VARms be ? FUNCtonumber(VARms). 
*0*let VARtime be FUNCmaketime(hourfromtime(VARt), minfromtime(VARt), secfromtime(VARt), VARms). 
*0*let VARu be FUNCtimeclip(FUNCutc(FUNCmakedate(day(VARt), VARtime))). 
*0*set the [[DATEVALUE]] internal slot of this date object to VARu. 
*0*return VARu.     

############# END ## 406 ###########################
############# BEGIN ## 407 ###########################
ID= 20.3.4.24
Summary= Date.prototype.setMinutes ( min [ , sec [ , ms ] ] )
Description= The following steps are performed:
*0*let VARt be FUNClocaltime(? thistimevalue(this value)). 
*0*let VARm be ? FUNCtonumber(VARmin). 
*0*if VARsec is not present, let VARs be secfromtime(VARt); otherwise, let VARs be ? FUNCtonumber(VARsec). 
*0*if VARms is not present, let VARmilli be msfromtime(VARt); otherwise, let VARmilli be ? FUNCtonumber(VARms). 
*0*let VARdate be FUNCmakedate(day(VARt), FUNCmaketime(hourfromtime(VARt), VARm, VARs, VARmilli)). 
*0*let VARu be FUNCtimeclip(FUNCutc(VARdate)). 
*0*set the [[DATEVALUE]] internal slot of this date object to VARu. 
*0*return VARu.     

############# END ## 407 ###########################
############# BEGIN ## 408 ###########################
ID= 20.3.4.25
Summary= Date.prototype.setMonth ( month [ , date ] )
Description= The following steps are performed:
*0*let VARt be FUNClocaltime(? thistimevalue(this value)). 
*0*let VARm be ? FUNCtonumber(VARmonth). 
*0*if VARdate is not present, let VARdt be FUNCdatefromtime(VARt); otherwise, let VARdt be ? FUNCtonumber(VARdate). 
*0*let VARnewdate be FUNCmakedate(FUNCmakeday(yearfromtime(VARt), VARm, VARdt), timewithinday(VARt)). 
*0*let VARu be FUNCtimeclip(FUNCutc(VARnewdate)). 
*0*set the [[DATEVALUE]] internal slot of this date object to VARu. 
*0*return VARu.     

############# END ## 408 ###########################
############# BEGIN ## 409 ###########################
ID= 20.3.4.26
Summary= Date.prototype.setSeconds ( sec [ , ms ] )
Description= The following steps are performed:
*0*let VARt be FUNClocaltime(? thistimevalue(this value)). 
*0*let VARs be ? FUNCtonumber(VARsec). 
*0*if VARms is not present, let VARmilli be msfromtime(VARt); otherwise, let VARmilli be ? FUNCtonumber(VARms). 
*0*let VARdate be FUNCmakedate(day(VARt), FUNCmaketime(hourfromtime(VARt), minfromtime(VARt), VARs, VARmilli)). 
*0*let VARu be FUNCtimeclip(FUNCutc(VARdate)). 
*0*set the [[DATEVALUE]] internal slot of this date object to VARu. 
*0*return VARu.     

############# END ## 409 ###########################
############# BEGIN ## 410 ###########################
ID= 20.3.4.27
Summary= Date.prototype.setTime ( time )
Description= The following steps are performed:
*0*perform ? thistimevalue(this value). 
*0*let VARt be ? FUNCtonumber(VARtime). 
*0*let VARv be FUNCtimeclip(VARt). 
*0*set the [[DATEVALUE]] internal slot of this date object to VARv. 
*0*return VARv.     

############# END ## 410 ###########################
############# BEGIN ## 411 ###########################
ID= 20.3.4.28
Summary= Date.prototype.setUTCDate ( date )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*let VARdt be ? FUNCtonumber(VARdate). 
*0*let VARnewdate be FUNCmakedate(FUNCmakeday(yearfromtime(VARt), monthfromtime(VARt), VARdt), timewithinday(VARt)). 
*0*let VARv be FUNCtimeclip(VARnewdate). 
*0*set the [[DATEVALUE]] internal slot of this date object to VARv. 
*0*return VARv.     

############# END ## 411 ###########################
############# BEGIN ## 412 ###########################
ID= 20.3.4.29
Summary= Date.prototype.setUTCFullYear ( year [ , month [ , date ] ] )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*if VARt is nan, let VARt be +0. 
*0*let VARy be ? FUNCtonumber(VARyear). 
*0*if VARmonth is not present, let VARm be monthfromtime(VARt); otherwise, let VARm be ? FUNCtonumber(VARmonth). 
*0*if VARdate is not present, let VARdt be FUNCdatefromtime(VARt); otherwise, let VARdt be ? FUNCtonumber(VARdate). 
*0*let VARnewdate be FUNCmakedate(FUNCmakeday(VARy, VARm, VARdt), timewithinday(VARt)). 
*0*let VARv be FUNCtimeclip(VARnewdate). 
*0*set the [[DATEVALUE]] internal slot of this date object to VARv. 
*0*return VARv.     

############# END ## 412 ###########################
############# BEGIN ## 413 ###########################
ID= 20.3.4.30
Summary= Date.prototype.setUTCHours ( hour [ , min [ , sec [ , ms ] ] ] )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*let VARh be ? FUNCtonumber(VARhour). 
*0*if VARmin is not present, let VARm be minfromtime(VARt); otherwise, let VARm be ? FUNCtonumber(VARmin). 
*0*if VARsec is not present, let VARs be secfromtime(VARt); otherwise, let VARs be ? FUNCtonumber(VARsec). 
*0*if VARms is not present, let VARmilli be msfromtime(VARt); otherwise, let VARmilli be ? FUNCtonumber(VARms). 
*0*let VARnewdate be FUNCmakedate(day(VARt), FUNCmaketime(VARh, VARm, VARs, VARmilli)). 
*0*let VARv be FUNCtimeclip(VARnewdate). 
*0*set the [[DATEVALUE]] internal slot of this date object to VARv. 
*0*return VARv.     

############# END ## 413 ###########################
############# BEGIN ## 414 ###########################
ID= 20.3.4.31
Summary= Date.prototype.setUTCMilliseconds ( ms )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*let VARmilli be ? FUNCtonumber(VARms). 
*0*let VARtime be FUNCmaketime(hourfromtime(VARt), minfromtime(VARt), secfromtime(VARt), VARmilli). 
*0*let VARv be FUNCtimeclip(FUNCmakedate(day(VARt), VARtime)). 
*0*set the [[DATEVALUE]] internal slot of this date object to VARv. 
*0*return VARv.     

############# END ## 414 ###########################
############# BEGIN ## 415 ###########################
ID= 20.3.4.32
Summary= Date.prototype.setUTCMinutes ( min [ , sec [ , ms ] ] )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*let VARm be ? FUNCtonumber(VARmin). 
*0*if VARsec is not present, let VARs be secfromtime(VARt). 
*0*else,
*1*let VARs be ? FUNCtonumber(VARsec). 
*0*if VARms is not present, let VARmilli be msfromtime(VARt). 
*0*else,
*1*let VARmilli be ? FUNCtonumber(VARms). 
*0*let VARdate be FUNCmakedate(day(VARt), FUNCmaketime(hourfromtime(VARt), VARm, VARs, VARmilli)). 
*0*let VARv be FUNCtimeclip(VARdate). 
*0*set the [[DATEVALUE]] internal slot of this date object to VARv. 
*0*return VARv.     

############# END ## 415 ###########################
############# BEGIN ## 416 ###########################
ID= 20.3.4.33
Summary= Date.prototype.setUTCMonth ( month [ , date ] )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*let VARm be ? FUNCtonumber(VARmonth). 
*0*if VARdate is not present, let VARdt be FUNCdatefromtime(VARt). 
*0*else,
*1*let VARdt be ? FUNCtonumber(VARdate). 
*0*let VARnewdate be FUNCmakedate(FUNCmakeday(yearfromtime(VARt), VARm, VARdt), timewithinday(VARt)). 
*0*let VARv be FUNCtimeclip(VARnewdate). 
*0*set the [[DATEVALUE]] internal slot of this date object to VARv. 
*0*return VARv.     

############# END ## 416 ###########################
############# BEGIN ## 417 ###########################
ID= 20.3.4.34
Summary= Date.prototype.setUTCSeconds ( sec [ , ms ] )
Description= The following steps are performed:
*0*let VARt be ? thistimevalue(this value). 
*0*let VARs be ? FUNCtonumber(VARsec). 
*0*if VARms is not present, let VARmilli be msfromtime(VARt). 
*0*else,
*1*let VARmilli be ? FUNCtonumber(VARms). 
*0*let VARdate be FUNCmakedate(day(VARt), FUNCmaketime(hourfromtime(VARt), minfromtime(VARt), VARs, VARmilli)). 
*0*let VARv be FUNCtimeclip(VARdate). 
*0*set the [[DATEVALUE]] internal slot of this date object to VARv. 
*0*return VARv.     

############# END ## 417 ###########################
############# BEGIN ## 418 ###########################
ID= 20.3.4.35
Summary= Date.prototype.toDateString ( )
Description= The following steps are performed:
*0*let VARo be this date object. 
*0*let VARtv be ? thistimevalue(VARo). 
*0*if VARtv is nan, return "invalid date". 
*0*let VARt be FUNClocaltime(VARtv). 
*0*return FUNCdatestring(VARt).     

############# END ## 418 ###########################
############# BEGIN ## 419 ###########################
ID= 20.3.4.37
Summary= Date.prototype.toJSON ( key )
Description= This function provides a String representation of a Date object for use by JSON.stringify (24.5.2).
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARtv be ? FUNCtoprimitive(VARo, hint number). 
*0*if FUNCtype(VARtv) is number and VARtv is not finite, return null. 
*0*return ? FUNCinvoke(VARo, "toisostring").     

############# END ## 419 ###########################
############# BEGIN ## 420 ###########################
ID= 20.3.4.41
Summary= Date.prototype.toString ( )
Description= The following steps are performed:
*0*let VARtv be ? thistimevalue(this value). 
*0*return FUNCtodatestring(VARtv).     

############# END ## 420 ###########################
############# BEGIN ## 421 ###########################
ID= 20.3.4.41.1
Summary= Runtime Semantics: TimeString ( tv )
Description= The following steps are performed:
*0*assert: FUNCtype(VARtv) is number. 
*0*assert: VARtv is not nan. 
*0*let VARhour be the string representation of hourfromtime(VARtv), formatted as a two-digit decimal number, padded to the left with a zero if necessary. 
*0*let VARminute be the string representation of minfromtime(VARtv), formatted as a two-digit decimal number, padded to the left with a zero if necessary. 
*0*let VARsecond be the string representation of secfromtime(VARtv), formatted as a two-digit decimal number, padded to the left with a zero if necessary. 
*0*return the string-concatenation of VARhour, ":", VARminute, ":", VARsecond, the code unit 0x0020 (space), and "gmt".      

############# END ## 421 ###########################
############# BEGIN ## 422 ###########################
ID= 20.3.4.41.2
Summary= Runtime Semantics: DateString ( tv )
Description= The following steps are performed:
*0*assert: FUNCtype(VARtv) is number. 
*0*assert: VARtv is not nan. 
*0*let VARweekday be the name of the entry in FUNCtable 46 with the number weekday(VARtv). 
*0*let VARmonth be the name of the entry in FUNCtable 47 with the number monthfromtime(VARtv). 
*0*let VARday be the string representation of FUNCdatefromtime(VARtv), formatted as a two-digit decimal number, padded to the left with a zero if necessary. 
*0*let VARyear be the string representation of yearfromtime(VARtv), formatted as a decimal number of at least four digits, padded to the left with zeroes if necessary. 
*0*return the string-concatenation of VARweekday, the code unit 0x0020 (space), VARmonth, the code unit 0x0020 (space), VARday, the code unit 0x0020 (space), and VARyear.      

############# END ## 422 ###########################
############# BEGIN ## 423 ###########################
ID= 20.3.4.41.3
Summary= Runtime Semantics: TimeZoneString ( tv )
Description= The following steps are performed:
*0*assert: FUNCtype(VARtv) is number. 
*0*assert: VARtv is not nan. 
*0*let VARoffset be FUNClocaltza(VARtv, true). 
*0*if VARoffset ≥ 0, let VARoffsetsign be "+"; otherwise, let VARoffsetsign be "-". 
*0*let VARoffsetmin be the string representation of minfromtime(abs(VARoffset)), formatted as a two-digit decimal number, padded to the left with a zero if necessary. 
*0*let VARoffsethour be the string representation of hourfromtime(abs(VARoffset)), formatted as a two-digit decimal number, padded to the left with a zero if necessary. 
*0*let VARtzname be an implementation-defined string that is either the empty string or the string-concatenation of the code unit 0x0020 (space), the code unit 0x0028 (left parenthesis), an implementation-dependent timezone name, and the code unit 0x0029 (right parenthesis). 
*0*return the string-concatenation of VARoffsetsign, VARoffsethour, VARoffsetmin, and VARtzname.      

############# END ## 423 ###########################
############# BEGIN ## 424 ###########################
ID= 20.3.4.41.4
Summary= Runtime Semantics: ToDateString ( tv )
Description= The following steps are performed:
*0*assert: FUNCtype(VARtv) is number. 
*0*if VARtv is nan, return "invalid date". 
*0*let VARt be FUNClocaltime(VARtv). 
*0*return the FUNCstring-concatenation of datestring(VARt), the code unit 0x0020 (space), FUNCtimestring(VARt), and FUNCtimezonestring(VARtv).      

############# END ## 424 ###########################
############# BEGIN ## 425 ###########################
ID= 20.3.4.42
Summary= Date.prototype.toTimeString ( )
Description= The following steps are performed:
*0*let VARo be this date object. 
*0*let VARtv be ? thistimevalue(VARo). 
*0*if VARtv is nan, return "invalid date". 
*0*let VARt be FUNClocaltime(VARtv). 
*0*return the FUNCstring-concatenation of timestring(VARt) and FUNCtimezonestring(VARtv).     

############# END ## 425 ###########################
############# BEGIN ## 426 ###########################
ID= 20.3.4.43
Summary= Date.prototype.toUTCString ( )
Description= The following steps are performed:
*0*let VARo be this date object. 
*0*let VARtv be ? thistimevalue(VARo). 
*0*if VARtv is nan, return "invalid date". 
*0*let VARweekday be the name of the entry in FUNCtable 46 with the number weekday(VARtv). 
*0*let VARmonth be the name of the entry in FUNCtable 47 with the number monthfromtime(VARtv). 
*0*let VARday be the string representation of FUNCdatefromtime(VARtv), formatted as a two-digit decimal number, padded to the left with a zero if necessary. 
*0*let VARyear be the string representation of yearfromtime(VARtv), formatted as a decimal number of at least four digits, padded to the left with zeroes if necessary. 
*0*return the FUNCstring-concatenation of VARweekday, ",", the code unit 0x0020 (space), VARday, the code unit 0x0020 (space), VARmonth, the code unit 0x0020 (space), VARyear, the code unit 0x0020 (space), and timestring(VARtv).     

############# END ## 426 ###########################
############# BEGIN ## 427 ###########################
ID= 20.3.4.44
Summary= Date.prototype.valueOf ( )
Description= The following steps are performed:
*0*return ? thistimevalue(this value).     

############# END ## 427 ###########################
############# BEGIN ## 428 ###########################
ID= 20.3.4.45
Summary= Date.prototype [ @@toPrimitive ] ( hint )
Description= This function is called by ECMAScript language operators to convert a Date object to a primitive value. The allowed values for hint are "default", "number", and "string". Date objects, are unique among built-in ECMAScript object in that they treat "default" as being equivalent to "string", All other built-in ECMAScript objects treat "default" as being equivalent to "number".
*0*let VARo be the this value. 
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*if VARhint is the string value "string" or the string value "default", then
*1*let VARtryfirst be "string". 
*0*else if VARhint is the string value "number", then
*1*let VARtryfirst be "number". 
*0*else, throw a typeerror exception. 
*0*return ? FUNCordinarytoprimitive(VARo, VARtryfirst).     

############# END ## 428 ###########################
############# BEGIN ## 429 ###########################
ID= 21.1.1.1
Summary= String ( value )
Description= When String is called with argument value, the following steps are taken:
*0*if no arguments were passed to this function invocation, let VARs be "". 
*0*else,
*1*if newtarget is undefined and FUNCtype(VARvalue) is symbol, return FUNCsymboldescriptivestring(VARvalue). 
*1*let VARs be ? FUNCtostring(VARvalue). 
*0*if newtarget is undefined, return VARs. 
*0*return ? FUNCstringcreate(VARs, ? FUNCgetprototypefromconstructor(newtarget, "%stringprototype%")).     

############# END ## 429 ###########################
############# BEGIN ## 430 ###########################
ID= 21.1.2.1
Summary= String.fromCharCode ( ...codeUnits )
Description= The String.fromCharCode function may be called with any number of arguments which form the rest parameter codeUnits. The following steps are taken:
*0*let VARcodeunits be a list containing the arguments passed to this function. 
*0*let VARlength be the number of elements in VARcodeunits. 
*0*let VARelements be a new empty list. 
*0*let VARnextindex be 0. 
*0*repeat, while VARnextindex &lt; VARlength
*1*let VARnext be VARcodeunits[VARnextindex]. 
*1*let VARnextcu be ? FUNCtouint16(VARnext). 
*1*append VARnextcu to the end of VARelements. 
*1*let VARnextindex be VARnextindex + 1. 
*0*return the string value whose elements are, in order, the elements in the list VARelements. if VARlength is 0, the empty string is returned.     

############# END ## 430 ###########################
############# BEGIN ## 431 ###########################
ID= 21.1.2.2
Summary= String.fromCodePoint ( ...codePoints )
Description= The String.fromCodePoint function may be called with any number of arguments which form the rest parameter codePoints. The following steps are taken:
*0*let VARcodepoints be a list containing the arguments passed to this function. 
*0*let VARlength be the number of elements in VARcodepoints. 
*0*let VARelements be a new empty list. 
*0*let VARnextindex be 0. 
*0*repeat, while VARnextindex &lt; VARlength
*1*let VARnext be VARcodepoints[VARnextindex]. 
*1*let VARnextcp be ? FUNCtonumber(VARnext). 
*1*if FUNCsamevalue(VARnextcp, FUNCtointeger(VARnextcp)) is false, throw a rangeerror exception. 
*1*if VARnextcp &lt; 0 or VARnextcp &gt; 0x10ffff, throw a rangeerror exception. 
*1*append the elements of the utf16encoding of VARnextcp to the end of VARelements. 
*1*let VARnextindex be VARnextindex + 1. 
*0*return the string value whose elements are, in order, the elements in the list VARelements. if VARlength is 0, the empty string is returned.     

############# END ## 431 ###########################
############# BEGIN ## 432 ###########################
ID= 21.1.2.4
Summary= String.raw ( template, ...substitutions )
Description= The String.raw function may be called with a variable number of arguments. The first argument is template and the remainder of the arguments form the List substitutions. The following steps are taken:
*0*let VARsubstitutions be a list consisting of all of the arguments passed to this function, starting with the second argument. if fewer than two arguments were passed, the list is empty. 
*0*let VARnumberofsubstitutions be the number of elements in VARsubstitutions. 
*0*let VARcooked be ? FUNCtoobject(VARtemplate). 
*0*let VARraw be ? FUNCtoobject(? FUNCget(VARcooked, "raw")). 
*0*let VARliteralsegments be ? FUNCtolength(? FUNCget(VARraw, "length")). 
*0*if VARliteralsegments ≤ 0, return the empty string. 
*0*let VARstringelements be a new empty list. 
*0*let VARnextindex be 0. 
*0*repeat,
*1*let VARnextkey be ! FUNCtostring(VARnextindex). 
*1*let VARnextseg be ? FUNCtostring(? FUNCget(VARraw, VARnextkey)). 
*1*append in order the code unit elements of VARnextseg to the end of VARstringelements. 
*1*if VARnextindex + 1 = VARliteralsegments, then
*2*return the string value whose code units are, in order, the elements in the list VARstringelements. if VARstringelements has no elements, the empty string is returned. 
*1*if VARnextindex &lt; VARnumberofsubstitutions, let VARnext be VARsubstitutions[VARnextindex]. 
*1*else, let VARnext be the empty string. 
*1*let VARnextsub be ? FUNCtostring(VARnext). 
*1*append in order the code unit elements of VARnextsub to the end of VARstringelements. 
*1*let VARnextindex be VARnextindex + 1.     

############# END ## 432 ###########################
############# BEGIN ## 433 ###########################
ID= 21.1.3.1
Summary= String.prototype.charAt ( pos )
Description= Returns a single element String containing the code unit at index pos within the String value resulting from converting this object to a String. If there is no element at that index, the result is the empty String. The result is a String value, not a String object.
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*let VARposition be ? FUNCtointeger(VARpos). 
*0*let VARsize be the length of VARs. 
*0*if VARposition &lt; 0 or VARposition ≥ VARsize, return the empty string. 
*0*return the string value of length 1, containing one code unit from VARs, namely the code unit at index VARposition.     

############# END ## 433 ###########################
############# BEGIN ## 434 ###########################
ID= 21.1.3.2
Summary= String.prototype.charCodeAt ( pos )
Description= Returns a Number (a nonnegative integer less than 216) that is the numeric value of the code unit at index pos within the String resulting from converting this object to a String. If there is no element at that index, the result is NaN.
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*let VARposition be ? FUNCtointeger(VARpos). 
*0*let VARsize be the length of VARs. 
*0*if VARposition &lt; 0 or VARposition ≥ VARsize, return nan. 
*0*return a value of number type, whose value is the numeric value of the code unit at index VARposition within the string VARs.     

############# END ## 434 ###########################
############# BEGIN ## 435 ###########################
ID= 21.1.3.3
Summary= String.prototype.codePointAt ( pos )
Description= Returns a nonnegative integer Number less than 0x110000 that is the code point value of the UTF-16 encoded code point (6.1.4) starting at the string element at index pos within the String resulting from converting this object to a String. If there is no element at that index, the result is undefined. If a valid UTF-16  surrogate pair does not begin at pos, the result is the code unit at pos.
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*let VARposition be ? FUNCtointeger(VARpos). 
*0*let VARsize be the length of VARs. 
*0*if VARposition &lt; 0 or VARposition ≥ VARsize, return undefined. 
*0*let VARfirst be the numeric value of the code unit at index VARposition within the string VARs. 
*0*if VARfirst &lt; 0xd800 or VARfirst &gt; 0xdbff or VARposition+1 = VARsize, return VARfirst. 
*0*let VARsecond be the numeric value of the code unit at index VARposition+1 within the string VARs. 
*0*if VARsecond &lt; 0xdc00 or VARsecond &gt; 0xdfff, return VARfirst. 
*0*return FUNCutf16decode(VARfirst, VARsecond).     

############# END ## 435 ###########################
############# BEGIN ## 436 ###########################
ID= 21.1.3.4
Summary= String.prototype.concat ( ...args )
Description= When the concat method is called it returns the String value consisting of the code units of the this object (converted to a String) followed by the code units of each of the arguments converted to a String. The result is a String value, not a String object.
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*let VARargs be a list whose elements are the arguments passed to this function. 
*0*let VARr be VARs. 
*0*repeat, while VARargs is not empty
*1*remove the first element from VARargs and let VARnext be the value of that element. 
*1*let VARnextstring be ? FUNCtostring(VARnext). 
*1*set VARr to the string-concatenation of the previous value of VARr and VARnextstring. 
*0*return VARr.     

############# END ## 436 ###########################
############# BEGIN ## 437 ###########################
ID= 21.1.3.6
Summary= String.prototype.endsWith ( searchString [ , endPosition ] )
Description= The following steps are taken:
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*let VARisregexp be ? FUNCisregexp(VARsearchstring). 
*0*if VARisregexp is true, throw a typeerror exception. 
*0*let VARsearchstr be ? FUNCtostring(VARsearchstring). 
*0*let VARlen be the length of VARs. 
*0*if VARendposition is undefined, let VARpos be VARlen, else let VARpos be ? FUNCtointeger(VARendposition). 
*0*let VARend be min(max(VARpos, 0), VARlen). 
*0*let VARsearchlength be the length of VARsearchstr. 
*0*let VARstart be VARend - VARsearchlength. 
*0*if VARstart is less than 0, return false. 
*0*if the sequence of elements of VARs starting at VARstart of length VARsearchlength is the same as the full element sequence of VARsearchstr, return true. 
*0*otherwise, return false.     

############# END ## 437 ###########################
############# BEGIN ## 438 ###########################
ID= 21.1.3.7
Summary= String.prototype.includes ( searchString [ , position ] )
Description= The includes method takes two arguments, searchString and position, and performs the following steps:
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*let VARisregexp be ? FUNCisregexp(VARsearchstring). 
*0*if VARisregexp is true, throw a typeerror exception. 
*0*let VARsearchstr be ? FUNCtostring(VARsearchstring). 
*0*let VARpos be ? FUNCtointeger(VARposition). (if VARposition is undefined, this step produces the value 0.) 
*0*let VARlen be the length of VARs. 
*0*let VARstart be min(max(VARpos, 0), VARlen). 
*0*let VARsearchlen be the length of VARsearchstr. 
*0*if there exists any integer VARk not smaller than VARstart such that VARk + VARsearchlen is not greater than VARlen, and for all nonnegative integers VARj less than VARsearchlen, the code unit at index VARk+VARj within VARs is the same as the code unit at index VARj within VARsearchstr, return true; but if there is no such integer VARk, return false.     

############# END ## 438 ###########################
############# BEGIN ## 439 ###########################
ID= 21.1.3.8
Summary= String.prototype.indexOf ( searchString [ , position ] )
Description= If searchString appears as a substring of the result of converting this object to a String, at one or more indices that are greater than or equal to position, then the smallest such index is returned; otherwise, -1 is returned. If position is undefined, 0 is assumed, so as to search all of the String.
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*let VARsearchstr be ? FUNCtostring(VARsearchstring). 
*0*let VARpos be ? FUNCtointeger(VARposition). (if VARposition is undefined, this step produces the value 0.) 
*0*let VARlen be the length of VARs. 
*0*let VARstart be min(max(VARpos, 0), VARlen). 
*0*let VARsearchlen be the length of VARsearchstr. 
*0*return the smallest possible integer VARk not smaller than VARstart such that VARk+VARsearchlen is not greater than VARlen, and for all nonnegative integers VARj less than VARsearchlen, the code unit at index VARk+VARj within VARs is the same as the code unit at index VARj within VARsearchstr; but if there is no such integer VARk, return the value -1.     

############# END ## 439 ###########################
############# BEGIN ## 440 ###########################
ID= 21.1.3.9
Summary= String.prototype.lastIndexOf ( searchString [ , position ] )
Description= If searchString appears as a substring of the result of converting this object to a String at one or more indices that are smaller than or equal to position, then the greatest such index is returned; otherwise, -1 is returned. If position is undefined, the length of the String value is assumed, so as to search all of the String.
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*let VARsearchstr be ? FUNCtostring(VARsearchstring). 
*0*let VARnumpos be ? FUNCtonumber(VARposition). (if VARposition is undefined, this step produces the value nan.) 
*0*if VARnumpos is nan, let VARpos be +∞; otherwise, let VARpos be FUNCtointeger(VARnumpos). 
*0*let VARlen be the length of VARs. 
*0*let VARstart be min(max(VARpos, 0), VARlen). 
*0*let VARsearchlen be the length of VARsearchstr. 
*0*return the largest possible nonnegative integer VARk not larger than VARstart such that VARk+VARsearchlen is not greater than VARlen, and for all nonnegative integers VARj less than VARsearchlen, the code unit at index VARk+VARj within VARs is the same as the code unit at index VARj within VARsearchstr; but if there is no such integer VARk, return the value -1.     

############# END ## 440 ###########################
############# BEGIN ## 441 ###########################
ID= 21.1.3.10
Summary= String.prototype.localeCompare ( that [ , reserved1 [ , reserved2 ] ] )
Description= An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the localeCompare method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of the localeCompare method is used.
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*let VARthat be ? FUNCtostring(VARthat).     

############# END ## 441 ###########################
############# BEGIN ## 442 ###########################
ID= 21.1.3.11
Summary= String.prototype.match ( regexp )
Description= When the match method is called with argument regexp, the following steps are taken:
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*if VARregexp is neither undefined nor null, then
*1*let VARmatcher be ? FUNCgetmethod(VARregexp, @@match). 
*1*if VARmatcher is not undefined, then
*2*return ? FUNCcall(VARmatcher, VARregexp, « VARo »). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*let VARrx be ? FUNCregexpcreate(VARregexp, undefined). 
*0*return ? FUNCinvoke(VARrx, @@match, « VARs »).     

############# END ## 442 ###########################
############# BEGIN ## 443 ###########################
ID= 21.1.3.12
Summary= String.prototype.normalize ( [ form ] )
Description= When the normalize method is called with one argument form, the following steps are taken:
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*if VARform is not present or VARform is undefined, let VARform be "nfc". 
*0*let VARf be ? FUNCtostring(VARform). 
*0*if VARf is not one of "nfc", "nfd", "nfkc", or "nfkd", throw a rangeerror exception. 
*0*let VARns be the string value that is the result of normalizing VARs into the normalization form named by VARf as specified in https://unicode.org/reports/tr15/. 
*0*return VARns.     

############# END ## 443 ###########################
############# BEGIN ## 444 ###########################
ID= 21.1.3.13
Summary= String.prototype.padEnd ( maxLength [ , fillString ] )
Description= When the padEnd method is called, the following steps are taken:
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*let VARintmaxlength be ? FUNCtolength(VARmaxlength). 
*0*let VARstringlength be the length of VARs. 
*0*if VARintmaxlength is not greater than VARstringlength, return VARs. 
*0*if VARfillstring is undefined, let VARfiller be the string value consisting solely of the code unit 0x0020 (space). 
*0*else, let VARfiller be ? FUNCtostring(VARfillstring). 
*0*if VARfiller is the empty string, return VARs. 
*0*let VARfilllen be VARintmaxlength - VARstringlength. 
*0*let VARtruncatedstringfiller be the string value consisting of repeated concatenations of VARfiller truncated to length VARfilllen. 
*0*return the string-concatenation of VARs and VARtruncatedstringfiller.     

############# END ## 444 ###########################
############# BEGIN ## 445 ###########################
ID= 21.1.3.14
Summary= String.prototype.padStart ( maxLength [ , fillString ] )
Description= When the padStart method is called, the following steps are taken:
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*let VARintmaxlength be ? FUNCtolength(VARmaxlength). 
*0*let VARstringlength be the length of VARs. 
*0*if VARintmaxlength is not greater than VARstringlength, return VARs. 
*0*if VARfillstring is undefined, let VARfiller be the string value consisting solely of the code unit 0x0020 (space). 
*0*else, let VARfiller be ? FUNCtostring(VARfillstring). 
*0*if VARfiller is the empty string, return VARs. 
*0*let VARfilllen be VARintmaxlength - VARstringlength. 
*0*let VARtruncatedstringfiller be the string value consisting of repeated concatenations of VARfiller truncated to length VARfilllen. 
*0*return the string-concatenation of VARtruncatedstringfiller and VARs.     

############# END ## 445 ###########################
############# BEGIN ## 446 ###########################
ID= 21.1.3.15
Summary= String.prototype.repeat ( count )
Description= The following steps are taken:
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*let VARn be ? FUNCtointeger(VARcount). 
*0*if VARn &lt; 0, throw a rangeerror exception. 
*0*if VARn is +∞, throw a rangeerror exception. 
*0*let VARt be the string value that is made from VARn copies of VARs appended together. if VARn is 0, VARt is the empty string. 
*0*return VARt.     

############# END ## 446 ###########################
############# BEGIN ## 447 ###########################
ID= 21.1.3.16
Summary= String.prototype.replace ( searchValue, replaceValue )
Description= When the replace method is called with arguments searchValue and replaceValue, the following steps are taken:
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*if VARsearchvalue is neither undefined nor null, then
*1*let VARreplacer be ? FUNCgetmethod(VARsearchvalue, @@replace). 
*1*if VARreplacer is not undefined, then
*2*return ? FUNCcall(VARreplacer, VARsearchvalue, « VARo, VARreplacevalue »). 
*0*let VARstring be ? FUNCtostring(VARo). 
*0*let VARsearchstring be ? FUNCtostring(VARsearchvalue). 
*0*let VARfunctionalreplace be FUNCiscallable(VARreplacevalue). 
*0*if VARfunctionalreplace is false, then
*1*let VARreplacevalue be ? FUNCtostring(VARreplacevalue). 
*0*search VARstring for the first occurrence of VARsearchstring and let VARpos be the index within VARstring of the first code unit of the matched substring and let VARmatched be VARsearchstring. if no occurrences of VARsearchstring were found, return VARstring. 
*0*if VARfunctionalreplace is true, then
*1*let VARreplvalue be ? FUNCcall(VARreplacevalue, undefined, « VARmatched, VARpos, VARstring »). 
*1*let VARreplstr be ? FUNCtostring(VARreplvalue). 
*0*else,
*1*let VARcaptures be a new empty list. 
*1*let VARreplstr be FUNCgetsubstitution(VARmatched, VARstring, VARpos, VARcaptures, undefined, VARreplacevalue). 
*0*let VARtailpos be VARpos + the number of code units in VARmatched. 
*0*let VARnewstring be the string-concatenation of the first VARpos code units of VARstring, VARreplstr, and the trailing substring of VARstring starting at index VARtailpos. if VARpos is 0, the first element of the concatenation will be the empty string. 
*0*return VARnewstring.     

############# END ## 447 ###########################
############# BEGIN ## 448 ###########################
ID= 21.1.3.16.1
Summary= Runtime Semantics: GetSubstitution ( matched, str, position, captures, namedCaptures, replacement )
Description= The abstract operation GetSubstitution performs the following steps:
*0*assert: FUNCtype(VARmatched) is string. 
*0*let VARmatchlength be the number of code units in VARmatched. 
*0*assert: FUNCtype(VARstr) is string. 
*0*let VARstringlength be the number of code units in VARstr. 
*0*assert: VARposition is a nonnegative integer. 
*0*assert: VARposition ≤ VARstringlength. 
*0*assert: VARcaptures is a possibly empty list of strings. 
*0*assert: FUNCtype(VARreplacement) is string. 
*0*let VARtailpos be VARposition + VARmatchlength. 
*0*let VARm be the number of elements in VARcaptures. 
*0*if VARnamedcaptures is not undefined, then
*1*set VARnamedcaptures to ? FUNCtoobject(VARnamedcaptures). 
*0*let VARresult be the string value derived from VARreplacement by copying code unit elements from VARreplacement to VARresult while performing replacements as specified in table 48. these $ replacements are done left-to-right, and, once such a replacement is performed, the new replacement text is not subject to further replacements. 
*0*return VARresult.      

############# END ## 448 ###########################
############# BEGIN ## 449 ###########################
ID= 21.1.3.17
Summary= String.prototype.search ( regexp )
Description= When the search method is called with argument regexp, the following steps are taken:
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*if VARregexp is neither undefined nor null, then
*1*let VARsearcher be ? FUNCgetmethod(VARregexp, @@search). 
*1*if VARsearcher is not undefined, then
*2*return ? FUNCcall(VARsearcher, VARregexp, « VARo »). 
*0*let VARstring be ? FUNCtostring(VARo). 
*0*let VARrx be ? FUNCregexpcreate(VARregexp, undefined). 
*0*return ? FUNCinvoke(VARrx, @@search, « VARstring »).     

############# END ## 449 ###########################
############# BEGIN ## 450 ###########################
ID= 21.1.3.18
Summary= String.prototype.slice ( start, end )
Description= The slice method takes two arguments, start and end, and returns a substring of the result of converting this object to a String, starting from index start and running to, but not including, index end (or through the end of the String if end is undefined). If start is negative, it is treated as  sourceLength+start where sourceLength is the length of the String. If end is negative, it is treated as  sourceLength+end where sourceLength is the length of the String. The result is a String value, not a String object. The following steps are taken:
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*let VARlen be the length of VARs. 
*0*let VARintstart be ? FUNCtointeger(VARstart). 
*0*if VARend is undefined, let VARintend be VARlen; else let VARintend be ? FUNCtointeger(VARend). 
*0*if VARintstart &lt; 0, let VARfrom be max(VARlen + VARintstart, 0); otherwise let VARfrom be min(VARintstart, VARlen). 
*0*if VARintend &lt; 0, let VARto be max(VARlen + VARintend, 0); otherwise let VARto be min(VARintend, VARlen). 
*0*let VARspan be max(VARto - VARfrom, 0). 
*0*return the string value containing VARspan consecutive elements from VARs beginning with the element at index VARfrom.     

############# END ## 450 ###########################
############# BEGIN ## 451 ###########################
ID= 21.1.3.19
Summary= String.prototype.split ( separator, limit )
Description= Returns an Array object into which substrings of the result of converting this object to a String have been stored. The substrings are determined by searching from left to right for occurrences of separator; these occurrences are not part of any substring in the returned array, but serve to divide up the String value. The value of separator may be a String of any length or it may be an object, such as a RegExp, that has a @@split method.
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*if VARseparator is neither undefined nor null, then
*1*let VARsplitter be ? FUNCgetmethod(VARseparator, @@split). 
*1*if VARsplitter is not undefined, then
*2*return ? FUNCcall(VARsplitter, VARseparator, « VARo, VARlimit »). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*let VARa be ! FUNCarraycreate(0). 
*0*let VARlengtha be 0. 
*0*if VARlimit is undefined, let VARlim be 232-1; else let VARlim be ? FUNCtouint32(VARlimit). 
*0*let VARs be the length of VARs. 
*0*let VARp be 0. 
*0*let VARr be ? FUNCtostring(VARseparator). 
*0*if VARlim = 0, return VARa. 
*0*if VARseparator is undefined, then
*1*perform ! FUNCcreatedataproperty(VARa, "0", VARs). 
*1*return VARa. 
*0*if VARs = 0, then
*1*let VARz be FUNCsplitmatch(VARs, 0, VARr). 
*1*if VARz is not false, return VARa. 
*1*perform ! FUNCcreatedataproperty(VARa, "0", VARs). 
*1*return VARa. 
*0*let VARq be VARp. 
*0*repeat, while VARq ≠ VARs
*1*let VARe be FUNCsplitmatch(VARs, VARq, VARr). 
*1*if VARe is false, let VARq be VARq+1. 
*1*else VARe is an integer index ≤ VARs,
*2*if VARe = VARp, let VARq be VARq+1. 
*2*else VARe ≠ VARp,
*3*let VARt be the string value equal to the substring of VARs consisting of the code units at indices VARp (inclusive) through VARq (exclusive). 
*3*perform ! FUNCcreatedataproperty(VARa, ! FUNCtostring(VARlengtha), VARt). 
*3*increment VARlengtha by 1. 
*3*if VARlengtha = VARlim, return VARa. 
*3*let VARp be VARe. 
*3*let VARq be VARp. 
*0*let VARt be the string value equal to the substring of VARs consisting of the code units at indices VARp (inclusive) through VARs (exclusive). 
*0*perform ! FUNCcreatedataproperty(VARa, ! FUNCtostring(VARlengtha), VARt). 
*0*return VARa.     

############# END ## 451 ###########################
############# BEGIN ## 452 ###########################
ID= 21.1.3.19.1
Summary= Runtime Semantics: SplitMatch ( S, q, R )
Description= The abstract operation SplitMatch takes three parameters, a String S, an integer q, and a String R, and performs the following steps in order to return either false or the end index of a match:
*0*assert: FUNCtype(VARr) is string. 
*0*let VARr be the number of code units in VARr. 
*0*let VARs be the number of code units in VARs. 
*0*if VARq+VARr &gt; VARs, return false. 
*0*if there exists an integer VARi between 0 (inclusive) and VARr (exclusive) such that the code unit at index VARq+VARi within VARs is different from the code unit at index VARi within VARr, return false. 
*0*return VARq+VARr.      

############# END ## 452 ###########################
############# BEGIN ## 453 ###########################
ID= 21.1.3.20
Summary= String.prototype.startsWith ( searchString [ , position ] )
Description= The following steps are taken:
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*let VARisregexp be ? FUNCisregexp(VARsearchstring). 
*0*if VARisregexp is true, throw a typeerror exception. 
*0*let VARsearchstr be ? FUNCtostring(VARsearchstring). 
*0*let VARpos be ? FUNCtointeger(VARposition). (if VARposition is undefined, this step produces the value 0.) 
*0*let VARlen be the length of VARs. 
*0*let VARstart be min(max(VARpos, 0), VARlen). 
*0*let VARsearchlength be the length of VARsearchstr. 
*0*if VARsearchlength+VARstart is greater than VARlen, return false. 
*0*if the sequence of elements of VARs starting at VARstart of length VARsearchlength is the same as the full element sequence of VARsearchstr, return true. 
*0*otherwise, return false.     

############# END ## 453 ###########################
############# BEGIN ## 454 ###########################
ID= 21.1.3.21
Summary= String.prototype.substring ( start, end )
Description= The substring method takes two arguments, start and end, and returns a substring of the result of converting this object to a String, starting from index start and running to, but not including, index end of the String (or through the end of the String if end is undefined). The result is a String value, not a String object.
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*let VARlen be the length of VARs. 
*0*let VARintstart be ? FUNCtointeger(VARstart). 
*0*if VARend is undefined, let VARintend be VARlen; else let VARintend be ? FUNCtointeger(VARend). 
*0*let VARfinalstart be min(max(VARintstart, 0), VARlen). 
*0*let VARfinalend be min(max(VARintend, 0), VARlen). 
*0*let VARfrom be min(VARfinalstart, VARfinalend). 
*0*let VARto be max(VARfinalstart, VARfinalend). 
*0*return the string value whose length is VARto - VARfrom, containing code units from VARs, namely the code units with indices VARfrom through VARto - 1, in ascending order.     

############# END ## 454 ###########################
############# BEGIN ## 455 ###########################
ID= 21.1.3.24
Summary= String.prototype.toLowerCase ( )
Description= This function interprets a String value as a sequence of UTF-16 encoded code points, as described in  6.1.4. The following steps are taken:
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*let VARcplist be a list containing in order the code points as defined in 6.1.4 of VARs, starting at the first element of VARs. 
*0*let VARculist be a list where the elements are the result of tolowercase(VARcplist), according to the unicode default case conversion algorithm. 
*0*let VARl be the string value whose elements are the utf16encoding of the code points of VARculist. 
*0*return VARl.     

############# END ## 455 ###########################
############# BEGIN ## 456 ###########################
ID= 21.1.3.25
Summary= String.prototype.toString ( )
Description= When the toString method is called, the following steps are taken:
*0*return ? FUNCthisstringvalue(this value).     

############# END ## 456 ###########################
############# BEGIN ## 457 ###########################
ID= 21.1.3.27
Summary= String.prototype.trim ( )
Description= This function interprets a String value as a sequence of UTF-16 encoded code points, as described in  6.1.4.
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*let VARt be the string value that is a copy of VARs with both leading and trailing white space removed. the definition of white space is the union of whitespace and lineterminator. when determining whether a unicode code point is in unicode general category “space_separator” (“zs”), code unit sequences are interpreted as utf-16 encoded code point sequences as specified in 6.1.4. 
*0*return VARt.     

############# END ## 457 ###########################
############# BEGIN ## 458 ###########################
ID= 21.1.3.28
Summary= String.prototype.valueOf ( )
Description= When the valueOf method is called, the following steps are taken:
*0*return ? FUNCthisstringvalue(this value).     

############# END ## 458 ###########################
############# BEGIN ## 459 ###########################
ID= 21.1.3.29
Summary= String.prototype [ @@iterator ] ( )
Description= When the @@iterator method is called it returns an Iterator object (25.1.1.2) that iterates over the code points of a String value, returning each code point as a String value. The following steps are taken:
*0*let VARo be ? FUNCrequireobjectcoercible(this value). 
*0*let VARs be ? FUNCtostring(VARo). 
*0*return FUNCcreatestringiterator(VARs).     

############# END ## 459 ###########################
############# BEGIN ## 460 ###########################
ID= 21.1.5.1
Summary= CreateStringIterator ( string )
Description= Several methods of String objects return Iterator objects. The abstract operation CreateStringIterator with argument string is used to create such iterator objects. It performs the following steps:
*0*assert: FUNCtype(VARstring) is string. 
*0*let VARiterator be FUNCobjectcreate(%stringiteratorprototype%, « [[ITERATEDSTRING]], [[STRINGITERATORNEXTINDEX]] »). 
*0*set VARiterator.[[ITERATEDSTRING]] to VARstring. 
*0*set VARiterator.[[STRINGITERATORNEXTINDEX]] to 0. 
*0*return VARiterator.     

############# END ## 460 ###########################
############# BEGIN ## 461 ###########################
ID= 21.1.5.2.1
Summary= %StringIteratorPrototype%.next ( )
Description= None
*0*let VARo be the this value. 
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*if VARo does not have all of the internal slots of a string iterator instance (21.1.5.3), throw a typeerror exception. 
*0*let VARs be VARo.[[ITERATEDSTRING]]. 
*0*if VARs is undefined, return FUNCcreateiterresultobject(undefined, true). 
*0*let VARposition be VARo.[[STRINGITERATORNEXTINDEX]]. 
*0*let VARlen be the length of VARs. 
*0*if VARposition ≥ VARlen, then
*1*set VARo.[[ITERATEDSTRING]] to undefined. 
*1*return FUNCcreateiterresultobject(undefined, true). 
*0*let VARfirst be the numeric value of the code unit at index VARposition within VARs. 
*0*if VARfirst &lt; 0xd800 or VARfirst &gt; 0xdbff or VARposition+1 = VARlen, let VARresultstring be the string value consisting of the single code unit VARfirst. 
*0*else,
*1*let VARsecond be the numeric value of the code unit at index VARposition+1 within the string VARs. 
*1*if VARsecond &lt; 0xdc00 or VARsecond &gt; 0xdfff, let VARresultstring be the string value consisting of the single code unit VARfirst. 
*1*else, let VARresultstring be the string-concatenation of the code unit VARfirst and the code unit VARsecond. 
*0*let VARresultsize be the number of code units in VARresultstring. 
*0*set VARo.[[STRINGITERATORNEXTINDEX]] to VARposition + VARresultsize. 
*0*return FUNCcreateiterresultobject(VARresultstring, false).      

############# END ## 461 ###########################
############# BEGIN ## 462 ###########################
ID= 21.2.2.5.1
Summary= Runtime Semantics: RepeatMatcher ( m, min, max, greedy, x, c, parenIndex, parenCount )
Description= The abstract operation RepeatMatcher takes eight parameters, a Matcher m, an integer min, an integer (or ∞) max, a Boolean greedy, a State x, a Continuation c, an integer parenIndex, and an integer parenCount, and performs the following steps:
*0*if VARmax is zero, return VARc(VARx). 
*0*let VARd be an internal continuation closure that takes one state argument VARy and performs the following steps when evaluated:
*1*if VARmin is zero and VARy's VARendindex is equal to VARx's VARendindex, return failure. 
*1*if VARmin is zero, let VARmin2 be zero; otherwise let VARmin2 be VARmin-1. 
*1*if VARmax is ∞, let VARmax2 be ∞; otherwise let VARmax2 be VARmax-1. 
*1*call FUNCrepeatmatcher(VARm, VARmin2, VARmax2, VARgreedy, VARy, VARc, VARparenindex, VARparencount) and return its result. 
*0*let VARcap be a copy of VARx's VARcaptures list. 
*0*for each integer VARk that satisfies VARparenindex &lt; VARk and VARk ≤ VARparenindex+VARparencount, set VARcap[VARk] to undefined. 
*0*let VARe be VARx's VARendindex. 
*0*let VARxr be the state (VARe, VARcap). 
*0*if VARmin is not zero, return VARm(VARxr, VARd). 
*0*if VARgreedy is false, then
*1*call VARc(VARx) and let VARz be its result. 
*1*if VARz is not failure, return VARz. 
*1*call VARm(VARxr, VARd) and return its result. 
*0*call VARm(VARxr, VARd) and let VARz be its result. 
*0*if VARz is not failure, return VARz. 
*0*call VARc(VARx) and return its result.      

############# END ## 462 ###########################
############# BEGIN ## 463 ###########################
ID= 21.2.2.6.1
Summary= Runtime Semantics: WordCharacters ( )
Description= The abstract operation WordCharacters performs the following steps:
*0*let VARa be a set of characters containing the sixty-three characters:      abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789_ 
*0*let VARu be an empty set. 
*0*for each character VARc not in set VARa where FUNCcanonicalize(VARc) is in VARa, add VARc to VARu. 
*0*assert: unless VARunicode and VARignorecase are both true, VARu is empty. 
*0*add the characters in set VARu to set VARa. 
*0*return VARa.      

############# END ## 463 ###########################
############# BEGIN ## 464 ###########################
ID= 21.2.2.6.2
Summary= Runtime Semantics: IsWordChar ( e )
Description= The abstract operation IsWordChar takes an integer parameter e and performs the following steps:
*0*if VARe is -1 or VARe is VARinputlength, return false. 
*0*let VARc be the character VARinput[VARe]. 
*0*let VARwordchars be the result of ! FUNCwordcharacters(). 
*0*if VARc is in VARwordchars, return true. 
*0*return false.      

############# END ## 464 ###########################
############# BEGIN ## 465 ###########################
ID= 21.2.2.8.1
Summary= Runtime Semantics: CharacterSetMatcher ( A, invert, direction )
Description= The abstract operation CharacterSetMatcher takes three arguments, a CharSet A, a Boolean flag invert, and an integer direction, and performs the following steps:
*0*return an internal matcher closure that takes two arguments, a state VARx and a continuation VARc, and performs the following steps when evaluated:
*1*let VARe be VARx's VARendindex. 
*1*let VARf be VARe + VARdirection. 
*1*if VARf &lt; 0 or VARf &gt; VARinputlength, return failure. 
*1*let VARindex be min(VARe, VARf). 
*1*let VARch be the character VARinput[VARindex]. 
*1*let VARcc be FUNCcanonicalize(VARch). 
*1*if VARinvert is false, then
*2*if there does not exist a member VARa of set VARa such that FUNCcanonicalize(VARa) is VARcc, return failure. 
*1*else,
*2*assert: VARinvert is true. 
*2*if there exists a member VARa of set VARa such that FUNCcanonicalize(VARa) is VARcc, return failure. 
*1*let VARcap be VARx's VARcaptures list. 
*1*let VARy be the state (VARf, VARcap). 
*1*call VARc(VARy) and return its result.      

############# END ## 465 ###########################
############# BEGIN ## 466 ###########################
ID= 21.2.2.8.2
Summary= Runtime Semantics: Canonicalize ( ch )
Description= The abstract operation Canonicalize takes a character parameter ch and performs the following steps:
*0*if VARignorecase is false, return VARch. 
*0*if VARunicode is true, then
*1*if the file casefolding.txt of the unicode character database provides a simple or common case folding mapping for VARch, return the result of applying that mapping to VARch. 
*1*return VARch. 
*0*else,
*1*assert: VARch is a utf-16 code unit. 
*1*let VARs be the string value consisting of the single code unit VARch. 
*1*let VARu be the same result produced as if by performing the algorithm for string.prototype.touppercase using VARs as the this value. 
*1*assert: VARu is a string value. 
*1*if VARu does not consist of a single code unit, return VARch. 
*1*let VARcu be VARu's single code unit element. 
*1*if the numeric value of VARch ≥ 128 and the numeric value of VARcu &lt; 128, return VARch. 
*1*return VARcu.      

############# END ## 466 ###########################
############# BEGIN ## 467 ###########################
ID= 21.2.2.8.3
Summary= Runtime Semantics: UnicodeMatchProperty ( p )
Description= The abstract operation UnicodeMatchProperty takes a parameter p that is a List of Unicode code points and performs the following steps:
*0*assert: VARp is a list of unicode code points that is identical to a list of unicode code points that is a unicode property name or property alias listed in the “property name and aliases” column of table 51 or table 52. 
*0*let VARc be the canonical property name of VARp as given in the “canonical property name” column of the corresponding row. 
*0*return the list of unicode code points of VARc.      

############# END ## 467 ###########################
############# BEGIN ## 468 ###########################
ID= 21.2.2.8.4
Summary= Runtime Semantics: UnicodeMatchPropertyValue ( p, v )
Description= The abstract operation UnicodeMatchPropertyValue takes two parameters p and v, each of which is a List of Unicode code points, and performs the following steps:
*0*assert: VARp is a list of unicode code points that is identical to a list of unicode code points that is a canonical, unaliased unicode property name listed in the “canonical property name” column of table 51. 
*0*assert: VARv is a list of unicode code points that is identical to a list of unicode code points that is a property value or property value alias for unicode property VARp listed in the “property value and aliases” column of table 53 or table 54. 
*0*let VARvalue be the canonical property value of VARv as given in the “canonical property value” column of the corresponding row. 
*0*return the list of unicode code points of VARvalue.      

############# END ## 468 ###########################
############# BEGIN ## 469 ###########################
ID= 21.2.2.9.1
Summary= Runtime Semantics: BackreferenceMatcher ( n, direction )
Description= The abstract operation BackreferenceMatcher takes two arguments, an integer n and an integer direction, and performs the following steps:
*0*return an internal matcher closure that takes two arguments, a state VARx and a continuation VARc, and performs the following steps:
*1*let VARcap be VARx's VARcaptures list. 
*1*let VARs be VARcap[VARn]. 
*1*if VARs is undefined, return VARc(VARx). 
*1*let VARe be VARx's VARendindex. 
*1*let VARlen be the number of elements in VARs. 
*1*let VARf be VARe + VARdirection × VARlen. 
*1*if VARf &lt; 0 or VARf &gt; VARinputlength, return failure. 
*1*let VARg be min(VARe, VARf). 
*1*if there exists an integer VARi between 0 (inclusive) and VARlen (exclusive) such that FUNCcanonicalize(VARs[VARi]) is not the same character value as FUNCcanonicalize(VARinput[VARg + VARi]), return failure. 
*1*let VARy be the state (VARf, VARcap). 
*1*call VARc(VARy) and return its result.      

############# END ## 469 ###########################
############# BEGIN ## 470 ###########################
ID= 21.2.2.15.1
Summary= Runtime Semantics: CharacterRange ( A, B )
Description= The abstract operation CharacterRange takes two CharSet parameters A and B and performs the following steps:
*0*assert: VARa and VARb each contain exactly one character. 
*0*let VARa be the one character in charset VARa. 
*0*let VARb be the one character in charset VARb. 
*0*let VARi be the character value of character VARa. 
*0*let VARj be the character value of character VARb. 
*0*assert: VARi ≤ VARj. 
*0*return the set containing all characters numbered VARi through VARj, inclusive.      

############# END ## 470 ###########################
############# BEGIN ## 471 ###########################
ID= 21.2.3.1
Summary= RegExp ( pattern, flags )
Description= The following steps are taken:
*0*let VARpatternisregexp be ? FUNCisregexp(VARpattern). 
*0*if newtarget is undefined, then
*1*let VARnewtarget be the active function object. 
*1*if VARpatternisregexp is true and VARflags is undefined, then
*2*let VARpatternconstructor be ? FUNCget(VARpattern, "constructor"). 
*2*if FUNCsamevalue(VARnewtarget, VARpatternconstructor) is true, return VARpattern. 
*0*else, let VARnewtarget be newtarget. 
*0*if FUNCtype(VARpattern) is object and VARpattern has a [[REGEXPMATCHER]] internal slot, then
*1*let VARp be VARpattern.[[ORIGINALSOURCE]]. 
*1*if VARflags is undefined, let VARf be VARpattern.[[ORIGINALFLAGS]]. 
*1*else, let VARf be VARflags. 
*0*else if VARpatternisregexp is true, then
*1*let VARp be ? FUNCget(VARpattern, "source"). 
*1*if VARflags is undefined, then
*2*let VARf be ? FUNCget(VARpattern, "flags"). 
*1*else, let VARf be VARflags. 
*0*else,
*1*let VARp be VARpattern. 
*1*let VARf be VARflags. 
*0*let VARo be ? FUNCregexpalloc(VARnewtarget). 
*0*return ? FUNCregexpinitialize(VARo, VARp, VARf).     

############# END ## 471 ###########################
############# BEGIN ## 472 ###########################
ID= 21.2.3.2.1
Summary= Runtime Semantics: RegExpAlloc ( newTarget )
Description= When the abstract operation RegExpAlloc with argument newTarget is called, the following steps are taken:
*0*let VARobj be ? FUNCordinarycreatefromconstructor(VARnewtarget, "%regexpprototype%", « [[REGEXPMATCHER]], [[ORIGINALSOURCE]], [[ORIGINALFLAGS]] »). 
*0*perform ! FUNCdefinepropertyorthrow(VARobj, "lastindex", propertydescriptor { [[WRITABLE]]: true, [[ENUMERABLE]]: false, [[CONFIGURABLE]]: false }). 
*0*return VARobj.      

############# END ## 472 ###########################
############# BEGIN ## 473 ###########################
ID= 21.2.3.2.2
Summary= Runtime Semantics: RegExpInitialize ( obj, pattern, flags )
Description= When the abstract operation RegExpInitialize with arguments obj, pattern, and flags is called, the following steps are taken:
*0*if VARpattern is undefined, let VARp be the empty string. 
*0*else, let VARp be ? FUNCtostring(VARpattern). 
*0*if VARflags is undefined, let VARf be the empty string. 
*0*else, let VARf be ? FUNCtostring(VARflags). 
*0*if VARf contains any code unit other than "g", "i", "m", "s", "u", or "y" or if it contains the same code unit more than once, throw a syntaxerror exception. 
*0*if VARf contains "u", let VARbmp be false; else let VARbmp be true. 
*0*if VARbmp is true, then
*1*parse VARp using the grammars in 21.2.1 and interpreting each of its 16-bit elements as a unicode bmp code point. utf-16 decoding is not applied to the elements. the goal symbol for the parse is pattern[~u, ~n]. if the result of parsing contains a groupname, reparse with the goal symbol pattern[~u, +n] and use this result instead. throw a syntaxerror exception if VARp did not conform to the grammar, if any elements of VARp were not matched by the parse, or if any early error conditions exist. 
*1*let VARpatterncharacters be a list whose elements are the code unit elements of VARp. 
*0*else,
*1*parse VARp using the grammars in 21.2.1 and interpreting VARp as utf-16 encoded unicode code points (6.1.4). the goal symbol for the parse is pattern[+u, +n]. throw a syntaxerror exception if VARp did not conform to the grammar, if any elements of VARp were not matched by the parse, or if any early error conditions exist. 
*1*let VARpatterncharacters be a list whose elements are the code points resulting from applying utf-16 decoding to VARp's sequence of elements. 
*0*set VARobj.[[ORIGINALSOURCE]] to VARp. 
*0*set VARobj.[[ORIGINALFLAGS]] to VARf. 
*0*set VARobj.[[REGEXPMATCHER]] to the internal procedure that evaluates the above parse of VARp by applying the semantics provided in 21.2.2 using VARpatterncharacters as the pattern's list of sourcecharacter values and VARf as the flag parameters. 
*0*perform ? FUNCset(VARobj, "lastindex", 0, true). 
*0*return VARobj.      

############# END ## 473 ###########################
############# BEGIN ## 474 ###########################
ID= 21.2.3.2.3
Summary= Runtime Semantics: RegExpCreate ( P, F )
Description= When the abstract operation RegExpCreate with arguments P and F is called, the following steps are taken:
*0*let VARobj be ? FUNCregexpalloc(%regexp%). 
*0*return ? FUNCregexpinitialize(VARobj, VARp, VARf).      

############# END ## 474 ###########################
############# BEGIN ## 475 ###########################
ID= 21.2.3.2.4
Summary= Runtime Semantics: EscapeRegExpPattern ( P, F )
Description= When the abstract operation EscapeRegExpPattern with arguments P and F is called, the following occurs:
*0*let VARs be a string in the form of a pattern[~u] (pattern[+u] if VARf contains "u") equivalent to VARp interpreted as utf-16 encoded unicode code points (6.1.4), in which certain code points are escaped as described below. VARs may or may not be identical to VARp; however, the internal procedure that would result from evaluating VARs as a pattern[~u] (pattern[+u] if VARf contains "u") must behave identically to the internal procedure given by the constructed object's [[REGEXPMATCHER]] internal slot. multiple calls to this abstract operation using the same values for VARp and VARf must produce identical results. 
*0*the code points / or any lineterminator occurring in the pattern shall be escaped in VARs as necessary to ensure that the string-concatenation of "/", VARs, "/", and VARf can be parsed (in an appropriate lexical context) as a regularexpressionliteral that behaves identically to the constructed regular expression. for example, if VARp is "/", then VARs could be "\/" or "\u002f", among other possibilities, but not "/", because /// followed by VARf would be parsed as a singlelinecomment rather than a regularexpressionliteral. if VARp is the empty string, this specification can be met by letting VARs be "(?:)". 
*0*return VARs.      

############# END ## 475 ###########################
############# BEGIN ## 476 ###########################
ID= 21.2.5.2
Summary= RegExp.prototype.exec ( string )
Description= Performs a regular expression match of string against the regular expression and returns an Array object containing the results of the match, or null if string did not match.
*0*let VARr be the this value. 
*0*if FUNCtype(VARr) is not object, throw a typeerror exception. 
*0*if VARr does not have a [[REGEXPMATCHER]] internal slot, throw a typeerror exception. 
*0*let VARs be ? FUNCtostring(VARstring). 
*0*return ? FUNCregexpbuiltinexec(VARr, VARs).     

############# END ## 476 ###########################
############# BEGIN ## 477 ###########################
ID= 21.2.5.2.1
Summary= Runtime Semantics: RegExpExec ( R, S )
Description= The abstract operation RegExpExec with arguments R and S performs the following steps:
*0*assert: FUNCtype(VARr) is object. 
*0*assert: FUNCtype(VARs) is string. 
*0*let VARexec be ? FUNCget(VARr, "exec"). 
*0*if FUNCiscallable(VARexec) is true, then
*1*let VARresult be ? FUNCcall(VARexec, VARr, « VARs »). 
*1*if FUNCtype(VARresult) is neither object or null, throw a typeerror exception. 
*1*return VARresult. 
*0*if VARr does not have a [[REGEXPMATCHER]] internal slot, throw a typeerror exception. 
*0*return ? FUNCregexpbuiltinexec(VARr, VARs).      

############# END ## 477 ###########################
############# BEGIN ## 478 ###########################
ID= 21.2.5.2.2
Summary= Runtime Semantics: RegExpBuiltinExec ( R, S )
Description= The abstract operation RegExpBuiltinExec with arguments R and S performs the following steps:
*0*assert: VARr is an initialized regexp instance. 
*0*assert: FUNCtype(VARs) is string. 
*0*let VARlength be the number of code units in VARs. 
*0*let VARlastindex be ? FUNCtolength(? FUNCget(VARr, "lastindex")). 
*0*let VARflags be VARr.[[ORIGINALFLAGS]]. 
*0*if VARflags contains "g", let VARglobal be true, else let VARglobal be false. 
*0*if VARflags contains "y", let VARsticky be true, else let VARsticky be false. 
*0*if VARglobal is false and VARsticky is false, set VARlastindex to 0. 
*0*let VARmatcher be VARr.[[REGEXPMATCHER]]. 
*0*if VARflags contains "u", let VARfullunicode be true, else let VARfullunicode be false. 
*0*let VARmatchsucceeded be false. 
*0*repeat, while VARmatchsucceeded is false
*1*if VARlastindex &gt; VARlength, then
*2*if VARglobal is true or VARsticky is true, then
*3*perform ? FUNCset(VARr, "lastindex", 0, true). 
*2*return null. 
*1*let VARr be VARmatcher(VARs, VARlastindex). 
*1*if VARr is failure, then
*2*if VARsticky is true, then
*3*perform ? FUNCset(VARr, "lastindex", 0, true). 
*3*return null. 
*2*set VARlastindex to FUNCadvancestringindex(VARs, VARlastindex, VARfullunicode). 
*1*else,
*2*assert: VARr is a state. 
*2*set VARmatchsucceeded to true. 
*0*let VARe be VARr's VARendindex value. 
*0*if VARfullunicode is true, then
*1*VARe is an index into the VARinput character list, derived from VARs, matched by VARmatcher. let VAReutf be the smallest index into VARs that corresponds to the character at element VARe of VARinput. if VARe is greater than or equal to the number of elements in VARinput, then VAReutf is the number of code units in VARs. 
*1*set VARe to VAReutf. 
*0*if VARglobal is true or VARsticky is true, then
*1*perform ? FUNCset(VARr, "lastindex", VARe, true). 
*0*let VARn be the number of elements in VARr's VARcaptures list. (this is the same value as 21.2.2.1's VARncapturingparens.) 
*0*assert: VARn &lt; 232-1. 
*0*let VARa be ! FUNCarraycreate(VARn + 1). 
*0*assert: the value of VARa's "length" property is VARn + 1. 
*0*perform ! FUNCcreatedataproperty(VARa, "index", VARlastindex). 
*0*perform ! FUNCcreatedataproperty(VARa, "input", VARs). 
*0*let VARmatchedsubstr be the matched substring (i.e. the portion of VARs between offset VARlastindex inclusive and offset VARe exclusive). 
*0*perform ! FUNCcreatedataproperty(VARa, "0", VARmatchedsubstr). 
*0*if VARr contains any groupname, then
*1*let VARgroups be FUNCobjectcreate(null). 
*0*else,
*1*let VARgroups be undefined. 
*0*perform ! FUNCcreatedataproperty(VARa, "groups", VARgroups). 
*0*for each integer VARi such that VARi &gt; 0 and VARi ≤ VARn, do
*1*let VARcapturei be VARith element of VARr's VARcaptures list. 
*1*if VARcapturei is undefined, let VARcapturedvalue be undefined. 
*1*else if VARfullunicode is true, then
*2*assert: VARcapturei is a list of code points. 
*2*let VARcapturedvalue be the string value whose code units are the utf16encoding of the code points of VARcapturei. 
*1*else VARfullunicode is false,
*2*assert: VARcapturei is a list of code units. 
*2*let VARcapturedvalue be the string value consisting of the code units of VARcapturei. 
*1*perform ! FUNCcreatedataproperty(VARa, ! FUNCtostring(VARi), VARcapturedvalue). 
*1*if the VARith capture of VARr was defined with a groupname, then
*2*let VARs be the stringvalue of the corresponding regexpidentifiername. 
*2*perform ! FUNCcreatedataproperty(VARgroups, VARs, VARcapturedvalue). 
*0*return VARa.      

############# END ## 478 ###########################
############# BEGIN ## 479 ###########################
ID= 21.2.5.2.3
Summary= AdvanceStringIndex ( S, index, unicode )
Description= The abstract operation AdvanceStringIndex with arguments S, index, and unicode performs the following steps:
*0*assert: FUNCtype(VARs) is string. 
*0*assert: VARindex is an integer such that 0≤VARindex≤253-1. 
*0*assert: FUNCtype(VARunicode) is boolean. 
*0*if VARunicode is false, return VARindex+1. 
*0*let VARlength be the number of code units in VARs. 
*0*if VARindex+1 ≥ VARlength, return VARindex+1. 
*0*let VARfirst be the numeric value of the code unit at index VARindex within VARs. 
*0*if VARfirst &lt; 0xd800 or VARfirst &gt; 0xdbff, return VARindex+1. 
*0*let VARsecond be the numeric value of the code unit at index VARindex+1 within VARs. 
*0*if VARsecond &lt; 0xdc00 or VARsecond &gt; 0xdfff, return VARindex+1. 
*0*return VARindex+2.      

############# END ## 479 ###########################
############# BEGIN ## 480 ###########################
ID= 21.2.5.7
Summary= RegExp.prototype [ @@match ] ( string )
Description= When the @@match method is called with argument string, the following steps are taken:
*0*let VARrx be the this value. 
*0*if FUNCtype(VARrx) is not object, throw a typeerror exception. 
*0*let VARs be ? FUNCtostring(VARstring). 
*0*let VARglobal be FUNCtoboolean(? FUNCget(VARrx, "global")). 
*0*if VARglobal is false, then
*1*return ? FUNCregexpexec(VARrx, VARs). 
*0*else VARglobal is true,
*1*let VARfullunicode be FUNCtoboolean(? FUNCget(VARrx, "unicode")). 
*1*perform ? FUNCset(VARrx, "lastindex", 0, true). 
*1*let VARa be ! FUNCarraycreate(0). 
*1*let VARn be 0. 
*1*repeat,
*2*let VARresult be ? FUNCregexpexec(VARrx, VARs). 
*2*if VARresult is null, then
*3*if VARn=0, return null. 
*3*return VARa. 
*2*else VARresult is not null,
*3*let VARmatchstr be ? FUNCtostring(? FUNCget(VARresult, "0")). 
*3*let VARstatus be FUNCcreatedataproperty(VARa, ! FUNCtostring(VARn), VARmatchstr). 
*3*assert: VARstatus is true. 
*3*if VARmatchstr is the empty string, then
*4*let VARthisindex be ? FUNCtolength(? FUNCget(VARrx, "lastindex")). 
*4*let VARnextindex be FUNCadvancestringindex(VARs, VARthisindex, VARfullunicode). 
*4*perform ? FUNCset(VARrx, "lastindex", VARnextindex, true). 
*3*increment VARn.     

############# END ## 480 ###########################
############# BEGIN ## 481 ###########################
ID= 21.2.5.9
Summary= RegExp.prototype [ @@replace ] ( string, replaceValue )
Description= When the @@replace method is called with arguments string and replaceValue, the following steps are taken:
*0*let VARrx be the this value. 
*0*if FUNCtype(VARrx) is not object, throw a typeerror exception. 
*0*let VARs be ? FUNCtostring(VARstring). 
*0*let VARlengths be the number of code unit elements in VARs. 
*0*let VARfunctionalreplace be FUNCiscallable(VARreplacevalue). 
*0*if VARfunctionalreplace is false, then
*1*let VARreplacevalue be ? FUNCtostring(VARreplacevalue). 
*0*let VARglobal be FUNCtoboolean(? FUNCget(VARrx, "global")). 
*0*if VARglobal is true, then
*1*let VARfullunicode be FUNCtoboolean(? FUNCget(VARrx, "unicode")). 
*1*perform ? FUNCset(VARrx, "lastindex", 0, true). 
*0*let VARresults be a new empty list. 
*0*let VARdone be false. 
*0*repeat, while VARdone is false
*1*let VARresult be ? FUNCregexpexec(VARrx, VARs). 
*1*if VARresult is null, set VARdone to true. 
*1*else VARresult is not null,
*2*append VARresult to the end of VARresults. 
*2*if VARglobal is false, set VARdone to true. 
*2*else,
*3*let VARmatchstr be ? FUNCtostring(? FUNCget(VARresult, "0")). 
*3*if VARmatchstr is the empty string, then
*4*let VARthisindex be ? FUNCtolength(? FUNCget(VARrx, "lastindex")). 
*4*let VARnextindex be FUNCadvancestringindex(VARs, VARthisindex, VARfullunicode). 
*4*perform ? FUNCset(VARrx, "lastindex", VARnextindex, true). 
*0*let VARaccumulatedresult be the empty string value. 
*0*let VARnextsourceposition be 0. 
*0*for each VARresult in VARresults, do
*1*let VARncaptures be ? FUNCtolength(? FUNCget(VARresult, "length")). 
*1*let VARncaptures be max(VARncaptures - 1, 0). 
*1*let VARmatched be ? FUNCtostring(? FUNCget(VARresult, "0")). 
*1*let VARmatchlength be the number of code units in VARmatched. 
*1*let VARposition be ? FUNCtointeger(? FUNCget(VARresult, "index")). 
*1*let VARposition be max(min(VARposition, VARlengths), 0). 
*1*let VARn be 1. 
*1*let VARcaptures be a new empty list. 
*1*repeat, while VARn ≤ VARncaptures
*2*let VARcapn be ? FUNCget(VARresult, ! FUNCtostring(VARn)). 
*2*if VARcapn is not undefined, then
*3*let VARcapn be ? FUNCtostring(VARcapn). 
*2*append VARcapn as the last element of VARcaptures. 
*2*let VARn be VARn+1. 
*1*let VARnamedcaptures be ? FUNCget(VARresult, "groups"). 
*1*if VARfunctionalreplace is true, then
*2*let VARreplacerargs be « VARmatched ». 
*2*append in list order the elements of VARcaptures to the end of the list VARreplacerargs. 
*2*append VARposition and VARs to VARreplacerargs. 
*2*if VARnamedcaptures is not undefined, then
*3*append VARnamedcaptures as the last element of VARreplacerargs. 
*2*let VARreplvalue be ? FUNCcall(VARreplacevalue, undefined, VARreplacerargs). 
*2*let VARreplacement be ? FUNCtostring(VARreplvalue). 
*1*else,
*2*let VARreplacement be FUNCgetsubstitution(VARmatched, VARs, VARposition, VARcaptures, VARnamedcaptures, VARreplacevalue). 
*1*if VARposition ≥ VARnextsourceposition, then
*2*note: VARposition should not normally move backwards. if it does, it is an indication of an ill-behaving regexp subclass or use of an access triggered side-effect to change the global flag or other characteristics of VARrx. in such cases, the corresponding substitution is ignored. 
*2*let VARaccumulatedresult be the string-concatenation of the current value of VARaccumulatedresult, the substring of VARs consisting of the code units from VARnextsourceposition (inclusive) up to VARposition (exclusive), and VARreplacement. 
*2*let VARnextsourceposition be VARposition + VARmatchlength. 
*0*if VARnextsourceposition ≥ VARlengths, return VARaccumulatedresult. 
*0*return the string-concatenation of VARaccumulatedresult and the substring of VARs consisting of the code units from VARnextsourceposition (inclusive) up through the final code unit of VARs (inclusive).     

############# END ## 481 ###########################
############# BEGIN ## 482 ###########################
ID= 21.2.5.10
Summary= RegExp.prototype [ @@search ] ( string )
Description= When the @@search method is called with argument string, the following steps are taken:
*0*let VARrx be the this value. 
*0*if FUNCtype(VARrx) is not object, throw a typeerror exception. 
*0*let VARs be ? FUNCtostring(VARstring). 
*0*let VARpreviouslastindex be ? FUNCget(VARrx, "lastindex"). 
*0*if FUNCsamevalue(VARpreviouslastindex, 0) is false, then
*1*perform ? FUNCset(VARrx, "lastindex", 0, true). 
*0*let VARresult be ? FUNCregexpexec(VARrx, VARs). 
*0*let VARcurrentlastindex be ? FUNCget(VARrx, "lastindex"). 
*0*if FUNCsamevalue(VARcurrentlastindex, VARpreviouslastindex) is false, then
*1*perform ? FUNCset(VARrx, "lastindex", VARpreviouslastindex, true). 
*0*if VARresult is null, return -1. 
*0*return ? FUNCget(VARresult, "index").     

############# END ## 482 ###########################
############# BEGIN ## 483 ###########################
ID= 21.2.5.12
Summary= RegExp.prototype [ @@split ] ( string, limit )
Description= Returns an Array object into which substrings of the result of converting string to a String have been stored. The substrings are determined by searching from left to right for matches of the this value regular expression; these occurrences are not part of any substring in the returned array, but serve to divide up the String value.
*0*let VARrx be the this value. 
*0*if FUNCtype(VARrx) is not object, throw a typeerror exception. 
*0*let VARs be ? FUNCtostring(VARstring). 
*0*let VARc be ? FUNCspeciesconstructor(VARrx, %regexp%). 
*0*let VARflags be ? FUNCtostring(? FUNCget(VARrx, "flags")). 
*0*if VARflags contains "u", let VARunicodematching be true. 
*0*else, let VARunicodematching be false. 
*0*if VARflags contains "y", let VARnewflags be VARflags. 
*0*else, let VARnewflags be the string-concatenation of VARflags and "y". 
*0*let VARsplitter be ? FUNCconstruct(VARc, « VARrx, VARnewflags »). 
*0*let VARa be ! FUNCarraycreate(0). 
*0*let VARlengtha be 0. 
*0*if VARlimit is undefined, let VARlim be 232-1; else let VARlim be ? FUNCtouint32(VARlimit). 
*0*let VARsize be the length of VARs. 
*0*let VARp be 0. 
*0*if VARlim = 0, return VARa. 
*0*if VARsize = 0, then
*1*let VARz be ? FUNCregexpexec(VARsplitter, VARs). 
*1*if VARz is not null, return VARa. 
*1*perform ! FUNCcreatedataproperty(VARa, "0", VARs). 
*1*return VARa. 
*0*let VARq be VARp. 
*0*repeat, while VARq &lt; VARsize
*1*perform ? FUNCset(VARsplitter, "lastindex", VARq, true). 
*1*let VARz be ? FUNCregexpexec(VARsplitter, VARs). 
*1*if VARz is null, let VARq be FUNCadvancestringindex(VARs, VARq, VARunicodematching). 
*1*else VARz is not null,
*2*let VARe be ? FUNCtolength(? FUNCget(VARsplitter, "lastindex")). 
*2*let VARe be min(VARe, VARsize). 
*2*if VARe = VARp, let VARq be FUNCadvancestringindex(VARs, VARq, VARunicodematching). 
*2*else VARe ≠ VARp,
*3*let VARt be the string value equal to the substring of VARs consisting of the elements at indices VARp (inclusive) through VARq (exclusive). 
*3*perform ! FUNCcreatedataproperty(VARa, ! FUNCtostring(VARlengtha), VARt). 
*3*let VARlengtha be VARlengtha + 1. 
*3*if VARlengtha = VARlim, return VARa. 
*3*let VARp be VARe. 
*3*let VARnumberofcaptures be ? FUNCtolength(? FUNCget(VARz, "length")). 
*3*let VARnumberofcaptures be max(VARnumberofcaptures-1, 0). 
*3*let VARi be 1. 
*3*repeat, while VARi ≤ VARnumberofcaptures,
*4*let VARnextcapture be ? FUNCget(VARz, ! FUNCtostring(VARi)). 
*4*perform ! FUNCcreatedataproperty(VARa, ! FUNCtostring(VARlengtha), VARnextcapture). 
*4*let VARi be VARi + 1. 
*4*let VARlengtha be VARlengtha + 1. 
*4*if VARlengtha = VARlim, return VARa. 
*3*let VARq be VARp. 
*0*let VARt be the string value equal to the substring of VARs consisting of the elements at indices VARp (inclusive) through VARsize (exclusive). 
*0*perform ! FUNCcreatedataproperty(VARa, ! FUNCtostring(VARlengtha), VARt). 
*0*return VARa.     

############# END ## 483 ###########################
############# BEGIN ## 484 ###########################
ID= 21.2.5.14
Summary= RegExp.prototype.test ( S )
Description= The following steps are taken:
*0*let VARr be the this value. 
*0*if FUNCtype(VARr) is not object, throw a typeerror exception. 
*0*let VARstring be ? FUNCtostring(VARs). 
*0*let VARmatch be ? FUNCregexpexec(VARr, VARstring). 
*0*if VARmatch is not null, return true; else return false.     

############# END ## 484 ###########################
############# BEGIN ## 485 ###########################
ID= 21.2.5.15
Summary= RegExp.prototype.toString ( )
Description= The returned String has the form of a RegularExpressionLiteral that evaluates to another RegExp object with the same behaviour as this object.
*0*let VARr be the this value. 
*0*if FUNCtype(VARr) is not object, throw a typeerror exception. 
*0*let VARpattern be ? FUNCtostring(? FUNCget(VARr, "source")). 
*0*let VARflags be ? FUNCtostring(? FUNCget(VARr, "flags")). 
*0*let VARresult be the string-concatenation of "/", VARpattern, "/", and VARflags. 
*0*return VARresult.     

############# END ## 485 ###########################
############# BEGIN ## 486 ###########################
ID= 22.1.1.1
Summary= Array ( )
Description= This description applies if and only if the Array constructor is called with no arguments.
*0*let VARnumberofargs be the number of arguments passed to this function call. 
*0*assert: VARnumberofargs = 0. 
*0*if newtarget is undefined, let VARnewtarget be the active function object, else let VARnewtarget be newtarget. 
*0*let VARproto be ? FUNCgetprototypefromconstructor(VARnewtarget, "%arrayprototype%"). 
*0*return ! FUNCarraycreate(0, VARproto).     

############# END ## 486 ###########################
############# BEGIN ## 487 ###########################
ID= 22.1.1.2
Summary= Array ( len )
Description= This description applies if and only if the Array constructor is called with exactly one argument.
*0*let VARnumberofargs be the number of arguments passed to this function call. 
*0*assert: VARnumberofargs = 1. 
*0*if newtarget is undefined, let VARnewtarget be the active function object, else let VARnewtarget be newtarget. 
*0*let VARproto be ? FUNCgetprototypefromconstructor(VARnewtarget, "%arrayprototype%"). 
*0*let VARarray be ! FUNCarraycreate(0, VARproto). 
*0*if FUNCtype(VARlen) is not number, then
*1*let VARdefinestatus be FUNCcreatedataproperty(VARarray, "0", VARlen). 
*1*assert: VARdefinestatus is true. 
*1*let VARintlen be 1. 
*0*else,
*1*let VARintlen be FUNCtouint32(VARlen). 
*1*if VARintlen ≠ VARlen, throw a rangeerror exception. 
*0*perform ! FUNCset(VARarray, "length", VARintlen, true). 
*0*return VARarray.     

############# END ## 487 ###########################
############# BEGIN ## 488 ###########################
ID= 22.1.1.3
Summary= Array ( ...items )
Description= This description applies if and only if the Array constructor is called with at least two arguments.
*0*let VARnumberofargs be the number of arguments passed to this function call. 
*0*assert: VARnumberofargs ≥ 2. 
*0*if newtarget is undefined, let VARnewtarget be the active function object, else let VARnewtarget be newtarget. 
*0*let VARproto be ? FUNCgetprototypefromconstructor(VARnewtarget, "%arrayprototype%"). 
*0*let VARarray be ? FUNCarraycreate(VARnumberofargs, VARproto). 
*0*let VARk be 0. 
*0*let VARitems be a zero-origined list containing the argument items in order. 
*0*repeat, while VARk &lt; VARnumberofargs
*1*let VARpk be ! FUNCtostring(VARk). 
*1*let VARitemk be VARitems[VARk]. 
*1*let VARdefinestatus be FUNCcreatedataproperty(VARarray, VARpk, VARitemk). 
*1*assert: VARdefinestatus is true. 
*1*increase VARk by 1. 
*0*assert: the value of VARarray's length property is VARnumberofargs. 
*0*return VARarray.     

############# END ## 488 ###########################
############# BEGIN ## 489 ###########################
ID= 22.1.2.1
Summary= Array.from ( items [ , mapfn [ , thisArg ] ] )
Description= When the from method is called with argument items and optional arguments mapfn and thisArg, the following steps are taken:
*0*let VARc be the this value. 
*0*if VARmapfn is undefined, let VARmapping be false. 
*0*else,
*1*if FUNCiscallable(VARmapfn) is false, throw a typeerror exception. 
*1*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*1*let VARmapping be true. 
*0*let VARusingiterator be ? FUNCgetmethod(VARitems, @@iterator). 
*0*if VARusingiterator is not undefined, then
*1*if FUNCisconstructor(VARc) is true, then
*2*let VARa be ? FUNCconstruct(VARc). 
*1*else,
*2*let VARa be ! FUNCarraycreate(0). 
*1*let VARiteratorrecord be ? FUNCgetiterator(VARitems, sync, VARusingiterator). 
*1*let VARk be 0. 
*1*repeat,
*2*if VARk ≥ 253-1, then
*3*let VARerror be FUNCthrowcompletion(a newly created typeerror object). 
*3*return ? FUNCiteratorclose(VARiteratorrecord, VARerror). 
*2*let VARpk be ! FUNCtostring(VARk). 
*2*let VARnext be ? FUNCiteratorstep(VARiteratorrecord). 
*2*if VARnext is false, then
*3*perform ? FUNCset(VARa, "length", VARk, true). 
*3*return VARa. 
*2*let VARnextvalue be ? FUNCiteratorvalue(VARnext). 
*2*if VARmapping is true, then
*3*let VARmappedvalue be FUNCcall(VARmapfn, VARt, « VARnextvalue, VARk »). 
*3*if VARmappedvalue is an FUNCabrupt completion, return ? iteratorclose(VARiteratorrecord, VARmappedvalue). 
*3*let VARmappedvalue be VARmappedvalue.[[VALUE]]. 
*2*else, let VARmappedvalue be VARnextvalue. 
*2*let VARdefinestatus be FUNCcreatedatapropertyorthrow(VARa, VARpk, VARmappedvalue). 
*2*if VARdefinestatus is an FUNCabrupt completion, return ? iteratorclose(VARiteratorrecord, VARdefinestatus). 
*2*increase VARk by 1. 
*0*note: VARitems is not an iterable so assume it is an array-like object. 
*0*let VARarraylike be ! FUNCtoobject(VARitems). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARarraylike, "length")). 
*0*if FUNCisconstructor(VARc) is true, then
*1*let VARa be ? FUNCconstruct(VARc, « VARlen »). 
*0*else,
*1*let VARa be ? FUNCarraycreate(VARlen). 
*0*let VARk be 0. 
*0*repeat, while VARk &lt; VARlen
*1*let VARpk be ! FUNCtostring(VARk). 
*1*let VARkvalue be ? FUNCget(VARarraylike, VARpk). 
*1*if VARmapping is true, then
*2*let VARmappedvalue be ? FUNCcall(VARmapfn, VARt, « VARkvalue, VARk »). 
*1*else, let VARmappedvalue be VARkvalue. 
*1*perform ? FUNCcreatedatapropertyorthrow(VARa, VARpk, VARmappedvalue). 
*1*increase VARk by 1. 
*0*perform ? FUNCset(VARa, "length", VARlen, true). 
*0*return VARa.     

############# END ## 489 ###########################
############# BEGIN ## 490 ###########################
ID= 22.1.2.2
Summary= Array.isArray ( arg )
Description= The isArray function takes one argument arg, and performs the following steps:
*0*return ? FUNCisarray(VARarg).     

############# END ## 490 ###########################
############# BEGIN ## 491 ###########################
ID= 22.1.2.3
Summary= Array.of ( ...items )
Description= When the of method is called with any number of arguments, the following steps are taken:
*0*let VARlen be the actual number of arguments passed to this function. 
*0*let VARitems be the list of arguments passed to this function. 
*0*let VARc be the this value. 
*0*if FUNCisconstructor(VARc) is true, then
*1*let VARa be ? FUNCconstruct(VARc, « VARlen »). 
*0*else,
*1*let VARa be ? FUNCarraycreate(VARlen). 
*0*let VARk be 0. 
*0*repeat, while VARk &lt; VARlen
*1*let VARkvalue be VARitems[VARk]. 
*1*let VARpk be ! FUNCtostring(VARk). 
*1*perform ? FUNCcreatedatapropertyorthrow(VARa, VARpk, VARkvalue). 
*1*increase VARk by 1. 
*0*perform ? FUNCset(VARa, "length", VARlen, true). 
*0*return VARa.     

############# END ## 491 ###########################
############# BEGIN ## 492 ###########################
ID= 22.1.3.1
Summary= Array.prototype.concat ( ...arguments )
Description= When the concat method is called with zero or more arguments, it returns an array containing the array elements of the object followed by the array elements of each argument in order.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARa be ? FUNCarrayspeciescreate(VARo, 0). 
*0*let VARn be 0. 
*0*let VARitems be a list whose first element is VARo and whose subsequent elements are, in left to right order, the arguments that were passed to this function invocation. 
*0*repeat, while VARitems is not empty
*1*remove the first element from VARitems and let VARe be the value of the element. 
*1*let VARspreadable be ? FUNCisconcatspreadable(VARe). 
*1*if VARspreadable is true, then
*2*let VARk be 0. 
*2*let VARlen be ? FUNCtolength(? FUNCget(VARe, "length")). 
*2*if VARn + VARlen &gt; 253-1, throw a typeerror exception. 
*2*repeat, while VARk &lt; VARlen
*3*let VARp be ! FUNCtostring(VARk). 
*3*let VARexists be ? FUNChasproperty(VARe, VARp). 
*3*if VARexists is true, then
*4*let VARsubelement be ? FUNCget(VARe, VARp). 
*4*perform ? FUNCcreatedatapropertyorthrow(VARa, ! FUNCtostring(VARn), VARsubelement). 
*3*increase VARn by 1. 
*3*increase VARk by 1. 
*1*else VARe is added as a single item rather than spread,
*2*if VARn≥253-1, throw a typeerror exception. 
*2*perform ? FUNCcreatedatapropertyorthrow(VARa, ! FUNCtostring(VARn), VARe). 
*2*increase VARn by 1. 
*0*perform ? FUNCset(VARa, "length", VARn, true). 
*0*return VARa.     

############# END ## 492 ###########################
############# BEGIN ## 493 ###########################
ID= 22.1.3.1.1
Summary= Runtime Semantics: IsConcatSpreadable ( O )
Description= The abstract operation IsConcatSpreadable with argument O performs the following steps:
*0*if FUNCtype(VARo) is not object, return false. 
*0*let VARspreadable be ? FUNCget(VARo, @@isconcatspreadable). 
*0*if VARspreadable is not undefined, return FUNCtoboolean(VARspreadable). 
*0*return ? FUNCisarray(VARo).      

############# END ## 493 ###########################
############# BEGIN ## 494 ###########################
ID= 22.1.3.3
Summary= Array.prototype.copyWithin ( target, start [ , end ] )
Description= The copyWithin method takes up to three arguments target, start and end.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*let VARrelativetarget be ? FUNCtointeger(VARtarget). 
*0*if VARrelativetarget &lt; 0, let VARto be max((VARlen + VARrelativetarget), 0); else let VARto be min(VARrelativetarget, VARlen). 
*0*let VARrelativestart be ? FUNCtointeger(VARstart). 
*0*if VARrelativestart &lt; 0, let VARfrom be max((VARlen + VARrelativestart), 0); else let VARfrom be min(VARrelativestart, VARlen). 
*0*if VARend is undefined, let VARrelativeend be VARlen; else let VARrelativeend be ? FUNCtointeger(VARend). 
*0*if VARrelativeend &lt; 0, let VARfinal be max((VARlen + VARrelativeend), 0); else let VARfinal be min(VARrelativeend, VARlen). 
*0*let VARcount be min(VARfinal-VARfrom, VARlen-VARto). 
*0*if VARfrom&lt;VARto and VARto&lt;VARfrom+VARcount, then
*1*let VARdirection be -1. 
*1*let VARfrom be VARfrom + VARcount - 1. 
*1*let VARto be VARto + VARcount - 1. 
*0*else,
*1*let VARdirection be 1. 
*0*repeat, while VARcount &gt; 0
*1*let VARfromkey be ! FUNCtostring(VARfrom). 
*1*let VARtokey be ! FUNCtostring(VARto). 
*1*let VARfrompresent be ? FUNChasproperty(VARo, VARfromkey). 
*1*if VARfrompresent is true, then
*2*let VARfromval be ? FUNCget(VARo, VARfromkey). 
*2*perform ? FUNCset(VARo, VARtokey, VARfromval, true). 
*1*else VARfrompresent is false,
*2*perform ? FUNCdeletepropertyorthrow(VARo, VARtokey). 
*1*let VARfrom be VARfrom + VARdirection. 
*1*let VARto be VARto + VARdirection. 
*1*let VARcount be VARcount - 1. 
*0*return VARo.     

############# END ## 494 ###########################
############# BEGIN ## 495 ###########################
ID= 22.1.3.4
Summary= Array.prototype.entries ( )
Description= The following steps are taken:
*0*let VARo be ? FUNCtoobject(this value). 
*0*return FUNCcreatearrayiterator(VARo, "key+value").     

############# END ## 495 ###########################
############# BEGIN ## 496 ###########################
ID= 22.1.3.5
Summary= Array.prototype.every ( callbackfn [ , thisArg ] )
Description= callbackfn should be a function that accepts three arguments and returns a value that is coercible to the Boolean value true or false. every calls callbackfn once for each element present in the array, in ascending order, until it finds one where callbackfn returns false. If such an element is found, every immediately returns false. Otherwise, if callbackfn returned true for all elements, every will return true. callbackfn is called only for elements of the array which actually exist; it is not called for missing elements of the array.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*let VARk be 0. 
*0*repeat, while VARk &lt; VARlen
*1*let VARpk be ! FUNCtostring(VARk). 
*1*let VARkpresent be ? FUNChasproperty(VARo, VARpk). 
*1*if VARkpresent is true, then
*2*let VARkvalue be ? FUNCget(VARo, VARpk). 
*2*let VARtestresult be FUNCtoboolean(? FUNCcall(VARcallbackfn, VARt, « VARkvalue, VARk, VARo »)). 
*2*if VARtestresult is false, return false. 
*1*increase VARk by 1. 
*0*return true.     

############# END ## 496 ###########################
############# BEGIN ## 497 ###########################
ID= 22.1.3.6
Summary= Array.prototype.fill ( value [ , start [ , end ] ] )
Description= The fill method takes up to three arguments value, start and end.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*let VARrelativestart be ? FUNCtointeger(VARstart). 
*0*if VARrelativestart &lt; 0, let VARk be max((VARlen + VARrelativestart), 0); else let VARk be min(VARrelativestart, VARlen). 
*0*if VARend is undefined, let VARrelativeend be VARlen; else let VARrelativeend be ? FUNCtointeger(VARend). 
*0*if VARrelativeend &lt; 0, let VARfinal be max((VARlen + VARrelativeend), 0); else let VARfinal be min(VARrelativeend, VARlen). 
*0*repeat, while VARk &lt; VARfinal
*1*let VARpk be ! FUNCtostring(VARk). 
*1*perform ? FUNCset(VARo, VARpk, VARvalue, true). 
*1*increase VARk by 1. 
*0*return VARo.     

############# END ## 497 ###########################
############# BEGIN ## 498 ###########################
ID= 22.1.3.7
Summary= Array.prototype.filter ( callbackfn [ , thisArg ] )
Description= callbackfn should be a function that accepts three arguments and returns a value that is coercible to the Boolean value true or false. filter calls callbackfn once for each element in the array, in ascending order, and constructs a new array of all the values for which callbackfn returns true. callbackfn is called only for elements of the array which actually exist; it is not called for missing elements of the array.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*let VARa be ? FUNCarrayspeciescreate(VARo, 0). 
*0*let VARk be 0. 
*0*let VARto be 0. 
*0*repeat, while VARk &lt; VARlen
*1*let VARpk be ! FUNCtostring(VARk). 
*1*let VARkpresent be ? FUNChasproperty(VARo, VARpk). 
*1*if VARkpresent is true, then
*2*let VARkvalue be ? FUNCget(VARo, VARpk). 
*2*let VARselected be FUNCtoboolean(? FUNCcall(VARcallbackfn, VARt, « VARkvalue, VARk, VARo »)). 
*2*if VARselected is true, then
*3*perform ? FUNCcreatedatapropertyorthrow(VARa, ! FUNCtostring(VARto), VARkvalue). 
*3*increase VARto by 1. 
*1*increase VARk by 1. 
*0*return VARa.     

############# END ## 498 ###########################
############# BEGIN ## 499 ###########################
ID= 22.1.3.8
Summary= Array.prototype.find ( predicate [ , thisArg ] )
Description= The find method is called with one or two arguments, predicate and thisArg.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*if FUNCiscallable(VARpredicate) is false, throw a typeerror exception. 
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*let VARk be 0. 
*0*repeat, while VARk &lt; VARlen
*1*let VARpk be ! FUNCtostring(VARk). 
*1*let VARkvalue be ? FUNCget(VARo, VARpk). 
*1*let VARtestresult be FUNCtoboolean(? FUNCcall(VARpredicate, VARt, « VARkvalue, VARk, VARo »)). 
*1*if VARtestresult is true, return VARkvalue. 
*1*increase VARk by 1. 
*0*return undefined.     

############# END ## 499 ###########################
############# BEGIN ## 500 ###########################
ID= 22.1.3.9
Summary= Array.prototype.findIndex ( predicate [ , thisArg ] )
Description= predicate should be a function that accepts three arguments and returns a value that is coercible to the Boolean value true or false. findIndex calls predicate once for each element of the array, in ascending order, until it finds one where predicate returns true. If such an element is found, findIndex immediately returns the index of that element value. Otherwise, findIndex returns -1.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*if FUNCiscallable(VARpredicate) is false, throw a typeerror exception. 
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*let VARk be 0. 
*0*repeat, while VARk &lt; VARlen
*1*let VARpk be ! FUNCtostring(VARk). 
*1*let VARkvalue be ? FUNCget(VARo, VARpk). 
*1*let VARtestresult be FUNCtoboolean(? FUNCcall(VARpredicate, VARt, « VARkvalue, VARk, VARo »)). 
*1*if VARtestresult is true, return VARk. 
*1*increase VARk by 1. 
*0*return -1.     

############# END ## 500 ###########################
############# BEGIN ## 501 ###########################
ID= 22.1.3.10
Summary= Array.prototype.forEach ( callbackfn [ , thisArg ] )
Description= callbackfn should be a function that accepts three arguments. forEach calls callbackfn once for each element present in the array, in ascending order. callbackfn is called only for elements of the array which actually exist; it is not called for missing elements of the array.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*let VARk be 0. 
*0*repeat, while VARk &lt; VARlen
*1*let VARpk be ! FUNCtostring(VARk). 
*1*let VARkpresent be ? FUNChasproperty(VARo, VARpk). 
*1*if VARkpresent is true, then
*2*let VARkvalue be ? FUNCget(VARo, VARpk). 
*2*perform ? FUNCcall(VARcallbackfn, VARt, « VARkvalue, VARk, VARo »). 
*1*increase VARk by 1. 
*0*return undefined.     

############# END ## 501 ###########################
############# BEGIN ## 502 ###########################
ID= 22.1.3.11
Summary= Array.prototype.includes ( searchElement [ , fromIndex ] )
Description= includes compares searchElement to the elements of the array, in ascending order, using the SameValueZero algorithm, and if found at any position, returns true; otherwise, false is returned.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*if VARlen is 0, return false. 
*0*let VARn be ? FUNCtointeger(VARfromindex). (if VARfromindex is undefined, this step produces the value 0.) 
*0*if VARn ≥ 0, then
*1*let VARk be VARn. 
*0*else VARn &lt; 0,
*1*let VARk be VARlen + VARn. 
*1*if VARk &lt; 0, let VARk be 0. 
*0*repeat, while VARk &lt; VARlen
*1*let VARelementk be the result of ? FUNCget(VARo, ! FUNCtostring(VARk)). 
*1*if FUNCsamevaluezero(VARsearchelement, VARelementk) is true, return true. 
*1*increase VARk by 1. 
*0*return false.     

############# END ## 502 ###########################
############# BEGIN ## 503 ###########################
ID= 22.1.3.12
Summary= Array.prototype.indexOf ( searchElement [ , fromIndex ] )
Description= indexOf compares searchElement to the elements of the array, in ascending order, using the Strict Equality Comparison algorithm, and if found at one or more indices, returns the smallest such index; otherwise, -1 is returned.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*if VARlen is 0, return -1. 
*0*let VARn be ? FUNCtointeger(VARfromindex). (if VARfromindex is undefined, this step produces the value 0.) 
*0*if VARn ≥ VARlen, return -1. 
*0*if VARn ≥ 0, then
*1*if VARn is -0, let VARk be +0; else let VARk be VARn. 
*0*else VARn &lt; 0,
*1*let VARk be VARlen + VARn. 
*1*if VARk &lt; 0, let VARk be 0. 
*0*repeat, while VARk &lt; VARlen
*1*let VARkpresent be ? FUNChasproperty(VARo, ! FUNCtostring(VARk)). 
*1*if VARkpresent is true, then
*2*let VARelementk be ? FUNCget(VARo, ! FUNCtostring(VARk)). 
*2*let VARsame be the result of performing strict equality comparison VARsearchelement === VARelementk. 
*2*if VARsame is true, return VARk. 
*1*increase VARk by 1. 
*0*return -1.     

############# END ## 503 ###########################
############# BEGIN ## 504 ###########################
ID= 22.1.3.13
Summary= Array.prototype.join ( separator )
Description= The elements of the array are converted to Strings, and these Strings are then concatenated, separated by occurrences of the separator. If no separator is provided, a single comma is used as the separator.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*if VARseparator is undefined, let VARsep be the single-element string ",". 
*0*else, let VARsep be ? FUNCtostring(VARseparator). 
*0*let VARr be the empty string. 
*0*let VARk be 0. 
*0*repeat, while VARk &lt; VARlen
*1*if VARk &gt; 0, let VARr be the string-concatenation of VARr and VARsep. 
*1*let VARelement be ? FUNCget(VARo, ! FUNCtostring(VARk)). 
*1*if VARelement is undefined or null, let VARnext be the empty string; otherwise, let VARnext be ? FUNCtostring(VARelement). 
*1*set VARr to the string-concatenation of VARr and VARnext. 
*1*increase VARk by 1. 
*0*return VARr.     

############# END ## 504 ###########################
############# BEGIN ## 505 ###########################
ID= 22.1.3.14
Summary= Array.prototype.keys ( )
Description= The following steps are taken:
*0*let VARo be ? FUNCtoobject(this value). 
*0*return FUNCcreatearrayiterator(VARo, "key").     

############# END ## 505 ###########################
############# BEGIN ## 506 ###########################
ID= 22.1.3.15
Summary= Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] )
Description= lastIndexOf compares searchElement to the elements of the array in descending order using the Strict Equality Comparison algorithm, and if found at one or more indices, returns the largest such index; otherwise, -1 is returned.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*if VARlen is 0, return -1. 
*0*if VARfromindex is present, let VARn be ? FUNCtointeger(VARfromindex); else let VARn be VARlen-1. 
*0*if VARn ≥ 0, then
*1*if VARn is -0, let VARk be +0; else let VARk be min(VARn, VARlen - 1). 
*0*else VARn &lt; 0,
*1*let VARk be VARlen + VARn. 
*0*repeat, while VARk ≥ 0
*1*let VARkpresent be ? FUNChasproperty(VARo, ! FUNCtostring(VARk)). 
*1*if VARkpresent is true, then
*2*let VARelementk be ? FUNCget(VARo, ! FUNCtostring(VARk)). 
*2*let VARsame be the result of performing strict equality comparison VARsearchelement === VARelementk. 
*2*if VARsame is true, return VARk. 
*1*decrease VARk by 1. 
*0*return -1.     

############# END ## 506 ###########################
############# BEGIN ## 507 ###########################
ID= 22.1.3.16
Summary= Array.prototype.map ( callbackfn [ , thisArg ] )
Description= callbackfn should be a function that accepts three arguments. map calls callbackfn once for each element in the array, in ascending order, and constructs a new Array from the results. callbackfn is called only for elements of the array which actually exist; it is not called for missing elements of the array.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*let VARa be ? FUNCarrayspeciescreate(VARo, VARlen). 
*0*let VARk be 0. 
*0*repeat, while VARk &lt; VARlen
*1*let VARpk be ! FUNCtostring(VARk). 
*1*let VARkpresent be ? FUNChasproperty(VARo, VARpk). 
*1*if VARkpresent is true, then
*2*let VARkvalue be ? FUNCget(VARo, VARpk). 
*2*let VARmappedvalue be ? FUNCcall(VARcallbackfn, VARt, « VARkvalue, VARk, VARo »). 
*2*perform ? FUNCcreatedatapropertyorthrow(VARa, VARpk, VARmappedvalue). 
*1*increase VARk by 1. 
*0*return VARa.     

############# END ## 507 ###########################
############# BEGIN ## 508 ###########################
ID= 22.1.3.17
Summary= Array.prototype.pop ( )
Description= The last element of the array is removed from the array and returned.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*if VARlen is zero, then
*1*perform ? FUNCset(VARo, "length", 0, true). 
*1*return undefined. 
*0*else VARlen &gt; 0,
*1*let VARnewlen be VARlen-1. 
*1*let VARindex be ! FUNCtostring(VARnewlen). 
*1*let VARelement be ? FUNCget(VARo, VARindex). 
*1*perform ? FUNCdeletepropertyorthrow(VARo, VARindex). 
*1*perform ? FUNCset(VARo, "length", VARnewlen, true). 
*1*return VARelement.     

############# END ## 508 ###########################
############# BEGIN ## 509 ###########################
ID= 22.1.3.18
Summary= Array.prototype.push ( ...items )
Description= The arguments are appended to the end of the array, in the order in which they appear. The new length of the array is returned as the result of the call.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*let VARitems be a list whose elements are, in left to right order, the arguments that were passed to this function invocation. 
*0*let VARargcount be the number of elements in VARitems. 
*0*if VARlen + VARargcount &gt; 253-1, throw a typeerror exception. 
*0*repeat, while VARitems is not empty
*1*remove the first element from VARitems and let VARe be the value of the element. 
*1*perform ? FUNCset(VARo, ! FUNCtostring(VARlen), VARe, true). 
*1*let VARlen be VARlen+1. 
*0*perform ? FUNCset(VARo, "length", VARlen, true). 
*0*return VARlen.     

############# END ## 509 ###########################
############# BEGIN ## 510 ###########################
ID= 22.1.3.19
Summary= Array.prototype.reduce ( callbackfn [ , initialValue ] )
Description= callbackfn should be a function that takes four arguments. reduce calls the callback, as a function, once for each element after the first element present in the array, in ascending order.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*if VARlen is 0 and VARinitialvalue is not present, throw a typeerror exception. 
*0*let VARk be 0. 
*0*let VARaccumulator be undefined. 
*0*if VARinitialvalue is present, then
*1*set VARaccumulator to VARinitialvalue. 
*0*else VARinitialvalue is not present,
*1*let VARkpresent be false. 
*1*repeat, while VARkpresent is false and VARk &lt; VARlen
*2*let VARpk be ! FUNCtostring(VARk). 
*2*let VARkpresent be ? FUNChasproperty(VARo, VARpk). 
*2*if VARkpresent is true, then
*3*set VARaccumulator to ? FUNCget(VARo, VARpk). 
*2*increase VARk by 1. 
*1*if VARkpresent is false, throw a typeerror exception. 
*0*repeat, while VARk &lt; VARlen
*1*let VARpk be ! FUNCtostring(VARk). 
*1*let VARkpresent be ? FUNChasproperty(VARo, VARpk). 
*1*if VARkpresent is true, then
*2*let VARkvalue be ? FUNCget(VARo, VARpk). 
*2*set VARaccumulator to ? FUNCcall(VARcallbackfn, undefined, « VARaccumulator, VARkvalue, VARk, VARo »). 
*1*increase VARk by 1. 
*0*return VARaccumulator.     

############# END ## 510 ###########################
############# BEGIN ## 511 ###########################
ID= 22.1.3.20
Summary= Array.prototype.reduceRight ( callbackfn [ , initialValue ] )
Description= callbackfn should be a function that takes four arguments. reduceRight calls the callback, as a function, once for each element after the first element present in the array, in descending order.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*if VARlen is 0 and VARinitialvalue is not present, throw a typeerror exception. 
*0*let VARk be VARlen-1. 
*0*let VARaccumulator be undefined. 
*0*if VARinitialvalue is present, then
*1*set VARaccumulator to VARinitialvalue. 
*0*else VARinitialvalue is not present,
*1*let VARkpresent be false. 
*1*repeat, while VARkpresent is false and VARk ≥ 0
*2*let VARpk be ! FUNCtostring(VARk). 
*2*let VARkpresent be ? FUNChasproperty(VARo, VARpk). 
*2*if VARkpresent is true, then
*3*set VARaccumulator to ? FUNCget(VARo, VARpk). 
*2*decrease VARk by 1. 
*1*if VARkpresent is false, throw a typeerror exception. 
*0*repeat, while VARk ≥ 0
*1*let VARpk be ! FUNCtostring(VARk). 
*1*let VARkpresent be ? FUNChasproperty(VARo, VARpk). 
*1*if VARkpresent is true, then
*2*let VARkvalue be ? FUNCget(VARo, VARpk). 
*2*set VARaccumulator to ? FUNCcall(VARcallbackfn, undefined, « VARaccumulator, VARkvalue, VARk, VARo »). 
*1*decrease VARk by 1. 
*0*return VARaccumulator.     

############# END ## 511 ###########################
############# BEGIN ## 512 ###########################
ID= 22.1.3.21
Summary= Array.prototype.reverse ( )
Description= The elements of the array are rearranged so as to reverse their order. The object is returned as the result of the call.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*let VARmiddle be floor(VARlen/2). 
*0*let VARlower be 0. 
*0*repeat, while VARlower ≠ VARmiddle
*1*let VARupper be VARlen - VARlower - 1. 
*1*let VARupperp be ! FUNCtostring(VARupper). 
*1*let VARlowerp be ! FUNCtostring(VARlower). 
*1*let VARlowerexists be ? FUNChasproperty(VARo, VARlowerp). 
*1*if VARlowerexists is true, then
*2*let VARlowervalue be ? FUNCget(VARo, VARlowerp). 
*1*let VARupperexists be ? FUNChasproperty(VARo, VARupperp). 
*1*if VARupperexists is true, then
*2*let VARuppervalue be ? FUNCget(VARo, VARupperp). 
*1*if VARlowerexists is true and VARupperexists is true, then
*2*perform ? FUNCset(VARo, VARlowerp, VARuppervalue, true). 
*2*perform ? FUNCset(VARo, VARupperp, VARlowervalue, true). 
*1*else if VARlowerexists is false and VARupperexists is true, then
*2*perform ? FUNCset(VARo, VARlowerp, VARuppervalue, true). 
*2*perform ? FUNCdeletepropertyorthrow(VARo, VARupperp). 
*1*else if VARlowerexists is true and VARupperexists is false, then
*2*perform ? FUNCdeletepropertyorthrow(VARo, VARlowerp). 
*2*perform ? FUNCset(VARo, VARupperp, VARlowervalue, true). 
*1*else both VARlowerexists and VARupperexists are false,
*2*no action is required. 
*1*increase VARlower by 1. 
*0*return VARo.     

############# END ## 512 ###########################
############# BEGIN ## 513 ###########################
ID= 22.1.3.22
Summary= Array.prototype.shift ( )
Description= The first element of the array is removed from the array and returned.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*if VARlen is zero, then
*1*perform ? FUNCset(VARo, "length", 0, true). 
*1*return undefined. 
*0*let VARfirst be ? FUNCget(VARo, "0"). 
*0*let VARk be 1. 
*0*repeat, while VARk &lt; VARlen
*1*let VARfrom be ! FUNCtostring(VARk). 
*1*let VARto be ! FUNCtostring(VARk-1). 
*1*let VARfrompresent be ? FUNChasproperty(VARo, VARfrom). 
*1*if VARfrompresent is true, then
*2*let VARfromval be ? FUNCget(VARo, VARfrom). 
*2*perform ? FUNCset(VARo, VARto, VARfromval, true). 
*1*else VARfrompresent is false,
*2*perform ? FUNCdeletepropertyorthrow(VARo, VARto). 
*1*increase VARk by 1. 
*0*perform ? FUNCdeletepropertyorthrow(VARo, ! FUNCtostring(VARlen-1)). 
*0*perform ? FUNCset(VARo, "length", VARlen-1, true). 
*0*return VARfirst.     

############# END ## 513 ###########################
############# BEGIN ## 514 ###########################
ID= 22.1.3.23
Summary= Array.prototype.slice ( start, end )
Description= The slice method takes two arguments, start and end, and returns an array containing the elements of the array from element start up to, but not including, element end (or through the end of the array if end is undefined). If start is negative, it is treated as  length+start where length is the length of the array. If end is negative, it is treated as  length+end where length is the length of the array.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*let VARrelativestart be ? FUNCtointeger(VARstart). 
*0*if VARrelativestart &lt; 0, let VARk be max((VARlen + VARrelativestart), 0); else let VARk be min(VARrelativestart, VARlen). 
*0*if VARend is undefined, let VARrelativeend be VARlen; else let VARrelativeend be ? FUNCtointeger(VARend). 
*0*if VARrelativeend &lt; 0, let VARfinal be max((VARlen + VARrelativeend), 0); else let VARfinal be min(VARrelativeend, VARlen). 
*0*let VARcount be max(VARfinal - VARk, 0). 
*0*let VARa be ? FUNCarrayspeciescreate(VARo, VARcount). 
*0*let VARn be 0. 
*0*repeat, while VARk &lt; VARfinal
*1*let VARpk be ! FUNCtostring(VARk). 
*1*let VARkpresent be ? FUNChasproperty(VARo, VARpk). 
*1*if VARkpresent is true, then
*2*let VARkvalue be ? FUNCget(VARo, VARpk). 
*2*perform ? FUNCcreatedatapropertyorthrow(VARa, ! FUNCtostring(VARn), VARkvalue). 
*1*increase VARk by 1. 
*1*increase VARn by 1. 
*0*perform ? FUNCset(VARa, "length", VARn, true). 
*0*return VARa.     

############# END ## 514 ###########################
############# BEGIN ## 515 ###########################
ID= 22.1.3.24
Summary= Array.prototype.some ( callbackfn [ , thisArg ] )
Description= callbackfn should be a function that accepts three arguments and returns a value that is coercible to the Boolean value true or false. some calls callbackfn once for each element present in the array, in ascending order, until it finds one where callbackfn returns true. If such an element is found, some immediately returns true. Otherwise, some returns false. callbackfn is called only for elements of the array which actually exist; it is not called for missing elements of the array.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*let VARk be 0. 
*0*repeat, while VARk &lt; VARlen
*1*let VARpk be ! FUNCtostring(VARk). 
*1*let VARkpresent be ? FUNChasproperty(VARo, VARpk). 
*1*if VARkpresent is true, then
*2*let VARkvalue be ? FUNCget(VARo, VARpk). 
*2*let VARtestresult be FUNCtoboolean(? FUNCcall(VARcallbackfn, VARt, « VARkvalue, VARk, VARo »)). 
*2*if VARtestresult is true, return true. 
*1*increase VARk by 1. 
*0*return false.     

############# END ## 515 ###########################
############# BEGIN ## 516 ###########################
ID= 22.1.3.25
Summary= Array.prototype.sort ( comparefn )
Description= The elements of this array are sorted. The sort is not necessarily stable (that is, elements that compare equal do not necessarily remain in their original order). If comparefn is not undefined, it should be a function that accepts two arguments x and y and returns a negative value if x &lt; y, zero if x = y, or a positive value if x &gt; y.
*0*if VARcomparefn is not undefined and FUNCiscallable(VARcomparefn) is false, throw a typeerror exception. 
*0*let VARobj be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARobj, "length")).     

############# END ## 516 ###########################
############# BEGIN ## 517 ###########################
ID= 22.1.3.25.1
Summary= Runtime Semantics: SortCompare ( x, y )
Description= The SortCompare abstract operation is called with two arguments x and y. It also has access to the comparefn argument passed to the current invocation of the sort method. The following steps are taken:
*0*if VARx and VARy are both undefined, return +0. 
*0*if VARx is undefined, return 1. 
*0*if VARy is undefined, return -1. 
*0*if VARcomparefn is not undefined, then
*1*let VARv be ? FUNCtonumber(? FUNCcall(VARcomparefn, undefined, « VARx, VARy »)). 
*1*if VARv is nan, return +0. 
*1*return VARv. 
*0*let VARxstring be ? FUNCtostring(VARx). 
*0*let VARystring be ? FUNCtostring(VARy). 
*0*let VARxsmaller be the result of performing abstract relational comparison VARxstring &lt; VARystring. 
*0*if VARxsmaller is true, return -1. 
*0*let VARysmaller be the result of performing abstract relational comparison VARystring &lt; VARxstring. 
*0*if VARysmaller is true, return 1. 
*0*return +0.      

############# END ## 517 ###########################
############# BEGIN ## 518 ###########################
ID= 22.1.3.26
Summary= Array.prototype.splice ( start, deleteCount, ...items )
Description= When the splice method is called with two or more arguments start, deleteCount and zero or more items, the deleteCount elements of the array starting at integer index start are replaced by the arguments items. An Array object containing the deleted elements (if any) is returned.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*let VARrelativestart be ? FUNCtointeger(VARstart). 
*0*if VARrelativestart &lt; 0, let VARactualstart be max((VARlen + VARrelativestart), 0); else let VARactualstart be min(VARrelativestart, VARlen). 
*0*if the number of actual arguments is 0, then
*1*let VARinsertcount be 0. 
*1*let VARactualdeletecount be 0. 
*0*else if the number of actual arguments is 1, then
*1*let VARinsertcount be 0. 
*1*let VARactualdeletecount be VARlen - VARactualstart. 
*0*else,
*1*let VARinsertcount be the number of actual arguments minus 2. 
*1*let VARdc be ? FUNCtointeger(VARdeletecount). 
*1*let VARactualdeletecount be min(max(VARdc, 0), VARlen - VARactualstart). 
*0*if VARlen+VARinsertcount-VARactualdeletecount &gt; 253-1, throw a typeerror exception. 
*0*let VARa be ? FUNCarrayspeciescreate(VARo, VARactualdeletecount). 
*0*let VARk be 0. 
*0*repeat, while VARk &lt; VARactualdeletecount
*1*let VARfrom be ! FUNCtostring(VARactualstart+VARk). 
*1*let VARfrompresent be ? FUNChasproperty(VARo, VARfrom). 
*1*if VARfrompresent is true, then
*2*let VARfromvalue be ? FUNCget(VARo, VARfrom). 
*2*perform ? FUNCcreatedatapropertyorthrow(VARa, ! FUNCtostring(VARk), VARfromvalue). 
*1*increment VARk by 1. 
*0*perform ? FUNCset(VARa, "length", VARactualdeletecount, true). 
*0*let VARitems be a list whose elements are, in left to right order, the portion of the actual argument list starting with the third argument. the list is empty if fewer than three arguments were passed. 
*0*let VARitemcount be the number of elements in VARitems. 
*0*if VARitemcount &lt; VARactualdeletecount, then
*1*let VARk be VARactualstart. 
*1*repeat, while VARk &lt; (VARlen - VARactualdeletecount)
*2*let VARfrom be ! FUNCtostring(VARk+VARactualdeletecount). 
*2*let VARto be ! FUNCtostring(VARk+VARitemcount). 
*2*let VARfrompresent be ? FUNChasproperty(VARo, VARfrom). 
*2*if VARfrompresent is true, then
*3*let VARfromvalue be ? FUNCget(VARo, VARfrom). 
*3*perform ? FUNCset(VARo, VARto, VARfromvalue, true). 
*2*else VARfrompresent is false,
*3*perform ? FUNCdeletepropertyorthrow(VARo, VARto). 
*2*increase VARk by 1. 
*1*let VARk be VARlen. 
*1*repeat, while VARk &gt; (VARlen - VARactualdeletecount + VARitemcount)
*2*perform ? FUNCdeletepropertyorthrow(VARo, ! FUNCtostring(VARk-1)). 
*2*decrease VARk by 1. 
*0*else if VARitemcount &gt; VARactualdeletecount, then
*1*let VARk be (VARlen - VARactualdeletecount). 
*1*repeat, while VARk &gt; VARactualstart
*2*let VARfrom be ! FUNCtostring(VARk + VARactualdeletecount - 1). 
*2*let VARto be ! FUNCtostring(VARk + VARitemcount - 1). 
*2*let VARfrompresent be ? FUNChasproperty(VARo, VARfrom). 
*2*if VARfrompresent is true, then
*3*let VARfromvalue be ? FUNCget(VARo, VARfrom). 
*3*perform ? FUNCset(VARo, VARto, VARfromvalue, true). 
*2*else VARfrompresent is false,
*3*perform ? FUNCdeletepropertyorthrow(VARo, VARto). 
*2*decrease VARk by 1. 
*0*let VARk be VARactualstart. 
*0*repeat, while VARitems is not empty
*1*remove the first element from VARitems and let VARe be the value of that element. 
*1*perform ? FUNCset(VARo, ! FUNCtostring(VARk), VARe, true). 
*1*increase VARk by 1. 
*0*perform ? FUNCset(VARo, "length", VARlen - VARactualdeletecount + VARitemcount, true). 
*0*return VARa.     

############# END ## 518 ###########################
############# BEGIN ## 519 ###########################
ID= 22.1.3.27
Summary= Array.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
Description= An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the Array.prototype.toLocaleString method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of the toLocaleString method is used.
*0*let VARarray be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARarray, "length")). 
*0*let VARseparator be the string value for the list-separator string appropriate for the host environment's current locale (this is derived in an implementation-defined way). 
*0*let VARr be the empty string. 
*0*let VARk be 0. 
*0*repeat, while VARk &lt; VARlen
*1*if VARk &gt; 0, then
*2*set VARr to the string-concatenation of VARr and VARseparator. 
*1*let VARnextelement be ? FUNCget(VARarray, ! FUNCtostring(VARk)). 
*1*if VARnextelement is not undefined or null, then
*2*let VARs be ? FUNCtostring(? FUNCinvoke(VARnextelement, "tolocalestring")). 
*2*set VARr to the string-concatenation of VARr and VARs. 
*1*increase VARk by 1. 
*0*return VARr.     

############# END ## 519 ###########################
############# BEGIN ## 520 ###########################
ID= 22.1.3.28
Summary= Array.prototype.toString ( )
Description= When the toString method is called, the following steps are taken:
*0*let VARarray be ? FUNCtoobject(this value). 
*0*let VARfunc be ? FUNCget(VARarray, "join"). 
*0*if FUNCiscallable(VARfunc) is false, let VARfunc be the intrinsic function %objproto_tostring%. 
*0*return ? FUNCcall(VARfunc, VARarray).     

############# END ## 520 ###########################
############# BEGIN ## 521 ###########################
ID= 22.1.3.29
Summary= Array.prototype.unshift ( ...items )
Description= The arguments are prepended to the start of the array, such that their order within the array is the same as the order in which they appear in the argument list.
*0*let VARo be ? FUNCtoobject(this value). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARo, "length")). 
*0*let VARargcount be the number of actual arguments. 
*0*if VARargcount &gt; 0, then
*1*if VARlen+VARargcount &gt; 253-1, throw a typeerror exception. 
*1*let VARk be VARlen. 
*1*repeat, while VARk &gt; 0,
*2*let VARfrom be ! FUNCtostring(VARk-1). 
*2*let VARto be ! FUNCtostring(VARk+VARargcount-1). 
*2*let VARfrompresent be ? FUNChasproperty(VARo, VARfrom). 
*2*if VARfrompresent is true, then
*3*let VARfromvalue be ? FUNCget(VARo, VARfrom). 
*3*perform ? FUNCset(VARo, VARto, VARfromvalue, true). 
*2*else VARfrompresent is false,
*3*perform ? FUNCdeletepropertyorthrow(VARo, VARto). 
*2*decrease VARk by 1. 
*1*let VARj be 0. 
*1*let VARitems be a list whose elements are, in left to right order, the arguments that were passed to this function invocation. 
*1*repeat, while VARitems is not empty
*2*remove the first element from VARitems and let VARe be the value of that element. 
*2*perform ? FUNCset(VARo, ! FUNCtostring(VARj), VARe, true). 
*2*increase VARj by 1. 
*0*perform ? FUNCset(VARo, "length", VARlen+VARargcount, true). 
*0*return VARlen+VARargcount.     

############# END ## 521 ###########################
############# BEGIN ## 522 ###########################
ID= 22.1.3.30
Summary= Array.prototype.values ( )
Description= The following steps are taken:
*0*let VARo be ? FUNCtoobject(this value). 
*0*return FUNCcreatearrayiterator(VARo, "value").     

############# END ## 522 ###########################
############# BEGIN ## 523 ###########################
ID= 22.1.5.1
Summary= CreateArrayIterator ( array, kind )
Description= Several methods of Array objects return Iterator objects. The abstract operation CreateArrayIterator with arguments array and kind is used to create such iterator objects. It performs the following steps:
*0*assert: FUNCtype(VARarray) is object. 
*0*let VARiterator be FUNCobjectcreate(%arrayiteratorprototype%, « [[ITERATEDOBJECT]], [[ARRAYITERATORNEXTINDEX]], [[ARRAYITERATIONKIND]] »). 
*0*set VARiterator.[[ITERATEDOBJECT]] to VARarray. 
*0*set VARiterator.[[ARRAYITERATORNEXTINDEX]] to 0. 
*0*set VARiterator.[[ARRAYITERATIONKIND]] to VARkind. 
*0*return VARiterator.     

############# END ## 523 ###########################
############# BEGIN ## 524 ###########################
ID= 22.1.5.2.1
Summary= %ArrayIteratorPrototype%.next ( )
Description= None
*0*let VARo be the this value. 
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*if VARo does not have all of the internal slots of an array iterator instance (22.1.5.3), throw a typeerror exception. 
*0*let VARa be VARo.[[ITERATEDOBJECT]]. 
*0*if VARa is undefined, return FUNCcreateiterresultobject(undefined, true). 
*0*let VARindex be VARo.[[ARRAYITERATORNEXTINDEX]]. 
*0*let VARitemkind be VARo.[[ARRAYITERATIONKIND]]. 
*0*if VARa has a [[TYPEDARRAYNAME]] internal slot, then
*1*if FUNCisdetachedbuffer(VARa.[[VIEWEDARRAYBUFFER]]) is true, throw a typeerror exception. 
*1*let VARlen be VARa.[[ARRAYLENGTH]]. 
*0*else,
*1*let VARlen be ? FUNCtolength(? FUNCget(VARa, "length")). 
*0*if VARindex ≥ VARlen, then
*1*set VARo.[[ITERATEDOBJECT]] to undefined. 
*1*return FUNCcreateiterresultobject(undefined, true). 
*0*set VARo.[[ARRAYITERATORNEXTINDEX]] to VARindex+1. 
*0*if VARitemkind is "key", return FUNCcreateiterresultobject(VARindex, false). 
*0*let VARelementkey be ! FUNCtostring(VARindex). 
*0*let VARelementvalue be ? FUNCget(VARa, VARelementkey). 
*0*if VARitemkind is "value", let VARresult be VARelementvalue. 
*0*else,
*1*assert: VARitemkind is "key+value". 
*1*let VARresult be FUNCcreatearrayfromlist(« VARindex, VARelementvalue »). 
*0*return FUNCcreateiterresultobject(VARresult, false).      

############# END ## 524 ###########################
############# BEGIN ## 525 ###########################
ID= 22.2.1.1
Summary= %TypedArray% ( )
Description= The %TypedArray% constructor performs the following steps:
*0*throw a typeerror exception.     

############# END ## 525 ###########################
############# BEGIN ## 526 ###########################
ID= 22.2.2.1
Summary= %TypedArray%.from ( source [ , mapfn [ , thisArg ] ] )
Description= When the from method is called with argument source, and optional arguments mapfn and thisArg, the following steps are taken:
*0*let VARc be the this value. 
*0*if FUNCisconstructor(VARc) is false, throw a typeerror exception. 
*0*if VARmapfn is present and VARmapfn is not undefined, then
*1*if FUNCiscallable(VARmapfn) is false, throw a typeerror exception. 
*1*let VARmapping be true. 
*0*else, let VARmapping be false. 
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*let VARusingiterator be ? FUNCgetmethod(VARsource, @@iterator). 
*0*if VARusingiterator is not undefined, then
*1*let VARvalues be ? FUNCiterabletolist(VARsource, VARusingiterator). 
*1*let VARlen be the number of elements in VARvalues. 
*1*let VARtargetobj be ? typedarraycreate(VARc, « VARlen »). 
*1*let VARk be 0. 
*1*repeat, while VARk &lt; VARlen
*2*let VARpk be ! FUNCtostring(VARk). 
*2*let VARkvalue be the first element of VARvalues and remove that element from VARvalues. 
*2*if VARmapping is true, then
*3*let VARmappedvalue be ? FUNCcall(VARmapfn, VARt, « VARkvalue, VARk »). 
*2*else, let VARmappedvalue be VARkvalue. 
*2*perform ? FUNCset(VARtargetobj, VARpk, VARmappedvalue, true). 
*2*increase VARk by 1. 
*1*assert: VARvalues is now an empty list. 
*1*return VARtargetobj. 
*0*note: VARsource is not an iterable so assume it is already an array-like object. 
*0*let VARarraylike be ! FUNCtoobject(VARsource). 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARarraylike, "length")). 
*0*let VARtargetobj be ? typedarraycreate(VARc, « VARlen »). 
*0*let VARk be 0. 
*0*repeat, while VARk &lt; VARlen
*1*let VARpk be ! FUNCtostring(VARk). 
*1*let VARkvalue be ? FUNCget(VARarraylike, VARpk). 
*1*if VARmapping is true, then
*2*let VARmappedvalue be ? FUNCcall(VARmapfn, VARt, « VARkvalue, VARk »). 
*1*else, let VARmappedvalue be VARkvalue. 
*1*perform ? FUNCset(VARtargetobj, VARpk, VARmappedvalue, true). 
*1*increase VARk by 1. 
*0*return VARtargetobj.     

############# END ## 526 ###########################
############# BEGIN ## 527 ###########################
ID= 22.2.2.1.1
Summary= Runtime Semantics: IterableToList ( items, method )
Description= The abstract operation IterableToList performs the following steps:
*0*let VARiteratorrecord be ? FUNCgetiterator(VARitems, sync, VARmethod). 
*0*let VARvalues be a new empty list. 
*0*let VARnext be true. 
*0*repeat, while VARnext is not false
*1*set VARnext to ? FUNCiteratorstep(VARiteratorrecord). 
*1*if VARnext is not false, then
*2*let VARnextvalue be ? FUNCiteratorvalue(VARnext). 
*2*append VARnextvalue to the end of the list VARvalues. 
*0*return VARvalues.      

############# END ## 527 ###########################
############# BEGIN ## 528 ###########################
ID= 22.2.2.2
Summary= %TypedArray%.of ( ...items )
Description= When the of method is called with any number of arguments, the following steps are taken:
*0*let VARlen be the actual number of arguments passed to this function. 
*0*let VARitems be the list of arguments passed to this function. 
*0*let VARc be the this value. 
*0*if FUNCisconstructor(VARc) is false, throw a typeerror exception. 
*0*let VARnewobj be ? typedarraycreate(VARc, « VARlen »). 
*0*let VARk be 0. 
*0*repeat, while VARk &lt; VARlen
*1*let VARkvalue be VARitems[VARk]. 
*1*let VARpk be ! FUNCtostring(VARk). 
*1*perform ? FUNCset(VARnewobj, VARpk, VARkvalue, true). 
*1*increase VARk by 1. 
*0*return VARnewobj.     

############# END ## 528 ###########################
############# BEGIN ## 529 ###########################
ID= 22.2.3.5
Summary= %TypedArray%.prototype.copyWithin ( target, start [ , end ] )
Description= The interpretation and use of the arguments of %TypedArray%.prototype.copyWithin are the same as for Array.prototype.copyWithin as defined in  22.1.3.3.
*0*let VARo be this value. 
*0*perform ? FUNCvalidatetypedarray(VARo). 
*0*let VARlen be VARo.[[ARRAYLENGTH]]. 
*0*let VARrelativetarget be ? FUNCtointeger(VARtarget). 
*0*if VARrelativetarget &lt; 0, let VARto be max((VARlen + VARrelativetarget), 0); else let VARto be min(VARrelativetarget, VARlen). 
*0*let VARrelativestart be ? FUNCtointeger(VARstart). 
*0*if VARrelativestart &lt; 0, let VARfrom be max((VARlen + VARrelativestart), 0); else let VARfrom be min(VARrelativestart, VARlen). 
*0*if VARend is undefined, let VARrelativeend be VARlen; else let VARrelativeend be ? FUNCtointeger(VARend). 
*0*if VARrelativeend &lt; 0, let VARfinal be max((VARlen + VARrelativeend), 0); else let VARfinal be min(VARrelativeend, VARlen). 
*0*let VARcount be min(VARfinal-VARfrom, VARlen-VARto). 
*0*if VARcount &gt; 0, then
*1*note: the copying must be performed in a manner that preserves the bit-level encoding of the source data. 
*1*let VARbuffer be VARo.[[VIEWEDARRAYBUFFER]]. 
*1*if FUNCisdetachedbuffer(VARbuffer) is true, throw a typeerror exception. 
*1*let VARtypedarrayname be the string value of VARo.[[TYPEDARRAYNAME]]. 
*1*let VARelementsize be the number value of the element size value specified in table 56 for VARtypedarrayname. 
*1*let VARbyteoffset be VARo.[[BYTEOFFSET]]. 
*1*let VARtobyteindex be VARto × VARelementsize + VARbyteoffset. 
*1*let VARfrombyteindex be VARfrom × VARelementsize + VARbyteoffset. 
*1*let VARcountbytes be VARcount × VARelementsize. 
*1*if VARfrombyteindex&lt;VARtobyteindex and VARtobyteindex&lt;VARfrombyteindex+VARcountbytes, then
*2*let VARdirection be -1. 
*2*let VARfrombyteindex be VARfrombyteindex + VARcountbytes - 1. 
*2*let VARtobyteindex be VARtobyteindex + VARcountbytes - 1. 
*1*else,
*2*let VARdirection be 1. 
*1*repeat, while VARcountbytes &gt; 0
*2*let VARvalue be FUNCgetvaluefrombuffer(VARbuffer, VARfrombyteindex, "uint8", true, "unordered"). 
*2*perform FUNCsetvalueinbuffer(VARbuffer, VARtobyteindex, "uint8", VARvalue, true, "unordered"). 
*2*let VARfrombyteindex be VARfrombyteindex + VARdirection. 
*2*let VARtobyteindex be VARtobyteindex + VARdirection. 
*2*let VARcountbytes be VARcountbytes - 1. 
*0*return VARo.     

############# END ## 529 ###########################
############# BEGIN ## 530 ###########################
ID= 22.2.3.5.1
Summary= Runtime Semantics: ValidateTypedArray ( O )
Description= When called with argument O, the following steps are taken:
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*if VARo does not have a [[TYPEDARRAYNAME]] internal slot, throw a typeerror exception. 
*0*assert: VARo has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*let VARbuffer be VARo.[[VIEWEDARRAYBUFFER]]. 
*0*if FUNCisdetachedbuffer(VARbuffer) is true, throw a typeerror exception. 
*0*return VARbuffer.      

############# END ## 530 ###########################
############# BEGIN ## 531 ###########################
ID= 22.2.3.6
Summary= %TypedArray%.prototype.entries ( )
Description= The following steps are taken:
*0*let VARo be the this value. 
*0*perform ? FUNCvalidatetypedarray(VARo). 
*0*return FUNCcreatearrayiterator(VARo, "key+value").     

############# END ## 531 ###########################
############# BEGIN ## 532 ###########################
ID= 22.2.3.8
Summary= %TypedArray%.prototype.fill ( value [ , start [ , end ] ] )
Description= The interpretation and use of the arguments of %TypedArray%.prototype.fill are the same as for Array.prototype.fill as defined in  22.1.3.6.
*0*let VARo be the this value. 
*0*perform ? FUNCvalidatetypedarray(VARo). 
*0*let VARlen be VARo.[[ARRAYLENGTH]]. 
*0*let VARvalue be ? FUNCtonumber(VARvalue). 
*0*let VARrelativestart be ? FUNCtointeger(VARstart). 
*0*if VARrelativestart &lt; 0, let VARk be max((VARlen + VARrelativestart), 0); else let VARk be min(VARrelativestart, VARlen). 
*0*if VARend is undefined, let VARrelativeend be VARlen; else let VARrelativeend be ? FUNCtointeger(VARend). 
*0*if VARrelativeend &lt; 0, let VARfinal be max((VARlen + VARrelativeend), 0); else let VARfinal be min(VARrelativeend, VARlen). 
*0*if FUNCisdetachedbuffer(VARo.[[VIEWEDARRAYBUFFER]]) is true, throw a typeerror exception. 
*0*repeat, while VARk &lt; VARfinal
*1*let VARpk be ! FUNCtostring(VARk). 
*1*perform ! FUNCset(VARo, VARpk, VARvalue, true). 
*1*increase VARk by 1. 
*0*return VARo.     

############# END ## 532 ###########################
############# BEGIN ## 533 ###########################
ID= 22.2.3.9
Summary= %TypedArray%.prototype.filter ( callbackfn [ , thisArg ] )
Description= The interpretation and use of the arguments of %TypedArray%.prototype.filter are the same as for Array.prototype.filter as defined in  22.1.3.7.
*0*let VARo be the this value. 
*0*perform ? FUNCvalidatetypedarray(VARo). 
*0*let VARlen be VARo.[[ARRAYLENGTH]]. 
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*let VARkept be a new empty list. 
*0*let VARk be 0. 
*0*let VARcaptured be 0. 
*0*repeat, while VARk &lt; VARlen
*1*let VARpk be ! FUNCtostring(VARk). 
*1*let VARkvalue be ? FUNCget(VARo, VARpk). 
*1*let VARselected be FUNCtoboolean(? FUNCcall(VARcallbackfn, VARt, « VARkvalue, VARk, VARo »)). 
*1*if VARselected is true, then
*2*append VARkvalue to the end of VARkept. 
*2*increase VARcaptured by 1. 
*1*increase VARk by 1. 
*0*let VARa be ? typedarrayspeciescreate(VARo, « VARcaptured »). 
*0*let VARn be 0. 
*0*for each element VARe of VARkept, do
*1*perform ! FUNCset(VARa, ! FUNCtostring(VARn), VARe, true). 
*1*increment VARn by 1. 
*0*return VARa.     

############# END ## 533 ###########################
############# BEGIN ## 534 ###########################
ID= 22.2.3.16
Summary= %TypedArray%.prototype.keys ( )
Description= The following steps are taken:
*0*let VARo be the this value. 
*0*perform ? FUNCvalidatetypedarray(VARo). 
*0*return FUNCcreatearrayiterator(VARo, "key").     

############# END ## 534 ###########################
############# BEGIN ## 535 ###########################
ID= 22.2.3.19
Summary= %TypedArray%.prototype.map ( callbackfn [ , thisArg ] )
Description= The interpretation and use of the arguments of %TypedArray%.prototype.map are the same as for Array.prototype.map as defined in  22.1.3.16.
*0*let VARo be the this value. 
*0*perform ? FUNCvalidatetypedarray(VARo). 
*0*let VARlen be VARo.[[ARRAYLENGTH]]. 
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*let VARa be ? typedarrayspeciescreate(VARo, « VARlen »). 
*0*let VARk be 0. 
*0*repeat, while VARk &lt; VARlen
*1*let VARpk be ! FUNCtostring(VARk). 
*1*let VARkvalue be ? FUNCget(VARo, VARpk). 
*1*let VARmappedvalue be ? FUNCcall(VARcallbackfn, VARt, « VARkvalue, VARk, VARo »). 
*1*perform ? FUNCset(VARa, VARpk, VARmappedvalue, true). 
*1*increase VARk by 1. 
*0*return VARa.     

############# END ## 535 ###########################
############# BEGIN ## 536 ###########################
ID= 22.2.3.23
Summary= %TypedArray%.prototype.set ( overloaded [ , offset ] )
Description= %TypedArray%.prototype.set is a single function whose behaviour is overloaded based upon the type of its first argument.
*0*assert: VARarray is any ecmascript language value other than an object with a [[TYPEDARRAYNAME]] internal slot. if it is such an object, the definition in 22.2.3.23.2 applies. 
*0*let VARtarget be the this value. 
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*if VARtarget does not have a [[TYPEDARRAYNAME]] internal slot, throw a typeerror exception. 
*0*assert: VARtarget has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*let VARtargetoffset be ? FUNCtointeger(VARoffset). 
*0*if VARtargetoffset &lt; 0, throw a rangeerror exception. 
*0*let VARtargetbuffer be VARtarget.[[VIEWEDARRAYBUFFER]]. 
*0*if FUNCisdetachedbuffer(VARtargetbuffer) is true, throw a typeerror exception. 
*0*let VARtargetlength be VARtarget.[[ARRAYLENGTH]]. 
*0*let VARtargetname be the string value of VARtarget.[[TYPEDARRAYNAME]]. 
*0*let VARtargetelementsize be the number value of the element size value specified in table 56 for VARtargetname. 
*0*let VARtargettype be the string value of the element type value in table 56 for VARtargetname. 
*0*let VARtargetbyteoffset be VARtarget.[[BYTEOFFSET]]. 
*0*let VARsrc be ? FUNCtoobject(VARarray). 
*0*let VARsrclength be ? FUNCtolength(? FUNCget(VARsrc, "length")). 
*0*if VARsrclength + VARtargetoffset &gt; VARtargetlength, throw a rangeerror exception. 
*0*let VARtargetbyteindex be VARtargetoffset × VARtargetelementsize + VARtargetbyteoffset. 
*0*let VARk be 0. 
*0*let VARlimit be VARtargetbyteindex + VARtargetelementsize × VARsrclength. 
*0*repeat, while VARtargetbyteindex &lt; VARlimit
*1*let VARpk be ! FUNCtostring(VARk). 
*1*let VARknumber be ? FUNCtonumber(? FUNCget(VARsrc, VARpk)). 
*1*if FUNCisdetachedbuffer(VARtargetbuffer) is true, throw a typeerror exception. 
*1*perform FUNCsetvalueinbuffer(VARtargetbuffer, VARtargetbyteindex, VARtargettype, VARknumber, true, "unordered"). 
*1*set VARk to VARk + 1. 
*1*set VARtargetbyteindex to VARtargetbyteindex + VARtargetelementsize. 
*0*return undefined.      

############# END ## 536 ###########################
############# BEGIN ## 537 ###########################
ID= 22.2.3.23.1
Summary= %TypedArray%.prototype.set ( array [ , offset ] )
Description= Sets multiple values in this TypedArray, reading the values from the object array. The optional offset value indicates the first element index in this TypedArray where values are written. If omitted, it is assumed to be 0.
*0*assert: VARarray is any ecmascript language value other than an object with a [[TYPEDARRAYNAME]] internal slot. if it is such an object, the definition in 22.2.3.23.2 applies. 
*0*let VARtarget be the this value. 
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*if VARtarget does not have a [[TYPEDARRAYNAME]] internal slot, throw a typeerror exception. 
*0*assert: VARtarget has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*let VARtargetoffset be ? FUNCtointeger(VARoffset). 
*0*if VARtargetoffset &lt; 0, throw a rangeerror exception. 
*0*let VARtargetbuffer be VARtarget.[[VIEWEDARRAYBUFFER]]. 
*0*if FUNCisdetachedbuffer(VARtargetbuffer) is true, throw a typeerror exception. 
*0*let VARtargetlength be VARtarget.[[ARRAYLENGTH]]. 
*0*let VARtargetname be the string value of VARtarget.[[TYPEDARRAYNAME]]. 
*0*let VARtargetelementsize be the number value of the element size value specified in table 56 for VARtargetname. 
*0*let VARtargettype be the string value of the element type value in table 56 for VARtargetname. 
*0*let VARtargetbyteoffset be VARtarget.[[BYTEOFFSET]]. 
*0*let VARsrc be ? FUNCtoobject(VARarray). 
*0*let VARsrclength be ? FUNCtolength(? FUNCget(VARsrc, "length")). 
*0*if VARsrclength + VARtargetoffset &gt; VARtargetlength, throw a rangeerror exception. 
*0*let VARtargetbyteindex be VARtargetoffset × VARtargetelementsize + VARtargetbyteoffset. 
*0*let VARk be 0. 
*0*let VARlimit be VARtargetbyteindex + VARtargetelementsize × VARsrclength. 
*0*repeat, while VARtargetbyteindex &lt; VARlimit
*1*let VARpk be ! FUNCtostring(VARk). 
*1*let VARknumber be ? FUNCtonumber(? FUNCget(VARsrc, VARpk)). 
*1*if FUNCisdetachedbuffer(VARtargetbuffer) is true, throw a typeerror exception. 
*1*perform FUNCsetvalueinbuffer(VARtargetbuffer, VARtargetbyteindex, VARtargettype, VARknumber, true, "unordered"). 
*1*set VARk to VARk + 1. 
*1*set VARtargetbyteindex to VARtargetbyteindex + VARtargetelementsize. 
*0*return undefined.      

############# END ## 537 ###########################
############# BEGIN ## 538 ###########################
ID= 22.2.3.23.2
Summary= %TypedArray%.prototype.set ( typedArray [ , offset ] )
Description= Sets multiple values in this TypedArray, reading the values from the typedArray argument object. The optional offset value indicates the first element index in this TypedArray where values are written. If omitted, it is assumed to be 0.
*0*assert: VARtypedarray has a [[TYPEDARRAYNAME]] internal slot. if it does not, the definition in 22.2.3.23.1 applies. 
*0*let VARtarget be the this value. 
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*if VARtarget does not have a [[TYPEDARRAYNAME]] internal slot, throw a typeerror exception. 
*0*assert: VARtarget has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*let VARtargetoffset be ? FUNCtointeger(VARoffset). 
*0*if VARtargetoffset &lt; 0, throw a rangeerror exception. 
*0*let VARtargetbuffer be VARtarget.[[VIEWEDARRAYBUFFER]]. 
*0*if FUNCisdetachedbuffer(VARtargetbuffer) is true, throw a typeerror exception. 
*0*let VARtargetlength be VARtarget.[[ARRAYLENGTH]]. 
*0*let VARsrcbuffer be VARtypedarray.[[VIEWEDARRAYBUFFER]]. 
*0*if FUNCisdetachedbuffer(VARsrcbuffer) is true, throw a typeerror exception. 
*0*let VARtargetname be the string value of VARtarget.[[TYPEDARRAYNAME]]. 
*0*let VARtargettype be the string value of the element type value in table 56 for VARtargetname. 
*0*let VARtargetelementsize be the number value of the element size value specified in table 56 for VARtargetname. 
*0*let VARtargetbyteoffset be VARtarget.[[BYTEOFFSET]]. 
*0*let VARsrcname be the string value of VARtypedarray.[[TYPEDARRAYNAME]]. 
*0*let VARsrctype be the string value of the element type value in table 56 for VARsrcname. 
*0*let VARsrcelementsize be the number value of the element size value specified in table 56 for VARsrcname. 
*0*let VARsrclength be VARtypedarray.[[ARRAYLENGTH]]. 
*0*let VARsrcbyteoffset be VARtypedarray.[[BYTEOFFSET]]. 
*0*if VARsrclength + VARtargetoffset &gt; VARtargetlength, throw a rangeerror exception. 
*0*if both FUNCissharedarraybuffer(VARsrcbuffer) and FUNCissharedarraybuffer(VARtargetbuffer) are true, then
*1*if VARsrcbuffer.[[ARRAYBUFFERDATA]] and VARtargetbuffer.[[ARRAYBUFFERDATA]] are the same shared data block values, let VARsame be true; else let VARsame be false. 
*0*else, let VARsame be FUNCsamevalue(VARsrcbuffer, VARtargetbuffer). 
*0*if VARsame is true, then
*1*let VARsrcbytelength be VARtypedarray.[[BYTELENGTH]]. 
*1*let VARsrcbuffer be ? FUNCclonearraybuffer(VARsrcbuffer, VARsrcbyteoffset, VARsrcbytelength, %arraybuffer%). 
*1*note: %arraybuffer% is used to clone VARsrcbuffer because is it known to not have any observable side-effects. 
*1*let VARsrcbyteindex be 0. 
*0*else, let VARsrcbyteindex be VARsrcbyteoffset. 
*0*let VARtargetbyteindex be VARtargetoffset × VARtargetelementsize + VARtargetbyteoffset. 
*0*let VARlimit be VARtargetbyteindex + VARtargetelementsize × VARsrclength. 
*0*if FUNCsamevalue(VARsrctype, VARtargettype) is true, then
*1*note: if VARsrctype and VARtargettype are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data. 
*1*repeat, while VARtargetbyteindex &lt; VARlimit
*2*let VARvalue be FUNCgetvaluefrombuffer(VARsrcbuffer, VARsrcbyteindex, "uint8", true, "unordered"). 
*2*perform FUNCsetvalueinbuffer(VARtargetbuffer, VARtargetbyteindex, "uint8", VARvalue, true, "unordered"). 
*2*set VARsrcbyteindex to VARsrcbyteindex + 1. 
*2*set VARtargetbyteindex to VARtargetbyteindex + 1. 
*0*else,
*1*repeat, while VARtargetbyteindex &lt; VARlimit
*2*let VARvalue be FUNCgetvaluefrombuffer(VARsrcbuffer, VARsrcbyteindex, VARsrctype, true, "unordered"). 
*2*perform FUNCsetvalueinbuffer(VARtargetbuffer, VARtargetbyteindex, VARtargettype, VARvalue, true, "unordered"). 
*2*set VARsrcbyteindex to VARsrcbyteindex + VARsrcelementsize. 
*2*set VARtargetbyteindex to VARtargetbyteindex + VARtargetelementsize. 
*0*return undefined.      

############# END ## 538 ###########################
############# BEGIN ## 539 ###########################
ID= 22.2.3.24
Summary= %TypedArray%.prototype.slice ( start, end )
Description= The interpretation and use of the arguments of %TypedArray%.prototype.slice are the same as for Array.prototype.slice as defined in  22.1.3.23. The following steps are taken:
*0*let VARo be the this value. 
*0*perform ? FUNCvalidatetypedarray(VARo). 
*0*let VARlen be VARo.[[ARRAYLENGTH]]. 
*0*let VARrelativestart be ? FUNCtointeger(VARstart). 
*0*if VARrelativestart &lt; 0, let VARk be max((VARlen + VARrelativestart), 0); else let VARk be min(VARrelativestart, VARlen). 
*0*if VARend is undefined, let VARrelativeend be VARlen; else let VARrelativeend be ? FUNCtointeger(VARend). 
*0*if VARrelativeend &lt; 0, let VARfinal be max((VARlen + VARrelativeend), 0); else let VARfinal be min(VARrelativeend, VARlen). 
*0*let VARcount be max(VARfinal - VARk, 0). 
*0*let VARa be ? typedarrayspeciescreate(VARo, « VARcount »). 
*0*let VARsrcname be the string value of VARo.[[TYPEDARRAYNAME]]. 
*0*let VARsrctype be the string value of the element type value in table 56 for VARsrcname. 
*0*let VARtargetname be the string value of VARa.[[TYPEDARRAYNAME]]. 
*0*let VARtargettype be the string value of the element type value in table 56 for VARtargetname. 
*0*if FUNCsamevalue(VARsrctype, VARtargettype) is false, then
*1*let VARn be 0. 
*1*repeat, while VARk &lt; VARfinal
*2*let VARpk be ! FUNCtostring(VARk). 
*2*let VARkvalue be ? FUNCget(VARo, VARpk). 
*2*perform ! FUNCset(VARa, ! FUNCtostring(VARn), VARkvalue). 
*2*increase VARk by 1. 
*2*increase VARn by 1. 
*0*else if VARcount &gt; 0, then
*1*let VARsrcbuffer be VARo.[[VIEWEDARRAYBUFFER]]. 
*1*if FUNCisdetachedbuffer(VARsrcbuffer) is true, throw a typeerror exception. 
*1*let VARtargetbuffer be VARa.[[VIEWEDARRAYBUFFER]]. 
*1*let VARelementsize be the number value of the element size value specified in table 56 for VARsrctype. 
*1*note: if VARsrctype and VARtargettype are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data. 
*1*let VARsrcbyteoffet be VARo.[[BYTEOFFSET]]. 
*1*let VARtargetbyteindex be VARa.[[BYTEOFFSET]]. 
*1*let VARsrcbyteindex be (VARk × VARelementsize) + VARsrcbyteoffet. 
*1*let VARlimit be VARtargetbyteindex + VARcount × VARelementsize. 
*1*repeat, while VARtargetbyteindex &lt; VARlimit
*2*let VARvalue be FUNCgetvaluefrombuffer(VARsrcbuffer, VARsrcbyteindex, "uint8", true, "unordered"). 
*2*perform FUNCsetvalueinbuffer(VARtargetbuffer, VARtargetbyteindex, "uint8", VARvalue, true, "unordered"). 
*2*increase VARsrcbyteindex by 1. 
*2*increase VARtargetbyteindex by 1. 
*0*return VARa.     

############# END ## 539 ###########################
############# BEGIN ## 540 ###########################
ID= 22.2.3.26
Summary= %TypedArray%.prototype.sort ( comparefn )
Description= %TypedArray%.prototype.sort is a distinct function that, except as described below, implements the same requirements as those of Array.prototype.sort as defined in  22.1.3.25. The implementation of the %TypedArray%.prototype.sort specification may be optimized with the knowledge that the this value is an object that has a fixed length and whose  integer-indexed properties are not sparse. The only internal methods of the this object that the algorithm may call are [[Get]] and [[Set]].
*0*if VARcomparefn is not undefined and FUNCiscallable(VARcomparefn) is false, throw a typeerror exception. 
*0*let VARobj be the this value. 
*0*let VARbuffer be ? FUNCvalidatetypedarray(VARobj). 
*0*let VARlen be VARobj.[[ARRAYLENGTH]].     

############# END ## 540 ###########################
############# BEGIN ## 541 ###########################
ID= 22.2.3.27
Summary= %TypedArray%.prototype.subarray ( begin, end )
Description= Returns a new TypedArray object whose element type is the same as this TypedArray and whose ArrayBuffer is the same as the ArrayBuffer of this TypedArray, referencing the elements at begin, inclusive, up to end, exclusive. If either begin or end is negative, it refers to an index from the end of the array, as opposed to from the beginning.
*0*let VARo be the this value. 
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*if VARo does not have a [[TYPEDARRAYNAME]] internal slot, throw a typeerror exception. 
*0*assert: VARo has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*let VARbuffer be VARo.[[VIEWEDARRAYBUFFER]]. 
*0*let VARsrclength be VARo.[[ARRAYLENGTH]]. 
*0*let VARrelativebegin be ? FUNCtointeger(VARbegin). 
*0*if VARrelativebegin &lt; 0, let VARbeginindex be max((VARsrclength + VARrelativebegin), 0); else let VARbeginindex be min(VARrelativebegin, VARsrclength). 
*0*if VARend is undefined, let VARrelativeend be VARsrclength; else, let VARrelativeend be ? FUNCtointeger(VARend). 
*0*if VARrelativeend &lt; 0, let VARendindex be max((VARsrclength + VARrelativeend), 0); else let VARendindex be min(VARrelativeend, VARsrclength). 
*0*let VARnewlength be max(VARendindex - VARbeginindex, 0). 
*0*let VARconstructorname be the string value of VARo.[[TYPEDARRAYNAME]]. 
*0*let VARelementsize be the number value of the element size value specified in table 56 for VARconstructorname. 
*0*let VARsrcbyteoffset be VARo.[[BYTEOFFSET]]. 
*0*let VARbeginbyteoffset be VARsrcbyteoffset + VARbeginindex × VARelementsize. 
*0*let VARargumentslist be « VARbuffer, VARbeginbyteoffset, VARnewlength ». 
*0*return ? typedarrayspeciescreate(VARo, VARargumentslist).     

############# END ## 541 ###########################
############# BEGIN ## 542 ###########################
ID= 22.2.3.30
Summary= %TypedArray%.prototype.values ( )
Description= The following steps are taken:
*0*let VARo be the this value. 
*0*perform ? FUNCvalidatetypedarray(VARo). 
*0*return FUNCcreatearrayiterator(VARo, "value").     

############# END ## 542 ###########################
############# BEGIN ## 543 ###########################
ID= 22.2.4.1
Summary= TypedArray ( )
Description= This description applies only if the TypedArray function is called with no arguments.
*0*if newtarget is undefined, throw a typeerror exception. 
*0*let VARconstructorname be the string value of the constructor name value specified in table 56 for this VARtypedarray constructor. 
*0*return ? FUNCallocatetypedarray(VARconstructorname, newtarget, "%VARtypedarrayprototype%", 0).     

############# END ## 543 ###########################
############# BEGIN ## 544 ###########################
ID= 22.2.4.2
Summary= TypedArray ( length )
Description= This description applies only if the TypedArray function is called with at least one argument and the Type of the first argument is not Object.
*0*assert: FUNCtype(VARlength) is not object. 
*0*if newtarget is undefined, throw a typeerror exception. 
*0*let VARelementlength be ? FUNCtoindex(VARlength). 
*0*let VARconstructorname be the string value of the constructor name value specified in table 56 for this VARtypedarray constructor. 
*0*return ? FUNCallocatetypedarray(VARconstructorname, newtarget, "%VARtypedarrayprototype%", VARelementlength).     

############# END ## 544 ###########################
############# BEGIN ## 545 ###########################
ID= 22.2.4.2.1
Summary= Runtime Semantics: AllocateTypedArray ( constructorName, newTarget, defaultProto [ , length ] )
Description= The abstract operation AllocateTypedArray with arguments constructorName, newTarget, defaultProto and optional argument length is used to validate and create an instance of a TypedArray constructor. constructorName is required to be the name of a TypedArray constructor in  Table 56. If the length argument is passed, an ArrayBuffer of that length is also allocated and associated with the new TypedArray instance. AllocateTypedArray provides common semantics that is used by all of the TypedArray overloads. AllocateTypedArray performs the following steps:
*0*let VARproto be ? FUNCgetprototypefromconstructor(VARnewtarget, VARdefaultproto). 
*0*let VARobj be FUNCintegerindexedobjectcreate(VARproto, « [[VIEWEDARRAYBUFFER]], [[TYPEDARRAYNAME]], [[BYTELENGTH]], [[BYTEOFFSET]], [[ARRAYLENGTH]] »). 
*0*assert: VARobj.[[VIEWEDARRAYBUFFER]] is undefined. 
*0*set VARobj.[[TYPEDARRAYNAME]] to VARconstructorname. 
*0*if VARlength is not present, then
*1*set VARobj.[[BYTELENGTH]] to 0. 
*1*set VARobj.[[BYTEOFFSET]] to 0. 
*1*set VARobj.[[ARRAYLENGTH]] to 0. 
*0*else,
*1*perform ? FUNCallocatetypedarraybuffer(VARobj, VARlength). 
*0*return VARobj.      

############# END ## 545 ###########################
############# BEGIN ## 546 ###########################
ID= 22.2.4.2.2
Summary= Runtime Semantics: AllocateTypedArrayBuffer ( O, length )
Description= The abstract operation AllocateTypedArrayBuffer with arguments O and length allocates and associates an ArrayBuffer with the TypedArray instance O. It performs the following steps:
*0*assert: VARo is an object that has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*assert: VARo.[[VIEWEDARRAYBUFFER]] is undefined. 
*0*assert: VARlength ≥ 0. 
*0*let VARconstructorname be the string value of VARo.[[TYPEDARRAYNAME]]. 
*0*let VARelementsize be the element size value in table 56 for VARconstructorname. 
*0*let VARbytelength be VARelementsize × VARlength. 
*0*let VARdata be ? FUNCallocatearraybuffer(%arraybuffer%, VARbytelength). 
*0*set VARo.[[VIEWEDARRAYBUFFER]] to VARdata. 
*0*set VARo.[[BYTELENGTH]] to VARbytelength. 
*0*set VARo.[[BYTEOFFSET]] to 0. 
*0*set VARo.[[ARRAYLENGTH]] to VARlength. 
*0*return VARo.      

############# END ## 546 ###########################
############# BEGIN ## 547 ###########################
ID= 22.2.4.3
Summary= TypedArray ( typedArray )
Description= This description applies only if the TypedArray function is called with at least one argument and the Type of the first argument is Object and that object has a [[TypedArrayName]] internal slot.
*0*assert: FUNCtype(VARtypedarray) is object and VARtypedarray has a [[TYPEDARRAYNAME]] internal slot. 
*0*if newtarget is undefined, throw a typeerror exception. 
*0*let VARconstructorname be the string value of the constructor name value specified in table 56 for this VARtypedarray constructor. 
*0*let VARo be ? FUNCallocatetypedarray(VARconstructorname, newtarget, "%VARtypedarrayprototype%"). 
*0*let VARsrcarray be VARtypedarray. 
*0*let VARsrcdata be VARsrcarray.[[VIEWEDARRAYBUFFER]]. 
*0*if FUNCisdetachedbuffer(VARsrcdata) is true, throw a typeerror exception. 
*0*let VARelementtype be the string value of the element type value in table 56 for VARconstructorname. 
*0*let VARelementlength be VARsrcarray.[[ARRAYLENGTH]]. 
*0*let VARsrcname be the string value of VARsrcarray.[[TYPEDARRAYNAME]]. 
*0*let VARsrctype be the string value of the element type value in table 56 for VARsrcname. 
*0*let VARsrcelementsize be the element size value in table 56 for VARsrcname. 
*0*let VARsrcbyteoffset be VARsrcarray.[[BYTEOFFSET]]. 
*0*let VARelementsize be the element size value in table 56 for VARconstructorname. 
*0*let VARbytelength be VARelementsize × VARelementlength. 
*0*if FUNCissharedarraybuffer(VARsrcdata) is false, then
*1*let VARbufferconstructor be ? FUNCspeciesconstructor(VARsrcdata, %arraybuffer%). 
*0*else,
*1*let VARbufferconstructor be %arraybuffer%. 
*0*if FUNCsamevalue(VARelementtype, VARsrctype) is true, then
*1*if FUNCisdetachedbuffer(VARsrcdata) is true, throw a typeerror exception. 
*1*let VARdata be ? FUNCclonearraybuffer(VARsrcdata, VARsrcbyteoffset, VARbytelength, VARbufferconstructor). 
*0*else,
*1*let VARdata be ? FUNCallocatearraybuffer(VARbufferconstructor, VARbytelength). 
*1*if FUNCisdetachedbuffer(VARsrcdata) is true, throw a typeerror exception. 
*1*let VARsrcbyteindex be VARsrcbyteoffset. 
*1*let VARtargetbyteindex be 0. 
*1*let VARcount be VARelementlength. 
*1*repeat, while VARcount &gt; 0
*2*let VARvalue be FUNCgetvaluefrombuffer(VARsrcdata, VARsrcbyteindex, VARsrctype, true, "unordered"). 
*2*perform FUNCsetvalueinbuffer(VARdata, VARtargetbyteindex, VARelementtype, VARvalue, true, "unordered"). 
*2*set VARsrcbyteindex to VARsrcbyteindex + VARsrcelementsize. 
*2*set VARtargetbyteindex to VARtargetbyteindex + VARelementsize. 
*2*decrement VARcount by 1. 
*0*set VARo.[[VIEWEDARRAYBUFFER]] to VARdata. 
*0*set VARo.[[BYTELENGTH]] to VARbytelength. 
*0*set VARo.[[BYTEOFFSET]] to 0. 
*0*set VARo.[[ARRAYLENGTH]] to VARelementlength. 
*0*return VARo.     

############# END ## 547 ###########################
############# BEGIN ## 548 ###########################
ID= 22.2.4.4
Summary= TypedArray ( object )
Description= This description applies only if the TypedArray function is called with at least one argument and the Type of the first argument is Object and that object does not have either a [[TypedArrayName]] or an [[ArrayBufferData]] internal slot.
*0*assert: FUNCtype(VARobject) is object and VARobject does not have either a [[TYPEDARRAYNAME]] or an [[ARRAYBUFFERDATA]] internal slot. 
*0*if newtarget is undefined, throw a typeerror exception. 
*0*let VARconstructorname be the string value of the constructor name value specified in table 56 for this VARtypedarray constructor. 
*0*let VARo be ? FUNCallocatetypedarray(VARconstructorname, newtarget, "%VARtypedarrayprototype%"). 
*0*let VARusingiterator be ? FUNCgetmethod(VARobject, @@iterator). 
*0*if VARusingiterator is not undefined, then
*1*let VARvalues be ? FUNCiterabletolist(VARobject, VARusingiterator). 
*1*let VARlen be the number of elements in VARvalues. 
*1*perform ? FUNCallocatetypedarraybuffer(VARo, VARlen). 
*1*let VARk be 0. 
*1*repeat, while VARk &lt; VARlen
*2*let VARpk be ! FUNCtostring(VARk). 
*2*let VARkvalue be the first element of VARvalues and remove that element from VARvalues. 
*2*perform ? FUNCset(VARo, VARpk, VARkvalue, true). 
*2*increase VARk by 1. 
*1*assert: VARvalues is now an empty list. 
*1*return VARo. 
*0*note: VARobject is not an iterable so assume it is already an array-like object. 
*0*let VARarraylike be VARobject. 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARarraylike, "length")). 
*0*perform ? FUNCallocatetypedarraybuffer(VARo, VARlen). 
*0*let VARk be 0. 
*0*repeat, while VARk &lt; VARlen
*1*let VARpk be ! FUNCtostring(VARk). 
*1*let VARkvalue be ? FUNCget(VARarraylike, VARpk). 
*1*perform ? FUNCset(VARo, VARpk, VARkvalue, true). 
*1*increase VARk by 1. 
*0*return VARo.     

############# END ## 548 ###########################
############# BEGIN ## 549 ###########################
ID= 22.2.4.5
Summary= TypedArray ( buffer [ , byteOffset [ , length ] ] )
Description= This description applies only if the TypedArray function is called with at least one argument and the Type of the first argument is Object and that object has an [[ArrayBufferData]] internal slot.
*0*assert: FUNCtype(VARbuffer) is object and VARbuffer has an [[ARRAYBUFFERDATA]] internal slot. 
*0*if newtarget is undefined, throw a typeerror exception. 
*0*let VARconstructorname be the string value of the constructor name value specified in table 56 for this VARtypedarray constructor. 
*0*let VARo be ? FUNCallocatetypedarray(VARconstructorname, newtarget, "%VARtypedarrayprototype%"). 
*0*let VARelementsize be the number value of the element size value in table 56 for VARconstructorname. 
*0*let VARoffset be ? FUNCtoindex(VARbyteoffset). 
*0*if VARoffset modulo VARelementsize ≠ 0, throw a rangeerror exception. 
*0*if VARlength is present and VARlength is not undefined, then
*1*let VARnewlength be ? FUNCtoindex(VARlength). 
*0*if FUNCisdetachedbuffer(VARbuffer) is true, throw a typeerror exception. 
*0*let VARbufferbytelength be VARbuffer.[[ARRAYBUFFERBYTELENGTH]]. 
*0*if VARlength is either not present or undefined, then
*1*if VARbufferbytelength modulo VARelementsize ≠ 0, throw a rangeerror exception. 
*1*let VARnewbytelength be VARbufferbytelength - VARoffset. 
*1*if VARnewbytelength &lt; 0, throw a rangeerror exception. 
*0*else,
*1*let VARnewbytelength be VARnewlength × VARelementsize. 
*1*if VARoffset+VARnewbytelength &gt; VARbufferbytelength, throw a rangeerror exception. 
*0*set VARo.[[VIEWEDARRAYBUFFER]] to VARbuffer. 
*0*set VARo.[[BYTELENGTH]] to VARnewbytelength. 
*0*set VARo.[[BYTEOFFSET]] to VARoffset. 
*0*set VARo.[[ARRAYLENGTH]] to VARnewbytelength / VARelementsize. 
*0*return VARo.     

############# END ## 549 ###########################
############# BEGIN ## 550 ###########################
ID= 22.2.4.6
Summary= TypedArrayCreate ( constructor, argumentList )
Description= The abstract operation TypedArrayCreate with arguments constructor and argumentList is used to specify the creation of a new TypedArray object using a constructor function. It performs the following steps:
*0*let VARnewtypedarray be ? FUNCconstruct(VARconstructor, VARargumentlist). 
*0*perform ? FUNCvalidatetypedarray(VARnewtypedarray). 
*0*if VARargumentlist is a list of a single number, then
*1*if VARnewtypedarray.[[ARRAYLENGTH]] &lt; VARargumentlist[0], throw a typeerror exception. 
*0*return VARnewtypedarray.     

############# END ## 550 ###########################
############# BEGIN ## 551 ###########################
ID= 22.2.4.7
Summary= TypedArraySpeciesCreate ( exemplar, argumentList )
Description= The abstract operation TypedArraySpeciesCreate with arguments exemplar and argumentList is used to specify the creation of a new TypedArray object using a constructor function that is derived from exemplar. It performs the following steps:
*0*assert: VARexemplar is an object that has a [[TYPEDARRAYNAME]] internal slot. 
*0*let VARdefaultconstructor be the intrinsic object listed in column one of table 56 for VARexemplar.[[TYPEDARRAYNAME]]. 
*0*let VARconstructor be ? FUNCspeciesconstructor(VARexemplar, VARdefaultconstructor). 
*0*return ? typedarraycreate(VARconstructor, VARargumentlist).     

############# END ## 551 ###########################
############# BEGIN ## 552 ###########################
ID= 23.1.1.1
Summary= Map ( [ iterable ] )
Description= When the Map function is called with optional argument, the following steps are taken:
*0*if newtarget is undefined, throw a typeerror exception. 
*0*let VARmap be ? FUNCordinarycreatefromconstructor(newtarget, "%mapprototype%", « [[MAPDATA]] »). 
*0*set VARmap.[[MAPDATA]] to a new empty list. 
*0*if VARiterable is not present, let VARiterable be undefined. 
*0*if VARiterable is either undefined or null, return VARmap. 
*0*let VARadder be ? FUNCget(VARmap, "set"). 
*0*if FUNCiscallable(VARadder) is false, throw a typeerror exception. 
*0*let VARiteratorrecord be ? FUNCgetiterator(VARiterable). 
*0*repeat,
*1*let VARnext be ? FUNCiteratorstep(VARiteratorrecord). 
*1*if VARnext is false, return VARmap. 
*1*let VARnextitem be ? FUNCiteratorvalue(VARnext). 
*1*if FUNCtype(VARnextitem) is not object, then
*2*let VARerror be FUNCthrowcompletion(a newly created typeerror object). 
*2*return ? FUNCiteratorclose(VARiteratorrecord, VARerror). 
*1*let VARk be FUNCget(VARnextitem, "0"). 
*1*if VARk is an FUNCabrupt completion, return ? iteratorclose(VARiteratorrecord, VARk). 
*1*let VARv be FUNCget(VARnextitem, "1"). 
*1*if VARv is an FUNCabrupt completion, return ? iteratorclose(VARiteratorrecord, VARv). 
*1*let VARstatus be FUNCcall(VARadder, VARmap, « VARk.[[VALUE]], VARv.[[VALUE]] »). 
*1*if VARstatus is an FUNCabrupt completion, return ? iteratorclose(VARiteratorrecord, VARstatus).     

############# END ## 552 ###########################
############# BEGIN ## 553 ###########################
ID= 23.1.3.1
Summary= Map.prototype.clear ( )
Description= The following steps are taken:
*0*let VARm be the this value. 
*0*if FUNCtype(VARm) is not object, throw a typeerror exception. 
*0*if VARm does not have a [[MAPDATA]] internal slot, throw a typeerror exception. 
*0*let VARentries be the list that is VARm.[[MAPDATA]]. 
*0*for each record { [[KEY]], [[VALUE]] } VARp that is an element of VARentries, do
*1*set VARp.[[KEY]] to empty. 
*1*set VARp.[[VALUE]] to empty. 
*0*return undefined.     

############# END ## 553 ###########################
############# BEGIN ## 554 ###########################
ID= 23.1.3.3
Summary= Map.prototype.delete ( key )
Description= The following steps are taken:
*0*let VARm be the this value. 
*0*if FUNCtype(VARm) is not object, throw a typeerror exception. 
*0*if VARm does not have a [[MAPDATA]] internal slot, throw a typeerror exception. 
*0*let VARentries be the list that is VARm.[[MAPDATA]]. 
*0*for each record { [[KEY]], [[VALUE]] } VARp that is an element of VARentries, do
*1*if VARp.[[KEY]] is not empty and FUNCsamevaluezero(VARp.[[KEY]], VARkey) is true, then
*2*set VARp.[[KEY]] to empty. 
*2*set VARp.[[VALUE]] to empty. 
*2*return true. 
*0*return false.     

############# END ## 554 ###########################
############# BEGIN ## 555 ###########################
ID= 23.1.3.4
Summary= Map.prototype.entries ( )
Description= The following steps are taken:
*0*let VARm be the this value. 
*0*return ? FUNCcreatemapiterator(VARm, "key+value").     

############# END ## 555 ###########################
############# BEGIN ## 556 ###########################
ID= 23.1.3.5
Summary= Map.prototype.forEach ( callbackfn [ , thisArg ] )
Description= When the forEach method is called with one or two arguments, the following steps are taken:
*0*let VARm be the this value. 
*0*if FUNCtype(VARm) is not object, throw a typeerror exception. 
*0*if VARm does not have a [[MAPDATA]] internal slot, throw a typeerror exception. 
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*let VARentries be the list that is VARm.[[MAPDATA]]. 
*0*for each record { [[KEY]], [[VALUE]] } VARe that is an element of VARentries, in original key insertion order, do
*1*if VARe.[[KEY]] is not empty, then
*2*perform ? FUNCcall(VARcallbackfn, VARt, « VARe.[[VALUE]], VARe.[[KEY]], VARm »). 
*0*return undefined.     

############# END ## 556 ###########################
############# BEGIN ## 557 ###########################
ID= 23.1.3.6
Summary= Map.prototype.get ( key )
Description= The following steps are taken:
*0*let VARm be the this value. 
*0*if FUNCtype(VARm) is not object, throw a typeerror exception. 
*0*if VARm does not have a [[MAPDATA]] internal slot, throw a typeerror exception. 
*0*let VARentries be the list that is VARm.[[MAPDATA]]. 
*0*for each record { [[KEY]], [[VALUE]] } VARp that is an element of VARentries, do
*1*if VARp.[[KEY]] is not empty and FUNCsamevaluezero(VARp.[[KEY]], VARkey) is true, return VARp.[[VALUE]]. 
*0*return undefined.     

############# END ## 557 ###########################
############# BEGIN ## 558 ###########################
ID= 23.1.3.7
Summary= Map.prototype.has ( key )
Description= The following steps are taken:
*0*let VARm be the this value. 
*0*if FUNCtype(VARm) is not object, throw a typeerror exception. 
*0*if VARm does not have a [[MAPDATA]] internal slot, throw a typeerror exception. 
*0*let VARentries be the list that is VARm.[[MAPDATA]]. 
*0*for each record { [[KEY]], [[VALUE]] } VARp that is an element of VARentries, do
*1*if VARp.[[KEY]] is not empty and FUNCsamevaluezero(VARp.[[KEY]], VARkey) is true, return true. 
*0*return false.     

############# END ## 558 ###########################
############# BEGIN ## 559 ###########################
ID= 23.1.3.8
Summary= Map.prototype.keys ( )
Description= The following steps are taken:
*0*let VARm be the this value. 
*0*return ? FUNCcreatemapiterator(VARm, "key").     

############# END ## 559 ###########################
############# BEGIN ## 560 ###########################
ID= 23.1.3.9
Summary= Map.prototype.set ( key, value )
Description= The following steps are taken:
*0*let VARm be the this value. 
*0*if FUNCtype(VARm) is not object, throw a typeerror exception. 
*0*if VARm does not have a [[MAPDATA]] internal slot, throw a typeerror exception. 
*0*let VARentries be the list that is VARm.[[MAPDATA]]. 
*0*for each record { [[KEY]], [[VALUE]] } VARp that is an element of VARentries, do
*1*if VARp.[[KEY]] is not empty and FUNCsamevaluezero(VARp.[[KEY]], VARkey) is true, then
*2*set VARp.[[VALUE]] to VARvalue. 
*2*return VARm. 
*0*if VARkey is -0, let VARkey be +0. 
*0*let VARp be the record { [[KEY]]: VARkey, [[VALUE]]: VARvalue }. 
*0*append VARp as the last element of VARentries. 
*0*return VARm.     

############# END ## 560 ###########################
############# BEGIN ## 561 ###########################
ID= 23.1.3.11
Summary= Map.prototype.values ( )
Description= The following steps are taken:
*0*let VARm be the this value. 
*0*return ? FUNCcreatemapiterator(VARm, "value").     

############# END ## 561 ###########################
############# BEGIN ## 562 ###########################
ID= 23.1.5.1
Summary= CreateMapIterator ( map, kind )
Description= Several methods of Map objects return Iterator objects. The abstract operation CreateMapIterator with arguments map and kind is used to create such iterator objects. It performs the following steps:
*0*if FUNCtype(VARmap) is not object, throw a typeerror exception. 
*0*if VARmap does not have a [[MAPDATA]] internal slot, throw a typeerror exception. 
*0*let VARiterator be FUNCobjectcreate(%mapiteratorprototype%, « [[MAP]], [[MAPNEXTINDEX]], [[MAPITERATIONKIND]] »). 
*0*set VARiterator.[[MAP]] to VARmap. 
*0*set VARiterator.[[MAPNEXTINDEX]] to 0. 
*0*set VARiterator.[[MAPITERATIONKIND]] to VARkind. 
*0*return VARiterator.     

############# END ## 562 ###########################
############# BEGIN ## 563 ###########################
ID= 23.1.5.2.1
Summary= %MapIteratorPrototype%.next ( )
Description= None
*0*let VARo be the this value. 
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*if VARo does not have all of the internal slots of a map iterator instance (23.1.5.3), throw a typeerror exception. 
*0*let VARm be VARo.[[MAP]]. 
*0*let VARindex be VARo.[[MAPNEXTINDEX]]. 
*0*let VARitemkind be VARo.[[MAPITERATIONKIND]]. 
*0*if VARm is undefined, return FUNCcreateiterresultobject(undefined, true). 
*0*assert: VARm has a [[MAPDATA]] internal slot. 
*0*let VARentries be the list that is VARm.[[MAPDATA]]. 
*0*let VARnumentries be the number of elements of VARentries. 
*0*note: VARnumentries must be redetermined each time this method is evaluated. 
*0*repeat, while VARindex is less than VARnumentries,
*1*let VARe be the record { [[KEY]], [[VALUE]] } that is the value of VARentries[VARindex]. 
*1*set VARindex to VARindex+1. 
*1*set VARo.[[MAPNEXTINDEX]] to VARindex. 
*1*if VARe.[[KEY]] is not empty, then
*2*if VARitemkind is "key", let VARresult be VARe.[[KEY]]. 
*2*else if VARitemkind is "value", let VARresult be VARe.[[VALUE]]. 
*2*else,
*3*assert: VARitemkind is "key+value". 
*3*let VARresult be FUNCcreatearrayfromlist(« VARe.[[KEY]], VARe.[[VALUE]] »). 
*2*return FUNCcreateiterresultobject(VARresult, false). 
*0*set VARo.[[MAP]] to undefined. 
*0*return FUNCcreateiterresultobject(undefined, true).      

############# END ## 563 ###########################
############# BEGIN ## 564 ###########################
ID= 23.2.1.1
Summary= Set ( [ iterable ] )
Description= When the Set function is called with optional argument iterable, the following steps are taken:
*0*if newtarget is undefined, throw a typeerror exception. 
*0*let VARset be ? FUNCordinarycreatefromconstructor(newtarget, "%setprototype%", « [[SETDATA]] »). 
*0*set VARset.[[SETDATA]] to a new empty list. 
*0*if VARiterable is not present, let VARiterable be undefined. 
*0*if VARiterable is either undefined or null, return VARset. 
*0*let VARadder be ? FUNCget(VARset, "add"). 
*0*if FUNCiscallable(VARadder) is false, throw a typeerror exception. 
*0*let VARiteratorrecord be ? FUNCgetiterator(VARiterable). 
*0*repeat,
*1*let VARnext be ? FUNCiteratorstep(VARiteratorrecord). 
*1*if VARnext is false, return VARset. 
*1*let VARnextvalue be ? FUNCiteratorvalue(VARnext). 
*1*let VARstatus be FUNCcall(VARadder, VARset, « VARnextvalue.[[VALUE]] »). 
*1*if VARstatus is an FUNCabrupt completion, return ? iteratorclose(VARiteratorrecord, VARstatus).     

############# END ## 564 ###########################
############# BEGIN ## 565 ###########################
ID= 23.2.3.1
Summary= Set.prototype.add ( value )
Description= The following steps are taken:
*0*let VARs be the this value. 
*0*if FUNCtype(VARs) is not object, throw a typeerror exception. 
*0*if VARs does not have a [[SETDATA]] internal slot, throw a typeerror exception. 
*0*let VARentries be the list that is VARs.[[SETDATA]]. 
*0*for each VARe that is an element of VARentries, do
*1*if VARe is not empty and FUNCsamevaluezero(VARe, VARvalue) is true, then
*2*return VARs. 
*0*if VARvalue is -0, let VARvalue be +0. 
*0*append VARvalue as the last element of VARentries. 
*0*return VARs.     

############# END ## 565 ###########################
############# BEGIN ## 566 ###########################
ID= 23.2.3.2
Summary= Set.prototype.clear ( )
Description= The following steps are taken:
*0*let VARs be the this value. 
*0*if FUNCtype(VARs) is not object, throw a typeerror exception. 
*0*if VARs does not have a [[SETDATA]] internal slot, throw a typeerror exception. 
*0*let VARentries be the list that is VARs.[[SETDATA]]. 
*0*for each VARe that is an element of VARentries, do
*1*replace the element of VARentries whose value is VARe with an element whose value is empty. 
*0*return undefined.     

############# END ## 566 ###########################
############# BEGIN ## 567 ###########################
ID= 23.2.3.4
Summary= Set.prototype.delete ( value )
Description= The following steps are taken:
*0*let VARs be the this value. 
*0*if FUNCtype(VARs) is not object, throw a typeerror exception. 
*0*if VARs does not have a [[SETDATA]] internal slot, throw a typeerror exception. 
*0*let VARentries be the list that is VARs.[[SETDATA]]. 
*0*for each VARe that is an element of VARentries, do
*1*if VARe is not empty and FUNCsamevaluezero(VARe, VARvalue) is true, then
*2*replace the element of VARentries whose value is VARe with an element whose value is empty. 
*2*return true. 
*0*return false.     

############# END ## 567 ###########################
############# BEGIN ## 568 ###########################
ID= 23.2.3.5
Summary= Set.prototype.entries ( )
Description= The following steps are taken:
*0*let VARs be the this value. 
*0*return ? FUNCcreatesetiterator(VARs, "key+value").     

############# END ## 568 ###########################
############# BEGIN ## 569 ###########################
ID= 23.2.3.6
Summary= Set.prototype.forEach ( callbackfn [ , thisArg ] )
Description= When the forEach method is called with one or two arguments, the following steps are taken:
*0*let VARs be the this value. 
*0*if FUNCtype(VARs) is not object, throw a typeerror exception. 
*0*if VARs does not have a [[SETDATA]] internal slot, throw a typeerror exception. 
*0*if FUNCiscallable(VARcallbackfn) is false, throw a typeerror exception. 
*0*if VARthisarg is present, let VARt be VARthisarg; else let VARt be undefined. 
*0*let VARentries be the list that is VARs.[[SETDATA]]. 
*0*for each VARe that is an element of VARentries, in original insertion order, do
*1*if VARe is not empty, then
*2*perform ? FUNCcall(VARcallbackfn, VARt, « VARe, VARe, VARs »). 
*0*return undefined.     

############# END ## 569 ###########################
############# BEGIN ## 570 ###########################
ID= 23.2.3.7
Summary= Set.prototype.has ( value )
Description= The following steps are taken:
*0*let VARs be the this value. 
*0*if FUNCtype(VARs) is not object, throw a typeerror exception. 
*0*if VARs does not have a [[SETDATA]] internal slot, throw a typeerror exception. 
*0*let VARentries be the list that is VARs.[[SETDATA]]. 
*0*for each VARe that is an element of VARentries, do
*1*if VARe is not empty and FUNCsamevaluezero(VARe, VARvalue) is true, return true. 
*0*return false.     

############# END ## 570 ###########################
############# BEGIN ## 571 ###########################
ID= 23.2.3.10
Summary= Set.prototype.values ( )
Description= The following steps are taken:
*0*let VARs be the this value. 
*0*return ? FUNCcreatesetiterator(VARs, "value").     

############# END ## 571 ###########################
############# BEGIN ## 572 ###########################
ID= 23.2.5.1
Summary= CreateSetIterator ( set, kind )
Description= Several methods of Set objects return Iterator objects. The abstract operation CreateSetIterator with arguments set and kind is used to create such iterator objects. It performs the following steps:
*0*if FUNCtype(VARset) is not object, throw a typeerror exception. 
*0*if VARset does not have a [[SETDATA]] internal slot, throw a typeerror exception. 
*0*let VARiterator be FUNCobjectcreate(%setiteratorprototype%, « [[ITERATEDSET]], [[SETNEXTINDEX]], [[SETITERATIONKIND]] »). 
*0*set VARiterator.[[ITERATEDSET]] to VARset. 
*0*set VARiterator.[[SETNEXTINDEX]] to 0. 
*0*set VARiterator.[[SETITERATIONKIND]] to VARkind. 
*0*return VARiterator.     

############# END ## 572 ###########################
############# BEGIN ## 573 ###########################
ID= 23.2.5.2.1
Summary= %SetIteratorPrototype%.next ( )
Description= None
*0*let VARo be the this value. 
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*if VARo does not have all of the internal slots of a set iterator instance (23.2.5.3), throw a typeerror exception. 
*0*let VARs be VARo.[[ITERATEDSET]]. 
*0*let VARindex be VARo.[[SETNEXTINDEX]]. 
*0*let VARitemkind be VARo.[[SETITERATIONKIND]]. 
*0*if VARs is undefined, return FUNCcreateiterresultobject(undefined, true). 
*0*assert: VARs has a [[SETDATA]] internal slot. 
*0*let VARentries be the list that is VARs.[[SETDATA]]. 
*0*let VARnumentries be the number of elements of VARentries. 
*0*note: VARnumentries must be redetermined each time this method is evaluated. 
*0*repeat, while VARindex is less than VARnumentries,
*1*let VARe be VARentries[VARindex]. 
*1*set VARindex to VARindex+1. 
*1*set VARo.[[SETNEXTINDEX]] to VARindex. 
*1*if VARe is not empty, then
*2*if VARitemkind is "key+value", then
*3*return FUNCcreateiterresultobject(FUNCcreatearrayfromlist(« VARe, VARe »), false). 
*2*return FUNCcreateiterresultobject(VARe, false). 
*0*set VARo.[[ITERATEDSET]] to undefined. 
*0*return FUNCcreateiterresultobject(undefined, true).      

############# END ## 573 ###########################
############# BEGIN ## 574 ###########################
ID= 23.3.1.1
Summary= WeakMap ( [ iterable ] )
Description= When the WeakMap function is called with optional argument iterable, the following steps are taken:
*0*if newtarget is undefined, throw a typeerror exception. 
*0*let VARmap be ? FUNCordinarycreatefromconstructor(newtarget, "%weakmapprototype%", « [[WEAKMAPDATA]] »). 
*0*set VARmap.[[WEAKMAPDATA]] to a new empty list. 
*0*if VARiterable is not present, let VARiterable be undefined. 
*0*if VARiterable is either undefined or null, return VARmap. 
*0*let VARadder be ? FUNCget(VARmap, "set"). 
*0*if FUNCiscallable(VARadder) is false, throw a typeerror exception. 
*0*let VARiteratorrecord be ? FUNCgetiterator(VARiterable). 
*0*repeat,
*1*let VARnext be ? FUNCiteratorstep(VARiterrecord). 
*1*if VARnext is false, return VARmap. 
*1*let VARnextitem be ? FUNCiteratorvalue(VARnext). 
*1*if FUNCtype(VARnextitem) is not object, then
*2*let VARerror be FUNCthrowcompletion(a newly created typeerror object). 
*2*return ? FUNCiteratorclose(VARiteratorrecord, VARerror). 
*1*let VARk be FUNCget(VARnextitem, "0"). 
*1*if VARk is an FUNCabrupt completion, return ? iteratorclose(VARiteratorrecord, VARk). 
*1*let VARv be FUNCget(VARnextitem, "1"). 
*1*if VARv is an FUNCabrupt completion, return ? iteratorclose(VARiteratorrecord, VARv). 
*1*let VARstatus be FUNCcall(VARadder, VARmap, « VARk.[[VALUE]], VARv.[[VALUE]] »). 
*1*if VARstatus is an FUNCabrupt completion, return ? iteratorclose(VARiteratorrecord, VARstatus).     

############# END ## 574 ###########################
############# BEGIN ## 575 ###########################
ID= 23.3.3.2
Summary= WeakMap.prototype.delete ( key )
Description= The following steps are taken:
*0*let VARm be the this value. 
*0*if FUNCtype(VARm) is not object, throw a typeerror exception. 
*0*if VARm does not have a [[WEAKMAPDATA]] internal slot, throw a typeerror exception. 
*0*let VARentries be the list that is VARm.[[WEAKMAPDATA]]. 
*0*if FUNCtype(VARkey) is not object, return false. 
*0*for each record { [[KEY]], [[VALUE]] } VARp that is an element of VARentries, do
*1*if VARp.[[KEY]] is not empty and FUNCsamevalue(VARp.[[KEY]], VARkey) is true, then
*2*set VARp.[[KEY]] to empty. 
*2*set VARp.[[VALUE]] to empty. 
*2*return true. 
*0*return false.     

############# END ## 575 ###########################
############# BEGIN ## 576 ###########################
ID= 23.3.3.3
Summary= WeakMap.prototype.get ( key )
Description= The following steps are taken:
*0*let VARm be the this value. 
*0*if FUNCtype(VARm) is not object, throw a typeerror exception. 
*0*if VARm does not have a [[WEAKMAPDATA]] internal slot, throw a typeerror exception. 
*0*let VARentries be the list that is VARm.[[WEAKMAPDATA]]. 
*0*if FUNCtype(VARkey) is not object, return undefined. 
*0*for each record { [[KEY]], [[VALUE]] } VARp that is an element of VARentries, do
*1*if VARp.[[KEY]] is not empty and FUNCsamevalue(VARp.[[KEY]], VARkey) is true, return VARp.[[VALUE]]. 
*0*return undefined.     

############# END ## 576 ###########################
############# BEGIN ## 577 ###########################
ID= 23.3.3.4
Summary= WeakMap.prototype.has ( key )
Description= The following steps are taken:
*0*let VARm be the this value. 
*0*if FUNCtype(VARm) is not object, throw a typeerror exception. 
*0*if VARm does not have a [[WEAKMAPDATA]] internal slot, throw a typeerror exception. 
*0*let VARentries be the list that is VARm.[[WEAKMAPDATA]]. 
*0*if FUNCtype(VARkey) is not object, return false. 
*0*for each record { [[KEY]], [[VALUE]] } VARp that is an element of VARentries, do
*1*if VARp.[[KEY]] is not empty and FUNCsamevalue(VARp.[[KEY]], VARkey) is true, return true. 
*0*return false.     

############# END ## 577 ###########################
############# BEGIN ## 578 ###########################
ID= 23.3.3.5
Summary= WeakMap.prototype.set ( key, value )
Description= The following steps are taken:
*0*let VARm be the this value. 
*0*if FUNCtype(VARm) is not object, throw a typeerror exception. 
*0*if VARm does not have a [[WEAKMAPDATA]] internal slot, throw a typeerror exception. 
*0*let VARentries be the list that is VARm.[[WEAKMAPDATA]]. 
*0*if FUNCtype(VARkey) is not object, throw a typeerror exception. 
*0*for each record { [[KEY]], [[VALUE]] } VARp that is an element of VARentries, do
*1*if VARp.[[KEY]] is not empty and FUNCsamevalue(VARp.[[KEY]], VARkey) is true, then
*2*set VARp.[[VALUE]] to VARvalue. 
*2*return VARm. 
*0*let VARp be the record { [[KEY]]: VARkey, [[VALUE]]: VARvalue }. 
*0*append VARp as the last element of VARentries. 
*0*return VARm.     

############# END ## 578 ###########################
############# BEGIN ## 579 ###########################
ID= 23.4.1.1
Summary= WeakSet ( [ iterable ] )
Description= When the WeakSet function is called with optional argument iterable, the following steps are taken:
*0*if newtarget is undefined, throw a typeerror exception. 
*0*let VARset be ? FUNCordinarycreatefromconstructor(newtarget, "%weaksetprototype%", « [[WEAKSETDATA]] »). 
*0*set VARset.[[WEAKSETDATA]] to a new empty list. 
*0*if VARiterable is not present, let VARiterable be undefined. 
*0*if VARiterable is either undefined or null, return VARset. 
*0*let VARadder be ? FUNCget(VARset, "add"). 
*0*if FUNCiscallable(VARadder) is false, throw a typeerror exception. 
*0*let VARiteratorrecord be ? FUNCgetiterator(VARiterable). 
*0*repeat,
*1*let VARnext be ? FUNCiteratorstep(VARiteratorrecord). 
*1*if VARnext is false, return VARset. 
*1*let VARnextvalue be ? FUNCiteratorvalue(VARnext). 
*1*let VARstatus be FUNCcall(VARadder, VARset, « VARnextvalue »). 
*1*if VARstatus is an FUNCabrupt completion, return ? iteratorclose(VARiteratorrecord, VARstatus).     

############# END ## 579 ###########################
############# BEGIN ## 580 ###########################
ID= 23.4.3.1
Summary= WeakSet.prototype.add ( value )
Description= The following steps are taken:
*0*let VARs be the this value. 
*0*if FUNCtype(VARs) is not object, throw a typeerror exception. 
*0*if VARs does not have a [[WEAKSETDATA]] internal slot, throw a typeerror exception. 
*0*if FUNCtype(VARvalue) is not object, throw a typeerror exception. 
*0*let VARentries be the list that is VARs.[[WEAKSETDATA]]. 
*0*for each VARe that is an element of VARentries, do
*1*if VARe is not empty and FUNCsamevalue(VARe, VARvalue) is true, then
*2*return VARs. 
*0*append VARvalue as the last element of VARentries. 
*0*return VARs.     

############# END ## 580 ###########################
############# BEGIN ## 581 ###########################
ID= 23.4.3.3
Summary= WeakSet.prototype.delete ( value )
Description= The following steps are taken:
*0*let VARs be the this value. 
*0*if FUNCtype(VARs) is not object, throw a typeerror exception. 
*0*if VARs does not have a [[WEAKSETDATA]] internal slot, throw a typeerror exception. 
*0*if FUNCtype(VARvalue) is not object, return false. 
*0*let VARentries be the list that is VARs.[[WEAKSETDATA]]. 
*0*for each VARe that is an element of VARentries, do
*1*if VARe is not empty and FUNCsamevalue(VARe, VARvalue) is true, then
*2*replace the element of VARentries whose value is VARe with an element whose value is empty. 
*2*return true. 
*0*return false.     

############# END ## 581 ###########################
############# BEGIN ## 582 ###########################
ID= 23.4.3.4
Summary= WeakSet.prototype.has ( value )
Description= The following steps are taken:
*0*let VARs be the this value. 
*0*if FUNCtype(VARs) is not object, throw a typeerror exception. 
*0*if VARs does not have a [[WEAKSETDATA]] internal slot, throw a typeerror exception. 
*0*let VARentries be the list that is VARs.[[WEAKSETDATA]]. 
*0*if FUNCtype(VARvalue) is not object, return false. 
*0*for each VARe that is an element of VARentries, do
*1*if VARe is not empty and FUNCsamevalue(VARe, VARvalue) is true, return true. 
*0*return false.     

############# END ## 582 ###########################
############# BEGIN ## 583 ###########################
ID= 24.1.1.1
Summary= AllocateArrayBuffer ( constructor, byteLength )
Description= The abstract operation AllocateArrayBuffer with arguments constructor and byteLength is used to create an ArrayBuffer object. It performs the following steps:
*0*let VARobj be ? FUNCordinarycreatefromconstructor(VARconstructor, "%arraybufferprototype%", « [[ARRAYBUFFERDATA]], [[ARRAYBUFFERBYTELENGTH]], [[ARRAYBUFFERDETACHKEY]] »). 
*0*assert: VARbytelength is an integer value ≥ 0. 
*0*let VARblock be ? FUNCcreatebytedatablock(VARbytelength). 
*0*set VARobj.[[ARRAYBUFFERDATA]] to VARblock. 
*0*set VARobj.[[ARRAYBUFFERBYTELENGTH]] to VARbytelength. 
*0*return VARobj.     

############# END ## 583 ###########################
############# BEGIN ## 584 ###########################
ID= 24.1.1.2
Summary= IsDetachedBuffer ( arrayBuffer )
Description= The abstract operation IsDetachedBuffer with argument arrayBuffer performs the following steps:
*0*assert: FUNCtype(VARarraybuffer) is object and it has an [[ARRAYBUFFERDATA]] internal slot. 
*0*if VARarraybuffer.[[ARRAYBUFFERDATA]] is null, return true. 
*0*return false.     

############# END ## 584 ###########################
############# BEGIN ## 585 ###########################
ID= 24.1.1.3
Summary= DetachArrayBuffer ( arrayBuffer [ , key ] )
Description= The abstract operation DetachArrayBuffer with argument arrayBuffer and optional argument key performs the following steps:
*0*assert: FUNCtype(VARarraybuffer) is object and it has [[ARRAYBUFFERDATA]], [[ARRAYBUFFERBYTELENGTH]], and [[ARRAYBUFFERDETACHKEY]] internal slots. 
*0*assert: FUNCissharedarraybuffer(VARarraybuffer) is false. 
*0*if VARkey is not present, set VARkey to undefined. 
*0*if FUNCsamevalue(VARarraybuffer.[[ARRAYBUFFERDETACHKEY]], VARkey) is false, throw a typeerror exception. 
*0*set VARarraybuffer.[[ARRAYBUFFERDATA]] to null. 
*0*set VARarraybuffer.[[ARRAYBUFFERBYTELENGTH]] to 0. 
*0*return FUNCnormalcompletion(null).     

############# END ## 585 ###########################
############# BEGIN ## 586 ###########################
ID= 24.1.1.4
Summary= CloneArrayBuffer ( srcBuffer, srcByteOffset, srcLength, cloneConstructor )
Description= The abstract operation CloneArrayBuffer takes four parameters, an ArrayBuffer srcBuffer, an integer offset srcByteOffset, an integer length srcLength, and a constructor function cloneConstructor. It creates a new ArrayBuffer whose data is a copy of srcBuffer's data over the range starting at srcByteOffset and continuing for srcLength bytes. This operation performs the following steps:
*0*assert: FUNCtype(VARsrcbuffer) is object and it has an [[ARRAYBUFFERDATA]] internal slot. 
*0*assert: FUNCisconstructor(VARcloneconstructor) is true. 
*0*let VARtargetbuffer be ? FUNCallocatearraybuffer(VARcloneconstructor, VARsrclength). 
*0*if FUNCisdetachedbuffer(VARsrcbuffer) is true, throw a typeerror exception. 
*0*let VARsrcblock be VARsrcbuffer.[[ARRAYBUFFERDATA]]. 
*0*let VARtargetblock be VARtargetbuffer.[[ARRAYBUFFERDATA]]. 
*0*perform FUNCcopydatablockbytes(VARtargetblock, 0, VARsrcblock, VARsrcbyteoffset, VARsrclength). 
*0*return VARtargetbuffer.     

############# END ## 586 ###########################
############# BEGIN ## 587 ###########################
ID= 24.1.1.5
Summary= RawBytesToNumber ( type, rawBytes, isLittleEndian )
Description= The abstract operation RawBytesToNumber takes three parameters, a String type, a List rawBytes, and a Boolean isLittleEndian. This operation performs the following steps:
*0*let VARelementsize be the number value of the element size value specified in table 56 for element type VARtype. 
*0*if VARislittleendian is false, reverse the order of the elements of VARrawbytes. 
*0*if VARtype is "float32", then
*1*let VARvalue be the byte elements of VARrawbytes concatenated and interpreted as a little-endian bit string encoding of an ieee 754-2008 binary32 value. 
*1*if VARvalue is an ieee 754-2008 binary32 nan value, return the nan number value. 
*1*return the number value that corresponds to VARvalue. 
*0*if VARtype is "float64", then
*1*let VARvalue be the byte elements of VARrawbytes concatenated and interpreted as a little-endian bit string encoding of an ieee 754-2008 binary64 value. 
*1*if VARvalue is an ieee 754-2008 binary64 nan value, return the nan number value. 
*1*return the number value that corresponds to VARvalue. 
*0*if the first code unit of VARtype is the code unit 0x0055 (latin capital letter u), then
*1*let VARintvalue be the byte elements of VARrawbytes concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number. 
*0*else,
*1*let VARintvalue be the byte elements of VARrawbytes concatenated and interpreted as a bit string encoding of a binary little-endian 2's complement number of bit length VARelementsize × 8. 
*0*return the number value that corresponds to VARintvalue.     

############# END ## 587 ###########################
############# BEGIN ## 588 ###########################
ID= 24.1.1.6
Summary= GetValueFromBuffer ( arrayBuffer, byteIndex, type, isTypedArray, order [ , isLittleEndian ] )
Description= The abstract operation GetValueFromBuffer takes six parameters, an ArrayBuffer or SharedArrayBuffer arrayBuffer, an integer byteIndex, a String type, a Boolean isTypedArray, a String order, and optionally a Boolean isLittleEndian. This operation performs the following steps:
*0*assert: FUNCisdetachedbuffer(VARarraybuffer) is false. 
*0*assert: there are sufficient bytes in VARarraybuffer starting at VARbyteindex to represent a value of VARtype. 
*0*assert: VARbyteindex is an integer value ≥ 0. 
*0*let VARblock be VARarraybuffer.[[ARRAYBUFFERDATA]]. 
*0*let VARelementsize be the number value of the element size value specified in table 56 for element type VARtype. 
*0*if FUNCissharedarraybuffer(VARarraybuffer) is true, then
*1*let VARexecution be the [[CANDIDATEEXECUTION]] field of the surrounding agent's agent record. 
*1*let VAReventlist be the [[EVENTLIST]] field of the element in VARexecution.[[EVENTLISTS]] whose [[AGENTSIGNIFIER]] is FUNCagentsignifier(). 
*1*if VARistypedarray is true and VARtype is "int8", "uint8", "int16", "uint16", "int32", or "uint32", let VARnotear be true; otherwise let VARnotear be false. 
*1*let VARrawvalue be a list of length VARelementsize of nondeterministically chosen byte values. 
*1*note: in implementations, VARrawvalue is the result of a non-atomic or atomic read instruction on the underlying hardware. the nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency. 
*1*let VARreadevent be readsharedmemory { [[ORDER]]: VARorder, [[NOTEAR]]: VARnotear, [[BLOCK]]: VARblock, [[BYTEINDEX]]: VARbyteindex, [[ELEMENTSIZE]]: VARelementsize }. 
*1*append VARreadevent to VAReventlist. 
*1*append chosen value record { [[EVENT]]: VARreadevent, [[CHOSENVALUE]]: VARrawvalue } to VARexecution.[[CHOSENVALUES]]. 
*0*else, let VARrawvalue be a list of VARelementsize containing, in order, the VARelementsize sequence of bytes starting with VARblock[VARbyteindex]. 
*0*if VARislittleendian is not present, set VARislittleendian to the value of the [[LITTLEENDIAN]] field of the surrounding agent's agent record. 
*0*return FUNCrawbytestonumber(VARtype, VARrawvalue, VARislittleendian).     

############# END ## 588 ###########################
############# BEGIN ## 589 ###########################
ID= 24.1.1.7
Summary= NumberToRawBytes ( type, value, isLittleEndian )
Description= The abstract operation NumberToRawBytes takes three parameters, a String type, a Number value, and a Boolean isLittleEndian. This operation performs the following steps:
*0*if VARtype is "float32", then
*1*let VARrawbytes be a list containing the 4 bytes that are the result of converting VARvalue to ieee 754-2008 binary32 format using “round to nearest, ties to even” rounding mode. if VARislittleendian is false, the bytes are arranged in big endian order. otherwise, the bytes are arranged in little endian order. if VARvalue is nan, VARrawbytes may be set to any implementation chosen ieee 754-2008 binary32 format not-a-number encoding. an implementation must always choose the same encoding for each implementation distinguishable nan value. 
*0*else if VARtype is "float64", then
*1*let VARrawbytes be a list containing the 8 bytes that are the ieee 754-2008 binary64 format encoding of VARvalue. if VARislittleendian is false, the bytes are arranged in big endian order. otherwise, the bytes are arranged in little endian order. if VARvalue is nan, VARrawbytes may be set to any implementation chosen ieee 754-2008 binary64 format not-a-number encoding. an implementation must always choose the same encoding for each implementation distinguishable nan value. 
*0*else,
*1*let VARn be the number value of the element size specified in table 56 for element type VARtype. 
*1*let VARconvop be the abstract operation named in the conversion operation column in table 56 for element type VARtype. 
*1*let VARintvalue be VARconvop(VARvalue). 
*1*if VARintvalue ≥ 0, then
*2*let VARrawbytes be a list containing the VARn-byte binary encoding of VARintvalue. if VARislittleendian is false, the bytes are ordered in big endian order. otherwise, the bytes are ordered in little endian order. 
*1*else,
*2*let VARrawbytes be a list containing the VARn-byte binary 2's complement encoding of VARintvalue. if VARislittleendian is false, the bytes are ordered in big endian order. otherwise, the bytes are ordered in little endian order. 
*0*return VARrawbytes.     

############# END ## 589 ###########################
############# BEGIN ## 590 ###########################
ID= 24.1.1.8
Summary= SetValueInBuffer ( arrayBuffer, byteIndex, type, value, isTypedArray, order [ , isLittleEndian ] )
Description= The abstract operation SetValueInBuffer takes seven parameters, an ArrayBuffer or SharedArrayBuffer arrayBuffer, an integer byteIndex, a String type, a Number value, a Boolean isTypedArray, a String order, and optionally a Boolean isLittleEndian. This operation performs the following steps:
*0*assert: FUNCisdetachedbuffer(VARarraybuffer) is false. 
*0*assert: there are sufficient bytes in VARarraybuffer starting at VARbyteindex to represent a value of VARtype. 
*0*assert: VARbyteindex is an integer value ≥ 0. 
*0*assert: FUNCtype(VARvalue) is number. 
*0*let VARblock be VARarraybuffer.[[ARRAYBUFFERDATA]]. 
*0*let VARelementsize be the number value of the element size value specified in table 56 for element type VARtype. 
*0*if VARislittleendian is not present, set VARislittleendian to the value of the [[LITTLEENDIAN]] field of the surrounding agent's agent record. 
*0*let VARrawbytes be FUNCnumbertorawbytes(VARtype, VARvalue, VARislittleendian). 
*0*if FUNCissharedarraybuffer(VARarraybuffer) is true, then
*1*let VARexecution be the [[CANDIDATEEXECUTION]] field of the surrounding agent's agent record. 
*1*let VAReventlist be the [[EVENTLIST]] field of the element in VARexecution.[[EVENTLISTS]] whose [[AGENTSIGNIFIER]] is FUNCagentsignifier(). 
*1*if VARistypedarray is true and VARtype is "int8", "uint8", "int16", "uint16", "int32", or "uint32", let VARnotear be true; otherwise let VARnotear be false. 
*1*append writesharedmemory { [[ORDER]]: VARorder, [[NOTEAR]]: VARnotear, [[BLOCK]]: VARblock, [[BYTEINDEX]]: VARbyteindex, [[ELEMENTSIZE]]: VARelementsize, [[PAYLOAD]]: VARrawbytes } to VAReventlist. 
*0*else, store the individual bytes of VARrawbytes into VARblock, in order, starting at VARblock[VARbyteindex]. 
*0*return FUNCnormalcompletion(undefined).     

############# END ## 590 ###########################
############# BEGIN ## 591 ###########################
ID= 24.1.1.9
Summary= GetModifySetValueInBuffer ( arrayBuffer, byteIndex, type, value, op [ , isLittleEndian ] )
Description= The abstract operation GetModifySetValueInBuffer takes six parameters, a SharedArrayBuffer arrayBuffer, a nonnegative integer byteIndex, a String type, a Number value, a semantic function op, and optionally a Boolean isLittleEndian. This operation performs the following steps:
*0*assert: FUNCissharedarraybuffer(VARarraybuffer) is true. 
*0*assert: there are sufficient bytes in VARarraybuffer starting at VARbyteindex to represent a value of VARtype. 
*0*assert: VARbyteindex is an integer value ≥ 0. 
*0*assert: FUNCtype(VARvalue) is number. 
*0*let VARblock be VARarraybuffer.[[ARRAYBUFFERDATA]]. 
*0*let VARelementsize be the number value of the element size value specified in table 56 for element type VARtype. 
*0*if VARislittleendian is not present, set VARislittleendian to the value of the [[LITTLEENDIAN]] field of the surrounding agent's agent record. 
*0*let VARrawbytes be FUNCnumbertorawbytes(VARtype, VARvalue, VARislittleendian). 
*0*let VARexecution be the [[CANDIDATEEXECUTION]] field of the surrounding agent's agent record. 
*0*let VAReventlist be the [[EVENTLIST]] field of the element in VARexecution.[[EVENTLISTS]] whose [[AGENTSIGNIFIER]] is FUNCagentsignifier(). 
*0*let VARrawbytesread be a list of length VARelementsize of nondeterministically chosen byte values. 
*0*note: in implementations, VARrawbytesread is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. the nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency. 
*0*let VARrmwevent be readmodifywritesharedmemory { [[ORDER]]: "seqcst", [[NOTEAR]]: true, [[BLOCK]]: VARblock, [[BYTEINDEX]]: VARbyteindex, [[ELEMENTSIZE]]: VARelementsize, [[PAYLOAD]]: VARrawbytes, [[MODIFYOP]]: VARop }. 
*0*append VARrmwevent to VAReventlist. 
*0*append chosen value record { [[EVENT]]: VARrmwevent, [[CHOSENVALUE]]: VARrawbytesread } to VARexecution.[[CHOSENVALUES]]. 
*0*return FUNCrawbytestonumber(VARtype, VARrawbytesread, VARislittleendian).     

############# END ## 591 ###########################
############# BEGIN ## 592 ###########################
ID= 24.1.2.1
Summary= ArrayBuffer ( length )
Description= When the ArrayBuffer function is called with argument length, the following steps are taken:
*0*if newtarget is undefined, throw a typeerror exception. 
*0*let VARbytelength be ? FUNCtoindex(VARlength). 
*0*return ? FUNCallocatearraybuffer(newtarget, VARbytelength).     

############# END ## 592 ###########################
############# BEGIN ## 593 ###########################
ID= 24.1.3.1
Summary= ArrayBuffer.isView ( arg )
Description= The isView function takes one argument arg, and performs, the following steps are taken:
*0*if FUNCtype(VARarg) is not object, return false. 
*0*if VARarg has a [[VIEWEDARRAYBUFFER]] internal slot, return true. 
*0*return false.     

############# END ## 593 ###########################
############# BEGIN ## 594 ###########################
ID= 24.1.4.3
Summary= ArrayBuffer.prototype.slice ( start, end )
Description= The following steps are taken:
*0*let VARo be the this value. 
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*if VARo does not have an [[ARRAYBUFFERDATA]] internal slot, throw a typeerror exception. 
*0*if FUNCissharedarraybuffer(VARo) is true, throw a typeerror exception. 
*0*if FUNCisdetachedbuffer(VARo) is true, throw a typeerror exception. 
*0*let VARlen be VARo.[[ARRAYBUFFERBYTELENGTH]]. 
*0*let VARrelativestart be ? FUNCtointeger(VARstart). 
*0*if VARrelativestart &lt; 0, let VARfirst be max((VARlen + VARrelativestart), 0); else let VARfirst be min(VARrelativestart, VARlen). 
*0*if VARend is undefined, let VARrelativeend be VARlen; else let VARrelativeend be ? FUNCtointeger(VARend). 
*0*if VARrelativeend &lt; 0, let VARfinal be max((VARlen + VARrelativeend), 0); else let VARfinal be min(VARrelativeend, VARlen). 
*0*let VARnewlen be max(VARfinal-VARfirst, 0). 
*0*let VARctor be ? FUNCspeciesconstructor(VARo, %arraybuffer%). 
*0*let VARnew be ? FUNCconstruct(VARctor, « VARnewlen »). 
*0*if VARnew does not have an [[ARRAYBUFFERDATA]] internal slot, throw a typeerror exception. 
*0*if FUNCissharedarraybuffer(VARnew) is true, throw a typeerror exception. 
*0*if FUNCisdetachedbuffer(VARnew) is true, throw a typeerror exception. 
*0*if FUNCsamevalue(VARnew, VARo) is true, throw a typeerror exception. 
*0*if VARnew.[[ARRAYBUFFERBYTELENGTH]] &lt; VARnewlen, throw a typeerror exception. 
*0*note: side-effects of the above steps may have detached VARo. 
*0*if FUNCisdetachedbuffer(VARo) is true, throw a typeerror exception. 
*0*let VARfrombuf be VARo.[[ARRAYBUFFERDATA]]. 
*0*let VARtobuf be VARnew.[[ARRAYBUFFERDATA]]. 
*0*perform FUNCcopydatablockbytes(VARtobuf, 0, VARfrombuf, VARfirst, VARnewlen). 
*0*return VARnew.     

############# END ## 594 ###########################
############# BEGIN ## 595 ###########################
ID= 24.2.1.1
Summary= AllocateSharedArrayBuffer ( constructor, byteLength )
Description= The abstract operation AllocateSharedArrayBuffer with arguments constructor and byteLength is used to create a SharedArrayBuffer object. It performs the following steps:
*0*let VARobj be ? FUNCordinarycreatefromconstructor(VARconstructor, "%sharedarraybufferprototype%", « [[ARRAYBUFFERDATA]], [[ARRAYBUFFERBYTELENGTH]] »). 
*0*assert: VARbytelength is a nonnegative integer. 
*0*let VARblock be ? FUNCcreatesharedbytedatablock(VARbytelength). 
*0*set VARobj.[[ARRAYBUFFERDATA]] to VARblock. 
*0*set VARobj.[[ARRAYBUFFERBYTELENGTH]] to VARbytelength. 
*0*return VARobj.     

############# END ## 595 ###########################
############# BEGIN ## 596 ###########################
ID= 24.2.1.2
Summary= IsSharedArrayBuffer ( obj )
Description= IsSharedArrayBuffer tests whether an object is an ArrayBuffer, a SharedArrayBuffer, or a subtype of either. It performs the following steps:
*0*assert: FUNCtype(VARobj) is object and it has an [[ARRAYBUFFERDATA]] internal slot. 
*0*let VARbufferdata be VARobj.[[ARRAYBUFFERDATA]]. 
*0*if VARbufferdata is null, return false. 
*0*if VARbufferdata is a data block, return false. 
*0*assert: VARbufferdata is a shared data block. 
*0*return true.     

############# END ## 596 ###########################
############# BEGIN ## 597 ###########################
ID= 24.2.2.1
Summary= SharedArrayBuffer ( length )
Description= When the SharedArrayBuffer function is called with optional argument length, the following steps are taken:
*0*if newtarget is undefined, throw a typeerror exception. 
*0*let VARbytelength be ? FUNCtoindex(VARlength). 
*0*return ? FUNCallocatesharedarraybuffer(newtarget, VARbytelength).     

############# END ## 597 ###########################
############# BEGIN ## 598 ###########################
ID= 24.2.4.3
Summary= SharedArrayBuffer.prototype.slice ( start, end )
Description= The following steps are taken:
*0*let VARo be the this value. 
*0*if FUNCtype(VARo) is not object, throw a typeerror exception. 
*0*if VARo does not have an [[ARRAYBUFFERDATA]] internal slot, throw a typeerror exception. 
*0*if FUNCissharedarraybuffer(VARo) is false, throw a typeerror exception. 
*0*let VARlen be VARo.[[ARRAYBUFFERBYTELENGTH]]. 
*0*let VARrelativestart be ? FUNCtointeger(VARstart). 
*0*if VARrelativestart &lt; 0, let VARfirst be max((VARlen + VARrelativestart), 0); else let VARfirst be min(VARrelativestart, VARlen). 
*0*if VARend is undefined, let VARrelativeend be VARlen; else let VARrelativeend be ? FUNCtointeger(VARend). 
*0*if VARrelativeend &lt; 0, let VARfinal be max((VARlen + VARrelativeend), 0); else let VARfinal be min(VARrelativeend, VARlen). 
*0*let VARnewlen be max(VARfinal - VARfirst, 0). 
*0*let VARctor be ? FUNCspeciesconstructor(VARo, %sharedarraybuffer%). 
*0*let VARnew be ? FUNCconstruct(VARctor, « VARnewlen »). 
*0*if VARnew does not have an [[ARRAYBUFFERDATA]] internal slot, throw a typeerror exception. 
*0*if FUNCissharedarraybuffer(VARnew) is false, throw a typeerror exception. 
*0*if VARnew.[[ARRAYBUFFERDATA]] and VARo.[[ARRAYBUFFERDATA]] are the same shared data block values, throw a typeerror exception. 
*0*if VARnew.[[ARRAYBUFFERBYTELENGTH]] &lt; VARnewlen, throw a typeerror exception. 
*0*let VARfrombuf be VARo.[[ARRAYBUFFERDATA]]. 
*0*let VARtobuf be VARnew.[[ARRAYBUFFERDATA]]. 
*0*perform FUNCcopydatablockbytes(VARtobuf, 0, VARfrombuf, VARfirst, VARnewlen). 
*0*return VARnew.     

############# END ## 598 ###########################
############# BEGIN ## 599 ###########################
ID= 24.3.1.1
Summary= GetViewValue ( view, requestIndex, isLittleEndian, type )
Description= The abstract operation GetViewValue with arguments view, requestIndex, isLittleEndian, and type is used by functions on DataView instances to retrieve values from the view's buffer. It performs the following steps:
*0*if FUNCtype(VARview) is not object, throw a typeerror exception. 
*0*if VARview does not have a [[DATAVIEW]] internal slot, throw a typeerror exception. 
*0*assert: VARview has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*let VARgetindex be ? FUNCtoindex(VARrequestindex). 
*0*set VARislittleendian to FUNCtoboolean(VARislittleendian). 
*0*let VARbuffer be VARview.[[VIEWEDARRAYBUFFER]]. 
*0*if FUNCisdetachedbuffer(VARbuffer) is true, throw a typeerror exception. 
*0*let VARviewoffset be VARview.[[BYTEOFFSET]]. 
*0*let VARviewsize be VARview.[[BYTELENGTH]]. 
*0*let VARelementsize be the number value of the element size value specified in table 56 for element type VARtype. 
*0*if VARgetindex + VARelementsize &gt; VARviewsize, throw a rangeerror exception. 
*0*let VARbufferindex be VARgetindex + VARviewoffset. 
*0*return FUNCgetvaluefrombuffer(VARbuffer, VARbufferindex, VARtype, false, "unordered", VARislittleendian).     

############# END ## 599 ###########################
############# BEGIN ## 600 ###########################
ID= 24.3.1.2
Summary= SetViewValue ( view, requestIndex, isLittleEndian, type, value )
Description= The abstract operation SetViewValue with arguments view, requestIndex, isLittleEndian, type, and value is used by functions on DataView instances to store values into the view's buffer. It performs the following steps:
*0*if FUNCtype(VARview) is not object, throw a typeerror exception. 
*0*if VARview does not have a [[DATAVIEW]] internal slot, throw a typeerror exception. 
*0*assert: VARview has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*let VARgetindex be ? FUNCtoindex(VARrequestindex). 
*0*let VARnumbervalue be ? FUNCtonumber(VARvalue). 
*0*set VARislittleendian to FUNCtoboolean(VARislittleendian). 
*0*let VARbuffer be VARview.[[VIEWEDARRAYBUFFER]]. 
*0*if FUNCisdetachedbuffer(VARbuffer) is true, throw a typeerror exception. 
*0*let VARviewoffset be VARview.[[BYTEOFFSET]]. 
*0*let VARviewsize be VARview.[[BYTELENGTH]]. 
*0*let VARelementsize be the number value of the element size value specified in table 56 for element type VARtype. 
*0*if VARgetindex + VARelementsize &gt; VARviewsize, throw a rangeerror exception. 
*0*let VARbufferindex be VARgetindex + VARviewoffset. 
*0*return FUNCsetvalueinbuffer(VARbuffer, VARbufferindex, VARtype, VARnumbervalue, false, "unordered", VARislittleendian).     

############# END ## 600 ###########################
############# BEGIN ## 601 ###########################
ID= 24.3.2.1
Summary= DataView ( buffer [ , byteOffset [ , byteLength  ] ] )
Description= When the DataView is called with at least one argument buffer, the following steps are taken:
*0*if newtarget is undefined, throw a typeerror exception. 
*0*if FUNCtype(VARbuffer) is not object, throw a typeerror exception. 
*0*if VARbuffer does not have an [[ARRAYBUFFERDATA]] internal slot, throw a typeerror exception. 
*0*let VARoffset be ? FUNCtoindex(VARbyteoffset). 
*0*if FUNCisdetachedbuffer(VARbuffer) is true, throw a typeerror exception. 
*0*let VARbufferbytelength be VARbuffer.[[ARRAYBUFFERBYTELENGTH]]. 
*0*if VARoffset &gt; VARbufferbytelength, throw a rangeerror exception. 
*0*if VARbytelength is either not present or undefined, then
*1*let VARviewbytelength be VARbufferbytelength - VARoffset. 
*0*else,
*1*let VARviewbytelength be ? FUNCtoindex(VARbytelength). 
*1*if VARoffset+VARviewbytelength &gt; VARbufferbytelength, throw a rangeerror exception. 
*0*let VARo be ? FUNCordinarycreatefromconstructor(newtarget, "%dataviewprototype%", « [[DATAVIEW]], [[VIEWEDARRAYBUFFER]], [[BYTELENGTH]], [[BYTEOFFSET]] »). 
*0*set VARo.[[VIEWEDARRAYBUFFER]] to VARbuffer. 
*0*set VARo.[[BYTELENGTH]] to VARviewbytelength. 
*0*set VARo.[[BYTEOFFSET]] to VARoffset. 
*0*return VARo.     

############# END ## 601 ###########################
############# BEGIN ## 602 ###########################
ID= 24.3.4.5
Summary= DataView.prototype.getFloat32 ( byteOffset [ , littleEndian ] )
Description= When the getFloat32 method is called with argument byteOffset and optional argument littleEndian, the following steps are taken:
*0*let VARv be the this value. 
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*return ? FUNCgetviewvalue(VARv, VARbyteoffset, VARlittleendian, "float32").     

############# END ## 602 ###########################
############# BEGIN ## 603 ###########################
ID= 24.3.4.6
Summary= DataView.prototype.getFloat64 ( byteOffset [ , littleEndian ] )
Description= When the getFloat64 method is called with argument byteOffset and optional argument littleEndian, the following steps are taken:
*0*let VARv be the this value. 
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*return ? FUNCgetviewvalue(VARv, VARbyteoffset, VARlittleendian, "float64").     

############# END ## 603 ###########################
############# BEGIN ## 604 ###########################
ID= 24.3.4.7
Summary= DataView.prototype.getInt8 ( byteOffset )
Description= When the getInt8 method is called with argument byteOffset, the following steps are taken:
*0*let VARv be the this value. 
*0*return ? FUNCgetviewvalue(VARv, VARbyteoffset, true, "int8").     

############# END ## 604 ###########################
############# BEGIN ## 605 ###########################
ID= 24.3.4.8
Summary= DataView.prototype.getInt16 ( byteOffset [ , littleEndian ] )
Description= When the getInt16 method is called with argument byteOffset and optional argument littleEndian, the following steps are taken:
*0*let VARv be the this value. 
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*return ? FUNCgetviewvalue(VARv, VARbyteoffset, VARlittleendian, "int16").     

############# END ## 605 ###########################
############# BEGIN ## 606 ###########################
ID= 24.3.4.9
Summary= DataView.prototype.getInt32 ( byteOffset [ , littleEndian ] )
Description= When the getInt32 method is called with argument byteOffset and optional argument littleEndian, the following steps are taken:
*0*let VARv be the this value. 
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*return ? FUNCgetviewvalue(VARv, VARbyteoffset, VARlittleendian, "int32").     

############# END ## 606 ###########################
############# BEGIN ## 607 ###########################
ID= 24.3.4.10
Summary= DataView.prototype.getUint8 ( byteOffset )
Description= When the getUint8 method is called with argument byteOffset, the following steps are taken:
*0*let VARv be the this value. 
*0*return ? FUNCgetviewvalue(VARv, VARbyteoffset, true, "uint8").     

############# END ## 607 ###########################
############# BEGIN ## 608 ###########################
ID= 24.3.4.11
Summary= DataView.prototype.getUint16 ( byteOffset [ , littleEndian ] )
Description= When the getUint16 method is called with argument byteOffset and optional argument littleEndian, the following steps are taken:
*0*let VARv be the this value. 
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*return ? FUNCgetviewvalue(VARv, VARbyteoffset, VARlittleendian, "uint16").     

############# END ## 608 ###########################
############# BEGIN ## 609 ###########################
ID= 24.3.4.12
Summary= DataView.prototype.getUint32 ( byteOffset [ , littleEndian ] )
Description= When the getUint32 method is called with argument byteOffset and optional argument littleEndian, the following steps are taken:
*0*let VARv be the this value. 
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*return ? FUNCgetviewvalue(VARv, VARbyteoffset, VARlittleendian, "uint32").     

############# END ## 609 ###########################
############# BEGIN ## 610 ###########################
ID= 24.3.4.13
Summary= DataView.prototype.setFloat32 ( byteOffset, value [ , littleEndian ] )
Description= When the setFloat32 method is called with arguments byteOffset and value and optional argument littleEndian, the following steps are taken:
*0*let VARv be the this value. 
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*return ? FUNCsetviewvalue(VARv, VARbyteoffset, VARlittleendian, "float32", VARvalue).     

############# END ## 610 ###########################
############# BEGIN ## 611 ###########################
ID= 24.3.4.14
Summary= DataView.prototype.setFloat64 ( byteOffset, value [ , littleEndian ] )
Description= When the setFloat64 method is called with arguments byteOffset and value and optional argument littleEndian, the following steps are taken:
*0*let VARv be the this value. 
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*return ? FUNCsetviewvalue(VARv, VARbyteoffset, VARlittleendian, "float64", VARvalue).     

############# END ## 611 ###########################
############# BEGIN ## 612 ###########################
ID= 24.3.4.15
Summary= DataView.prototype.setInt8 ( byteOffset, value )
Description= When the setInt8 method is called with arguments byteOffset and value, the following steps are taken:
*0*let VARv be the this value. 
*0*return ? FUNCsetviewvalue(VARv, VARbyteoffset, true, "int8", VARvalue).     

############# END ## 612 ###########################
############# BEGIN ## 613 ###########################
ID= 24.3.4.16
Summary= DataView.prototype.setInt16 ( byteOffset, value [ , littleEndian ] )
Description= When the setInt16 method is called with arguments byteOffset and value and optional argument littleEndian, the following steps are taken:
*0*let VARv be the this value. 
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*return ? FUNCsetviewvalue(VARv, VARbyteoffset, VARlittleendian, "int16", VARvalue).     

############# END ## 613 ###########################
############# BEGIN ## 614 ###########################
ID= 24.3.4.17
Summary= DataView.prototype.setInt32 ( byteOffset, value [ , littleEndian ] )
Description= When the setInt32 method is called with arguments byteOffset and value and optional argument littleEndian, the following steps are taken:
*0*let VARv be the this value. 
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*return ? FUNCsetviewvalue(VARv, VARbyteoffset, VARlittleendian, "int32", VARvalue).     

############# END ## 614 ###########################
############# BEGIN ## 615 ###########################
ID= 24.3.4.18
Summary= DataView.prototype.setUint8 ( byteOffset, value )
Description= When the setUint8 method is called with arguments byteOffset and value, the following steps are taken:
*0*let VARv be the this value. 
*0*return ? FUNCsetviewvalue(VARv, VARbyteoffset, true, "uint8", VARvalue).     

############# END ## 615 ###########################
############# BEGIN ## 616 ###########################
ID= 24.3.4.19
Summary= DataView.prototype.setUint16 ( byteOffset, value [ , littleEndian ] )
Description= When the setUint16 method is called with arguments byteOffset and value and optional argument littleEndian, the following steps are taken:
*0*let VARv be the this value. 
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*return ? FUNCsetviewvalue(VARv, VARbyteoffset, VARlittleendian, "uint16", VARvalue).     

############# END ## 616 ###########################
############# BEGIN ## 617 ###########################
ID= 24.3.4.20
Summary= DataView.prototype.setUint32 ( byteOffset, value [ , littleEndian ] )
Description= When the setUint32 method is called with arguments byteOffset and value and optional argument littleEndian, the following steps are taken:
*0*let VARv be the this value. 
*0*if VARlittleendian is not present, let VARlittleendian be false. 
*0*return ? FUNCsetviewvalue(VARv, VARbyteoffset, VARlittleendian, "uint32", VARvalue).     

############# END ## 617 ###########################
############# BEGIN ## 618 ###########################
ID= 24.4.1.1
Summary= ValidateSharedIntegerTypedArray ( typedArray [ , onlyInt32 ] )
Description= The abstract operation ValidateSharedIntegerTypedArray takes one argument typedArray and an optional Boolean onlyInt32. It performs the following steps:
*0*if VARonlyint32 is not present, set VARonlyint32 to false. 
*0*if FUNCtype(VARtypedarray) is not object, throw a typeerror exception. 
*0*if VARtypedarray does not have a [[TYPEDARRAYNAME]] internal slot, throw a typeerror exception. 
*0*let VARtypename be VARtypedarray.[[TYPEDARRAYNAME]]. 
*0*if VARonlyint32 is true, then
*1*if VARtypename is not "int32array", throw a typeerror exception. 
*0*else,
*1*if VARtypename is not "int8array", "uint8array", "int16array", "uint16array", "int32array", or "uint32array", throw a typeerror exception. 
*0*assert: VARtypedarray has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*let VARbuffer be VARtypedarray.[[VIEWEDARRAYBUFFER]]. 
*0*if FUNCissharedarraybuffer(VARbuffer) is false, throw a typeerror exception. 
*0*return VARbuffer.     

############# END ## 618 ###########################
############# BEGIN ## 619 ###########################
ID= 24.4.1.2
Summary= ValidateAtomicAccess ( typedArray, requestIndex )
Description= The abstract operation ValidateAtomicAccess takes two arguments, typedArray and requestIndex. It performs the following steps:
*0*assert: VARtypedarray is an object that has a [[VIEWEDARRAYBUFFER]] internal slot. 
*0*let VARaccessindex be ? FUNCtoindex(VARrequestindex). 
*0*let VARlength be VARtypedarray.[[ARRAYLENGTH]]. 
*0*assert: VARaccessindex ≥ 0. 
*0*if VARaccessindex ≥ VARlength, throw a rangeerror exception. 
*0*return VARaccessindex.     

############# END ## 619 ###########################
############# BEGIN ## 620 ###########################
ID= 24.4.1.3
Summary= GetWaiterList ( block, i )
Description= A  WaiterList is a semantic object that contains an ordered list of those agents that are waiting on a location (block, i) in shared memory; block is a Shared Data Block and i a byte offset into the memory of block.
*0*assert: VARblock is a shared data block. 
*0*assert: VARi and VARi+3 are valid byte offsets within the memory of VARblock. 
*0*assert: VARi is divisible by 4. 
*0*return the waiterlist that is referenced by the pair (VARblock, VARi).     

############# END ## 620 ###########################
############# BEGIN ## 621 ###########################
ID= 24.4.1.4
Summary= EnterCriticalSection ( WL )
Description= The abstract operation EnterCriticalSection takes one argument, a WaiterList WL. It performs the following steps:
*0*assert: the calling agent is not in the critical section for any waiterlist. 
*0*wait until no agent is in the critical section for VARwl, then enter the critical section for VARwl (without allowing any other agent to enter).     

############# END ## 621 ###########################
############# BEGIN ## 622 ###########################
ID= 24.4.1.5
Summary= LeaveCriticalSection ( WL )
Description= The abstract operation LeaveCriticalSection takes one argument, a WaiterList WL. It performs the following steps:
*0*assert: the calling agent is in the critical section for VARwl. 
*0*leave the critical section for VARwl.     

############# END ## 622 ###########################
############# BEGIN ## 623 ###########################
ID= 24.4.1.6
Summary= AddWaiter ( WL, W )
Description= The abstract operation AddWaiter takes two arguments, a WaiterList WL and an agent signifier W. It performs the following steps:
*0*assert: the calling agent is in the critical section for VARwl. 
*0*assert: VARw is not on the list of waiters in any waiterlist. 
*0*add VARw to the end of the list of waiters in VARwl.     

############# END ## 623 ###########################
############# BEGIN ## 624 ###########################
ID= 24.4.1.7
Summary= RemoveWaiter ( WL, W )
Description= The abstract operation RemoveWaiter takes two arguments, a WaiterList WL and an agent signifier W. It performs the following steps:
*0*assert: the calling agent is in the critical section for VARwl. 
*0*assert: VARw is on the list of waiters in VARwl. 
*0*remove VARw from the list of waiters in VARwl.     

############# END ## 624 ###########################
############# BEGIN ## 625 ###########################
ID= 24.4.1.8
Summary= RemoveWaiters ( WL, c )
Description= The abstract operation RemoveWaiters takes two arguments, a WaiterList WL and nonnegative integer c. It performs the following steps:
*0*assert: the calling agent is in the critical section for VARwl. 
*0*let VARl be a new empty list. 
*0*let VARs be a reference to the list of waiters in VARwl. 
*0*repeat, while VARc &gt; 0 and VARs is not an empty list,
*1*let VARw be the first waiter in VARs. 
*1*add VARw to the end of VARl. 
*1*remove VARw from VARs. 
*1*subtract 1 from VARc. 
*0*return VARl.     

############# END ## 625 ###########################
############# BEGIN ## 626 ###########################
ID= 24.4.1.9
Summary= Suspend ( WL, W, timeout )
Description= The abstract operation Suspend takes three arguments, a WaiterList WL, an agent signifier W, and a nonnegative, non-NaN Number timeout. It performs the following steps:
*0*assert: the calling agent is in the critical section for VARwl. 
*0*assert: VARw is equal to FUNCagentsignifier(). 
*0*assert: VARw is on the list of waiters in VARwl. 
*0*assert: FUNCagentcansuspend() is true. 
*0*perform FUNCleavecriticalsection(VARwl) and suspend VARw for up to VARtimeout milliseconds, performing the combined operation in such a way that a wakeup that arrives after the critical section is exited but before the suspension takes effect is not lost. VARw can wake up either because the timeout expired or because it was woken explicitly by another agent calling FUNCwakewaiter(VARwl, VARw), and not for any other reasons at all. 
*0*perform FUNCentercriticalsection(VARwl). 
*0*if VARw was woken explicitly by another agent calling FUNCwakewaiter(VARwl, VARw), return true. 
*0*return false.     

############# END ## 626 ###########################
############# BEGIN ## 627 ###########################
ID= 24.4.1.10
Summary= WakeWaiter ( WL, W )
Description= The abstract operation WakeWaiter takes two arguments, a WaiterList WL and an agent signifier W. It performs the following steps:
*0*assert: the calling agent is in the critical section for VARwl. 
*0*assert: VARw is on the list of waiters in VARwl. 
*0*wake the agent VARw.     

############# END ## 627 ###########################
############# BEGIN ## 628 ###########################
ID= 24.4.1.11
Summary= AtomicReadModifyWrite ( typedArray, index, value, op )
Description= The abstract operation AtomicReadModifyWrite takes four arguments, typedArray, index, value, and a pure combining operation op. The pure combining operation op takes two List of byte values arguments and returns a List of byte values. The operation atomically loads a value, combines it with another value, and stores the result of the combination. It returns the loaded value. It performs the following steps:
*0*let VARbuffer be ? FUNCvalidatesharedintegertypedarray(VARtypedarray). 
*0*let VARi be ? FUNCvalidateatomicaccess(VARtypedarray, VARindex). 
*0*let VARv be ? FUNCtointeger(VARvalue). 
*0*let VARarraytypename be VARtypedarray.[[TYPEDARRAYNAME]]. 
*0*let VARelementsize be the number value of the element size value specified in table 56 for VARarraytypename. 
*0*let VARelementtype be the string value of the element type value in table 56 for VARarraytypename. 
*0*let VARoffset be VARtypedarray.[[BYTEOFFSET]]. 
*0*let VARindexedposition be (VARi × VARelementsize) + VARoffset. 
*0*return FUNCgetmodifysetvalueinbuffer(VARbuffer, VARindexedposition, VARelementtype, VARv, VARop).     

############# END ## 628 ###########################
############# BEGIN ## 629 ###########################
ID= 24.4.1.12
Summary= AtomicLoad ( typedArray, index )
Description= The abstract operation AtomicLoad takes two arguments, typedArray, index. The operation atomically loads a value and returns the loaded value. It performs the following steps:
*0*let VARbuffer be ? FUNCvalidatesharedintegertypedarray(VARtypedarray). 
*0*let VARi be ? FUNCvalidateatomicaccess(VARtypedarray, VARindex). 
*0*let VARarraytypename be VARtypedarray.[[TYPEDARRAYNAME]]. 
*0*let VARelementsize be the number value of the element size value specified in table 56 for VARarraytypename. 
*0*let VARelementtype be the string value of the element type value in table 56 for VARarraytypename. 
*0*let VARoffset be VARtypedarray.[[BYTEOFFSET]]. 
*0*let VARindexedposition be (VARi × VARelementsize) + VARoffset. 
*0*return FUNCgetvaluefrombuffer(VARbuffer, VARindexedposition, VARelementtype, true, "seqcst").     

############# END ## 629 ###########################
############# BEGIN ## 630 ###########################
ID= 24.4.2
Summary= Atomics.add ( typedArray, index, value )
Description= Let add denote a semantic function of two List of byte values arguments that applies the addition operation to the Number values corresponding to the List of byte values arguments and returns a List of byte values corresponding to the result of that operation.
*0*return ? FUNCatomicreadmodifywrite(VARtypedarray, VARindex, VARvalue, add).    

############# END ## 630 ###########################
############# BEGIN ## 631 ###########################
ID= 24.4.3
Summary= Atomics.and ( typedArray, index, value )
Description= Let and denote a semantic function of two List of byte values arguments that applies the bitwise-and operation element-wise to the two arguments and returns a List of byte values corresponding to the result of that operation.
*0*return ? FUNCatomicreadmodifywrite(VARtypedarray, VARindex, VARvalue, and).    

############# END ## 631 ###########################
############# BEGIN ## 632 ###########################
ID= 24.4.4
Summary= Atomics.compareExchange ( typedArray, index, expectedValue, replacementValue )
Description= The following steps are taken:
*0*let VARbuffer be ? FUNCvalidatesharedintegertypedarray(VARtypedarray). 
*0*let VARi be ? FUNCvalidateatomicaccess(VARtypedarray, VARindex). 
*0*let VARexpected be ? FUNCtointeger(VARexpectedvalue). 
*0*let VARreplacement be ? FUNCtointeger(VARreplacementvalue). 
*0*let VARarraytypename be VARtypedarray.[[TYPEDARRAYNAME]]. 
*0*let VARelementtype be the string value of the element type value in table 56 for VARarraytypename. 
*0*let VARislittleendian be the value of the [[LITTLEENDIAN]] field of the surrounding agent's agent record. 
*0*let VARexpectedbytes be FUNCnumbertorawbytes(VARelementtype, VARexpected, VARislittleendian). 
*0*let VARelementsize be the number value of the element size value specified in table 56 for VARarraytypename. 
*0*let VARoffset be VARtypedarray.[[BYTEOFFSET]]. 
*0*let VARindexedposition be (VARi × VARelementsize) + VARoffset. 
*0*let compareexchange denote a semantic function of two list of byte values arguments that returns the second argument if the first argument is element-wise equal to VARexpectedbytes. 
*0*return FUNCgetmodifysetvalueinbuffer(VARbuffer, VARindexedposition, VARelementtype, VARreplacement, compareexchange).    

############# END ## 632 ###########################
############# BEGIN ## 633 ###########################
ID= 24.4.5
Summary= Atomics.exchange ( typedArray, index, value )
Description= Let second denote a semantic function of two List of byte values arguments that returns its second argument.
*0*return ? FUNCatomicreadmodifywrite(VARtypedarray, VARindex, VARvalue, second).    

############# END ## 633 ###########################
############# BEGIN ## 634 ###########################
ID= 24.4.6
Summary= Atomics.isLockFree ( size )
Description= The following steps are taken:
*0*let VARn be ? FUNCtointeger(VARsize). 
*0*let VARar be the agent record of the surrounding agent. 
*0*if VARn equals 1, return VARar.[[ISLOCKFREE1]]. 
*0*if VARn equals 2, return VARar.[[ISLOCKFREE2]]. 
*0*if VARn equals 4, return true. 
*0*return false.    

############# END ## 634 ###########################
############# BEGIN ## 635 ###########################
ID= 24.4.7
Summary= Atomics.load ( typedArray, index )
Description= The following steps are taken:
*0*return ? FUNCatomicload(VARtypedarray, VARindex).    

############# END ## 635 ###########################
############# BEGIN ## 636 ###########################
ID= 24.4.8
Summary= Atomics.or ( typedArray, index, value )
Description= Let or denote a semantic function of two List of byte values arguments that applies the bitwise-or operation element-wise to the two arguments and returns a List of byte values corresponding to the result of that operation.
*0*return ? FUNCatomicreadmodifywrite(VARtypedarray, VARindex, VARvalue, or).    

############# END ## 636 ###########################
############# BEGIN ## 637 ###########################
ID= 24.4.9
Summary= Atomics.store ( typedArray, index, value )
Description= The following steps are taken:
*0*let VARbuffer be ? FUNCvalidatesharedintegertypedarray(VARtypedarray). 
*0*let VARi be ? FUNCvalidateatomicaccess(VARtypedarray, VARindex). 
*0*let VARv be ? FUNCtointeger(VARvalue). 
*0*let VARarraytypename be VARtypedarray.[[TYPEDARRAYNAME]]. 
*0*let VARelementsize be the number value of the element size value specified in table 56 for VARarraytypename. 
*0*let VARelementtype be the string value of the element type value in table 56 for VARarraytypename. 
*0*let VARoffset be VARtypedarray.[[BYTEOFFSET]]. 
*0*let VARindexedposition be (VARi × VARelementsize) + VARoffset. 
*0*perform FUNCsetvalueinbuffer(VARbuffer, VARindexedposition, VARelementtype, VARv, true, "seqcst"). 
*0*return VARv.    

############# END ## 637 ###########################
############# BEGIN ## 638 ###########################
ID= 24.4.10
Summary= Atomics.sub ( typedArray, index, value )
Description= Let subtract denote a semantic function of two List of byte values arguments that applies the subtraction operation to the Number values corresponding to the List of byte values arguments and returns a List of byte values corresponding to the result of that operation.
*0*return ? FUNCatomicreadmodifywrite(VARtypedarray, VARindex, VARvalue, subtract).    

############# END ## 638 ###########################
############# BEGIN ## 639 ###########################
ID= 24.4.11
Summary= Atomics.wait ( typedArray, index, value, timeout )
Description= Atomics.wait puts the calling agent in a wait queue and puts it to sleep until it is awoken or the sleep times out. The following steps are taken:
*0*let VARbuffer be ? FUNCvalidatesharedintegertypedarray(VARtypedarray, true). 
*0*let VARi be ? FUNCvalidateatomicaccess(VARtypedarray, VARindex). 
*0*let VARv be ? FUNCtoint32(VARvalue). 
*0*let VARq be ? FUNCtonumber(VARtimeout). 
*0*if VARq is nan, let VARt be +∞, else let VARt be max(VARq, 0). 
*0*let VARb be FUNCagentcansuspend(). 
*0*if VARb is false, throw a typeerror exception. 
*0*let VARblock be VARbuffer.[[ARRAYBUFFERDATA]]. 
*0*let VARoffset be VARtypedarray.[[BYTEOFFSET]]. 
*0*let VARindexedposition be (VARi × 4) + VARoffset. 
*0*let VARwl be FUNCgetwaiterlist(VARblock, VARindexedposition). 
*0*perform FUNCentercriticalsection(VARwl). 
*0*let VARw be ! FUNCatomicload(VARtypedarray, VARi). 
*0*if VARv is not equal to VARw, then
*1*perform FUNCleavecriticalsection(VARwl). 
*1*return the string "not-equal". 
*0*let VARw be FUNCagentsignifier(). 
*0*perform FUNCaddwaiter(VARwl, VARw). 
*0*let VARawoken be FUNCsuspend(VARwl, VARw, VARt). 
*0*if VARawoken is true, then
*1*assert: VARw is not on the list of waiters in VARwl. 
*0*else,
*1*perform FUNCremovewaiter(VARwl, VARw). 
*0*perform FUNCleavecriticalsection(VARwl). 
*0*if VARawoken is true, return the string "ok". 
*0*return the string "timed-out".    

############# END ## 639 ###########################
############# BEGIN ## 640 ###########################
ID= 24.4.12
Summary= Atomics.wake ( typedArray, index, count )
Description= Atomics.wake wakes up some agents that are sleeping in the wait queue.  The following steps are taken:
*0*let VARbuffer be ? FUNCvalidatesharedintegertypedarray(VARtypedarray, true). 
*0*let VARi be ? FUNCvalidateatomicaccess(VARtypedarray, VARindex). 
*0*if VARcount is undefined, let VARc be +∞. 
*0*else,
*1*let VARintcount be ? FUNCtointeger(VARcount). 
*1*let VARc be max(VARintcount, 0). 
*0*let VARblock be VARbuffer.[[ARRAYBUFFERDATA]]. 
*0*let VARoffset be VARtypedarray.[[BYTEOFFSET]]. 
*0*let VARindexedposition be (VARi × 4) + VARoffset. 
*0*let VARwl be FUNCgetwaiterlist(VARblock, VARindexedposition). 
*0*let VARn be 0. 
*0*perform FUNCentercriticalsection(VARwl). 
*0*let VARs be FUNCremovewaiters(VARwl, VARc). 
*0*repeat, while VARs is not an empty list,
*1*let VARw be the first agent in VARs. 
*1*remove VARw from the front of VARs. 
*1*perform FUNCwakewaiter(VARwl, VARw). 
*1*add 1 to VARn. 
*0*perform FUNCleavecriticalsection(VARwl). 
*0*return VARn.    

############# END ## 640 ###########################
############# BEGIN ## 641 ###########################
ID= 24.4.13
Summary= Atomics.xor ( typedArray, index, value )
Description= Let xor denote a semantic function of two List of byte values arguments that applies the bitwise-xor operation element-wise to the two arguments and returns a List of byte values corresponding to the result of that operation.
*0*return ? FUNCatomicreadmodifywrite(VARtypedarray, VARindex, VARvalue, xor).    

############# END ## 641 ###########################
############# BEGIN ## 642 ###########################
ID= 24.5.1
Summary= JSON.parse ( text [ , reviver ] )
Description= The parse function parses a JSON text (a JSON-formatted String) and produces an ECMAScript value. The JSON format represents literals, arrays, and objects with a syntax similar to the syntax for ECMAScript literals, Array Initializers, and Object Initializers. After parsing, JSON objects are realized as ECMAScript objects. JSON arrays are realized as ECMAScript Array instances. JSON strings, numbers, booleans, and null are realized as ECMAScript Strings, Numbers, Booleans, and null.
*0*let VARjtext be ? FUNCtostring(VARtext). 
*0*parse VARjtext interpreted as utf-16 encoded unicode points (6.1.4) as a json text as specified in ecma-404. throw a syntaxerror exception if VARjtext is not a valid json text as defined in that specification. 
*0*let VARscripttext be the string-concatenation of "(", VARjtext, and ");". 
*0*let VARcompletion be the result of parsing and evaluating VARscripttext as if it was the source text of an ecmascript script, but using the alternative definition of doublestringcharacter provided below. the extended propertydefinitionevaluation semantics defined in b.3.1 must not be used during the evaluation. 
*0*let VARunfiltered be VARcompletion.[[VALUE]]. 
*0*assert: VARunfiltered is either a string, number, boolean, null, or an object that is defined by either an arrayliteral or an objectliteral. 
*0*if FUNCiscallable(VARreviver) is true, then
*1*let VARroot be FUNCobjectcreate(%objectprototype%). 
*1*let VARrootname be the empty string. 
*1*let VARstatus be FUNCcreatedataproperty(VARroot, VARrootname, VARunfiltered). 
*1*assert: VARstatus is true. 
*1*return ? FUNCinternalizejsonproperty(VARroot, VARrootname). 
*0*else,
*1*return VARunfiltered.    

############# END ## 642 ###########################
############# BEGIN ## 643 ###########################
ID= 24.5.1.1
Summary= Runtime Semantics: InternalizeJSONProperty ( holder, name )
Description= The abstract operation InternalizeJSONProperty is a recursive abstract operation that takes two parameters: a holder object and the String name of a property in that object. InternalizeJSONProperty uses the value of reviver that was originally passed to the above parse function.
*0*let VARval be ? FUNCget(VARholder, VARname). 
*0*if FUNCtype(VARval) is object, then
*1*let VARisarray be ? FUNCisarray(VARval). 
*1*if VARisarray is true, then
*2*let VARi be 0. 
*2*let VARlen be ? FUNCtolength(? FUNCget(VARval, "length")). 
*2*repeat, while VARi &lt; VARlen,
*3*let VARnewelement be ? FUNCinternalizejsonproperty(VARval, ! FUNCtostring(VARi)). 
*3*if VARnewelement is undefined, then
*4*perform ? VARval.[[DELETE]](! FUNCtostring(VARi)). 
*3*else,
*4*perform ? FUNCcreatedataproperty(VARval, ! FUNCtostring(VARi), VARnewelement). 
*4*note: this algorithm intentionally does not throw an exception if createdataproperty returns false. 
*3*add 1 to VARi. 
*1*else,
*2*let VARkeys be ? FUNCenumerableownpropertynames(VARval, "key"). 
*2*for each string VARp in VARkeys, do
*3*let VARnewelement be ? FUNCinternalizejsonproperty(VARval, VARp). 
*3*if VARnewelement is undefined, then
*4*perform ? VARval.[[DELETE]](VARp). 
*3*else,
*4*perform ? FUNCcreatedataproperty(VARval, VARp, VARnewelement). 
*4*note: this algorithm intentionally does not throw an exception if createdataproperty returns false. 
*0*return ? FUNCcall(VARreviver, VARholder, « VARname, VARval »).     

############# END ## 643 ###########################
############# BEGIN ## 644 ###########################
ID= 24.5.2
Summary= JSON.stringify ( value [ , replacer [ , space ] ] )
Description= The stringify function returns a String in UTF-16 encoded JSON format representing an ECMAScript value. It can take three parameters. The value parameter is an ECMAScript value, which is usually an object or array, although it can also be a String, Boolean, Number or null. The optional replacer parameter is either a function that alters the way objects and arrays are stringified, or an array of Strings and Numbers that acts as an inclusion list for selecting the object properties that will be stringified. The optional space parameter is a String or Number that allows the result to have white space injected into it to improve human readability.
*0*let VARstack be a new empty list. 
*0*let VARindent be the empty string. 
*0*let VARpropertylist and VARreplacerfunction be undefined. 
*0*if FUNCtype(VARreplacer) is object, then
*1*if FUNCiscallable(VARreplacer) is true, then
*2*let VARreplacerfunction be VARreplacer. 
*1*else,
*2*let VARisarray be ? FUNCisarray(VARreplacer). 
*2*if VARisarray is true, then
*3*let VARpropertylist be a new empty list. 
*3*let VARlen be ? FUNCtolength(? FUNCget(VARreplacer, "length")). 
*3*let VARk be 0. 
*3*repeat, while VARk&lt;VARlen,
*4*let VARv be ? FUNCget(VARreplacer, ! FUNCtostring(VARk)). 
*4*let VARitem be undefined. 
*4*if FUNCtype(VARv) is string, let VARitem be VARv. 
*4*else if FUNCtype(VARv) is number, let VARitem be ! FUNCtostring(VARv). 
*4*else if FUNCtype(VARv) is object, then
*5*if VARv has a [[STRINGDATA]] or [[NUMBERDATA]] internal slot, let VARitem be ? FUNCtostring(VARv). 
*4*if VARitem is not undefined and VARitem is not currently an element of VARpropertylist, then
*5*append VARitem to the end of VARpropertylist. 
*4*let VARk be VARk+1. 
*0*if FUNCtype(VARspace) is object, then
*1*if VARspace has a [[NUMBERDATA]] internal slot, then
*2*let VARspace be ? FUNCtonumber(VARspace). 
*1*else if VARspace has a [[STRINGDATA]] internal slot, then
*2*let VARspace be ? FUNCtostring(VARspace). 
*0*if FUNCtype(VARspace) is number, then
*1*let VARspace be min(10, FUNCtointeger(VARspace)). 
*1*set VARgap to the string value containing VARspace occurrences of the code unit 0x0020 (space). this will be the empty string if VARspace is less than 1. 
*0*else if FUNCtype(VARspace) is string, then
*1*if the length of VARspace is 10 or less, set VARgap to VARspace; otherwise set VARgap to the string value consisting of the first 10 elements of VARspace. 
*0*else,
*1*set VARgap to the empty string. 
*0*let VARwrapper be FUNCobjectcreate(%objectprototype%). 
*0*let VARstatus be FUNCcreatedataproperty(VARwrapper, the empty string, VARvalue). 
*0*assert: VARstatus is true. 
*0*return ? FUNCserializejsonproperty(the empty string, VARwrapper).    

############# END ## 644 ###########################
############# BEGIN ## 645 ###########################
ID= 24.5.2.1
Summary= Runtime Semantics: SerializeJSONProperty ( key, holder )
Description= The abstract operation SerializeJSONProperty with arguments key, and holder has access to ReplacerFunction from the invocation of the stringify method. Its algorithm is as follows:
*0*let VARvalue be ? FUNCget(VARholder, VARkey). 
*0*if FUNCtype(VARvalue) is object, then
*1*let VARtojson be ? FUNCget(VARvalue, "tojson"). 
*1*if FUNCiscallable(VARtojson) is true, then
*2*set VARvalue to ? FUNCcall(VARtojson, VARvalue, « VARkey »). 
*0*if VARreplacerfunction is not undefined, then
*1*set VARvalue to ? FUNCcall(VARreplacerfunction, VARholder, « VARkey, VARvalue »). 
*0*if FUNCtype(VARvalue) is object, then
*1*if VARvalue has a [[NUMBERDATA]] internal slot, then
*2*set VARvalue to ? FUNCtonumber(VARvalue). 
*1*else if VARvalue has a [[STRINGDATA]] internal slot, then
*2*set VARvalue to ? FUNCtostring(VARvalue). 
*1*else if VARvalue has a [[BOOLEANDATA]] internal slot, then
*2*set VARvalue to VARvalue.[[BOOLEANDATA]]. 
*0*if VARvalue is null, return "null". 
*0*if VARvalue is true, return "true". 
*0*if VARvalue is false, return "false". 
*0*if FUNCtype(VARvalue) is string, return FUNCquotejsonstring(VARvalue). 
*0*if FUNCtype(VARvalue) is number, then
*1*if VARvalue is finite, return ! FUNCtostring(VARvalue). 
*1*return "null". 
*0*if FUNCtype(VARvalue) is object and FUNCiscallable(VARvalue) is false, then
*1*let VARisarray be ? FUNCisarray(VARvalue). 
*1*if VARisarray is true, return ? FUNCserializejsonarray(VARvalue). 
*1*return ? FUNCserializejsonobject(VARvalue). 
*0*return undefined.     

############# END ## 645 ###########################
############# BEGIN ## 646 ###########################
ID= 24.5.2.2
Summary= Runtime Semantics: QuoteJSONString ( value )
Description= The abstract operation QuoteJSONString with argument value wraps a String value in QUOTATION MARK code units and escapes certain other code units within it.
*0*let VARproduct be the string value consisting solely of the code unit 0x0022 (quotation mark). 
*0*for each code unit VARc in VARvalue, do
*1*if the numeric value of VARc is listed in the code unit value column of table 59, then
*2*set VARproduct to the string-concatenation of VARproduct and the escape sequence for VARc as specified in table 59. 
*1*else if VARc has a numeric value less than 0x0020 (space), then
*2*set VARproduct to the FUNCstring-concatenation of VARproduct and unicodeescape(VARc). 
*1*else,
*2*set VARproduct to the string-concatenation of VARproduct and VARc. 
*0*set VARproduct to the string-concatenation of VARproduct and the code unit 0x0022 (quotation mark). 
*0*return VARproduct.     

############# END ## 646 ###########################
############# BEGIN ## 647 ###########################
ID= 24.5.2.3
Summary= Runtime Semantics: UnicodeEscape ( C )
Description= The abstract operation UnicodeEscape takes a code unit argument C and represents it as a Unicode escape sequence.
*0*let VARn be the numeric value of VARc. 
*0*assert: VARn ≤ 0xffff. 
*0*return the string-concatenation of:the code unit 0x005c (reverse solidus) "u" the string representation of VARn, formatted as a four-digit lowercase hexadecimal number, padded to the left with zeroes if necessary     

############# END ## 647 ###########################
############# BEGIN ## 648 ###########################
ID= 24.5.2.4
Summary= Runtime Semantics: SerializeJSONObject ( value )
Description= The abstract operation SerializeJSONObject with argument value serializes an object. It has access to the stack, indent, gap, and PropertyList values of the current invocation of the stringify method.
*0*if VARstack contains VARvalue, throw a typeerror exception because the structure is cyclical. 
*0*append VARvalue to VARstack. 
*0*let VARstepback be VARindent. 
*0*set VARindent to the string-concatenation of VARindent and VARgap. 
*0*if VARpropertylist is not undefined, then
*1*let VARk be VARpropertylist. 
*0*else,
*1*let VARk be ? FUNCenumerableownpropertynames(VARvalue, "key"). 
*0*let VARpartial be a new empty list. 
*0*for each element VARp of VARk, do
*1*let VARstrp be ? FUNCserializejsonproperty(VARp, VARvalue). 
*1*if VARstrp is not undefined, then
*2*let VARmember be FUNCquotejsonstring(VARp). 
*2*set VARmember to the string-concatenation of VARmember and ":". 
*2*if VARgap is not the empty string, then
*3*set VARmember to the string-concatenation of VARmember and the code unit 0x0020 (space). 
*2*set VARmember to the string-concatenation of VARmember and VARstrp. 
*2*append VARmember to VARpartial. 
*0*if VARpartial is empty, then
*1*let VARfinal be "{}". 
*0*else,
*1*if VARgap is the empty string, then
*2*let VARproperties be the string value formed by concatenating all the element strings of VARpartial with each adjacent pair of strings separated with the code unit 0x002c (comma). a comma is not inserted either before the first string or after the last string. 
*2*let VARfinal be the string-concatenation of "{", VARproperties, and "}". 
*1*else VARgap is not the empty string,
*2*let VARseparator be the string-concatenation of the code unit 0x002c (comma), the code unit 0x000a (line feed), and VARindent. 
*2*let VARproperties be the string value formed by concatenating all the element strings of VARpartial with each adjacent pair of strings separated with VARseparator. the VARseparator string is not inserted either before the first string or after the last string. 
*2*let VARfinal be the string-concatenation of "{", the code unit 0x000a (line feed), VARindent, VARproperties, the code unit 0x000a (line feed), VARstepback, and "}". 
*0*remove the last element of VARstack. 
*0*set VARindent to VARstepback. 
*0*return VARfinal.     

############# END ## 648 ###########################
############# BEGIN ## 649 ###########################
ID= 24.5.2.5
Summary= Runtime Semantics: SerializeJSONArray ( value )
Description= The abstract operation SerializeJSONArray with argument value serializes an array. It has access to the stack, indent, and gap values of the current invocation of the stringify method.
*0*if VARstack contains VARvalue, throw a typeerror exception because the structure is cyclical. 
*0*append VARvalue to VARstack. 
*0*let VARstepback be VARindent. 
*0*set VARindent to the string-concatenation of VARindent and VARgap. 
*0*let VARpartial be a new empty list. 
*0*let VARlen be ? FUNCtolength(? FUNCget(VARvalue, "length")). 
*0*let VARindex be 0. 
*0*repeat, while VARindex &lt; VARlen
*1*let VARstrp be ? FUNCserializejsonproperty(! FUNCtostring(VARindex), VARvalue). 
*1*if VARstrp is undefined, then
*2*append "null" to VARpartial. 
*1*else,
*2*append VARstrp to VARpartial. 
*1*increment VARindex by 1. 
*0*if VARpartial is empty, then
*1*let VARfinal be "[]". 
*0*else,
*1*if VARgap is the empty string, then
*2*let VARproperties be the string value formed by concatenating all the element strings of VARpartial with each adjacent pair of strings separated with the code unit 0x002c (comma). a comma is not inserted either before the first string or after the last string. 
*2*let VARfinal be the string-concatenation of "[", VARproperties, and "]". 
*1*else,
*2*let VARseparator be the string-concatenation of the code unit 0x002c (comma), the code unit 0x000a (line feed), and VARindent. 
*2*let VARproperties be the string value formed by concatenating all the element strings of VARpartial with each adjacent pair of strings separated with VARseparator. the VARseparator string is not inserted either before the first string or after the last string. 
*2*let VARfinal be the string-concatenation of "[", the code unit 0x000a (line feed), VARindent, VARproperties, the code unit 0x000a (line feed), VARstepback, and "]". 
*0*remove the last element of VARstack. 
*0*set VARindent to VARstepback. 
*0*return VARfinal.     

############# END ## 649 ###########################
############# BEGIN ## 650 ###########################
ID= 25.1.2.1
Summary= %IteratorPrototype% [ @@iterator ] ( )
Description= The following steps are taken:
*0*return the this value.     

############# END ## 650 ###########################
############# BEGIN ## 651 ###########################
ID= 25.1.3.1
Summary= %AsyncIteratorPrototype% [ @@asyncIterator ] ( )
Description= The following steps are taken:
*0*return the this value.     

############# END ## 651 ###########################
############# BEGIN ## 652 ###########################
ID= 25.1.4.1
Summary= CreateAsyncFromSyncIterator ( syncIteratorRecord )
Description= The abstract operation CreateAsyncFromSyncIterator is used to create an async iterator Record from a synchronous iterator Record. It performs the following steps:
*0*let VARasynciterator be ! FUNCobjectcreate(%asyncfromsynciteratorprototype%, « [[SYNCITERATORRECORD]] »). 
*0*set VARasynciterator.[[SYNCITERATORRECORD]] to VARsynciteratorrecord. 
*0*return ? FUNCgetiterator(VARasynciterator, async).     

############# END ## 652 ###########################
############# BEGIN ## 653 ###########################
ID= 25.1.4.2.1
Summary= %AsyncFromSyncIteratorPrototype%.next ( value )
Description= None
*0*let VARo be the this value. 
*0*let VARpromisecapability be ! FUNCnewpromisecapability(%promise%). 
*0*if FUNCtype(VARo) is not object, or if VARo does not have a [[SYNCITERATORRECORD]] internal slot, then
*1*let VARinvaliditeratorerror be a newly created typeerror object. 
*1*perform ! FUNCcall(VARpromisecapability.[[REJECT]], undefined, « VARinvaliditeratorerror »). 
*1*return VARpromisecapability.[[PROMISE]]. 
*0*let VARsynciteratorrecord be VARo.[[SYNCITERATORRECORD]]. 
*0*let VARnextresult be FUNCiteratornext(VARsynciteratorrecord, VARvalue). 
*0*FUNCifabruptrejectpromise(VARnextresult, VARpromisecapability). 
*0*let VARnextdone be FUNCiteratorcomplete(VARnextresult). 
*0*FUNCifabruptrejectpromise(VARnextdone, VARpromisecapability). 
*0*let VARnextvalue be FUNCiteratorvalue(VARnextresult). 
*0*FUNCifabruptrejectpromise(VARnextvalue, VARpromisecapability). 
*0*let VARvaluewrappercapability be ! FUNCnewpromisecapability(%promise%). 
*0*perform ! FUNCcall(VARvaluewrappercapability.[[RESOLVE]], undefined, « VARnextvalue »). 
*0*let VARsteps be the algorithm steps defined in async-from-sync iterator value unwrap functions. 
*0*let VARonfulfilled be FUNCcreatebuiltinfunction(VARsteps, « [[DONE]] »). 
*0*set VARonfulfilled.[[DONE]] to VARnextdone. 
*0*perform ! FUNCperformpromisethen(VARvaluewrappercapability.[[PROMISE]], VARonfulfilled, undefined, VARpromisecapability). 
*0*return VARpromisecapability.[[PROMISE]].      

############# END ## 653 ###########################
############# BEGIN ## 654 ###########################
ID= 25.1.4.2.2
Summary= %AsyncFromSyncIteratorPrototype%.return ( value )
Description= None
*0*let VARo be the this value. 
*0*let VARpromisecapability be ! FUNCnewpromisecapability(%promise%). 
*0*if FUNCtype(VARo) is not object, or if VARo does not have a [[SYNCITERATORRECORD]] internal slot, then
*1*let VARinvaliditeratorerror be a newly created typeerror object. 
*1*perform ! FUNCcall(VARpromisecapability.[[REJECT]], undefined, « VARinvaliditeratorerror »). 
*1*return VARpromisecapability.[[PROMISE]]. 
*0*let VARsynciterator be VARo.[[SYNCITERATORRECORD]].[[ITERATOR]]. 
*0*let VARreturn be FUNCgetmethod(VARsynciterator, "return"). 
*0*FUNCifabruptrejectpromise(VARreturn, VARpromisecapability). 
*0*if VARreturn is undefined, then
*1*let VARiterresult be ! FUNCcreateiterresultobject(VARvalue, true). 
*1*perform ! FUNCcall(VARpromisecapability.[[RESOLVE]], undefined, « VARiterresult »). 
*1*return VARpromisecapability.[[PROMISE]]. 
*0*let VARreturnresult be FUNCcall(VARreturn, VARsynciterator, « VARvalue »). 
*0*FUNCifabruptrejectpromise(VARreturnresult, VARpromisecapability). 
*0*if FUNCtype(VARreturnresult) is not object, then
*1*perform ! FUNCcall(VARpromisecapability.[[REJECT]], undefined, « a newly created typeerror object »). 
*1*return VARpromisecapability.[[PROMISE]]. 
*0*let VARreturndone be FUNCiteratorcomplete(VARreturnresult). 
*0*FUNCifabruptrejectpromise(VARreturndone, VARpromisecapability). 
*0*let VARreturnvalue be FUNCiteratorvalue(VARreturnresult). 
*0*FUNCifabruptrejectpromise(VARreturnvalue, VARpromisecapability). 
*0*let VARvaluewrappercapability be ! FUNCnewpromisecapability(%promise%). 
*0*perform ! FUNCcall(VARvaluewrappercapability.[[RESOLVE]], undefined, « VARreturnvalue »). 
*0*let VARsteps be the algorithm steps defined in async-from-sync iterator value unwrap functions. 
*0*let VARonfulfilled be FUNCcreatebuiltinfunction(VARsteps, « [[DONE]] »). 
*0*set VARonfulfilled.[[DONE]] to VARreturndone. 
*0*perform ! FUNCperformpromisethen(VARvaluewrappercapability.[[PROMISE]], VARonfulfilled, undefined, VARpromisecapability). 
*0*return VARpromisecapability.[[PROMISE]].      

############# END ## 654 ###########################
############# BEGIN ## 655 ###########################
ID= 25.1.4.2.3
Summary= %AsyncFromSyncIteratorPrototype%.throw ( value )
Description= None
*0*let VARo be the this value. 
*0*let VARpromisecapability be ! FUNCnewpromisecapability(%promise%). 
*0*if FUNCtype(VARo) is not object, or if VARo does not have a [[SYNCITERATORRECORD]] internal slot, then
*1*let VARinvaliditeratorerror be a newly created typeerror object. 
*1*perform ! FUNCcall(VARpromisecapability.[[REJECT]], undefined, « VARinvaliditeratorerror »). 
*1*return VARpromisecapability.[[PROMISE]]. 
*0*let VARsynciterator be VARo.[[SYNCITERATORRECORD]].[[ITERATOR]]. 
*0*let VARthrow be FUNCgetmethod(VARsynciterator, "throw"). 
*0*FUNCifabruptrejectpromise(VARthrow, VARpromisecapability). 
*0*if VARthrow is undefined, then
*1*perform ! FUNCcall(VARpromisecapability.[[REJECT]], undefined, « VARvalue »). 
*1*return VARpromisecapability.[[PROMISE]]. 
*0*let VARthrowresult be FUNCcall(VARthrow, VARsynciterator, « VARvalue »). 
*0*FUNCifabruptrejectpromise(VARthrowresult, VARpromisecapability). 
*0*if FUNCtype(VARthrowresult) is not object, then
*1*perform ! FUNCcall(VARpromisecapability.[[REJECT]], undefined, « a newly created typeerror object »). 
*1*return VARpromisecapability.[[PROMISE]]. 
*0*let VARthrowdone be FUNCiteratorcomplete(VARthrowresult). 
*0*FUNCifabruptrejectpromise(VARthrowdone, VARpromisecapability). 
*0*let VARthrowvalue be FUNCiteratorvalue(VARthrowresult). 
*0*FUNCifabruptrejectpromise(VARthrowvalue, VARpromisecapability). 
*0*let VARvaluewrappercapability be ! FUNCnewpromisecapability(%promise%). 
*0*perform ! FUNCcall(VARvaluewrappercapability.[[RESOLVE]], undefined, « VARthrowvalue »). 
*0*let VARsteps be the algorithm steps defined in async-from-sync iterator value unwrap functions. 
*0*let VARonfulfilled be FUNCcreatebuiltinfunction(VARsteps, « [[DONE]] »). 
*0*set VARonfulfilled.[[DONE]] to VARthrowdone. 
*0*perform ! FUNCperformpromisethen(VARvaluewrappercapability.[[PROMISE]], VARonfulfilled, undefined, VARpromisecapability). 
*0*return VARpromisecapability.[[PROMISE]].      

############# END ## 655 ###########################
############# BEGIN ## 656 ###########################
ID= 25.2.1.1
Summary= GeneratorFunction ( p1, p2, … , pn, body )
Description= The last argument specifies the body (executable code) of a generator function; any preceding arguments specify formal parameters.
*0*let VARc be the active function object. 
*0*let VARargs be the VARargumentslist that was passed to this function by [[CALL]] or [[CONSTRUCT]]. 
*0*return ? FUNCcreatedynamicfunction(VARc, newtarget, "generator", VARargs).     

############# END ## 656 ###########################
############# BEGIN ## 657 ###########################
ID= 25.3.1.1
Summary= AsyncGeneratorFunction ( p1, p2, ..., pn, body )
Description= The last argument specifies the body (executable code) of an async generator function; any preceding arguments specify formal parameters.
*0*let VARc be the active function object. 
*0*let VARargs be the VARargumentslist that was passed to this function by [[CALL]] or [[CONSTRUCT]]. 
*0*return ? FUNCcreatedynamicfunction(VARc, newtarget, "async generator", VARargs).     

############# END ## 657 ###########################
############# BEGIN ## 658 ###########################
ID= 25.4.1.2
Summary= Generator.prototype.next ( value )
Description= The next method performs the following steps:
*0*let VARg be the this value. 
*0*return ? FUNCgeneratorresume(VARg, VARvalue).     

############# END ## 658 ###########################
############# BEGIN ## 659 ###########################
ID= 25.4.1.3
Summary= Generator.prototype.return ( value )
Description= The return method performs the following steps:
*0*let VARg be the this value. 
*0*let VARc be completion { [[TYPE]]: return, [[VALUE]]: VARvalue, [[TARGET]]: empty }. 
*0*return ? FUNCgeneratorresumeabrupt(VARg, VARc).     

############# END ## 659 ###########################
############# BEGIN ## 660 ###########################
ID= 25.4.1.4
Summary= Generator.prototype.throw ( exception )
Description= The throw method performs the following steps:
*0*let VARg be the this value. 
*0*let VARc be FUNCthrowcompletion(VARexception). 
*0*return ? FUNCgeneratorresumeabrupt(VARg, VARc).     

############# END ## 660 ###########################
############# BEGIN ## 661 ###########################
ID= 25.4.3.1
Summary= GeneratorStart ( generator, generatorBody )
Description= The abstract operation GeneratorStart with arguments generator and generatorBody performs the following steps:
*0*assert: the value of VARgenerator.[[GENERATORSTATE]] is undefined. 
*0*let VARgencontext be the running execution context. 
*0*set the generator component of VARgencontext to VARgenerator. 
*0*set the code evaluation state of VARgencontext such that when evaluation is resumed for that execution context the following steps will be performed:
*1*let VARresult be the result of evaluating VARgeneratorbody. 
*1*assert: if we return here, the generator either threw an exception or performed either an implicit or explicit return. 
*1*remove VARgencontext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context. 
*1*set VARgenerator.[[GENERATORSTATE]] to "completed". 
*1*once a generator enters the "completed" state it never leaves it and its associated execution context is never resumed. any execution state associated with VARgenerator can be discarded at this point. 
*1*if VARresult.[[TYPE]] is normal, let VARresultvalue be undefined. 
*1*else if VARresult.[[TYPE]] is return, let VARresultvalue be VARresult.[[VALUE]]. 
*1*else,
*2*assert: VARresult.[[TYPE]] is throw. 
*2*return FUNCcompletion(VARresult). 
*1*return FUNCcreateiterresultobject(VARresultvalue, true). 
*0*set VARgenerator.[[GENERATORCONTEXT]] to VARgencontext. 
*0*set VARgenerator.[[GENERATORSTATE]] to "suspendedstart". 
*0*return FUNCnormalcompletion(undefined).     

############# END ## 661 ###########################
############# BEGIN ## 662 ###########################
ID= 25.4.3.2
Summary= GeneratorValidate ( generator )
Description= The abstract operation GeneratorValidate with argument generator performs the following steps:
*0*if FUNCtype(VARgenerator) is not object, throw a typeerror exception. 
*0*if VARgenerator does not have a [[GENERATORSTATE]] internal slot, throw a typeerror exception. 
*0*assert: VARgenerator also has a [[GENERATORCONTEXT]] internal slot. 
*0*let VARstate be VARgenerator.[[GENERATORSTATE]]. 
*0*if VARstate is "executing", throw a typeerror exception. 
*0*return VARstate.     

############# END ## 662 ###########################
############# BEGIN ## 663 ###########################
ID= 25.4.3.3
Summary= GeneratorResume ( generator, value )
Description= The abstract operation GeneratorResume with arguments generator and value performs the following steps:
*0*let VARstate be ? FUNCgeneratorvalidate(VARgenerator). 
*0*if VARstate is "completed", return FUNCcreateiterresultobject(undefined, true). 
*0*assert: VARstate is either "suspendedstart" or "suspendedyield". 
*0*let VARgencontext be VARgenerator.[[GENERATORCONTEXT]]. 
*0*let VARmethodcontext be the running execution context. 
*0*suspend VARmethodcontext. 
*0*set VARgenerator.[[GENERATORSTATE]] to "executing". 
*0*push VARgencontext onto the execution context stack; VARgencontext is now the running execution context. 
*0*resume the suspended evaluation of VARgencontext using FUNCnormalcompletion(VARvalue) as the result of the operation that suspended it. let VARresult be the value returned by the resumed computation. 
*0*assert: when we return here, VARgencontext has already been removed from the execution context stack and VARmethodcontext is the currently running execution context. 
*0*return FUNCcompletion(VARresult).     

############# END ## 663 ###########################
############# BEGIN ## 664 ###########################
ID= 25.4.3.4
Summary= GeneratorResumeAbrupt ( generator, abruptCompletion )
Description= The abstract operation GeneratorResumeAbrupt with arguments generator and abruptCompletion performs the following steps:
*0*let VARstate be ? FUNCgeneratorvalidate(VARgenerator). 
*0*if VARstate is "suspendedstart", then
*1*set VARgenerator.[[GENERATORSTATE]] to "completed". 
*1*once a generator enters the "completed" state it never leaves it and its associated execution context is never resumed. any execution state associated with VARgenerator can be discarded at this point. 
*1*set VARstate to "completed". 
*0*if VARstate is "completed", then
*1*if VARabruptcompletion.[[TYPE]] is return, then
*2*return FUNCcreateiterresultobject(VARabruptcompletion.[[VALUE]], true). 
*1*return FUNCcompletion(VARabruptcompletion). 
*0*assert: VARstate is "suspendedyield". 
*0*let VARgencontext be VARgenerator.[[GENERATORCONTEXT]]. 
*0*let VARmethodcontext be the running execution context. 
*0*suspend VARmethodcontext. 
*0*set VARgenerator.[[GENERATORSTATE]] to "executing". 
*0*push VARgencontext onto the execution context stack; VARgencontext is now the running execution context. 
*0*resume the suspended evaluation of VARgencontext using VARabruptcompletion as the result of the operation that suspended it. let VARresult be the completion record returned by the resumed computation. 
*0*assert: when we return here, VARgencontext has already been removed from the execution context stack and VARmethodcontext is the currently running execution context. 
*0*return FUNCcompletion(VARresult).     

############# END ## 664 ###########################
############# BEGIN ## 665 ###########################
ID= 25.4.3.5
Summary= GetGeneratorKind ( )
Description= None
*0*let VARgencontext be the running execution context. 
*0*if VARgencontext does not have a generator component, return non-generator. 
*0*let VARgenerator be the generator component of VARgencontext. 
*0*if VARgenerator has an [[ASYNCGENERATORSTATE]] internal slot, return async. 
*0*else, return sync.     

############# END ## 665 ###########################
############# BEGIN ## 666 ###########################
ID= 25.4.3.6
Summary= GeneratorYield ( iterNextObj )
Description= The abstract operation GeneratorYield with argument iterNextObj performs the following steps:
*0*assert: VARiternextobj is an object that implements the iteratorresult interface. 
*0*let VARgencontext be the running execution context. 
*0*assert: VARgencontext is the execution context of a generator. 
*0*let VARgenerator be the value of the generator component of VARgencontext. 
*0*assert: FUNCgetgeneratorkind() is sync. 
*0*set VARgenerator.[[GENERATORSTATE]] to "suspendedyield". 
*0*remove VARgencontext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context. 
*0*set the code evaluation state of VARgencontext such that when evaluation is resumed with a completion VARresumptionvalue the following steps will be performed:
*1*return VARresumptionvalue. 
*1*note: this returns to the evaluation of the yieldexpression that originally called this abstract operation. 
*0*return FUNCnormalcompletion(VARiternextobj). 
*0*note: this returns to the evaluation of the operation that had most previously resumed evaluation of VARgencontext.     

############# END ## 666 ###########################
############# BEGIN ## 667 ###########################
ID= 25.5.1.2
Summary= AsyncGenerator.prototype.next ( value )
Description= None
*0*let VARgenerator be the this value. 
*0*let VARcompletion be FUNCnormalcompletion(VARvalue). 
*0*return ! FUNCasyncgeneratorenqueue(VARgenerator, VARcompletion).     

############# END ## 667 ###########################
############# BEGIN ## 668 ###########################
ID= 25.5.1.3
Summary= AsyncGenerator.prototype.return ( value )
Description= None
*0*let VARgenerator be the this value. 
*0*let VARcompletion be completion { [[TYPE]]: return, [[VALUE]]: VARvalue, [[TARGET]]: empty }. 
*0*return ! FUNCasyncgeneratorenqueue(VARgenerator, VARcompletion).     

############# END ## 668 ###########################
############# BEGIN ## 669 ###########################
ID= 25.5.1.4
Summary= AsyncGenerator.prototype.throw ( exception )
Description= None
*0*let VARgenerator be the this value. 
*0*let VARcompletion be FUNCthrowcompletion(VARexception). 
*0*return ! FUNCasyncgeneratorenqueue(VARgenerator, VARcompletion).     

############# END ## 669 ###########################
############# BEGIN ## 670 ###########################
ID= 25.5.3.2
Summary= AsyncGeneratorStart ( generator, generatorBody )
Description= None
*0*assert: VARgenerator is an asyncgenerator instance. 
*0*assert: VARgenerator.[[ASYNCGENERATORSTATE]] is undefined. 
*0*let VARgencontext be the running execution context. 
*0*set the generator component of VARgencontext to VARgenerator. 
*0*set the code evaluation state of VARgencontext such that when evaluation is resumed for that execution context the following steps will be performed:
*1*let VARresult be the result of evaluating VARgeneratorbody. 
*1*assert: if we return here, the async generator either threw an exception or performed either an implicit or explicit return. 
*1*remove VARgencontext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context. 
*1*set VARgenerator.[[ASYNCGENERATORSTATE]] to "completed". 
*1*if VARresult is a normal completion, let VARresultvalue be undefined. 
*1*else,
*2*let VARresultvalue be VARresult.[[VALUE]]. 
*2*if VARresult.[[TYPE]] is not return, then
*3*return ! FUNCasyncgeneratorreject(VARgenerator, VARresultvalue). 
*1*return ! FUNCasyncgeneratorresolve(VARgenerator, VARresultvalue, true). 
*0*set VARgenerator.[[ASYNCGENERATORCONTEXT]] to VARgencontext. 
*0*set VARgenerator.[[ASYNCGENERATORSTATE]] to "suspendedstart". 
*0*set VARgenerator.[[ASYNCGENERATORQUEUE]] to a new empty list. 
*0*return undefined.     

############# END ## 670 ###########################
############# BEGIN ## 671 ###########################
ID= 25.5.3.3
Summary= AsyncGeneratorResolve ( generator, value, done )
Description= None
*0*assert: VARgenerator is an asyncgenerator instance. 
*0*let VARqueue be VARgenerator.[[ASYNCGENERATORQUEUE]]. 
*0*assert: VARqueue is not an empty list. 
*0*remove the first element from VARqueue and let VARnext be the value of that element. 
*0*let VARpromisecapability be VARnext.[[CAPABILITY]]. 
*0*let VARiteratorresult be ! FUNCcreateiterresultobject(VARvalue, VARdone). 
*0*perform ! FUNCcall(VARpromisecapability.[[RESOLVE]], undefined, « VARiteratorresult »). 
*0*perform ! FUNCasyncgeneratorresumenext(VARgenerator). 
*0*return undefined.     

############# END ## 671 ###########################
############# BEGIN ## 672 ###########################
ID= 25.5.3.4
Summary= AsyncGeneratorReject ( generator, exception )
Description= None
*0*assert: VARgenerator is an asyncgenerator instance. 
*0*let VARqueue be VARgenerator.[[ASYNCGENERATORQUEUE]]. 
*0*assert: VARqueue is not an empty list. 
*0*remove the first element from VARqueue and let VARnext be the value of that element. 
*0*let VARpromisecapability be VARnext.[[CAPABILITY]]. 
*0*perform ! FUNCcall(VARpromisecapability.[[REJECT]], undefined, « VARexception »). 
*0*perform ! FUNCasyncgeneratorresumenext(VARgenerator). 
*0*return undefined.     

############# END ## 672 ###########################
############# BEGIN ## 673 ###########################
ID= 25.5.3.5
Summary= AsyncGeneratorResumeNext ( generator )
Description= An AsyncGeneratorResumeNext return processor fulfilled function is an anonymous built-in function that is used as part of the AsyncGeneratorResumeNext specification device to unwrap promises passed in to the  AsyncGenerator.prototype.return ( value ) method. Each AsyncGeneratorResumeNext return processor fulfilled function has a [[Generator]] internal slot.
*0*assert: VARgenerator is an asyncgenerator instance. 
*0*let VARstate be VARgenerator.[[ASYNCGENERATORSTATE]]. 
*0*assert: VARstate is not "executing". 
*0*if VARstate is "awaiting-return", return undefined. 
*0*let VARqueue be VARgenerator.[[ASYNCGENERATORQUEUE]]. 
*0*if VARqueue is an empty list, return undefined. 
*0*let VARnext be the value of the first element of VARqueue. 
*0*assert: VARnext is an asyncgeneratorrequest record. 
*0*let VARcompletion be VARnext.[[COMPLETION]]. 
*0*if VARcompletion is an abrupt completion, then
*1*if VARstate is "suspendedstart", then
*2*set VARgenerator.[[ASYNCGENERATORSTATE]] to "completed". 
*2*set VARstate to "completed". 
*1*if VARstate is "completed", then
*2*if VARcompletion.[[TYPE]] is return, then
*3*set VARgenerator.[[ASYNCGENERATORSTATE]] to "awaiting-return". 
*3*let VARpromisecapability be ! FUNCnewpromisecapability(%promise%). 
*3*perform ! FUNCcall(VARpromisecapability.[[RESOLVE]], undefined, « VARcompletion.[[VALUE]] »). 
*3*let VARstepsfulfilled be the algorithm steps defined in asyncgeneratorresumenext return processor fulfilled functions. 
*3*let VARonfulfilled be FUNCcreatebuiltinfunction(VARstepsfulfilled, « [[GENERATOR]] »). 
*3*set VARonfulfilled.[[GENERATOR]] to VARgenerator. 
*3*let VARstepsrejected be the algorithm steps defined in asyncgeneratorresumenext return processor rejected functions. 
*3*let VARonrejected be FUNCcreatebuiltinfunction(VARstepsrejected, « [[GENERATOR]] »). 
*3*set VARonrejected.[[GENERATOR]] to VARgenerator. 
*3*let VARthrowawaycapability be ! FUNCnewpromisecapability(%promise%). 
*3*set VARthrowawaycapability.[[PROMISE]].[[PROMISEISHANDLED]] to true. 
*3*perform ! FUNCperformpromisethen(VARpromisecapability.[[PROMISE]], VARonfulfilled, VARonrejected, VARthrowawaycapability). 
*3*return undefined. 
*2*else,
*3*assert: VARcompletion.[[TYPE]] is throw. 
*3*perform ! FUNCasyncgeneratorreject(VARgenerator, VARcompletion.[[VALUE]]). 
*3*return undefined. 
*0*else if VARstate is "completed", return ! FUNCasyncgeneratorresolve(VARgenerator, undefined, true). 
*0*assert: VARstate is either "suspendedstart" or "suspendedyield". 
*0*let VARgencontext be VARgenerator.[[ASYNCGENERATORCONTEXT]]. 
*0*let VARcallercontext be the running execution context. 
*0*suspend VARcallercontext. 
*0*set VARgenerator.[[ASYNCGENERATORSTATE]] to "executing". 
*0*push VARgencontext onto the execution context stack; VARgencontext is now the running execution context. 
*0*resume the suspended evaluation of VARgencontext using VARcompletion as the result of the operation that suspended it. let VARresult be the completion record returned by the resumed computation. 
*0*assert: VARresult is never an abrupt completion. 
*0*assert: when we return here, VARgencontext has already been removed from the execution context stack and VARcallercontext is the currently running execution context. 
*0*return undefined.     

############# END ## 673 ###########################
############# BEGIN ## 674 ###########################
ID= 25.5.3.6
Summary= AsyncGeneratorEnqueue ( generator, completion )
Description= None
*0*assert: VARcompletion is a completion record. 
*0*let VARpromisecapability be ! FUNCnewpromisecapability(%promise%). 
*0*if FUNCtype(VARgenerator) is not object, or if VARgenerator does not have an [[ASYNCGENERATORSTATE]] internal slot, then
*1*let VARbadgeneratorerror be a newly created typeerror object. 
*1*perform ! FUNCcall(VARpromisecapability.[[REJECT]], undefined, « VARbadgeneratorerror »). 
*1*return VARpromisecapability.[[PROMISE]]. 
*0*let VARqueue be VARgenerator.[[ASYNCGENERATORQUEUE]]. 
*0*let VARrequest be asyncgeneratorrequest { [[COMPLETION]]: VARcompletion, [[CAPABILITY]]: VARpromisecapability }. 
*0*append VARrequest to the end of VARqueue. 
*0*let VARstate be VARgenerator.[[ASYNCGENERATORSTATE]]. 
*0*if VARstate is not "executing", then
*1*perform ! FUNCasyncgeneratorresumenext(VARgenerator). 
*0*return VARpromisecapability.[[PROMISE]].     

############# END ## 674 ###########################
############# BEGIN ## 675 ###########################
ID= 25.5.3.7
Summary= AsyncGeneratorYield ( value )
Description= The abstract operation AsyncGeneratorYield with argument value performs the following steps:
*0*let VARgencontext be the running execution context. 
*0*assert: VARgencontext is the execution context of a generator. 
*0*let VARgenerator be the value of the generator component of VARgencontext. 
*0*assert: FUNCgetgeneratorkind() is async. 
*0*set VARvalue to ? await(VARvalue). 
*0*set VARgenerator.[[ASYNCGENERATORSTATE]] to "suspendedyield". 
*0*remove VARgencontext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context. 
*0*set the code evaluation state of VARgencontext such that when evaluation is resumed with a completion VARresumptionvalue the following steps will be performed:
*1*if VARresumptionvalue.[[TYPE]] is not return, return FUNCcompletion(VARresumptionvalue). 
*1*let VARawaited be await(VARresumptionvalue.[[VALUE]]). 
*1*if VARawaited.[[TYPE]] is throw, return FUNCcompletion(VARawaited). 
*1*assert: VARawaited.[[TYPE]] is normal. 
*1*return completion { [[TYPE]]: return, [[VALUE]]: VARawaited.[[VALUE]], [[TARGET]]: empty }. 
*1*note: when one of the above steps returns, it returns to the evaluation of the yieldexpression production that originally called this abstract operation. 
*0*return ! FUNCasyncgeneratorresolve(VARgenerator, VARvalue, false). 
*0*note: this returns to the evaluation of the operation that had most previously resumed evaluation of VARgencontext.     

############# END ## 675 ###########################
############# BEGIN ## 676 ###########################
ID= 25.6.1.1.1
Summary= IfAbruptRejectPromise ( value, capability )
Description= IfAbruptRejectPromise is a shorthand for a sequence of algorithm steps that use a PromiseCapability Record. An algorithm step of the form:
*0*FUNCifabruptrejectpromise(VARvalue, VARcapability).      

############# END ## 676 ###########################
############# BEGIN ## 677 ###########################
ID= 25.6.1.3
Summary= CreateResolvingFunctions ( promise )
Description= When CreateResolvingFunctions is performed with argument promise, the following steps are taken:
*0*let VARalreadyresolved be a new record { [[VALUE]]: false }. 
*0*let VARstepsresolve be the algorithm steps defined in promise resolve functions (25.6.1.3.2). 
*0*let VARresolve be FUNCcreatebuiltinfunction(VARstepsresolve, « [[PROMISE]], [[ALREADYRESOLVED]] »). 
*0*set VARresolve.[[PROMISE]] to VARpromise. 
*0*set VARresolve.[[ALREADYRESOLVED]] to VARalreadyresolved. 
*0*let VARstepsreject be the algorithm steps defined in promise reject functions (25.6.1.3.1). 
*0*let VARreject be FUNCcreatebuiltinfunction(VARstepsreject, « [[PROMISE]], [[ALREADYRESOLVED]] »). 
*0*set VARreject.[[PROMISE]] to VARpromise. 
*0*set VARreject.[[ALREADYRESOLVED]] to VARalreadyresolved. 
*0*return a new record { [[RESOLVE]]: VARresolve, [[REJECT]]: VARreject }.     

############# END ## 677 ###########################
############# BEGIN ## 678 ###########################
ID= 25.6.1.4
Summary= FulfillPromise ( promise, value )
Description= When the FulfillPromise abstract operation is called with arguments promise and value, the following steps are taken:
*0*assert: the value of VARpromise.[[PROMISESTATE]] is "pending". 
*0*let VARreactions be VARpromise.[[PROMISEFULFILLREACTIONS]]. 
*0*set VARpromise.[[PROMISERESULT]] to VARvalue. 
*0*set VARpromise.[[PROMISEFULFILLREACTIONS]] to undefined. 
*0*set VARpromise.[[PROMISEREJECTREACTIONS]] to undefined. 
*0*set VARpromise.[[PROMISESTATE]] to "fulfilled". 
*0*return FUNCtriggerpromisereactions(VARreactions, VARvalue).     

############# END ## 678 ###########################
############# BEGIN ## 679 ###########################
ID= 25.6.1.5
Summary= NewPromiseCapability ( C )
Description= The abstract operation NewPromiseCapability takes a constructor function, and attempts to use that constructor function in the fashion of the built-in Promise constructor to create a Promise object and extract its resolve and reject functions. The promise plus the resolve and reject functions are used to initialize a new PromiseCapability Record which is returned as the value of this abstract operation.
*0*if FUNCisconstructor(VARc) is false, throw a typeerror exception. 
*0*note: VARc is assumed to be a constructor function that supports the parameter conventions of the promise constructor (see 25.6.3.1). 
*0*let VARpromisecapability be a new promisecapability { [[PROMISE]]: undefined, [[RESOLVE]]: undefined, [[REJECT]]: undefined }. 
*0*let VARsteps be the algorithm steps defined in getcapabilitiesexecutor functions. 
*0*let VARexecutor be FUNCcreatebuiltinfunction(VARsteps, « [[CAPABILITY]] »). 
*0*set VARexecutor.[[CAPABILITY]] to VARpromisecapability. 
*0*let VARpromise be ? FUNCconstruct(VARc, « VARexecutor »). 
*0*if FUNCiscallable(VARpromisecapability.[[RESOLVE]]) is false, throw a typeerror exception. 
*0*if FUNCiscallable(VARpromisecapability.[[REJECT]]) is false, throw a typeerror exception. 
*0*set VARpromisecapability.[[PROMISE]] to VARpromise. 
*0*return VARpromisecapability.     

############# END ## 679 ###########################
############# BEGIN ## 680 ###########################
ID= 25.6.1.6
Summary= IsPromise ( x )
Description= The abstract operation IsPromise checks for the promise brand on an object.
*0*if FUNCtype(VARx) is not object, return false. 
*0*if VARx does not have a [[PROMISESTATE]] internal slot, return false. 
*0*return true.     

############# END ## 680 ###########################
############# BEGIN ## 681 ###########################
ID= 25.6.1.7
Summary= RejectPromise ( promise, reason )
Description= When the RejectPromise abstract operation is called with arguments promise and reason, the following steps are taken:
*0*assert: the value of VARpromise.[[PROMISESTATE]] is "pending". 
*0*let VARreactions be VARpromise.[[PROMISEREJECTREACTIONS]]. 
*0*set VARpromise.[[PROMISERESULT]] to VARreason. 
*0*set VARpromise.[[PROMISEFULFILLREACTIONS]] to undefined. 
*0*set VARpromise.[[PROMISEREJECTREACTIONS]] to undefined. 
*0*set VARpromise.[[PROMISESTATE]] to "rejected". 
*0*if VARpromise.[[PROMISEISHANDLED]] is false, perform FUNChostpromiserejectiontracker(VARpromise, "reject"). 
*0*return FUNCtriggerpromisereactions(VARreactions, VARreason).     

############# END ## 681 ###########################
############# BEGIN ## 682 ###########################
ID= 25.6.1.8
Summary= TriggerPromiseReactions ( reactions, argument )
Description= The abstract operation TriggerPromiseReactions takes a collection of PromiseReactionRecords and enqueues a new Job for each record. Each such Job processes the [[Type]] and [[Handler]] of the PromiseReactionRecord, and if the [[Handler]] is a function, calls it passing the given argument. If the [[Handler]] is undefined, the behaviour is determined by the [[Type]].
*0*for each VARreaction in VARreactions, in original insertion order, do
*1*perform FUNCenqueuejob("promisejobs", promisereactionjob, « VARreaction, VARargument »). 
*0*return undefined.     

############# END ## 682 ###########################
############# BEGIN ## 683 ###########################
ID= 25.6.2.1
Summary= PromiseReactionJob ( reaction, argument )
Description= The job PromiseReactionJob with parameters reaction and argument applies the appropriate handler to the incoming value, and uses the handler's return value to resolve or reject the derived promise associated with that handler.
*0*assert: VARreaction is a promisereaction record. 
*0*let VARpromisecapability be VARreaction.[[CAPABILITY]]. 
*0*let VARtype be VARreaction.[[TYPE]]. 
*0*let VARhandler be VARreaction.[[HANDLER]]. 
*0*if VARhandler is undefined, then
*1*if VARtype is "fulfill", let VARhandlerresult be FUNCnormalcompletion(VARargument). 
*1*else,
*2*assert: VARtype is "reject". 
*2*let VARhandlerresult be FUNCthrowcompletion(VARargument). 
*0*else, let VARhandlerresult be FUNCcall(VARhandler, undefined, « VARargument »). 
*0*if VARhandlerresult is an abrupt completion, then
*1*let VARstatus be FUNCcall(VARpromisecapability.[[REJECT]], undefined, « VARhandlerresult.[[VALUE]] »). 
*0*else,
*1*let VARstatus be FUNCcall(VARpromisecapability.[[RESOLVE]], undefined, « VARhandlerresult.[[VALUE]] »). 
*0*return FUNCcompletion(VARstatus).     

############# END ## 683 ###########################
############# BEGIN ## 684 ###########################
ID= 25.6.2.2
Summary= PromiseResolveThenableJob ( promiseToResolve, thenable, then )
Description= The job PromiseResolveThenableJob with parameters promiseToResolve, thenable, and then performs the following steps:
*0*let VARresolvingfunctions be FUNCcreateresolvingfunctions(VARpromisetoresolve). 
*0*let VARthencallresult be FUNCcall(VARthen, VARthenable, « VARresolvingfunctions.[[RESOLVE]], VARresolvingfunctions.[[REJECT]] »). 
*0*if VARthencallresult is an abrupt completion, then
*1*let VARstatus be FUNCcall(VARresolvingfunctions.[[REJECT]], undefined, « VARthencallresult.[[VALUE]] »). 
*1*return FUNCcompletion(VARstatus). 
*0*return FUNCcompletion(VARthencallresult).     

############# END ## 684 ###########################
############# BEGIN ## 685 ###########################
ID= 25.6.3.1
Summary= Promise ( executor )
Description= When the Promise function is called with argument executor, the following steps are taken:
*0*if newtarget is undefined, throw a typeerror exception. 
*0*if FUNCiscallable(VARexecutor) is false, throw a typeerror exception. 
*0*let VARpromise be ? FUNCordinarycreatefromconstructor(newtarget, "%promiseprototype%", « [[PROMISESTATE]], [[PROMISERESULT]], [[PROMISEFULFILLREACTIONS]], [[PROMISEREJECTREACTIONS]], [[PROMISEISHANDLED]] »). 
*0*set VARpromise.[[PROMISESTATE]] to "pending". 
*0*set VARpromise.[[PROMISEFULFILLREACTIONS]] to a new empty list. 
*0*set VARpromise.[[PROMISEREJECTREACTIONS]] to a new empty list. 
*0*set VARpromise.[[PROMISEISHANDLED]] to false. 
*0*let VARresolvingfunctions be FUNCcreateresolvingfunctions(VARpromise). 
*0*let VARcompletion be FUNCcall(VARexecutor, undefined, « VARresolvingfunctions.[[RESOLVE]], VARresolvingfunctions.[[REJECT]] »). 
*0*if VARcompletion is an abrupt completion, then
*1*perform ? FUNCcall(VARresolvingfunctions.[[REJECT]], undefined, « VARcompletion.[[VALUE]] »). 
*0*return VARpromise.     

############# END ## 685 ###########################
############# BEGIN ## 686 ###########################
ID= 25.6.4.1
Summary= Promise.all ( iterable )
Description= The all function returns a new promise which is fulfilled with an array of fulfillment values for the passed promises, or rejects with the reason of the first passed promise that rejects. It resolves all elements of the passed iterable to promises as it runs this algorithm.
*0*let VARc be the this value. 
*0*if FUNCtype(VARc) is not object, throw a typeerror exception. 
*0*let VARpromisecapability be ? FUNCnewpromisecapability(VARc). 
*0*let VARiteratorrecord be FUNCgetiterator(VARiterable). 
*0*FUNCifabruptrejectpromise(VARiteratorrecord, VARpromisecapability). 
*0*let VARresult be FUNCperformpromiseall(VARiteratorrecord, VARc, VARpromisecapability). 
*0*if VARresult is an abrupt completion, then
*1*if VARiteratorrecord.[[DONE]] is false, let VARresult be FUNCiteratorclose(VARiteratorrecord, VARresult). 
*1*FUNCifabruptrejectpromise(VARresult, VARpromisecapability). 
*0*return FUNCcompletion(VARresult).     

############# END ## 686 ###########################
############# BEGIN ## 687 ###########################
ID= 25.6.4.1.1
Summary= Runtime Semantics: PerformPromiseAll ( iteratorRecord, constructor, resultCapability )
Description= When the PerformPromiseAll abstract operation is called with arguments iteratorRecord, constructor, and resultCapability, the following steps are taken:
*0*assert: VARconstructor is a constructor function. 
*0*assert: VARresultcapability is a promisecapability record. 
*0*let VARvalues be a new empty list. 
*0*let VARremainingelementscount be a new record { [[VALUE]]: 1 }. 
*0*let VARindex be 0. 
*0*repeat,
*1*let VARnext be FUNCiteratorstep(VARiteratorrecord). 
*1*if VARnext is an abrupt completion, set VARiteratorrecord.[[DONE]] to true. 
*1*FUNCreturnifabrupt(VARnext). 
*1*if VARnext is false, then
*2*set VARiteratorrecord.[[DONE]] to true. 
*2*set VARremainingelementscount.[[VALUE]] to VARremainingelementscount.[[VALUE]] - 1. 
*2*if VARremainingelementscount.[[VALUE]] is 0, then
*3*let VARvaluesarray be FUNCcreatearrayfromlist(VARvalues). 
*3*perform ? FUNCcall(VARresultcapability.[[RESOLVE]], undefined, « VARvaluesarray »). 
*2*return VARresultcapability.[[PROMISE]]. 
*1*let VARnextvalue be FUNCiteratorvalue(VARnext). 
*1*if VARnextvalue is an abrupt completion, set VARiteratorrecord.[[DONE]] to true. 
*1*FUNCreturnifabrupt(VARnextvalue). 
*1*append undefined to VARvalues. 
*1*let VARnextpromise be ? FUNCinvoke(VARconstructor, "resolve", « VARnextvalue »). 
*1*let VARsteps be the algorithm steps defined in promise.all resolve element functions. 
*1*let VARresolveelement be FUNCcreatebuiltinfunction(VARsteps, « [[ALREADYCALLED]], [[INDEX]], [[VALUES]], [[CAPABILITY]], [[REMAININGELEMENTS]] »). 
*1*set VARresolveelement.[[ALREADYCALLED]] to a new record { [[VALUE]]: false }. 
*1*set VARresolveelement.[[INDEX]] to VARindex. 
*1*set VARresolveelement.[[VALUES]] to VARvalues. 
*1*set VARresolveelement.[[CAPABILITY]] to VARresultcapability. 
*1*set VARresolveelement.[[REMAININGELEMENTS]] to VARremainingelementscount. 
*1*set VARremainingelementscount.[[VALUE]] to VARremainingelementscount.[[VALUE]] + 1. 
*1*perform ? FUNCinvoke(VARnextpromise, "then", « VARresolveelement, VARresultcapability.[[REJECT]] »). 
*1*set VARindex to VARindex + 1.      

############# END ## 687 ###########################
############# BEGIN ## 688 ###########################
ID= 25.6.4.3
Summary= Promise.race ( iterable )
Description= The race function returns a new promise which is settled in the same way as the first passed promise to settle. It resolves all elements of the passed iterable to promises as it runs this algorithm.
*0*let VARc be the this value. 
*0*if FUNCtype(VARc) is not object, throw a typeerror exception. 
*0*let VARpromisecapability be ? FUNCnewpromisecapability(VARc). 
*0*let VARiteratorrecord be FUNCgetiterator(VARiterable). 
*0*FUNCifabruptrejectpromise(VARiteratorrecord, VARpromisecapability). 
*0*let VARresult be FUNCperformpromiserace(VARiteratorrecord, VARc, VARpromisecapability). 
*0*if VARresult is an abrupt completion, then
*1*if VARiteratorrecord.[[DONE]] is false, let VARresult be FUNCiteratorclose(VARiterator, VARresult). 
*1*FUNCifabruptrejectpromise(VARresult, VARpromisecapability). 
*0*return FUNCcompletion(VARresult).     

############# END ## 688 ###########################
############# BEGIN ## 689 ###########################
ID= 25.6.4.3.1
Summary= Runtime Semantics: PerformPromiseRace ( iteratorRecord, constructor, resultCapability )
Description= When the PerformPromiseRace abstract operation is called with arguments iteratorRecord, constructor, and resultCapability, the following steps are taken:
*0*assert: VARconstructor is a constructor function. 
*0*assert: VARresultcapability is a promisecapability record. 
*0*repeat,
*1*let VARnext be FUNCiteratorstep(VARiteratorrecord). 
*1*if VARnext is an abrupt completion, set VARiteratorrecord.[[DONE]] to true. 
*1*FUNCreturnifabrupt(VARnext). 
*1*if VARnext is false, then
*2*set VARiteratorrecord.[[DONE]] to true. 
*2*return VARresultcapability.[[PROMISE]]. 
*1*let VARnextvalue be FUNCiteratorvalue(VARnext). 
*1*if VARnextvalue is an abrupt completion, set VARiteratorrecord.[[DONE]] to true. 
*1*FUNCreturnifabrupt(VARnextvalue). 
*1*let VARnextpromise be ? FUNCinvoke(VARconstructor, "resolve", « VARnextvalue »). 
*1*perform ? FUNCinvoke(VARnextpromise, "then", « VARresultcapability.[[RESOLVE]], VARresultcapability.[[REJECT]] »).      

############# END ## 689 ###########################
############# BEGIN ## 690 ###########################
ID= 25.6.4.4
Summary= Promise.reject ( r )
Description= The reject function returns a new promise rejected with the passed argument.
*0*let VARc be the this value. 
*0*if FUNCtype(VARc) is not object, throw a typeerror exception. 
*0*let VARpromisecapability be ? FUNCnewpromisecapability(VARc). 
*0*perform ? FUNCcall(VARpromisecapability.[[REJECT]], undefined, « VARr »). 
*0*return VARpromisecapability.[[PROMISE]].     

############# END ## 690 ###########################
############# BEGIN ## 691 ###########################
ID= 25.6.4.5
Summary= Promise.resolve ( x )
Description= The resolve function returns either a new promise resolved with the passed argument, or the argument itself if the argument is a promise produced by this constructor.
*0*let VARc be the this value. 
*0*if FUNCtype(VARc) is not object, throw a typeerror exception. 
*0*return ? FUNCpromiseresolve(VARc, VARx).     

############# END ## 691 ###########################
############# BEGIN ## 692 ###########################
ID= 25.6.4.5.1
Summary= PromiseResolve ( C, x )
Description= The abstract operation PromiseResolve, given a constructor and a value, returns a new promise resolved with that value.
*0*assert: FUNCtype(VARc) is object. 
*0*if FUNCispromise(VARx) is true, then
*1*let VARxconstructor be ? FUNCget(VARx, "constructor"). 
*1*if FUNCsamevalue(VARxconstructor, VARc) is true, return VARx. 
*0*let VARpromisecapability be ? FUNCnewpromisecapability(VARc). 
*0*perform ? FUNCcall(VARpromisecapability.[[RESOLVE]], undefined, « VARx »). 
*0*return VARpromisecapability.[[PROMISE]].      

############# END ## 692 ###########################
############# BEGIN ## 693 ###########################
ID= 25.6.5.1
Summary= Promise.prototype.catch ( onRejected )
Description= When the catch method is called with argument onRejected, the following steps are taken:
*0*let VARpromise be the this value. 
*0*return ? FUNCinvoke(VARpromise, "then", « undefined, VARonrejected »).     

############# END ## 693 ###########################
############# BEGIN ## 694 ###########################
ID= 25.6.5.3
Summary= Promise.prototype.finally ( onFinally )
Description= When the finally method is called with argument onFinally, the following steps are taken:
*0*let VARpromise be the this value. 
*0*if FUNCtype(VARpromise) is not object, throw a typeerror exception. 
*0*let VARc be ? FUNCspeciesconstructor(VARpromise, %promise%). 
*0*assert: FUNCisconstructor(VARc) is true. 
*0*if FUNCiscallable(VARonfinally) is false, then
*1*let VARthenfinally be VARonfinally. 
*1*let VARcatchfinally be VARonfinally. 
*0*else,
*1*let VARstepsthenfinally be the algorithm steps defined in then finally functions. 
*1*let VARthenfinally be FUNCcreatebuiltinfunction(VARstepsthenfinally, « [[CONSTRUCTOR]], [[ONFINALLY]] »). 
*1*set VARthenfinally.[[CONSTRUCTOR]] to VARc. 
*1*set VARthenfinally.[[ONFINALLY]] to VARonfinally. 
*1*let VARstepscatchfinally be the algorithm steps defined in catch finally functions. 
*1*let VARcatchfinally be FUNCcreatebuiltinfunction(VARstepscatchfinally, « [[CONSTRUCTOR]], [[ONFINALLY]] »). 
*1*set VARcatchfinally.[[CONSTRUCTOR]] to VARc. 
*1*set VARcatchfinally.[[ONFINALLY]] to VARonfinally. 
*0*return ? FUNCinvoke(VARpromise, "then", « VARthenfinally, VARcatchfinally »).     

############# END ## 694 ###########################
############# BEGIN ## 695 ###########################
ID= 25.6.5.4
Summary= Promise.prototype.then ( onFulfilled, onRejected )
Description= When the then method is called with arguments onFulfilled and onRejected, the following steps are taken:
*0*let VARpromise be the this value. 
*0*if FUNCispromise(VARpromise) is false, throw a typeerror exception. 
*0*let VARc be ? FUNCspeciesconstructor(VARpromise, %promise%). 
*0*let VARresultcapability be ? FUNCnewpromisecapability(VARc). 
*0*return FUNCperformpromisethen(VARpromise, VARonfulfilled, VARonrejected, VARresultcapability).     

############# END ## 695 ###########################
############# BEGIN ## 696 ###########################
ID= 25.6.5.4.1
Summary= PerformPromiseThen ( promise, onFulfilled, onRejected, resultCapability )
Description= The abstract operation PerformPromiseThen performs the “then” operation on promise using onFulfilled and onRejected as its settlement actions. The result is resultCapability's promise.
*0*assert: FUNCispromise(VARpromise) is true. 
*0*assert: VARresultcapability is a promisecapability record. 
*0*if FUNCiscallable(VARonfulfilled) is false, then
*1*set VARonfulfilled to undefined. 
*0*if FUNCiscallable(VARonrejected) is false, then
*1*set VARonrejected to undefined. 
*0*let VARfulfillreaction be the promisereaction { [[CAPABILITY]]: VARresultcapability, [[TYPE]]: "fulfill", [[HANDLER]]: VARonfulfilled }. 
*0*let VARrejectreaction be the promisereaction { [[CAPABILITY]]: VARresultcapability, [[TYPE]]: "reject", [[HANDLER]]: VARonrejected }. 
*0*if VARpromise.[[PROMISESTATE]] is "pending", then
*1*append VARfulfillreaction as the last element of the list that is VARpromise.[[PROMISEFULFILLREACTIONS]]. 
*1*append VARrejectreaction as the last element of the list that is VARpromise.[[PROMISEREJECTREACTIONS]]. 
*0*else if VARpromise.[[PROMISESTATE]] is "fulfilled", then
*1*let VARvalue be VARpromise.[[PROMISERESULT]]. 
*1*perform FUNCenqueuejob("promisejobs", promisereactionjob, « VARfulfillreaction, VARvalue »). 
*0*else,
*1*assert: the value of VARpromise.[[PROMISESTATE]] is "rejected". 
*1*let VARreason be VARpromise.[[PROMISERESULT]]. 
*1*if VARpromise.[[PROMISEISHANDLED]] is false, perform FUNChostpromiserejectiontracker(VARpromise, "handle"). 
*1*perform FUNCenqueuejob("promisejobs", promisereactionjob, « VARrejectreaction, VARreason »). 
*0*set VARpromise.[[PROMISEISHANDLED]] to true. 
*0*return VARresultcapability.[[PROMISE]].      

############# END ## 696 ###########################
############# BEGIN ## 697 ###########################
ID= 25.7.1.1
Summary= AsyncFunction ( p1, p2, … , pn, body )
Description= The last argument specifies the body (executable code) of an async function. Any preceding arguments specify formal parameters.
*0*let VARc be the active function object. 
*0*let VARargs be the VARargumentslist that was passed to this function by [[CALL]] or [[CONSTRUCT]]. 
*0*return FUNCcreatedynamicfunction(VARc, newtarget, "async", VARargs).     

############# END ## 697 ###########################
############# BEGIN ## 698 ###########################
ID= 25.7.5.1
Summary= AsyncFunctionStart ( promiseCapability, asyncFunctionBody )
Description= None
*0*let VARrunningcontext be the running execution context. 
*0*let VARasynccontext be a copy of VARrunningcontext. 
*0*set the code evaluation state of VARasynccontext such that when evaluation is resumed for that execution context the following steps will be performed:
*1*let VARresult be the result of evaluating VARasyncfunctionbody. 
*1*assert: if we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done. 
*1*remove VARasynccontext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context. 
*1*if VARresult.[[TYPE]] is normal, then
*2*perform ! FUNCcall(VARpromisecapability.[[RESOLVE]], undefined, « undefined »). 
*1*else if VARresult.[[TYPE]] is return, then
*2*perform ! FUNCcall(VARpromisecapability.[[RESOLVE]], undefined, « VARresult.[[VALUE]] »). 
*1*else,
*2*assert: VARresult.[[TYPE]] is throw. 
*2*perform ! FUNCcall(VARpromisecapability.[[REJECT]], undefined, « VARresult.[[VALUE]] »). 
*1*return. 
*0*push VARasynccontext onto the execution context stack; VARasynccontext is now the running execution context. 
*0*resume the suspended evaluation of VARasynccontext. let VARresult be the value returned by the resumed computation. 
*0*assert: when we return here, VARasynccontext has already been removed from the execution context stack and VARrunningcontext is the currently running execution context. 
*0*assert: VARresult is a normal completion with a value of undefined. the possible sources of completion values are await or, if the async function doesn't await anything, the step 3.g above. 
*0*return.     

############# END ## 698 ###########################
############# BEGIN ## 699 ###########################
ID= 26.1.1
Summary= Reflect.apply ( target, thisArgument, argumentsList )
Description= When the apply function is called with arguments target, thisArgument, and argumentsList, the following steps are taken:
*0*if FUNCiscallable(VARtarget) is false, throw a typeerror exception. 
*0*let VARargs be ? FUNCcreatelistfromarraylike(VARargumentslist). 
*0*perform FUNCpreparefortailcall(). 
*0*return ? FUNCcall(VARtarget, VARthisargument, VARargs).    

############# END ## 699 ###########################
############# BEGIN ## 700 ###########################
ID= 26.1.2
Summary= Reflect.construct ( target, argumentsList [ , newTarget ] )
Description= When the construct function is called with arguments target, argumentsList, and newTarget, the following steps are taken:
*0*if FUNCisconstructor(VARtarget) is false, throw a typeerror exception. 
*0*if VARnewtarget is not present, let VARnewtarget be VARtarget. 
*0*else if FUNCisconstructor(VARnewtarget) is false, throw a typeerror exception. 
*0*let VARargs be ? FUNCcreatelistfromarraylike(VARargumentslist). 
*0*return ? FUNCconstruct(VARtarget, VARargs, VARnewtarget).    

############# END ## 700 ###########################
############# BEGIN ## 701 ###########################
ID= 26.1.3
Summary= Reflect.defineProperty ( target, propertyKey, attributes )
Description= When the defineProperty function is called with arguments target, propertyKey, and attributes, the following steps are taken:
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*let VARkey be ? FUNCtopropertykey(VARpropertykey). 
*0*let VARdesc be ? FUNCtopropertydescriptor(VARattributes). 
*0*return ? VARtarget.[[DEFINEOWNPROPERTY]](VARkey, VARdesc).    

############# END ## 701 ###########################
############# BEGIN ## 702 ###########################
ID= 26.1.4
Summary= Reflect.deleteProperty ( target, propertyKey )
Description= When the deleteProperty function is called with arguments target and propertyKey, the following steps are taken:
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*let VARkey be ? FUNCtopropertykey(VARpropertykey). 
*0*return ? VARtarget.[[DELETE]](VARkey).    

############# END ## 702 ###########################
############# BEGIN ## 703 ###########################
ID= 26.1.5
Summary= Reflect.get ( target, propertyKey [ , receiver ] )
Description= When the get function is called with arguments target, propertyKey, and receiver, the following steps are taken:
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*let VARkey be ? FUNCtopropertykey(VARpropertykey). 
*0*if VARreceiver is not present, then
*1*let VARreceiver be VARtarget. 
*0*return ? VARtarget.[[GET]](VARkey, VARreceiver).    

############# END ## 703 ###########################
############# BEGIN ## 704 ###########################
ID= 26.1.6
Summary= Reflect.getOwnPropertyDescriptor ( target, propertyKey )
Description= When the getOwnPropertyDescriptor function is called with arguments target and propertyKey, the following steps are taken:
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*let VARkey be ? FUNCtopropertykey(VARpropertykey). 
*0*let VARdesc be ? VARtarget.[[GETOWNPROPERTY]](VARkey). 
*0*return FUNCfrompropertydescriptor(VARdesc).    

############# END ## 704 ###########################
############# BEGIN ## 705 ###########################
ID= 26.1.7
Summary= Reflect.getPrototypeOf ( target )
Description= When the getPrototypeOf function is called with argument target, the following steps are taken:
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*return ? VARtarget.[[GETPROTOTYPEOF]]().    

############# END ## 705 ###########################
############# BEGIN ## 706 ###########################
ID= 26.1.8
Summary= Reflect.has ( target, propertyKey )
Description= When the has function is called with arguments target and propertyKey, the following steps are taken:
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*let VARkey be ? FUNCtopropertykey(VARpropertykey). 
*0*return ? VARtarget.[[HASPROPERTY]](VARkey).    

############# END ## 706 ###########################
############# BEGIN ## 707 ###########################
ID= 26.1.9
Summary= Reflect.isExtensible ( target )
Description= When the isExtensible function is called with argument target, the following steps are taken:
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*return ? VARtarget.[[ISEXTENSIBLE]]().    

############# END ## 707 ###########################
############# BEGIN ## 708 ###########################
ID= 26.1.10
Summary= Reflect.ownKeys ( target )
Description= When the ownKeys function is called with argument target, the following steps are taken:
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*let VARkeys be ? VARtarget.[[OWNPROPERTYKEYS]](). 
*0*return FUNCcreatearrayfromlist(VARkeys).    

############# END ## 708 ###########################
############# BEGIN ## 709 ###########################
ID= 26.1.11
Summary= Reflect.preventExtensions ( target )
Description= When the preventExtensions function is called with argument target, the following steps are taken:
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*return ? VARtarget.[[PREVENTEXTENSIONS]]().    

############# END ## 709 ###########################
############# BEGIN ## 710 ###########################
ID= 26.1.12
Summary= Reflect.set ( target, propertyKey, V [ , receiver ] )
Description= When the set function is called with arguments target, V, propertyKey, and receiver, the following steps are taken:
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*let VARkey be ? FUNCtopropertykey(VARpropertykey). 
*0*if VARreceiver is not present, then
*1*let VARreceiver be VARtarget. 
*0*return ? VARtarget.[[SET]](VARkey, VARv, VARreceiver).    

############# END ## 710 ###########################
############# BEGIN ## 711 ###########################
ID= 26.1.13
Summary= Reflect.setPrototypeOf ( target, proto )
Description= When the setPrototypeOf function is called with arguments target and proto, the following steps are taken:
*0*if FUNCtype(VARtarget) is not object, throw a typeerror exception. 
*0*if FUNCtype(VARproto) is not object and VARproto is not null, throw a typeerror exception. 
*0*return ? VARtarget.[[SETPROTOTYPEOF]](VARproto).    

############# END ## 711 ###########################
############# BEGIN ## 712 ###########################
ID= 26.2.1.1
Summary= Proxy ( target, handler )
Description= When Proxy is called with arguments target and handler performs the following steps:
*0*if newtarget is undefined, throw a typeerror exception. 
*0*return ? FUNCproxycreate(VARtarget, VARhandler).     

############# END ## 712 ###########################
############# BEGIN ## 713 ###########################
ID= 26.2.2.1
Summary= Proxy.revocable ( target, handler )
Description= The Proxy.revocable function is used to create a revocable Proxy object. When Proxy.revocable is called with arguments target and handler, the following steps are taken:
*0*let VARp be ? FUNCproxycreate(VARtarget, VARhandler). 
*0*let VARsteps be the algorithm steps defined in proxy revocation functions. 
*0*let VARrevoker be FUNCcreatebuiltinfunction(VARsteps, « [[REVOCABLEPROXY]] »). 
*0*set VARrevoker.[[REVOCABLEPROXY]] to VARp. 
*0*let VARresult be FUNCobjectcreate(%objectprototype%). 
*0*perform FUNCcreatedataproperty(VARresult, "proxy", VARp). 
*0*perform FUNCcreatedataproperty(VARresult, "revoke", VARrevoker). 
*0*return VARresult.     

############# END ## 713 ###########################
############# BEGIN ## 714 ###########################
ID= 27.5.1
Summary= EventSet ( execution )
Description= The abstract operation EventSet takes one argument, a candidate execution execution. It performs the following steps:
*0*let VARevents be an empty set. 
*0*for each agent events record VARaer in VARexecution.[[EVENTLISTS]], do
*1*for each event VARe in VARaer.[[EVENTLIST]], do
*2*add VARe to VARevents. 
*0*return VARevents.    

############# END ## 714 ###########################
############# BEGIN ## 715 ###########################
ID= 27.5.2
Summary= SharedDataBlockEventSet ( execution )
Description= The abstract operation SharedDataBlockEventSet takes one argument, a candidate execution execution. It performs the following steps:
*0*let VARevents be an empty set. 
*0*for each event VARe in FUNCeventset(VARexecution), do
*1*if VARe is a readsharedmemory, writesharedmemory, or readmodifywritesharedmemory event, add VARe to VARevents. 
*0*return VARevents.    

############# END ## 715 ###########################
############# BEGIN ## 716 ###########################
ID= 27.5.3
Summary= HostEventSet ( execution )
Description= The abstract operation HostEventSet takes one argument, a candidate execution execution. It performs the following steps:
*0*let VARevents be an empty set. 
*0*for each event VARe in FUNCeventset(VARexecution), do
*1*if VARe is not in FUNCshareddatablockeventset(VARexecution), add VARe to VARevents. 
*0*return VARevents.    

############# END ## 716 ###########################
############# BEGIN ## 717 ###########################
ID= 27.5.4
Summary= ComposeWriteEventBytes ( execution, byteIndex, Ws )
Description= The abstract operation ComposeWriteEventBytes takes four arguments, a candidate execution execution, a nonnegative integer byteIndex, and a List Ws of WriteSharedMemory or ReadModifyWriteSharedMemory events. It performs the following steps:
*0*let VARbytelocation be VARbyteindex. 
*0*let VARbytesread be a new empty list. 
*0*for each element VARw of VARws in list order, do
*1*assert: VARw has VARbytelocation in its range. 
*1*let VARpayloadindex be VARbytelocation - VARw.[[BYTEINDEX]]. 
*1*if VARw is a writesharedmemory event, then
*2*let VARbyte be VARw.[[PAYLOAD]][VARpayloadindex]. 
*1*else,
*2*assert: VARw is a readmodifywritesharedmemory event. 
*2*let VARbytes be FUNCvalueofreadevent(VARexecution, VARw). 
*2*let VARbytesmodified be VARw.[[MODIFYOP]](VARbytes, VARw.[[PAYLOAD]]). 
*2*let VARbyte be VARbytesmodified[VARpayloadindex]. 
*1*append VARbyte to VARbytesread. 
*1*increment VARbytelocation by 1. 
*0*return VARbytesread.    

############# END ## 717 ###########################
############# BEGIN ## 718 ###########################
ID= 27.5.5
Summary= ValueOfReadEvent ( execution, R )
Description= The abstract operation ValueOfReadEvent takes two arguments, a candidate execution execution and a ReadSharedMemory or ReadModifyWriteSharedMemory event R. It performs the following steps:
*0*assert: VARr is a readsharedmemory or readmodifywritesharedmemory event. 
*0*let VARws be VARexecution.[[READSBYTESFROM]](VARr). 
*0*assert: VARws is a list of writesharedmemory or readmodifywritesharedmemory events with length equal to VARr.[[ELEMENTSIZE]]. 
*0*return FUNCcomposewriteeventbytes(VARexecution, VARr.[[BYTEINDEX]], VARws).    

############# END ## 718 ###########################
